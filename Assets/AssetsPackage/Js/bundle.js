/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/GameMain.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/inkjs/dist/ink-es2015.js":
/*!***********************************************!*\
  !*** ./node_modules/inkjs/dist/ink-es2015.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{constructor(){if(this._components=[],this._componentsString=null,this._isRelative=!1,"string"==typeof arguments[0]){let t=arguments[0];this.componentsString=t}else if(arguments[0]instanceof e.Component&&arguments[1]instanceof e){let t=arguments[0],e=arguments[1];this._components.push(t),this._components=this._components.concat(e._components)}else if(arguments[0]instanceof Array){let t=arguments[0],e=!!arguments[1];this._components=this._components.concat(t),this._isRelative=e}}get isRelative(){return this._isRelative}get componentCount(){return this._components.length}get head(){return this._components.length>0?this._components[0]:null}get tail(){if(this._components.length>=2){let t=this._components.slice(1,this._components.length);return new e(t)}return e.self}get length(){return this._components.length}get lastComponent(){let t=this._components.length-1;return t>=0?this._components[t]:null}get containsNamedComponent(){for(let t=0,e=this._components.length;t<e;t++)if(!this._components[t].isIndex)return!0;return!1}static get self(){let t=new e;return t._isRelative=!0,t}GetComponent(t){return this._components[t]}PathByAppendingPath(t){let n=new e,i=0;for(let e=0;e<t._components.length&&t._components[e].isParent;++e)i++;for(let t=0;t<this._components.length-i;++t)n._components.push(this._components[t]);for(let e=i;e<t._components.length;++e)n._components.push(t._components[e]);return n}get componentsString(){return null==this._componentsString&&(this._componentsString=this._components.join("."),this.isRelative&&(this._componentsString="."+this._componentsString)),this._componentsString}set componentsString(t){if(this._components.length=0,this._componentsString=t,null==this._componentsString||""==this._componentsString)return;"."==this._componentsString[0]&&(this._isRelative=!0,this._componentsString=this._componentsString.substring(1));let n=this._componentsString.split(".");for(let t of n)/^(\-|\+)?([0-9]+|Infinity)$/.test(t)?this._components.push(new e.Component(parseInt(t))):this._components.push(new e.Component(t))}toString(){return this.componentsString}Equals(t){if(null==t)return!1;if(t._components.length!=this._components.length)return!1;if(t.isRelative!=this.isRelative)return!1;for(let e=0,n=t._components.length;e<n;e++)if(!t._components[e].Equals(this._components[e]))return!1;return!0}PathByAppendingComponent(t){let n=new e;return n._components.push.apply(n._components,this._components),n._components.push(t),n}}var n,i,r;function a(t,e){return t instanceof e?h(t):null}function s(t,e){if(t instanceof e)return h(t);throw new Error(`${t} is not of type ${e}`)}function l(t){return t.hasValidName&&t.name?t:null}function o(t){return void 0===t?null:t}function u(t){return"object"==typeof t&&"function"==typeof t.Equals}function h(t,e){return t}e.parentId="^",function(t){class e{constructor(t){this.index=-1,this.name=null,"string"==typeof t?this.name=t:this.index=t}get isIndex(){return this.index>=0}get isParent(){return this.name==t.parentId}static ToParent(){return new e(t.parentId)}toString(){return this.isIndex?this.index.toString():this.name}Equals(t){return null!=t&&t.isIndex==this.isIndex&&(this.isIndex?this.index==t.index:this.name==t.name)}}t.Component=e}(e||(e={})),function(t){function e(t,e){if(!t)throw void 0!==e&&console.warn(e),console.trace&&console.trace(),new Error("")}t.AssertType=function(t,n,i){e(t instanceof n,i)},t.Assert=e}(n||(n={}));class c extends Error{}function d(t){throw new c(t+" is null or undefined")}class p{constructor(){this.parent=null,this._debugMetadata=null,this._path=null}get debugMetadata(){return null===this._debugMetadata&&this.parent?this.parent.debugMetadata:this._debugMetadata}set debugMetadata(t){this._debugMetadata=t}get ownDebugMetadata(){return this._debugMetadata}DebugLineNumberOfPath(t){if(null===t)return null;let e=this.rootContentContainer;if(e){let n=e.ContentAtPath(t).obj;if(n){let t=n.debugMetadata;if(null!==t)return t.startLineNumber}}return null}get path(){if(null==this._path)if(null==this.parent)this._path=new e;else{let t=[],n=this,i=a(n.parent,N);for(;null!==i;){let r=l(n);null!=r&&r.hasValidName?t.unshift(new e.Component(r.name)):t.unshift(new e.Component(i.content.indexOf(n))),n=i,i=a(i.parent,N)}this._path=new e(t)}return this._path}ResolvePath(t){if(null===t)return d("path");if(t.isRelative){let e=a(this,N);return null===e&&(n.Assert(null!==this.parent,"Can't resolve relative path because we don't have a parent"),e=a(this.parent,N),n.Assert(null!==e,"Expected parent to be a container"),n.Assert(t.GetComponent(0).isParent),t=t.tail),null===e?d("nearestContainer"):e.ContentAtPath(t)}{let e=this.rootContentContainer;return null===e?d("contentContainer"):e.ContentAtPath(t)}}ConvertPathToRelative(t){let n=this.path,i=Math.min(t.length,n.length),r=-1;for(let e=0;e<i;++e){let i=n.GetComponent(e),a=t.GetComponent(e);if(!i.Equals(a))break;r=e}if(-1==r)return t;let a=n.componentCount-1-r,s=[];for(let t=0;t<a;++t)s.push(e.Component.ToParent());for(let e=r+1;e<t.componentCount;++e)s.push(t.GetComponent(e));return new e(s,!0)}CompactPathString(t){let e=null,n=null;if(t.isRelative)n=t.componentsString,e=this.path.PathByAppendingPath(t).componentsString;else{n=this.ConvertPathToRelative(t).componentsString,e=t.componentsString}return n.length<e.length?n:e}get rootContentContainer(){let t=this;for(;t.parent;)t=t.parent;return a(t,N)}Copy(){throw Error("Not Implemented: Doesn't support copying")}SetChild(t,e,n){t[e]&&(t[e]=null),t[e]=n,t[e]&&(t[e].parent=this)}}class m{constructor(t){t=void 0!==t?t.toString():"",this.string=t}get Length(){return this.string.length}Append(t){null!==t&&(this.string+=t)}AppendLine(t){void 0!==t&&this.Append(t),this.string+="\n"}AppendFormat(t,...e){this.string+=t.replace(/{(\d+)}/g,(t,n)=>void 0!==e[n]?e[n]:t)}toString(){return this.string}}class f{constructor(){if(this.originName=null,this.itemName=null,void 0!==arguments[1]){let t=arguments[0],e=arguments[1];this.originName=t,this.itemName=e}else if(arguments[0]){let t=arguments[0].toString().split(".");this.originName=t[0],this.itemName=t[1]}}static get Null(){return new f(null,null)}get isNull(){return null==this.originName&&null==this.itemName}get fullName(){return(null!==this.originName?this.originName:"?")+"."+this.itemName}toString(){return this.fullName}Equals(t){if(t instanceof f){let e=t;return e.itemName==this.itemName&&e.originName==this.originName}return!1}copy(){return new f(this.originName,this.itemName)}serialized(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}static fromSerializedKey(t){let e=JSON.parse(t);if(!f.isLikeInkListItem(e))return f.Null;let n=e;return new f(n.originName,n.itemName)}static isLikeInkListItem(t){return"object"==typeof t&&(!(!t.hasOwnProperty("originName")||!t.hasOwnProperty("itemName"))&&(("string"==typeof t.originName||null===typeof t.originName)&&("string"==typeof t.itemName||null===typeof t.itemName)))}}class g extends Map{constructor(){if(super(arguments[0]instanceof g?arguments[0]:[]),this.origins=null,this._originNames=[],arguments[0]instanceof g){let t=arguments[0];t._originNames&&(this._originNames=t._originNames.slice())}else if("string"==typeof arguments[0]){let t=arguments[0],e=arguments[1];this.SetInitialOriginName(t);let n=e.listDefinitions.TryListGetDefinition(t,null);if(!n.exists)throw new Error("InkList origin could not be found in story when constructing new list: "+t);this.origins=[n.result]}else if("object"==typeof arguments[0]&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")){let t=arguments[0];this.Add(t.Key,t.Value)}}AddItem(t){if(t instanceof f){let e=t;if(null==e.originName)return void this.AddItem(e.itemName);if(null===this.origins)return d("this.origins");for(let t of this.origins)if(t.name==e.originName){let n=t.TryGetValueForItem(e,0);if(n.exists)return void this.Add(e,n.result);throw new Error("Could not add the item "+e+" to this list because it doesn't exist in the original list definition in ink.")}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}{let e=t,n=null;if(null===this.origins)return d("this.origins");for(let t of this.origins){if(null===e)return d("itemName");if(t.ContainsItemWithName(e)){if(null!=n)throw new Error("Could not add the item "+e+" to this list because it could come from either "+t.name+" or "+n.name);n=t}}if(null==n)throw new Error("Could not add the item "+e+" to this list because it isn't known to any list definitions previously associated with this list.");let i=new f(n.name,e),r=n.ValueForItem(i);this.Add(i,r)}}ContainsItemNamed(t){for(let[e]of this){if(f.fromSerializedKey(e).itemName==t)return!0}return!1}ContainsKey(t){return this.has(t.serialized())}Add(t,e){let n=t.serialized();if(this.has(n))throw new Error("The Map already contains an entry for "+t);this.set(n,e)}Remove(t){return this.delete(t.serialized())}get Count(){return this.size}get originOfMaxItem(){if(null==this.origins)return null;let t=this.maxItem.Key.originName,e=null;return this.origins.every(n=>n.name!=t||(e=n,!1)),e}get originNames(){if(this.Count>0){null==this._originNames&&this.Count>0?this._originNames=[]:(this._originNames||(this._originNames=[]),this._originNames.length=0);for(let[t]of this){let e=f.fromSerializedKey(t);if(null===e.originName)return d("item.originName");this._originNames.push(e.originName)}}return this._originNames}SetInitialOriginName(t){this._originNames=[t]}SetInitialOriginNames(t){this._originNames=null==t?null:t.slice()}get maxItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n>t.Value)&&(t={Key:i,Value:n})}return t}get minItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n<t.Value)&&(t={Key:i,Value:n})}return t}get inverse(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);this.ContainsKey(e)||t.Add(e,i)}return t}get all(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);t.set(e.serialized(),i)}return t}Union(t){let e=new g(this);for(let[n,i]of t)e.set(n,i);return e}Intersect(t){let e=new g;for(let[n,i]of this)t.has(n)&&e.set(n,i);return e}Without(t){let e=new g(this);for(let[n]of t)e.delete(n);return e}Contains(t){for(let[e]of t)if(!this.has(e))return!1;return!0}GreaterThan(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>t.maxItem.Value)}GreaterThanOrEquals(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>=t.minItem.Value&&this.maxItem.Value>=t.maxItem.Value)}LessThan(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<t.minItem.Value)}LessThanOrEquals(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<=t.maxItem.Value&&this.minItem.Value<=t.minItem.Value)}MaxAsList(){return this.Count>0?new g(this.maxItem):new g}MinAsList(){return this.Count>0?new g(this.minItem):new g}ListWithSubRange(t,e){if(0==this.Count)return new g;let n=this.orderedItems,i=0,r=Number.MAX_SAFE_INTEGER;Number.isInteger(t)?i=t:t instanceof g&&t.Count>0&&(i=t.minItem.Value),Number.isInteger(e)?r=e:t instanceof g&&t.Count>0&&(r=e.maxItem.Value);let a=new g;a.SetInitialOriginNames(this.originNames);for(let t of n)t.Value>=i&&t.Value<=r&&a.Add(t.Key,t.Value);return a}Equals(t){if(t instanceof g==!1)return!1;if(t.Count!=this.Count)return!1;for(let[e]of this)if(!t.has(e))return!1;return!0}get orderedItems(){let t=new Array;for(let[e,n]of this){let i=f.fromSerializedKey(e);t.push({Key:i,Value:n})}return t.sort((t,e)=>null===t.Key.originName?d("x.Key.originName"):null===e.Key.originName?d("y.Key.originName"):t.Value==e.Value?t.Key.originName.localeCompare(e.Key.originName):t.Value<e.Value?-1:t.Value>e.Value?1:0),t}toString(){let t=this.orderedItems,e=new m;for(let n=0;n<t.length;n++){n>0&&e.Append(", ");let i=t[n].Key;if(null===i.itemName)return d("item.itemName");e.Append(i.itemName)}return e.toString()}valueOf(){return NaN}}class S extends Error{constructor(t){super(t),this.useEndLineNumber=!1,this.message=t,this.name="StoryException"}}function y(t,e,n){if(null===t)return{result:n,exists:!1};let i=t.get(e);return void 0===i?{result:n,exists:!1}:{result:i,exists:!0}}class C extends p{static Create(t,n){if(n){if(n===i.Int&&Number.isInteger(Number(t)))return new b(Number(t));if(n===i.Float&&!isNaN(t))return new _(Number(t))}if("boolean"==typeof t){t=!!t?1:0}return"string"==typeof t?new T(String(t)):Number.isInteger(Number(t))?new b(Number(t)):isNaN(t)?t instanceof e?new P(s(t,e)):t instanceof g?new O(s(t,g)):null:new _(Number(t))}Copy(){return s(C.Create(this),p)}BadCastException(t){return new S("Can't cast "+this.valueObject+" from "+this.valueType+" to "+t)}}class v extends C{constructor(t){super(),this.value=t}get valueObject(){return this.value}toString(){return null===this.value?d("Value.value"):this.value.toString()}}class b extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Int}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Float)return new _(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class _ extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Float}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Int)return new b(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class T extends v{constructor(t){if(super(t||""),this._isNewline="\n"==this.value,this._isInlineWhitespace=!0,null===this.value)return d("Value.value");this.value.length>0&&this.value.split("").every(t=>" "==t||"\t"==t||(this._isInlineWhitespace=!1,!1))}get valueType(){return i.String}get isTruthy(){return null===this.value?d("Value.value"):this.value.length>0}get isNewline(){return this._isNewline}get isInlineWhitespace(){return this._isInlineWhitespace}get isNonWhitespace(){return!this.isNewline&&!this.isInlineWhitespace}Cast(t){if(t==this.valueType)return this;if(t==i.Int){let e=function(t,e=0){let n=parseInt(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new b(e.result);throw this.BadCastException(t)}if(t==i.Float){let e=function(t,e=0){let n=parseFloat(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new _(e.result);throw this.BadCastException(t)}throw this.BadCastException(t)}}class P extends v{constructor(t){super(t)}get valueType(){return i.DivertTarget}get targetPath(){return null===this.value?d("Value.value"):this.value}set targetPath(t){this.value=t}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a divert target")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"DivertTargetValue("+this.targetPath+")"}}class w extends v{constructor(t,e=-1){super(t),this._contextIndex=e}get contextIndex(){return this._contextIndex}set contextIndex(t){this._contextIndex=t}get variableName(){return null===this.value?d("Value.value"):this.value}set variableName(t){this.value=t}get valueType(){return i.VariablePointer}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"VariablePointerValue("+this.variableName+")"}Copy(){return new w(this.variableName,this.contextIndex)}}class O extends v{get isTruthy(){return null===this.value?d("this.value"):this.value.Count>0}get valueType(){return i.List}Cast(t){if(null===this.value)return d("Value.value");if(t==i.Int){let t=this.value.maxItem;return t.Key.isNull?new b(0):new b(t.Value)}if(t==i.Float){let t=this.value.maxItem;return t.Key.isNull?new _(0):new _(t.Value)}if(t==i.String){let t=this.value.maxItem;return t.Key.isNull?new T(""):new T(t.Key.toString())}if(t==this.valueType)return this;throw this.BadCastException(t)}constructor(t,e){super(null),t||e?t instanceof g?this.value=new g(t):t instanceof f&&"number"==typeof e&&(this.value=new g({Key:t,Value:e})):this.value=new g}static RetainListOriginsForAssignment(t,e){let n=a(t,O),i=a(e,O);return i&&null===i.value?d("newList.value"):n&&null===n.value?d("oldList.value"):void(n&&i&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames))}}!function(t){t[t.Int=0]="Int",t[t.Float=1]="Float",t[t.List=2]="List",t[t.String=3]="String",t[t.DivertTarget=4]="DivertTarget",t[t.VariablePointer=5]="VariablePointer"}(i||(i={}));class E{constructor(){this.obj=null,this.approximate=!1}get correctObj(){return this.approximate?null:this.obj}get container(){return this.obj instanceof N?this.obj:null}copy(){let t=new E;return t.obj=this.obj,t.approximate=this.approximate,t}}class N extends p{constructor(){super(...arguments),this.name="",this._content=[],this.namedContent=new Map,this.visitsShouldBeCounted=!1,this.turnIndexShouldBeCounted=!1,this.countingAtStartOnly=!1,this._pathToFirstLeafContent=null}get hasValidName(){return null!=this.name&&this.name.length>0}get content(){return this._content}set content(t){this.AddContent(t)}get namedOnlyContent(){let t=new Map;for(let[e,n]of this.namedContent){let i=s(n,p);t.set(e,i)}for(let e of this.content){let n=l(e);null!=n&&n.hasValidName&&t.delete(n.name)}return 0==t.size&&(t=null),t}set namedOnlyContent(t){let e=this.namedOnlyContent;if(null!=e)for(let[t]of e)this.namedContent.delete(t);if(null!=t)for(let[,e]of t){let t=l(e);null!=t&&this.AddToNamedContentOnly(t)}}get countFlags(){let t=0;return this.visitsShouldBeCounted&&(t|=N.CountFlags.Visits),this.turnIndexShouldBeCounted&&(t|=N.CountFlags.Turns),this.countingAtStartOnly&&(t|=N.CountFlags.CountStartOnly),t==N.CountFlags.CountStartOnly&&(t=0),t}set countFlags(t){let e=t;(e&N.CountFlags.Visits)>0&&(this.visitsShouldBeCounted=!0),(e&N.CountFlags.Turns)>0&&(this.turnIndexShouldBeCounted=!0),(e&N.CountFlags.CountStartOnly)>0&&(this.countingAtStartOnly=!0)}get pathToFirstLeafContent(){return null==this._pathToFirstLeafContent&&(this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent)),this._pathToFirstLeafContent}get internalPathToFirstLeafContent(){let t=[],n=this;for(;n instanceof N;)n.content.length>0&&(t.push(new e.Component(0)),n=n.content[0]);return new e(t)}AddContent(t){if(t instanceof Array){let e=t;for(let t of e)this.AddContent(t)}else{let e=t;if(this._content.push(e),e.parent)throw new Error("content is already in "+e.parent);e.parent=this,this.TryAddNamedContent(e)}}TryAddNamedContent(t){let e=l(t);null!=e&&e.hasValidName&&this.AddToNamedContentOnly(e)}AddToNamedContentOnly(t){n.AssertType(t,p,"Can only add Runtime.Objects to a Runtime.Container"),s(t,p).parent=this,this.namedContent.set(t.name,t)}ContentAtPath(t,e=0,n=-1){-1==n&&(n=t.length);let i=new E;i.approximate=!1;let r=this,s=this;for(let l=e;l<n;++l){let e=t.GetComponent(l);if(null==r){i.approximate=!0;break}let n=r.ContentWithPathComponent(e);if(null==n){i.approximate=!0;break}s=n,r=a(n,N)}return i.obj=s,i}InsertContent(t,e){if(this.content[e]=t,t.parent)throw new Error("content is already in "+t.parent);t.parent=this,this.TryAddNamedContent(t)}AddContentsOfContainer(t){this.content=this.content.concat(t.content);for(let e of t.content)e.parent=this,this.TryAddNamedContent(e)}ContentWithPathComponent(t){if(t.isIndex)return t.index>=0&&t.index<this.content.length?this.content[t.index]:null;if(t.isParent)return this.parent;{if(null===t.name)return d("component.name");let e=y(this.namedContent,t.name,null);return e.exists?s(e.result,p):null}}BuildStringOfHierarchy(){let t;if(0==arguments.length)return t=new m,this.BuildStringOfHierarchy(t,0,null),t.toString();t=arguments[0];let e=arguments[1],i=arguments[2];function r(){for(let n=0;n<4*e;++n)t.Append(" ")}r(),t.Append("["),this.hasValidName&&t.AppendFormat(" ({0})",this.name),this==i&&t.Append("  <---"),t.AppendLine(),e++;for(let n=0;n<this.content.length;++n){let a=this.content[n];if(a instanceof N){a.BuildStringOfHierarchy(t,e,i)}else r(),a instanceof T?(t.Append('"'),t.Append(a.toString().replace("\n","\\n")),t.Append('"')):t.Append(a.toString());n!=this.content.length-1&&t.Append(","),a instanceof N||a!=i||t.Append("  <---"),t.AppendLine()}let a=new Map;for(let[t,e]of this.namedContent)this.content.indexOf(s(e,p))>=0||a.set(t,e);if(a.size>0){r(),t.AppendLine("-- named: --");for(let[,r]of a){n.AssertType(r,N,"Can only print out named Containers"),r.BuildStringOfHierarchy(t,e,i),t.AppendLine()}}e--,r(),t.Append("]")}}!function(t){let e;!function(t){t[t.Visits=1]="Visits",t[t.Turns=2]="Turns",t[t.CountStartOnly=4]="CountStartOnly"}(e=t.CountFlags||(t.CountFlags={}))}(N||(N={}));class x extends p{toString(){return"Glue"}}class A extends p{constructor(t=A.CommandType.NotSet){super(),this._commandType=t}get commandType(){return this._commandType}Copy(){return new A(this.commandType)}static EvalStart(){return new A(A.CommandType.EvalStart)}static EvalOutput(){return new A(A.CommandType.EvalOutput)}static EvalEnd(){return new A(A.CommandType.EvalEnd)}static Duplicate(){return new A(A.CommandType.Duplicate)}static PopEvaluatedValue(){return new A(A.CommandType.PopEvaluatedValue)}static PopFunction(){return new A(A.CommandType.PopFunction)}static PopTunnel(){return new A(A.CommandType.PopTunnel)}static BeginString(){return new A(A.CommandType.BeginString)}static EndString(){return new A(A.CommandType.EndString)}static NoOp(){return new A(A.CommandType.NoOp)}static ChoiceCount(){return new A(A.CommandType.ChoiceCount)}static Turns(){return new A(A.CommandType.Turns)}static TurnsSince(){return new A(A.CommandType.TurnsSince)}static ReadCount(){return new A(A.CommandType.ReadCount)}static Random(){return new A(A.CommandType.Random)}static SeedRandom(){return new A(A.CommandType.SeedRandom)}static VisitIndex(){return new A(A.CommandType.VisitIndex)}static SequenceShuffleIndex(){return new A(A.CommandType.SequenceShuffleIndex)}static StartThread(){return new A(A.CommandType.StartThread)}static Done(){return new A(A.CommandType.Done)}static End(){return new A(A.CommandType.End)}static ListFromInt(){return new A(A.CommandType.ListFromInt)}static ListRange(){return new A(A.CommandType.ListRange)}static ListRandom(){return new A(A.CommandType.ListRandom)}toString(){return this.commandType.toString()}}!function(t){let e;!function(t){t[t.NotSet=-1]="NotSet",t[t.EvalStart=0]="EvalStart",t[t.EvalOutput=1]="EvalOutput",t[t.EvalEnd=2]="EvalEnd",t[t.Duplicate=3]="Duplicate",t[t.PopEvaluatedValue=4]="PopEvaluatedValue",t[t.PopFunction=5]="PopFunction",t[t.PopTunnel=6]="PopTunnel",t[t.BeginString=7]="BeginString",t[t.EndString=8]="EndString",t[t.NoOp=9]="NoOp",t[t.ChoiceCount=10]="ChoiceCount",t[t.Turns=11]="Turns",t[t.TurnsSince=12]="TurnsSince",t[t.Random=13]="Random",t[t.SeedRandom=14]="SeedRandom",t[t.VisitIndex=15]="VisitIndex",t[t.SequenceShuffleIndex=16]="SequenceShuffleIndex",t[t.StartThread=17]="StartThread",t[t.Done=18]="Done",t[t.End=19]="End",t[t.ListFromInt=20]="ListFromInt",t[t.ListRange=21]="ListRange",t[t.ListRandom=22]="ListRandom",t[t.ReadCount=23]="ReadCount",t[t.TOTAL_VALUES=24]="TOTAL_VALUES"}(e=t.CommandType||(t.CommandType={}))}(A||(A={})),function(t){t[t.Tunnel=0]="Tunnel",t[t.Function=1]="Function",t[t.FunctionEvaluationFromGame=2]="FunctionEvaluationFromGame"}(r||(r={}));class I{constructor(){this.container=null,this.index=-1,2===arguments.length&&(this.container=arguments[0],this.index=arguments[1])}Resolve(){return this.index<0?this.container:null==this.container?null:0==this.container.content.length?this.container:this.index>=this.container.content.length?null:this.container.content[this.index]}get isNull(){return null==this.container}get path(){return this.isNull?null:this.index>=0?this.container.path.PathByAppendingComponent(new e.Component(this.index)):this.container.path}toString(){return this.container?"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index:"Ink Pointer (null)"}copy(){return new I(this.container,this.index)}static StartOf(t){return new I(t,0)}static get Null(){return new I(null,-1)}}class k extends p{constructor(t){super(),this._targetPath=null,this._targetPointer=I.Null,this.variableDivertName=null,this.pushesToStack=!1,this.stackPushType=0,this.isExternal=!1,this.externalArgs=0,this.isConditional=!1,this.pushesToStack=!1,void 0!==t&&(this.pushesToStack=!0,this.stackPushType=t)}get targetPath(){if(null!=this._targetPath&&this._targetPath.isRelative){let t=this.targetPointer.Resolve();t&&(this._targetPath=t.path)}return this._targetPath}set targetPath(t){this._targetPath=t,this._targetPointer=I.Null}get targetPointer(){if(this._targetPointer.isNull){let t=this.ResolvePath(this._targetPath).obj;if(null===this._targetPath)return d("this._targetPath");if(null===this._targetPath.lastComponent)return d("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(null===t)return d("targetObj");this._targetPointer.container=t.parent instanceof N?t.parent:null,this._targetPointer.index=this._targetPath.lastComponent.index}else this._targetPointer=I.StartOf(t instanceof N?t:null)}return this._targetPointer.copy()}get targetPathString(){return null==this.targetPath?null:this.CompactPathString(this.targetPath)}set targetPathString(t){this.targetPath=null==t?null:new e(t)}get hasVariableTarget(){return null!=this.variableDivertName}Equals(t){let e=t;return e instanceof k&&this.hasVariableTarget==e.hasVariableTarget&&(this.hasVariableTarget?this.variableDivertName==e.variableDivertName:null===this.targetPath?d("this.targetPath"):this.targetPath.Equals(e.targetPath))}toString(){if(this.hasVariableTarget)return"Divert(variable: "+this.variableDivertName+")";if(null==this.targetPath)return"Divert(null)";{let t=new m,e=this.targetPath.toString();return t.Append("Divert"),this.isConditional&&t.Append("?"),this.pushesToStack&&(this.stackPushType==r.Function?t.Append(" function"):t.Append(" tunnel")),t.Append(" -> "),t.Append(this.targetPathString),t.Append(" ("),t.Append(e),t.Append(")"),t.toString()}}}class W extends p{constructor(t=!0){super(),this._pathOnChoice=null,this.hasCondition=!1,this.hasStartContent=!1,this.hasChoiceOnlyContent=!1,this.isInvisibleDefault=!1,this.onceOnly=!0,this.onceOnly=t}get pathOnChoice(){if(null!=this._pathOnChoice&&this._pathOnChoice.isRelative){let t=this.choiceTarget;t&&(this._pathOnChoice=t.path)}return this._pathOnChoice}set pathOnChoice(t){this._pathOnChoice=t}get choiceTarget(){return null===this._pathOnChoice?d("ChoicePoint._pathOnChoice"):this.ResolvePath(this._pathOnChoice).container}get pathStringOnChoice(){return null===this.pathOnChoice?d("ChoicePoint.pathOnChoice"):this.CompactPathString(this.pathOnChoice)}set pathStringOnChoice(t){this.pathOnChoice=new e(t)}get flags(){let t=0;return this.hasCondition&&(t|=1),this.hasStartContent&&(t|=2),this.hasChoiceOnlyContent&&(t|=4),this.isInvisibleDefault&&(t|=8),this.onceOnly&&(t|=16),t}set flags(t){this.hasCondition=(1&t)>0,this.hasStartContent=(2&t)>0,this.hasChoiceOnlyContent=(4&t)>0,this.isInvisibleDefault=(8&t)>0,this.onceOnly=(16&t)>0}toString(){if(null===this.pathOnChoice)return d("ChoicePoint.pathOnChoice");return"Choice: -> "+this.pathOnChoice.toString()}}class F extends p{constructor(t=null){super(),this.pathForCount=null,this.name=t}get containerForCount(){return null===this.pathForCount?null:this.ResolvePath(this.pathForCount).container}get pathStringForCount(){return null===this.pathForCount?null:this.CompactPathString(this.pathForCount)}set pathStringForCount(t){this.pathForCount=null===t?null:new e(t)}toString(){if(null!=this.name)return"var("+this.name+")";return"read_count("+this.pathStringForCount+")"}}class V extends p{constructor(t,e){super(),this.variableName=t||null,this.isNewDeclaration=!!e,this.isGlobal=!1}toString(){return"VarAssign to "+this.variableName}}class L extends p{}class R extends p{constructor(){if(super(),this._name=null,this._numberOfParameters=0,this._prototype=null,this._isPrototype=!1,this._operationFuncs=null,0===arguments.length)R.GenerateNativeFunctionsIfNecessary();else if(1===arguments.length){let t=arguments[0];R.GenerateNativeFunctionsIfNecessary(),this.name=t}else if(2===arguments.length){let t=arguments[0],e=arguments[1];this._isPrototype=!0,this.name=t,this.numberOfParameters=e}}static CallWithName(t){return new R(t)}static CallExistsWithName(t){return this.GenerateNativeFunctionsIfNecessary(),this._nativeFunctions.get(t)}get name(){return null===this._name?d("NativeFunctionCall._name"):this._name}set name(t){this._name=t,this._isPrototype||(null===R._nativeFunctions?d("NativeFunctionCall._nativeFunctions"):this._prototype=R._nativeFunctions.get(this._name)||null)}get numberOfParameters(){return this._prototype?this._prototype.numberOfParameters:this._numberOfParameters}set numberOfParameters(t){this._numberOfParameters=t}Call(t){if(this._prototype)return this._prototype.Call(t);if(this.numberOfParameters!=t.length)throw new Error("Unexpected number of parameters");let e=!1;for(let n of t){if(n instanceof L)throw new S('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');n instanceof O&&(e=!0)}if(2==t.length&&e)return this.CallBinaryListOperation(t);let n=this.CoerceValuesToSingleType(t),r=n[0].valueType;return r==i.Int||r==i.Float||r==i.String||r==i.DivertTarget||r==i.List?this.CallType(n):null}CallType(t){let e=s(t[0],v),n=e.valueType,r=e,a=t.length;if(2==a||1==a){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(n);if(!l){const t=i[n];throw new S("Cannot perform operation "+this.name+" on "+t)}if(2==a){let e=s(t[1],v),n=l;if(null===r.value||null===e.value)return d("NativeFunctionCall.Call BinaryOp values");let i=n(r.value,e.value);return v.Create(i)}{let t=l;if(null===r.value)return d("NativeFunctionCall.Call UnaryOp value");let n=t(r.value);return this.name===R.Int?v.Create(n,i.Int):this.name===R.Float?v.Create(n,i.Float):v.Create(n,e.valueType)}}throw new Error("Unexpected number of parameters to NativeFunctionCall: "+t.length)}CallBinaryListOperation(t){if(("+"==this.name||"-"==this.name)&&t[0]instanceof O&&t[1]instanceof b)return this.CallListIncrementOperation(t);let e=s(t[0],v),n=s(t[1],v);if(!("&&"!=this.name&&"||"!=this.name||e.valueType==i.List&&n.valueType==i.List)){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let t=this._operationFuncs.get(i.Int);if(null===t)return d("NativeFunctionCall.CallBinaryListOperation op");let r=t(e.isTruthy?1:0,n.isTruthy?1:0);return new b(r)}if(e.valueType==i.List&&n.valueType==i.List)return this.CallType([e,n]);throw new S("Can not call use "+this.name+" operation on "+i[e.valueType]+" and "+i[n.valueType])}CallListIncrementOperation(t){let e=s(t[0],O),n=s(t[1],b),r=new g;if(null===e.value)return d("NativeFunctionCall.CallListIncrementOperation listVal.value");for(let[t,a]of e.value){let s=f.fromSerializedKey(t);if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(i.Int);if(null===n.value)return d("NativeFunctionCall.CallListIncrementOperation intVal.value");let o=l(a,n.value),u=null;if(null===e.value.origins)return d("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");for(let t of e.value.origins)if(t.name==s.originName){u=t;break}if(null!=u){let t=u.TryGetItemWithValue(o,f.Null);t.exists&&r.Add(t.result,o)}}return new O(r)}CoerceValuesToSingleType(t){let e=i.Int,n=null;for(let r of t){let t=s(r,v);t.valueType>e&&(e=t.valueType),t.valueType==i.List&&(n=a(t,O))}let r=[];if(i[e]==i[i.List])for(let e of t){let t=s(e,v);if(t.valueType==i.List)r.push(t);else{if(t.valueType!=i.Int){const e=i[t.valueType];throw new S("Cannot mix Lists and "+e+" values in this operation")}{let e=parseInt(t.valueObject);if(n=s(n,O),null===n.value)return d("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");let i=n.value.originOfMaxItem;if(null===i)return d("NativeFunctionCall.CoerceValuesToSingleType list");let a=i.TryGetItemWithValue(e,f.Null);if(!a.exists)throw new S("Could not find List item with the value "+e+" in "+i.name);{let t=new O(a.result,e);r.push(t)}}}}else for(let n of t){let t=s(n,v).Cast(e);r.push(t)}return r}static Identity(t){return t}static GenerateNativeFunctionsIfNecessary(){if(null==this._nativeFunctions){this._nativeFunctions=new Map,this.AddIntBinaryOp(this.Add,(t,e)=>t+e),this.AddIntBinaryOp(this.Subtract,(t,e)=>t-e),this.AddIntBinaryOp(this.Multiply,(t,e)=>t*e),this.AddIntBinaryOp(this.Divide,(t,e)=>Math.floor(t/e)),this.AddIntBinaryOp(this.Mod,(t,e)=>t%e),this.AddIntUnaryOp(this.Negate,t=>-t),this.AddIntBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddIntBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddIntBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddIntBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddIntBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddIntBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddIntUnaryOp(this.Not,t=>0==t?1:0),this.AddIntBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddIntBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddIntBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddIntBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddIntBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddIntUnaryOp(this.Floor,R.Identity),this.AddIntUnaryOp(this.Ceiling,R.Identity),this.AddIntUnaryOp(this.Int,R.Identity),this.AddIntUnaryOp(this.Float,t=>t),this.AddFloatBinaryOp(this.Add,(t,e)=>t+e),this.AddFloatBinaryOp(this.Subtract,(t,e)=>t-e),this.AddFloatBinaryOp(this.Multiply,(t,e)=>t*e),this.AddFloatBinaryOp(this.Divide,(t,e)=>t/e),this.AddFloatBinaryOp(this.Mod,(t,e)=>t%e),this.AddFloatUnaryOp(this.Negate,t=>-t),this.AddFloatBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddFloatBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddFloatBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddFloatBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddFloatBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddFloatBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddFloatUnaryOp(this.Not,t=>0==t?1:0),this.AddFloatBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddFloatBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddFloatBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddFloatBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddFloatBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddFloatUnaryOp(this.Floor,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Ceiling,t=>Math.ceil(t)),this.AddFloatUnaryOp(this.Int,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Float,R.Identity),this.AddStringBinaryOp(this.Add,(t,e)=>t+e),this.AddStringBinaryOp(this.Equal,(t,e)=>t===e?1:0),this.AddStringBinaryOp(this.NotEquals,(t,e)=>t!==e?1:0),this.AddStringBinaryOp(this.Has,(t,e)=>t.includes(e)?1:0),this.AddStringBinaryOp(this.Hasnt,(t,e)=>t.includes(e)?0:1),this.AddListBinaryOp(this.Add,(t,e)=>t.Union(e)),this.AddListBinaryOp(this.Subtract,(t,e)=>t.Without(e)),this.AddListBinaryOp(this.Has,(t,e)=>t.Contains(e)?1:0),this.AddListBinaryOp(this.Hasnt,(t,e)=>t.Contains(e)?0:1),this.AddListBinaryOp(this.Intersect,(t,e)=>t.Intersect(e)),this.AddListBinaryOp(this.Equal,(t,e)=>t.Equals(e)?1:0),this.AddListBinaryOp(this.Greater,(t,e)=>t.GreaterThan(e)?1:0),this.AddListBinaryOp(this.Less,(t,e)=>t.LessThan(e)?1:0),this.AddListBinaryOp(this.GreaterThanOrEquals,(t,e)=>t.GreaterThanOrEquals(e)?1:0),this.AddListBinaryOp(this.LessThanOrEquals,(t,e)=>t.LessThanOrEquals(e)?1:0),this.AddListBinaryOp(this.NotEquals,(t,e)=>t.Equals(e)?0:1),this.AddListBinaryOp(this.And,(t,e)=>t.Count>0&&e.Count>0?1:0),this.AddListBinaryOp(this.Or,(t,e)=>t.Count>0||e.Count>0?1:0),this.AddListUnaryOp(this.Not,t=>0==t.Count?1:0),this.AddListUnaryOp(this.Invert,t=>t.inverse),this.AddListUnaryOp(this.All,t=>t.all),this.AddListUnaryOp(this.ListMin,t=>t.MinAsList()),this.AddListUnaryOp(this.ListMax,t=>t.MaxAsList()),this.AddListUnaryOp(this.Count,t=>t.Count),this.AddListUnaryOp(this.ValueOfList,t=>t.maxItem.Value);let t=(t,e)=>t.Equals(e)?1:0,e=(t,e)=>t.Equals(e)?0:1;this.AddOpToNativeFunc(this.Equal,2,i.DivertTarget,t),this.AddOpToNativeFunc(this.NotEquals,2,i.DivertTarget,e)}}AddOpFuncForType(t,e){null==this._operationFuncs&&(this._operationFuncs=new Map),this._operationFuncs.set(t,e)}static AddOpToNativeFunc(t,e,n,i){if(null===this._nativeFunctions)return d("NativeFunctionCall._nativeFunctions");let r=this._nativeFunctions.get(t);r||(r=new R(t,e),this._nativeFunctions.set(t,r)),r.AddOpFuncForType(n,i)}static AddIntBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Int,e)}static AddIntUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Int,e)}static AddFloatBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Float,e)}static AddFloatUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Float,e)}static AddStringBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.String,e)}static AddListBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.List,e)}static AddListUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.List,e)}toString(){return'Native "'+this.name+'"'}}R.Add="+",R.Subtract="-",R.Divide="/",R.Multiply="*",R.Mod="%",R.Negate="_",R.Equal="==",R.Greater=">",R.Less="<",R.GreaterThanOrEquals=">=",R.LessThanOrEquals="<=",R.NotEquals="!=",R.Not="!",R.And="&&",R.Or="||",R.Min="MIN",R.Max="MAX",R.Pow="POW",R.Floor="FLOOR",R.Ceiling="CEILING",R.Int="INT",R.Float="FLOAT",R.Has="?",R.Hasnt="!?",R.Intersect="^",R.ListMin="LIST_MIN",R.ListMax="LIST_MAX",R.All="LIST_ALL",R.Count="LIST_COUNT",R.ValueOfList="LIST_VALUE",R.Invert="LIST_INVERT",R._nativeFunctions=null;class j extends p{constructor(t){super(),this.text=t.toString()||""}toString(){return"# "+this.text}}class D extends p{constructor(){super(...arguments),this.text="",this.index=0,this.threadAtGeneration=null,this.sourcePath="",this.targetPath=null,this.isInvisibleDefault=!1,this.originalThreadIndex=0}get pathStringOnChoice(){return null===this.targetPath?d("Choice.targetPath"):this.targetPath.toString()}set pathStringOnChoice(t){this.targetPath=new e(t)}}class G{constructor(t,e){this._name=t||"",this._items=null,this._itemNameToValues=e||new Map}get name(){return this._name}get items(){if(null==this._items){this._items=new Map;for(let[t,e]of this._itemNameToValues){let n=new f(this.name,t);this._items.set(n.serialized(),e)}}return this._items}ValueForItem(t){if(!t.itemName)return 0;let e=this._itemNameToValues.get(t.itemName);return void 0!==e?e:0}ContainsItem(t){return!!t.itemName&&(t.originName==this.name&&this._itemNameToValues.has(t.itemName))}ContainsItemWithName(t){return this._itemNameToValues.has(t)}TryGetItemWithValue(t,e){for(let[e,n]of this._itemNameToValues)if(n==t)return{result:new f(this.name,e),exists:!0};return{result:f.Null,exists:!1}}TryGetValueForItem(t,e){if(!t.itemName)return{result:0,exists:!1};let n=this._itemNameToValues.get(t.itemName);return n?{result:n,exists:!0}:{result:0,exists:!1}}}class B{constructor(t){this._lists=new Map,this._allUnambiguousListValueCache=new Map;for(let e of t){this._lists.set(e.name,e);for(let[t,n]of e.items){let e=f.fromSerializedKey(t),i=new O(e,n);if(!e.itemName)throw new Error("item.itemName is null or undefined.");this._allUnambiguousListValueCache.set(e.itemName,i),this._allUnambiguousListValueCache.set(e.fullName,i)}}}get lists(){let t=[];for(let[,e]of this._lists)t.push(e);return t}TryListGetDefinition(t,e){if(null===t)return{result:e,exists:!1};let n=this._lists.get(t);return n?{result:n,exists:!0}:{result:e,exists:!1}}FindSingleItemListWithName(t){if(null===t)return d("name");let e=this._allUnambiguousListValueCache.get(t);return void 0!==e?e:null}}class M{static JArrayToRuntimeObjList(t,e=!1){let n=t.length;e&&n--;let i=[];for(let e=0;e<n;e++){let n=t[e],r=this.JTokenToRuntimeObject(n);if(null===r)return d("runtimeObj");i.push(r)}return i}static WriteDictionaryRuntimeObjs(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WritePropertyStart(n),this.WriteRuntimeObject(t,i),t.WritePropertyEnd();t.WriteObjectEnd()}static WriteListRuntimeObjs(t,e){t.WriteArrayStart();for(let n of e)this.WriteRuntimeObject(t,n);t.WriteArrayEnd()}static WriteIntDictionary(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WriteIntProperty(n,i);t.WriteObjectEnd()}static WriteRuntimeObject(t,e){let n=a(e,N);if(n)return void this.WriteRuntimeContainer(t,n);let i=a(e,k);if(i){let e,n="->";return i.isExternal?n="x()":i.pushesToStack&&(i.stackPushType==r.Function?n="f()":i.stackPushType==r.Tunnel&&(n="->t->")),e=i.hasVariableTarget?i.variableDivertName:i.targetPathString,t.WriteObjectStart(),t.WriteProperty(n,e),i.hasVariableTarget&&t.WriteProperty("var",!0),i.isConditional&&t.WriteProperty("c",!0),i.externalArgs>0&&t.WriteIntProperty("exArgs",i.externalArgs),void t.WriteObjectEnd()}let s=a(e,W);if(s)return t.WriteObjectStart(),t.WriteProperty("*",s.pathStringOnChoice),t.WriteIntProperty("flg",s.flags),void t.WriteObjectEnd();let l=a(e,b);if(l)return void t.WriteInt(l.value);let o=a(e,_);if(o)return void t.WriteFloat(o.value);let u=a(e,T);if(u)return void(u.isNewline?t.Write("\n",!1):(t.WriteStringStart(),t.WriteStringInner("^"),t.WriteStringInner(u.value),t.WriteStringEnd()));let h=a(e,O);if(h)return void this.WriteInkList(t,h);let c=a(e,P);if(c)return t.WriteObjectStart(),null===c.value?d("divTargetVal.value"):(t.WriteProperty("^->",c.value.componentsString),void t.WriteObjectEnd());let p=a(e,w);if(p)return t.WriteObjectStart(),t.WriteProperty("^var",p.value),t.WriteIntProperty("ci",p.contextIndex),void t.WriteObjectEnd();if(a(e,x))return void t.Write("<>");let m=a(e,A);if(m)return void t.Write(M._controlCommandNames[m.commandType]);let f=a(e,R);if(f){let e=f.name;return"^"==e&&(e="L^"),void t.Write(e)}let g=a(e,F);if(g){t.WriteObjectStart();let e=g.pathStringForCount;return null!=e?t.WriteProperty("CNT?",e):t.WriteProperty("VAR?",g.name),void t.WriteObjectEnd()}let S=a(e,V);if(S){t.WriteObjectStart();let e=S.isGlobal?"VAR=":"temp=";return t.WriteProperty(e,S.variableName),S.isNewDeclaration||t.WriteProperty("re",!0),void t.WriteObjectEnd()}if(a(e,L))return void t.Write("void");let y=a(e,j);if(y)return t.WriteObjectStart(),t.WriteProperty("#",y.text),void t.WriteObjectEnd();let C=a(e,D);if(!C)throw new Error("Failed to convert runtime object to Json token: "+e);this.WriteChoice(t,C)}static JObjectToDictionaryRuntimeObjs(t){let e=new Map;for(let n in t)if(t.hasOwnProperty(n)){let i=this.JTokenToRuntimeObject(t[n]);if(null===i)return d("inkObject");e.set(n,i)}return e}static JObjectToIntDictionary(t){let e=new Map;for(let n in t)t.hasOwnProperty(n)&&e.set(n,parseInt(t[n]));return e}static JTokenToRuntimeObject(t){if("number"==typeof t&&!isNaN(t))return v.Create(t);if("string"==typeof t){let e=t.toString(),n=e[0];if("^"==n)return new T(e.substring(1));if("\n"==n&&1==e.length)return new T("\n");if("<>"==e)return new x;for(let t=0;t<M._controlCommandNames.length;++t){if(e==M._controlCommandNames[t])return new A(t)}if("L^"==e&&(e="^"),R.CallExistsWithName(e))return R.CallWithName(e);if("->->"==e)return A.PopTunnel();if("~ret"==e)return A.PopFunction();if("void"==e)return new L}if("object"==typeof t&&!Array.isArray(t)){let n,i=t;if(i["^->"])return n=i["^->"],new P(new e(n.toString()));if(i["^var"]){n=i["^var"];let t=new w(n.toString());return"ci"in i&&(n=i.ci,t.contextIndex=parseInt(n)),t}let a=!1,s=!1,l=r.Function,o=!1;if((n=i["->"])?a=!0:(n=i["f()"])?(a=!0,s=!0,l=r.Function):(n=i["->t->"])?(a=!0,s=!0,l=r.Tunnel):(n=i["x()"])&&(a=!0,o=!0,s=!1,l=r.Function),a){let t=new k;t.pushesToStack=s,t.stackPushType=l,t.isExternal=o;let e=n.toString();return(n=i.var)?t.variableDivertName=e:t.targetPathString=e,t.isConditional=!!i.c,o&&(n=i.exArgs)&&(t.externalArgs=parseInt(n)),t}if(n=i["*"]){let t=new W;return t.pathStringOnChoice=n.toString(),(n=i.flg)&&(t.flags=parseInt(n)),t}if(n=i["VAR?"])return new F(n.toString());if(n=i["CNT?"]){let t=new F;return t.pathStringForCount=n.toString(),t}let u=!1,h=!1;if((n=i["VAR="])?(u=!0,h=!0):(n=i["temp="])&&(u=!0,h=!1),u){let t=n.toString(),e=!i.re,r=new V(t,e);return r.isGlobal=h,r}if(void 0!==i["#"])return n=i["#"],new j(n.toString());if(n=i.list){let t=n,e=new g;if(n=i.origins){let t=n;e.SetInitialOriginNames(t)}for(let n in t)if(t.hasOwnProperty(n)){let i=t[n],r=new f(n),a=parseInt(i);e.Add(r,a)}return new O(e)}if(null!=i.originalChoicePath)return this.JObjectToChoice(i)}if(Array.isArray(t))return this.JArrayToContainer(t);if(null==t)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(t))}static WriteRuntimeContainer(t,e,n=!1){if(t.WriteArrayStart(),null===e)return d("container");for(let n of e.content)this.WriteRuntimeObject(t,n);let i=e.namedOnlyContent,r=e.countFlags,s=null!=e.name&&!n,l=null!=i||r>0||s;if(l&&t.WriteObjectStart(),null!=i)for(let[e,n]of i){let i=e,r=a(n,N);t.WritePropertyStart(i),this.WriteRuntimeContainer(t,r,!0),t.WritePropertyEnd()}s&&t.WriteProperty("#n",e.name),l?t.WriteObjectEnd():t.WriteNull(),t.WriteArrayEnd()}static JArrayToContainer(t){let e=new N;e.content=this.JArrayToRuntimeObjList(t,!0);let n=t[t.length-1];if(null!=n){let t=new Map;for(let i in n)if("#f"==i)e.countFlags=parseInt(n[i]);else if("#n"==i)e.name=n[i].toString();else{let e=this.JTokenToRuntimeObject(n[i]),r=a(e,N);r&&(r.name=i),t.set(i,e)}e.namedOnlyContent=t}return e}static JObjectToChoice(t){let e=new D;return e.text=t.text.toString(),e.index=parseInt(t.index),e.sourcePath=t.originalChoicePath.toString(),e.originalThreadIndex=parseInt(t.originalThreadIndex),e.pathStringOnChoice=t.targetPath.toString(),e}static WriteChoice(t,e){t.WriteObjectStart(),t.WriteProperty("text",e.text),t.WriteIntProperty("index",e.index),t.WriteProperty("originalChoicePath",e.sourcePath),t.WriteIntProperty("originalThreadIndex",e.originalThreadIndex),t.WriteProperty("targetPath",e.pathStringOnChoice),t.WriteObjectEnd()}static WriteInkList(t,e){let n=e.value;if(null===n)return d("rawList");t.WriteObjectStart(),t.WritePropertyStart("list"),t.WriteObjectStart();for(let[e,i]of n){let n=f.fromSerializedKey(e),r=i;if(null===n.itemName)return d("item.itemName");t.WritePropertyNameStart(),t.WritePropertyNameInner(n.originName?n.originName:"?"),t.WritePropertyNameInner("."),t.WritePropertyNameInner(n.itemName),t.WritePropertyNameEnd(),t.Write(r),t.WritePropertyEnd()}if(t.WriteObjectEnd(),t.WritePropertyEnd(),0==n.Count&&null!=n.originNames&&n.originNames.length>0){t.WritePropertyStart("origins"),t.WriteArrayStart();for(let e of n.originNames)t.Write(e);t.WriteArrayEnd(),t.WritePropertyEnd()}t.WriteObjectEnd()}static ListDefinitionsToJToken(t){let e={};for(let n of t.lists){let t={};for(let[e,i]of n.items){let n=f.fromSerializedKey(e);if(null===n.itemName)return d("item.itemName");t[n.itemName]=i}e[n.name]=t}return e}static JTokenToListDefinitions(t){let e=t,n=[];for(let t in e)if(e.hasOwnProperty(t)){let i=t.toString(),r=e[t],a=new Map;for(let n in r)if(e.hasOwnProperty(t)){let t=r[n];a.set(n,parseInt(t))}let s=new G(i,a);n.push(s)}return new B(n)}}M._controlCommandNames=(()=>{let t=[];t[A.CommandType.EvalStart]="ev",t[A.CommandType.EvalOutput]="out",t[A.CommandType.EvalEnd]="/ev",t[A.CommandType.Duplicate]="du",t[A.CommandType.PopEvaluatedValue]="pop",t[A.CommandType.PopFunction]="~ret",t[A.CommandType.PopTunnel]="->->",t[A.CommandType.BeginString]="str",t[A.CommandType.EndString]="/str",t[A.CommandType.NoOp]="nop",t[A.CommandType.ChoiceCount]="choiceCnt",t[A.CommandType.Turns]="turn",t[A.CommandType.TurnsSince]="turns",t[A.CommandType.ReadCount]="readc",t[A.CommandType.Random]="rnd",t[A.CommandType.SeedRandom]="srnd",t[A.CommandType.VisitIndex]="visit",t[A.CommandType.SequenceShuffleIndex]="seq",t[A.CommandType.StartThread]="thread",t[A.CommandType.Done]="done",t[A.CommandType.End]="end",t[A.CommandType.ListFromInt]="listInt",t[A.CommandType.ListRange]="range",t[A.CommandType.ListRandom]="lrnd";for(let e=0;e<A.CommandType.TOTAL_VALUES;++e)if(null==t[e])throw new Error("Control command not accounted for in serialisation");return t})();class q{constructor(){if(this._threadCounter=0,this._startOfRoot=I.Null,arguments[0]instanceof X){let t=arguments[0];this._startOfRoot=I.StartOf(t.rootContentContainer),this.Reset()}else{let t=arguments[0];this._threads=[];for(let e of t._threads)this._threads.push(e.Copy());this._threadCounter=t._threadCounter,this._startOfRoot=t._startOfRoot}}get elements(){return this.callStack}get depth(){return this.elements.length}get currentElement(){let t=this._threads[this._threads.length-1].callstack;return t[t.length-1]}get currentElementIndex(){return this.callStack.length-1}get currentThread(){return this._threads[this._threads.length-1]}set currentThread(t){n.Assert(1==this._threads.length,"Shouldn't be directly setting the current thread when we have a stack of them"),this._threads.length=0,this._threads.push(t)}get canPop(){return this.callStack.length>1}Reset(){this._threads=[],this._threads.push(new q.Thread),this._threads[0].callstack.push(new q.Element(r.Tunnel,this._startOfRoot))}SetJsonToken(t,e){this._threads.length=0;let n=t.threads;for(let t of n){let n=t,i=new q.Thread(n,e);this._threads.push(i)}this._threadCounter=parseInt(t.threadCounter),this._startOfRoot=I.StartOf(e.rootContentContainer)}WriteJson(t){t.WriteObject(t=>{t.WritePropertyStart("threads"),t.WriteArrayStart();for(let e of this._threads)e.WriteJson(t);t.WriteArrayEnd(),t.WritePropertyEnd(),t.WritePropertyStart("threadCounter"),t.WriteInt(this._threadCounter),t.WritePropertyEnd()})}PushThread(){let t=this.currentThread.Copy();this._threadCounter++,t.threadIndex=this._threadCounter,this._threads.push(t)}ForkThread(){let t=this.currentThread.Copy();return this._threadCounter++,t.threadIndex=this._threadCounter,t}PopThread(){if(!this.canPopThread)throw new Error("Can't pop thread");this._threads.splice(this._threads.indexOf(this.currentThread),1)}get canPopThread(){return this._threads.length>1&&!this.elementIsEvaluateFromGame}get elementIsEvaluateFromGame(){return this.currentElement.type==r.FunctionEvaluationFromGame}Push(t,e=0,n=0){let i=new q.Element(t,this.currentElement.currentPointer,!1);i.evaluationStackHeightWhenPushed=e,i.functionStartInOutputStream=n,this.callStack.push(i)}CanPop(t=null){return!!this.canPop&&(null==t||this.currentElement.type==t)}Pop(t=null){if(!this.CanPop(t))throw new Error("Mismatched push/pop in Callstack");this.callStack.pop()}GetTemporaryVariableWithName(t,e=-1){-1==e&&(e=this.currentElementIndex+1);let n=y(this.callStack[e-1].temporaryVariables,t,null);return n.exists?n.result:null}SetTemporaryVariable(t,e,n,i=-1){-1==i&&(i=this.currentElementIndex+1);let r=this.callStack[i-1];if(!n&&!r.temporaryVariables.get(t))throw new S("Could not find temporary variable to set: "+t);let a=y(r.temporaryVariables,t,null);a.exists&&O.RetainListOriginsForAssignment(a.result,e),r.temporaryVariables.set(t,e)}ContextForVariableNamed(t){return this.currentElement.temporaryVariables.get(t)?this.currentElementIndex+1:0}ThreadWithIndex(t){let e=this._threads.filter(e=>{if(e.threadIndex==t)return e});return e.length>0?e[0]:null}get callStack(){return this.currentThread.callstack}get callStackTrace(){let t=new m;for(let e=0;e<this._threads.length;e++){let n=this._threads[e],i=e==this._threads.length-1;t.AppendFormat("=== THREAD {0}/{1} {2}===\n",e+1,this._threads.length,i?"(current) ":"");for(let e=0;e<n.callstack.length;e++){n.callstack[e].type==r.Function?t.Append("  [FUNCTION] "):t.Append("  [TUNNEL] ");let i=n.callstack[e].currentPointer;if(!i.isNull){if(t.Append("<SOMEWHERE IN "),null===i.container)return d("pointer.container");t.Append(i.container.path.toString()),t.AppendLine(">")}}}return t.toString()}}!function(t){class n{constructor(t,e,n=!1){this.evaluationStackHeightWhenPushed=0,this.functionStartInOutputStream=0,this.currentPointer=e.copy(),this.inExpressionEvaluation=n,this.temporaryVariables=new Map,this.type=t}Copy(){let t=new n(this.type,this.currentPointer,this.inExpressionEvaluation);return t.temporaryVariables=new Map(this.temporaryVariables),t.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed,t.functionStartInOutputStream=this.functionStartInOutputStream,t}}t.Element=n;class i{constructor(){if(this.threadIndex=0,this.previousPointer=I.Null,this.callstack=[],arguments[0]&&arguments[1]){let t=arguments[0],i=arguments[1];this.threadIndex=parseInt(t.threadIndex);let r=t.callstack;for(let t of r){let r,a=t,s=parseInt(a.type),l=I.Null,o=a.cPath;if(void 0!==o){r=o.toString();let t=i.ContentAtPath(new e(r));if(l.container=t.container,l.index=parseInt(a.idx),null==t.obj)throw new Error("When loading state, internal story location couldn't be found: "+r+". Has the story changed since this save data was created?");if(t.approximate){if(null===l.container)return d("pointer.container");i.Warning("When loading state, exact internal story location couldn't be found: '"+r+"', so it was approximated to '"+l.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}let u=!!a.exp,h=new n(s,l,u),c=a.temp;void 0!==c?h.temporaryVariables=M.JObjectToDictionaryRuntimeObjs(c):h.temporaryVariables.clear(),this.callstack.push(h)}let a=t.previousContentObject;if(void 0!==a){let t=new e(a.toString());this.previousPointer=i.PointerAtPath(t)}}}Copy(){let t=new i;t.threadIndex=this.threadIndex;for(let e of this.callstack)t.callstack.push(e.Copy());return t.previousPointer=this.previousPointer.copy(),t}WriteJson(t){t.WriteObjectStart(),t.WritePropertyStart("callstack"),t.WriteArrayStart();for(let e of this.callstack){if(t.WriteObjectStart(),!e.currentPointer.isNull){if(null===e.currentPointer.container)return d("el.currentPointer.container");t.WriteProperty("cPath",e.currentPointer.container.path.componentsString),t.WriteIntProperty("idx",e.currentPointer.index)}t.WriteProperty("exp",e.inExpressionEvaluation),t.WriteIntProperty("type",e.type),e.temporaryVariables.size>0&&(t.WritePropertyStart("temp"),M.WriteDictionaryRuntimeObjs(t,e.temporaryVariables),t.WritePropertyEnd()),t.WriteObjectEnd()}if(t.WriteArrayEnd(),t.WritePropertyEnd(),t.WriteIntProperty("threadIndex",this.threadIndex),!this.previousPointer.isNull){let e=this.previousPointer.Resolve();if(null===e)return d("this.previousPointer.Resolve()");t.WriteProperty("previousContentObject",e.path.toString())}t.WriteObjectEnd()}}t.Thread=i}(q||(q={}));class J{constructor(t,e){this.variableChangedEventCallbacks=[],this.patch=null,this._batchObservingVariableChanges=!1,this._defaultGlobalVariables=new Map,this._changedVariablesForBatchObs=new Set,this._globalVariables=new Map,this._callStack=t,this._listDefsOrigin=e;try{return new Proxy(this,{get:(t,e)=>e in t?t[e]:t.$(e),set:(t,e,n)=>(e in t?t[e]=n:t.$(e,n),!0)})}catch(t){}}variableChangedEvent(t,e){for(let n of this.variableChangedEventCallbacks)n(t,e)}get batchObservingVariableChanges(){return this._batchObservingVariableChanges}set batchObservingVariableChanges(t){if(this._batchObservingVariableChanges=t,t)this._changedVariablesForBatchObs=new Set;else if(null!=this._changedVariablesForBatchObs){for(let t of this._changedVariablesForBatchObs){let e=this._globalVariables.get(t);e?this.variableChangedEvent(t,e):d("currentValue")}this._changedVariablesForBatchObs=null}}get callStack(){return this._callStack}set callStack(t){this._callStack=t}$(t,e){if(void 0===e){let e=null;return null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists)?e.result.valueObject:(e=this._globalVariables.get(t),void 0===e&&(e=this._defaultGlobalVariables.get(t)),void 0!==e?e.valueObject:null)}{if(void 0===this._defaultGlobalVariables.get(t))throw new S("Cannot assign to a variable ("+t+") that hasn't been declared in the story");let n=v.Create(e);if(null==n)throw new S(null==e?"Cannot pass null to VariableState":"Invalid value passed to VariableState: "+e.toString());this.SetGlobal(t,n)}}ApplyPatch(){if(null===this.patch)return d("this.patch");for(let[t,e]of this.patch.globals)this._globalVariables.set(t,e);if(null!==this._changedVariablesForBatchObs)for(let t of this.patch.changedVariables)this._changedVariablesForBatchObs.add(t);this.patch=null}SetJsonToken(t){this._globalVariables.clear();for(let[e,n]of this._defaultGlobalVariables){let i=t[e];if(void 0!==i){let t=M.JTokenToRuntimeObject(i);if(null===t)return d("tokenInkObject");this._globalVariables.set(e,t)}else this._globalVariables.set(e,n)}}WriteJson(t){t.WriteObjectStart();for(let[e,n]of this._globalVariables){let i=e,r=n;if(J.dontSaveDefaultValues&&this._defaultGlobalVariables.has(i)){let t=this._defaultGlobalVariables.get(i);if(this.RuntimeObjectsEqual(r,t))continue}t.WritePropertyStart(i),M.WriteRuntimeObject(t,r),t.WritePropertyEnd()}t.WriteObjectEnd()}RuntimeObjectsEqual(t,e){if(null===t)return d("obj1");if(null===e)return d("obj2");if(t.constructor!==e.constructor)return!1;let n=a(t,b);if(null!==n)return n.value===s(e,b).value;let i=a(t,_);if(null!==i)return i.value===s(e,_).value;let r=a(t,v),l=a(e,v);if(null!==r&&null!==l)return u(r.valueObject)&&u(l.valueObject)?r.valueObject.Equals(l.valueObject):r.valueObject===l.valueObject;throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: "+t.constructor.name)}GetVariableWithName(t,e=-1){let n=this.GetRawVariableWithName(t,e),i=a(n,w);return null!==i&&(n=this.ValueAtVariablePointer(i)),n}TryGetDefaultVariableValue(t){let e=y(this._defaultGlobalVariables,t,null);return e.exists?e.result:null}GlobalVariableExistsWithName(t){return this._globalVariables.has(t)||null!==this._defaultGlobalVariables&&this._defaultGlobalVariables.has(t)}GetRawVariableWithName(t,e){let n=null;if(0==e||-1==e){let e=null;if(null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists))return e.result;if(e=y(this._globalVariables,t,null),e.exists)return e.result;if(null!==this._defaultGlobalVariables&&(e=y(this._defaultGlobalVariables,t,null),e.exists))return e.result;if(null===this._listDefsOrigin)return d("VariablesState._listDefsOrigin");let n=this._listDefsOrigin.FindSingleItemListWithName(t);if(n)return n}return n=this._callStack.GetTemporaryVariableWithName(t,e),n}ValueAtVariablePointer(t){return this.GetVariableWithName(t.variableName,t.contextIndex)}Assign(t,e){let n=t.variableName;if(null===n)return d("name");let i=-1,r=!1;if(r=t.isNewDeclaration?t.isGlobal:this.GlobalVariableExistsWithName(n),t.isNewDeclaration){let t=a(e,w);if(null!==t){e=this.ResolveVariablePointer(t)}}else{let t=null;do{t=a(this.GetRawVariableWithName(n,i),w),null!=t&&(n=t.variableName,i=t.contextIndex,r=0==i)}while(null!=t)}r?this.SetGlobal(n,e):this._callStack.SetTemporaryVariable(n,e,t.isNewDeclaration,i)}SnapshotDefaultGlobals(){this._defaultGlobalVariables=new Map(this._globalVariables)}RetainListOriginsForAssignment(t,e){let n=s(t,O),i=s(e,O);n.value&&i.value&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames)}SetGlobal(t,e){let n=null;if(null===this.patch&&(n=y(this._globalVariables,t,null)),null!==this.patch&&(n=this.patch.TryGetGlobal(t,null),n.exists||(n=y(this._globalVariables,t,null))),O.RetainListOriginsForAssignment(n.result,e),null===t)return d("variableName");if(null!==this.patch?this.patch.SetGlobal(t,e):this._globalVariables.set(t,e),null!==this.variableChangedEvent&&null!==n&&e!==n.result)if(this.batchObservingVariableChanges){if(null===this._changedVariablesForBatchObs)return d("this._changedVariablesForBatchObs");null!==this.patch?this.patch.AddChangedVariable(t):null!==this._changedVariablesForBatchObs&&this._changedVariablesForBatchObs.add(t)}else this.variableChangedEvent(t,e)}ResolveVariablePointer(t){let e=t.contextIndex;-1==e&&(e=this.GetContextIndexOfVariableNamed(t.variableName));let n=a(this.GetRawVariableWithName(t.variableName,e),w);return null!=n?n:new w(t.variableName,e)}GetContextIndexOfVariableNamed(t){return this.GlobalVariableExistsWithName(t)?0:this._callStack.currentElementIndex}ObserveVariableChange(t){this.variableChangedEventCallbacks.push(t)}}J.dontSaveDefaultValues=!0;class K{constructor(t){this.seed=t%2147483647,this.seed<=0&&(this.seed+=2147483646)}next(){return this.seed=16807*this.seed%2147483647}nextFloat(){return(this.next()-1)/2147483646}}class U{constructor(){if(this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map,1===arguments.length&&null!==arguments[0]){let t=arguments[0];this._globals=new Map(t._globals),this._changedVariables=new Set(t._changedVariables),this._visitCounts=new Map(t._visitCounts),this._turnIndices=new Map(t._turnIndices)}else this._globals=new Map,this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map}get globals(){return this._globals}get changedVariables(){return this._changedVariables}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}TryGetGlobal(t,e){return null!==t&&this._globals.has(t)?{result:this._globals.get(t),exists:!0}:{result:e,exists:!1}}SetGlobal(t,e){this._globals.set(t,e)}AddChangedVariable(t){return this._changedVariables.add(t)}TryGetVisitCount(t,e){return this._visitCounts.has(t)?{result:this._visitCounts.get(t),exists:!0}:{result:e,exists:!1}}SetVisitCount(t,e){this._visitCounts.set(t,e)}SetTurnIndex(t,e){this._turnIndices.set(t,e)}TryGetTurnIndex(t,e){return this._turnIndices.has(t)?{result:this._turnIndices.get(t),exists:!0}:{result:e,exists:!1}}}class z{static TextToDictionary(t){return new z.Reader(t).ToDictionary()}static TextToArray(t){return new z.Reader(t).ToArray()}}!function(t){t.Reader=class{constructor(t){this._rootObject=JSON.parse(t)}ToDictionary(){return this._rootObject}ToArray(){return this._rootObject}};class e{constructor(){this._currentPropertyName=null,this._currentString=null,this._stateStack=[],this._collectionStack=[],this._propertyNameStack=[],this._jsonObject=null}WriteObject(t){this.WriteObjectStart(),t(this),this.WriteObjectEnd()}WriteObjectStart(){this.StartNewObject(!0);let e={};if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Object))}WriteObjectEnd(){this.Assert(this.state===t.Writer.State.Object),this._collectionStack.pop(),this._stateStack.pop()}WriteProperty(t,e){if(this.WritePropertyStart(t),arguments[1]instanceof Function){(0,arguments[1])(this)}else{let t=arguments[1];this.Write(t)}this.WritePropertyEnd()}WriteIntProperty(t,e){this.WritePropertyStart(t),this.WriteInt(e),this.WritePropertyEnd()}WriteFloatProperty(t,e){this.WritePropertyStart(t),this.WriteFloat(e),this.WritePropertyEnd()}WritePropertyStart(e){this.Assert(this.state===t.Writer.State.Object),this._propertyNameStack.push(e),this.IncrementChildCount(),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property))}WritePropertyEnd(){this.Assert(this.state===t.Writer.State.Property),this.Assert(1===this.childCount),this._stateStack.pop()}WritePropertyNameStart(){this.Assert(this.state===t.Writer.State.Object),this.IncrementChildCount(),this._currentPropertyName="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property)),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.PropertyName))}WritePropertyNameEnd(){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._propertyNameStack.push(this._currentPropertyName),this._currentPropertyName=null,this._stateStack.pop()}WritePropertyNameInner(e){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._currentPropertyName+=e}WriteArrayStart(){this.StartNewObject(!0);let e=[];if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Array))}WriteArrayEnd(){this.Assert(this.state===t.Writer.State.Array),this._collectionStack.pop(),this._stateStack.pop()}Write(t,e=!0){null!==t?(this.StartNewObject(!1),this._addToCurrentObject(t)):console.error("Warning: trying to write a null string")}WriteInt(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(Math.floor(t)))}WriteFloat(t){null!==t&&(this.StartNewObject(!1),t==Number.POSITIVE_INFINITY?this._addToCurrentObject(34e37):t==Number.NEGATIVE_INFINITY?this._addToCurrentObject(-34e37):isNaN(t)?this._addToCurrentObject(0):this._addToCurrentObject(t))}WriteNull(){this.StartNewObject(!1),this._addToCurrentObject(null)}WriteStringStart(){this.StartNewObject(!1),this._currentString="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.String))}WriteStringEnd(){this.Assert(this.state==t.Writer.State.String),this._stateStack.pop(),this._addToCurrentObject(this._currentString),this._currentString=null}WriteStringInner(e,n=!0){this.Assert(this.state===t.Writer.State.String),null!==e?this._currentString+=e:console.error("Warning: trying to write a null string")}ToString(){return null===this._jsonObject?"":JSON.stringify(this._jsonObject)}StartNewObject(e){e?this.Assert(this.state===t.Writer.State.None||this.state===t.Writer.State.Property||this.state===t.Writer.State.Array):this.Assert(this.state===t.Writer.State.Property||this.state===t.Writer.State.Array),this.state===t.Writer.State.Property&&this.Assert(0===this.childCount),this.state!==t.Writer.State.Array&&this.state!==t.Writer.State.Property||this.IncrementChildCount()}get state(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].type:t.Writer.State.None}get childCount(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].childCount:0}get currentCollection(){return this._collectionStack.length>0?this._collectionStack[this._collectionStack.length-1]:null}get currentPropertyName(){return this._propertyNameStack.length>0?this._propertyNameStack[this._propertyNameStack.length-1]:null}IncrementChildCount(){this.Assert(this._stateStack.length>0);let t=this._stateStack.pop();t.childCount++,this._stateStack.push(t)}Assert(t){if(!t)throw Error("Assert failed while writing JSON")}_addToCurrentObject(e){this.Assert(null!==this.currentCollection),this.state===t.Writer.State.Array?(this.Assert(Array.isArray(this.currentCollection)),this.currentCollection.push(e)):this.state===t.Writer.State.Property&&(this.Assert(!Array.isArray(this.currentCollection)),this.Assert(null!==this.currentPropertyName),this.currentCollection[this.currentPropertyName]=e,this._propertyNameStack.pop())}}t.Writer=e,function(e){let n;!function(t){t[t.None=0]="None",t[t.Object=1]="Object",t[t.Array=2]="Array",t[t.Property=3]="Property",t[t.PropertyName=4]="PropertyName",t[t.String=5]="String"}(n=e.State||(e.State={}));e.StateElement=class{constructor(e){this.type=t.Writer.State.None,this.childCount=0,this.type=e}}}(e=t.Writer||(t.Writer={}))}(z||(z={}));class H{constructor(t){this.kInkSaveStateVersion=8,this.kMinCompatibleLoadVersion=8,this._currentErrors=null,this._currentWarnings=null,this.divertedPointer=I.Null,this._currentTurnIndex=0,this.storySeed=0,this.previousRandom=0,this.didSafeExit=!1,this._currentText=null,this._currentTags=null,this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0,this._patch=null,this.story=t,this._outputStream=[],this.OutputStreamDirty(),this._evaluationStack=[],this.callStack=new q(t),this._variablesState=new J(this.callStack,t.listDefinitions),this._visitCounts=new Map,this._turnIndices=new Map,this.currentTurnIndex=-1;let e=(new Date).getTime();this.storySeed=new K(e).next()%100,this.previousRandom=0,this._currentChoices=[],this.GoToStart()}ToJson(t=!1){let e=new z.Writer;return this.WriteJson(e),e.ToString()}toJson(t=!1){return this.ToJson(t)}LoadJson(t){let e=z.TextToDictionary(t);this.LoadJsonObj(e)}VisitCountAtPathString(t){let n;if(null!==this._patch){let i=this.story.ContentAtPath(new e(t)).container;if(null===i)throw new Error("Content at path not found: "+t);if(n=this._patch.TryGetVisitCount(i,0),n.exists)return n.result}return n=y(this._visitCounts,t,null),n.exists?n.result:0}VisitCountForContainer(t){if(null===t)return d("container");if(!t.visitsShouldBeCounted)return this.story.Error("Read count for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),0;if(null!==this._patch){let e=this._patch.TryGetVisitCount(t,0);if(e.exists)return e.result}let e=t.path.toString(),n=y(this._visitCounts,e,null);return n.exists?n.result:0}IncrementVisitCountForContainer(t){if(null!==this._patch){let e=this.VisitCountForContainer(t);return e++,void this._patch.SetVisitCount(t,e)}let e=t.path.toString(),n=y(this._visitCounts,e,null);n.exists?this._visitCounts.set(e,n.result+1):this._visitCounts.set(e,1)}RecordTurnIndexVisitToContainer(t){if(null!==this._patch)return void this._patch.SetTurnIndex(t,this.currentTurnIndex);let e=t.path.toString();this._turnIndices.set(e,this.currentTurnIndex)}TurnsSinceForContainer(t){if(t.turnIndexShouldBeCounted||this.story.Error("TURNS_SINCE() for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),null!==this._patch){let e=this._patch.TryGetTurnIndex(t,0);if(e.exists)return this.currentTurnIndex-e.result}let e=t.path.toString(),n=y(this._turnIndices,e,0);return n.exists?this.currentTurnIndex-n.result:-1}get callstackDepth(){return this.callStack.depth}get outputStream(){return this._outputStream}get currentChoices(){return this.canContinue?[]:this._currentChoices}get generatedChoices(){return this._currentChoices}get currentErrors(){return this._currentErrors}get currentWarnings(){return this._currentWarnings}get variablesState(){return this._variablesState}set variablesState(t){this._variablesState=t}get evaluationStack(){return this._evaluationStack}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}get currentTurnIndex(){return this._currentTurnIndex}set currentTurnIndex(t){this._currentTurnIndex=t}get currentPathString(){let t=this.currentPointer;return t.isNull?null:null===t.path?d("pointer.path"):t.path.toString()}get currentPointer(){return this.callStack.currentElement.currentPointer.copy()}set currentPointer(t){this.callStack.currentElement.currentPointer=t.copy()}get previousPointer(){return this.callStack.currentThread.previousPointer.copy()}set previousPointer(t){this.callStack.currentThread.previousPointer=t.copy()}get canContinue(){return!this.currentPointer.isNull&&!this.hasError}get hasError(){return null!=this.currentErrors&&this.currentErrors.length>0}get hasWarning(){return null!=this.currentWarnings&&this.currentWarnings.length>0}get currentText(){if(this._outputStreamTextDirty){let t=new m;for(let e of this._outputStream){let n=a(e,T);null!==n&&t.Append(n.value)}this._currentText=this.CleanOutputWhitespace(t.toString()),this._outputStreamTextDirty=!1}return this._currentText}CleanOutputWhitespace(t){let e=new m,n=-1,i=0;for(let r=0;r<t.length;r++){let a=t.charAt(r),s=" "==a||"\t"==a;s&&-1==n&&(n=r),s||("\n"!=a&&n>0&&n!=i&&e.Append(" "),n=-1),"\n"==a&&(i=r+1),s||e.Append(a)}return e.toString()}get currentTags(){if(this._outputStreamTagsDirty){this._currentTags=[];for(let t of this._outputStream){let e=a(t,j);null!==e&&this._currentTags.push(e.text)}this._outputStreamTagsDirty=!1}return this._currentTags}get inExpressionEvaluation(){return this.callStack.currentElement.inExpressionEvaluation}set inExpressionEvaluation(t){this.callStack.currentElement.inExpressionEvaluation=t}GoToStart(){this.callStack.currentElement.currentPointer=I.StartOf(this.story.mainContentContainer)}CopyAndStartPatching(){let t=new H(this.story);return t._patch=new U(this._patch),t.outputStream.push.apply(t.outputStream,this._outputStream),t.OutputStreamDirty(),t._currentChoices.push.apply(t._currentChoices,this._currentChoices),this.hasError&&(t._currentErrors=[],t._currentErrors.push.apply(t._currentErrors,this.currentErrors||[])),this.hasWarning&&(t._currentWarnings=[],t._currentWarnings.push.apply(t._currentWarnings,this.currentWarnings||[])),t.callStack=new q(this.callStack),t.variablesState=this.variablesState,t.variablesState.callStack=t.callStack,t.variablesState.patch=t._patch,t.evaluationStack.push.apply(t.evaluationStack,this.evaluationStack),this.divertedPointer.isNull||(t.divertedPointer=this.divertedPointer.copy()),t.previousPointer=this.previousPointer.copy(),t._visitCounts=this._visitCounts,t._turnIndices=this._turnIndices,t.currentTurnIndex=this.currentTurnIndex,t.storySeed=this.storySeed,t.previousRandom=this.previousRandom,t.didSafeExit=this.didSafeExit,t}RestoreAfterPatch(){this.variablesState.callStack=this.callStack,this.variablesState.patch=this._patch}ApplyAnyPatch(){if(null!==this._patch){this.variablesState.ApplyPatch();for(let[t,e]of this._patch.visitCounts)this.ApplyCountChanges(t,e,!0);for(let[t,e]of this._patch.turnIndices)this.ApplyCountChanges(t,e,!1);this._patch=null}}ApplyCountChanges(t,e,n){(n?this._visitCounts:this._turnIndices).set(t.path.toString(),e)}WriteJson(t){t.WriteObjectStart();let e=!1;for(let n of this._currentChoices){if(null===n.threadAtGeneration)return d("c.threadAtGeneration");n.originalThreadIndex=n.threadAtGeneration.threadIndex,null===this.callStack.ThreadWithIndex(n.originalThreadIndex)&&(e||(e=!0,t.WritePropertyStart("choiceThreads"),t.WriteObjectStart()),t.WritePropertyStart(n.originalThreadIndex),n.threadAtGeneration.WriteJson(t),t.WritePropertyEnd())}if(e&&(t.WriteObjectEnd(),t.WritePropertyEnd()),t.WriteProperty("callstackThreads",t=>this.callStack.WriteJson(t)),t.WriteProperty("variablesState",t=>this.variablesState.WriteJson(t)),t.WriteProperty("evalStack",t=>M.WriteListRuntimeObjs(t,this.evaluationStack)),t.WriteProperty("outputStream",t=>M.WriteListRuntimeObjs(t,this._outputStream)),t.WriteProperty("currentChoices",t=>{t.WriteArrayStart();for(let e of this._currentChoices)M.WriteChoice(t,e);t.WriteArrayEnd()}),!this.divertedPointer.isNull){if(null===this.divertedPointer.path)return d("divertedPointer");t.WriteProperty("currentDivertTarget",this.divertedPointer.path.componentsString)}t.WriteProperty("visitCounts",t=>M.WriteIntDictionary(t,this._visitCounts)),t.WriteProperty("turnIndices",t=>M.WriteIntDictionary(t,this._turnIndices)),t.WriteIntProperty("turnIdx",this.currentTurnIndex),t.WriteIntProperty("storySeed",this.storySeed),t.WriteIntProperty("previousRandom",this.previousRandom),t.WriteIntProperty("inkSaveVersion",this.kInkSaveStateVersion),t.WriteIntProperty("inkFormatVersion",X.inkVersionCurrent),t.WriteObjectEnd()}LoadJsonObj(t){let n=t,i=n.inkSaveVersion;if(null==i)throw new S("ink save format incorrect, can't load.");if(parseInt(i)<this.kMinCompatibleLoadVersion)throw new S("Ink save format isn't compatible with the current version (saw '"+i+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.");this.callStack.SetJsonToken(n.callstackThreads,this.story),this.variablesState.SetJsonToken(n.variablesState),this._evaluationStack=M.JArrayToRuntimeObjList(n.evalStack),this._outputStream=M.JArrayToRuntimeObjList(n.outputStream),this.OutputStreamDirty(),this._currentChoices=M.JArrayToRuntimeObjList(n.currentChoices);let r=n.currentDivertTarget;if(null!=r){let t=new e(r.toString());this.divertedPointer=this.story.PointerAtPath(t)}this._visitCounts=M.JObjectToIntDictionary(n.visitCounts),this._turnIndices=M.JObjectToIntDictionary(n.turnIndices),this.currentTurnIndex=parseInt(n.turnIdx),this.storySeed=parseInt(n.storySeed),this.previousRandom=parseInt(n.previousRandom);let a=n.choiceThreads;for(let t of this._currentChoices){let e=this.callStack.ThreadWithIndex(t.originalThreadIndex);if(null!=e)t.threadAtGeneration=e.Copy();else{let e=a[t.originalThreadIndex.toString()];t.threadAtGeneration=new q.Thread(e,this.story)}}}ResetErrors(){this._currentErrors=null,this._currentWarnings=null}ResetOutput(t=null){this._outputStream.length=0,null!==t&&this._outputStream.push.apply(this._outputStream,t),this.OutputStreamDirty()}PushToOutputStream(t){let e=a(t,T);if(null!==e){let t=this.TrySplittingHeadTailWhitespace(e);if(null!==t){for(let e of t)this.PushToOutputStreamIndividual(e);return void this.OutputStreamDirty()}}this.PushToOutputStreamIndividual(t),this.OutputStreamDirty()}PopFromOutputStream(t){this.outputStream.splice(this.outputStream.length-t,t),this.OutputStreamDirty()}TrySplittingHeadTailWhitespace(t){let e=t.value;if(null===e)return d("single.value");let n=-1,i=-1;for(let t=0;t<e.length;++t){let r=e[t];if("\n"!=r){if(" "==r||"\t"==r)continue;break}-1==n&&(n=t),i=t}let r=-1,a=-1;for(let t=0;t<e.length;++t){let n=e[t];if("\n"!=n){if(" "==n||"\t"==n)continue;break}-1==r&&(r=t),a=t}if(-1==n&&-1==r)return null;let s=[],l=0,o=e.length;if(-1!=n){if(n>0){let t=new T(e.substring(0,n));s.push(t)}s.push(new T("\n")),l=i+1}if(-1!=r&&(o=a),o>l){let t=e.substring(l,o-l);s.push(new T(t))}if(-1!=r&&a>i&&(s.push(new T("\n")),r<e.length-1)){let t=e.length-r-1,n=new T(e.substring(r+1,t));s.push(n)}return s}PushToOutputStreamIndividual(t){let e=a(t,x),n=a(t,T),i=!0;if(e)this.TrimNewlinesFromOutputStream(),i=!0;else if(n){let t=-1,e=this.callStack.currentElement;e.type==r.Function&&(t=e.functionStartInOutputStream);let a=-1;for(let e=this._outputStream.length-1;e>=0;e--){let n=this._outputStream[e],i=n instanceof A?n:null;if(null!=(n instanceof x?n:null)){a=e;break}if(null!=i&&i.commandType==A.CommandType.BeginString){e>=t&&(t=-1);break}}let s=-1;if(s=-1!=a&&-1!=t?Math.min(t,a):-1!=a?a:t,-1!=s){if(n.isNewline)i=!1;else if(n.isNonWhitespace&&(a>-1&&this.RemoveExistingGlue(),t>-1)){let t=this.callStack.elements;for(let e=t.length-1;e>=0;e--){let n=t[e];if(n.type!=r.Function)break;n.functionStartInOutputStream=-1}}}else n.isNewline&&(!this.outputStreamEndsInNewline&&this.outputStreamContainsContent||(i=!1))}if(i){if(null===t)return d("obj");this._outputStream.push(t),this.OutputStreamDirty()}}TrimNewlinesFromOutputStream(){let t=-1,e=this._outputStream.length-1;for(;e>=0;){let n=this._outputStream[e],i=a(n,A),r=a(n,T);if(null!=i||null!=r&&r.isNonWhitespace)break;null!=r&&r.isNewline&&(t=e),e--}if(t>=0)for(e=t;e<this._outputStream.length;){a(this._outputStream[e],T)?this._outputStream.splice(e,1):e++}this.OutputStreamDirty()}RemoveExistingGlue(){for(let t=this._outputStream.length-1;t>=0;t--){let e=this._outputStream[t];if(e instanceof x)this._outputStream.splice(t,1);else if(e instanceof A)break}this.OutputStreamDirty()}get outputStreamEndsInNewline(){if(this._outputStream.length>0)for(let t=this._outputStream.length-1;t>=0;t--){if(this._outputStream[t]instanceof A)break;let e=this._outputStream[t];if(e instanceof T){if(e.isNewline)return!0;if(e.isNonWhitespace)break}}return!1}get outputStreamContainsContent(){for(let t=0;t<this._outputStream.length;t++)if(this._outputStream[t]instanceof T)return!0;return!1}get inStringEvaluation(){for(let t=this._outputStream.length-1;t>=0;t--){let e=a(this._outputStream[t],A);if(e instanceof A&&e.commandType==A.CommandType.BeginString)return!0}return!1}PushEvaluationStack(t){let e=a(t,O);if(e){let t=e.value;if(null===t)return d("rawList");if(null!=t.originNames){t.origins||(t.origins=[]),t.origins.length=0;for(let e of t.originNames){if(null===this.story.listDefinitions)return d("StoryState.story.listDefinitions");let n=this.story.listDefinitions.TryListGetDefinition(e,null);if(null===n.result)return d("StoryState def.result");t.origins.indexOf(n.result)<0&&t.origins.push(n.result)}}}if(null===t)return d("obj");this.evaluationStack.push(t)}PopEvaluationStack(t){if(void 0===t){return o(this.evaluationStack.pop())}if(t>this.evaluationStack.length)throw new Error("trying to pop too many objects");return o(this.evaluationStack.splice(this.evaluationStack.length-t,t))}PeekEvaluationStack(){return this.evaluationStack[this.evaluationStack.length-1]}ForceEnd(){this.callStack.Reset(),this._currentChoices.length=0,this.currentPointer=I.Null,this.previousPointer=I.Null,this.didSafeExit=!0}TrimWhitespaceFromFunctionEnd(){n.Assert(this.callStack.currentElement.type==r.Function);let t=this.callStack.currentElement.functionStartInOutputStream;-1==t&&(t=0);for(let e=this._outputStream.length-1;e>=t;e--){let t=this._outputStream[e],n=a(t,T),i=a(t,A);if(null!=n){if(i)break;if(!n.isNewline&&!n.isInlineWhitespace)break;this._outputStream.splice(e,1),this.OutputStreamDirty()}}}PopCallStack(t=null){this.callStack.currentElement.type==r.Function&&this.TrimWhitespaceFromFunctionEnd(),this.callStack.Pop(t)}SetChosenPath(t,e){this._currentChoices.length=0;let n=this.story.PointerAtPath(t);n.isNull||-1!=n.index||(n.index=0),this.currentPointer=n,e&&this.currentTurnIndex++}StartFunctionEvaluationFromGame(t,e){this.callStack.Push(r.FunctionEvaluationFromGame,this.evaluationStack.length),this.callStack.currentElement.currentPointer=I.StartOf(t),this.PassArgumentsToEvaluationStack(e)}PassArgumentsToEvaluationStack(t){if(null!=t)for(let e=0;e<t.length;e++){if("number"!=typeof t[e]&&"string"!=typeof t[e])throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");this.PushEvaluationStack(v.Create(t[e]))}}TryExitFunctionEvaluationFromGame(){return this.callStack.currentElement.type==r.FunctionEvaluationFromGame&&(this.currentPointer=I.Null,this.didSafeExit=!0,!0)}CompleteFunctionEvaluationFromGame(){if(this.callStack.currentElement.type!=r.FunctionEvaluationFromGame)throw new S("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace);let t=this.callStack.currentElement.evaluationStackHeightWhenPushed,e=null;for(;this.evaluationStack.length>t;){let t=this.PopEvaluationStack();null===e&&(e=t)}if(this.PopCallStack(r.FunctionEvaluationFromGame),e){if(e instanceof L)return null;let t=s(e,v);return t.valueType==i.DivertTarget?t.valueObject.toString():t.valueObject}return null}AddError(t,e){e?(null==this._currentWarnings&&(this._currentWarnings=[]),this._currentWarnings.push(t)):(null==this._currentErrors&&(this._currentErrors=[]),this._currentErrors.push(t))}OutputStreamDirty(){this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0}}class ${constructor(){this.startTime=void 0}get ElapsedMilliseconds(){return void 0===this.startTime?0:(new Date).getTime()-this.startTime}Start(){this.startTime=(new Date).getTime()}Stop(){this.startTime=void 0}}Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&t>-9007199254740992&&t<9007199254740992&&Math.floor(t)===t});class X extends p{constructor(){let t;super(),this.inkVersionMinimumCompatible=18,this._prevContainers=[],this.allowExternalFunctionFallbacks=!1,this._listDefinitions=null,this._variableObservers=null,this._hasValidatedExternals=!1,this._temporaryEvaluationContainer=null,this._asyncContinueActive=!1,this._stateSnapshotAtLastNewline=null,this._recursiveContinueCount=0,this._asyncSaving=!1,this._profiler=null;let e=null,n=null;if(arguments[0]instanceof N)t=arguments[0],void 0!==arguments[1]&&(e=arguments[1]),this._mainContentContainer=t;else if("string"==typeof arguments[0]){let t=arguments[0];n=z.TextToDictionary(t)}else n=arguments[0];if(null!=e&&(this._listDefinitions=new B(e)),this._externals=new Map,null!==n){let t=n,e=t.inkVersion;if(null==e)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");let i=parseInt(e);if(i>X.inkVersionCurrent)throw new Error("Version of ink used to build story was newer than the current version of the engine");if(i<this.inkVersionMinimumCompatible)throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");i!=X.inkVersionCurrent&&console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");let r,a=t.root;if(null==a)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");(r=t.listDefs)&&(this._listDefinitions=M.JTokenToListDefinitions(r)),this._mainContentContainer=s(M.JTokenToRuntimeObject(a),N),this.ResetState()}}get currentChoices(){let t=[];if(null===this._state)return d("this._state");for(let e of this._state.currentChoices)e.isInvisibleDefault||(e.index=t.length,t.push(e));return t}get currentText(){return this.IfAsyncWeCant("call currentText since it's a work in progress"),this.state.currentText}get currentTags(){return this.IfAsyncWeCant("call currentTags since it's a work in progress"),this.state.currentTags}get currentErrors(){return this.state.currentErrors}get currentWarnings(){return this.state.currentWarnings}get hasError(){return this.state.hasError}get hasWarning(){return this.state.hasWarning}get variablesState(){return this.state.variablesState}get listDefinitions(){return this._listDefinitions}get state(){return this._state}StartProfiling(){}EndProfiling(){}ToJson(t){let e=!1;if(t||(e=!0,t=new z.Writer),t.WriteObjectStart(),t.WriteIntProperty("inkVersion",X.inkVersionCurrent),t.WriteProperty("root",t=>M.WriteRuntimeContainer(t,this._mainContentContainer)),null!=this._listDefinitions){t.WritePropertyStart("listDefs"),t.WriteObjectStart();for(let e of this._listDefinitions.lists){t.WritePropertyStart(e.name),t.WriteObjectStart();for(let[n,i]of e.items){let e=f.fromSerializedKey(n),r=i;t.WriteIntProperty(e.itemName,r)}t.WriteObjectEnd(),t.WritePropertyEnd()}t.WriteObjectEnd(),t.WritePropertyEnd()}if(t.WriteObjectEnd(),e)return t.ToString()}ResetState(){this.IfAsyncWeCant("ResetState"),this._state=new H(this),this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this)),this.ResetGlobals()}ResetErrors(){if(null===this._state)return d("this._state");this._state.ResetErrors()}ResetCallstack(){if(this.IfAsyncWeCant("ResetCallstack"),null===this._state)return d("this._state");this._state.ForceEnd()}ResetGlobals(){if(this._mainContentContainer.namedContent.get("global decl")){let t=this.state.currentPointer.copy();this.ChoosePath(new e("global decl"),!1),this.ContinueInternal(),this.state.currentPointer=t}this.state.variablesState.SnapshotDefaultGlobals()}Continue(){return this.ContinueAsync(0),this.currentText}get canContinue(){return this.state.canContinue}get asyncContinueComplete(){return!this._asyncContinueActive}ContinueAsync(t){this._hasValidatedExternals||this.ValidateExternalBindings(),this.ContinueInternal(t)}ContinueInternal(t=0){null!=this._profiler&&this._profiler.PreContinue();let e=t>0;if(this._recursiveContinueCount++,!this._asyncContinueActive){if(this._asyncContinueActive=e,!this.canContinue)throw new S("Can't continue - should check canContinue before calling Continue");this._state.didSafeExit=!1,this._state.ResetOutput(),1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!0)}let n=new $;n.Start();let i=!1;do{try{i=this.ContinueSingleStep()}catch(t){if(!(t instanceof S))throw t;this.AddError(t.message,void 0,t.useEndLineNumber);break}if(i)break;if(this._asyncContinueActive&&n.ElapsedMilliseconds>t)break}while(this.canContinue);n.Stop(),!i&&this.canContinue||(null!==this._stateSnapshotAtLastNewline&&this.RestoreStateSnapshot(),this.canContinue||(this.state.callStack.canPopThread&&this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?"),0!=this.state.generatedChoices.length||this.state.didSafeExit||null!=this._temporaryEvaluationContainer||(this.state.callStack.CanPop(r.Tunnel)?this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?"):this.state.callStack.CanPop(r.Function)?this.AddError("unexpectedly reached end of content. Do you need a '~ return'?"):this.state.callStack.canPop?this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!"):this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?"))),this.state.didSafeExit=!1,1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!1),this._asyncContinueActive=!1),this._recursiveContinueCount--,null!=this._profiler&&this._profiler.PostContinue()}ContinueSingleStep(){if(null!=this._profiler&&this._profiler.PreStep(),this.Step(),null!=this._profiler&&this._profiler.PostStep(),this.canContinue||this.state.callStack.elementIsEvaluateFromGame||this.TryFollowDefaultInvisibleChoice(),null!=this._profiler&&this._profiler.PreSnapshot(),!this.state.inStringEvaluation){if(null!==this._stateSnapshotAtLastNewline){if(null===this._stateSnapshotAtLastNewline.currentTags)return d("this._stateAtLastNewline.currentTags");if(null===this.state.currentTags)return d("this.state.currentTags");let t=this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText,this.state.currentText,this._stateSnapshotAtLastNewline.currentTags.length,this.state.currentTags.length);if(t==X.OutputStateChange.ExtendedBeyondNewline)return this.RestoreStateSnapshot(),!0;t==X.OutputStateChange.NewlineRemoved&&this.DiscardSnapshot()}this.state.outputStreamEndsInNewline&&(this.canContinue?null==this._stateSnapshotAtLastNewline&&this.StateSnapshot():this.DiscardSnapshot())}return null!=this._profiler&&this._profiler.PostSnapshot(),!1}CalculateNewlineOutputStateChange(t,e,n,i){if(null===t)return d("prevText");if(null===e)return d("currText");let r=e.length>=t.length&&"\n"==e.charAt(t.length-1);if(n==i&&t.length==e.length&&r)return X.OutputStateChange.NoChange;if(!r)return X.OutputStateChange.NewlineRemoved;if(i>n)return X.OutputStateChange.ExtendedBeyondNewline;for(let n=t.length;n<e.length;n++){let t=e.charAt(n);if(" "!=t&&"\t"!=t)return X.OutputStateChange.ExtendedBeyondNewline}return X.OutputStateChange.NoChange}ContinueMaximally(){this.IfAsyncWeCant("ContinueMaximally");let t=new m;for(;this.canContinue;)t.Append(this.Continue());return t.toString()}ContentAtPath(t){return this.mainContentContainer.ContentAtPath(t)}KnotContainerWithName(t){let e=this.mainContentContainer.namedContent.get(t);return e instanceof N?e:null}PointerAtPath(t){if(0==t.length)return I.Null;let e=new I,n=t.length,i=null;return null===t.lastComponent?d("path.lastComponent"):(t.lastComponent.isIndex?(n=t.length-1,i=this.mainContentContainer.ContentAtPath(t,void 0,n),e.container=i.container,e.index=t.lastComponent.index):(i=this.mainContentContainer.ContentAtPath(t),e.container=i.container,e.index=-1),null==i.obj||i.obj==this.mainContentContainer&&n>0?this.Error("Failed to find content at path '"+t+"', and no approximation of it was possible."):i.approximate&&this.Warning("Failed to find content at path '"+t+"', so it was approximated to: '"+i.obj.path+"'."),e)}StateSnapshot(){this._stateSnapshotAtLastNewline=this._state,this._state=this._state.CopyAndStartPatching()}RestoreStateSnapshot(){null===this._stateSnapshotAtLastNewline&&d("_stateSnapshotAtLastNewline"),this._stateSnapshotAtLastNewline.RestoreAfterPatch(),this._state=this._stateSnapshotAtLastNewline,this._stateSnapshotAtLastNewline=null,this._asyncSaving||this._state.ApplyAnyPatch()}DiscardSnapshot(){this._asyncSaving||this._state.ApplyAnyPatch(),this._stateSnapshotAtLastNewline=null}CopyStateForBackgroundThreadSave(){if(this.IfAsyncWeCant("start saving on a background thread"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");let t=this._state;return this._state=this._state.CopyAndStartPatching(),this._asyncSaving=!0,t}BackgroundSaveComplete(){null===this._stateSnapshotAtLastNewline&&this._state.ApplyAnyPatch(),this._asyncSaving=!1}Step(){let t=!0,e=this.state.currentPointer.copy();if(e.isNull)return;let n=a(e.Resolve(),N);for(;n&&(this.VisitContainer(n,!0),0!=n.content.length);)e=I.StartOf(n),n=a(e.Resolve(),N);this.state.currentPointer=e.copy(),null!=this._profiler&&this._profiler.Step(this.state.callStack);let i=e.Resolve(),r=this.PerformLogicAndFlowControl(i);if(this.state.currentPointer.isNull)return;r&&(t=!1);let s=a(i,W);if(s){let e=this.ProcessChoice(s);e&&this.state.generatedChoices.push(e),i=null,t=!1}if(i instanceof N&&(t=!1),t){let t=a(i,w);if(t&&-1==t.contextIndex){let e=this.state.callStack.ContextForVariableNamed(t.variableName);i=new w(t.variableName,e)}this.state.inExpressionEvaluation?this.state.PushEvaluationStack(i):this.state.PushToOutputStream(i)}this.NextContent();let l=a(i,A);l&&l.commandType==A.CommandType.StartThread&&this.state.callStack.PushThread()}VisitContainer(t,e){t.countingAtStartOnly&&!e||(t.visitsShouldBeCounted&&this.state.IncrementVisitCountForContainer(t),t.turnIndexShouldBeCounted&&this.state.RecordTurnIndexVisitToContainer(t))}VisitChangedContainersDueToDivert(){let t=this.state.previousPointer.copy(),e=this.state.currentPointer.copy();if(e.isNull||-1==e.index)return;if(this._prevContainers.length=0,!t.isNull){let e=a(t.Resolve(),N)||a(t.container,N);for(;e;)this._prevContainers.push(e),e=a(e.parent,N)}let n=e.Resolve();if(null==n)return;let i=a(n.parent,N);for(;i&&(this._prevContainers.indexOf(i)<0||i.countingAtStartOnly);){let t=i.content.length>0&&n==i.content[0];this.VisitContainer(i,t),n=i,i=a(i.parent,N)}}ProcessChoice(t){let e=!0;if(t.hasCondition){let t=this.state.PopEvaluationStack();this.IsTruthy(t)||(e=!1)}let n="",i="";if(t.hasChoiceOnlyContent){i=s(this.state.PopEvaluationStack(),T).value||""}if(t.hasStartContent){n=s(this.state.PopEvaluationStack(),T).value||""}if(t.onceOnly){this.state.VisitCountForContainer(t.choiceTarget)>0&&(e=!1)}if(!e)return null;let r=new D;return r.targetPath=t.pathOnChoice,r.sourcePath=t.path.toString(),r.isInvisibleDefault=t.isInvisibleDefault,r.threadAtGeneration=this.state.callStack.ForkThread(),r.text=(n+i).replace(/^[ \t]+|[ \t]+$/g,""),r}IsTruthy(t){if(t instanceof v){let e=t;if(e instanceof P){let t=e;return this.Error("Shouldn't use a divert target (to "+t.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)"),!1}return e.isTruthy}return!1}PerformLogicAndFlowControl(t){if(null==t)return!1;if(t instanceof k){let e=t;if(e.isConditional){let t=this.state.PopEvaluationStack();if(!this.IsTruthy(t))return!0}if(e.hasVariableTarget){let t=e.variableDivertName,n=this.state.variablesState.GetVariableWithName(t);if(null==n)this.Error("Tried to divert using a target from a variable that could not be found ("+t+")");else if(!(n instanceof P)){let e=a(n,b),i="Tried to divert to a target from a variable, but the variable ("+t+") didn't contain a divert target, it ";e instanceof b&&0==e.value?i+="was empty/null (the value 0).":i+="contained '"+n+"'.",this.Error(i)}let i=s(n,P);this.state.divertedPointer=this.PointerAtPath(i.targetPath)}else{if(e.isExternal)return this.CallExternalFunction(e.targetPathString,e.externalArgs),!0;this.state.divertedPointer=e.targetPointer.copy()}return e.pushesToStack&&this.state.callStack.Push(e.stackPushType,void 0,this.state.outputStream.length),this.state.divertedPointer.isNull&&!e.isExternal&&(e&&e.debugMetadata&&null!=e.debugMetadata.sourceName?this.Error("Divert target doesn't exist: "+e.debugMetadata.sourceName):this.Error("Divert resolution failed: "+e)),!0}if(t instanceof A){let e=t;switch(e.commandType){case A.CommandType.EvalStart:this.Assert(!1===this.state.inExpressionEvaluation,"Already in expression evaluation?"),this.state.inExpressionEvaluation=!0;break;case A.CommandType.EvalEnd:this.Assert(!0===this.state.inExpressionEvaluation,"Not in expression evaluation mode"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EvalOutput:if(this.state.evaluationStack.length>0){let t=this.state.PopEvaluationStack();if(!(t instanceof L)){let e=new T(t.toString());this.state.PushToOutputStream(e)}}break;case A.CommandType.NoOp:break;case A.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case A.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case A.CommandType.PopFunction:case A.CommandType.PopTunnel:let t=e.commandType==A.CommandType.PopFunction?r.Function:r.Tunnel,n=null;if(t==r.Tunnel){let t=this.state.PopEvaluationStack();n=a(t,P),null===n&&this.Assert(t instanceof L,"Expected void if ->-> doesn't override target")}if(this.state.TryExitFunctionEvaluationFromGame())break;if(this.state.callStack.currentElement.type==t&&this.state.callStack.canPop)this.state.PopCallStack(),n&&(this.state.divertedPointer=this.PointerAtPath(n.targetPath));else{let e=new Map;e.set(r.Function,"function return statement (~ return)"),e.set(r.Tunnel,"tunnel onwards statement (->->)");let n=e.get(this.state.callStack.currentElement.type);this.state.callStack.canPop||(n="end of flow (-> END or choice)");let i="Found "+e.get(t)+", when expected "+n;this.Error(i)}break;case A.CommandType.BeginString:this.state.PushToOutputStream(e),this.Assert(!0===this.state.inExpressionEvaluation,"Expected to be in an expression when evaluating a string"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EndString:let i=[],l=0;for(let t=this.state.outputStream.length-1;t>=0;--t){let e=this.state.outputStream[t];l++;let n=a(e,A);if(n&&n.commandType==A.CommandType.BeginString)break;e instanceof T&&i.push(e)}this.state.PopFromOutputStream(l),i=i.reverse();let o=new m;for(let t of i)o.Append(t.toString());this.state.inExpressionEvaluation=!0,this.state.PushEvaluationStack(new T(o.toString()));break;case A.CommandType.ChoiceCount:let u=this.state.generatedChoices.length;this.state.PushEvaluationStack(new b(u));break;case A.CommandType.Turns:this.state.PushEvaluationStack(new b(this.state.currentTurnIndex+1));break;case A.CommandType.TurnsSince:case A.CommandType.ReadCount:let h=this.state.PopEvaluationStack();if(!(h instanceof P)){let t="";h instanceof b&&(t=". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?"),this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+h+t);break}let c,p=s(h,P),y=a(this.ContentAtPath(p.targetPath).correctObj,N);null!=y?c=e.commandType==A.CommandType.TurnsSince?this.state.TurnsSinceForContainer(y):this.state.VisitCountForContainer(y):(c=e.commandType==A.CommandType.TurnsSince?-1:0,this.Warning("Failed to find container for "+e.toString()+" lookup at "+p.targetPath.toString())),this.state.PushEvaluationStack(new b(c));break;case A.CommandType.Random:{let t=a(this.state.PopEvaluationStack(),b),e=a(this.state.PopEvaluationStack(),b);if(null==e||e instanceof b==!1)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(null==t||e instanceof b==!1)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(null===t.value)return d("maxInt.value");if(null===e.value)return d("minInt.value");let n=t.value-e.value+1;n<=0&&this.Error("RANDOM was called with minimum as "+e.value+" and maximum as "+t.value+". The maximum must be larger");let i=this.state.storySeed+this.state.previousRandom,r=new K(i).next(),s=r%n+e.value;this.state.PushEvaluationStack(new b(s)),this.state.previousRandom=r;break}case A.CommandType.SeedRandom:let C=a(this.state.PopEvaluationStack(),b);if(null==C||C instanceof b==!1)return this.Error("Invalid value passed to SEED_RANDOM");if(null===C.value)return d("minInt.value");this.state.storySeed=C.value,this.state.previousRandom=0,this.state.PushEvaluationStack(new L);break;case A.CommandType.VisitIndex:let _=this.state.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new b(_));break;case A.CommandType.SequenceShuffleIndex:let w=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new b(w));break;case A.CommandType.StartThread:break;case A.CommandType.Done:this.state.callStack.canPopThread?this.state.callStack.PopThread():(this.state.didSafeExit=!0,this.state.currentPointer=I.Null);break;case A.CommandType.End:this.state.ForceEnd();break;case A.CommandType.ListFromInt:let E=a(this.state.PopEvaluationStack(),b),x=s(this.state.PopEvaluationStack(),T);if(null===E)throw new S("Passed non-integer when creating a list element from a numerical value.");let k=null;if(null===this.listDefinitions)return d("this.listDefinitions");let W=this.listDefinitions.TryListGetDefinition(x.value,null);if(!W.exists)throw new S("Failed to find LIST called "+x.value);{if(null===E.value)return d("minInt.value");let t=W.result.TryGetItemWithValue(E.value,f.Null);t.exists&&(k=new O(t.result,E.value))}null==k&&(k=new O),this.state.PushEvaluationStack(k);break;case A.CommandType.ListRange:let F=a(this.state.PopEvaluationStack(),v),V=a(this.state.PopEvaluationStack(),v),R=a(this.state.PopEvaluationStack(),O);if(null===R||null===V||null===F)throw new S("Expected list, minimum and maximum for LIST_RANGE");if(null===R.value)return d("targetList.value");let j=R.value.ListWithSubRange(V.valueObject,F.valueObject);this.state.PushEvaluationStack(new O(j));break;case A.CommandType.ListRandom:{let t=this.state.PopEvaluationStack();if(null===t)throw new S("Expected list for LIST_RANDOM");let e=t.value,n=null;if(null===e)throw d("list");if(0==e.Count)n=new g;else{let t=this.state.storySeed+this.state.previousRandom,i=new K(t).next(),r=i%e.Count,a=e.entries();for(let t=0;t<=r-1;t++)a.next();let s=a.next().value,l={Key:f.fromSerializedKey(s[0]),Value:s[1]};if(null===l.Key.originName)return d("randomItem.Key.originName");n=new g(l.Key.originName,this),n.Add(l.Key,l.Value),this.state.previousRandom=i}this.state.PushEvaluationStack(new O(n));break}default:this.Error("unhandled ControlCommand: "+e)}return!0}if(t instanceof V){let e=t,n=this.state.PopEvaluationStack();return this.state.variablesState.Assign(e,n),!0}if(t instanceof F){let e=t,n=null;if(null!=e.pathForCount){let t=e.containerForCount,i=this.state.VisitCountForContainer(t);n=new b(i)}else n=this.state.variablesState.GetVariableWithName(e.name),null==n&&(this.Warning("Variable not found: '"+e.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state."),n=new b(0));return this.state.PushEvaluationStack(n),!0}if(t instanceof R){let e=t,n=this.state.PopEvaluationStack(e.numberOfParameters),i=e.Call(n);return this.state.PushEvaluationStack(i),!0}return!1}ChoosePathString(t,n=!0,i=[]){if(this.IfAsyncWeCant("call ChoosePathString right now"),n)this.ResetCallstack();else if(this.state.callStack.currentElement.type==r.Function){let e="",n=this.state.callStack.currentElement.currentPointer.container;throw null!=n&&(e="("+n.path.toString()+") "),new Error("Story was running a function "+e+"when you called ChoosePathString("+t+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}this.state.PassArgumentsToEvaluationStack(i),this.ChoosePath(new e(t))}IfAsyncWeCant(t){if(this._asyncContinueActive)throw new Error("Can't "+t+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}ChoosePath(t,e=!0){this.state.SetChosenPath(t,e),this.VisitChangedContainersDueToDivert()}ChooseChoiceIndex(t){t=t;let e=this.currentChoices;this.Assert(t>=0&&t<e.length,"choice out of range");let n=e[t];return null===n.threadAtGeneration?d("choiceToChoose.threadAtGeneration"):null===n.targetPath?d("choiceToChoose.targetPath"):(this.state.callStack.currentThread=n.threadAtGeneration,void this.ChoosePath(n.targetPath))}HasFunction(t){try{return null!=this.KnotContainerWithName(t)}catch(t){return!1}}EvaluateFunction(t,e=[],n=!1){if(this.IfAsyncWeCant("evaluate a function"),null==t)throw new Error("Function is null");if(""==t||""==t.trim())throw new Error("Function is empty or white space.");let i=this.KnotContainerWithName(t);if(null==i)throw new Error("Function doesn't exist: '"+t+"'");let r=[];r.push.apply(r,this.state.outputStream),this._state.ResetOutput(),this.state.StartFunctionEvaluationFromGame(i,e);let a=new m;for(;this.canContinue;)a.Append(this.Continue());let s=a.toString();this._state.ResetOutput(r);let l=this.state.CompleteFunctionEvaluationFromGame();return n?{returned:l,output:s}:l}EvaluateExpression(t){let e=this.state.callStack.elements.length;this.state.callStack.Push(r.Tunnel),this._temporaryEvaluationContainer=t,this.state.GoToStart();let n=this.state.evaluationStack.length;return this.Continue(),this._temporaryEvaluationContainer=null,this.state.callStack.elements.length>e&&this.state.PopCallStack(),this.state.evaluationStack.length>n?this.state.PopEvaluationStack():null}CallExternalFunction(t,e){if(null===t)return d("funcName");let n=this._externals.get(t),i=null;if(!(void 0!==n)){if(this.allowExternalFunctionFallbacks)return i=this.KnotContainerWithName(t),this.Assert(null!==i,"Trying to call EXTERNAL function '"+t+"' which has not been bound, and fallback ink function could not be found."),this.state.callStack.Push(r.Function,void 0,this.state.outputStream.length),void(this.state.divertedPointer=I.StartOf(i));this.Assert(!1,"Trying to call EXTERNAL function '"+t+"' which has not been bound (and ink fallbacks disabled).")}let a=[];for(let t=0;t<e;++t){let t=s(this.state.PopEvaluationStack(),v).valueObject;a.push(t)}a.reverse();let l=n(a),o=null;null!=l?(o=v.Create(l),this.Assert(null!==o,"Could not create ink value from returned object of type "+typeof l)):o=new L,this.state.PushEvaluationStack(o)}BindExternalFunctionGeneral(t,e){this.IfAsyncWeCant("bind an external function"),this.Assert(!this._externals.has(t),"Function '"+t+"' has already been bound."),this._externals.set(t,e)}TryCoerce(t){return t}BindExternalFunction(t,e){this.Assert(null!=e,"Can't bind a null function"),this.BindExternalFunctionGeneral(t,t=>{this.Assert(t.length>=e.length,"External function expected "+e.length+" arguments");let n=[];for(let e=0,i=t.length;e<i;e++)n[e]=this.TryCoerce(t[e]);return e.apply(null,n)})}UnbindExternalFunction(t){this.IfAsyncWeCant("unbind an external a function"),this.Assert(this._externals.has(t),"Function '"+t+"' has not been bound."),this._externals.delete(t)}ValidateExternalBindings(){let t=null,e=null,n=arguments[1]||new Set;if(arguments[0]instanceof N&&(t=arguments[0]),arguments[0]instanceof p&&(e=arguments[0]),null===t&&null===e)if(this.ValidateExternalBindings(this._mainContentContainer,n),this._hasValidatedExternals=!0,0==n.size)this._hasValidatedExternals=!0;else{let t="Error: Missing function binding for external";t+=n.size>1?"s":"",t+=": '",t+=Array.from(n).join("', '"),t+="' ",t+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)",this.Error(t)}else if(null!=t){for(let e of t.content){let t=e;null!=t&&t.hasValidName||this.ValidateExternalBindings(e,n)}for(let[,e]of t.namedContent)this.ValidateExternalBindings(a(e,p),n)}else if(null!=e){let t=a(e,k);if(t&&t.isExternal){let e=t.targetPathString;if(null===e)return d("name");if(!this._externals.has(e))if(this.allowExternalFunctionFallbacks){this.mainContentContainer.namedContent.has(e)||n.add(e)}else n.add(e)}}}ObserveVariable(t,e){if(this.IfAsyncWeCant("observe a new variable"),null===this._variableObservers&&(this._variableObservers=new Map),!this.state.variablesState.GlobalVariableExistsWithName(t))throw new S("Cannot observe variable '"+t+"' because it wasn't declared in the ink story.");this._variableObservers.has(t)?this._variableObservers.get(t).push(e):this._variableObservers.set(t,[e])}ObserveVariables(t,e){for(let n=0,i=t.length;n<i;n++)this.ObserveVariable(t[n],e[n])}RemoveVariableObserver(t,e){if(this.IfAsyncWeCant("remove a variable observer"),null!==this._variableObservers)if(void 0!==e){if(this._variableObservers.has(e)){let n=this._variableObservers.get(e);null!==t?n.splice(n.indexOf(t),1):this._variableObservers.delete(e)}}else if(null!==t){let e=this._variableObservers.keys();for(let n of e){let e=this._variableObservers.get(n);e.splice(e.indexOf(t),1)}}}VariableStateDidChangeEvent(t,e){if(null===this._variableObservers)return;let n=this._variableObservers.get(t);if(void 0!==n){if(!(e instanceof v))throw new Error("Tried to get the value of a variable that isn't a standard type");let i=s(e,v);for(let e of n)e(t,i.valueObject)}}get globalTags(){return this.TagsAtStartOfFlowContainerWithPathString("")}TagsForContentAtPath(t){return this.TagsAtStartOfFlowContainerWithPathString(t)}TagsAtStartOfFlowContainerWithPathString(t){let n=new e(t),i=this.ContentAtPath(n).container;if(null===i)return d("flowContainer");for(;;){let t=i.content[0];if(!(t instanceof N))break;i=t}let r=null;for(let t of i.content){let e=a(t,j);if(!e)break;null==r&&(r=[]),r.push(e.text)}return r}BuildStringOfHierarchy(){let t=new m;return this.mainContentContainer.BuildStringOfHierarchy(t,0,this.state.currentPointer.Resolve()),t.toString()}BuildStringOfContainer(t){let e=new m;return t.BuildStringOfHierarchy(e,0,this.state.currentPointer.Resolve()),e.toString()}NextContent(){if(this.state.previousPointer=this.state.currentPointer.copy(),!this.state.divertedPointer.isNull&&(this.state.currentPointer=this.state.divertedPointer.copy(),this.state.divertedPointer=I.Null,this.VisitChangedContainersDueToDivert(),!this.state.currentPointer.isNull))return;if(!this.IncrementContentPointer()){let t=!1;this.state.callStack.CanPop(r.Function)?(this.state.PopCallStack(r.Function),this.state.inExpressionEvaluation&&this.state.PushEvaluationStack(new L),t=!0):this.state.callStack.canPopThread?(this.state.callStack.PopThread(),t=!0):this.state.TryExitFunctionEvaluationFromGame(),t&&!this.state.currentPointer.isNull&&this.NextContent()}}IncrementContentPointer(){let t=!0,e=this.state.callStack.currentElement.currentPointer.copy();if(e.index++,null===e.container)return d("pointer.container");for(;e.index>=e.container.content.length;){t=!1;let n=a(e.container.parent,N);if(n instanceof N==!1)break;let i=n.content.indexOf(e.container);if(-1==i)break;if(e=new I(n,i),e.index++,t=!0,null===e.container)return d("pointer.container")}return t||(e=I.Null),this.state.callStack.currentElement.currentPointer=e.copy(),t}TryFollowDefaultInvisibleChoice(){let t=this._state.currentChoices,e=t.filter(t=>t.isInvisibleDefault);if(0==e.length||t.length>e.length)return!1;let n=e[0];return null===n.targetPath?d("choice.targetPath"):null===n.threadAtGeneration?d("choice.threadAtGeneration"):(this.state.callStack.currentThread=n.threadAtGeneration,this.ChoosePath(n.targetPath,!1),!0)}NextSequenceShuffleIndex(){let t=a(this.state.PopEvaluationStack(),b);if(!(t instanceof b))return this.Error("expected number of elements in sequence for shuffle index"),0;let e=this.state.currentPointer.container;if(null===e)return d("seqContainer");if(null===t.value)return d("numElementsIntVal.value");let n=t.value,i=s(this.state.PopEvaluationStack(),b).value;if(null===i)return d("seqCount");let r=i/n,l=i%n,o=e.path.toString(),u=0;for(let t=0,e=o.length;t<e;t++)u+=o.charCodeAt(t)||0;let h=u+r+this.state.storySeed,c=new K(Math.floor(h)),p=[];for(let t=0;t<n;++t)p.push(t);for(let t=0;t<=l;++t){let e=c.next()%p.length,n=p[e];if(p.splice(e,1),t==l)return n}throw new Error("Should never reach here")}Error(t,e=!1){let n=new S(t);throw n.useEndLineNumber=e,n}Warning(t){this.AddError(t,!0)}AddError(t,e=!1,n=!1){let i=this.currentDebugMetadata,r=e?"WARNING":"ERROR";if(null!=i){let e=n?i.endLineNumber:i.startLineNumber;t="RUNTIME "+r+": '"+i.fileName+"' line "+e+": "+t}else t=this.state.currentPointer.isNull?"RUNTIME "+r+": "+t:"RUNTIME "+r+": ("+this.state.currentPointer+"): "+t;this.state.AddError(t,e),e||this.state.ForceEnd()}Assert(t,e=null){if(0==t)throw null==e&&(e="Story assert"),new Error(e+" "+this.currentDebugMetadata)}get currentDebugMetadata(){let t,e=this.state.currentPointer;if(!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let n=this.state.callStack.elements.length-1;n>=0;--n)if(e=this.state.callStack.elements[n].currentPointer,!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let e=this.state.outputStream.length-1;e>=0;--e){if(t=this.state.outputStream[e].debugMetadata,null!==t)return t}return null}get mainContentContainer(){return this._temporaryEvaluationContainer?this._temporaryEvaluationContainer:this._mainContentContainer}}X.inkVersionCurrent=19,function(t){let e;!function(t){t[t.NoChange=0]="NoChange",t[t.ExtendedBeyondNewline=1]="ExtendedBeyondNewline",t[t.NewlineRemoved=2]="NewlineRemoved"}(e=t.OutputStateChange||(t.OutputStateChange={}))}(X||(X={})),t.InkList=g,t.Story=X,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=ink-es2015.js.map


/***/ }),

/***/ "./node_modules/inkjs/engine/CallStack.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/CallStack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStack = void 0;
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class CallStack {
    constructor() {
        this._threadCounter = 0;
        this._startOfRoot = Pointer_1.Pointer.Null;
        if (arguments[0] instanceof Story_1.Story) {
            let storyContext = arguments[0];
            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
            this.Reset();
        }
        else {
            let toCopy = arguments[0];
            this._threads = [];
            for (let otherThread of toCopy._threads) {
                this._threads.push(otherThread.Copy());
            }
            this._threadCounter = toCopy._threadCounter;
            this._startOfRoot = toCopy._startOfRoot;
        }
    }
    get elements() {
        return this.callStack;
    }
    get depth() {
        return this.elements.length;
    }
    get currentElement() {
        let thread = this._threads[this._threads.length - 1];
        let cs = thread.callstack;
        return cs[cs.length - 1];
    }
    get currentElementIndex() {
        return this.callStack.length - 1;
    }
    get currentThread() {
        return this._threads[this._threads.length - 1];
    }
    set currentThread(value) {
        Debug_1.Debug.Assert(this._threads.length == 1, "Shouldn't be directly setting the current thread when we have a stack of them");
        this._threads.length = 0;
        this._threads.push(value);
    }
    get canPop() {
        return this.callStack.length > 1;
    }
    Reset() {
        this._threads = [];
        this._threads.push(new CallStack.Thread());
        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));
    }
    SetJsonToken(jObject, storyContext) {
        this._threads.length = 0;
        // TODO: (List<object>) jObject ["threads"];
        let jThreads = jObject["threads"];
        for (let jThreadTok of jThreads) {
            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;
            let jThreadObj = jThreadTok;
            let thread = new CallStack.Thread(jThreadObj, storyContext);
            this._threads.push(thread);
        }
        // TODO: (int)jObject ["threadCounter"];
        this._threadCounter = parseInt(jObject["threadCounter"]);
        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
    }
    WriteJson(w) {
        w.WriteObject((writer) => {
            writer.WritePropertyStart("threads");
            writer.WriteArrayStart();
            for (let thread of this._threads) {
                thread.WriteJson(writer);
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WritePropertyStart("threadCounter");
            writer.WriteInt(this._threadCounter);
            writer.WritePropertyEnd();
        });
    }
    PushThread() {
        let newThread = this.currentThread.Copy();
        this._threadCounter++;
        newThread.threadIndex = this._threadCounter;
        this._threads.push(newThread);
    }
    ForkThread() {
        let forkedThread = this.currentThread.Copy();
        this._threadCounter++;
        forkedThread.threadIndex = this._threadCounter;
        return forkedThread;
    }
    PopThread() {
        if (this.canPopThread) {
            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()
        }
        else {
            throw new Error("Can't pop thread");
        }
    }
    get canPopThread() {
        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;
    }
    get elementIsEvaluateFromGame() {
        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;
    }
    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {
        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);
        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;
        element.functionStartInOutputStream = outputStreamLengthWithPushed;
        this.callStack.push(element);
    }
    CanPop(type = null) {
        if (!this.canPop)
            return false;
        if (type == null)
            return true;
        return this.currentElement.type == type;
    }
    Pop(type = null) {
        if (this.CanPop(type)) {
            this.callStack.pop();
            return;
        }
        else {
            throw new Error("Mismatched push/pop in Callstack");
        }
    }
    GetTemporaryVariableWithName(name, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        let varValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (varValue.exists) {
            return varValue.result;
        }
        else {
            return null;
        }
    }
    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        if (!declareNew && !contextElement.temporaryVariables.get(name)) {
            throw new StoryException_1.StoryException("Could not find temporary variable to set: " + name);
        }
        let oldValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (oldValue.exists)
            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        contextElement.temporaryVariables.set(name, value);
    }
    ContextForVariableNamed(name) {
        if (this.currentElement.temporaryVariables.get(name)) {
            return this.currentElementIndex + 1;
        }
        else {
            return 0;
        }
    }
    ThreadWithIndex(index) {
        let filtered = this._threads.filter((t) => {
            if (t.threadIndex == index)
                return t;
        });
        return filtered.length > 0 ? filtered[0] : null;
    }
    get callStack() {
        return this.currentThread.callstack;
    }
    get callStackTrace() {
        let sb = new StringBuilder_1.StringBuilder();
        for (let t = 0; t < this._threads.length; t++) {
            let thread = this._threads[t];
            let isCurrent = t == this._threads.length - 1;
            sb.AppendFormat("=== THREAD {0}/{1} {2}===\n", t + 1, this._threads.length, isCurrent ? "(current) " : "");
            for (let i = 0; i < thread.callstack.length; i++) {
                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)
                    sb.Append("  [FUNCTION] ");
                else
                    sb.Append("  [TUNNEL] ");
                let pointer = thread.callstack[i].currentPointer;
                if (!pointer.isNull) {
                    sb.Append("<SOMEWHERE IN ");
                    if (pointer.container === null) {
                        return NullException_1.throwNullException("pointer.container");
                    }
                    sb.Append(pointer.container.path.toString());
                    sb.AppendLine(">");
                }
            }
        }
        return sb.toString();
    }
}
exports.CallStack = CallStack;
(function (CallStack) {
    class Element {
        constructor(type, pointer, inExpressionEvaluation = false) {
            this.evaluationStackHeightWhenPushed = 0;
            this.functionStartInOutputStream = 0;
            this.currentPointer = pointer.copy();
            this.inExpressionEvaluation = inExpressionEvaluation;
            this.temporaryVariables = new Map();
            this.type = type;
        }
        Copy() {
            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);
            copy.temporaryVariables = new Map(this.temporaryVariables);
            copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;
            copy.functionStartInOutputStream = this.functionStartInOutputStream;
            return copy;
        }
    }
    CallStack.Element = Element;
    class Thread {
        constructor() {
            this.threadIndex = 0;
            this.previousPointer = Pointer_1.Pointer.Null;
            this.callstack = [];
            if (arguments[0] && arguments[1]) {
                let jThreadObj = arguments[0];
                let storyContext = arguments[1];
                // TODO: (int) jThreadObj['threadIndex'] can raise;
                this.threadIndex = parseInt(jThreadObj["threadIndex"]);
                let jThreadCallstack = jThreadObj["callstack"];
                for (let jElTok of jThreadCallstack) {
                    let jElementObj = jElTok;
                    // TODO: (int) jElementObj['type'] can raise;
                    let pushPopType = parseInt(jElementObj["type"]);
                    let pointer = Pointer_1.Pointer.Null;
                    let currentContainerPathStr;
                    // TODO: jElementObj.TryGetValue ("cPath", out currentContainerPathStrToken);
                    let currentContainerPathStrToken = jElementObj["cPath"];
                    if (typeof currentContainerPathStrToken !== "undefined") {
                        currentContainerPathStr = currentContainerPathStrToken.toString();
                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));
                        pointer.container = threadPointerResult.container;
                        pointer.index = parseInt(jElementObj["idx"]);
                        if (threadPointerResult.obj == null)
                            throw new Error("When loading state, internal story location couldn't be found: " +
                                currentContainerPathStr +
                                ". Has the story changed since this save data was created?");
                        else if (threadPointerResult.approximate) {
                            if (pointer.container === null) {
                                return NullException_1.throwNullException("pointer.container");
                            }
                            storyContext.Warning("When loading state, exact internal story location couldn't be found: '" +
                                currentContainerPathStr +
                                "', so it was approximated to '" +
                                pointer.container.path.toString() +
                                "' to recover. Has the story changed since this save data was created?");
                        }
                    }
                    let inExpressionEvaluation = !!jElementObj["exp"];
                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);
                    let temps = jElementObj["temp"];
                    if (typeof temps !== "undefined") {
                        el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);
                    }
                    else {
                        el.temporaryVariables.clear();
                    }
                    this.callstack.push(el);
                }
                let prevContentObjPath = jThreadObj["previousContentObject"];
                if (typeof prevContentObjPath !== "undefined") {
                    let prevPath = new Path_1.Path(prevContentObjPath.toString());
                    this.previousPointer = storyContext.PointerAtPath(prevPath);
                }
            }
        }
        Copy() {
            let copy = new Thread();
            copy.threadIndex = this.threadIndex;
            for (let e of this.callstack) {
                copy.callstack.push(e.Copy());
            }
            copy.previousPointer = this.previousPointer.copy();
            return copy;
        }
        WriteJson(writer) {
            writer.WriteObjectStart();
            writer.WritePropertyStart("callstack");
            writer.WriteArrayStart();
            for (let el of this.callstack) {
                writer.WriteObjectStart();
                if (!el.currentPointer.isNull) {
                    if (el.currentPointer.container === null) {
                        return NullException_1.throwNullException("el.currentPointer.container");
                    }
                    writer.WriteProperty("cPath", el.currentPointer.container.path.componentsString);
                    writer.WriteIntProperty("idx", el.currentPointer.index);
                }
                writer.WriteProperty("exp", el.inExpressionEvaluation);
                writer.WriteIntProperty("type", el.type);
                if (el.temporaryVariables.size > 0) {
                    writer.WritePropertyStart("temp");
                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);
                    writer.WritePropertyEnd();
                }
                writer.WriteObjectEnd();
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WriteIntProperty("threadIndex", this.threadIndex);
            if (!this.previousPointer.isNull) {
                let resolvedPointer = this.previousPointer.Resolve();
                if (resolvedPointer === null) {
                    return NullException_1.throwNullException("this.previousPointer.Resolve()");
                }
                writer.WriteProperty("previousContentObject", resolvedPointer.path.toString());
            }
            writer.WriteObjectEnd();
        }
    }
    CallStack.Thread = Thread;
})(CallStack = exports.CallStack || (exports.CallStack = {}));
//# sourceMappingURL=CallStack.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Choice.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Choice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Choice = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Choice extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.text = "";
        this.index = 0;
        this.threadAtGeneration = null;
        this.sourcePath = "";
        this.targetPath = null;
        this.isInvisibleDefault = false;
        this.originalThreadIndex = 0;
    }
    get pathStringOnChoice() {
        if (this.targetPath === null)
            return NullException_1.throwNullException("Choice.targetPath");
        return this.targetPath.toString();
    }
    set pathStringOnChoice(value) {
        this.targetPath = new Path_1.Path(value);
    }
}
exports.Choice = Choice;
//# sourceMappingURL=Choice.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ChoicePoint.js":
/*!**************************************************!*\
  !*** ./node_modules/inkjs/engine/ChoicePoint.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoicePoint = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ChoicePoint extends Object_1.InkObject {
    constructor(onceOnly = true) {
        super();
        this._pathOnChoice = null;
        this.hasCondition = false;
        this.hasStartContent = false;
        this.hasChoiceOnlyContent = false;
        this.isInvisibleDefault = false;
        this.onceOnly = true;
        this.onceOnly = onceOnly;
    }
    get pathOnChoice() {
        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {
            let choiceTargetObj = this.choiceTarget;
            if (choiceTargetObj) {
                this._pathOnChoice = choiceTargetObj.path;
            }
        }
        return this._pathOnChoice;
    }
    set pathOnChoice(value) {
        this._pathOnChoice = value;
    }
    get choiceTarget() {
        if (this._pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint._pathOnChoice");
        return this.ResolvePath(this._pathOnChoice).container;
    }
    get pathStringOnChoice() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        return this.CompactPathString(this.pathOnChoice);
    }
    set pathStringOnChoice(value) {
        this.pathOnChoice = new Path_1.Path(value);
    }
    get flags() {
        let flags = 0;
        if (this.hasCondition)
            flags |= 1;
        if (this.hasStartContent)
            flags |= 2;
        if (this.hasChoiceOnlyContent)
            flags |= 4;
        if (this.isInvisibleDefault)
            flags |= 8;
        if (this.onceOnly)
            flags |= 16;
        return flags;
    }
    set flags(value) {
        this.hasCondition = (value & 1) > 0;
        this.hasStartContent = (value & 2) > 0;
        this.hasChoiceOnlyContent = (value & 4) > 0;
        this.isInvisibleDefault = (value & 8) > 0;
        this.onceOnly = (value & 16) > 0;
    }
    toString() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);
        let targetLineNum = null;
        let targetString = this.pathOnChoice.toString();
        if (targetLineNum != null) {
            targetString = " line " + targetLineNum + "(" + targetString + ")";
        }
        return "Choice: -> " + targetString;
    }
}
exports.ChoicePoint = ChoicePoint;
//# sourceMappingURL=ChoicePoint.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Container.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/Container.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const SearchResult_1 = __webpack_require__(/*! ./SearchResult */ "./node_modules/inkjs/engine/SearchResult.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
class Container extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.name = "";
        this._content = [];
        this.namedContent = new Map();
        this.visitsShouldBeCounted = false;
        this.turnIndexShouldBeCounted = false;
        this.countingAtStartOnly = false;
        this._pathToFirstLeafContent = null;
    }
    get hasValidName() {
        return this.name != null && this.name.length > 0;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this.AddContent(value);
    }
    get namedOnlyContent() {
        let namedOnlyContentDict = new Map();
        for (let [key, value] of this.namedContent) {
            let inkObject = TypeAssertion_1.asOrThrows(value, Object_1.InkObject);
            namedOnlyContentDict.set(key, inkObject);
        }
        for (let c of this.content) {
            let named = TypeAssertion_1.asINamedContentOrNull(c);
            if (named != null && named.hasValidName) {
                namedOnlyContentDict.delete(named.name);
            }
        }
        if (namedOnlyContentDict.size == 0)
            namedOnlyContentDict = null;
        return namedOnlyContentDict;
    }
    set namedOnlyContent(value) {
        let existingNamedOnly = this.namedOnlyContent;
        if (existingNamedOnly != null) {
            for (let [key] of existingNamedOnly) {
                this.namedContent.delete(key);
            }
        }
        if (value == null)
            return;
        for (let [, val] of value) {
            let named = TypeAssertion_1.asINamedContentOrNull(val);
            if (named != null)
                this.AddToNamedContentOnly(named);
        }
    }
    get countFlags() {
        let flags = 0;
        if (this.visitsShouldBeCounted)
            flags |= Container.CountFlags.Visits;
        if (this.turnIndexShouldBeCounted)
            flags |= Container.CountFlags.Turns;
        if (this.countingAtStartOnly)
            flags |= Container.CountFlags.CountStartOnly;
        if (flags == Container.CountFlags.CountStartOnly) {
            flags = 0;
        }
        return flags;
    }
    set countFlags(value) {
        let flag = value;
        if ((flag & Container.CountFlags.Visits) > 0)
            this.visitsShouldBeCounted = true;
        if ((flag & Container.CountFlags.Turns) > 0)
            this.turnIndexShouldBeCounted = true;
        if ((flag & Container.CountFlags.CountStartOnly) > 0)
            this.countingAtStartOnly = true;
    }
    get pathToFirstLeafContent() {
        if (this._pathToFirstLeafContent == null)
            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);
        return this._pathToFirstLeafContent;
    }
    get internalPathToFirstLeafContent() {
        let components = [];
        let container = this;
        while (container instanceof Container) {
            if (container.content.length > 0) {
                components.push(new Path_1.Path.Component(0));
                container = container.content[0];
            }
        }
        return new Path_1.Path(components);
    }
    AddContent(contentObjOrList) {
        if (contentObjOrList instanceof Array) {
            let contentList = contentObjOrList;
            for (let c of contentList) {
                this.AddContent(c);
            }
        }
        else {
            let contentObj = contentObjOrList;
            this._content.push(contentObj);
            if (contentObj.parent) {
                throw new Error("content is already in " + contentObj.parent);
            }
            contentObj.parent = this;
            this.TryAddNamedContent(contentObj);
        }
    }
    TryAddNamedContent(contentObj) {
        let namedContentObj = TypeAssertion_1.asINamedContentOrNull(contentObj);
        if (namedContentObj != null && namedContentObj.hasValidName) {
            this.AddToNamedContentOnly(namedContentObj);
        }
    }
    AddToNamedContentOnly(namedContentObj) {
        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, "Can only add Runtime.Objects to a Runtime.Container");
        let runtimeObj = TypeAssertion_1.asOrThrows(namedContentObj, Object_1.InkObject);
        runtimeObj.parent = this;
        this.namedContent.set(namedContentObj.name, namedContentObj);
    }
    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {
        if (partialPathLength == -1)
            partialPathLength = path.length;
        let result = new SearchResult_1.SearchResult();
        result.approximate = false;
        let currentContainer = this;
        let currentObj = this;
        for (let i = partialPathStart; i < partialPathLength; ++i) {
            let comp = path.GetComponent(i);
            if (currentContainer == null) {
                result.approximate = true;
                break;
            }
            let foundObj = currentContainer.ContentWithPathComponent(comp);
            if (foundObj == null) {
                result.approximate = true;
                break;
            }
            currentObj = foundObj;
            currentContainer = TypeAssertion_1.asOrNull(foundObj, Container);
        }
        result.obj = currentObj;
        return result;
    }
    InsertContent(contentObj, index) {
        this.content[index] = contentObj;
        if (contentObj.parent) {
            throw new Error("content is already in " + contentObj.parent);
        }
        contentObj.parent = this;
        this.TryAddNamedContent(contentObj);
    }
    AddContentsOfContainer(otherContainer) {
        this.content = this.content.concat(otherContainer.content);
        for (let obj of otherContainer.content) {
            obj.parent = this;
            this.TryAddNamedContent(obj);
        }
    }
    ContentWithPathComponent(component) {
        if (component.isIndex) {
            if (component.index >= 0 && component.index < this.content.length) {
                return this.content[component.index];
            }
            else {
                return null;
            }
        }
        else if (component.isParent) {
            return this.parent;
        }
        else {
            if (component.name === null) {
                return NullException_1.throwNullException("component.name");
            }
            let foundContent = TryGetResult_1.tryGetValueFromMap(this.namedContent, component.name, null);
            if (foundContent.exists) {
                return TypeAssertion_1.asOrThrows(foundContent.result, Object_1.InkObject);
            }
            else {
                return null;
            }
        }
    }
    BuildStringOfHierarchy() {
        let sb;
        if (arguments.length == 0) {
            sb = new StringBuilder_1.StringBuilder();
            this.BuildStringOfHierarchy(sb, 0, null);
            return sb.toString();
        }
        sb = arguments[0];
        let indentation = arguments[1];
        let pointedObj = arguments[2];
        function appendIndentation() {
            const spacesPerIndent = 4; // Truly const in the original code
            for (let i = 0; i < spacesPerIndent * indentation; ++i) {
                sb.Append(" ");
            }
        }
        appendIndentation();
        sb.Append("[");
        if (this.hasValidName) {
            sb.AppendFormat(" ({0})", this.name);
        }
        if (this == pointedObj) {
            sb.Append("  <---");
        }
        sb.AppendLine();
        indentation++;
        for (let i = 0; i < this.content.length; ++i) {
            let obj = this.content[i];
            if (obj instanceof Container) {
                let container = obj;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
            }
            else {
                appendIndentation();
                if (obj instanceof Value_1.StringValue) {
                    sb.Append('"');
                    sb.Append(obj.toString().replace("\n", "\\n"));
                    sb.Append('"');
                }
                else {
                    sb.Append(obj.toString());
                }
            }
            if (i != this.content.length - 1) {
                sb.Append(",");
            }
            if (!(obj instanceof Container) && obj == pointedObj) {
                sb.Append("  <---");
            }
            sb.AppendLine();
        }
        let onlyNamed = new Map();
        for (let [key, value] of this.namedContent) {
            if (this.content.indexOf(TypeAssertion_1.asOrThrows(value, Object_1.InkObject)) >= 0) {
                continue;
            }
            else {
                onlyNamed.set(key, value);
            }
        }
        if (onlyNamed.size > 0) {
            appendIndentation();
            sb.AppendLine("-- named: --");
            for (let [, value] of onlyNamed) {
                Debug_1.Debug.AssertType(value, Container, "Can only print out named Containers");
                let container = value;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
                sb.AppendLine();
            }
        }
        indentation--;
        appendIndentation();
        sb.Append("]");
    }
}
exports.Container = Container;
(function (Container) {
    let CountFlags;
    (function (CountFlags) {
        CountFlags[CountFlags["Visits"] = 1] = "Visits";
        CountFlags[CountFlags["Turns"] = 2] = "Turns";
        CountFlags[CountFlags["CountStartOnly"] = 4] = "CountStartOnly";
    })(CountFlags = Container.CountFlags || (Container.CountFlags = {}));
})(Container = exports.Container || (exports.Container = {}));
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ControlCommand.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ControlCommand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlCommand = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class ControlCommand extends Object_1.InkObject {
    constructor(commandType = ControlCommand.CommandType.NotSet) {
        super();
        this._commandType = commandType;
    }
    get commandType() {
        return this._commandType;
    }
    Copy() {
        return new ControlCommand(this.commandType);
    }
    static EvalStart() {
        return new ControlCommand(ControlCommand.CommandType.EvalStart);
    }
    static EvalOutput() {
        return new ControlCommand(ControlCommand.CommandType.EvalOutput);
    }
    static EvalEnd() {
        return new ControlCommand(ControlCommand.CommandType.EvalEnd);
    }
    static Duplicate() {
        return new ControlCommand(ControlCommand.CommandType.Duplicate);
    }
    static PopEvaluatedValue() {
        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);
    }
    static PopFunction() {
        return new ControlCommand(ControlCommand.CommandType.PopFunction);
    }
    static PopTunnel() {
        return new ControlCommand(ControlCommand.CommandType.PopTunnel);
    }
    static BeginString() {
        return new ControlCommand(ControlCommand.CommandType.BeginString);
    }
    static EndString() {
        return new ControlCommand(ControlCommand.CommandType.EndString);
    }
    static NoOp() {
        return new ControlCommand(ControlCommand.CommandType.NoOp);
    }
    static ChoiceCount() {
        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);
    }
    static Turns() {
        return new ControlCommand(ControlCommand.CommandType.Turns);
    }
    static TurnsSince() {
        return new ControlCommand(ControlCommand.CommandType.TurnsSince);
    }
    static ReadCount() {
        return new ControlCommand(ControlCommand.CommandType.ReadCount);
    }
    static Random() {
        return new ControlCommand(ControlCommand.CommandType.Random);
    }
    static SeedRandom() {
        return new ControlCommand(ControlCommand.CommandType.SeedRandom);
    }
    static VisitIndex() {
        return new ControlCommand(ControlCommand.CommandType.VisitIndex);
    }
    static SequenceShuffleIndex() {
        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);
    }
    static StartThread() {
        return new ControlCommand(ControlCommand.CommandType.StartThread);
    }
    static Done() {
        return new ControlCommand(ControlCommand.CommandType.Done);
    }
    static End() {
        return new ControlCommand(ControlCommand.CommandType.End);
    }
    static ListFromInt() {
        return new ControlCommand(ControlCommand.CommandType.ListFromInt);
    }
    static ListRange() {
        return new ControlCommand(ControlCommand.CommandType.ListRange);
    }
    static ListRandom() {
        return new ControlCommand(ControlCommand.CommandType.ListRandom);
    }
    toString() {
        return this.commandType.toString();
    }
}
exports.ControlCommand = ControlCommand;
(function (ControlCommand) {
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["NotSet"] = -1] = "NotSet";
        CommandType[CommandType["EvalStart"] = 0] = "EvalStart";
        CommandType[CommandType["EvalOutput"] = 1] = "EvalOutput";
        CommandType[CommandType["EvalEnd"] = 2] = "EvalEnd";
        CommandType[CommandType["Duplicate"] = 3] = "Duplicate";
        CommandType[CommandType["PopEvaluatedValue"] = 4] = "PopEvaluatedValue";
        CommandType[CommandType["PopFunction"] = 5] = "PopFunction";
        CommandType[CommandType["PopTunnel"] = 6] = "PopTunnel";
        CommandType[CommandType["BeginString"] = 7] = "BeginString";
        CommandType[CommandType["EndString"] = 8] = "EndString";
        CommandType[CommandType["NoOp"] = 9] = "NoOp";
        CommandType[CommandType["ChoiceCount"] = 10] = "ChoiceCount";
        CommandType[CommandType["Turns"] = 11] = "Turns";
        CommandType[CommandType["TurnsSince"] = 12] = "TurnsSince";
        CommandType[CommandType["Random"] = 13] = "Random";
        CommandType[CommandType["SeedRandom"] = 14] = "SeedRandom";
        CommandType[CommandType["VisitIndex"] = 15] = "VisitIndex";
        CommandType[CommandType["SequenceShuffleIndex"] = 16] = "SequenceShuffleIndex";
        CommandType[CommandType["StartThread"] = 17] = "StartThread";
        CommandType[CommandType["Done"] = 18] = "Done";
        CommandType[CommandType["End"] = 19] = "End";
        CommandType[CommandType["ListFromInt"] = 20] = "ListFromInt";
        CommandType[CommandType["ListRange"] = 21] = "ListRange";
        CommandType[CommandType["ListRandom"] = 22] = "ListRandom";
        CommandType[CommandType["ReadCount"] = 23] = "ReadCount";
        CommandType[CommandType["TOTAL_VALUES"] = 24] = "TOTAL_VALUES";
    })(CommandType = ControlCommand.CommandType || (ControlCommand.CommandType = {}));
})(ControlCommand = exports.ControlCommand || (exports.ControlCommand = {}));
//# sourceMappingURL=ControlCommand.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Debug.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Debug.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Debug = void 0;
var Debug;
(function (Debug) {
    function AssertType(variable, type, message) {
        Assert(variable instanceof type, message);
    }
    Debug.AssertType = AssertType;
    function Assert(condition, message) {
        if (!condition) {
            if (typeof message !== "undefined") {
                console.warn(message);
            }
            if (console.trace) {
                console.trace();
            }
            throw new Error("");
        }
    }
    Debug.Assert = Assert;
})(Debug = exports.Debug || (exports.Debug = {}));
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Divert.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Divert.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Divert = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class Divert extends Object_1.InkObject {
    constructor(stackPushType) {
        super();
        this._targetPath = null;
        this._targetPointer = Pointer_1.Pointer.Null;
        this.variableDivertName = null;
        this.pushesToStack = false;
        this.stackPushType = 0;
        this.isExternal = false;
        this.externalArgs = 0;
        this.isConditional = false;
        this.pushesToStack = false;
        if (typeof stackPushType !== "undefined") {
            this.pushesToStack = true;
            this.stackPushType = stackPushType;
        }
    }
    get targetPath() {
        if (this._targetPath != null && this._targetPath.isRelative) {
            let targetObj = this.targetPointer.Resolve();
            if (targetObj) {
                this._targetPath = targetObj.path;
            }
        }
        return this._targetPath;
    }
    set targetPath(value) {
        this._targetPath = value;
        this._targetPointer = Pointer_1.Pointer.Null;
    }
    get targetPointer() {
        if (this._targetPointer.isNull) {
            let targetObj = this.ResolvePath(this._targetPath).obj;
            if (this._targetPath === null)
                return NullException_1.throwNullException("this._targetPath");
            if (this._targetPath.lastComponent === null)
                return NullException_1.throwNullException("this._targetPath.lastComponent");
            if (this._targetPath.lastComponent.isIndex) {
                if (targetObj === null)
                    return NullException_1.throwNullException("targetObj");
                this._targetPointer.container =
                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;
                this._targetPointer.index = this._targetPath.lastComponent.index;
            }
            else {
                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);
            }
        }
        return this._targetPointer.copy();
    }
    get targetPathString() {
        if (this.targetPath == null)
            return null;
        return this.CompactPathString(this.targetPath);
    }
    set targetPathString(value) {
        if (value == null) {
            this.targetPath = null;
        }
        else {
            this.targetPath = new Path_1.Path(value);
        }
    }
    get hasVariableTarget() {
        return this.variableDivertName != null;
    }
    Equals(obj) {
        let otherDivert = obj;
        if (otherDivert instanceof Divert) {
            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {
                if (this.hasVariableTarget) {
                    return this.variableDivertName == otherDivert.variableDivertName;
                }
                else {
                    if (this.targetPath === null)
                        return NullException_1.throwNullException("this.targetPath");
                    return this.targetPath.Equals(otherDivert.targetPath);
                }
            }
        }
        return false;
    }
    toString() {
        if (this.hasVariableTarget) {
            return "Divert(variable: " + this.variableDivertName + ")";
        }
        else if (this.targetPath == null) {
            return "Divert(null)";
        }
        else {
            let sb = new StringBuilder_1.StringBuilder();
            let targetStr = this.targetPath.toString();
            // int? targetLineNum = DebugLineNumberOfPath (targetPath);
            let targetLineNum = null;
            if (targetLineNum != null) {
                targetStr = "line " + targetLineNum;
            }
            sb.Append("Divert");
            if (this.isConditional)
                sb.Append("?");
            if (this.pushesToStack) {
                if (this.stackPushType == PushPop_1.PushPopType.Function) {
                    sb.Append(" function");
                }
                else {
                    sb.Append(" tunnel");
                }
            }
            sb.Append(" -> ");
            sb.Append(this.targetPathString);
            sb.Append(" (");
            sb.Append(targetStr);
            sb.Append(")");
            return sb.toString();
        }
    }
}
exports.Divert = Divert;
//# sourceMappingURL=Divert.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Glue.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Glue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Glue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Glue extends Object_1.InkObject {
    toString() {
        return "Glue";
    }
}
exports.Glue = Glue;
//# sourceMappingURL=Glue.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/InkList.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/InkList.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkList = exports.InkListItem = void 0;
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
class InkListItem {
    constructor() {
        // InkListItem is a struct
        this.originName = null;
        this.itemName = null;
        if (typeof arguments[1] !== "undefined") {
            let originName = arguments[0];
            let itemName = arguments[1];
            this.originName = originName;
            this.itemName = itemName;
        }
        else if (arguments[0]) {
            let fullName = arguments[0];
            let nameParts = fullName.toString().split(".");
            this.originName = nameParts[0];
            this.itemName = nameParts[1];
        }
    }
    static get Null() {
        return new InkListItem(null, null);
    }
    get isNull() {
        return this.originName == null && this.itemName == null;
    }
    get fullName() {
        return ((this.originName !== null ? this.originName : "?") + "." + this.itemName);
    }
    toString() {
        return this.fullName;
    }
    Equals(obj) {
        if (obj instanceof InkListItem) {
            let otherItem = obj;
            return (otherItem.itemName == this.itemName &&
                otherItem.originName == this.originName);
        }
        return false;
    }
    // These methods did not exist in the original C# code. Their purpose is to
    // make `InkListItem` mimics the value-type semantics of the original
    // struct. Please refer to the end of this file, for a more in-depth
    // explanation.
    /**
     * Returns a shallow clone of the current instance.
     */
    copy() {
        return new InkListItem(this.originName, this.itemName);
    }
    /**
     * Returns a `SerializedInkListItem` representing the current
     * instance. The result is intended to be used as a key inside a Map.
     */
    serialized() {
        // We are simply using a JSON representation as a value-typed key.
        return JSON.stringify({
            originName: this.originName,
            itemName: this.itemName,
        });
    }
    /**
     * Reconstructs a `InkListItem` from the given SerializedInkListItem.
     */
    static fromSerializedKey(key) {
        let obj = JSON.parse(key);
        if (!InkListItem.isLikeInkListItem(obj))
            return InkListItem.Null;
        let inkListItem = obj;
        return new InkListItem(inkListItem.originName, inkListItem.itemName);
    }
    /**
     * Determines whether the given item is sufficiently `InkListItem`-like
     * to be used as a template when reconstructing the InkListItem.
     */
    static isLikeInkListItem(item) {
        if (typeof item !== "object")
            return false;
        if (!item.hasOwnProperty("originName") || !item.hasOwnProperty("itemName"))
            return false;
        if (typeof item.originName !== "string" && typeof item.originName !== null)
            return false;
        if (typeof item.itemName !== "string" && typeof item.itemName !== null)
            return false;
        return true;
    }
}
exports.InkListItem = InkListItem;
class InkList extends Map {
    constructor() {
        // Trying to be smart here, this emulates the constructor inheritance found
        // in the original code, but only if otherList is an InkList. IIFE FTW.
        super((() => {
            if (arguments[0] instanceof InkList) {
                return arguments[0];
            }
            else {
                return [];
            }
        })());
        this.origins = null;
        this._originNames = [];
        if (arguments[0] instanceof InkList) {
            let otherList = arguments[0];
            if (otherList._originNames) {
                this._originNames = otherList._originNames.slice();
            }
        }
        else if (typeof arguments[0] === "string") {
            let singleOriginListName = arguments[0];
            let originStory = arguments[1]; /* as Story */
            this.SetInitialOriginName(singleOriginListName);
            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);
            if (def.exists) {
                this.origins = [def.result];
            }
            else {
                throw new Error("InkList origin could not be found in story when constructing new list: " +
                    singleOriginListName);
            }
        }
        else if (typeof arguments[0] === "object" &&
            arguments[0].hasOwnProperty("Key") &&
            arguments[0].hasOwnProperty("Value")) {
            let singleElement = arguments[0];
            this.Add(singleElement.Key, singleElement.Value);
        }
    }
    AddItem(itemOrItemName) {
        if (itemOrItemName instanceof InkListItem) {
            let item = itemOrItemName;
            if (item.originName == null) {
                this.AddItem(item.itemName);
                return;
            }
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (origin.name == item.originName) {
                    let intVal = origin.TryGetValueForItem(item, 0);
                    if (intVal.exists) {
                        this.Add(item, intVal.result);
                        return;
                    }
                    else {
                        throw new Error("Could not add the item " +
                            item +
                            " to this list because it doesn't exist in the original list definition in ink.");
                    }
                }
            }
            throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.");
        }
        else {
            let itemName = itemOrItemName;
            let foundListDef = null;
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (itemName === null)
                    return NullException_1.throwNullException("itemName");
                if (origin.ContainsItemWithName(itemName)) {
                    if (foundListDef != null) {
                        throw new Error("Could not add the item " +
                            itemName +
                            " to this list because it could come from either " +
                            origin.name +
                            " or " +
                            foundListDef.name);
                    }
                    else {
                        foundListDef = origin;
                    }
                }
            }
            if (foundListDef == null)
                throw new Error("Could not add the item " +
                    itemName +
                    " to this list because it isn't known to any list definitions previously associated with this list.");
            let item = new InkListItem(foundListDef.name, itemName);
            let itemVal = foundListDef.ValueForItem(item);
            this.Add(item, itemVal);
        }
    }
    ContainsItemNamed(itemName) {
        for (let [key] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (item.itemName == itemName)
                return true;
        }
        return false;
    }
    ContainsKey(key) {
        return this.has(key.serialized());
    }
    Add(key, value) {
        let serializedKey = key.serialized();
        if (this.has(serializedKey)) {
            // Throw an exception to match the C# behavior.
            throw new Error(`The Map already contains an entry for ${key}`);
        }
        this.set(serializedKey, value);
    }
    Remove(key) {
        return this.delete(key.serialized());
    }
    get Count() {
        return this.size;
    }
    get originOfMaxItem() {
        if (this.origins == null)
            return null;
        let maxOriginName = this.maxItem.Key.originName;
        let result = null;
        this.origins.every((origin) => {
            if (origin.name == maxOriginName) {
                result = origin;
                return false;
            }
            else
                return true;
        });
        return result;
    }
    get originNames() {
        if (this.Count > 0) {
            if (this._originNames == null && this.Count > 0)
                this._originNames = [];
            else {
                if (!this._originNames)
                    this._originNames = [];
                this._originNames.length = 0;
            }
            for (let [key] of this) {
                let item = InkListItem.fromSerializedKey(key);
                if (item.originName === null)
                    return NullException_1.throwNullException("item.originName");
                this._originNames.push(item.originName);
            }
        }
        return this._originNames;
    }
    SetInitialOriginName(initialOriginName) {
        this._originNames = [initialOriginName];
    }
    SetInitialOriginNames(initialOriginNames) {
        if (initialOriginNames == null)
            this._originNames = null;
        else
            this._originNames = initialOriginNames.slice(); // store a copy
    }
    get maxItem() {
        let max = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (max.Key.isNull || value > max.Value)
                max = { Key: item, Value: value };
        }
        return max;
    }
    get minItem() {
        let min = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (min.Key.isNull || value < min.Value) {
                min = { Key: item, Value: value };
            }
        }
        return min;
    }
    get inverse() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    if (!this.ContainsKey(item))
                        list.Add(item, value);
                }
            }
        }
        return list;
    }
    get all() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    list.set(item.serialized(), value);
                }
            }
        }
        return list;
    }
    Union(otherList) {
        let union = new InkList(this);
        for (let [key, value] of otherList) {
            union.set(key, value);
        }
        return union;
    }
    Intersect(otherList) {
        let intersection = new InkList();
        for (let [key, value] of this) {
            if (otherList.has(key))
                intersection.set(key, value);
        }
        return intersection;
    }
    Without(listToRemove) {
        let result = new InkList(this);
        for (let [key] of listToRemove) {
            result.delete(key);
        }
        return result;
    }
    Contains(otherList) {
        for (let [key] of otherList) {
            if (!this.has(key))
                return false;
        }
        return true;
    }
    GreaterThan(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return this.minItem.Value > otherList.maxItem.Value;
    }
    GreaterThanOrEquals(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return (this.minItem.Value >= otherList.minItem.Value &&
            this.maxItem.Value >= otherList.maxItem.Value);
    }
    LessThan(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return this.maxItem.Value < otherList.minItem.Value;
    }
    LessThanOrEquals(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return (this.maxItem.Value <= otherList.maxItem.Value &&
            this.minItem.Value <= otherList.minItem.Value);
    }
    MaxAsList() {
        if (this.Count > 0)
            return new InkList(this.maxItem);
        else
            return new InkList();
    }
    MinAsList() {
        if (this.Count > 0)
            return new InkList(this.minItem);
        else
            return new InkList();
    }
    ListWithSubRange(minBound, maxBound) {
        if (this.Count == 0)
            return new InkList();
        let ordered = this.orderedItems;
        let minValue = 0;
        let maxValue = Number.MAX_SAFE_INTEGER;
        if (Number.isInteger(minBound)) {
            minValue = minBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                minValue = minBound.minItem.Value;
        }
        if (Number.isInteger(maxBound)) {
            maxValue = maxBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                maxValue = maxBound.maxItem.Value;
        }
        let subList = new InkList();
        subList.SetInitialOriginNames(this.originNames);
        for (let item of ordered) {
            if (item.Value >= minValue && item.Value <= maxValue) {
                subList.Add(item.Key, item.Value);
            }
        }
        return subList;
    }
    Equals(otherInkList) {
        if (otherInkList instanceof InkList === false)
            return false;
        if (otherInkList.Count != this.Count)
            return false;
        for (let [key] of this) {
            if (!otherInkList.has(key))
                return false;
        }
        return true;
    }
    // GetHashCode not implemented
    get orderedItems() {
        // List<KeyValuePair<InkListItem, int>>
        let ordered = new Array();
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            ordered.push({ Key: item, Value: value });
        }
        ordered.sort((x, y) => {
            if (x.Key.originName === null) {
                return NullException_1.throwNullException("x.Key.originName");
            }
            if (y.Key.originName === null) {
                return NullException_1.throwNullException("y.Key.originName");
            }
            if (x.Value == y.Value) {
                return x.Key.originName.localeCompare(y.Key.originName);
            }
            else {
                // TODO: refactor this bit into a numberCompareTo method?
                if (x.Value < y.Value)
                    return -1;
                return x.Value > y.Value ? 1 : 0;
            }
        });
        return ordered;
    }
    toString() {
        let ordered = this.orderedItems;
        let sb = new StringBuilder_1.StringBuilder();
        for (let i = 0; i < ordered.length; i++) {
            if (i > 0)
                sb.Append(", ");
            let item = ordered[i].Key;
            if (item.itemName === null)
                return NullException_1.throwNullException("item.itemName");
            sb.Append(item.itemName);
        }
        return sb.toString();
    }
    // casting a InkList to a Number, for somereason, actually gives a number.
    // This messes up the type detection when creating a Value from a InkList.
    // Returning NaN here prevents that.
    valueOf() {
        return NaN;
    }
}
exports.InkList = InkList;
//# sourceMappingURL=InkList.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/JsonSerialisation.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/JsonSerialisation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerialisation = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const ListDefinition_1 = __webpack_require__(/*! ./ListDefinition */ "./node_modules/inkjs/engine/ListDefinition.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class JsonSerialisation {
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException("runtimeObj");
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static WriteDictionaryRuntimeObjs(writer, dictionary) {
        writer.WriteObjectStart();
        for (let [key, value] of dictionary) {
            writer.WritePropertyStart(key);
            this.WriteRuntimeObject(writer, value);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static WriteListRuntimeObjs(writer, list) {
        writer.WriteArrayStart();
        for (let value of list) {
            this.WriteRuntimeObject(writer, value);
        }
        writer.WriteArrayEnd();
    }
    static WriteIntDictionary(writer, dict) {
        writer.WriteObjectStart();
        for (let [key, value] of dict) {
            writer.WriteIntProperty(key, value);
        }
        writer.WriteObjectEnd();
    }
    static WriteRuntimeObject(writer, obj) {
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            this.WriteRuntimeContainer(writer, container);
            return;
        }
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = "->";
            if (divert.isExternal) {
                divTypeKey = "x()";
            }
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function) {
                    divTypeKey = "f()";
                }
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {
                    divTypeKey = "->t->";
                }
            }
            let targetStr;
            if (divert.hasVariableTarget) {
                targetStr = divert.variableDivertName;
            }
            else {
                targetStr = divert.targetPathString;
            }
            writer.WriteObjectStart();
            writer.WriteProperty(divTypeKey, targetStr);
            if (divert.hasVariableTarget) {
                writer.WriteProperty("var", true);
            }
            if (divert.isConditional) {
                writer.WriteProperty("c", true);
            }
            if (divert.externalArgs > 0) {
                writer.WriteIntProperty("exArgs", divert.externalArgs);
            }
            writer.WriteObjectEnd();
            return;
        }
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            writer.WriteObjectStart();
            writer.WriteProperty("*", choicePoint.pathStringOnChoice);
            writer.WriteIntProperty("flg", choicePoint.flags);
            writer.WriteObjectEnd();
            return;
        }
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal) {
            writer.WriteInt(intVal.value);
            return;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal) {
            writer.WriteFloat(floatVal.value);
            return;
        }
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline) {
                writer.Write("\n", false);
            }
            else {
                writer.WriteStringStart();
                writer.WriteStringInner("^");
                writer.WriteStringInner(strVal.value);
                writer.WriteStringEnd();
            }
            return;
        }
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            this.WriteInkList(writer, listVal);
            return;
        }
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            writer.WriteObjectStart();
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException("divTargetVal.value");
            }
            writer.WriteProperty("^->", divTargetVal.value.componentsString);
            writer.WriteObjectEnd();
            return;
        }
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            writer.WriteObjectStart();
            writer.WriteProperty("^var", varPtrVal.value);
            writer.WriteIntProperty("ci", varPtrVal.contextIndex);
            writer.WriteObjectEnd();
            return;
        }
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue) {
            writer.Write("<>");
            return;
        }
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);
            return;
        }
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == "^")
                name = "L^";
            writer.Write(name);
            return;
        }
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            writer.WriteObjectStart();
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                writer.WriteProperty("CNT?", readCountPath);
            }
            else {
                writer.WriteProperty("VAR?", varRef.name);
            }
            writer.WriteObjectEnd();
            return;
        }
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            writer.WriteObjectStart();
            let key = varAss.isGlobal ? "VAR=" : "temp=";
            writer.WriteProperty(key, varAss.variableName);
            // Reassignment?
            if (!varAss.isNewDeclaration)
                writer.WriteProperty("re", true);
            writer.WriteObjectEnd();
            return;
        }
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj) {
            writer.Write("void");
            return;
        }
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            writer.WriteObjectStart();
            writer.WriteProperty("#", tag.text);
            writer.WriteObjectEnd();
            return;
        }
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice) {
            this.WriteChoice(writer, choice);
            return;
        }
        throw new Error("Failed to convert runtime object to Json token: " + obj);
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException("inkObject");
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === "number" && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === "string") {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == "^")
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == "\n" && str.length == 1)
                return new Value_1.StringValue("\n");
            // Glue
            if (str == "<>")
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == "L^")
                str = "^";
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == "->->")
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == "~ret")
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == "void")
                return new Void_1.Void();
        }
        if (typeof token === "object" && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj["^->"]) {
                propValue = obj["^->"];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj["^var"]) {
                propValue = obj["^var"];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ("ci" in obj) {
                    propValue = obj["ci"];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if ((propValue = obj["->"])) {
                isDivert = true;
            }
            else if ((propValue = obj["f()"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if ((propValue = obj["->t->"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if ((propValue = obj["x()"])) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if ((propValue = obj["var"]))
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj["c"];
                if (external) {
                    if ((propValue = obj["exArgs"]))
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if ((propValue = obj["*"])) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if ((propValue = obj["flg"]))
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if ((propValue = obj["VAR?"])) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if ((propValue = obj["CNT?"])) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if ((propValue = obj["VAR="])) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if ((propValue = obj["temp="])) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj["re"];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj["#"] !== undefined) {
                propValue = obj["#"];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if ((propValue = obj["list"])) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if ((propValue = obj["origins"])) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj["originalChoicePath"] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error("Failed to convert token to runtime object: " + JSON.stringify(token));
    }
    static WriteRuntimeContainer(writer, container, withoutName = false) {
        writer.WriteArrayStart();
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        for (let c of container.content)
            this.WriteRuntimeObject(writer, c);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        let hasNameProperty = container.name != null && !withoutName;
        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;
        if (hasTerminator) {
            writer.WriteObjectStart();
        }
        if (namedOnlyContent != null) {
            for (let [key, value] of namedOnlyContent) {
                let name = key;
                let namedContainer = TypeAssertion_1.asOrNull(value, Container_1.Container);
                writer.WritePropertyStart(name);
                this.WriteRuntimeContainer(writer, namedContainer, true);
                writer.WritePropertyEnd();
            }
        }
        if (hasNameProperty)
            writer.WriteProperty("#n", container.name);
        if (hasTerminator)
            writer.WriteObjectEnd();
        else
            writer.WriteNull();
        writer.WriteArrayEnd();
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == "#f") {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == "#n") {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj["text"].toString();
        choice.index = parseInt(jObj["index"]);
        choice.sourcePath = jObj["originalChoicePath"].toString();
        choice.originalThreadIndex = parseInt(jObj["originalThreadIndex"]);
        choice.pathStringOnChoice = jObj["targetPath"].toString();
        return choice;
    }
    static WriteChoice(writer, choice) {
        writer.WriteObjectStart();
        writer.WriteProperty("text", choice.text);
        writer.WriteIntProperty("index", choice.index);
        writer.WriteProperty("originalChoicePath", choice.sourcePath);
        writer.WriteIntProperty("originalThreadIndex", choice.originalThreadIndex);
        writer.WriteProperty("targetPath", choice.pathStringOnChoice);
        writer.WriteObjectEnd();
    }
    static WriteInkList(writer, listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException("rawList");
        }
        writer.WriteObjectStart();
        writer.WritePropertyStart("list");
        writer.WriteObjectStart();
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            let itemVal = val;
            if (item.itemName === null) {
                return NullException_1.throwNullException("item.itemName");
            }
            writer.WritePropertyNameStart();
            writer.WritePropertyNameInner(item.originName ? item.originName : "?");
            writer.WritePropertyNameInner(".");
            writer.WritePropertyNameInner(item.itemName);
            writer.WritePropertyNameEnd();
            writer.Write(itemVal);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        writer.WritePropertyEnd();
        if (rawList.Count == 0 &&
            rawList.originNames != null &&
            rawList.originNames.length > 0) {
            writer.WritePropertyStart("origins");
            writer.WriteArrayStart();
            for (let name of rawList.originNames)
                writer.Write(name);
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException("item.itemName");
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
exports.JsonSerialisation = JsonSerialisation;
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = "ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = "out";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = "/ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = "du";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = "pop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = "~ret";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = "->->";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = "str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = "/str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = "nop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = "choiceCnt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = "turn";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = "turns";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = "readc";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = "rnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = "srnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = "visit";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =
        "seq";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = "thread";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = "done";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = "end";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = "listInt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = "range";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = "lrnd";
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error("Control command not accounted for in serialisation");
    }
    return _controlCommandNames;
})();
//# sourceMappingURL=JsonSerialisation.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinition.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinition = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
class ListDefinition {
    constructor(name, items) {
        this._name = name || "";
        this._items = null;
        this._itemNameToValues = items || new Map();
    }
    get name() {
        return this._name;
    }
    get items() {
        if (this._items == null) {
            this._items = new Map();
            for (let [key, value] of this._itemNameToValues) {
                let item = new InkList_1.InkListItem(this.name, key);
                this._items.set(item.serialized(), value);
            }
        }
        return this._items;
    }
    ValueForItem(item) {
        if (!item.itemName)
            return 0;
        let intVal = this._itemNameToValues.get(item.itemName);
        if (typeof intVal !== "undefined")
            return intVal;
        else
            return 0;
    }
    ContainsItem(item) {
        if (!item.itemName)
            return false;
        if (item.originName != this.name)
            return false;
        return this._itemNameToValues.has(item.itemName);
    }
    ContainsItemWithName(itemName) {
        return this._itemNameToValues.has(itemName);
    }
    TryGetItemWithValue(val, 
    /* out */ item) {
        for (let [key, value] of this._itemNameToValues) {
            if (value == val) {
                item = new InkList_1.InkListItem(this.name, key);
                return { result: item, exists: true };
            }
        }
        item = InkList_1.InkListItem.Null;
        return { result: item, exists: false };
    }
    TryGetValueForItem(item, 
    /* out */ intVal) {
        if (!item.itemName)
            return { result: 0, exists: false };
        let value = this._itemNameToValues.get(item.itemName);
        if (!value)
            return { result: 0, exists: false };
        return { result: value, exists: true };
    }
}
exports.ListDefinition = ListDefinition;
//# sourceMappingURL=ListDefinition.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js":
/*!************************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinitionsOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinitionsOrigin = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ListDefinitionsOrigin {
    constructor(lists) {
        this._lists = new Map();
        this._allUnambiguousListValueCache = new Map();
        for (let list of lists) {
            this._lists.set(list.name, list);
            for (let [key, val] of list.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                let listValue = new Value_1.ListValue(item, val);
                if (!item.itemName) {
                    throw new Error("item.itemName is null or undefined.");
                }
                this._allUnambiguousListValueCache.set(item.itemName, listValue);
                this._allUnambiguousListValueCache.set(item.fullName, listValue);
            }
        }
    }
    get lists() {
        let listOfLists = [];
        for (let [, value] of this._lists) {
            listOfLists.push(value);
        }
        return listOfLists;
    }
    TryListGetDefinition(name, 
    /* out */ def) {
        if (name === null) {
            return { result: def, exists: false };
        }
        // initially, this function returns a boolean and the second parameter is an out.
        let definition = this._lists.get(name);
        if (!definition)
            return { result: def, exists: false };
        return { result: definition, exists: true };
    }
    FindSingleItemListWithName(name) {
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let val = this._allUnambiguousListValueCache.get(name);
        if (typeof val !== "undefined") {
            return val;
        }
        return null;
    }
}
exports.ListDefinitionsOrigin = ListDefinitionsOrigin;
//# sourceMappingURL=ListDefinitionsOrigin.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NativeFunctionCall.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/NativeFunctionCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeFunctionCall = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class NativeFunctionCall extends Object_1.InkObject {
    constructor() {
        super();
        this._name = null;
        this._numberOfParameters = 0;
        this._prototype = null;
        this._isPrototype = false;
        this._operationFuncs = null;
        if (arguments.length === 0) {
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
        }
        else if (arguments.length === 1) {
            let name = arguments[0];
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
            this.name = name;
        }
        else if (arguments.length === 2) {
            let name = arguments[0];
            let numberOfParameters = arguments[1];
            this._isPrototype = true;
            this.name = name;
            this.numberOfParameters = numberOfParameters;
        }
    }
    static CallWithName(functionName) {
        return new NativeFunctionCall(functionName);
    }
    static CallExistsWithName(functionName) {
        this.GenerateNativeFunctionsIfNecessary();
        return this._nativeFunctions.get(functionName);
    }
    get name() {
        if (this._name === null)
            return NullException_1.throwNullException("NativeFunctionCall._name");
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._isPrototype) {
            if (NativeFunctionCall._nativeFunctions === null)
                NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
            else
                this._prototype =
                    NativeFunctionCall._nativeFunctions.get(this._name) || null;
        }
    }
    get numberOfParameters() {
        if (this._prototype) {
            return this._prototype.numberOfParameters;
        }
        else {
            return this._numberOfParameters;
        }
    }
    set numberOfParameters(value) {
        this._numberOfParameters = value;
    }
    Call(parameters) {
        if (this._prototype) {
            return this._prototype.Call(parameters);
        }
        if (this.numberOfParameters != parameters.length) {
            throw new Error("Unexpected number of parameters");
        }
        let hasList = false;
        for (let p of parameters) {
            if (p instanceof Void_1.Void)
                throw new StoryException_1.StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');
            if (p instanceof Value_1.ListValue)
                hasList = true;
        }
        if (parameters.length == 2 && hasList) {
            return this.CallBinaryListOperation(parameters);
        }
        let coercedParams = this.CoerceValuesToSingleType(parameters);
        let coercedType = coercedParams[0].valueType;
        if (coercedType == Value_1.ValueType.Int) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.Float) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.String) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.DivertTarget) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.List) {
            return this.CallType(coercedParams);
        }
        return null;
    }
    CallType(parametersOfSingleType) {
        let param1 = TypeAssertion_1.asOrThrows(parametersOfSingleType[0], Value_1.Value);
        let valType = param1.valueType;
        let val1 = param1;
        let paramCount = parametersOfSingleType.length;
        if (paramCount == 2 || paramCount == 1) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let opForTypeObj = this._operationFuncs.get(valType);
            if (!opForTypeObj) {
                const key = Value_1.ValueType[valType];
                throw new StoryException_1.StoryException("Cannot perform operation " + this.name + " on " + key);
            }
            if (paramCount == 2) {
                let param2 = TypeAssertion_1.asOrThrows(parametersOfSingleType[1], Value_1.Value);
                let val2 = param2;
                let opForType = opForTypeObj;
                if (val1.value === null || val2.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call BinaryOp values");
                let resultVal = opForType(val1.value, val2.value);
                return Value_1.Value.Create(resultVal);
            }
            else {
                let opForType = opForTypeObj;
                if (val1.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call UnaryOp value");
                let resultVal = opForType(val1.value);
                // This code is different from upstream. Since JavaScript treats
                // integers and floats as the same numbers, it's impossible
                // to force an number to be either an integer or a float.
                //
                // It can be useful to force a specific number type
                // (especially for divisions), so the result of INT() & FLOAT()
                // is coerced to the the proper value type.
                //
                // Note that we also force all other unary operation to
                // return the same value type, although this is only
                // meaningful for numbers. See `Value.Create`.
                if (this.name === NativeFunctionCall.Int) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);
                }
                else if (this.name === NativeFunctionCall.Float) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);
                }
                else {
                    return Value_1.Value.Create(resultVal, param1.valueType);
                }
            }
        }
        else {
            throw new Error("Unexpected number of parameters to NativeFunctionCall: " +
                parametersOfSingleType.length);
        }
    }
    CallBinaryListOperation(parameters) {
        if ((this.name == "+" || this.name == "-") &&
            parameters[0] instanceof Value_1.ListValue &&
            parameters[1] instanceof Value_1.IntValue)
            return this.CallListIncrementOperation(parameters);
        let v1 = TypeAssertion_1.asOrThrows(parameters[0], Value_1.Value);
        let v2 = TypeAssertion_1.asOrThrows(parameters[1], Value_1.Value);
        if ((this.name == "&&" || this.name == "||") &&
            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let op = this._operationFuncs.get(Value_1.ValueType.Int);
            if (op === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallBinaryListOperation op");
            let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);
            return new Value_1.IntValue(result);
        }
        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)
            return this.CallType([v1, v2]);
        throw new StoryException_1.StoryException("Can not call use " +
            this.name +
            " operation on " +
            Value_1.ValueType[v1.valueType] +
            " and " +
            Value_1.ValueType[v2.valueType]);
    }
    CallListIncrementOperation(listIntParams) {
        let listVal = TypeAssertion_1.asOrThrows(listIntParams[0], Value_1.ListValue);
        let intVal = TypeAssertion_1.asOrThrows(listIntParams[1], Value_1.IntValue);
        let resultInkList = new InkList_1.InkList();
        if (listVal.value === null)
            return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");
        for (let [listItemKey, listItemValue] of listVal.value) {
            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);
            if (intVal.value === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");
            let targetInt = intOp(listItemValue, intVal.value);
            let itemOrigin = null;
            if (listVal.value.origins === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");
            for (let origin of listVal.value.origins) {
                if (origin.name == listItem.originName) {
                    itemOrigin = origin;
                    break;
                }
            }
            if (itemOrigin != null) {
                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);
                if (incrementedItem.exists)
                    resultInkList.Add(incrementedItem.result, targetInt);
            }
        }
        return new Value_1.ListValue(resultInkList);
    }
    CoerceValuesToSingleType(parametersIn) {
        let valType = Value_1.ValueType.Int;
        let specialCaseList = null;
        for (let obj of parametersIn) {
            let val = TypeAssertion_1.asOrThrows(obj, Value_1.Value);
            if (val.valueType > valType) {
                valType = val.valueType;
            }
            if (val.valueType == Value_1.ValueType.List) {
                specialCaseList = TypeAssertion_1.asOrNull(val, Value_1.ListValue);
            }
        }
        let parametersOut = [];
        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                if (val.valueType == Value_1.ValueType.List) {
                    parametersOut.push(val);
                }
                else if (val.valueType == Value_1.ValueType.Int) {
                    let intVal = parseInt(val.valueObject);
                    specialCaseList = TypeAssertion_1.asOrThrows(specialCaseList, Value_1.ListValue);
                    if (specialCaseList.value === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");
                    let list = specialCaseList.value.originOfMaxItem;
                    if (list === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");
                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);
                    if (item.exists) {
                        let castedValue = new Value_1.ListValue(item.result, intVal);
                        parametersOut.push(castedValue);
                    }
                    else
                        throw new StoryException_1.StoryException("Could not find List item with the value " +
                            intVal +
                            " in " +
                            list.name);
                }
                else {
                    const key = Value_1.ValueType[val.valueType];
                    throw new StoryException_1.StoryException("Cannot mix Lists and " + key + " values in this operation");
                }
            }
        }
        else {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                let castedValue = val.Cast(valType);
                parametersOut.push(castedValue);
            }
        }
        return parametersOut;
    }
    static Identity(t) {
        return t;
    }
    static GenerateNativeFunctionsIfNecessary() {
        if (this._nativeFunctions == null) {
            this._nativeFunctions = new Map();
            // Int operations
            this.AddIntBinaryOp(this.Add, (x, y) => x + y);
            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));
            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);
            this.AddIntUnaryOp(this.Negate, (x) => -x);
            this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));
            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));
            this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Float, (x) => x);
            // Float operations
            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);
            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);
            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);
            this.AddFloatUnaryOp(this.Negate, (x) => -x);
            this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);
            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));
            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);
            // String operations
            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat
            this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));
            this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));
            this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));
            this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));
            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));
            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));
            this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));
            this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));
            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));
            this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);
            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);
            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));
            this.AddListUnaryOp(this.Invert, (x) => x.inverse);
            this.AddListUnaryOp(this.All, (x) => x.all);
            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());
            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());
            this.AddListUnaryOp(this.Count, (x) => x.Count);
            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);
            let divertTargetsEqual = (d1, d2) => (d1.Equals(d2) ? 1 : 0);
            let divertTargetsNotEqual = (d1, d2) => d1.Equals(d2) ? 0 : 1;
            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);
            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);
        }
    }
    AddOpFuncForType(valType, op) {
        if (this._operationFuncs == null) {
            this._operationFuncs = new Map();
        }
        this._operationFuncs.set(valType, op);
    }
    static AddOpToNativeFunc(name, args, valType, op) {
        if (this._nativeFunctions === null)
            return NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
        let nativeFunc = this._nativeFunctions.get(name);
        if (!nativeFunc) {
            nativeFunc = new NativeFunctionCall(name, args);
            this._nativeFunctions.set(name, nativeFunc);
        }
        nativeFunc.AddOpFuncForType(valType, op);
    }
    static AddIntBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);
    }
    static AddIntUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);
    }
    static AddFloatBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);
    }
    static AddFloatUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);
    }
    static AddStringBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);
    }
    static AddListBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);
    }
    static AddListUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);
    }
    toString() {
        return 'Native "' + this.name + '"';
    }
}
exports.NativeFunctionCall = NativeFunctionCall;
NativeFunctionCall.Add = "+";
NativeFunctionCall.Subtract = "-";
NativeFunctionCall.Divide = "/";
NativeFunctionCall.Multiply = "*";
NativeFunctionCall.Mod = "%";
NativeFunctionCall.Negate = "_";
NativeFunctionCall.Equal = "==";
NativeFunctionCall.Greater = ">";
NativeFunctionCall.Less = "<";
NativeFunctionCall.GreaterThanOrEquals = ">=";
NativeFunctionCall.LessThanOrEquals = "<=";
NativeFunctionCall.NotEquals = "!=";
NativeFunctionCall.Not = "!";
NativeFunctionCall.And = "&&";
NativeFunctionCall.Or = "||";
NativeFunctionCall.Min = "MIN";
NativeFunctionCall.Max = "MAX";
NativeFunctionCall.Pow = "POW";
NativeFunctionCall.Floor = "FLOOR";
NativeFunctionCall.Ceiling = "CEILING";
NativeFunctionCall.Int = "INT";
NativeFunctionCall.Float = "FLOAT";
NativeFunctionCall.Has = "?";
NativeFunctionCall.Hasnt = "!?";
NativeFunctionCall.Intersect = "^";
NativeFunctionCall.ListMin = "LIST_MIN";
NativeFunctionCall.ListMax = "LIST_MAX";
NativeFunctionCall.All = "LIST_ALL";
NativeFunctionCall.Count = "LIST_COUNT";
NativeFunctionCall.ValueOfList = "LIST_VALUE";
NativeFunctionCall.Invert = "LIST_INVERT";
NativeFunctionCall._nativeFunctions = null;
//# sourceMappingURL=NativeFunctionCall.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NullException.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/NullException.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.throwNullException = exports.NullException = void 0;
/**
 * In the original C# code, a SystemException would be thrown when passing
 * null to methods expected a valid instance. Javascript has no such
 * concept, but TypeScript will not allow `null` to be passed to methods
 * explicitely requiring a valid type.
 *
 * Whenever TypeScript complain about the possibility of a `null` value,
 * check the offending value and it it's null, throw this exception using
 * `throwNullException(name: string)`.
 */
class NullException extends Error {
}
exports.NullException = NullException;
/**
 * Throw a NullException.
 *
 * @param name a short description of the offending value (often its name within the code).
 */
function throwNullException(name) {
    throw new NullException(`${name} is null or undefined`);
}
exports.throwNullException = throwNullException;
//# sourceMappingURL=NullException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Object.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Object.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkObject = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class InkObject {
    constructor() {
        this.parent = null;
        this._debugMetadata = null;
        this._path = null;
    }
    get debugMetadata() {
        if (this._debugMetadata === null) {
            if (this.parent) {
                return this.parent.debugMetadata;
            }
        }
        return this._debugMetadata;
    }
    set debugMetadata(value) {
        this._debugMetadata = value;
    }
    get ownDebugMetadata() {
        return this._debugMetadata;
    }
    DebugLineNumberOfPath(path) {
        if (path === null)
            return null;
        // Try to get a line number from debug metadata
        let root = this.rootContentContainer;
        if (root) {
            let targetContent = root.ContentAtPath(path).obj;
            if (targetContent) {
                let dm = targetContent.debugMetadata;
                if (dm !== null) {
                    return dm.startLineNumber;
                }
            }
        }
        return null;
    }
    get path() {
        if (this._path == null) {
            if (this.parent == null) {
                this._path = new Path_1.Path();
            }
            else {
                let comps = [];
                let child = this;
                let container = TypeAssertion_1.asOrNull(child.parent, Container_1.Container);
                while (container !== null) {
                    let namedChild = TypeAssertion_1.asINamedContentOrNull(child);
                    if (namedChild != null && namedChild.hasValidName) {
                        comps.unshift(new Path_1.Path.Component(namedChild.name));
                    }
                    else {
                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));
                    }
                    child = container;
                    container = TypeAssertion_1.asOrNull(container.parent, Container_1.Container);
                }
                this._path = new Path_1.Path(comps);
            }
        }
        return this._path;
    }
    ResolvePath(path) {
        if (path === null)
            return NullException_1.throwNullException("path");
        if (path.isRelative) {
            let nearestContainer = TypeAssertion_1.asOrNull(this, Container_1.Container);
            if (nearestContainer === null) {
                Debug_1.Debug.Assert(this.parent !== null, "Can't resolve relative path because we don't have a parent");
                nearestContainer = TypeAssertion_1.asOrNull(this.parent, Container_1.Container);
                Debug_1.Debug.Assert(nearestContainer !== null, "Expected parent to be a container");
                Debug_1.Debug.Assert(path.GetComponent(0).isParent);
                path = path.tail;
            }
            if (nearestContainer === null) {
                return NullException_1.throwNullException("nearestContainer");
            }
            return nearestContainer.ContentAtPath(path);
        }
        else {
            let contentContainer = this.rootContentContainer;
            if (contentContainer === null) {
                return NullException_1.throwNullException("contentContainer");
            }
            return contentContainer.ContentAtPath(path);
        }
    }
    ConvertPathToRelative(globalPath) {
        let ownPath = this.path;
        let minPathLength = Math.min(globalPath.length, ownPath.length);
        let lastSharedPathCompIndex = -1;
        for (let i = 0; i < minPathLength; ++i) {
            let ownComp = ownPath.GetComponent(i);
            let otherComp = globalPath.GetComponent(i);
            if (ownComp.Equals(otherComp)) {
                lastSharedPathCompIndex = i;
            }
            else {
                break;
            }
        }
        // No shared path components, so just use global path
        if (lastSharedPathCompIndex == -1)
            return globalPath;
        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;
        let newPathComps = [];
        for (let up = 0; up < numUpwardsMoves; ++up)
            newPathComps.push(Path_1.Path.Component.ToParent());
        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)
            newPathComps.push(globalPath.GetComponent(down));
        let relativePath = new Path_1.Path(newPathComps, true);
        return relativePath;
    }
    CompactPathString(otherPath) {
        let globalPathStr = null;
        let relativePathStr = null;
        if (otherPath.isRelative) {
            relativePathStr = otherPath.componentsString;
            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;
        }
        else {
            let relativePath = this.ConvertPathToRelative(otherPath);
            relativePathStr = relativePath.componentsString;
            globalPathStr = otherPath.componentsString;
        }
        if (relativePathStr.length < globalPathStr.length)
            return relativePathStr;
        else
            return globalPathStr;
    }
    get rootContentContainer() {
        let ancestor = this;
        while (ancestor.parent) {
            ancestor = ancestor.parent;
        }
        return TypeAssertion_1.asOrNull(ancestor, Container_1.Container);
    }
    Copy() {
        throw Error("Not Implemented: Doesn't support copying");
    }
    // SetChild works slightly diferently in the js implementation.
    // Since we can't pass an objets property by reference, we instead pass
    // the object and the property string.
    // TODO: This method can probably be rewritten with type-safety in mind.
    SetChild(obj, prop, value) {
        if (obj[prop])
            obj[prop] = null;
        obj[prop] = value;
        if (obj[prop])
            obj[prop].parent = this;
    }
}
exports.InkObject = InkObject;
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PRNG.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/PRNG.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PRNG = void 0;
// Taken from https://gist.github.com/blixt/f17b47c62508be59987b
// Ink uses a seedable PRNG of which there is none in native javascript.
class PRNG {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0)
            this.seed += 2147483646;
    }
    next() {
        return (this.seed = (this.seed * 16807) % 2147483647);
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}
exports.PRNG = PRNG;
//# sourceMappingURL=PRNG.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Path.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
class Path {
    constructor() {
        this._components = [];
        this._componentsString = null;
        this._isRelative = false;
        if (typeof arguments[0] == "string") {
            let componentsString = arguments[0];
            this.componentsString = componentsString;
        }
        else if (arguments[0] instanceof Path.Component &&
            arguments[1] instanceof Path) {
            let head = arguments[0];
            let tail = arguments[1];
            this._components.push(head);
            this._components = this._components.concat(tail._components);
        }
        else if (arguments[0] instanceof Array) {
            let head = arguments[0];
            let relative = !!arguments[1];
            this._components = this._components.concat(head);
            this._isRelative = relative;
        }
    }
    get isRelative() {
        return this._isRelative;
    }
    get componentCount() {
        return this._components.length;
    }
    get head() {
        if (this._components.length > 0) {
            return this._components[0];
        }
        else {
            return null;
        }
    }
    get tail() {
        if (this._components.length >= 2) {
            // careful, the original code uses length-1 here. This is because the second argument of
            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index
            let tailComps = this._components.slice(1, this._components.length);
            return new Path(tailComps);
        }
        else {
            return Path.self;
        }
    }
    get length() {
        return this._components.length;
    }
    get lastComponent() {
        let lastComponentIdx = this._components.length - 1;
        if (lastComponentIdx >= 0) {
            return this._components[lastComponentIdx];
        }
        else {
            return null;
        }
    }
    get containsNamedComponent() {
        for (let i = 0, l = this._components.length; i < l; i++) {
            if (!this._components[i].isIndex) {
                return true;
            }
        }
        return false;
    }
    static get self() {
        let path = new Path();
        path._isRelative = true;
        return path;
    }
    GetComponent(index) {
        return this._components[index];
    }
    PathByAppendingPath(pathToAppend) {
        let p = new Path();
        let upwardMoves = 0;
        for (let i = 0; i < pathToAppend._components.length; ++i) {
            if (pathToAppend._components[i].isParent) {
                upwardMoves++;
            }
            else {
                break;
            }
        }
        for (let i = 0; i < this._components.length - upwardMoves; ++i) {
            p._components.push(this._components[i]);
        }
        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {
            p._components.push(pathToAppend._components[i]);
        }
        return p;
    }
    get componentsString() {
        if (this._componentsString == null) {
            this._componentsString = this._components.join(".");
            if (this.isRelative)
                this._componentsString = "." + this._componentsString;
        }
        return this._componentsString;
    }
    set componentsString(value) {
        this._components.length = 0;
        this._componentsString = value;
        if (this._componentsString == null || this._componentsString == "")
            return;
        if (this._componentsString[0] == ".") {
            this._isRelative = true;
            this._componentsString = this._componentsString.substring(1);
        }
        let componentStrings = this._componentsString.split(".");
        for (let str of componentStrings) {
            // we need to distinguish between named components that start with a number, eg "42somewhere", and indexed components
            // the normal parseInt won't do for the detection because it's too relaxed.
            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
            if (/^(\-|\+)?([0-9]+|Infinity)$/.test(str)) {
                this._components.push(new Path.Component(parseInt(str)));
            }
            else {
                this._components.push(new Path.Component(str));
            }
        }
    }
    toString() {
        return this.componentsString;
    }
    Equals(otherPath) {
        if (otherPath == null)
            return false;
        if (otherPath._components.length != this._components.length)
            return false;
        if (otherPath.isRelative != this.isRelative)
            return false;
        // the original code uses SequenceEqual here, so we need to iterate over the components manually.
        for (let i = 0, l = otherPath._components.length; i < l; i++) {
            // it's not quite clear whether this test should use Equals or a simple == operator,
            // see https://github.com/y-lohse/inkjs/issues/22
            if (!otherPath._components[i].Equals(this._components[i]))
                return false;
        }
        return true;
    }
    PathByAppendingComponent(c) {
        let p = new Path();
        p._components.push.apply(p._components, this._components);
        p._components.push(c);
        return p;
    }
}
exports.Path = Path;
Path.parentId = "^";
(function (Path) {
    class Component {
        constructor(indexOrName) {
            this.index = -1;
            this.name = null;
            if (typeof indexOrName == "string") {
                this.name = indexOrName;
            }
            else {
                this.index = indexOrName;
            }
        }
        get isIndex() {
            return this.index >= 0;
        }
        get isParent() {
            return this.name == Path.parentId;
        }
        static ToParent() {
            return new Component(Path.parentId);
        }
        toString() {
            if (this.isIndex) {
                return this.index.toString();
            }
            else {
                return this.name;
            }
        }
        Equals(otherComp) {
            if (otherComp != null && otherComp.isIndex == this.isIndex) {
                if (this.isIndex) {
                    return this.index == otherComp.index;
                }
                else {
                    return this.name == otherComp.name;
                }
            }
            return false;
        }
    }
    Path.Component = Component;
})(Path = exports.Path || (exports.Path = {}));
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Pointer.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/Pointer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class Pointer {
    constructor() {
        this.container = null;
        this.index = -1;
        if (arguments.length === 2) {
            this.container = arguments[0];
            this.index = arguments[1];
        }
    }
    Resolve() {
        if (this.index < 0)
            return this.container;
        if (this.container == null)
            return null;
        if (this.container.content.length == 0)
            return this.container;
        if (this.index >= this.container.content.length)
            return null;
        return this.container.content[this.index];
    }
    get isNull() {
        return this.container == null;
    }
    get path() {
        if (this.isNull)
            return null;
        if (this.index >= 0)
            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));
        else
            return this.container.path;
    }
    toString() {
        if (!this.container)
            return "Ink Pointer (null)";
        return ("Ink Pointer -> " +
            this.container.path.toString() +
            " -- index " +
            this.index);
    }
    // This method does not exist in the original C# code, but is here to maintain the
    // value semantics of Pointer.
    copy() {
        return new Pointer(this.container, this.index);
    }
    static StartOf(container) {
        return new Pointer(container, 0);
    }
    static get Null() {
        return new Pointer(null, -1);
    }
}
exports.Pointer = Pointer;
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PushPop.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/PushPop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPopType = void 0;
var PushPopType;
(function (PushPopType) {
    PushPopType[PushPopType["Tunnel"] = 0] = "Tunnel";
    PushPopType[PushPopType["Function"] = 1] = "Function";
    PushPopType[PushPopType["FunctionEvaluationFromGame"] = 2] = "FunctionEvaluationFromGame";
})(PushPopType = exports.PushPopType || (exports.PushPopType = {}));
//# sourceMappingURL=PushPop.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SearchResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/SearchResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
class SearchResult {
    constructor() {
        this.obj = null;
        this.approximate = false;
    }
    get correctObj() {
        return this.approximate ? null : this.obj;
    }
    get container() {
        return this.obj instanceof Container_1.Container ? this.obj : null;
    }
    copy() {
        let searchResult = new SearchResult();
        searchResult.obj = this.obj;
        searchResult.approximate = this.approximate;
        return searchResult;
    }
}
exports.SearchResult = SearchResult;
//# sourceMappingURL=SearchResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SimpleJson.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/SimpleJson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleJson = void 0;
class SimpleJson {
    static TextToDictionary(text) {
        return new SimpleJson.Reader(text).ToDictionary();
    }
    static TextToArray(text) {
        return new SimpleJson.Reader(text).ToArray();
    }
}
exports.SimpleJson = SimpleJson;
(function (SimpleJson) {
    class Reader {
        constructor(text) {
            this._rootObject = JSON.parse(text);
        }
        ToDictionary() {
            return this._rootObject;
        }
        ToArray() {
            return this._rootObject;
        }
    }
    SimpleJson.Reader = Reader;
    // In C#, this class writes json tokens directly to a StringWriter or
    // another stream. Here, a temporary hierarchy is created in the form
    // of a javascript object, which is serialised in the `toString` method.
    // See individual methods and properties for more information.
    class Writer {
        constructor() {
            // In addition to `_stateStack` present in the original code,
            // this implementation of SimpleJson use two other stacks and two
            // temporary variables holding the current context.
            // Used to keep track of the current property name being built
            // with `WritePropertyNameStart`, `WritePropertyNameInner` and
            // `WritePropertyNameEnd`.
            this._currentPropertyName = null;
            // Used to keep track of the current string value being built
            // with `WriteStringStart`, `WriteStringInner` and
            // `WriteStringEnd`.
            this._currentString = null;
            this._stateStack = [];
            // Keep track of the current collection being built (either an array
            // or an object). For instance, at the '?' step during the hiarchy
            // creation, this hierarchy:
            // [3, {a: [b, ?]}] will have this corresponding stack:
            // (bottom) [Array, Object, Array] (top)
            this._collectionStack = [];
            // Keep track of the current property being assigned. For instance, at
            // the '?' step during the hiarchy creation, this hierarchy:
            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:
            // (bottom) [a, c] (top)
            this._propertyNameStack = [];
            // Object containing the entire hiearchy.
            this._jsonObject = null;
        }
        WriteObject(inner) {
            this.WriteObjectStart();
            inner(this);
            this.WriteObjectEnd();
        }
        // Add a new object.
        WriteObjectStart() {
            this.StartNewObject(true);
            let newObject = {};
            if (this.state === SimpleJson.Writer.State.Property) {
                // This object is created as the value of a property,
                // inside an other object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This object is created as the child of an array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This object is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));
        }
        WriteObjectEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Write a property name / value pair to the current object.
        WriteProperty(name, innerOrContent) {
            this.WritePropertyStart(name);
            if (arguments[1] instanceof Function) {
                let inner = arguments[1];
                inner(this);
            }
            else {
                let content = arguments[1];
                this.Write(content);
            }
            this.WritePropertyEnd();
        }
        // Int and Float are separate calls, since there both are
        // numbers in JavaScript, but need to be handled differently.
        WriteIntProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteInt(content);
            this.WritePropertyEnd();
        }
        WriteFloatProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteFloat(content);
            this.WritePropertyEnd();
        }
        // Prepare a new property name, which will be use to add the
        // new object when calling _addToCurrentObject() from a Write
        // method.
        WritePropertyStart(name) {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._propertyNameStack.push(name);
            this.IncrementChildCount();
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
        }
        WritePropertyEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Property);
            this.Assert(this.childCount === 1);
            this._stateStack.pop();
        }
        // Prepare a new property name, except this time, the property name
        // will be created by concatenating all the strings passed to
        // WritePropertyNameInner.
        WritePropertyNameStart() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this.IncrementChildCount();
            this._currentPropertyName = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));
        }
        WritePropertyNameEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._propertyNameStack.push(this._currentPropertyName);
            this._currentPropertyName = null;
            this._stateStack.pop();
        }
        WritePropertyNameInner(str) {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._currentPropertyName += str;
        }
        // Add a new array.
        WriteArrayStart() {
            this.StartNewObject(true);
            let newObject = [];
            if (this.state === SimpleJson.Writer.State.Property) {
                // This array is created as the value of a property,
                // inside an object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This array is created as the child of another array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This array is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));
        }
        WriteArrayEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Array);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Add the value to the appropriate collection (array / object), given the current
        // context.
        Write(value, escape = true) {
            if (value === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this.StartNewObject(false);
            this._addToCurrentObject(value);
        }
        WriteInt(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            // Math.floor is used as a precaution:
            //     1. to ensure that the value is written as an integer
            //        (without a fractional part -> 1 instead of 1.0), even
            //        though it should be the default behaviour of
            //        JSON.serialize;
            //     2. to ensure that if a floating number is passed
            //        accidentally, it's converted to an integer.
            //
            // This guarantees savegame compatibility with the reference
            // implementation.
            this._addToCurrentObject(Math.floor(value));
        }
        // Since JSON doesn't support NaN and Infinity, these values
        // are converted here.
        WriteFloat(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            if (value == Number.POSITIVE_INFINITY) {
                this._addToCurrentObject(3.4e38);
            }
            else if (value == Number.NEGATIVE_INFINITY) {
                this._addToCurrentObject(-3.4e38);
            }
            else if (isNaN(value)) {
                this._addToCurrentObject(0.0);
            }
            else {
                this._addToCurrentObject(value);
            }
        }
        WriteNull() {
            this.StartNewObject(false);
            this._addToCurrentObject(null);
        }
        // Prepare a string before adding it to the current collection in
        // WriteStringEnd(). The string will be a concatenation of all the
        // strings passed to WriteStringInner.
        WriteStringStart() {
            this.StartNewObject(false);
            this._currentString = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));
        }
        WriteStringEnd() {
            this.Assert(this.state == SimpleJson.Writer.State.String);
            this._stateStack.pop();
            this._addToCurrentObject(this._currentString);
            this._currentString = null;
        }
        WriteStringInner(str, escape = true) {
            this.Assert(this.state === SimpleJson.Writer.State.String);
            if (str === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this._currentString += str;
        }
        // Serialise the root object into a JSON string.
        ToString() {
            if (this._jsonObject === null) {
                return "";
            }
            return JSON.stringify(this._jsonObject);
        }
        // Prepare the state stack when adding new objects / values.
        StartNewObject(container) {
            if (container) {
                this.Assert(this.state === SimpleJson.Writer.State.None ||
                    this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            else {
                this.Assert(this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(this.childCount === 0);
            }
            if (this.state === SimpleJson.Writer.State.Array ||
                this.state === SimpleJson.Writer.State.Property) {
                this.IncrementChildCount();
            }
        }
        // These getters peek all the different stacks.
        get state() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].type;
            }
            else {
                return SimpleJson.Writer.State.None;
            }
        }
        get childCount() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].childCount;
            }
            else {
                return 0;
            }
        }
        get currentCollection() {
            if (this._collectionStack.length > 0) {
                return this._collectionStack[this._collectionStack.length - 1];
            }
            else {
                return null;
            }
        }
        get currentPropertyName() {
            if (this._propertyNameStack.length > 0) {
                return this._propertyNameStack[this._propertyNameStack.length - 1];
            }
            else {
                return null;
            }
        }
        IncrementChildCount() {
            this.Assert(this._stateStack.length > 0);
            let currEl = this._stateStack.pop();
            currEl.childCount++;
            this._stateStack.push(currEl);
        }
        Assert(condition) {
            if (!condition)
                throw Error("Assert failed while writing JSON");
        }
        // This method did not exist in the original C# code. It adds
        // the given value to the current collection (used by Write methods).
        _addToCurrentObject(value) {
            this.Assert(this.currentCollection !== null);
            if (this.state === SimpleJson.Writer.State.Array) {
                this.Assert(Array.isArray(this.currentCollection));
                this.currentCollection.push(value);
            }
            else if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(!Array.isArray(this.currentCollection));
                this.Assert(this.currentPropertyName !== null);
                this.currentCollection[this.currentPropertyName] = value;
                this._propertyNameStack.pop();
            }
        }
    }
    SimpleJson.Writer = Writer;
    (function (Writer) {
        let State;
        (function (State) {
            State[State["None"] = 0] = "None";
            State[State["Object"] = 1] = "Object";
            State[State["Array"] = 2] = "Array";
            State[State["Property"] = 3] = "Property";
            State[State["PropertyName"] = 4] = "PropertyName";
            State[State["String"] = 5] = "String";
        })(State = Writer.State || (Writer.State = {}));
        class StateElement {
            constructor(type) {
                this.type = SimpleJson.Writer.State.None;
                this.childCount = 0;
                this.type = type;
            }
        }
        Writer.StateElement = StateElement;
    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));
})(SimpleJson = exports.SimpleJson || (exports.SimpleJson = {}));
//# sourceMappingURL=SimpleJson.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StatePatch.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StatePatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePatch = void 0;
class StatePatch {
    constructor() {
        this._changedVariables = new Set();
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        if (arguments.length === 1 && arguments[0] !== null) {
            let toCopy = arguments[0];
            this._globals = new Map(toCopy._globals);
            this._changedVariables = new Set(toCopy._changedVariables);
            this._visitCounts = new Map(toCopy._visitCounts);
            this._turnIndices = new Map(toCopy._turnIndices);
        }
        else {
            this._globals = new Map();
            this._changedVariables = new Set();
            this._visitCounts = new Map();
            this._turnIndices = new Map();
        }
    }
    get globals() {
        return this._globals;
    }
    get changedVariables() {
        return this._changedVariables;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    TryGetGlobal(name, /* out */ value) {
        if (name !== null && this._globals.has(name)) {
            return { result: this._globals.get(name), exists: true };
        }
        return { result: value, exists: false };
    }
    SetGlobal(name, value) {
        this._globals.set(name, value);
    }
    AddChangedVariable(name) {
        return this._changedVariables.add(name);
    }
    TryGetVisitCount(container, /* out */ count) {
        if (this._visitCounts.has(container)) {
            return { result: this._visitCounts.get(container), exists: true };
        }
        return { result: count, exists: false };
    }
    SetVisitCount(container, count) {
        this._visitCounts.set(container, count);
    }
    SetTurnIndex(container, index) {
        this._turnIndices.set(container, index);
    }
    TryGetTurnIndex(container, /* out */ index) {
        if (this._turnIndices.has(container)) {
            return { result: this._turnIndices.get(container), exists: true };
        }
        return { result: index, exists: false };
    }
}
exports.StatePatch = StatePatch;
//# sourceMappingURL=StatePatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StopWatch.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/StopWatch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopwatch = void 0;
// This is simple replacement of the Stopwatch class from the .NET Framework.
// The original class can count time with much more accuracy than the Javascript version.
// It might be worth considering using `window.performance` in the browser
// or `process.hrtime()` in node.
class Stopwatch {
    constructor() {
        this.startTime = undefined;
    }
    get ElapsedMilliseconds() {
        if (typeof this.startTime === "undefined") {
            return 0;
        }
        return new Date().getTime() - this.startTime;
    }
    Start() {
        this.startTime = new Date().getTime();
    }
    Stop() {
        this.startTime = undefined;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=StopWatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Story.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Story.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Story = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const StoryState_1 = __webpack_require__(/*! ./StoryState */ "./node_modules/inkjs/engine/StoryState.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const StopWatch_1 = __webpack_require__(/*! ./StopWatch */ "./node_modules/inkjs/engine/StopWatch.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
var InkList_2 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
Object.defineProperty(exports, "InkList", { enumerable: true, get: function () { return InkList_2.InkList; } });
if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return (typeof nVal === "number" &&
            isFinite(nVal) &&
            nVal > -9007199254740992 &&
            nVal < 9007199254740992 &&
            Math.floor(nVal) === nVal);
    };
}
class Story extends Object_1.InkObject {
    constructor() {
        super();
        this.inkVersionMinimumCompatible = 18;
        this._prevContainers = [];
        this.allowExternalFunctionFallbacks = false;
        this._listDefinitions = null;
        this._variableObservers = null;
        this._hasValidatedExternals = false;
        this._temporaryEvaluationContainer = null;
        this._asyncContinueActive = false;
        this._stateSnapshotAtLastNewline = null;
        this._recursiveContinueCount = 0;
        this._asyncSaving = false;
        this._profiler = null; // TODO: Profiler
        // Discrimination between constructors
        let contentContainer;
        let lists = null;
        let json = null;
        if (arguments[0] instanceof Container_1.Container) {
            contentContainer = arguments[0];
            if (typeof arguments[1] !== "undefined") {
                lists = arguments[1];
            }
            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
            this._mainContentContainer = contentContainer;
            // ------
        }
        else {
            if (typeof arguments[0] === "string") {
                let jsonString = arguments[0];
                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);
            }
            else {
                json = arguments[0];
            }
        }
        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
        if (lists != null)
            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);
        this._externals = new Map();
        // ------
        // ------ Story(string jsonString) : this((Container)null)
        if (json !== null) {
            let rootObject = json;
            let versionObj = rootObject["inkVersion"];
            if (versionObj == null)
                throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");
            let formatFromFile = parseInt(versionObj);
            if (formatFromFile > Story.inkVersionCurrent) {
                throw new Error("Version of ink used to build story was newer than the current version of the engine");
            }
            else if (formatFromFile < this.inkVersionMinimumCompatible) {
                throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");
            }
            else if (formatFromFile != Story.inkVersionCurrent) {
                console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");
            }
            let rootToken = rootObject["root"];
            if (rootToken == null)
                throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");
            let listDefsObj;
            if ((listDefsObj = rootObject["listDefs"])) {
                this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);
            }
            this._mainContentContainer = TypeAssertion_1.asOrThrows(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);
            this.ResetState();
        }
        // ------
    }
    get currentChoices() {
        let choices = [];
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        for (let c of this._state.currentChoices) {
            if (!c.isInvisibleDefault) {
                c.index = choices.length;
                choices.push(c);
            }
        }
        return choices;
    }
    get currentText() {
        this.IfAsyncWeCant("call currentText since it's a work in progress");
        return this.state.currentText;
    }
    get currentTags() {
        this.IfAsyncWeCant("call currentTags since it's a work in progress");
        return this.state.currentTags;
    }
    get currentErrors() {
        return this.state.currentErrors;
    }
    get currentWarnings() {
        return this.state.currentWarnings;
    }
    get hasError() {
        return this.state.hasError;
    }
    get hasWarning() {
        return this.state.hasWarning;
    }
    get variablesState() {
        return this.state.variablesState;
    }
    get listDefinitions() {
        return this._listDefinitions;
    }
    get state() {
        return this._state;
    }
    // TODO: Implement Profiler
    StartProfiling() {
        /* */
    }
    EndProfiling() {
        /* */
    }
    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.
    // Will only return a value if writer was not provided.
    ToJson(writer) {
        let shouldReturn = false;
        if (!writer) {
            shouldReturn = true;
            writer = new SimpleJson_1.SimpleJson.Writer();
        }
        writer.WriteObjectStart();
        writer.WriteIntProperty("inkVersion", Story.inkVersionCurrent);
        writer.WriteProperty("root", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));
        if (this._listDefinitions != null) {
            writer.WritePropertyStart("listDefs");
            writer.WriteObjectStart();
            for (let def of this._listDefinitions.lists) {
                writer.WritePropertyStart(def.name);
                writer.WriteObjectStart();
                for (let [key, value] of def.items) {
                    let item = InkList_1.InkListItem.fromSerializedKey(key);
                    let val = value;
                    writer.WriteIntProperty(item.itemName, val);
                }
                writer.WriteObjectEnd();
                writer.WritePropertyEnd();
            }
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        if (shouldReturn)
            return writer.ToString();
    }
    ResetState() {
        this.IfAsyncWeCant("ResetState");
        this._state = new StoryState_1.StoryState(this);
        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));
        this.ResetGlobals();
    }
    ResetErrors() {
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ResetErrors();
    }
    ResetCallstack() {
        this.IfAsyncWeCant("ResetCallstack");
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ForceEnd();
    }
    ResetGlobals() {
        if (this._mainContentContainer.namedContent.get("global decl")) {
            let originalPointer = this.state.currentPointer.copy();
            this.ChoosePath(new Path_1.Path("global decl"), false);
            this.ContinueInternal();
            this.state.currentPointer = originalPointer;
        }
        this.state.variablesState.SnapshotDefaultGlobals();
    }
    Continue() {
        this.ContinueAsync(0);
        return this.currentText;
    }
    get canContinue() {
        return this.state.canContinue;
    }
    get asyncContinueComplete() {
        return !this._asyncContinueActive;
    }
    ContinueAsync(millisecsLimitAsync) {
        if (!this._hasValidatedExternals)
            this.ValidateExternalBindings();
        this.ContinueInternal(millisecsLimitAsync);
    }
    ContinueInternal(millisecsLimitAsync = 0) {
        if (this._profiler != null)
            this._profiler.PreContinue();
        let isAsyncTimeLimited = millisecsLimitAsync > 0;
        this._recursiveContinueCount++;
        if (!this._asyncContinueActive) {
            this._asyncContinueActive = isAsyncTimeLimited;
            if (!this.canContinue) {
                throw new StoryException_1.StoryException("Can't continue - should check canContinue before calling Continue");
            }
            this._state.didSafeExit = false;
            this._state.ResetOutput();
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = true;
        }
        let durationStopwatch = new StopWatch_1.Stopwatch();
        durationStopwatch.Start();
        let outputStreamEndsInNewline = false;
        do {
            try {
                outputStreamEndsInNewline = this.ContinueSingleStep();
            }
            catch (e) {
                if (!(e instanceof StoryException_1.StoryException))
                    throw e;
                this.AddError(e.message, undefined, e.useEndLineNumber);
                break;
            }
            if (outputStreamEndsInNewline)
                break;
            if (this._asyncContinueActive &&
                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {
                break;
            }
        } while (this.canContinue);
        durationStopwatch.Stop();
        if (outputStreamEndsInNewline || !this.canContinue) {
            if (this._stateSnapshotAtLastNewline !== null) {
                this.RestoreStateSnapshot();
            }
            if (!this.canContinue) {
                if (this.state.callStack.canPopThread)
                    this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");
                if (this.state.generatedChoices.length == 0 &&
                    !this.state.didSafeExit &&
                    this._temporaryEvaluationContainer == null) {
                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))
                        this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))
                        this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");
                    else if (!this.state.callStack.canPop)
                        this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");
                    else
                        this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!");
                }
            }
            this.state.didSafeExit = false;
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = false;
            this._asyncContinueActive = false;
        }
        this._recursiveContinueCount--;
        if (this._profiler != null)
            this._profiler.PostContinue();
    }
    ContinueSingleStep() {
        if (this._profiler != null)
            this._profiler.PreStep();
        this.Step();
        if (this._profiler != null)
            this._profiler.PostStep();
        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {
            this.TryFollowDefaultInvisibleChoice();
        }
        if (this._profiler != null)
            this._profiler.PreSnapshot();
        if (!this.state.inStringEvaluation) {
            if (this._stateSnapshotAtLastNewline !== null) {
                if (this._stateSnapshotAtLastNewline.currentTags === null) {
                    return NullException_1.throwNullException("this._stateAtLastNewline.currentTags");
                }
                if (this.state.currentTags === null) {
                    return NullException_1.throwNullException("this.state.currentTags");
                }
                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);
                if (change == Story.OutputStateChange.ExtendedBeyondNewline) {
                    this.RestoreStateSnapshot();
                    return true;
                }
                else if (change == Story.OutputStateChange.NewlineRemoved) {
                    this.DiscardSnapshot();
                }
            }
            if (this.state.outputStreamEndsInNewline) {
                if (this.canContinue) {
                    if (this._stateSnapshotAtLastNewline == null)
                        this.StateSnapshot();
                }
                else {
                    this.DiscardSnapshot();
                }
            }
        }
        if (this._profiler != null)
            this._profiler.PostSnapshot();
        return false;
    }
    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {
        if (prevText === null) {
            return NullException_1.throwNullException("prevText");
        }
        if (currText === null) {
            return NullException_1.throwNullException("currText");
        }
        let newlineStillExists = currText.length >= prevText.length &&
            currText.charAt(prevText.length - 1) == "\n";
        if (prevTagCount == currTagCount &&
            prevText.length == currText.length &&
            newlineStillExists)
            return Story.OutputStateChange.NoChange;
        if (!newlineStillExists) {
            return Story.OutputStateChange.NewlineRemoved;
        }
        if (currTagCount > prevTagCount)
            return Story.OutputStateChange.ExtendedBeyondNewline;
        for (let i = prevText.length; i < currText.length; i++) {
            let c = currText.charAt(i);
            if (c != " " && c != "\t") {
                return Story.OutputStateChange.ExtendedBeyondNewline;
            }
        }
        return Story.OutputStateChange.NoChange;
    }
    ContinueMaximally() {
        this.IfAsyncWeCant("ContinueMaximally");
        let sb = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            sb.Append(this.Continue());
        }
        return sb.toString();
    }
    ContentAtPath(path) {
        return this.mainContentContainer.ContentAtPath(path);
    }
    KnotContainerWithName(name) {
        let namedContainer = this.mainContentContainer.namedContent.get(name);
        if (namedContainer instanceof Container_1.Container)
            return namedContainer;
        else
            return null;
    }
    PointerAtPath(path) {
        if (path.length == 0)
            return Pointer_1.Pointer.Null;
        let p = new Pointer_1.Pointer();
        let pathLengthToUse = path.length;
        let result = null;
        if (path.lastComponent === null) {
            return NullException_1.throwNullException("path.lastComponent");
        }
        if (path.lastComponent.isIndex) {
            pathLengthToUse = path.length - 1;
            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);
            p.container = result.container;
            p.index = path.lastComponent.index;
        }
        else {
            result = this.mainContentContainer.ContentAtPath(path);
            p.container = result.container;
            p.index = -1;
        }
        if (result.obj == null ||
            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {
            this.Error("Failed to find content at path '" +
                path +
                "', and no approximation of it was possible.");
        }
        else if (result.approximate)
            this.Warning("Failed to find content at path '" +
                path +
                "', so it was approximated to: '" +
                result.obj.path +
                "'.");
        return p;
    }
    StateSnapshot() {
        this._stateSnapshotAtLastNewline = this._state;
        this._state = this._state.CopyAndStartPatching();
    }
    RestoreStateSnapshot() {
        if (this._stateSnapshotAtLastNewline === null) {
            NullException_1.throwNullException("_stateSnapshotAtLastNewline");
        }
        this._stateSnapshotAtLastNewline.RestoreAfterPatch();
        this._state = this._stateSnapshotAtLastNewline;
        this._stateSnapshotAtLastNewline = null;
        if (!this._asyncSaving) {
            this._state.ApplyAnyPatch();
        }
    }
    DiscardSnapshot() {
        if (!this._asyncSaving)
            this._state.ApplyAnyPatch();
        this._stateSnapshotAtLastNewline = null;
    }
    CopyStateForBackgroundThreadSave() {
        this.IfAsyncWeCant("start saving on a background thread");
        if (this._asyncSaving)
            throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");
        let stateToSave = this._state;
        this._state = this._state.CopyAndStartPatching();
        this._asyncSaving = true;
        return stateToSave;
    }
    BackgroundSaveComplete() {
        if (this._stateSnapshotAtLastNewline === null) {
            this._state.ApplyAnyPatch();
        }
        this._asyncSaving = false;
    }
    Step() {
        let shouldAddToStream = true;
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull) {
            return;
        }
        // Container containerToEnter = pointer.Resolve () as Container;
        let containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        while (containerToEnter) {
            this.VisitContainer(containerToEnter, true);
            // No content? the most we can do is step past it
            if (containerToEnter.content.length == 0) {
                break;
            }
            pointer = Pointer_1.Pointer.StartOf(containerToEnter);
            // containerToEnter = pointer.Resolve() as Container;
            containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        }
        this.state.currentPointer = pointer.copy();
        if (this._profiler != null)
            this._profiler.Step(this.state.callStack);
        // Is the current content object:
        //  - Normal content
        //  - Or a logic/flow statement - if so, do it
        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot
        // that was diverted to rather than called as a function)
        let currentContentObj = pointer.Resolve();
        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);
        // Has flow been forced to end by flow control above?
        if (this.state.currentPointer.isNull) {
            return;
        }
        if (isLogicOrFlowControl) {
            shouldAddToStream = false;
        }
        // Choice with condition?
        // var choicePoint = currentContentObj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(currentContentObj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let choice = this.ProcessChoice(choicePoint);
            if (choice) {
                this.state.generatedChoices.push(choice);
            }
            currentContentObj = null;
            shouldAddToStream = false;
        }
        // If the container has no content, then it will be
        // the "content" itself, but we skip over it.
        if (currentContentObj instanceof Container_1.Container) {
            shouldAddToStream = false;
        }
        // Content to add to evaluation stack or the output stream
        if (shouldAddToStream) {
            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific
            // to our current (possibly temporary) context index. And make a copy of the pointer
            // so that we're not editing the original runtime object.
            // var varPointer = currentContentObj as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(currentContentObj, Value_1.VariablePointerValue);
            if (varPointer && varPointer.contextIndex == -1) {
                // Create new object so we're not overwriting the story's own data
                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);
                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);
            }
            // Expression evaluation content
            if (this.state.inExpressionEvaluation) {
                this.state.PushEvaluationStack(currentContentObj);
            }
            // Output stream content (i.e. not expression evaluation)
            else {
                this.state.PushToOutputStream(currentContentObj);
            }
        }
        // Increment the content pointer, following diverts if necessary
        this.NextContent();
        // Starting a thread should be done after the increment to the content pointer,
        // so that when returning from the thread, it returns to the content after this instruction.
        // var controlCmd = currentContentObj as ;
        let controlCmd = TypeAssertion_1.asOrNull(currentContentObj, ControlCommand_1.ControlCommand);
        if (controlCmd &&
            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {
            this.state.callStack.PushThread();
        }
    }
    VisitContainer(container, atStart) {
        if (!container.countingAtStartOnly || atStart) {
            if (container.visitsShouldBeCounted)
                this.state.IncrementVisitCountForContainer(container);
            if (container.turnIndexShouldBeCounted)
                this.state.RecordTurnIndexVisitToContainer(container);
        }
    }
    VisitChangedContainersDueToDivert() {
        let previousPointer = this.state.previousPointer.copy();
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull || pointer.index == -1)
            return;
        this._prevContainers.length = 0;
        if (!previousPointer.isNull) {
            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;
            let resolvedPreviousAncestor = previousPointer.Resolve();
            let prevAncestor = TypeAssertion_1.asOrNull(resolvedPreviousAncestor, Container_1.Container) ||
                TypeAssertion_1.asOrNull(previousPointer.container, Container_1.Container);
            while (prevAncestor) {
                this._prevContainers.push(prevAncestor);
                // prevAncestor = prevAncestor.parent as Container;
                prevAncestor = TypeAssertion_1.asOrNull(prevAncestor.parent, Container_1.Container);
            }
        }
        let currentChildOfContainer = pointer.Resolve();
        if (currentChildOfContainer == null)
            return;
        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;
        let currentContainerAncestor = TypeAssertion_1.asOrNull(currentChildOfContainer.parent, Container_1.Container);
        while (currentContainerAncestor &&
            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||
                currentContainerAncestor.countingAtStartOnly)) {
            // Check whether this ancestor container is being entered at the start,
            // by checking whether the child object is the first.
            let enteringAtStart = currentContainerAncestor.content.length > 0 &&
                currentChildOfContainer == currentContainerAncestor.content[0];
            // Mark a visit to this container
            this.VisitContainer(currentContainerAncestor, enteringAtStart);
            currentChildOfContainer = currentContainerAncestor;
            // currentContainerAncestor = currentContainerAncestor.parent as Container;
            currentContainerAncestor = TypeAssertion_1.asOrNull(currentContainerAncestor.parent, Container_1.Container);
        }
    }
    ProcessChoice(choicePoint) {
        let showChoice = true;
        // Don't create choice if choice point doesn't pass conditional
        if (choicePoint.hasCondition) {
            let conditionValue = this.state.PopEvaluationStack();
            if (!this.IsTruthy(conditionValue)) {
                showChoice = false;
            }
        }
        let startText = "";
        let choiceOnlyText = "";
        if (choicePoint.hasChoiceOnlyContent) {
            // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;
            let choiceOnlyStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            choiceOnlyText = choiceOnlyStrVal.value || "";
        }
        if (choicePoint.hasStartContent) {
            // var startStrVal = state.PopEvaluationStack () as StringValue;
            let startStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            startText = startStrVal.value || "";
        }
        // Don't create choice if player has already read this content
        if (choicePoint.onceOnly) {
            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);
            if (visitCount > 0) {
                showChoice = false;
            }
        }
        // We go through the full process of creating the choice above so
        // that we consume the content for it, since otherwise it'll
        // be shown on the output stream.
        if (!showChoice) {
            return null;
        }
        let choice = new Choice_1.Choice();
        choice.targetPath = choicePoint.pathOnChoice;
        choice.sourcePath = choicePoint.path.toString();
        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;
        choice.threadAtGeneration = this.state.callStack.ForkThread();
        choice.text = (startText + choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g, "");
        return choice;
    }
    IsTruthy(obj) {
        let truthy = false;
        if (obj instanceof Value_1.Value) {
            let val = obj;
            if (val instanceof Value_1.DivertTargetValue) {
                let divTarget = val;
                this.Error("Shouldn't use a divert target (to " +
                    divTarget.targetPath +
                    ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
                return false;
            }
            return val.isTruthy;
        }
        return truthy;
    }
    PerformLogicAndFlowControl(contentObj) {
        if (contentObj == null) {
            return false;
        }
        // Divert
        if (contentObj instanceof Divert_1.Divert) {
            let currentDivert = contentObj;
            if (currentDivert.isConditional) {
                let conditionValue = this.state.PopEvaluationStack();
                // False conditional? Cancel divert
                if (!this.IsTruthy(conditionValue))
                    return true;
            }
            if (currentDivert.hasVariableTarget) {
                let varName = currentDivert.variableDivertName;
                let varContents = this.state.variablesState.GetVariableWithName(varName);
                if (varContents == null) {
                    this.Error("Tried to divert using a target from a variable that could not be found (" +
                        varName +
                        ")");
                }
                else if (!(varContents instanceof Value_1.DivertTargetValue)) {
                    // var intContent = varContents as IntValue;
                    let intContent = TypeAssertion_1.asOrNull(varContents, Value_1.IntValue);
                    let errorMessage = "Tried to divert to a target from a variable, but the variable (" +
                        varName +
                        ") didn't contain a divert target, it ";
                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {
                        errorMessage += "was empty/null (the value 0).";
                    }
                    else {
                        errorMessage += "contained '" + varContents + "'.";
                    }
                    this.Error(errorMessage);
                }
                let target = TypeAssertion_1.asOrThrows(varContents, Value_1.DivertTargetValue);
                this.state.divertedPointer = this.PointerAtPath(target.targetPath);
            }
            else if (currentDivert.isExternal) {
                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);
                return true;
            }
            else {
                this.state.divertedPointer = currentDivert.targetPointer.copy();
            }
            if (currentDivert.pushesToStack) {
                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);
            }
            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {
                if (currentDivert &&
                    currentDivert.debugMetadata &&
                    currentDivert.debugMetadata.sourceName != null) {
                    this.Error("Divert target doesn't exist: " +
                        currentDivert.debugMetadata.sourceName);
                }
                else {
                    this.Error("Divert resolution failed: " + currentDivert);
                }
            }
            return true;
        }
        // Start/end an expression evaluation? Or print out the result?
        else if (contentObj instanceof ControlCommand_1.ControlCommand) {
            let evalCommand = contentObj;
            switch (evalCommand.commandType) {
                case ControlCommand_1.ControlCommand.CommandType.EvalStart:
                    this.Assert(this.state.inExpressionEvaluation === false, "Already in expression evaluation?");
                    this.state.inExpressionEvaluation = true;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:
                    this.Assert(this.state.inExpressionEvaluation === true, "Not in expression evaluation mode");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:
                    // If the expression turned out to be empty, there may not be anything on the stack
                    if (this.state.evaluationStack.length > 0) {
                        let output = this.state.PopEvaluationStack();
                        // Functions may evaluate to Void, in which case we skip output
                        if (!(output instanceof Void_1.Void)) {
                            // TODO: Should we really always blanket convert to string?
                            // It would be okay to have numbers in the output stream the
                            // only problem is when exporting text for viewing, it skips over numbers etc.
                            let text = new Value_1.StringValue(output.toString());
                            this.state.PushToOutputStream(text);
                        }
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.NoOp:
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Duplicate:
                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:
                    this.state.PopEvaluationStack();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopFunction:
                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:
                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction
                        ? PushPop_1.PushPopType.Function
                        : PushPop_1.PushPopType.Tunnel;
                    let overrideTunnelReturnTarget = null;
                    if (popType == PushPop_1.PushPopType.Tunnel) {
                        let popped = this.state.PopEvaluationStack();
                        // overrideTunnelReturnTarget = popped as DivertTargetValue;
                        overrideTunnelReturnTarget = TypeAssertion_1.asOrNull(popped, Value_1.DivertTargetValue);
                        if (overrideTunnelReturnTarget === null) {
                            this.Assert(popped instanceof Void_1.Void, "Expected void if ->-> doesn't override target");
                        }
                    }
                    if (this.state.TryExitFunctionEvaluationFromGame()) {
                        break;
                    }
                    else if (this.state.callStack.currentElement.type != popType ||
                        !this.state.callStack.canPop) {
                        let names = new Map();
                        names.set(PushPop_1.PushPopType.Function, "function return statement (~ return)");
                        names.set(PushPop_1.PushPopType.Tunnel, "tunnel onwards statement (->->)");
                        let expected = names.get(this.state.callStack.currentElement.type);
                        if (!this.state.callStack.canPop) {
                            expected = "end of flow (-> END or choice)";
                        }
                        let errorMsg = "Found " + names.get(popType) + ", when expected " + expected;
                        this.Error(errorMsg);
                    }
                    else {
                        this.state.PopCallStack();
                        if (overrideTunnelReturnTarget)
                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.BeginString:
                    this.state.PushToOutputStream(evalCommand);
                    this.Assert(this.state.inExpressionEvaluation === true, "Expected to be in an expression when evaluating a string");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EndString:
                    let contentStackForString = [];
                    let outputCountConsumed = 0;
                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
                        let obj = this.state.outputStream[i];
                        outputCountConsumed++;
                        // var command = obj as ControlCommand;
                        let command = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
                        if (command &&
                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                            break;
                        }
                        if (obj instanceof Value_1.StringValue) {
                            contentStackForString.push(obj);
                        }
                    }
                    // Consume the content that was produced for this string
                    this.state.PopFromOutputStream(outputCountConsumed);
                    // The C# version uses a Stack for contentStackForString, but we're
                    // using a simple array, so we need to reverse it before using it
                    contentStackForString = contentStackForString.reverse();
                    // Build string out of the content we collected
                    let sb = new StringBuilder_1.StringBuilder();
                    for (let c of contentStackForString) {
                        sb.Append(c.toString());
                    }
                    // Return to expression evaluation (from content mode)
                    this.state.inExpressionEvaluation = true;
                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:
                    let choiceCount = this.state.generatedChoices.length;
                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Turns:
                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:
                case ControlCommand_1.ControlCommand.CommandType.ReadCount:
                    let target = this.state.PopEvaluationStack();
                    if (!(target instanceof Value_1.DivertTargetValue)) {
                        let extraNote = "";
                        if (target instanceof Value_1.IntValue)
                            extraNote =
                                ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
                        this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw " +
                            target +
                            extraNote);
                        break;
                    }
                    // var divertTarget = target as DivertTargetValue;
                    let divertTarget = TypeAssertion_1.asOrThrows(target, Value_1.DivertTargetValue);
                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;
                    let container = TypeAssertion_1.asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);
                    let eitherCount;
                    if (container != null) {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = this.state.TurnsSinceForContainer(container);
                        else
                            eitherCount = this.state.VisitCountForContainer(container);
                    }
                    else {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = -1;
                        else
                            eitherCount = 0;
                        this.Warning("Failed to find container for " +
                            evalCommand.toString() +
                            " lookup at " +
                            divertTarget.targetPath.toString());
                    }
                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Random: {
                    let maxInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    let minInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (minInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");
                    if (maxInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (maxInt.value === null) {
                        return NullException_1.throwNullException("maxInt.value");
                    }
                    if (minInt.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    let randomRange = maxInt.value - minInt.value + 1;
                    if (randomRange <= 0)
                        this.Error("RANDOM was called with minimum as " +
                            minInt.value +
                            " and maximum as " +
                            maxInt.value +
                            ". The maximum must be larger");
                    let resultSeed = this.state.storySeed + this.state.previousRandom;
                    let random = new PRNG_1.PRNG(resultSeed);
                    let nextRandom = random.next();
                    let chosenValue = (nextRandom % randomRange) + minInt.value;
                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));
                    // Next random number (rather than keeping the Random object around)
                    this.state.previousRandom = nextRandom;
                    break;
                }
                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:
                    let seed = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (seed == null || seed instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value passed to SEED_RANDOM");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (seed.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    this.state.storySeed = seed.value;
                    this.state.previousRandom = 0;
                    this.state.PushEvaluationStack(new Void_1.Void());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:
                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count
                    this.state.PushEvaluationStack(new Value_1.IntValue(count));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:
                    let shuffleIndex = this.NextSequenceShuffleIndex();
                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.StartThread:
                    // Handled in main step function
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Done:
                    // We may exist in the context of the initial
                    // act of creating the thread, or in the context of
                    // evaluating the content.
                    if (this.state.callStack.canPopThread) {
                        this.state.callStack.PopThread();
                    }
                    // In normal flow - allow safe exit without warning
                    else {
                        this.state.didSafeExit = true;
                        // Stop flow in current thread
                        this.state.currentPointer = Pointer_1.Pointer.Null;
                    }
                    break;
                // Force flow to end completely
                case ControlCommand_1.ControlCommand.CommandType.End:
                    this.state.ForceEnd();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:
                    // var intVal = state.PopEvaluationStack () as IntValue;
                    let intVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    // var listNameVal = state.PopEvaluationStack () as StringValue;
                    let listNameVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
                    if (intVal === null) {
                        throw new StoryException_1.StoryException("Passed non-integer when creating a list element from a numerical value.");
                    }
                    let generatedListValue = null;
                    if (this.listDefinitions === null) {
                        return NullException_1.throwNullException("this.listDefinitions");
                    }
                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);
                    if (foundListDef.exists) {
                        // Originally a primitive type, but here, can be null.
                        // TODO: Replace by default value?
                        if (intVal.value === null) {
                            return NullException_1.throwNullException("minInt.value");
                        }
                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);
                        if (foundItem.exists) {
                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);
                        }
                    }
                    else {
                        throw new StoryException_1.StoryException("Failed to find LIST called " + listNameVal.value);
                    }
                    if (generatedListValue == null)
                        generatedListValue = new Value_1.ListValue();
                    this.state.PushEvaluationStack(generatedListValue);
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRange:
                    let max = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    let min = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    // var targetList = state.PopEvaluationStack () as ListValue;
                    let targetList = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.ListValue);
                    if (targetList === null || min === null || max === null)
                        throw new StoryException_1.StoryException("Expected list, minimum and maximum for LIST_RANGE");
                    if (targetList.value === null) {
                        return NullException_1.throwNullException("targetList.value");
                    }
                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);
                    this.state.PushEvaluationStack(new Value_1.ListValue(result));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {
                    let listVal = this.state.PopEvaluationStack();
                    if (listVal === null)
                        throw new StoryException_1.StoryException("Expected list for LIST_RANDOM");
                    let list = listVal.value;
                    let newList = null;
                    if (list === null) {
                        throw NullException_1.throwNullException("list");
                    }
                    if (list.Count == 0) {
                        newList = new InkList_1.InkList();
                    }
                    else {
                        // Generate a random index for the element to take
                        let resultSeed = this.state.storySeed + this.state.previousRandom;
                        let random = new PRNG_1.PRNG(resultSeed);
                        let nextRandom = random.next();
                        let listItemIndex = nextRandom % list.Count;
                        // This bit is a little different from the original
                        // C# code, since iterators do not work in the same way.
                        // First, we iterate listItemIndex - 1 times, calling next().
                        // The listItemIndex-th time is made outside of the loop,
                        // in order to retrieve the value.
                        let listEnumerator = list.entries();
                        for (let i = 0; i <= listItemIndex - 1; i++) {
                            listEnumerator.next();
                        }
                        let value = listEnumerator.next().value;
                        let randomItem = {
                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),
                            Value: value[1],
                        };
                        // Origin list is simply the origin of the one element
                        if (randomItem.Key.originName === null) {
                            return NullException_1.throwNullException("randomItem.Key.originName");
                        }
                        newList = new InkList_1.InkList(randomItem.Key.originName, this);
                        newList.Add(randomItem.Key, randomItem.Value);
                        this.state.previousRandom = nextRandom;
                    }
                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));
                    break;
                }
                default:
                    this.Error("unhandled ControlCommand: " + evalCommand);
                    break;
            }
            return true;
        }
        // Variable assignment
        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {
            let varAss = contentObj;
            let assignedVal = this.state.PopEvaluationStack();
            this.state.variablesState.Assign(varAss, assignedVal);
            return true;
        }
        // Variable reference
        else if (contentObj instanceof VariableReference_1.VariableReference) {
            let varRef = contentObj;
            let foundValue = null;
            // Explicit read count value
            if (varRef.pathForCount != null) {
                let container = varRef.containerForCount;
                let count = this.state.VisitCountForContainer(container);
                foundValue = new Value_1.IntValue(count);
            }
            // Normal variable reference
            else {
                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);
                if (foundValue == null) {
                    this.Warning("Variable not found: '" +
                        varRef.name +
                        "'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.");
                    foundValue = new Value_1.IntValue(0);
                }
            }
            this.state.PushEvaluationStack(foundValue);
            return true;
        }
        // Native function call
        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {
            let func = contentObj;
            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);
            let result = func.Call(funcParams);
            this.state.PushEvaluationStack(result);
            return true;
        }
        // No control content, must be ordinary content
        return false;
    }
    ChoosePathString(path, resetCallstack = true, args = []) {
        this.IfAsyncWeCant("call ChoosePathString right now");
        if (resetCallstack) {
            this.ResetCallstack();
        }
        else {
            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {
                let funcDetail = "";
                let container = this.state.callStack.currentElement.currentPointer
                    .container;
                if (container != null) {
                    funcDetail = "(" + container.path.toString() + ") ";
                }
                throw new Error("Story was running a function " +
                    funcDetail +
                    "when you called ChoosePathString(" +
                    path +
                    ") - this is almost certainly not not what you want! Full stack trace: \n" +
                    this.state.callStack.callStackTrace);
            }
        }
        this.state.PassArgumentsToEvaluationStack(args);
        this.ChoosePath(new Path_1.Path(path));
    }
    IfAsyncWeCant(activityStr) {
        if (this._asyncContinueActive)
            throw new Error("Can't " +
                activityStr +
                ". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.");
    }
    ChoosePath(p, incrementingTurnIndex = true) {
        this.state.SetChosenPath(p, incrementingTurnIndex);
        // Take a note of newly visited containers for read counts etc
        this.VisitChangedContainersDueToDivert();
    }
    ChooseChoiceIndex(choiceIdx) {
        choiceIdx = choiceIdx;
        let choices = this.currentChoices;
        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, "choice out of range");
        let choiceToChoose = choices[choiceIdx];
        if (choiceToChoose.threadAtGeneration === null) {
            return NullException_1.throwNullException("choiceToChoose.threadAtGeneration");
        }
        if (choiceToChoose.targetPath === null) {
            return NullException_1.throwNullException("choiceToChoose.targetPath");
        }
        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;
        this.ChoosePath(choiceToChoose.targetPath);
    }
    HasFunction(functionName) {
        try {
            return this.KnotContainerWithName(functionName) != null;
        }
        catch (e) {
            return false;
        }
    }
    EvaluateFunction(functionName, args = [], returnTextOutput = false) {
        // EvaluateFunction behaves slightly differently than the C# version.
        // In C#, you can pass a (second) parameter `out textOutput` to get the
        // text outputted by the function. This is not possible in js. Instead,
        // we maintain the regular signature (functionName, args), plus an
        // optional third parameter returnTextOutput. If set to true, we will
        // return both the textOutput and the returned value, as an object.
        this.IfAsyncWeCant("evaluate a function");
        if (functionName == null) {
            throw new Error("Function is null");
        }
        else if (functionName == "" || functionName.trim() == "") {
            throw new Error("Function is empty or white space.");
        }
        let funcContainer = this.KnotContainerWithName(functionName);
        if (funcContainer == null) {
            throw new Error("Function doesn't exist: '" + functionName + "'");
        }
        let outputStreamBefore = [];
        outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);
        this._state.ResetOutput();
        this.state.StartFunctionEvaluationFromGame(funcContainer, args);
        // Evaluate the function, and collect the string output
        let stringOutput = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            stringOutput.Append(this.Continue());
        }
        let textOutput = stringOutput.toString();
        this._state.ResetOutput(outputStreamBefore);
        let result = this.state.CompleteFunctionEvaluationFromGame();
        return returnTextOutput ? { returned: result, output: textOutput } : result;
    }
    EvaluateExpression(exprContainer) {
        let startCallStackHeight = this.state.callStack.elements.length;
        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);
        this._temporaryEvaluationContainer = exprContainer;
        this.state.GoToStart();
        let evalStackHeight = this.state.evaluationStack.length;
        this.Continue();
        this._temporaryEvaluationContainer = null;
        // Should have fallen off the end of the Container, which should
        // have auto-popped, but just in case we didn't for some reason,
        // manually pop to restore the state (including currentPath).
        if (this.state.callStack.elements.length > startCallStackHeight) {
            this.state.PopCallStack();
        }
        let endStackHeight = this.state.evaluationStack.length;
        if (endStackHeight > evalStackHeight) {
            return this.state.PopEvaluationStack();
        }
        else {
            return null;
        }
    }
    CallExternalFunction(funcName, numberOfArguments) {
        if (funcName === null) {
            return NullException_1.throwNullException("funcName");
        }
        let func = this._externals.get(funcName);
        let fallbackFunctionContainer = null;
        let foundExternal = typeof func !== "undefined";
        // Try to use fallback function?
        if (!foundExternal) {
            if (this.allowExternalFunctionFallbacks) {
                fallbackFunctionContainer = this.KnotContainerWithName(funcName);
                this.Assert(fallbackFunctionContainer !== null, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound, and fallback ink function could not be found.");
                // Divert direct into fallback function and we're done
                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);
                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);
                return;
            }
            else {
                this.Assert(false, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound (and ink fallbacks disabled).");
            }
        }
        // Pop arguments
        let args = [];
        for (let i = 0; i < numberOfArguments; ++i) {
            // var poppedObj = state.PopEvaluationStack () as Value;
            let poppedObj = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.Value);
            let valueObj = poppedObj.valueObject;
            args.push(valueObj);
        }
        // Reverse arguments from the order they were popped,
        // so they're the right way round again.
        args.reverse();
        // Run the function!
        let funcResult = func(args);
        // Convert return value (if any) to the a type that the ink engine can use
        let returnObj = null;
        if (funcResult != null) {
            returnObj = Value_1.Value.Create(funcResult);
            this.Assert(returnObj !== null, "Could not create ink value from returned object of type " +
                typeof funcResult);
        }
        else {
            returnObj = new Void_1.Void();
        }
        this.state.PushEvaluationStack(returnObj);
    }
    BindExternalFunctionGeneral(funcName, func) {
        this.IfAsyncWeCant("bind an external function");
        this.Assert(!this._externals.has(funcName), "Function '" + funcName + "' has already been bound.");
        this._externals.set(funcName, func);
    }
    TryCoerce(value) {
        // We're skipping type coercition in this implementation. First of, js
        // is loosely typed, so it's not that important. Secondly, there is no
        // clean way (AFAIK) for the user to describe what type of parameters
        // they expect.
        return value;
    }
    BindExternalFunction(funcName, func) {
        this.Assert(func != null, "Can't bind a null function");
        this.BindExternalFunctionGeneral(funcName, (args) => {
            this.Assert(args.length >= func.length, "External function expected " + func.length + " arguments");
            let coercedArgs = [];
            for (let i = 0, l = args.length; i < l; i++) {
                coercedArgs[i] = this.TryCoerce(args[i]);
            }
            return func.apply(null, coercedArgs);
        });
    }
    UnbindExternalFunction(funcName) {
        this.IfAsyncWeCant("unbind an external a function");
        this.Assert(this._externals.has(funcName), "Function '" + funcName + "' has not been bound.");
        this._externals.delete(funcName);
    }
    ValidateExternalBindings() {
        let c = null;
        let o = null;
        let missingExternals = arguments[1] || new Set();
        if (arguments[0] instanceof Container_1.Container) {
            c = arguments[0];
        }
        if (arguments[0] instanceof Object_1.InkObject) {
            o = arguments[0];
        }
        if (c === null && o === null) {
            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);
            this._hasValidatedExternals = true;
            // No problem! Validation complete
            if (missingExternals.size == 0) {
                this._hasValidatedExternals = true;
            }
            else {
                let message = "Error: Missing function binding for external";
                message += missingExternals.size > 1 ? "s" : "";
                message += ": '";
                message += Array.from(missingExternals).join("', '");
                message += "' ";
                message += this.allowExternalFunctionFallbacks
                    ? ", and no fallback ink function found."
                    : " (ink fallbacks disabled)";
                this.Error(message);
            }
        }
        else if (c != null) {
            for (let innerContent of c.content) {
                let container = innerContent;
                if (container == null || !container.hasValidName)
                    this.ValidateExternalBindings(innerContent, missingExternals);
            }
            for (let [, value] of c.namedContent) {
                this.ValidateExternalBindings(TypeAssertion_1.asOrNull(value, Object_1.InkObject), missingExternals);
            }
        }
        else if (o != null) {
            let divert = TypeAssertion_1.asOrNull(o, Divert_1.Divert);
            if (divert && divert.isExternal) {
                let name = divert.targetPathString;
                if (name === null) {
                    return NullException_1.throwNullException("name");
                }
                if (!this._externals.has(name)) {
                    if (this.allowExternalFunctionFallbacks) {
                        let fallbackFound = this.mainContentContainer.namedContent.has(name);
                        if (!fallbackFound) {
                            missingExternals.add(name);
                        }
                    }
                    else {
                        missingExternals.add(name);
                    }
                }
            }
        }
    }
    ObserveVariable(variableName, observer) {
        this.IfAsyncWeCant("observe a new variable");
        if (this._variableObservers === null)
            this._variableObservers = new Map();
        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))
            throw new StoryException_1.StoryException("Cannot observe variable '" +
                variableName +
                "' because it wasn't declared in the ink story.");
        if (this._variableObservers.has(variableName)) {
            this._variableObservers.get(variableName).push(observer);
        }
        else {
            this._variableObservers.set(variableName, [observer]);
        }
    }
    ObserveVariables(variableNames, observers) {
        for (let i = 0, l = variableNames.length; i < l; i++) {
            this.ObserveVariable(variableNames[i], observers[i]);
        }
    }
    RemoveVariableObserver(observer, specificVariableName) {
        this.IfAsyncWeCant("remove a variable observer");
        if (this._variableObservers === null)
            return;
        if (typeof specificVariableName !== "undefined") {
            if (this._variableObservers.has(specificVariableName)) {
                let observers = this._variableObservers.get(specificVariableName);
                if (observer !== null) {
                    observers.splice(observers.indexOf(observer), 1);
                }
                else {
                    this._variableObservers.delete(specificVariableName);
                }
            }
        }
        else if (observer !== null) {
            let keys = this._variableObservers.keys();
            for (let varName of keys) {
                let observers = this._variableObservers.get(varName);
                observers.splice(observers.indexOf(observer), 1);
            }
        }
    }
    VariableStateDidChangeEvent(variableName, newValueObj) {
        if (this._variableObservers === null)
            return;
        let observers = this._variableObservers.get(variableName);
        if (typeof observers !== "undefined") {
            if (!(newValueObj instanceof Value_1.Value)) {
                throw new Error("Tried to get the value of a variable that isn't a standard type");
            }
            // var val = newValueObj as Value;
            let val = TypeAssertion_1.asOrThrows(newValueObj, Value_1.Value);
            for (let observer of observers) {
                observer(variableName, val.valueObject);
            }
        }
    }
    get globalTags() {
        return this.TagsAtStartOfFlowContainerWithPathString("");
    }
    TagsForContentAtPath(path) {
        return this.TagsAtStartOfFlowContainerWithPathString(path);
    }
    TagsAtStartOfFlowContainerWithPathString(pathString) {
        let path = new Path_1.Path(pathString);
        let flowContainer = this.ContentAtPath(path).container;
        if (flowContainer === null) {
            return NullException_1.throwNullException("flowContainer");
        }
        while (true) {
            let firstContent = flowContainer.content[0];
            if (firstContent instanceof Container_1.Container)
                flowContainer = firstContent;
            else
                break;
        }
        let tags = null;
        for (let c of flowContainer.content) {
            // var tag = c as Runtime.Tag;
            let tag = TypeAssertion_1.asOrNull(c, Tag_1.Tag);
            if (tag) {
                if (tags == null)
                    tags = [];
                tags.push(tag.text);
            }
            else
                break;
        }
        return tags;
    }
    BuildStringOfHierarchy() {
        let sb = new StringBuilder_1.StringBuilder();
        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    BuildStringOfContainer(container) {
        let sb = new StringBuilder_1.StringBuilder();
        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    NextContent() {
        this.state.previousPointer = this.state.currentPointer.copy();
        if (!this.state.divertedPointer.isNull) {
            this.state.currentPointer = this.state.divertedPointer.copy();
            this.state.divertedPointer = Pointer_1.Pointer.Null;
            this.VisitChangedContainersDueToDivert();
            if (!this.state.currentPointer.isNull) {
                return;
            }
        }
        let successfulPointerIncrement = this.IncrementContentPointer();
        if (!successfulPointerIncrement) {
            let didPop = false;
            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {
                this.state.PopCallStack(PushPop_1.PushPopType.Function);
                if (this.state.inExpressionEvaluation) {
                    this.state.PushEvaluationStack(new Void_1.Void());
                }
                didPop = true;
            }
            else if (this.state.callStack.canPopThread) {
                this.state.callStack.PopThread();
                didPop = true;
            }
            else {
                this.state.TryExitFunctionEvaluationFromGame();
            }
            if (didPop && !this.state.currentPointer.isNull) {
                this.NextContent();
            }
        }
    }
    IncrementContentPointer() {
        let successfulIncrement = true;
        let pointer = this.state.callStack.currentElement.currentPointer.copy();
        pointer.index++;
        if (pointer.container === null) {
            return NullException_1.throwNullException("pointer.container");
        }
        while (pointer.index >= pointer.container.content.length) {
            successfulIncrement = false;
            // Container nextAncestor = pointer.container.parent as Container;
            let nextAncestor = TypeAssertion_1.asOrNull(pointer.container.parent, Container_1.Container);
            if (nextAncestor instanceof Container_1.Container === false) {
                break;
            }
            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);
            if (indexInAncestor == -1) {
                break;
            }
            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);
            pointer.index++;
            successfulIncrement = true;
            if (pointer.container === null) {
                return NullException_1.throwNullException("pointer.container");
            }
        }
        if (!successfulIncrement)
            pointer = Pointer_1.Pointer.Null;
        this.state.callStack.currentElement.currentPointer = pointer.copy();
        return successfulIncrement;
    }
    TryFollowDefaultInvisibleChoice() {
        let allChoices = this._state.currentChoices;
        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);
        if (invisibleChoices.length == 0 ||
            allChoices.length > invisibleChoices.length)
            return false;
        let choice = invisibleChoices[0];
        if (choice.targetPath === null) {
            return NullException_1.throwNullException("choice.targetPath");
        }
        if (choice.threadAtGeneration === null) {
            return NullException_1.throwNullException("choice.threadAtGeneration");
        }
        this.state.callStack.currentThread = choice.threadAtGeneration;
        this.ChoosePath(choice.targetPath, false);
        return true;
    }
    NextSequenceShuffleIndex() {
        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;
        let numElementsIntVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
        if (!(numElementsIntVal instanceof Value_1.IntValue)) {
            this.Error("expected number of elements in sequence for shuffle index");
            return 0;
        }
        let seqContainer = this.state.currentPointer.container;
        if (seqContainer === null) {
            return NullException_1.throwNullException("seqContainer");
        }
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (numElementsIntVal.value === null) {
            return NullException_1.throwNullException("numElementsIntVal.value");
        }
        let numElements = numElementsIntVal.value;
        // var seqCountVal = state.PopEvaluationStack () as IntValue;
        let seqCountVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.IntValue);
        let seqCount = seqCountVal.value;
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (seqCount === null) {
            return NullException_1.throwNullException("seqCount");
        }
        let loopIndex = seqCount / numElements;
        let iterationIndex = seqCount % numElements;
        let seqPathStr = seqContainer.path.toString();
        let sequenceHash = 0;
        for (let i = 0, l = seqPathStr.length; i < l; i++) {
            sequenceHash += seqPathStr.charCodeAt(i) || 0;
        }
        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;
        let random = new PRNG_1.PRNG(Math.floor(randomSeed));
        let unpickedIndices = [];
        for (let i = 0; i < numElements; ++i) {
            unpickedIndices.push(i);
        }
        for (let i = 0; i <= iterationIndex; ++i) {
            let chosen = random.next() % unpickedIndices.length;
            let chosenIndex = unpickedIndices[chosen];
            unpickedIndices.splice(chosen, 1);
            if (i == iterationIndex) {
                return chosenIndex;
            }
        }
        throw new Error("Should never reach here");
    }
    Error(message, useEndLineNumber = false) {
        let e = new StoryException_1.StoryException(message);
        e.useEndLineNumber = useEndLineNumber;
        throw e;
    }
    Warning(message) {
        this.AddError(message, true);
    }
    AddError(message, isWarning = false, useEndLineNumber = false) {
        let dm = this.currentDebugMetadata;
        let errorTypeStr = isWarning ? "WARNING" : "ERROR";
        if (dm != null) {
            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": '" +
                    dm.fileName +
                    "' line " +
                    lineNum +
                    ": " +
                    message;
        }
        else if (!this.state.currentPointer.isNull) {
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": (" +
                    this.state.currentPointer +
                    "): " +
                    message;
        }
        else {
            message = "RUNTIME " + errorTypeStr + ": " + message;
        }
        this.state.AddError(message, isWarning);
        // In a broken state don't need to know about any other errors.
        if (!isWarning)
            this.state.ForceEnd();
    }
    Assert(condition, message = null) {
        if (condition == false) {
            if (message == null) {
                message = "Story assert";
            }
            throw new Error(message + " " + this.currentDebugMetadata);
        }
    }
    get currentDebugMetadata() {
        let dm;
        let pointer = this.state.currentPointer;
        if (!pointer.isNull && pointer.Resolve() !== null) {
            dm = pointer.Resolve().debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {
            pointer = this.state.callStack.elements[i].currentPointer;
            if (!pointer.isNull && pointer.Resolve() !== null) {
                dm = pointer.Resolve().debugMetadata;
                if (dm !== null) {
                    return dm;
                }
            }
        }
        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
            let outputObj = this.state.outputStream[i];
            dm = outputObj.debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        return null;
    }
    get mainContentContainer() {
        if (this._temporaryEvaluationContainer) {
            return this._temporaryEvaluationContainer;
        }
        else {
            return this._mainContentContainer;
        }
    }
}
exports.Story = Story;
Story.inkVersionCurrent = 19;
(function (Story) {
    let OutputStateChange;
    (function (OutputStateChange) {
        OutputStateChange[OutputStateChange["NoChange"] = 0] = "NoChange";
        OutputStateChange[OutputStateChange["ExtendedBeyondNewline"] = 1] = "ExtendedBeyondNewline";
        OutputStateChange[OutputStateChange["NewlineRemoved"] = 2] = "NewlineRemoved";
    })(OutputStateChange = Story.OutputStateChange || (Story.OutputStateChange = {}));
})(Story = exports.Story || (exports.Story = {}));
//# sourceMappingURL=Story.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryException.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryException.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryException = void 0;
class StoryException extends Error {
    constructor(message) {
        super(message);
        this.useEndLineNumber = false;
        this.message = message;
        this.name = "StoryException";
    }
}
exports.StoryException = StoryException;
//# sourceMappingURL=StoryException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryState.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryState.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryState = void 0;
const CallStack_1 = __webpack_require__(/*! ./CallStack */ "./node_modules/inkjs/engine/CallStack.js");
const VariablesState_1 = __webpack_require__(/*! ./VariablesState */ "./node_modules/inkjs/engine/VariablesState.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StatePatch_1 = __webpack_require__(/*! ./StatePatch */ "./node_modules/inkjs/engine/StatePatch.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this._patch = null;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this.currentTurnIndex = -1;
        let timeSeed = new Date().getTime();
        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        let writer = new SimpleJson_1.SimpleJson.Writer();
        this.WriteJson(writer);
        return writer.ToString();
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);
        this.LoadJsonObj(jObject);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut;
        if (this._patch !== null) {
            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;
            if (container === null)
                throw new Error("Content at path not found: " + pathString);
            visitCountOut = this._patch.TryGetVisitCount(container, 0);
            if (visitCountOut.exists)
                return visitCountOut.result;
        }
        visitCountOut = TryGetResult_1.tryGetValueFromMap(this._visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    VisitCountForContainer(container) {
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        if (!container.visitsShouldBeCounted) {
            this.story.Error("Read count for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
            return 0;
        }
        if (this._patch !== null) {
            let count = this._patch.TryGetVisitCount(container, 0);
            if (count.exists) {
                return count.result;
            }
        }
        let containerPathStr = container.path.toString();
        let count2 = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count2.exists) {
            return count2.result;
        }
        return 0;
    }
    IncrementVisitCountForContainer(container) {
        if (this._patch !== null) {
            let currCount = this.VisitCountForContainer(container);
            currCount++;
            this._patch.SetVisitCount(container, currCount);
            return;
        }
        let containerPathStr = container.path.toString();
        let count = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count.exists) {
            this._visitCounts.set(containerPathStr, count.result + 1);
        }
        else {
            this._visitCounts.set(containerPathStr, 1);
        }
    }
    RecordTurnIndexVisitToContainer(container) {
        if (this._patch !== null) {
            this._patch.SetTurnIndex(container, this.currentTurnIndex);
            return;
        }
        let containerPathStr = container.path.toString();
        this._turnIndices.set(containerPathStr, this.currentTurnIndex);
    }
    TurnsSinceForContainer(container) {
        if (!container.turnIndexShouldBeCounted) {
            this.story.Error("TURNS_SINCE() for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
        }
        if (this._patch !== null) {
            let index = this._patch.TryGetTurnIndex(container, 0);
            if (index.exists) {
                return this.currentTurnIndex - index.result;
            }
        }
        let containerPathStr = container.path.toString();
        let index2 = TryGetResult_1.tryGetValueFromMap(this._turnIndices, containerPathStr, 0);
        if (index2.exists) {
            return this.currentTurnIndex - index2.result;
        }
        else {
            return -1;
        }
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    set variablesState(value) {
        this._variablesState = value;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    set currentTurnIndex(value) {
        this._currentTurnIndex = value;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException("pointer.path");
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = c == " " || c == "\t";
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != "\n" &&
                    currentWhitespaceStart > 0 &&
                    currentWhitespaceStart != startOfLine) {
                    sb.Append(" ");
                }
                currentWhitespaceStart = -1;
            }
            if (c == "\n")
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    CopyAndStartPatching() {
        let copy = new StoryState(this.story);
        copy._patch = new StatePatch_1.StatePatch(this._patch);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        copy.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy.variablesState = this.variablesState;
        copy.variablesState.callStack = copy.callStack;
        copy.variablesState.patch = copy._patch;
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = this._visitCounts;
        copy._turnIndices = this._turnIndices;
        copy.currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    RestoreAfterPatch() {
        this.variablesState.callStack = this.callStack;
        this.variablesState.patch = this._patch;
    }
    ApplyAnyPatch() {
        if (this._patch === null)
            return;
        this.variablesState.ApplyPatch();
        for (let [key, value] of this._patch.visitCounts)
            this.ApplyCountChanges(key, value, true);
        for (let [key, value] of this._patch.turnIndices)
            this.ApplyCountChanges(key, value, false);
        this._patch = null;
    }
    ApplyCountChanges(container, newCount, isVisit) {
        let counts = isVisit ? this._visitCounts : this._turnIndices;
        counts.set(container.path.toString(), newCount);
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        let hasChoiceThreads = false;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException("c.threadAtGeneration");
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {
                if (!hasChoiceThreads) {
                    hasChoiceThreads = true;
                    writer.WritePropertyStart("choiceThreads");
                    writer.WriteObjectStart();
                }
                writer.WritePropertyStart(c.originalThreadIndex);
                c.threadAtGeneration.WriteJson(writer);
                writer.WritePropertyEnd();
            }
        }
        if (hasChoiceThreads) {
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        // In the following two calls, `WriteJson` is called inside an arrow
        // function to make sure `this` is correctly bound and passed down
        // the call hierarchy.
        writer.WriteProperty("callstackThreads", (w) => this.callStack.WriteJson(w));
        writer.WriteProperty("variablesState", (w) => this.variablesState.WriteJson(w));
        writer.WriteProperty("evalStack", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));
        writer.WriteProperty("outputStream", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream));
        writer.WriteProperty("currentChoices", (w) => {
            w.WriteArrayStart();
            for (let c of this._currentChoices)
                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);
            w.WriteArrayEnd();
        });
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException("divertedPointer");
            }
            writer.WriteProperty("currentDivertTarget", this.divertedPointer.path.componentsString);
        }
        writer.WriteProperty("visitCounts", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));
        writer.WriteProperty("turnIndices", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));
        writer.WriteIntProperty("turnIdx", this.currentTurnIndex);
        writer.WriteIntProperty("storySeed", this.storySeed);
        writer.WriteIntProperty("previousRandom", this.previousRandom);
        writer.WriteIntProperty("inkSaveVersion", this.kInkSaveStateVersion);
        writer.WriteIntProperty("inkFormatVersion", Story_1.Story.inkVersionCurrent);
        writer.WriteObjectEnd();
    }
    LoadJsonObj(value) {
        let jObject = value;
        let jSaveVersion = jObject["inkSaveVersion"];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" +
                jSaveVersion +
                "', but minimum is " +
                this.kMinCompatibleLoadVersion +
                "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject["callstackThreads"], this.story);
        this.variablesState.SetJsonToken(jObject["variablesState"]);
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);
        let currentDivertTargetPath = jObject["currentDivertTarget"];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);
        this.currentTurnIndex = parseInt(jObject["turnIdx"]);
        this.storySeed = parseInt(jObject["storySeed"]);
        this.previousRandom = parseInt(jObject["previousRandom"]);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject["choiceThreads"];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException("single.value");
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue("\n"));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue("\n"));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = str.length - tailLastNewlineIdx - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;
                let g = o instanceof Glue_1.Glue ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null &&
                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException("obj");
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand &&
                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException("rawList");
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException("StoryState.story.listDefinitions");
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException("StoryState def.result");
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException("obj");
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === "undefined") {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error("trying to pop too many objects");
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement
            .functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex) {
            this.currentTurnIndex++;
        }
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === "number" || typeof args[i] === "string")) {
                    throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type ==
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type !=
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException("Expected external function evaluation to be complete. Stack trace: " +
                this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement
            .evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StringBuilder.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/StringBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StringBuilder = void 0;
class StringBuilder {
    constructor(str) {
        str = typeof str !== "undefined" ? str.toString() : "";
        this.string = str;
    }
    get Length() {
        return this.string.length;
    }
    Append(str) {
        if (str !== null) {
            this.string += str;
        }
    }
    AppendLine(str) {
        if (typeof str !== "undefined")
            this.Append(str);
        this.string += "\n";
    }
    AppendFormat(format, ...args) {
        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format
        this.string += format.replace(/{(\d+)}/g, (match, num) => typeof args[num] != "undefined" ? args[num] : match);
    }
    toString() {
        return this.string;
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Tag.js":
/*!******************************************!*\
  !*** ./node_modules/inkjs/engine/Tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Tag extends Object_1.InkObject {
    constructor(tagText) {
        super();
        this.text = tagText.toString() || "";
    }
    toString() {
        return "# " + this.text;
    }
}
exports.Tag = Tag;
//# sourceMappingURL=Tag.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TryGetResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/TryGetResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseFloat = exports.tryParseInt = exports.tryGetValueFromMap = void 0;
function tryGetValueFromMap(map, key, 
/* out */ value) {
    if (map === null) {
        return { result: value, exists: false };
    }
    let val = map.get(key);
    if (typeof val === "undefined") {
        return { result: value, exists: false };
    }
    else {
        return { result: val, exists: true };
    }
}
exports.tryGetValueFromMap = tryGetValueFromMap;
function tryParseInt(value, 
/* out */ defaultValue = 0) {
    let val = parseInt(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseInt = tryParseInt;
function tryParseFloat(value, 
/* out */ defaultValue = 0) {
    let val = parseFloat(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseFloat = tryParseFloat;
//# sourceMappingURL=TryGetResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TypeAssertion.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/TypeAssertion.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isEquatable = exports.nullIfUndefined = exports.asINamedContentOrNull = exports.asNumberOrThrows = exports.asOrThrows = exports.asOrNull = void 0;
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === "number") {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === "undefined") {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function isEquatable(type) {
    return typeof type === "object" && typeof type.Equals === "function";
}
exports.isEquatable = isEquatable;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Value.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Value.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = exports.ListValue = exports.VariablePointerValue = exports.DivertTargetValue = exports.StringValue = exports.FloatValue = exports.IntValue = exports.Value = exports.AbstractValue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class AbstractValue extends Object_1.InkObject {
    static Create(val, preferredNumberType) {
        // This code doesn't exist in upstream and is simply here to enforce
        // the creation of the proper number value.
        // If `preferredNumberType` is not provided or if value doesn't match
        // `preferredNumberType`, this conditional does nothing.
        if (preferredNumberType) {
            if (preferredNumberType === ValueType.Int &&
                Number.isInteger(Number(val))) {
                return new IntValue(Number(val));
            }
            else if (preferredNumberType === ValueType.Float &&
                !isNaN(val)) {
                return new FloatValue(Number(val));
            }
        }
        // Implicitly convert bools into ints
        if (typeof val === "boolean") {
            let b = !!val;
            val = b ? 1 : 0;
        }
        // https://github.com/y-lohse/inkjs/issues/425
        // Changed condition sequence, because Number('') is
        // parsed to 0, which made setting string to empty
        // impossible
        if (typeof val === "string") {
            return new StringValue(String(val));
        }
        else if (Number.isInteger(Number(val))) {
            return new IntValue(Number(val));
        }
        else if (!isNaN(val)) {
            return new FloatValue(Number(val));
        }
        else if (val instanceof Path_1.Path) {
            return new DivertTargetValue(TypeAssertion_1.asOrThrows(val, Path_1.Path));
        }
        else if (val instanceof InkList_1.InkList) {
            return new ListValue(TypeAssertion_1.asOrThrows(val, InkList_1.InkList));
        }
        return null;
    }
    Copy() {
        return TypeAssertion_1.asOrThrows(AbstractValue.Create(this), Object_1.InkObject);
    }
    BadCastException(targetType) {
        return new StoryException_1.StoryException("Can't cast " +
            this.valueObject +
            " from " +
            this.valueType +
            " to " +
            targetType);
    }
}
exports.AbstractValue = AbstractValue;
class Value extends AbstractValue {
    constructor(val) {
        super();
        this.value = val;
    }
    get valueObject() {
        return this.value;
    }
    toString() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.toString();
    }
}
exports.Value = Value;
class IntValue extends Value {
    constructor(val) {
        super(val || 0);
    }
    get isTruthy() {
        return this.value != 0;
    }
    get valueType() {
        return ValueType.Int;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Float) {
            return new FloatValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.IntValue = IntValue;
class FloatValue extends Value {
    constructor(val) {
        super(val || 0.0);
    }
    get isTruthy() {
        return this.value != 0.0;
    }
    get valueType() {
        return ValueType.Float;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            return new IntValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.FloatValue = FloatValue;
class StringValue extends Value {
    constructor(val) {
        super(val || "");
        this._isNewline = this.value == "\n";
        this._isInlineWhitespace = true;
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (this.value.length > 0) {
            this.value.split("").every((c) => {
                if (c != " " && c != "\t") {
                    this._isInlineWhitespace = false;
                    return false;
                }
                return true;
            });
        }
    }
    get valueType() {
        return ValueType.String;
    }
    get isTruthy() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.length > 0;
    }
    get isNewline() {
        return this._isNewline;
    }
    get isInlineWhitespace() {
        return this._isInlineWhitespace;
    }
    get isNonWhitespace() {
        return !this.isNewline && !this.isInlineWhitespace;
    }
    Cast(newType) {
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            let parsedInt = TryGetResult_1.tryParseInt(this.value);
            if (parsedInt.exists) {
                return new IntValue(parsedInt.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        if (newType == ValueType.Float) {
            let parsedFloat = TryGetResult_1.tryParseFloat(this.value);
            if (parsedFloat.exists) {
                return new FloatValue(parsedFloat.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        throw this.BadCastException(newType);
    }
}
exports.StringValue = StringValue;
class DivertTargetValue extends Value {
    constructor(targetPath) {
        super(targetPath);
    }
    get valueType() {
        return ValueType.DivertTarget;
    }
    get targetPath() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set targetPath(value) {
        this.value = value;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a divert target");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "DivertTargetValue(" + this.targetPath + ")";
    }
}
exports.DivertTargetValue = DivertTargetValue;
class VariablePointerValue extends Value {
    constructor(variableName, contextIndex = -1) {
        super(variableName);
        this._contextIndex = contextIndex;
    }
    get contextIndex() {
        return this._contextIndex;
    }
    set contextIndex(value) {
        this._contextIndex = value;
    }
    get variableName() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set variableName(value) {
        this.value = value;
    }
    get valueType() {
        return ValueType.VariablePointer;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a variable pointer");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "VariablePointerValue(" + this.variableName + ")";
    }
    Copy() {
        return new VariablePointerValue(this.variableName, this.contextIndex);
    }
}
exports.VariablePointerValue = VariablePointerValue;
class ListValue extends Value {
    get isTruthy() {
        if (this.value === null) {
            return NullException_1.throwNullException("this.value");
        }
        return this.value.Count > 0;
    }
    get valueType() {
        return ValueType.List;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == ValueType.Int) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new IntValue(0);
            else
                return new IntValue(max.Value);
        }
        else if (newType == ValueType.Float) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new FloatValue(0.0);
            else
                return new FloatValue(max.Value);
        }
        else if (newType == ValueType.String) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new StringValue("");
            else {
                return new StringValue(max.Key.toString());
            }
        }
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    constructor(listOrSingleItem, singleValue) {
        super(null);
        if (!listOrSingleItem && !singleValue) {
            this.value = new InkList_1.InkList();
        }
        else if (listOrSingleItem instanceof InkList_1.InkList) {
            this.value = new InkList_1.InkList(listOrSingleItem);
        }
        else if (listOrSingleItem instanceof InkList_1.InkListItem &&
            typeof singleValue === "number") {
            this.value = new InkList_1.InkList({
                Key: listOrSingleItem,
                Value: singleValue,
            });
        }
    }
    static RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrNull(oldValue, ListValue);
        let newList = TypeAssertion_1.asOrNull(newValue, ListValue);
        if (newList && newList.value === null)
            return NullException_1.throwNullException("newList.value");
        if (oldList && oldList.value === null)
            return NullException_1.throwNullException("oldList.value");
        // When assigning the empty list, try to retain any initial origin names
        if (oldList && newList && newList.value.Count == 0)
            newList.value.SetInitialOriginNames(oldList.value.originNames);
    }
}
exports.ListValue = ListValue;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 0] = "Int";
    ValueType[ValueType["Float"] = 1] = "Float";
    ValueType[ValueType["List"] = 2] = "List";
    ValueType[ValueType["String"] = 3] = "String";
    ValueType[ValueType["DivertTarget"] = 4] = "DivertTarget";
    ValueType[ValueType["VariablePointer"] = 5] = "VariablePointer";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=Value.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableAssignment.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableAssignment.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableAssignment = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class VariableAssignment extends Object_1.InkObject {
    constructor(variableName, isNewDeclaration) {
        super();
        this.variableName = variableName || null;
        this.isNewDeclaration = !!isNewDeclaration;
        this.isGlobal = false;
    }
    toString() {
        return "VarAssign to " + this.variableName;
    }
}
exports.VariableAssignment = VariableAssignment;
//# sourceMappingURL=VariableAssignment.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableReference.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableReference.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReference = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class VariableReference extends Object_1.InkObject {
    constructor(name = null) {
        super();
        this.pathForCount = null;
        this.name = name;
    }
    get containerForCount() {
        if (this.pathForCount === null)
            return null;
        return this.ResolvePath(this.pathForCount).container;
    }
    get pathStringForCount() {
        if (this.pathForCount === null)
            return null;
        return this.CompactPathString(this.pathForCount);
    }
    set pathStringForCount(value) {
        if (value === null)
            this.pathForCount = null;
        else
            this.pathForCount = new Path_1.Path(value);
    }
    toString() {
        if (this.name != null) {
            return "var(" + this.name + ")";
        }
        else {
            let pathStr = this.pathStringForCount;
            return "read_count(" + pathStr + ")";
        }
    }
}
exports.VariableReference = VariableReference;
//# sourceMappingURL=VariableReference.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariablesState.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/VariablesState.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesState = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class VariablesState {
    constructor(callStack, listDefsOrigin) {
        // The way variableChangedEvent is a bit different than the reference implementation.
        // Originally it uses the C# += operator to add delegates, but in js we need to maintain
        // an actual collection of delegates (ie. callbacks) to register a new one, there is a
        // special ObserveVariableChange method below.
        this.variableChangedEventCallbacks = [];
        this.patch = null;
        this._batchObservingVariableChanges = false;
        this._defaultGlobalVariables = new Map();
        this._changedVariablesForBatchObs = new Set();
        this._globalVariables = new Map();
        this._callStack = callStack;
        this._listDefsOrigin = listDefsOrigin;
        // if es6 proxies are available, use them.
        try {
            // the proxy is used to allow direct manipulation of global variables.
            // It first tries to access the objects own property, and if none is
            // found it delegates the call to the $ method, defined below
            let p = new Proxy(this, {
                get(target, name) {
                    return name in target ? target[name] : target.$(name);
                },
                set(target, name, value) {
                    if (name in target)
                        target[name] = value;
                    else
                        target.$(name, value);
                    return true; // returning a falsy value make the trap fail
                },
            });
            return p;
        }
        catch (e) {
            // thr proxy object is not available in this context. we should warn the
            // dev but writting to the console feels a bit intrusive.
            // console.log("ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.");
        }
    }
    variableChangedEvent(variableName, newValue) {
        for (let callback of this.variableChangedEventCallbacks) {
            callback(variableName, newValue);
        }
    }
    get batchObservingVariableChanges() {
        return this._batchObservingVariableChanges;
    }
    set batchObservingVariableChanges(value) {
        this._batchObservingVariableChanges = value;
        if (value) {
            this._changedVariablesForBatchObs = new Set();
        }
        else {
            if (this._changedVariablesForBatchObs != null) {
                for (let variableName of this._changedVariablesForBatchObs) {
                    let currentValue = this._globalVariables.get(variableName);
                    if (!currentValue) {
                        NullException_1.throwNullException("currentValue");
                    }
                    else {
                        this.variableChangedEvent(variableName, currentValue);
                    }
                }
                this._changedVariablesForBatchObs = null;
            }
        }
    }
    get callStack() {
        return this._callStack;
    }
    set callStack(callStack) {
        this._callStack = callStack;
    }
    // the original code uses a magic getter and setter for global variables,
    // allowing things like variableState['varname]. This is not quite possible
    // in js without a Proxy, so it is replaced with this $ function.
    $(variableName, value) {
        if (typeof value === "undefined") {
            let varContents = null;
            if (this.patch !== null) {
                varContents = this.patch.TryGetGlobal(variableName, null);
                if (varContents.exists)
                    return varContents.result.valueObject;
            }
            varContents = this._globalVariables.get(variableName);
            if (typeof varContents === "undefined") {
                varContents = this._defaultGlobalVariables.get(variableName);
            }
            if (typeof varContents !== "undefined")
                return varContents.valueObject;
            else
                return null;
        }
        else {
            if (typeof this._defaultGlobalVariables.get(variableName) === "undefined")
                throw new StoryException_1.StoryException("Cannot assign to a variable (" +
                    variableName +
                    ") that hasn't been declared in the story");
            let val = Value_1.Value.Create(value);
            if (val == null) {
                if (value == null) {
                    throw new StoryException_1.StoryException("Cannot pass null to VariableState");
                }
                else {
                    throw new StoryException_1.StoryException("Invalid value passed to VariableState: " + value.toString());
                }
            }
            this.SetGlobal(variableName, val);
        }
    }
    ApplyPatch() {
        if (this.patch === null) {
            return NullException_1.throwNullException("this.patch");
        }
        for (let [namedVarKey, namedVarValue] of this.patch.globals) {
            this._globalVariables.set(namedVarKey, namedVarValue);
        }
        if (this._changedVariablesForBatchObs !== null) {
            for (let name of this.patch.changedVariables) {
                this._changedVariablesForBatchObs.add(name);
            }
        }
        this.patch = null;
    }
    SetJsonToken(jToken) {
        this._globalVariables.clear();
        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {
            let loadedToken = jToken[varValKey];
            if (typeof loadedToken !== "undefined") {
                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);
                if (tokenInkObject === null) {
                    return NullException_1.throwNullException("tokenInkObject");
                }
                this._globalVariables.set(varValKey, tokenInkObject);
            }
            else {
                this._globalVariables.set(varValKey, varValValue);
            }
        }
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        for (let [keyValKey, keyValValue] of this._globalVariables) {
            let name = keyValKey;
            let val = keyValValue;
            if (VariablesState.dontSaveDefaultValues) {
                if (this._defaultGlobalVariables.has(name)) {
                    let defaultVal = this._defaultGlobalVariables.get(name);
                    if (this.RuntimeObjectsEqual(val, defaultVal))
                        continue;
                }
            }
            writer.WritePropertyStart(name);
            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    RuntimeObjectsEqual(obj1, obj2) {
        if (obj1 === null) {
            return NullException_1.throwNullException("obj1");
        }
        if (obj2 === null) {
            return NullException_1.throwNullException("obj2");
        }
        if (obj1.constructor !== obj2.constructor)
            return false;
        let intVal = TypeAssertion_1.asOrNull(obj1, Value_1.IntValue);
        if (intVal !== null) {
            return intVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.IntValue).value;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj1, Value_1.FloatValue);
        if (floatVal !== null) {
            return floatVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.FloatValue).value;
        }
        let val1 = TypeAssertion_1.asOrNull(obj1, Value_1.Value);
        let val2 = TypeAssertion_1.asOrNull(obj2, Value_1.Value);
        if (val1 !== null && val2 !== null) {
            if (TypeAssertion_1.isEquatable(val1.valueObject) && TypeAssertion_1.isEquatable(val2.valueObject)) {
                return val1.valueObject.Equals(val2.valueObject);
            }
            else {
                return val1.valueObject === val2.valueObject;
            }
        }
        throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: " +
            obj1.constructor.name);
    }
    GetVariableWithName(name, contextIndex = -1) {
        let varValue = this.GetRawVariableWithName(name, contextIndex);
        // var varPointer = varValue as VariablePointerValue;
        let varPointer = TypeAssertion_1.asOrNull(varValue, Value_1.VariablePointerValue);
        if (varPointer !== null) {
            varValue = this.ValueAtVariablePointer(varPointer);
        }
        return varValue;
    }
    TryGetDefaultVariableValue(name) {
        let val = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
        return val.exists ? val.result : null;
    }
    GlobalVariableExistsWithName(name) {
        return (this._globalVariables.has(name) ||
            (this._defaultGlobalVariables !== null &&
                this._defaultGlobalVariables.has(name)));
    }
    GetRawVariableWithName(name, contextIndex) {
        let varValue = null;
        if (contextIndex == 0 || contextIndex == -1) {
            let variableValue = null;
            if (this.patch !== null) {
                variableValue = this.patch.TryGetGlobal(name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            // this is a conditional assignment
            variableValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, name, null);
            if (variableValue.exists)
                return variableValue.result;
            if (this._defaultGlobalVariables !== null) {
                variableValue = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            if (this._listDefsOrigin === null)
                return NullException_1.throwNullException("VariablesState._listDefsOrigin");
            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);
            if (listItemValue)
                return listItemValue;
        }
        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);
        return varValue;
    }
    ValueAtVariablePointer(pointer) {
        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);
    }
    Assign(varAss, value) {
        let name = varAss.variableName;
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let contextIndex = -1;
        let setGlobal = false;
        if (varAss.isNewDeclaration) {
            setGlobal = varAss.isGlobal;
        }
        else {
            setGlobal = this.GlobalVariableExistsWithName(name);
        }
        if (varAss.isNewDeclaration) {
            // var varPointer = value as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(value, Value_1.VariablePointerValue);
            if (varPointer !== null) {
                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);
                value = fullyResolvedVariablePointer;
            }
        }
        else {
            let existingPointer = null;
            do {
                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;
                existingPointer = TypeAssertion_1.asOrNull(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);
                if (existingPointer != null) {
                    name = existingPointer.variableName;
                    contextIndex = existingPointer.contextIndex;
                    setGlobal = contextIndex == 0;
                }
            } while (existingPointer != null);
        }
        if (setGlobal) {
            this.SetGlobal(name, value);
        }
        else {
            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);
        }
    }
    SnapshotDefaultGlobals() {
        this._defaultGlobalVariables = new Map(this._globalVariables);
    }
    RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrThrows(oldValue, Value_1.ListValue);
        let newList = TypeAssertion_1.asOrThrows(newValue, Value_1.ListValue);
        if (oldList.value && newList.value && newList.value.Count == 0) {
            newList.value.SetInitialOriginNames(oldList.value.originNames);
        }
    }
    SetGlobal(variableName, value) {
        let oldValue = null;
        if (this.patch === null) {
            oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
        }
        if (this.patch !== null) {
            oldValue = this.patch.TryGetGlobal(variableName, null);
            if (!oldValue.exists) {
                oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
            }
        }
        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        if (variableName === null) {
            return NullException_1.throwNullException("variableName");
        }
        if (this.patch !== null) {
            this.patch.SetGlobal(variableName, value);
        }
        else {
            this._globalVariables.set(variableName, value);
        }
        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)
        if (this.variableChangedEvent !== null &&
            oldValue !== null &&
            value !== oldValue.result) {
            if (this.batchObservingVariableChanges) {
                if (this._changedVariablesForBatchObs === null) {
                    return NullException_1.throwNullException("this._changedVariablesForBatchObs");
                }
                if (this.patch !== null) {
                    this.patch.AddChangedVariable(variableName);
                }
                else if (this._changedVariablesForBatchObs !== null) {
                    this._changedVariablesForBatchObs.add(variableName);
                }
            }
            else {
                this.variableChangedEvent(variableName, value);
            }
        }
    }
    ResolveVariablePointer(varPointer) {
        let contextIndex = varPointer.contextIndex;
        if (contextIndex == -1)
            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);
        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);
        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;
        let doubleRedirectionPointer = TypeAssertion_1.asOrNull(valueOfVariablePointedTo, Value_1.VariablePointerValue);
        if (doubleRedirectionPointer != null) {
            return doubleRedirectionPointer;
        }
        else {
            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);
        }
    }
    GetContextIndexOfVariableNamed(varName) {
        if (this.GlobalVariableExistsWithName(varName))
            return 0;
        return this._callStack.currentElementIndex;
    }
    /**
     * This function is specific to the js version of ink. It allows to register a
     * callback that will be called when a variable changes. The original code uses
     * `state.variableChangedEvent += callback` instead.
     *
     * @param {function} callback
     */
    ObserveVariableChange(callback) {
        this.variableChangedEventCallbacks.push(callback);
    }
}
exports.VariablesState = VariablesState;
VariablesState.dontSaveDefaultValues = true;
//# sourceMappingURL=VariablesState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Void.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Void.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Void extends Object_1.InkObject {
}
exports.Void = Void;
//# sourceMappingURL=Void.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/GameMain.ts":
/*!*************************!*\
  !*** ./src/GameMain.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UnitTest_1 = __webpack_require__(/*! ./unittest/UnitTest */ "./src/unittest/UnitTest.ts");
const GameObjectPool_1 = __webpack_require__(/*! ./framework/common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
const UIManager_1 = __webpack_require__(/*! ./framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const ResManager_1 = __webpack_require__(/*! ./framework/common/ResManager */ "./src/framework/common/ResManager.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
const SceneDef_1 = __webpack_require__(/*! ./framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
const SceneManager_1 = __webpack_require__(/*! ./framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
const StoryManager_1 = __webpack_require__(/*! ./framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
class GameMain {
    constructor() {
        csharp_1.JsManager.Instance.JsOnApplicationQuit = () => this.onApplicationQuit();
        csharp_1.JsManager.Instance.JsOnDispose = () => this.onDispose();
    }
    async start() {
        try {
            console.log("Game start in JS....");
            //
            GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool);
            UIManager_1.UIManager.Instance(UIManager_1.UIManager);
            ResManager_1.ResManager.Instance(ResManager_1.ResManager);
            StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).initialize();
            //excel
            //ExcelManager.Instance(ExcelManager);
            //do Unit Test
            UnitTest_1.UnitTest.doTest();
            //
            SceneManager_1.SceneManager.Instance(SceneManager_1.SceneManager).loadScene(SceneDef_1.SceneDef.LoginScene, () => { });
            //JSC#
            csharp_1.GameLaunch.Instance.JsLuanchFinish();
        }
        catch (ex) {
            console.error(ex);
        }
    }
    onApplicationQuit() {
        GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).cleanup(true);
        console.log("Game onApplicationQuit in JS....");
    }
    onDispose() {
        console.log("Game onDispose in JS....");
    }
}
new GameMain().start();


/***/ }),

/***/ "./src/data/excel/SkillConfig.ts":
/*!***************************************!*\
  !*** ./src/data/excel/SkillConfig.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SkillConfigTB = exports.SkillConfigTR = void 0;
const Singleton_1 = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class SkillConfigTR {
    constructor(_id, _Name, _Description, _CoolTime, _CostSP, _AttackDistance, _AttackAngle, _AttackTargetTags, _ImpactType, _NextBattlerId, _AtkRatio, _DurationTime, _AtkInterval, _SkillPrefab, _AnimationName, _HitFxPrefab, _Level, _AttackType, _SelectorType) {
        this._id = _id;
        this._Name = _Name;
        this._Description = _Description;
        this._CoolTime = _CoolTime;
        this._CostSP = _CostSP;
        this._AttackDistance = _AttackDistance;
        this._AttackAngle = _AttackAngle;
        this._AttackTargetTags = _AttackTargetTags;
        this._ImpactType = _ImpactType;
        this._NextBattlerId = _NextBattlerId;
        this._AtkRatio = _AtkRatio;
        this._DurationTime = _DurationTime;
        this._AtkInterval = _AtkInterval;
        this._SkillPrefab = _SkillPrefab;
        this._AnimationName = _AnimationName;
        this._HitFxPrefab = _HitFxPrefab;
        this._Level = _Level;
        this._AttackType = _AttackType;
        this._SelectorType = _SelectorType;
    }
}
exports.SkillConfigTR = SkillConfigTR;
class SkillConfigTB extends Singleton_1.Singleton {
    constructor() {
        super();
        this.trs = new Map();
        this.trs.set(1001, new SkillConfigTR(1001, "", "", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill1", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1002, new SkillConfigTR(1002, "", "", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill2", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1003, new SkillConfigTR(1003, "", "", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill3", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1004, new SkillConfigTR(1004, "", "", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill4", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
    }
}
exports.SkillConfigTB = SkillConfigTB;


/***/ }),

/***/ "./src/data/pb/Opcode.ts":
/*!*******************************!*\
  !*** ./src/data/pb/Opcode.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Opcode = exports.DecodeMsg = void 0;
const pb_1 = __webpack_require__(/*! ./gen/pb */ "./src/data/pb/gen/pb.js");
class DecodeMsg {
}
exports.DecodeMsg = DecodeMsg;
class Opcode {
    static decode(opcode, msg) {
        let msgObj = this.map[opcode](msg);
        let decodeMsg = new DecodeMsg();
        decodeMsg.rpcId = msgObj.RpcId;
        decodeMsg.msgObj = msgObj;
        return decodeMsg;
    }
}
exports.Opcode = Opcode;
Opcode.MSG_C2R_Login = 1000;
Opcode.MSG_R2C_Login = 1001;
Opcode.MSG_C2G_LoginGate = 1002;
Opcode.MSG_G2C_LoginGate = 1003;
Opcode.MSG_C2GS_Test = 2001;
Opcode.MSG_GS2C_Test = 2002;
Opcode.map = {
    1000: pb_1.nice_ts.C2R_Login.decode,
    1001: pb_1.nice_ts.R2C_Login.decode,
    1002: pb_1.nice_ts.C2G_LoginGate.decode,
    1003: pb_1.nice_ts.G2C_LoginGate.decode,
    2001: pb_1.nice_ts.C2GS_Test.decode,
    2002: pb_1.nice_ts.GS2C_Test.decode,
};


/***/ }),

/***/ "./src/data/pb/gen/pb.js":
/*!*******************************!*\
  !*** ./src/data/pb/gen/pb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
$protobuf.util.Long = Long;
$protobuf.configure();


// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.nice_ts = (function() {

    /**
     * Namespace nice_ts.
     * @exports nice_ts
     * @namespace
     */
    var nice_ts = {};

    nice_ts.C2R_Login = (function() {

        /**
         * Properties of a C2R_Login.
         * @memberof nice_ts
         * @interface IC2R_Login
         * @property {string|null} [Account] C2R_Login Account
         * @property {string|null} [Password] C2R_Login Password
         */

        /**
         * Constructs a new C2R_Login.
         * @memberof nice_ts
         * @classdesc Represents a C2R_Login.
         * @implements IC2R_Login
         * @constructor
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         */
        function C2R_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2R_Login Account.
         * @member {string} Account
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Account = "";

        /**
         * C2R_Login Password.
         * @member {string} Password
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Password = "";

        /**
         * Creates a new C2R_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         * @returns {nice_ts.C2R_Login} C2R_Login instance
         */
        C2R_Login.create = function create(properties) {
            return new C2R_Login(properties);
        };

        /**
         * Encodes the specified C2R_Login message. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && Object.hasOwnProperty.call(message, "Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && Object.hasOwnProperty.call(message, "Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified C2R_Login message, length delimited. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2R_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2R_Login message.
         * @function verify
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2R_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        /**
         * Creates a C2R_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2R_Login} C2R_Login
         */
        C2R_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2R_Login)
                return object;
            var message = new $root.nice_ts.C2R_Login();
            if (object.Account != null)
                message.Account = String(object.Account);
            if (object.Password != null)
                message.Password = String(object.Password);
            return message;
        };

        /**
         * Creates a plain object from a C2R_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.C2R_Login} message C2R_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2R_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Account = "";
                object.Password = "";
            }
            if (message.Account != null && message.hasOwnProperty("Account"))
                object.Account = message.Account;
            if (message.Password != null && message.hasOwnProperty("Password"))
                object.Password = message.Password;
            return object;
        };

        /**
         * Converts this C2R_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.C2R_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2R_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2R_Login;
    })();

    nice_ts.R2C_Login = (function() {

        /**
         * Properties of a R2C_Login.
         * @memberof nice_ts
         * @interface IR2C_Login
         * @property {number|null} [Error] R2C_Login Error
         * @property {string|null} [Message] R2C_Login Message
         * @property {string|null} [Address] R2C_Login Address
         * @property {number|Long|null} [Key] R2C_Login Key
         * @property {number|Long|null} [GateId] R2C_Login GateId
         */

        /**
         * Constructs a new R2C_Login.
         * @memberof nice_ts
         * @classdesc Represents a R2C_Login.
         * @implements IR2C_Login
         * @constructor
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         */
        function R2C_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * R2C_Login Error.
         * @member {number} Error
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Error = 0;

        /**
         * R2C_Login Message.
         * @member {string} Message
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Message = "";

        /**
         * R2C_Login Address.
         * @member {string} Address
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Address = "";

        /**
         * R2C_Login Key.
         * @member {number|Long} Key
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * R2C_Login GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new R2C_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         * @returns {nice_ts.R2C_Login} R2C_Login instance
         */
        R2C_Login.create = function create(properties) {
            return new R2C_Login(properties);
        };

        /**
         * Encodes the specified R2C_Login message. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Address != null && Object.hasOwnProperty.call(message, "Address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Address);
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GateId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified R2C_Login message, length delimited. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.R2C_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.Address = reader.string();
                    break;
                case 2:
                    message.Key = reader.int64();
                    break;
                case 3:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a R2C_Login message.
         * @function verify
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        R2C_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.Address != null && message.hasOwnProperty("Address"))
                if (!$util.isString(message.Address))
                    return "Address: string expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a R2C_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.R2C_Login} R2C_Login
         */
        R2C_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.R2C_Login)
                return object;
            var message = new $root.nice_ts.R2C_Login();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.Address != null)
                message.Address = String(object.Address);
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a R2C_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.R2C_Login} message R2C_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        R2C_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.Address != null && message.hasOwnProperty("Address"))
                object.Address = message.Address;
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this R2C_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.R2C_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        R2C_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return R2C_Login;
    })();

    nice_ts.C2G_LoginGate = (function() {

        /**
         * Properties of a C2G_LoginGate.
         * @memberof nice_ts
         * @interface IC2G_LoginGate
         * @property {number|Long|null} [Key] C2G_LoginGate Key
         * @property {number|Long|null} [GateId] C2G_LoginGate GateId
         */

        /**
         * Constructs a new C2G_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a C2G_LoginGate.
         * @implements IC2G_LoginGate
         * @constructor
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         */
        function C2G_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2G_LoginGate Key.
         * @member {number|Long} Key
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2G_LoginGate GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2G_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate instance
         */
        C2G_LoginGate.create = function create(properties) {
            return new C2G_LoginGate(properties);
        };

        /**
         * Encodes the specified C2G_LoginGate message. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.GateId);
            return writer;
        };

        /**
         * Encodes the specified C2G_LoginGate message, length delimited. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2G_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Key = reader.int64();
                    break;
                case 2:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2G_LoginGate message.
         * @function verify
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2G_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2G_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         */
        C2G_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2G_LoginGate)
                return object;
            var message = new $root.nice_ts.C2G_LoginGate();
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2G_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.C2G_LoginGate} message C2G_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2G_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
            }
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            return object;
        };

        /**
         * Converts this C2G_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2G_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2G_LoginGate;
    })();

    nice_ts.G2C_LoginGate = (function() {

        /**
         * Properties of a G2C_LoginGate.
         * @memberof nice_ts
         * @interface IG2C_LoginGate
         * @property {number|null} [Error] G2C_LoginGate Error
         * @property {string|null} [Message] G2C_LoginGate Message
         * @property {number|Long|null} [PlayerId] G2C_LoginGate PlayerId
         */

        /**
         * Constructs a new G2C_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a G2C_LoginGate.
         * @implements IG2C_LoginGate
         * @constructor
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         */
        function G2C_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2C_LoginGate Error.
         * @member {number} Error
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Error = 0;

        /**
         * G2C_LoginGate Message.
         * @member {string} Message
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Message = "";

        /**
         * G2C_LoginGate PlayerId.
         * @member {number|Long} PlayerId
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.PlayerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new G2C_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate instance
         */
        G2C_LoginGate.create = function create(properties) {
            return new G2C_LoginGate(properties);
        };

        /**
         * Encodes the specified G2C_LoginGate message. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerId != null && Object.hasOwnProperty.call(message, "PlayerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PlayerId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified G2C_LoginGate message, length delimited. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.G2C_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.PlayerId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2C_LoginGate message.
         * @function verify
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2C_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (!$util.isInteger(message.PlayerId) && !(message.PlayerId && $util.isInteger(message.PlayerId.low) && $util.isInteger(message.PlayerId.high)))
                    return "PlayerId: integer|Long expected";
            return null;
        };

        /**
         * Creates a G2C_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         */
        G2C_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.G2C_LoginGate)
                return object;
            var message = new $root.nice_ts.G2C_LoginGate();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.PlayerId != null)
                if ($util.Long)
                    (message.PlayerId = $util.Long.fromValue(object.PlayerId)).unsigned = false;
                else if (typeof object.PlayerId === "string")
                    message.PlayerId = parseInt(object.PlayerId, 10);
                else if (typeof object.PlayerId === "number")
                    message.PlayerId = object.PlayerId;
                else if (typeof object.PlayerId === "object")
                    message.PlayerId = new $util.LongBits(object.PlayerId.low >>> 0, object.PlayerId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a G2C_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.G2C_LoginGate} message G2C_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        G2C_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.PlayerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PlayerId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (typeof message.PlayerId === "number")
                    object.PlayerId = options.longs === String ? String(message.PlayerId) : message.PlayerId;
                else
                    object.PlayerId = options.longs === String ? $util.Long.prototype.toString.call(message.PlayerId) : options.longs === Number ? new $util.LongBits(message.PlayerId.low >>> 0, message.PlayerId.high >>> 0).toNumber() : message.PlayerId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this G2C_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        G2C_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return G2C_LoginGate;
    })();

    nice_ts.C2GS_Test = (function() {

        /**
         * Properties of a C2GS_Test.
         * @memberof nice_ts
         * @interface IC2GS_Test
         * @property {number|null} [testID] C2GS_Test testID
         * @property {string|null} [testName] C2GS_Test testName
         */

        /**
         * Constructs a new C2GS_Test.
         * @memberof nice_ts
         * @classdesc Represents a C2GS_Test.
         * @implements IC2GS_Test
         * @constructor
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         */
        function C2GS_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2GS_Test testID.
         * @member {number} testID
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testID = 0;

        /**
         * C2GS_Test testName.
         * @member {string} testName
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testName = "";

        /**
         * Creates a new C2GS_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         * @returns {nice_ts.C2GS_Test} C2GS_Test instance
         */
        C2GS_Test.create = function create(properties) {
            return new C2GS_Test(properties);
        };

        /**
         * Encodes the specified C2GS_Test message. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testID != null && Object.hasOwnProperty.call(message, "testID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.testID);
            if (message.testName != null && Object.hasOwnProperty.call(message, "testName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testName);
            return writer;
        };

        /**
         * Encodes the specified C2GS_Test message, length delimited. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2GS_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.testID = reader.int32();
                    break;
                case 2:
                    message.testName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2GS_Test message.
         * @function verify
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2GS_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.testID != null && message.hasOwnProperty("testID"))
                if (!$util.isInteger(message.testID))
                    return "testID: integer expected";
            if (message.testName != null && message.hasOwnProperty("testName"))
                if (!$util.isString(message.testName))
                    return "testName: string expected";
            return null;
        };

        /**
         * Creates a C2GS_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         */
        C2GS_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2GS_Test)
                return object;
            var message = new $root.nice_ts.C2GS_Test();
            if (object.testID != null)
                message.testID = object.testID | 0;
            if (object.testName != null)
                message.testName = String(object.testName);
            return message;
        };

        /**
         * Creates a plain object from a C2GS_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.C2GS_Test} message C2GS_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2GS_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testID = 0;
                object.testName = "";
            }
            if (message.testID != null && message.hasOwnProperty("testID"))
                object.testID = message.testID;
            if (message.testName != null && message.hasOwnProperty("testName"))
                object.testName = message.testName;
            return object;
        };

        /**
         * Converts this C2GS_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.C2GS_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2GS_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2GS_Test;
    })();

    nice_ts.GS2C_Test = (function() {

        /**
         * Properties of a GS2C_Test.
         * @memberof nice_ts
         * @interface IGS2C_Test
         * @property {number|null} [Error] GS2C_Test Error
         * @property {string|null} [Message] GS2C_Test Message
         * @property {string|null} [testResponse] GS2C_Test testResponse
         */

        /**
         * Constructs a new GS2C_Test.
         * @memberof nice_ts
         * @classdesc Represents a GS2C_Test.
         * @implements IGS2C_Test
         * @constructor
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         */
        function GS2C_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GS2C_Test Error.
         * @member {number} Error
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Error = 0;

        /**
         * GS2C_Test Message.
         * @member {string} Message
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Message = "";

        /**
         * GS2C_Test testResponse.
         * @member {string} testResponse
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.testResponse = "";

        /**
         * Creates a new GS2C_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         * @returns {nice_ts.GS2C_Test} GS2C_Test instance
         */
        GS2C_Test.create = function create(properties) {
            return new GS2C_Test(properties);
        };

        /**
         * Encodes the specified GS2C_Test message. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testResponse != null && Object.hasOwnProperty.call(message, "testResponse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.testResponse);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified GS2C_Test message, length delimited. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.GS2C_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.testResponse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GS2C_Test message.
         * @function verify
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GS2C_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                if (!$util.isString(message.testResponse))
                    return "testResponse: string expected";
            return null;
        };

        /**
         * Creates a GS2C_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         */
        GS2C_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.GS2C_Test)
                return object;
            var message = new $root.nice_ts.GS2C_Test();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.testResponse != null)
                message.testResponse = String(object.testResponse);
            return message;
        };

        /**
         * Creates a plain object from a GS2C_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.GS2C_Test} message GS2C_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GS2C_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testResponse = "";
                object.Error = 0;
                object.Message = "";
            }
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                object.testResponse = message.testResponse;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this GS2C_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.GS2C_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GS2C_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GS2C_Test;
    })();

    return nice_ts;
})();

module.exports = $root;


/***/ }),

/***/ "./src/data/ui/common.ts":
/*!*******************************!*\
  !*** ./src/data/ui/common.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonUI = void 0;
class commonUI {
}
exports.commonUI = commonUI;
commonUI.PackageName = "common";
commonUI.PackageBytes = "common_fui.bytes";
commonUI.UILoadingPage = "LoadingPage";
commonUI.UIUINoticeWin = "UINoticeWin";


/***/ }),

/***/ "./src/data/ui/home.ts":
/*!*****************************!*\
  !*** ./src/data/ui/home.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.homeUI = void 0;
class homeUI {
}
exports.homeUI = homeUI;
homeUI.PackageName = "home";
homeUI.PackageBytes = "home_fui.bytes";
homeUI.UIHomePage = "HomePage";
homeUI.UILevelPage = "LevelPage";
homeUI.UIShopPage = "ShopPage";


/***/ }),

/***/ "./src/data/ui/login.ts":
/*!******************************!*\
  !*** ./src/data/ui/login.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.loginUI = void 0;
class loginUI {
}
exports.loginUI = loginUI;
loginUI.PackageName = "login";
loginUI.PackageBytes = "login_fui.bytes";
loginUI.UILoginPage = "LoginPage";
loginUI.UISelServerWin = "SelServerWin";
loginUI.UIAreaItem = "AreaItem";


/***/ }),

/***/ "./src/data/ui/story.ts":
/*!******************************!*\
  !*** ./src/data/ui/story.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.storyUI = void 0;
class storyUI {
}
exports.storyUI = storyUI;
storyUI.PackageName = "story";
storyUI.PackageBytes = "story_fui.bytes";
storyUI.UIStoryWin = "StoryWin";


/***/ }),

/***/ "./src/framework/common/GameObjectPool.ts":
/*!************************************************!*\
  !*** ./src/framework/common/GameObjectPool.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameObjectPool = void 0;
const Singleton_1 = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
const ResManager_1 = __webpack_require__(/*! ./ResManager */ "./src/framework/common/ResManager.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
// -- GameObject
// -- 
// -- 1ResourcesManager
// -- 2GameObject(Asset)GameObjectInst
class GameObjectPool extends Singleton_1.Singleton {
    constructor() {
        super();
        this.__cacheTransRoot = null;
        this.__goPool = new Map();
        this.__instCache = new Map();
        let go = csharp_1.UnityEngine.GameObject.Find("GameObjectCacheRoot");
        if (go == undefined) {
            go = new csharp_1.UnityEngine.GameObject("GameObjectCacheRoot");
            csharp_1.UnityEngine.Object.DontDestroyOnLoad(go);
        }
        this.__cacheTransRoot = go.transform;
    }
    //-- 
    checkHasCached(path) {
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            return true;
        }
        let pooledGo = this.__goPool.get(path);
        return pooledGo != undefined;
    }
    //-- GameObject
    cacheAndInstGameObject(path, go, inst_count = 1) {
        this.__goPool.set(path, go);
        if (inst_count > 0) {
            let cachedInst = this.__instCache.get(path);
            for (let i = 0; i < inst_count; i++) {
                let inst = csharp_1.UnityEngine.GameObject.Instantiate(go);
                inst.transform.SetParent(this.__cacheTransRoot);
                inst.SetActive(false);
                cachedInst.push(inst);
            }
        }
    }
    //-- 
    tryGetFromCache(path) {
        if (!this.checkHasCached(path)) {
            return null;
        }
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            let inst = cachedInst.pop();
            return inst;
        }
        let pooledGo = this.__goPool.get(path);
        if (pooledGo != undefined) {
            let inst = csharp_1.UnityEngine.GameObject.Instantiate(pooledGo);
            return inst;
        }
        return null;
    }
    //
    async preLoadGameObjectAsync(path, inst_count, callback, ...params) {
        if (this.checkHasCached(path)) {
            if (callback != null) {
                callback(params);
            }
            return;
        }
        let go = await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadPrefab(path);
        if (go != undefined) {
            this.cacheAndInstGameObject(path, go, inst_count);
        }
        if (callback != null) {
            callback(params);
        }
    }
    //-- 
    async getGameObjectAsync(path, callback, ...params) {
        let inst = this.tryGetFromCache(path);
        if (inst == null) {
            await this.preLoadGameObjectAsync(path, 1, callback, params);
        }
        inst = this.tryGetFromCache(path);
        inst.SetActive(true);
    }
    //-- 
    recycleGameObject(path, inst) {
        inst.transform.SetParent(this.__cacheTransRoot);
        inst.SetActive(false);
        let cachedInst = this.__instCache.get(path) || new Array();
        cachedInst.push(inst);
        this.__instCache.set(path, cachedInst);
    }
    //-- 
    cleanup(includePooledGo = false) {
        this.__instCache.forEach((values, key) => {
            for (let inst of values) {
                if (inst != null) {
                    csharp_1.UnityEngine.GameObject.Destroy(inst);
                }
            }
        });
        this.__instCache.clear();
        if (includePooledGo) {
            this.__goPool.forEach((go, key) => {
                if (go != null) {
                    ResManager_1.ResManager.Instance(ResManager_1.ResManager).releaseAddressGO(go);
                }
            });
            this.__goPool.clear();
        }
    }
}
exports.GameObjectPool = GameObjectPool;


/***/ }),

/***/ "./src/framework/common/Messenger.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Messenger.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Messenger = exports.MesObj = void 0;
class MesObj {
}
exports.MesObj = MesObj;
class Messenger {
    constructor() {
        this.listenerMap = new Map();
    }
    addListener(e_type, e_obj, e_listner) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) == "undefined") {
            msgObj = new MesObj();
            msgObj.obj = e_obj;
            msgObj.listeners = new Array();
        }
        msgObj.listeners.push(e_listner);
        this.listenerMap.set(e_type, msgObj);
    }
    getListener(e_type) {
        return this.listenerMap.get(e_type);
    }
    broadcast(e_type, ...params) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let l of msgObj.listeners) {
                l.apply(msgObj.obj, params);
            }
        }
    }
    removeListenerByType(e_type) {
        this.listenerMap.delete(e_type);
    }
    removeListener(e_type, e_listener) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let i = 0; i < msgObj.listeners.length; i++) {
                if (msgObj.listeners[i] == e_listener) {
                    msgObj.listeners.splice(i, 1);
                }
            }
        }
    }
    clearup() {
        this.listenerMap.clear();
    }
}
exports.Messenger = Messenger;


/***/ }),

/***/ "./src/framework/common/NiceDecorator.ts":
/*!***********************************************!*\
  !*** ./src/framework/common/NiceDecorator.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.binder = void 0;
// FairyGUI  
function binder(name) {
    return function (target, key) {
        target["binders"] = target["binders"] || {};
        target["binders"][key] = name;
    };
}
exports.binder = binder;


/***/ }),

/***/ "./src/framework/common/ResManager.ts":
/*!********************************************!*\
  !*** ./src/framework/common/ResManager.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ResManager = void 0;
const Singleton_1 = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
const puerts_1 = __webpack_require__(/*! puerts */ "puerts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class ResManager extends Singleton_1.Singleton {
    constructor() {
        super();
    }
    async loadPrefab(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadPrefab(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load prefab :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextAsset(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadTextAsset(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load textasset :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextBytes(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadTextBytes(address);
            let bytes = await puerts_1.$promise(task);
            return bytes;
        }
        catch (ex) {
            console.error(`LoadTextBytes :${address} : ${ex}`);
        }
    }
    async loadSprite(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadSprite(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load sprite :${address} : ${ex}`);
            return null;
        }
    }
    async loadFairyGUIPackage(address, packageName, callback) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadFairyGUIPackage(address, packageName);
            await puerts_1.$promise(task);
            if (callback)
                callback();
        }
        catch (ex) {
            console.error(`Load fairyGUI :${address} : ${ex}`);
        }
    }
    releaseAddressGO(go) {
        csharp_1.NiceTS.ResourceManager.ReleaseAddressGO(go);
    }
    releaseFairyGUIPackage(packageName) {
        csharp_1.NiceTS.ResourceManager.ReleaseFGUIPackage(packageName);
    }
}
exports.ResManager = ResManager;


/***/ }),

/***/ "./src/framework/common/Singleton.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Singleton.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Singleton = void 0;
class Singleton {
    static Instance(c) {
        if (this.instance == null) {
            this.instance = new c();
        }
        return this.instance;
    }
}
exports.Singleton = Singleton;
Singleton.instance = null;


/***/ }),

/***/ "./src/framework/ink/InkStateInspector.ts":
/*!************************************************!*\
  !*** ./src/framework/ink/InkStateInspector.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkStateInspector = void 0;
class InkStateInspector {
    BindInkMethods(inkStory) {
        //3
        this.bindInkMethodOnce(inkStory, "GetCharacterName", this.getCharacterName);
        //3 
        this.bindInkMethodOnceGeneral(inkStory, "GetCharacterNameByMutiParams", this.getCharacterNameMutiParams);
    }
    getCharacterName() {
        return "Justin Test Puerts";
    }
    getCharacterNameMutiParams(p1, p2, p3) {
        return "Justin Muti Params";
    }
    bindInkMethodOnce(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunction(funcName, func);
        }
        catch (err) {
            console.warn(err);
        }
    }
    bindInkMethodOnceGeneral(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunctionGeneral(funcName, func);
        }
        catch (err) {
            console.warn(err);
        }
    }
    unbindInkMethod(inkStory, funcName) {
        try {
            inkStory.UnbindExternalFunction(funcName);
        }
        catch (err) {
            console.warn(err);
        }
    }
}
exports.InkStateInspector = InkStateInspector;


/***/ }),

/***/ "./src/framework/ink/InkWriter.ts":
/*!****************************************!*\
  !*** ./src/framework/ink/InkWriter.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkWriter = void 0;
const Story_1 = __webpack_require__(/*! inkjs/engine/Story */ "./node_modules/inkjs/engine/Story.js");
const InkStateInspector_1 = __webpack_require__(/*! ./InkStateInspector */ "./src/framework/ink/InkStateInspector.ts");
const StoryMessageManager_1 = __webpack_require__(/*! ./StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
class InkWriter {
    constructor(storyJson) {
        this._allInkCommands = new Map();
        this.setupInkCommands();
        this.createStroy(storyJson);
        this.load();
    }
    load() {
        let storyState = "";
        if (storyState != null && storyState != "") {
            this._currentStory.state.LoadJson(storyState);
        }
    }
    createStroy(json) {
        this._currentStory = new Story_1.Story(json);
    }
    beginStory(knotName) {
        if (this._currentStory == null) {
            console.warn("Trying to AdvanceStory in InkWriter when no story has been created");
            return;
        }
        this._currentStory.ChoosePathString(knotName, true);
        let inkState = new InkStateInspector_1.InkStateInspector();
        inkState.BindInkMethods(this._currentStory);
        this.advanceStory();
    }
    giveReward() {
        console.log("give reward...");
        return true;
    }
    setupInkCommands() {
        this._allInkCommands.set("GIVE_REWARD", this.giveReward);
    }
    handleCommand(command, args) {
        if (this._allInkCommands.has(command)) {
            return this._allInkCommands.get(command)(args);
        }
        console.error("Could not find InkCommand with name:" + command);
        return true;
    }
    parseCommandName(text) {
        let num = text.indexOf(InkWriter.COMMAND_PREFIX);
        let num2 = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num2 == -1) {
            num2 = text.length;
        }
        let length = num2 - (num + InkWriter.COMMAND_PREFIX.length);
        return text.substr(num + InkWriter.COMMAND_PREFIX.length, length).trim();
    }
    parseCommandArgs(text) {
        let num = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num == -1) {
            return [];
        }
        let length = text.length - (num + 1);
        let list = text.substr(num + 1, length).
            trim().
            split(InkWriter.COMMAND_ARG_DELIMITER);
        for (let i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
        }
        return list;
    }
    extractSpeaker(line) {
        if (line.startsWith(InkWriter.COMMAND_PREFIX)) {
            return ["0", line.trim()];
        }
        let array = line.split(':', 2);
        if (array.length > 1) {
            let speakID = array[0].trim();
            let speakContent = array[1].trim();
            return [speakID, speakContent];
        }
        return ["0", line.trim()];
    }
    saveCurrentStory() {
        let currState = this._currentStory.state.toJson();
        //TODO
    }
    canContinue() {
        return this._currentStory.canContinue;
    }
    advanceStory() {
        if (this._currentStory == null) {
            console.warn("Trying to AdvanceStory in InkWriter when no story has been created");
        }
        else if (this._currentStory.canContinue) {
            let text = this._currentStory.Continue().trim();
            if (text == "") {
                this.advanceStory();
                return;
            }
            let speakID;
            let speakContent;
            [speakID, speakContent] = this.extractSpeaker(text);
            let commandName = null;
            let args = null;
            if (speakContent.startsWith(InkWriter.COMMAND_PREFIX)) {
                commandName = this.parseCommandName(speakContent);
                args = this.parseCommandArgs(speakContent);
                if (commandName != null && commandName != "") {
                    if (this.handleCommand(commandName, args)) {
                        this.advanceStory();
                    }
                }
            }
            else {
                //OnContentReady
                StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastContentReady(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, speakContent, speakID, this._currentStory.currentTags, this._currentStory.currentChoices);
            }
        }
        else if (this._currentStory.currentChoices.length > 0) {
            //OnChoicesPresented
            StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastChoicesPresented(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this._currentStory.currentChoices);
        }
        else {
            //OnStoryFinished
            StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastStoryFinished(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED);
        }
    }
    selectChoice(choiceIndex) {
        if (this._currentStory == null) {
            console.warn("Trying to ChooseChoice in InkWriter when no story has begun");
            return;
        }
        this._currentStory.ChooseChoiceIndex(choiceIndex);
        this.advanceStory();
    }
    getVariable(variableName) {
        return this._currentStory.variablesState.GetVariableWithName(variableName);
    }
    setVariable(variableName, value) {
        this._currentStory.variablesState.$(variableName, value);
    }
}
exports.InkWriter = InkWriter;
InkWriter.DEBUG_STORY_ID = "DEBUG_STORY";
InkWriter.COMMAND_PREFIX = ">>>";
InkWriter.COMMAND_DELIMITER = ":";
InkWriter.COMMAND_ARG_DELIMITER = ',';


/***/ }),

/***/ "./src/framework/ink/StoryManager.ts":
/*!*******************************************!*\
  !*** ./src/framework/ink/StoryManager.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryManager = void 0;
const ResManager_1 = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const InkWriter_1 = __webpack_require__(/*! ./InkWriter */ "./src/framework/ink/InkWriter.ts");
class StoryManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.storyAddress = "Story/TestStory.json";
    }
    get inkWriter() {
        return this._inkWriter;
    }
    async initialize() {
        if (this._inkWriter == null) {
            var json = (await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadTextAsset(this.storyAddress)).text;
            this._inkWriter = new InkWriter_1.InkWriter(json);
        }
    }
    beginStory(knotName) {
        this._inkWriter.beginStory(knotName);
    }
    canContinue() {
        return this._inkWriter.canContinue;
    }
    advanceStory() {
        this._inkWriter.advanceStory();
    }
    selectChoice(choice) {
        this._inkWriter.selectChoice(choice.index);
    }
    loadCurrent() {
        if (this._inkWriter != null)
            this._inkWriter.load();
    }
    getVariable(variableName) {
        return this._inkWriter.getVariable(variableName);
    }
    setVariable(variableName, value) {
        this.inkWriter.setVariable(variableName, value);
    }
}
exports.StoryManager = StoryManager;


/***/ }),

/***/ "./src/framework/ink/StoryMessageManager.ts":
/*!**************************************************!*\
  !*** ./src/framework/ink/StoryMessageManager.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryMessageManager = void 0;
const Messenger_1 = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
class StoryMessageManager extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.storyMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.storyMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.storyMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.storyMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.storyMessage.clearup();
    }
    broadcastContentReady(msgCode, speakerContent, speakerId, currentTags, currentChoices) {
        this.storyMessage.broadcast(msgCode, speakerContent, speakerId, currentTags, currentChoices);
    }
    broadcastChoicesPresented(mesgCode, currentChoices) {
        this.storyMessage.broadcast(mesgCode, currentChoices);
    }
    broadcastStoryFinished(mesgCode) {
        this.storyMessage.broadcast(mesgCode);
    }
}
exports.StoryMessageManager = StoryMessageManager;
StoryMessageManager.ONCONTENTREADY = 1001;
StoryMessageManager.ONCHOICESPRESENTED = 1002;
StoryMessageManager.ONSTORYFINISHED = 1003;


/***/ }),

/***/ "./src/framework/net/GameSession.ts":
/*!******************************************!*\
  !*** ./src/framework/net/GameSession.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameSession = exports.MsgPack = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const Opcode_1 = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
const NetErrorCode_1 = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
const MessageParser_1 = __webpack_require__(/*! ./MessageParser */ "./src/framework/net/MessageParser.ts");
class MsgPack {
    constructor() {
        this.retryTimes = 0;
    }
}
exports.MsgPack = MsgPack;
class GameSession extends Singleton_1.Singleton {
    constructor() {
        super();
        this.id = 0; //session ID
        this.reSendInterval = 10000; //10
        this.timeoutInterval = 5000; //5
        this.maxReSendTimes = 5; //
        this._rpcId = 1;
        this.requestCallback = new Map();
        this.listeners = new Map();
        //ID, 
        this._serverId = -1;
        this._serverType = 1;
    }
    get rpcId() {
        return ++this._rpcId;
    }
    //address-> ip:port
    connectChannel(address, connCaback) {
        this.channel = csharp_1.NiceTS.TService.Instance.GetChannel();
        this.channel.errorCallback = (channel, code) => {
            if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
                this.timeoutIimer = setInterval(() => {
                    this.checkTimeoutMsg();
                }, this.timeoutInterval);
            }
            connCaback(channel, code);
        };
        this.channel.readCallback = (buffer) => {
            this.onReceive(buffer);
        };
        this.channel.Connect(address);
        return this;
    }
    //
    listen(opcode, callback) {
        this.listeners.set(opcode, callback);
    }
    //protoubf
    // rpc_id[4] - opcode[2] - server_id[2] - server_type[1] - 
    send(opcode, rpcid, message, callBack) {
        //
        let rpcBuf = MessageParser_1.MessageParser.encodeInt(rpcid); //4
        let opcodeBuf = MessageParser_1.MessageParser.encodeShort(opcode); //2
        let serveridBuf = MessageParser_1.MessageParser.encodeShort(this._serverId); //2
        let servertypeBuf = MessageParser_1.MessageParser.encodeByte(this._serverType); //1
        let sendArray = new Uint8Array(4 + 2 + 2 + 1 + message.length);
        sendArray.set(rpcBuf);
        sendArray.set(opcodeBuf, 4);
        sendArray.set(serveridBuf, 4 + 2);
        sendArray.set(servertypeBuf, 4 + 2 + 2);
        sendArray.set(message, 4 + 2 + 2 + 1);
        if (callBack != null) {
            let msgPack = new MsgPack();
            msgPack.sendTime = new Date().getTime();
            msgPack.callback = callBack;
            msgPack.bytes = sendArray;
            this.requestCallback.set(rpcid, msgPack);
        }
        // for(let i in sendArray){
        //     console.log("TS -- send array: "+i);
        // }
        //Console.log("send array: "+sendArray);
        this.channel.Send(sendArray);
    }
    reSend(bytes) {
        this.channel.Send(bytes);
    }
    onReceive(buffer) {
        let msgBuf = new Uint8Array(buffer);
        let rpcid = MessageParser_1.MessageParser.decodeInt(msgBuf.subarray(0, 4));
        let opcode = MessageParser_1.MessageParser.decodeShort(msgBuf.subarray(4, 6));
        let serverid = MessageParser_1.MessageParser.decodeShort(msgBuf.subarray(6, 8));
        let servertype = MessageParser_1.MessageParser.decodeByte(msgBuf.subarray(8, 9));
        this._serverId = serverid;
        this._serverType = servertype;
        let msgBytes = msgBuf.subarray(9);
        try {
            let decodeMsg = Opcode_1.Opcode.decode(opcode, msgBytes);
            if (rpcid == undefined || !this.requestCallback.has(rpcid)) {
                //
                if (this.listeners.has(opcode)) {
                    let listen = this.listeners.get(opcode);
                    listen(decodeMsg.msgObj);
                }
            }
            else {
                let msgPack = this.requestCallback.get(rpcid);
                msgPack.callback(decodeMsg.msgObj);
                this.requestCallback.delete(rpcid);
            }
        }
        catch (e) {
            console.error("parse msg error, opcode:" + opcode);
        }
    }
    checkTimeoutMsg() {
        let currTime = new Date().getTime();
        this.requestCallback.forEach((value, key) => {
            if (value.retryTimes >= this.maxReSendTimes) {
                //
                console.log(`Message resend too more, opcode:${key}, lastsend:${value.sendTime}`);
                this.requestCallback.delete(key);
            }
            else {
                if ((currTime - value.sendTime) >= this.reSendInterval) {
                    value.retryTimes++;
                    value.sendTime = currTime;
                    //
                    this.reSend(value.bytes);
                    console.log(`resend message:, opcode:${key}, retry times:${value.retryTimes}`);
                }
            }
        });
    }
    disconnect() {
        clearInterval(this.timeoutIimer);
        this.channel.Dispose();
    }
}
exports.GameSession = GameSession;


/***/ }),

/***/ "./src/framework/net/MessageParser.ts":
/*!********************************************!*\
  !*** ./src/framework/net/MessageParser.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageParser = void 0;
class MessageParser {
    static encodeInt(n) {
        let buffer = new Uint8Array(4);
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        return buffer;
    }
    static decodeInt(buffer) {
        let n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        return n;
    }
    static encodeShort(n) {
        let buffer = new Uint8Array(2);
        buffer[0] = n >>> 8;
        buffer[1] = n & 0xff;
        return buffer;
    }
    static decodeShort(buffer) {
        let n = buffer[0] << 8 | buffer[1];
        return n;
    }
    static encodeByte(n) {
        let buffer = new Uint8Array(1);
        buffer[0] = n & 0xff;
        return buffer;
    }
    static decodeByte(buffer) {
        let n = buffer[0];
        return n;
    }
}
exports.MessageParser = MessageParser;


/***/ }),

/***/ "./src/framework/net/NetErrorCode.ts":
/*!*******************************************!*\
  !*** ./src/framework/net/NetErrorCode.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetErrorCode = void 0;
class NetErrorCode {
}
exports.NetErrorCode = NetErrorCode;
NetErrorCode.ERR_SocketConnSucc = 100000;
NetErrorCode.ERR_ConnectGateKeyError = 100006;
NetErrorCode.ERR_PeerDisconnect = 102008;
NetErrorCode.ERR_SocketCantSend = 102009;
NetErrorCode.ERR_SocketError = 102010;
NetErrorCode.ERR_SocketConnError = 102011;


/***/ }),

/***/ "./src/framework/net/SessionManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/net/SessionManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
const GameConfig_1 = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const GameSession_1 = __webpack_require__(/*! ./GameSession */ "./src/framework/net/GameSession.ts");
const NetErrorCode_1 = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
class SessionManager extends Singleton_1.Singleton {
    get realmRpcID() {
        return this.sessionReam.rpcId;
    }
    get gateRpcID() {
        return this.sessionGate.rpcId;
    }
    connectRealmServer(onSucc, onError) {
        //
        this.sessionReam = GameSession_1.GameSession.Instance(GameSession_1.GameSession).connectChannel(GameConfig_1.GameConfig.realmServerIP + ":" + GameConfig_1.GameConfig.realmServerPort, (channel, code) => {
            this.onReamSocketErr(channel, code, onSucc, onError);
        });
    }
    onReamSocketErr(channel, code, onSucc, onError) {
        if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
            this.sessionReam.id = channel.Id;
            onSucc(code);
        }
        else {
            onError(code);
            console.error("login reamserver err, code: " + code + ",id:" + channel.Id);
        }
    }
    disconnectRealmServer() {
        this.sessionReam.disconnect();
        this.sessionReam = null;
    }
    sendRealmMsg(opcode, rpcID, buf, callback) {
        this.sessionReam.send(opcode, rpcID, buf, (response) => {
            callback(response);
        });
    }
    connectGateServer(address, onSucc, onError) {
        this.sessionGate = GameSession_1.GameSession.Instance(GameSession_1.GameSession).connectChannel(address, (channel, code) => {
            console.log("login Gate Server: " + code);
            this.onGateSocketErr(channel, code, onSucc, onError);
        });
    }
    onGateSocketErr(channel, code, onSucc, onError) {
        if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
            this.sessionGate.id = channel.Id;
            onSucc(code);
        }
        else {
            onError(code);
            console.error("gate server err, code: " + code + ",id:" + channel.Id);
        }
    }
    disconnectGateServer() {
        this.sessionGate.disconnect();
        this.sessionGate = null;
    }
    sendGateMsg(opcode, rpcID, buf, callback) {
        this.sessionGate.send(opcode, rpcID, buf, (response) => {
            callback(response);
        });
    }
}
exports.SessionManager = SessionManager;


/***/ }),

/***/ "./src/framework/redhints/RedHintsManager.ts":
/*!***************************************************!*\
  !*** ./src/framework/redhints/RedHintsManager.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RedHintsManager = exports.enumRedHints = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const RedHintsMessageManager_1 = __webpack_require__(/*! ./RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");
var enumRedHints;
(function (enumRedHints) {
    /**  */
    enumRedHints[enumRedHints["none"] = 0] = "none";
    /**  */
    enumRedHints[enumRedHints["chat"] = 1] = "chat";
    /**  */
    enumRedHints[enumRedHints["chat_world"] = 2] = "chat_world";
    /**  */
    enumRedHints[enumRedHints["chat_family"] = 3] = "chat_family";
    /**  */
    enumRedHints[enumRedHints["chat_system"] = 4] = "chat_system";
})(enumRedHints = exports.enumRedHints || (exports.enumRedHints = {}));
class RedHintsManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.init();
    }
    init() {
        this._data = [0]; //
        this._parentIndex = [0];
        this._childNum = [0];
        this._childIndex = [0];
        //-----------------------------------------------
        //
        this.setParent(enumRedHints.chat_world, enumRedHints.chat);
        this.setParent(enumRedHints.chat_family, enumRedHints.chat);
        this.setParent(enumRedHints.chat_system, enumRedHints.chat);
    }
    /**
     * 
    */
    setRedHintOpenOrClose(red, isOpen) {
        if (this._childNum[red] > 0) {
            console.log("");
            return;
        }
        this.doSetRedHintOpenOrClose(red, isOpen ? 1 : 0);
    }
    /**
     * ---
    */
    setParent(child, parent) {
        if (this._parentIndex[parent] == child) {
            console.log("");
            return;
        }
        if (this._parentIndex[child]) {
            console.log("");
            return;
        }
        this._parentIndex[child] = parent;
        if (isNaN(this._childNum[parent])) {
            this._childNum[parent] = 0;
        }
        this._childNum[parent]++; //
        this._childIndex[child] = this._childNum[parent]; // 1
    }
    doSetRedHintOpenOrClose(red, value) {
        if (this._data[red] != value) {
            this._data[red] = value;
            let _parent = this._parentIndex[red];
            if (_parent) {
                //
                let index = this._childIndex[red]; //
                this.doSetRedHintOpenOrClose(_parent, value > 0 ? this._data[_parent] | this.addV(index) : this._data[_parent] & this.subV(index)); //
            }
            //:
            //emit(RedHintsManager.RED_HINT_VALUE_CHANGED, red);
            //
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).broadcast(red, value);
        }
    }
    addV(index) {
        return 1 << (index - 1);
    }
    subV(index) {
        return ~this.addV(index);
    }
    /**
     * 
    */
    checkRedIsOpen(red) {
        return this._data[red] > 0;
    }
}
exports.RedHintsManager = RedHintsManager;
/**
 * 
*/
RedHintsManager.RED_HINT_VALUE_CHANGED = "RED_HINT_VALUE_CHANGED";


/***/ }),

/***/ "./src/framework/redhints/RedHintsMessageManager.ts":
/*!**********************************************************!*\
  !*** ./src/framework/redhints/RedHintsMessageManager.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RedHintsMessageManager = void 0;
const Messenger_1 = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
class RedHintsMessageManager extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.redhintsMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.redhintsMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.redhintsMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.redhintsMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.redhintsMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.redhintsMessage.broadcast(msgCode, params);
    }
}
exports.RedHintsMessageManager = RedHintsMessageManager;


/***/ }),

/***/ "./src/framework/scene/BaseScene.ts":
/*!******************************************!*\
  !*** ./src/framework/scene/BaseScene.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseScene = void 0;
const GameObjectPool_1 = __webpack_require__(/*! ../common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
const ResManager_1 = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
class BaseScene {
    constructor() {
        this.finishCount = 0;
        this.totalCount = 0;
        this.preloadFairyGUIPackage = new Map();
        this.preloadPrefab = new Map();
        this.finishCount = 0;
    }
    addPreloadFairyGUIPackage(address, packageName) {
        this.preloadFairyGUIPackage.set(address, packageName);
    }
    addPreloadPrefab(address, instCount) {
        this.preloadPrefab.set(address, instCount);
    }
    async onPrepare() {
        let fguiPkgCount = this.preloadFairyGUIPackage.size;
        let prefabCount = this.preloadPrefab.size;
        this.totalCount = fguiPkgCount + prefabCount;
        let premises = [];
        this.preloadFairyGUIPackage.forEach((value, key) => {
            let premise = ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadFairyGUIPackage(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        this.preloadPrefab.forEach((value, key) => {
            let premise = GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).preLoadGameObjectAsync(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        await Promise.all(premises);
    }
    onDestroy() {
        this.preloadFairyGUIPackage.forEach((value, key) => {
            console.log("destroy scene: " + key);
            ResManager_1.ResManager.Instance(ResManager_1.ResManager).releaseFairyGUIPackage(value);
        });
        //
        GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).cleanup(true);
        this.preloadFairyGUIPackage.clear();
        this.preloadPrefab.clear();
    }
}
exports.BaseScene = BaseScene;


/***/ }),

/***/ "./src/framework/scene/SceneDef.ts":
/*!*****************************************!*\
  !*** ./src/framework/scene/SceneDef.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneDef = void 0;
class SceneDef {
}
exports.SceneDef = SceneDef;
SceneDef.LoadingScene = "LoadingScene";
SceneDef.LaunchScene = "LaunchScene";
SceneDef.HomeScene = "HomeScene";
SceneDef.LoginScene = "LoginScene";
SceneDef.PveScene = "PveScene";


/***/ }),

/***/ "./src/framework/scene/SceneFactory.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneFactory.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneFactory = void 0;
const PveScene_1 = __webpack_require__(/*! ../../game/module/pve/scene/PveScene */ "./src/game/module/pve/scene/PveScene.ts");
const HomeScene_1 = __webpack_require__(/*! ../../game/module/home/scene/HomeScene */ "./src/game/module/home/scene/HomeScene.ts");
const LoginScene_1 = __webpack_require__(/*! ../../game/module/login/scene/LoginScene */ "./src/game/module/login/scene/LoginScene.ts");
const SceneDef_1 = __webpack_require__(/*! ./SceneDef */ "./src/framework/scene/SceneDef.ts");
class SceneFactory {
    static createScene(sceneName) {
        let scene = null;
        switch (sceneName) {
            case SceneDef_1.SceneDef.LoginScene:
                scene = new LoginScene_1.LoginScene();
                break;
            case SceneDef_1.SceneDef.HomeScene:
                scene = new HomeScene_1.HomeScene();
                break;
            case SceneDef_1.SceneDef.PveScene:
                scene = new PveScene_1.PveScene();
                break;
        }
        return scene;
    }
}
exports.SceneFactory = SceneFactory;


/***/ }),

/***/ "./src/framework/scene/SceneManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneManager = void 0;
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
const common_1 = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
const UIMessage_1 = __webpack_require__(/*! ../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const UIManager_1 = __webpack_require__(/*! ../ui/UIManager */ "./src/framework/ui/UIManager.ts");
const SceneFactory_1 = __webpack_require__(/*! ./SceneFactory */ "./src/framework/scene/SceneFactory.ts");
class SceneManager extends Singleton_1.Singleton {
    constructor() {
        super();
        csharp_1.UnityEngine.SceneManagement.SceneManager.add_sceneLoaded((scene, _mode) => {
            if (this.onSceneLoadedOnly != null)
                this.onSceneLoadedOnly(scene.name);
        });
    }
    async loadScene(scene, onLoadComplete) {
        try {
            this.onSceneLoadedOnly = async (sceneName) => {
                if (sceneName == scene) {
                    this.onSceneLoadedOnly = null;
                    this.currentScene = SceneFactory_1.SceneFactory.createScene(scene);
                    this.currentScene.onEnter();
                    let progressInterval = setInterval(() => {
                        let progress = this.currentScene.finishCount / this.currentScene.totalCount;
                        console.log("progress:" + progress + " = " + this.currentScene.finishCount + " = " + this.currentScene.totalCount);
                        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).broadcast(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS, progress * 100);
                        if (this.currentScene.finishCount == this.currentScene.totalCount) {
                            clearInterval(progressInterval);
                            //
                            this.currentScene.onComplete();
                            if (onLoadComplete != null)
                                onLoadComplete();
                            UIManager_1.UIManager.Instance(UIManager_1.UIManager).closeLoading(common_1.commonUI.UILoadingPage);
                        }
                    }, 100);
                    this.currentScene.onPrepare();
                }
            };
            UIManager_1.UIManager.Instance(UIManager_1.UIManager).openLoading(common_1.commonUI.PackageName, common_1.commonUI.UILoadingPage);
            //
            if (this.currentScene) {
                this.currentScene.onLeave();
                this.currentScene.onDestroy();
            }
            await csharp_1.UnityEngine.SceneManagement.SceneManager.LoadScene(scene);
        }
        catch (ex) {
            console.log("load scene excep:" + ex);
        }
    }
}
exports.SceneManager = SceneManager;


/***/ }),

/***/ "./src/framework/ui/UIDefine.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIDefine.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIComDefs = exports.UILayerDef = exports.UITypeDef = void 0;
var UITypeDef;
(function (UITypeDef) {
    UITypeDef[UITypeDef["Unkown"] = 0] = "Unkown";
    UITypeDef[UITypeDef["Page"] = 1] = "Page";
    UITypeDef[UITypeDef["Window"] = 2] = "Window";
    UITypeDef[UITypeDef["Widget"] = 3] = "Widget";
    UITypeDef[UITypeDef["Loading"] = 4] = "Loading";
})(UITypeDef = exports.UITypeDef || (exports.UITypeDef = {}));
class UILayerDef {
    static getDefaultLayer(type) {
        switch (type) {
            case UITypeDef.Loading: return this.Loading;
            case UITypeDef.Widget: return this.Widget;
            case UITypeDef.Window: return this.NormalWindow;
            case UITypeDef.Page: return this.Page;
            case UITypeDef.Unkown: return this.Unkown;
            default: return this.Unkown;
        }
    }
}
exports.UILayerDef = UILayerDef;
UILayerDef.Background = 0;
UILayerDef.Page = 1000;
UILayerDef.NormalWindow = 2000;
UILayerDef.TopWindow = 3000;
UILayerDef.Widget = 4000;
UILayerDef.Loading = 5000;
UILayerDef.Unkown = 9999;
class UIComDefs {
}
exports.UIComDefs = UIComDefs;
UIComDefs.BackBtn = "back_btn";
UIComDefs.WindowCloseBtn = "win_close_btn";


/***/ }),

/***/ "./src/framework/ui/UIFactory.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIFactory.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIFactory = void 0;
const UILoginPage_1 = __webpack_require__(/*! ../../game/module/login/ui/UILoginPage */ "./src/game/module/login/ui/UILoginPage.ts");
const UIHomePage_1 = __webpack_require__(/*! ../../game/module/home/ui/UIHomePage */ "./src/game/module/home/ui/UIHomePage.ts");
const UILoading_1 = __webpack_require__(/*! ./UILib/UILoading */ "./src/framework/ui/UILib/UILoading.ts");
const login_1 = __webpack_require__(/*! ../../data/ui/login */ "./src/data/ui/login.ts");
const common_1 = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
const home_1 = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
const UIMsgBox_1 = __webpack_require__(/*! ./UILib/UIMsgBox */ "./src/framework/ui/UILib/UIMsgBox.ts");
const UISelServerWin_1 = __webpack_require__(/*! ../../game/module/login/ui/UISelServerWin */ "./src/game/module/login/ui/UISelServerWin.ts");
const UIShopPage_1 = __webpack_require__(/*! ../../game/module/home/ui/UIShopPage */ "./src/game/module/home/ui/UIShopPage.ts");
const story_1 = __webpack_require__(/*! ../../data/ui/story */ "./src/data/ui/story.ts");
const UIStoryWin_1 = __webpack_require__(/*! ../../game/module/story/UIStoryWin */ "./src/game/module/story/UIStoryWin.ts");
const CS = __webpack_require__(/*! csharp */ "csharp");
class UIFactory {
    static createUI(pkg, name) {
        console.log(`create UI: ${pkg}:${name}`);
        let comp = CS.FairyGUI.UIPackage.CreateObject(pkg, name).asCom;
        let ui = this.uiCache.get(name);
        if (!ui) {
            switch (name) {
                //common
                case common_1.commonUI.UIUINoticeWin:
                    ui = new UIMsgBox_1.UIMsgBox();
                    break;
                case common_1.commonUI.UILoadingPage:
                    ui = new UILoading_1.UILoading();
                    break;
                //login
                case login_1.loginUI.UILoginPage:
                    ui = new UILoginPage_1.UILoginPage();
                    break;
                case login_1.loginUI.UISelServerWin:
                    ui = new UISelServerWin_1.UISelServerWin();
                    break;
                //home
                case home_1.homeUI.UIHomePage:
                    ui = new UIHomePage_1.UIHomePage();
                    break;
                case home_1.homeUI.UIShopPage:
                    ui = new UIShopPage_1.UIShopPage();
                    break;
                //story
                case story_1.storyUI.UIStoryWin:
                    ui = new UIStoryWin_1.UIStoryWin();
                    break;
            }
            this.uiCache.set(name, ui);
        }
        if (ui != null) {
            ui.fui = comp;
            ui.name = name;
            //FairyGUI
            ui.bindAll(ui);
            ui.awake();
        }
        else {
            console.error(`not create ui: ${pkg}-${name}`);
        }
        return ui;
    }
}
exports.UIFactory = UIFactory;
UIFactory.uiCache = new Map();


/***/ }),

/***/ "./src/framework/ui/UILib/UILoading.ts":
/*!*********************************************!*\
  !*** ./src/framework/ui/UILib/UILoading.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UILoading = void 0;
const UIPanel_1 = __webpack_require__(/*! ../UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ../UIDefine */ "./src/framework/ui/UIDefine.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
class UILoading extends UIPanel_1.UIPanel {
    onAwake() {
    }
    get uiType() {
        return UIDefine_1.UITypeDef.Loading;
    }
    onOpen(arg) {
        super.onOpen(arg);
        this.progressLoading.value = 0;
        this.progressLoading.visible = true;
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).addListener(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS, this, (progress) => {
            this.progressLoading.TweenValue(progress, 0.1);
        });
    }
    onClose(arg) {
        super.onClose(arg);
        this.progressLoading.visible = false;
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).removeListenerByCode(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS);
    }
}
__decorate([
    NiceDecorator_1.binder("loading_pregress")
], UILoading.prototype, "progressLoading", void 0);
exports.UILoading = UILoading;


/***/ }),

/***/ "./src/framework/ui/UILib/UIMsgBox.ts":
/*!********************************************!*\
  !*** ./src/framework/ui/UILib/UIMsgBox.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMsgBox = exports.UIMsgBoxArg = void 0;
const NiceDecorator_1 = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIWindow_1 = __webpack_require__(/*! ../UIWindow */ "./src/framework/ui/UIWindow.ts");
// 
class UIMsgBoxArg {
    constructor() {
        this.title = "";
        this.content = "";
        this.btnText = ""; //"||"
    }
}
exports.UIMsgBoxArg = UIMsgBoxArg;
class UIMsgBox extends UIWindow_1.UIWindow {
    onAwake() {
        super.onAwake();
        this.bindAll(this);
    }
    onOpen(arg) {
        super.onOpen(arg);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    NiceDecorator_1.binder("msgTxt")
], UIMsgBox.prototype, "m_txt", void 0);
__decorate([
    NiceDecorator_1.binder("okBtn")
], UIMsgBox.prototype, "m_okBtn", void 0);
__decorate([
    NiceDecorator_1.binder("cancelBtn")
], UIMsgBox.prototype, "m_cancelBtn", void 0);
exports.UIMsgBox = UIMsgBox;


/***/ }),

/***/ "./src/framework/ui/UIManager.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIManager.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIManager = exports.UIPageTrack = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const UIFactory_1 = __webpack_require__(/*! ./UIFactory */ "./src/framework/ui/UIFactory.ts");
const home_1 = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
class UIPageTrack {
}
exports.UIPageTrack = UIPageTrack;
class UIManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.m_pageTrackStack = new Array();
        this.m_listLoadedPanel = new Array();
    }
    closeAllLoadedPanel() {
        for (let i = this.m_listLoadedPanel.length - 1; i >= 0; i--) {
            let panel = this.m_listLoadedPanel[i];
            if (panel.isOpen) {
                panel.close();
            }
            panel.dispose();
        }
        this.m_listLoadedPanel.length = 0;
    }
    clean() {
        this.closeAllLoadedPanel();
        this.m_pageTrackStack.length = 0;
        this.m_listLoadedPanel.length = 0;
    }
    open(pkg, name, arg) {
        let ui = this.getUI(name);
        if (ui == null) {
            ui = UIFactory_1.UIFactory.createUI(pkg, name);
            this.m_listLoadedPanel.push(ui);
        }
        if (ui != null) {
            ui.open(arg);
        }
        return ui;
    }
    getUI(name) {
        for (const panel of this.m_listLoadedPanel) {
            if (panel.name == name) {
                console.log("find panel in cache: " + name);
                return panel;
            }
        }
        return null;
    }
    //,,
    openPageInScene(pkg, page, arg) {
        this.openPageWorker(pkg, page, arg);
    }
    //==========================================================UILoading
    //Loading
    openLoading(pkg, name, arg) {
        this.openPageInScene(pkg, name, arg);
    }
    //Loading
    closeLoading(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================Page
    openPageWorker(pkg, page, arg) {
        this.m_currentPage = new UIPageTrack();
        this.m_currentPage.pkg = pkg;
        this.m_currentPage.name = page;
        this.m_currentPage.arg = arg;
        this.closeAllLoadedPanel();
        this.open(pkg, page, arg);
    }
    //, ,Widiget
    openPage(pkg, name, arg) {
        if (this.m_currentPage != undefined && this.m_currentPage.name != name) {
            this.m_pageTrackStack.push(this.m_currentPage);
        }
        this.openPageWorker(pkg, name, arg);
    }
    //
    goBackPage() {
        if (this.m_pageTrackStack.length > 0) {
            let track = this.m_pageTrackStack.pop();
            this.openPageWorker(track.pkg, track.name, track.arg);
        }
        else {
            this.enterMainPage();
        }
    }
    //
    enterMainPage() {
        this.m_pageTrackStack.length = 0;
        this.openPageInScene(home_1.homeUI.PackageName, home_1.homeUI.UIHomePage, null);
    }
    //==========================================================UIWindow
    //
    openWindow(pkg, name, arg) {
        let ui = this.open(pkg, name, arg);
        return ui;
    }
    //
    closeWindow(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================UIWidget
    //Widiget
    openWidget(pkg, name, arg) {
        let ui = this.open(pkg, name, arg);
        return ui;
    }
    //uWidiget
    closeWidget(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
}
exports.UIManager = UIManager;


/***/ }),

/***/ "./src/framework/ui/UIPage.ts":
/*!************************************!*\
  !*** ./src/framework/ui/UIPage.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIPage = void 0;
const UIPanel_1 = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const UIManager_1 = __webpack_require__(/*! ./UIManager */ "./src/framework/ui/UIManager.ts");
class UIPage extends UIPanel_1.UIPanel {
    get uiType() {
        return UIDefine_1.UITypeDef.Page;
    }
    onAwake() {
        this.m_btnGoBack = this.fui.GetChild(UIDefine_1.UIComDefs.BackBtn);
        if (this.m_btnGoBack != undefined) {
            this.m_btnGoBack.onClick.Add(() => {
                this.onBtnGoBack();
            });
        }
    }
    onOpen(vo) {
        super.onOpen(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onBtnGoBack() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).goBackPage();
    }
}
exports.UIPage = UIPage;


/***/ }),

/***/ "./src/framework/ui/UIPanel.ts":
/*!*************************************!*\
  !*** ./src/framework/ui/UIPanel.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIPanel = void 0;
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class UIPanel {
    constructor() {
        this.m_layer = UIDefine_1.UILayerDef.Unkown;
    }
    set name(v) {
        this._name = v;
    }
    get name() {
        return this._name;
    }
    get uiType() {
        return UIDefine_1.UITypeDef.Unkown;
    }
    get layer() {
        return this.m_layer;
    }
    set layer(v) {
        this.m_layer = v;
    }
    get isOpen() {
        return this.fui.visible;
    }
    onUpdate() { }
    onOpen(vo) {
        this.layer = UIDefine_1.UILayerDef.getDefaultLayer(this.uiType);
    }
    onClose(arg) { }
    awake() {
        this.onAwake();
    }
    //FairyGUI
    bindAll(target) {
        for (let k in target["binders"]) {
            let fguiName = this["binders"][k];
            this[k] = this.fui.GetChild(fguiName);
        }
    }
    update() {
        this.onUpdate();
    }
    open(arg) {
        this.onOpen(arg);
        csharp_1.FairyGUI.GRoot.inst.AddChild(this.fui);
    }
    close(arg = null) {
        this.onClose(arg);
        csharp_1.FairyGUI.GRoot.inst.RemoveChild(this.fui);
    }
    dispose() {
        this.fui.Dispose();
    }
}
exports.UIPanel = UIPanel;


/***/ }),

/***/ "./src/framework/ui/UIWindow.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIWindow.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIWindow = void 0;
const UIPanel_1 = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class UIWindow extends UIPanel_1.UIPanel {
    get uiType() {
        return UIDefine_1.UITypeDef.Window;
    }
    onAwake() {
        this.m_btnClose = this.fui.GetChild(UIDefine_1.UIComDefs.WindowCloseBtn);
    }
    onOpen(arg) {
        super.onOpen(arg);
        this.fui.x = csharp_1.FairyGUI.GRoot.inst.width / 2 - this.fui.width / 2;
        this.fui.y = csharp_1.FairyGUI.GRoot.inst.height / 2 - this.fui.height / 2;
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Add(this.onBtnClose);
        }
    }
    onClose(arg) {
        super.onClose(arg);
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Remove(this.onBtnClose);
        }
    }
    onBtnClose() {
        this.close(0);
    }
}
exports.UIWindow = UIWindow;


/***/ }),

/***/ "./src/framework/util/TimeUtil.ts":
/*!****************************************!*\
  !*** ./src/framework/util/TimeUtil.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUtil = void 0;
class TimeUtil {
    static prefixInteger(num, length) {
        return (Array(length).join('0') + num).slice(-length);
    }
    //"00:00:00"
    static getTimeString1(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${hourstr}:${minutestr}:${secondstr}`;
        }
    }
    //"00:00"
    static getTimeString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${hourstr}:${minutestr}`;
        }
    }
    //"00"
    static getTimeMinuteString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${minutestr}`;
        }
    }
    //"00
    static getTimeSecondString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${secondstr}`;
        }
    }
    //1
    static getWeekOfMonthFirstDay(time) {
        let date = new Date(time);
        date.setDate(1);
        return date.getDay();
    }
    //
    static isLeapYear(year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
            return true;
        }
        return false;
    }
    static getMonthDays_(year, month) {
        if (month == 2) {
            if (this.isLeapYear(year))
                return 29;
            else {
                return 28;
            }
        }
        else {
            return this.months[month];
        }
    }
    static getMonthDays(time) {
        let t = new Date(time);
        return this.getMonthDays_(t.getFullYear(), t.getMonth());
    }
    static async sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve('');
            }, ms);
        });
    }
    static test() {
        let t1 = this.getTimeString1(5000);
        console.log(t1);
        let t2 = this.getTimeString(5000);
        console.log(t2);
        let t3 = this.getTimeMinuteString(5000);
        console.log(t3);
        let t4 = this.getTimeSecondString(5000);
        console.log(t4);
        let time = new Date().getTime();
        let t5 = this.getWeekOfMonthFirstDay(time);
        console.log("getWeekOfMonthFirstDay: " + t5 + " ,time:" + time);
        let t6 = this.getMonthDays(time);
        console.log("getMonthDays: " + t6);
    }
}
exports.TimeUtil = TimeUtil;
//
TimeUtil.months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];


/***/ }),

/***/ "./src/game/api/LoginAPI.ts":
/*!**********************************!*\
  !*** ./src/game/api/LoginAPI.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginAPI = void 0;
const pb_1 = __webpack_require__(/*! ../../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
const Opcode_1 = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
const SessionManager_1 = __webpack_require__(/*! ../../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
class LoginAPI {
    static benchmarkTest() {
        for (let i = 1; i < 2; i++) {
            let msg = pb_1.nice_ts.C2GS_Test.create();
            msg.testID = i;
            msg.testName = "benchmark test";
            let buf = pb_1.nice_ts.C2GS_Test.encode(msg).finish();
            let rpcId = SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).gateRpcID;
            //test
            rpcId = i;
            console.log("send msg: " + rpcId);
            SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendGateMsg(Opcode_1.Opcode.MSG_C2GS_Test, rpcId, buf, (response) => {
                let msg = response;
                console.log("code: " + msg.Error + ",msg:" + msg.Message + ",res:" + msg.testResponse);
            });
        }
    }
    static loginRealmServer(account, password, callback) {
        let msg = pb_1.nice_ts.C2R_Login.create();
        msg.Account = account;
        msg.Password = password;
        let buf = pb_1.nice_ts.C2R_Login.encode(msg).finish();
        let rpcId = SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).realmRpcID;
        SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendRealmMsg(Opcode_1.Opcode.MSG_C2R_Login, rpcId, buf, (response) => {
            let msg = response;
            callback(msg);
        });
    }
    static loginGateServer(gateId, gateKey, callback) {
        let rpcId = SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).gateRpcID;
        let msg = pb_1.nice_ts.C2G_LoginGate.create();
        msg.GateId = gateId;
        msg.Key = gateKey;
        let buf = pb_1.nice_ts.C2G_LoginGate.encode(msg).finish();
        SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendGateMsg(Opcode_1.Opcode.MSG_C2G_LoginGate, rpcId, buf, (response) => {
            let msg = response;
            callback(msg);
        });
    }
}
exports.LoginAPI = LoginAPI;


/***/ }),

/***/ "./src/game/event/UIMessage.ts":
/*!*************************************!*\
  !*** ./src/game/event/UIMessage.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMessage = void 0;
class UIMessage {
}
exports.UIMessage = UIMessage;
UIMessage.MSG_SELECT_SERVER = 1000;
UIMessage.MSG_SCENE_PROGRESS = 1001;


/***/ }),

/***/ "./src/game/event/UIMessageManager.ts":
/*!********************************************!*\
  !*** ./src/game/event/UIMessageManager.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMessageManger = void 0;
const Messenger_1 = __webpack_require__(/*! ../../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class UIMessageManger extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.uiMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.uiMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.uiMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.uiMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.uiMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.uiMessage.broadcast(msgCode, params);
    }
}
exports.UIMessageManger = UIMessageManger;


/***/ }),

/***/ "./src/game/module/home/scene/HomeScene.ts":
/*!*************************************************!*\
  !*** ./src/game/module/home/scene/HomeScene.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HomeScene = void 0;
const home_1 = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const VoHome_1 = __webpack_require__(/*! ../vo/VoHome */ "./src/game/module/home/vo/VoHome.ts");
class HomeScene extends BaseScene_1.BaseScene {
    constructor() {
        super();
    }
    onEnter() {
        this.addPreloadFairyGUIPackage(home_1.homeUI.PackageBytes, home_1.homeUI.PackageName);
    }
    onComplete() {
        let vo = new VoHome_1.VoHome();
        vo.name = "Justin";
        vo.hp = 1200;
        vo.mp = 3300;
        vo.money = 666;
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPageInScene(home_1.homeUI.PackageName, home_1.homeUI.UIHomePage, vo);
    }
    onLeave() {
    }
}
exports.HomeScene = HomeScene;


/***/ }),

/***/ "./src/game/module/home/ui/UIHomePage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIHomePage.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIHomePage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const common_1 = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
const home_1 = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
const LoginAPI_1 = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
const GameSession_1 = __webpack_require__(/*! ../../../../framework/net/GameSession */ "./src/framework/net/GameSession.ts");
const Opcode_1 = __webpack_require__(/*! ../../../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
class UIHomePage extends UIPage_1.UIPage {
    onAwake() {
        super.onAwake();
        this.m_chatBtn.onClick.Add(() => {
            this.onchatBtn();
        });
        this.m_bagBtn.onClick.Add(() => {
            this.onbagBtn();
        });
        this.m_shopBtn.onClick.Add(() => {
            this.onshopBtn();
        });
        this.m_levelBtn.onClick.Add(() => {
            this.onlevelBtn();
        });
    }
    onOpen(vo) {
        super.onOpen(vo);
        this.m_nameLbl.text = vo.name;
        this.m_mpLbl.text = vo.mp.toString();
        this.m_hpLbl.text = vo.hp.toString();
        this.m_moneyLbl.text = vo.money.toString();
        GameSession_1.GameSession.Instance(GameSession_1.GameSession).listen(Opcode_1.Opcode.MSG_GS2C_Test, function (msg) {
            console.log("" + msg.testResponse);
        });
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onchatBtn() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(common_1.commonUI.PackageName, common_1.commonUI.UIUINoticeWin, null);
        console.log("on chat...");
    }
    onbagBtn() {
        console.log("on bag ..");
        //benchmark test
        LoginAPI_1.LoginAPI.benchmarkTest();
    }
    onshopBtn() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPage(home_1.homeUI.PackageName, home_1.homeUI.UIShopPage);
    }
    onlevelBtn() {
        console.log("on level...");
    }
}
__decorate([
    NiceDecorator_1.binder("chatBtn")
], UIHomePage.prototype, "m_chatBtn", void 0);
__decorate([
    NiceDecorator_1.binder("bagBtn")
], UIHomePage.prototype, "m_bagBtn", void 0);
__decorate([
    NiceDecorator_1.binder("shopBtn")
], UIHomePage.prototype, "m_shopBtn", void 0);
__decorate([
    NiceDecorator_1.binder("levelBtn")
], UIHomePage.prototype, "m_levelBtn", void 0);
__decorate([
    NiceDecorator_1.binder("nameTxt")
], UIHomePage.prototype, "m_nameLbl", void 0);
__decorate([
    NiceDecorator_1.binder("hpTxt")
], UIHomePage.prototype, "m_hpLbl", void 0);
__decorate([
    NiceDecorator_1.binder("mpTxt")
], UIHomePage.prototype, "m_mpLbl", void 0);
__decorate([
    NiceDecorator_1.binder("moneyTxt")
], UIHomePage.prototype, "m_moneyLbl", void 0);
exports.UIHomePage = UIHomePage;


/***/ }),

/***/ "./src/game/module/home/ui/UIShopPage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIShopPage.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIShopPage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
class UIShopPage extends UIPage_1.UIPage {
    onAwake() {
        super.onAwake();
    }
    onOpen(vo) {
        super.onOpen(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
exports.UIShopPage = UIShopPage;


/***/ }),

/***/ "./src/game/module/home/vo/VoHome.ts":
/*!*******************************************!*\
  !*** ./src/game/module/home/vo/VoHome.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VoHome = void 0;
class VoHome {
}
exports.VoHome = VoHome;


/***/ }),

/***/ "./src/game/module/login/scene/LoginScene.ts":
/*!***************************************************!*\
  !*** ./src/game/module/login/scene/LoginScene.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginScene = void 0;
const login_1 = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
const story_1 = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
class LoginScene extends BaseScene_1.BaseScene {
    onEnter() {
        //
        this.addPreloadFairyGUIPackage(login_1.loginUI.PackageBytes, login_1.loginUI.PackageName);
        //Story
        this.addPreloadFairyGUIPackage(story_1.storyUI.PackageBytes, story_1.storyUI.PackageName);
    }
    onComplete() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPageInScene(login_1.loginUI.PackageName, login_1.loginUI.UILoginPage, null);
    }
    onLeave() {
    }
}
exports.LoginScene = LoginScene;


/***/ }),

/***/ "./src/game/module/login/ui/UILoginPage.ts":
/*!*************************************************!*\
  !*** ./src/game/module/login/ui/UILoginPage.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UILoginPage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const SessionManager_1 = __webpack_require__(/*! ../../../../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
const LoginAPI_1 = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const login_1 = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
const VoServer_1 = __webpack_require__(/*! ../vo/VoServer */ "./src/game/module/login/vo/VoServer.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
const SceneManager_1 = __webpack_require__(/*! ../../../../framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
const SceneDef_1 = __webpack_require__(/*! ../../../../framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
const story_1 = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
class UILoginPage extends UIPage_1.UIPage {
    onAwake() {
        super.onAwake();
        this.m_loginBtn.onClick.Add(() => {
            this.onLoginClick();
        });
        this.m_storyBtn.onClick.Add(() => {
            UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(story_1.storyUI.PackageName, story_1.storyUI.UIStoryWin, null);
        });
        this.m_selserverBtn.onClick.Add(() => {
            this.openSelServerWin();
        });
        this.m_loginBtn.enabled = false;
        SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).connectRealmServer((code) => {
            this.m_loginBtn.enabled = true;
        }, (code) => {
        });
    }
    onSelectServer(serverItem) {
        console.log(" server selected: " + serverItem.serverName);
        this.m_selserverBtn.text = serverItem.serverName;
    }
    onOpen(vo) {
        super.onOpen(vo);
        //
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).addListener(UIMessage_1.UIMessage.MSG_SELECT_SERVER, this, this.onSelectServer);
    }
    onClose(arg) {
        super.onClose(arg);
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).removeListener(UIMessage_1.UIMessage.MSG_SELECT_SERVER, this.onSelectServer);
    }
    openSelServerWin() {
        // 
        let voServer = new VoServer_1.VoServer();
        for (let i = 1; i < 10; i++) {
            voServer.areaMap.set(i, "" + i);
            voServer.serverMap.set(i, new Array());
            for (let j = 1; j < 20; j++) {
                let voServerItem = new VoServer_1.VoServerItem();
                voServerItem.areaId = i;
                voServerItem.serverId = j;
                voServerItem.serverName = "" + i + ":" + j;
                voServerItem.serverStatus = Math.floor(Math.random() * 3 + 1);
                voServer.serverMap.get(i).push(voServerItem);
            }
        }
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(login_1.loginUI.PackageName, login_1.loginUI.UISelServerWin, voServer);
    }
    onLoginClick() {
        let account = this.m_account.text;
        let password = this.m_password.text;
        console.log(`account:${account} - password: ${password}`);
        if (account != "" && password != "") {
            LoginAPI_1.LoginAPI.loginRealmServer(account, password, (msg) => {
                this.gateId = msg.GateId;
                this.gateKey = msg.Key;
                console.log("login ream succ, gate addr:" + msg.Address + ",key:" + msg.Key);
                SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).disconnectRealmServer();
                //
                SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).connectGateServer(msg.Address, (code) => { this.onConnGateSucc(code); }, (code) => { this.onConnGateErr(code); });
            });
        }
    }
    onConnGateSucc(code) {
        console.log("connect gate succ: " + code);
        LoginAPI_1.LoginAPI.loginGateServer(this.gateId, this.gateKey, (msg) => {
            let playerID = msg.PlayerId;
            console.log("login gate response.." + playerID);
            SceneManager_1.SceneManager.Instance(SceneManager_1.SceneManager).loadScene(SceneDef_1.SceneDef.HomeScene, () => { });
        });
    }
    onConnGateErr(code) {
        console.log("connect gate err: " + code);
    }
}
__decorate([
    NiceDecorator_1.binder("account")
], UILoginPage.prototype, "m_account", void 0);
__decorate([
    NiceDecorator_1.binder("password")
], UILoginPage.prototype, "m_password", void 0);
__decorate([
    NiceDecorator_1.binder("selserverBtn")
], UILoginPage.prototype, "m_selserverBtn", void 0);
__decorate([
    NiceDecorator_1.binder("loginBtn")
], UILoginPage.prototype, "m_loginBtn", void 0);
__decorate([
    NiceDecorator_1.binder("storyBtn")
], UILoginPage.prototype, "m_storyBtn", void 0);
exports.UILoginPage = UILoginPage;


/***/ }),

/***/ "./src/game/module/login/ui/UISelServerWin.ts":
/*!****************************************************!*\
  !*** ./src/game/module/login/ui/UISelServerWin.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UISelServerWin = void 0;
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIWindow_1 = __webpack_require__(/*! ../../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
class UISelServerWin extends UIWindow_1.UIWindow {
    constructor() {
        super(...arguments);
        this.clickAreaIndex = 0;
        this.clickServerIndex = 0;
    }
    onAwake() {
        super.onAwake();
        this.backBtn.onClick.Add(() => {
            this.close();
        });
        this.okBtn.onClick.Add(() => {
            this.onSelectServer();
        });
        this.areaList.onClickItem.Add((event) => {
            this.clickAreaIndex = this.areaList.GetChildIndex(event.data);
            this.serverList.numItems = this.voServer.serverMap.get(this.clickAreaIndex + 1).length;
            this.serverList.RefreshVirtualList();
        });
        this.serverList.onClickItem.Add((event) => {
            this.clickServerIndex = this.serverList.GetChildIndex(event.data);
            this.title.text = "" + this.clickServerIndex;
        });
    }
    onSelectServer() {
        let selItem = this.voServer.serverMap.get(this.clickAreaIndex + 1)[this.clickServerIndex];
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).broadcast(UIMessage_1.UIMessage.MSG_SELECT_SERVER, selItem);
        this.close();
    }
    onOpen(vo) {
        super.onOpen(vo);
        this.voServer = vo;
        this.areaList.SetVirtual();
        this.areaList.itemRenderer = (index, obj) => {
            this.renderAreaListItem(index, obj);
        };
        this.areaList.numItems = vo.areaMap.size;
        this.serverList.SetVirtual();
        this.serverList.itemRenderer = (index, obj) => {
            this.renderServerListItem(index, obj);
        };
        this.serverList.numItems = vo.serverMap.get(this.clickAreaIndex + 1).length;
    }
    renderAreaListItem(index, obj) {
        let areaBtn = obj.asButton;
        areaBtn.text = this.voServer.areaMap.get(index + 1);
    }
    renderServerListItem(index, obj) {
        let serverBtn = obj.asButton;
        serverBtn.text = this.voServer.serverMap.get(this.clickAreaIndex + 1)[index].serverName;
        //serverBtn.icon = FairyGUI.UIPackage.
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    NiceDecorator_1.binder("areaList")
], UISelServerWin.prototype, "areaList", void 0);
__decorate([
    NiceDecorator_1.binder("serverList")
], UISelServerWin.prototype, "serverList", void 0);
__decorate([
    NiceDecorator_1.binder("backBtn")
], UISelServerWin.prototype, "backBtn", void 0);
__decorate([
    NiceDecorator_1.binder("okBtn")
], UISelServerWin.prototype, "okBtn", void 0);
__decorate([
    NiceDecorator_1.binder("title")
], UISelServerWin.prototype, "title", void 0);
exports.UISelServerWin = UISelServerWin;


/***/ }),

/***/ "./src/game/module/login/vo/VoServer.ts":
/*!**********************************************!*\
  !*** ./src/game/module/login/vo/VoServer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VoServer = exports.VoServerItem = void 0;
class VoServerItem {
}
exports.VoServerItem = VoServerItem;
class VoServer {
    constructor() {
        this.serverMap = new Map();
        this.areaMap = new Map();
    }
}
exports.VoServer = VoServer;


/***/ }),

/***/ "./src/game/module/pve/scene/PveScene.ts":
/*!***********************************************!*\
  !*** ./src/game/module/pve/scene/PveScene.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PveScene = void 0;
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
class PveScene extends BaseScene_1.BaseScene {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
    }
    onLeave() {
    }
}
exports.PveScene = PveScene;


/***/ }),

/***/ "./src/game/module/story/UIStoryWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/story/UIStoryWin.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIStoryWin = void 0;
const story_1 = __webpack_require__(/*! ../../../data/ui/story */ "./src/data/ui/story.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const StoryManager_1 = __webpack_require__(/*! ../../../framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
const StoryMessageManager_1 = __webpack_require__(/*! ../../../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
const UIManager_1 = __webpack_require__(/*! ../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const UIWindow_1 = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
class UIStoryWin extends UIWindow_1.UIWindow {
    constructor() {
        super(...arguments);
        this.shouldContineStory = false;
        this.optionsMap = new Map();
    }
    onAwake() {
        super.onAwake();
        this.m_btnList.itemRenderer = (index, obj) => {
            this.renderBtnList(index, obj);
        };
        this.m_btnList.onClickItem.Add((event) => {
            let clickId = this.m_btnList.GetChildIndex(event.data);
            if (this.shouldContineStory) {
                StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).advanceStory();
            }
            else {
                this.optionsMap.clear();
                StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).selectChoice(this.allChoices[clickId]);
            }
        });
    }
    onOpen(vo) {
        super.onOpen(vo);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, this, this.OnContentReady);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this, this.OnChoicesPresented);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED, this, this.OnStoryFinished);
        this.optionsMap.clear();
        this.shouldContineStory = false;
        StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).beginStory("story2");
    }
    OnContentReady(speakerContent, speakerId, currentTags, currentChoices) {
        this.m_speakerTxt.text = speakerContent;
        if (StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).canContinue) {
            this.shouldContineStory = true;
            this.m_btnList.numItems = 1;
        }
        if (currentChoices.length > 0) {
            this.allChoices = currentChoices;
            this.shouldContineStory = false;
            let len = currentChoices.length;
            for (let i = 0; i < len; i++) {
                this.optionsMap.set(i, currentChoices[i].text);
            }
            this.m_btnList.numItems = len;
        }
    }
    renderBtnList(index, obj) {
        let continueBtn = obj.asButton;
        if (this.optionsMap.size > 0) {
            continueBtn.text = this.optionsMap.get(index);
        }
        else {
            continueBtn.text = "";
        }
    }
    OnChoicesPresented(currentChoices) {
        this.shouldContineStory = false;
        console.log("....OnChoicesPresented......");
    }
    OnStoryFinished() {
        console.log("Story Finished");
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).closeWindow(story_1.storyUI.UIStoryWin, null);
    }
    onClose(arg) {
        super.onClose(arg);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, this.OnContentReady);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this.OnChoicesPresented);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED, this.OnStoryFinished);
    }
}
__decorate([
    NiceDecorator_1.binder("speakerTxt")
], UIStoryWin.prototype, "m_speakerTxt", void 0);
__decorate([
    NiceDecorator_1.binder("btnList")
], UIStoryWin.prototype, "m_btnList", void 0);
exports.UIStoryWin = UIStoryWin;


/***/ }),

/***/ "./src/global/GameConfig.ts":
/*!**********************************!*\
  !*** ./src/global/GameConfig.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameConfig = void 0;
class GameConfig {
}
exports.GameConfig = GameConfig;
GameConfig.debug = true;
GameConfig.realmServerIP = "127.0.0.1";
GameConfig.realmServerPort = 9001;


/***/ }),

/***/ "./src/unittest/SingletonTest.ts":
/*!***************************************!*\
  !*** ./src/unittest/SingletonTest.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SingletonTest = void 0;
const Singleton_1 = __webpack_require__(/*! ../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class SingletonTest extends Singleton_1.Singleton {
    constructor() {
        super();
        this.num = 0;
        console.log("SingletonTest call constructor");
    }
    add() {
        this.num += 1;
    }
    test() {
        return this.num;
    }
}
exports.SingletonTest = SingletonTest;


/***/ }),

/***/ "./src/unittest/UnitTest.ts":
/*!**********************************!*\
  !*** ./src/unittest/UnitTest.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitTest = void 0;
const TimeUtil_1 = __webpack_require__(/*! ../framework/util/TimeUtil */ "./src/framework/util/TimeUtil.ts");
const SingletonTest_1 = __webpack_require__(/*! ./SingletonTest */ "./src/unittest/SingletonTest.ts");
const Messenger_1 = __webpack_require__(/*! ../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
const ResManager_1 = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
const SkillConfig_1 = __webpack_require__(/*! ../data/excel/SkillConfig */ "./src/data/excel/SkillConfig.ts");
const RedHintsMessageManager_1 = __webpack_require__(/*! ../framework/redhints/RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");
const RedHintsManager_1 = __webpack_require__(/*! ../framework/redhints/RedHintsManager */ "./src/framework/redhints/RedHintsManager.ts");
const inkjs_1 = __webpack_require__(/*! inkjs */ "./node_modules/inkjs/dist/ink-es2015.js");
const pb_1 = __webpack_require__(/*! ../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
class UnitTest {
    static async doTest() {
        console.log("TimeUtil =============================");
        TimeUtil_1.TimeUtil.test();
        console.log("Singleton =============================");
        SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        console.log("===");
        let t1 = SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        let t2 = SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        console.log(t1.test() + " : " + t2.test());
        t1.add();
        console.log(t1.test() + " : " + t2.test());
        t2.add();
        console.log(t1.test() + " : " + t2.test());
        console.log("Messager =============================");
        let messenger = new Messenger_1.Messenger();
        let listen = function (a, b) {
            console.log(`listen call: ${a} , ${b}`);
        };
        let listen2 = function (a, b) {
            console.log(`listen call2: ${a} , ${b}`);
        };
        let EVENT_CODE = 100;
        messenger.addListener(EVENT_CODE, this, listen);
        messenger.addListener(EVENT_CODE, this, listen2);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.removeListener(EVENT_CODE, listen);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.clearup();
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        console.log("Timer =============================");
        let interval = setInterval(() => {
            console.log("inter val..");
        }, 1000);
        let timeout = setTimeout(() => {
            clearInterval(interval);
        }, 5000);
        console.log("ResourceManager =============================");
        let prefab = await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadPrefab("Models/1001/Character.prefab");
        console.log(prefab);
        //let inst = CS.UnityEngine.GameObject.Instantiate(prefab);
        //inst.name = "Test Ch";
        console.log(" =============================");
        let testMap = new Map();
        testMap.set("key1", new Array());
        let arr1 = testMap.get("key1");
        arr1.push(12);
        arr1.push(333);
        let arr2 = testMap.get("key1");
        console.log(arr2);
        // Logger.log("FariyGUI =============================");
        //  let page:UI_LoginPage = new UI_LoginPage();
        //  CS.FairyGUI.GRoot.inst.AddChild(page._ui);
        //  Logger.log(page._ui);
        // Logger.log("ModuleManager =============================");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.LoginModule,"create login");
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.LoginModule, "test1",2233);
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.HomeModule, "test2",2233);
        // Logger.log("then create Home");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.HomeModule,"create login");
        console.log("UIManager =============================");
        console.log("excel data =============================");
        let skillMap = SkillConfig_1.SkillConfigTB.Instance(SkillConfig_1.SkillConfigTB).trs;
        let skilltr = skillMap.get(1003);
        console.log(`${skilltr._Name} : ${skilltr._AttackType}`);
        let impacttype = skilltr._ImpactType;
        console.log(impacttype);
        console.log("Protobuf =============================");
        try {
            let c2rLogin = {
                "Account": "test",
                "Password": "1234"
            };
            //
            let v1 = pb_1.nice_ts.C2R_Login.verify(c2rLogin);
            console.log("verify pb: " + v1);
            let msg = pb_1.nice_ts.C2R_Login.create(c2rLogin);
            msg.Account = "test1";
            msg.Password = "1122";
            console.log(msg);
            let buf = pb_1.nice_ts.C2R_Login.encode(msg).finish();
            console.log(buf);
            let de_buf = pb_1.nice_ts.C2R_Login.decode(buf);
            console.log(de_buf.Account);
            console.log(de_buf.Password);
        }
        catch (ex) {
            console.log(ex);
        }
        console.log("UintArray =============================");
        let opcode_arr = new Uint8Array([257, 25]);
        console.log(opcode_arr.subarray(0, 1));
        console.log(opcode_arr.length);
        let opcode_arr2 = new Uint8Array([33]);
        // Uint8Array
        let merge_arr = new Uint8Array(opcode_arr.length + opcode_arr2.length);
        merge_arr.set(opcode_arr2);
        merge_arr.set(opcode_arr, opcode_arr2.length);
        console.log(merge_arr.length);
        let n = 5678;
        let buffer = new Uint8Array(4);
        // <<   >>   >>> 
        //nuint8Array
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        //unit8Arrayn
        n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        console.log(n);
        n = 300;
        let buffer1 = new Uint8Array(2);
        buffer1[0] = n >>> 8;
        buffer1[1] = n & 0xff;
        console.log(buffer1);
        n = buffer1[0] << 8 | buffer1[1];
        console.log(n);
        console.log("sleep =============================");
        await TimeUtil_1.TimeUtil.sleep(1000);
        console.log("sleep ..end");
        // console.log("flatbuffer =============================");
        // try{
        //     let bytes:ArrayBuffer = await ResManager.Instance(ResManager).loadTextBytes("Config/fb/unitconfig.bytes")
        //     let unitByte = new flatbuffers.ByteBuffer(new Uint8Array(bytes));
        //     console.log(unitByte);
        //     let unitconfig:fb.unitconfigTB = fb.unitconfigTB.getRootAsunitconfigTB(unitByte)
        //     console.log(unitconfig.unitconfigTRSLength());
        //     for(let i=0; i<unitconfig.unitconfigTRSLength(); i++){
        //         let a =  unitconfig.unitconfigTRS(i);
        //         console.log(a.Name());
        //     }
        // }catch(ex){
        //     console.error(ex);
        // }
        try {
            console.log(" =============================");
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat, this, function () {
                console.log("red hints chat...");
            });
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat_family, this, function () {
                console.log("red hints chat_family...");
            });
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat_system, this, function () {
                console.log("red hints chat...");
            });
            RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).setRedHintOpenOrClose(RedHintsManager_1.enumRedHints.chat_family, true);
            let r_chat = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat);
            let r_chat_family = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat_family);
            let r_chat_system = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat_system);
            console.log(r_chat, r_chat_family, r_chat_system);
        }
        catch (error) {
            console.log(error);
        }
        try {
            console.log("Ink Story =============================");
            var json = await (await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadTextAsset("Story/TestStory.json")).text;
            let story = new inkjs_1.Story(json);
            story.ChoosePathString("story1", true);
            story.BindExternalFunction("GetCharacterName", () => {
                return "Justin Test";
            });
            story.BindExternalFunctionGeneral("GetCharacterNameByMutiParams", (args) => {
                console.log(args.length);
                return "TTTT";
            });
            console.log(story.Continue());
            console.log(story.Continue());
            console.log(story.Continue());
        }
        catch (error) {
            console.log(error);
        }
    }
}
exports.UnitTest = UnitTest;
UnitTest.testVar = 10000;


/***/ }),

/***/ "csharp":
/*!*************************!*\
  !*** external "csharp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("csharp");

/***/ }),

/***/ "puerts":
/*!*************************!*\
  !*** external "puerts" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("puerts");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9kaXN0L2luay1lczIwMTUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DYWxsU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRyb2xDb21tYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvRGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9EaXZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9HbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvSW5rTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0pzb25TZXJpYWxpc2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTGlzdERlZmluaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9MaXN0RGVmaW5pdGlvbnNPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OYXRpdmVGdW5jdGlvbkNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OdWxsRXhjZXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUFJORy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Qb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUHVzaFBvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NlYXJjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NpbXBsZUpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdGF0ZVBhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcFdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdG9yeUV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3J5U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdHJpbmdCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHJ5R2V0UmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHlwZUFzc2VydGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVBc3NpZ25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVSZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9WYXJpYWJsZXNTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2FtZU1haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjZWwvU2tpbGxDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvcGIvT3Bjb2RlLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3BiL2dlbi9wYi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9jb21tb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvaG9tZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9sb2dpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9zdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9HYW1lT2JqZWN0UG9vbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtTdGF0ZUluc3BlY3Rvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtXcml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvU3RvcnlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL1N0b3J5TWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvR2FtZVNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvTWVzc2FnZVBhcnNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9OZXRFcnJvckNvZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvU2Vzc2lvbk1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01lc3NhZ2VNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWYudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSURlZmluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJRmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTG9hZGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTXNnQm94LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYW5lbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJV2luZG93LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdXRpbC9UaW1lVXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9hcGkvTG9naW5BUEkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvZXZlbnQvVUlNZXNzYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvc2NlbmUvSG9tZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3VpL1VJSG9tZVBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlTaG9wUGFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS92by9Wb0hvbWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3NjZW5lL0xvZ2luU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJTG9naW5QYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlbFNlcnZlcldpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vdm8vVm9TZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL3B2ZS9zY2VuZS9QdmVTY2VuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvc3RvcnkvVUlTdG9yeVdpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2xvYmFsL0dhbWVDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VuaXR0ZXN0L1NpbmdsZXRvblRlc3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VuaXR0ZXN0L1VuaXRUZXN0LnRzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNzaGFycFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInB1ZXJ0c1wiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRmE7QUFDYjs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNB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QUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5VWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFR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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDbkQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQy9jYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNkRBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyxpRUFBZTtBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDekQsNkJBQTZCLG1CQUFPLENBQUMsK0VBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLCtFQUFzQjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGlEQUFPO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMscUZBQXlCO0FBQ2pFLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQW1EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBOEQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkM7Ozs7Ozs7Ozs7OztBQzdrQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDaEVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOzs7Ozs7Ozs7Ozs7QUNyRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7Ozs7Ozs7OztBQ3phYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQ3pCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBLG9EQUFvRCxrQ0FBa0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDOzs7Ozs7Ozs7Ozs7QUNoS2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7Ozs7OztBQ25CYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQ0FBMkM7QUFDbEU7QUFDQTtBQUNBLGlDQUFpQyxxQ0FBcUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU87QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDJDQUEyQztBQUM1QyxnQzs7Ozs7Ozs7Ozs7O0FDdk1hO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDeERhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakUsbUM7Ozs7Ozs7Ozs7OztBQ1RhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyw2REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxLQUFLLEVBQUU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVELENBQUMsNkRBQTZEO0FBQzlELHNDOzs7Ozs7Ozs7Ozs7QUM5V2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRCxpQzs7Ozs7Ozs7Ozs7O0FDL1VhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDaEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELDRCQUE0QixtQkFBTyxDQUFDLDZFQUFxQjtBQUN6RCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsbUVBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7Ozs7OztBQ2hYYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7Ozs7O0FDUEE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFEQUFxRCxjQUFjOztBQUVuRTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsOENBQThDO0FBQy9FLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsOENBQThDO0FBQy9FLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7Ozs7QUMxWmE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx5REFBVTtBQUMvQjs7QUFFQSxXQUFXLG1CQUFPLENBQUMscUVBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ2xEYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3REO0FBQ0EsVUFBVTtBQUNWLFdBQVcsbUNBQW1DLFlBQVksR0FBRztBQUM3RCxXQUFXLFdBQVc7QUFDdEIsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjs7QUFFQSxjQUFjLG1CQUFPLENBQUMsbUVBQWU7Ozs7Ozs7Ozs7Ozs7QUNuQ3hCO0FBQ2I7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHNFQUFpQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxzQ0FBc0M7QUFDL0U7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7O0FBRUE7QUFDQSwrQkFBK0Isa0JBQWtCLGdCQUFnQixxQkFBcUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsZ0NBQWdDO0FBQzNDLGFBQWEsdUJBQXVCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMscUJBQXFCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRSxXQUFXLG9DQUFvQztBQUMvQyxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGdDQUFnQztBQUMzQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0Isa0NBQWtDLEVBQUU7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtCQUErQixlQUFlLEVBQUU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0lhO0FBQ2I7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLHNFQUFpQjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSw0QkFBNEIsVUFBVTtBQUN0Qyw0Q0FBNEMsYUFBYTtBQUN6RCwwQkFBMEIsVUFBVTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZNQSw4Q0FBYTtBQUNiOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsNEVBQXVCOztBQUVoRDtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxzRUFBb0I7O0FBRTFDO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsa0ZBQTBCOztBQUV0RDtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRUFBbUI7O0FBRXhDO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHdFQUFxQjs7QUFFNUM7QUFDQSxZQUFZLG1CQUFPLENBQUMsa0VBQWtCOztBQUV0QztBQUNBLFlBQVksbUJBQU8sQ0FBQyxrRUFBa0I7O0FBRXRDO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVk7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9GQUFvRjs7QUFFcEY7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsbURBQW1ELGtDQUFrQzs7QUFFckY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrQ0FBa0MsRUFBRTs7QUFFcEM7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixXQUFXLGtCQUFrQjtBQUM3QixXQUFXLFFBQVE7QUFDbkIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxvQ0FBb0M7QUFDcEMsNENBQTRDLGlCQUFpQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0RBQWdELGtCQUFrQixnQkFBZ0IsRUFBRSxFQUFFOztBQUV0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQ0FBaUM7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwREFBMEQsa0JBQWtCLGFBQWEsRUFBRSxFQUFFOztBQUU3RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQSxVQUFVO0FBQ1YsYUFBYSxpQkFBaUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQzs7QUFFQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLCtEQUErRCxRQUFRO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLFVBQVU7QUFDVixXQUFXLGlCQUFpQjtBQUM1QixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFlBQVk7QUFDekI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BhYTtBQUNiOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLHFFQUFnQjs7QUFFeEMsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CLElBQUksbUJBQW1CLDBDQUEwQztBQUNsRztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdDQUFnQztBQUMzQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxPQUFPO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsT0FBTztBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUIsYUFBYSxPQUFPO0FBQ3BCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCLGFBQWEsT0FBTztBQUNwQixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixhQUFhLE9BQU87QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QixLQUFLLDJCQUEyQjtBQUNyRSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoZGE7QUFDYjs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx5REFBVTtBQUMvQjs7QUFFQSxXQUFXLG1CQUFPLENBQUMscUVBQWdCOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7O0FBRUE7Ozs7Ozs7Ozs7OztBQ3BGQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7OztBQ2xCQSxnR0FBNkM7QUFDN0Msa0lBQW1FO0FBQ25FLDJHQUFxRDtBQUNyRCxzSEFBMkQ7QUFFM0QsNkRBQXVEO0FBQ3ZELDhHQUFzRDtBQUN0RCwwSEFBOEQ7QUFDOUQsc0hBQTREO0FBSTVELE1BQU0sUUFBUTtJQUVWO1FBQ0ksa0JBQVMsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDeEUsa0JBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxHQUFHLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUM1RCxDQUFDO0lBRU0sS0FBSyxDQUFDLEtBQUs7UUFFZCxJQUFHO1lBQ0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBRXBDLE1BQU07WUFDTiwrQkFBYyxDQUFDLFFBQVEsQ0FBQywrQkFBYyxDQUFDLENBQUM7WUFFeEMscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDO1lBQzlCLHVCQUFVLENBQUMsUUFBUSxDQUFDLHVCQUFVLENBQUMsQ0FBQztZQUNoQywyQkFBWSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7WUFHakQsWUFBWTtZQUNaLHNDQUFzQztZQUV0QyxjQUFjO1lBQ2QsbUJBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUVsQixRQUFRO1lBQ1IsMkJBQVksQ0FBQyxRQUFRLENBQUMsMkJBQVksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxtQkFBUSxDQUFDLFVBQVUsRUFBQyxHQUFFLEVBQUUsR0FBQyxDQUFDLENBQUMsQ0FBQztZQUcxRSxjQUFjO1lBQ2QsbUJBQVUsQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7U0FFeEM7UUFBQSxPQUFNLEVBQUUsRUFBQztZQUNOLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDckI7SUFFTCxDQUFDO0lBRU0saUJBQWlCO1FBRXBCLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTSxTQUFTO1FBRVosT0FBTyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBQzVDLENBQUM7Q0FFSjtBQUVELElBQUksUUFBUSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqRXZCLHVIQUE2RDtBQUM3RCxNQUFhLGFBQWE7SUFxQnpCLFlBQVksR0FBVSxFQUFFLEtBQVksRUFBRSxZQUFtQixFQUFFLFNBQWdCLEVBQUUsT0FBYyxFQUFFLGVBQXNCLEVBQUUsWUFBbUIsRUFBRSxpQkFBK0IsRUFBRSxXQUF5QixFQUFFLGNBQXFCLEVBQUUsU0FBZ0IsRUFBRSxhQUFvQixFQUFFLFlBQW1CLEVBQUUsWUFBbUIsRUFBRSxjQUFxQixFQUFFLFlBQW1CLEVBQUUsTUFBYSxFQUFFLFdBQWtCLEVBQUUsYUFBb0I7UUFDalosSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDZixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUMzQixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztRQUN2QyxJQUFJLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUNqQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7UUFDM0MsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDckMsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLGNBQWMsR0FBRyxjQUFjLENBQUM7UUFDckMsSUFBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7UUFDL0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7SUFFcEMsQ0FBQztDQUNEO0FBM0NELHNDQTJDQztBQUVELE1BQWEsYUFBYyxTQUFRLHFCQUF3QjtJQUUxRDtRQUNDLEtBQUssRUFBRSxDQUFDO1FBRkYsUUFBRyxHQUE4QixJQUFJLEdBQUcsRUFBeUIsQ0FBQztRQUd4RSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLDBDQUEwQyxFQUFFLFFBQVEsRUFBRSwwQ0FBMEMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDek8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksYUFBYSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSwwQ0FBMEMsRUFBRSxRQUFRLEVBQUUsMENBQTBDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hPLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLGFBQWEsQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsMENBQTBDLEVBQUUsUUFBUSxFQUFFLDBDQUEwQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4TyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxhQUFhLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLDBDQUEwQyxFQUFFLFFBQVEsRUFBRSwwQ0FBMEMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDek8sQ0FBQztDQUNGO0FBVEQsc0NBU0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2REQsNEVBQW1DO0FBQ25DLE1BQWEsU0FBUztDQUdyQjtBQUhELDhCQUdDO0FBQ0QsTUFBYSxNQUFNO0lBa0JYLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBYSxFQUFFLEdBQWM7UUFDakQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNuQyxJQUFJLFNBQVMsR0FBRyxJQUFJLFNBQVMsRUFBRSxDQUFDO1FBQ2hDLFNBQVMsQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUMvQixTQUFTLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUMxQixPQUFPLFNBQVMsQ0FBQztJQUNsQixDQUFDOztBQXhCRix3QkF5QkM7QUF4QmMsb0JBQWEsR0FBVSxJQUFJLENBQUM7QUFDNUIsb0JBQWEsR0FBVSxJQUFJLENBQUM7QUFDNUIsd0JBQWlCLEdBQVUsSUFBSSxDQUFDO0FBQ2hDLHdCQUFpQixHQUFVLElBQUksQ0FBQztBQUVoQyxvQkFBYSxHQUFVLElBQUksQ0FBQztBQUM1QixvQkFBYSxHQUFVLElBQUksQ0FBQztBQUU1QixVQUFHLEdBQUc7SUFDbkIsSUFBSSxFQUFHLFlBQU8sQ0FBQyxTQUFTLENBQUMsTUFBTTtJQUMvQixJQUFJLEVBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNO0lBQy9CLElBQUksRUFBRyxZQUFPLENBQUMsYUFBYSxDQUFDLE1BQU07SUFDbkMsSUFBSSxFQUFHLFlBQU8sQ0FBQyxhQUFhLENBQUMsTUFBTTtJQUVuQyxJQUFJLEVBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNO0lBQy9CLElBQUksRUFBRyxZQUFPLENBQUMsU0FBUyxDQUFDLE1BQU07Q0FDL0I7Ozs7Ozs7Ozs7Ozs7QUN0QkY7QUFDYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBb0I7O0FBRTVDO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLDZDQUFNO0FBQ3pCO0FBQ0E7OztBQUdBO0FBQ0EsMEVBQTBFOztBQUUxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxzQkFBc0IsWUFBWTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxzQ0FBc0M7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxtQkFBbUIsaUJBQWlCO0FBQ3BDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRkFBMkYsc0NBQXNDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLGlCQUFpQjtBQUNwQyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixrQkFBa0I7QUFDdkMsb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MscUJBQXFCLGtCQUFrQjtBQUN2QyxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEMsc0JBQXNCLFlBQVk7QUFDbEMsc0JBQXNCLFlBQVk7QUFDbEMsc0JBQXNCLGlCQUFpQjtBQUN2QyxzQkFBc0IsaUJBQWlCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLHNDQUFzQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixpQkFBaUI7QUFDcEMscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixzQ0FBc0M7QUFDakk7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxtQkFBbUIsaUJBQWlCO0FBQ3BDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLGtCQUFrQjtBQUN2QyxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSwrREFBK0QsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2RUFBNkUsMENBQTBDO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsbUJBQW1CLGlCQUFpQjtBQUNwQyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0ZBQStGLDBDQUEwQztBQUN6STtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixpQkFBaUI7QUFDcEMscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxtQkFBbUIsT0FBTztBQUMxQixxQkFBcUIsc0JBQXNCO0FBQzNDLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLHFCQUFxQixzQkFBc0I7QUFDM0Msb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekMsbUJBQW1CLDZCQUE2QjtBQUNoRCxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHNCQUFzQixZQUFZO0FBQ2xDLHNCQUFzQixpQkFBaUI7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSwrREFBK0QsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQyxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFLDBDQUEwQztBQUN2SDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixpQkFBaUI7QUFDcEMscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrRkFBK0YsMENBQTBDO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUMsbUJBQW1CLGlCQUFpQjtBQUNwQyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQixzQkFBc0I7QUFDM0Msb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLDZCQUE2QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MscUJBQXFCLHNCQUFzQjtBQUMzQyxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLHNCQUFzQixZQUFZO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLHNDQUFzQztBQUMvRztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDLG1CQUFtQixpQkFBaUI7QUFDcEMscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixzQ0FBc0M7QUFDakk7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxtQkFBbUIsaUJBQWlCO0FBQ3BDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLGtCQUFrQjtBQUN2QyxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsbUJBQW1CLDZCQUE2QjtBQUNoRCxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxzQkFBc0IsWUFBWTtBQUNsQyxzQkFBc0IsWUFBWTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsc0NBQXNDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEMsbUJBQW1CLGlCQUFpQjtBQUNwQyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixzQ0FBc0M7QUFDakk7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QyxtQkFBbUIsaUJBQWlCO0FBQ3BDLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0MsbUJBQW1CLE9BQU87QUFDMUIscUJBQXFCLGtCQUFrQjtBQUN2QyxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQiw2QkFBNkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQyxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQiw2QkFBNkI7QUFDaEQscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDs7Ozs7Ozs7Ozs7Ozs7QUM1N0NBLHNGQUFzRjs7O0FBRXRGLE1BQWEsUUFBUTs7QUFBckIsNEJBTUM7QUFKaUIsb0JBQVcsR0FBVSxRQUFRLENBQUM7QUFDOUIscUJBQVksR0FBVSxrQkFBa0IsQ0FBQztBQUN6QyxzQkFBYSxHQUFVLGFBQWEsQ0FBQztBQUNyQyxzQkFBYSxHQUFVLGFBQWEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUNQdkQsc0ZBQXNGOzs7QUFFdEYsTUFBYSxNQUFNOztBQUFuQix3QkFPQztBQUxpQixrQkFBVyxHQUFVLE1BQU0sQ0FBQztBQUM1QixtQkFBWSxHQUFVLGdCQUFnQixDQUFDO0FBQ3ZDLGlCQUFVLEdBQVUsVUFBVSxDQUFDO0FBQy9CLGtCQUFXLEdBQVUsV0FBVyxDQUFDO0FBQ2pDLGlCQUFVLEdBQVUsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQ1JqRCxzRkFBc0Y7OztBQUV0RixNQUFhLE9BQU87O0FBQXBCLDBCQU9DO0FBTGlCLG1CQUFXLEdBQVUsT0FBTyxDQUFDO0FBQzdCLG9CQUFZLEdBQVUsaUJBQWlCLENBQUM7QUFDeEMsbUJBQVcsR0FBVSxXQUFXLENBQUM7QUFDakMsc0JBQWMsR0FBVSxjQUFjLENBQUM7QUFDdkMsa0JBQVUsR0FBVSxVQUFVLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDUmpELHNGQUFzRjs7O0FBRXRGLE1BQWEsT0FBTzs7QUFBcEIsMEJBS0M7QUFIaUIsbUJBQVcsR0FBVSxPQUFPLENBQUM7QUFDN0Isb0JBQVksR0FBVSxpQkFBaUIsQ0FBQztBQUN4QyxrQkFBVSxHQUFVLFVBQVUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0xqRCxrR0FBd0M7QUFDeEMscUdBQTBDO0FBQzFDLDZEQUFxQztBQUlyQyxtQkFBbUI7QUFDbkIsU0FBUztBQUNULHdEQUF3RDtBQUN4RCxrRUFBa0U7QUFDbEUsTUFBYSxjQUFlLFNBQVEscUJBQXlCO0lBT3pEO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFOSixxQkFBZ0IsR0FBRyxJQUFJLENBQUM7UUFDeEIsYUFBUSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDckIsZ0JBQVcsR0FBMEIsSUFBSSxHQUFHLEVBQXFCLENBQUM7UUFNdEUsSUFBSSxFQUFFLEdBQUcsb0JBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFFNUQsSUFBRyxFQUFFLElBQUksU0FBUyxFQUFDO1lBQ2YsRUFBRSxHQUFHLElBQUksb0JBQVcsQ0FBQyxVQUFVLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUN2RCxvQkFBVyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM1QztRQUVELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDO0lBQ3pDLENBQUM7SUFFRCxjQUFjO0lBQ1AsY0FBYyxDQUFDLElBQVc7UUFFN0IsSUFBSSxVQUFVLEdBQWMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdkQsSUFBRyxVQUFVLElBQUksU0FBUyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO1lBQ2hELE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxPQUFPLFFBQVEsSUFBSSxTQUFTLENBQUM7SUFDakMsQ0FBQztJQUdELHFCQUFxQjtJQUNkLHNCQUFzQixDQUFDLElBQVcsRUFBRSxFQUFNLEVBQUUsYUFBb0IsQ0FBQztRQUVwRSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDNUIsSUFBRyxVQUFVLEdBQUcsQ0FBQyxFQUFDO1lBRWQsSUFBSSxVQUFVLEdBQWMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDdkQsS0FBSSxJQUFJLENBQUMsR0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsRUFBRSxDQUFDLEVBQUUsRUFBQztnQkFFckMsSUFBSSxJQUFJLEdBQUcsb0JBQVcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBMkIsQ0FBQztnQkFDNUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7Z0JBQ2hELElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBRXRCLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDekI7U0FDSjtJQUNMLENBQUM7SUFFRCxhQUFhO0lBQ04sZUFBZSxDQUFDLElBQVc7UUFFOUIsSUFBRyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0IsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUVELElBQUksVUFBVSxHQUFrQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzRCxJQUFHLFVBQVUsSUFBSSxTQUFTLElBQUksVUFBVSxDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUM7WUFFOUMsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzVCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFFRCxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN2QyxJQUFHLFFBQVEsSUFBSSxTQUFTLEVBQUM7WUFDckIsSUFBSSxJQUFJLEdBQUcsb0JBQVcsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hELE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBR0QsZ0JBQWdCO0lBQ1QsS0FBSyxDQUFDLHNCQUFzQixDQUFDLElBQVcsRUFBRSxVQUFpQixFQUFFLFFBQWlCLEVBQUMsR0FBRyxNQUFNO1FBRTNGLElBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBQztZQUN6QixJQUFHLFFBQVEsSUFBRSxJQUFJLEVBQUM7Z0JBQ2QsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3BCO1lBQ0QsT0FBTztTQUNWO1FBRUQsSUFBSSxFQUFFLEdBQUcsTUFBTSx1QkFBVSxDQUFDLFFBQVEsQ0FBQyx1QkFBVSxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2hFLElBQUcsRUFBRSxJQUFFLFNBQVMsRUFBQztZQUNiLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLEVBQUUsRUFBRSxFQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsSUFBRyxRQUFRLElBQUUsSUFBSSxFQUFDO1lBQ2QsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3BCO0lBQ0wsQ0FBQztJQUdELGVBQWU7SUFDUixLQUFLLENBQUMsa0JBQWtCLENBQUMsSUFBVyxFQUFFLFFBQWlCLEVBQUMsR0FBRyxNQUFNO1FBRXBFLElBQUksSUFBSSxHQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUMsSUFBRyxJQUFJLElBQUcsSUFBSSxFQUFDO1lBQ1gsTUFBTSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDaEU7UUFFRCxJQUFJLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBR3pCLENBQUM7SUFHRCxPQUFPO0lBQ0EsaUJBQWlCLENBQUMsSUFBVyxFQUFFLElBQVE7UUFFMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDaEQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV0QixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQzNELFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTNDLENBQUM7SUFHRCxTQUFTO0lBQ0YsT0FBTyxDQUFDLGtCQUEwQixLQUFLO1FBRTFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBQyxFQUFFO1lBRXBDLEtBQUksSUFBSSxJQUFJLElBQUksTUFBTSxFQUFDO2dCQUNuQixJQUFHLElBQUksSUFBSSxJQUFJLEVBQUM7b0JBQ1osb0JBQVcsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN4QzthQUNKO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBRXpCLElBQUcsZUFBZSxFQUFDO1lBQ2YsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUUsR0FBRyxFQUFDLEVBQUU7Z0JBRTdCLElBQUcsRUFBRSxJQUFJLElBQUksRUFBQztvQkFDVix1QkFBVSxDQUFDLFFBQVEsQ0FBQyx1QkFBVSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3hEO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ3pCO0lBRUwsQ0FBQztDQUdKO0FBdkpELHdDQXVKQzs7Ozs7Ozs7Ozs7Ozs7OztBQ2hLRCxNQUFhLE1BQU07Q0FHbEI7QUFIRCx3QkFHQztBQUdELE1BQWEsU0FBUztJQUlsQjtRQUZRLGdCQUFXLEdBQUcsSUFBSSxHQUFHLEVBQWlCLENBQUM7SUFJL0MsQ0FBQztJQUVNLFdBQVcsQ0FBQyxNQUFhLEVBQUUsS0FBUyxFQUFFLFNBQWtCO1FBRTNELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLElBQUcsT0FBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFdBQVcsRUFBQztZQUM3QixNQUFNLEdBQUcsSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUN0QixNQUFNLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztZQUNuQixNQUFNLENBQUMsU0FBUyxHQUFHLElBQUksS0FBSyxFQUFZLENBQUM7U0FDNUM7UUFDRCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUVqQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVNLFdBQVcsQ0FBQyxNQUFhO1FBQzVCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVNLFNBQVMsQ0FBQyxNQUFhLEVBQUUsR0FBRyxNQUFZO1FBRTNDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRTFDLElBQUcsT0FBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLFdBQVcsRUFBQztZQUM3QixLQUFJLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUM7Z0JBQzNCLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQzthQUU5QjtTQUNKO0lBRUwsQ0FBQztJQUdNLG9CQUFvQixDQUFDLE1BQWE7UUFFckMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUdNLGNBQWMsQ0FBQyxNQUFhLEVBQUUsVUFBbUI7UUFFcEQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFMUMsSUFBRyxPQUFNLENBQUMsTUFBTSxDQUFDLElBQUksV0FBVyxFQUFDO1lBRTdCLEtBQUksSUFBSSxDQUFDLEdBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRSxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztnQkFDakQsSUFBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLFVBQVUsRUFBQztvQkFDakMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNoQzthQUNKO1NBQ0o7SUFDTCxDQUFDO0lBRU0sT0FBTztRQUVWLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDN0IsQ0FBQztDQUVKO0FBakVELDhCQWlFQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RFRCxrQkFBa0I7QUFDbEIsU0FBZ0IsTUFBTSxDQUFDLElBQVc7SUFDOUIsT0FBTyxVQUFTLE1BQVUsRUFBRSxHQUFtQjtRQUMzQyxNQUFNLENBQUMsU0FBUyxDQUFDLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUM1QyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ2xDLENBQUM7QUFDTCxDQUFDO0FBTEQsd0JBS0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSRCxrR0FBd0M7QUFDeEMsNkRBQWtDO0FBQ2xDLDZEQUE4QjtBQUU5QixNQUFhLFVBQVcsU0FBUSxxQkFBcUI7SUFFakQ7UUFDSSxLQUFLLEVBQUUsQ0FBQztJQUNaLENBQUM7SUFFRCxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQWM7UUFFM0IsSUFBRztZQUNDLElBQUksSUFBSSxHQUFFLGVBQU0sQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3JELElBQUksRUFBRSxHQUFHLE1BQU0saUJBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBQUEsT0FBTSxFQUFFLEVBQUM7WUFFTixPQUFPLENBQUMsS0FBSyxDQUFDLGdCQUFnQixPQUFPLE1BQU0sRUFBRSxFQUFFLENBQUM7WUFFaEQsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUVMLENBQUM7SUFFRCxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQWM7UUFFOUIsSUFBRztZQUNDLElBQUksSUFBSSxHQUFHLGVBQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELElBQUksRUFBRSxHQUFHLE1BQU0saUJBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QixPQUFPLEVBQUUsQ0FBQztTQUNiO1FBQUEsT0FBTSxFQUFFLEVBQUM7WUFDTixPQUFPLENBQUMsS0FBSyxDQUFDLG1CQUFtQixPQUFPLE1BQU0sRUFBRSxFQUFFLENBQUM7WUFFbkQsT0FBTyxJQUFJLENBQUM7U0FDZjtJQUNMLENBQUM7SUFHRCxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQWM7UUFFOUIsSUFBRztZQUNDLElBQUksSUFBSSxHQUFHLGVBQU0sQ0FBQyxlQUFlLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pELElBQUksS0FBSyxHQUFHLE1BQU0saUJBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqQyxPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUFBLE9BQU0sRUFBRSxFQUFDO1lBQ04sT0FBTyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsT0FBTyxNQUFNLEVBQUUsRUFBRSxDQUFDO1NBQ3JEO0lBQ0wsQ0FBQztJQUVELEtBQUssQ0FBQyxVQUFVLENBQUMsT0FBYztRQUUzQixJQUFHO1lBQ0MsSUFBSSxJQUFJLEdBQUcsZUFBTSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdEQsSUFBSSxFQUFFLEdBQUcsTUFBTSxpQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlCLE9BQU8sRUFBRSxDQUFDO1NBRWI7UUFBQSxPQUFNLEVBQUUsRUFBQztZQUNOLE9BQU8sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLE9BQU8sTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUVoRCxPQUFPLElBQUksQ0FBQztTQUNmO0lBQ0wsQ0FBQztJQUVELEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxPQUFjLEVBQUUsV0FBa0IsRUFBRSxRQUFrQjtRQUU1RSxJQUFHO1lBQ0MsSUFBSSxJQUFJLEdBQUcsZUFBTSxDQUFDLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLEVBQUMsV0FBVyxDQUFDLENBQUM7WUFDM0UsTUFBTSxpQkFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRXJCLElBQUcsUUFBUTtnQkFBRSxRQUFRLEVBQUUsQ0FBQztTQUMzQjtRQUFBLE9BQU0sRUFBRSxFQUFDO1lBQ04sT0FBTyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsT0FBTyxNQUFNLEVBQUUsRUFBRSxDQUFDO1NBQ3JEO0lBQ0wsQ0FBQztJQUVNLGdCQUFnQixDQUFDLEVBQU07UUFFMUIsZUFBTSxDQUFDLGVBQWUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRU0sc0JBQXNCLENBQUMsV0FBVztRQUNyQyxlQUFNLENBQUMsZUFBZSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNELENBQUM7Q0FDSjtBQWhGRCxnQ0FnRkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuRkQsTUFBYSxTQUFTO0lBSVgsTUFBTSxDQUFDLFFBQVEsQ0FBSyxDQUFlO1FBRXRDLElBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLEVBQUM7WUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDO1NBQzNCO1FBRUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3pCLENBQUM7O0FBWEwsOEJBYUM7QUFYa0Isa0JBQVEsR0FBTyxJQUFJLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGdkMsTUFBYSxpQkFBaUI7SUFFbkIsY0FBYyxDQUFDLFFBQWM7UUFFaEMsWUFBWTtRQUNaLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUMsa0JBQWtCLEVBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDMUUsYUFBYTtRQUNiLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLEVBQUMsOEJBQThCLEVBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFFM0csQ0FBQztJQUVPLGdCQUFnQjtRQUNwQixPQUFPLG9CQUFvQixDQUFDO0lBQ2hDLENBQUM7SUFFTywwQkFBMEIsQ0FBQyxFQUFTLEVBQUMsRUFBUyxFQUFDLEVBQVM7UUFDNUQsT0FBTyxvQkFBb0IsQ0FBQztJQUNoQyxDQUFDO0lBR08saUJBQWlCLENBQUMsUUFBYyxFQUFDLFFBQWUsRUFBQyxJQUEyQjtRQUNoRixJQUFHO1lBQ0MsUUFBUSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNqRDtRQUFBLE9BQU0sR0FBRyxFQUFDO1lBQ1AsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNyQjtJQUVMLENBQUM7SUFFTyx3QkFBd0IsQ0FBQyxRQUFjLEVBQUUsUUFBZSxFQUFDLElBQTJCO1FBQ3hGLElBQUc7WUFDQyxRQUFRLENBQUMsMkJBQTJCLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3hEO1FBQUEsT0FBTSxHQUFHLEVBQUM7WUFDUCxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO0lBQ0wsQ0FBQztJQUVNLGVBQWUsQ0FBQyxRQUFjLEVBQUMsUUFBZTtRQUVqRCxJQUFHO1lBQ0MsUUFBUSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQzdDO1FBQUEsT0FBTSxHQUFHLEVBQUM7WUFDUCxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO0lBQ0wsQ0FBQztDQUNKO0FBN0NELDhDQTZDQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9DRCxzR0FBMkM7QUFDM0MsdUhBQXdEO0FBQ3hELDZIQUE0RDtBQUU1RCxNQUFhLFNBQVM7SUFXbEIsWUFBWSxTQUFnQjtRQUhwQixvQkFBZSxHQUF3QixJQUFJLEdBQUcsRUFBbUIsQ0FBQztRQUl0RSxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRU0sSUFBSTtRQUNQLElBQUksVUFBVSxHQUFVLEVBQUUsQ0FBQztRQUMzQixJQUFHLFVBQVUsSUFBRSxJQUFJLElBQUksVUFBVSxJQUFFLEVBQUUsRUFBQztZQUNsQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDakQ7SUFDTCxDQUFDO0lBRU8sV0FBVyxDQUFDLElBQVc7UUFDM0IsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGFBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUd6QyxDQUFDO0lBRU0sVUFBVSxDQUFDLFFBQWU7UUFDN0IsSUFBRyxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksRUFBQztZQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLG9FQUFvRSxDQUFDLENBQUM7WUFDbkYsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFbkQsSUFBSSxRQUFRLEdBQXFCLElBQUkscUNBQWlCLEVBQUUsQ0FBQztRQUN6RCxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU3QyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDeEIsQ0FBQztJQUdPLFVBQVU7UUFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFOUIsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVPLGdCQUFnQjtRQUNwQixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUMzRCxDQUFDO0lBRU8sYUFBYSxDQUFDLE9BQWMsRUFBRSxJQUFhO1FBQy9DLElBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUM7WUFDakMsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNsRDtRQUNELE9BQU8sQ0FBQyxLQUFLLENBQUMsc0NBQXNDLEdBQUMsT0FBTyxDQUFDLENBQUM7UUFDOUQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVPLGdCQUFnQixDQUFDLElBQVc7UUFDaEMsSUFBSSxHQUFHLEdBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDeEQsSUFBSSxJQUFJLEdBQVUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUM1RCxJQUFHLElBQUksSUFBSSxDQUFDLENBQUMsRUFBQztZQUNWLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQ3RCO1FBRUQsSUFBSSxNQUFNLEdBQVUsSUFBSSxHQUFHLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDbkUsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxTQUFTLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM3RSxDQUFDO0lBRU0sZ0JBQWdCLENBQUMsSUFBVztRQUMvQixJQUFJLEdBQUcsR0FBVSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1FBQzNELElBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxFQUFDO1lBQ1QsT0FBTyxFQUFFLENBQUM7U0FDYjtRQUNELElBQUksTUFBTSxHQUFVLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDNUMsSUFBSSxJQUFJLEdBQVksSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQztZQUMxQixJQUFJLEVBQUU7WUFDTixLQUFLLENBQUMsU0FBUyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUFDM0QsS0FBSyxJQUFJLENBQUMsR0FBUSxDQUFDLEVBQUUsQ0FBQyxHQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDckMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUM1QjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxjQUFjLENBQUMsSUFBVztRQUM3QixJQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFDO1lBQ3pDLE9BQU8sQ0FBQyxHQUFHLEVBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7U0FDNUI7UUFFRCxJQUFJLEtBQUssR0FBWSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUN2QyxJQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO1lBQ2hCLElBQUksT0FBTyxHQUFVLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNyQyxJQUFJLFlBQVksR0FBVSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFFMUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQztTQUNsQztRQUVELE9BQU8sQ0FBQyxHQUFHLEVBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVNLGdCQUFnQjtRQUNuQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNsRCxVQUFVO0lBQ2QsQ0FBQztJQUVNLFdBQVc7UUFDZCxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDO0lBQzFDLENBQUM7SUFFTSxZQUFZO1FBQ2YsSUFBRyxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksRUFBQztZQUMxQixPQUFPLENBQUMsSUFBSSxDQUFDLG9FQUFvRSxDQUFDLENBQUM7U0FDdEY7YUFDSSxJQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFDO1lBQ25DLElBQUksSUFBSSxHQUFVLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDdkQsSUFBRyxJQUFJLElBQUksRUFBRSxFQUFDO2dCQUNWLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztnQkFDcEIsT0FBTTthQUNUO1lBRUQsSUFBSSxPQUFjLENBQUM7WUFDbkIsSUFBSSxZQUFtQixDQUFDO1lBRXhCLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFcEQsSUFBSSxXQUFXLEdBQVUsSUFBSSxDQUFDO1lBQzlCLElBQUksSUFBSSxHQUFZLElBQUksQ0FBQztZQUN6QixJQUFHLFlBQVksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFDO2dCQUNqRCxXQUFXLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUNsRCxJQUFJLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDO2dCQUMzQyxJQUFHLFdBQVcsSUFBSSxJQUFJLElBQUksV0FBVyxJQUFHLEVBQUUsRUFBQztvQkFDdkMsSUFBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsRUFBQzt3QkFDckMsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO3FCQUN2QjtpQkFDSjthQUNKO2lCQUFJO2dCQUNELGdCQUFnQjtnQkFDaEIseUNBQW1CLENBQUMsUUFBUSxDQUFDLHlDQUFtQixDQUFDLENBQUMscUJBQXFCLENBQ25FLHlDQUFtQixDQUFDLGNBQWMsRUFDbEMsWUFBWSxFQUNaLE9BQU8sRUFDUCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFDOUIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQ3BDLENBQUM7YUFDTDtTQUNKO2FBQ0ksSUFBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFDO1lBQ2pELG9CQUFvQjtZQUNwQix5Q0FBbUIsQ0FBQyxRQUFRLENBQUMseUNBQW1CLENBQUMsQ0FBQyx5QkFBeUIsQ0FDdkUseUNBQW1CLENBQUMsa0JBQWtCLEVBQ3RDLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUNwQyxDQUFDO1NBQ0w7YUFBSTtZQUNELGlCQUFpQjtZQUNqQix5Q0FBbUIsQ0FBQyxRQUFRLENBQUMseUNBQW1CLENBQUMsQ0FBQyxzQkFBc0IsQ0FDcEUseUNBQW1CLENBQUMsZUFBZSxDQUN0QztTQUNKO0lBQ0wsQ0FBQztJQUVNLFlBQVksQ0FBQyxXQUFrQjtRQUNsQyxJQUFHLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxFQUFDO1lBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsNkRBQTZELENBQUMsQ0FBQztZQUM1RSxPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ2xELElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QixDQUFDO0lBRU0sV0FBVyxDQUFDLFlBQW1CO1FBQ2xDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDL0UsQ0FBQztJQUVNLFdBQVcsQ0FBQyxZQUFtQixFQUFFLEtBQVM7UUFDN0MsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM3RCxDQUFDOztBQXBMTCw4QkFxTEM7QUFuTGlCLHdCQUFjLEdBQVUsYUFBYSxDQUFDO0FBQ3RDLHdCQUFjLEdBQVUsS0FBSyxDQUFDO0FBQzlCLDJCQUFpQixHQUFVLEdBQUcsQ0FBQztBQUMvQiwrQkFBcUIsR0FBVSxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNSckQsNkdBQWtEO0FBQ2xELDBHQUFnRDtBQUNoRCwrRkFBd0M7QUFFeEMsTUFBYSxZQUFhLFNBQVEscUJBQXVCO0lBU3JEO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFQSixpQkFBWSxHQUFVLHNCQUFzQixDQUFDO0lBUXJELENBQUM7SUFORCxJQUFXLFNBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzNCLENBQUM7SUFNTSxLQUFLLENBQUMsVUFBVTtRQUVuQixJQUFHLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxFQUFDO1lBRXZCLElBQUksSUFBSSxHQUFJLENBQUMsTUFBTSx1QkFBVSxDQUFDLFFBQVEsQ0FBQyx1QkFBVSxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztZQUMxRixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUkscUJBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN6QztJQUVMLENBQUM7SUFFTSxVQUFVLENBQUMsUUFBZTtRQUM3QixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUN6QyxDQUFDO0lBRU0sV0FBVztRQUNkLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUM7SUFDdkMsQ0FBQztJQUVNLFlBQVk7UUFDZixJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFTSxZQUFZLENBQUMsTUFBYTtRQUM3QixJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVNLFdBQVc7UUFDZCxJQUFHLElBQUksQ0FBQyxVQUFVLElBQUUsSUFBSTtZQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDckQsQ0FBQztJQUVNLFdBQVcsQ0FBQyxZQUFtQjtRQUNsQyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFTSxXQUFXLENBQUMsWUFBbUIsRUFBRSxLQUFTO1FBQzdDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRCxDQUFDO0NBRUo7QUFuREQsb0NBbURDOzs7Ozs7Ozs7Ozs7Ozs7O0FDdkRELDBHQUFnRDtBQUNoRCwwR0FBZ0Q7QUFFaEQsTUFBYSxtQkFBb0IsU0FBUSxxQkFBOEI7SUFBdkU7O1FBTVksaUJBQVksR0FBYSxJQUFJLHFCQUFTLEVBQUUsQ0FBQztJQTBDckQsQ0FBQztJQXZDVSxXQUFXLENBQUMsT0FBYyxFQUFDLEdBQU8sRUFBRSxRQUFpQjtRQUV4RCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFTSxjQUFjLENBQUMsT0FBYyxFQUFFLFFBQWlCO1FBQ25ELElBQUksQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBRU0sb0JBQW9CLENBQUMsT0FBYztRQUN0QyxJQUFJLENBQUMsWUFBWSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTSxPQUFPO1FBQ1YsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRU0scUJBQXFCLENBQ3hCLE9BQWMsRUFDZCxjQUFxQixFQUNyQixTQUFnQixFQUNoQixXQUFvQixFQUNwQixjQUF1QjtRQUl2QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsY0FBYyxFQUFDLFNBQVMsRUFBQyxXQUFXLEVBQUMsY0FBYyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQUVNLHlCQUF5QixDQUM1QixRQUFlLEVBQ2YsY0FBdUI7UUFFdkIsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFTSxzQkFBc0IsQ0FBQyxRQUFlO1FBQ3pDLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzFDLENBQUM7O0FBL0NMLGtEQWdEQztBQTlDaUIsa0NBQWMsR0FBVSxJQUFJLENBQUM7QUFDN0Isc0NBQWtCLEdBQVUsSUFBSSxDQUFDO0FBQ2pDLG1DQUFlLEdBQVUsSUFBSSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDUmhELDBHQUFnRDtBQUNoRCw0RkFBOEM7QUFDOUMsd0dBQThDO0FBQzlDLDZEQUFnQztBQUNoQywyR0FBZ0Q7QUFHaEQsTUFBYSxPQUFPO0lBQXBCO1FBR1csZUFBVSxHQUFVLENBQUMsQ0FBQztJQUVqQyxDQUFDO0NBQUE7QUFMRCwwQkFLQztBQUVELE1BQWEsV0FBWSxTQUFRLHFCQUFzQjtJQWlCbkQ7UUFDSSxLQUFLLEVBQUUsQ0FBQztRQWhCTCxPQUFFLEdBQVUsQ0FBQyxDQUFDLENBQUUsWUFBWTtRQUMzQixtQkFBYyxHQUFVLEtBQUssQ0FBQyxDQUFDLFNBQVM7UUFDeEMsb0JBQWUsR0FBVSxJQUFJLENBQUMsQ0FBQyxZQUFZO1FBQzNDLG1CQUFjLEdBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUTtRQUduQyxXQUFNLEdBQVUsQ0FBQyxDQUFDO1FBRWxCLG9CQUFlLEdBQXVCLElBQUksR0FBRyxFQUFrQixDQUFDO1FBQ2hFLGNBQVMsR0FBd0IsSUFBSSxHQUFHLEVBQW1CLENBQUM7UUFFcEUsY0FBYztRQUNOLGNBQVMsR0FBVSxDQUFDLENBQUMsQ0FBQztRQUN0QixnQkFBVyxHQUFVLENBQUMsQ0FBQztJQUkvQixDQUFDO0lBRUQsSUFBVyxLQUFLO1FBQ1osT0FBTyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDekIsQ0FBQztJQUVELG1CQUFtQjtJQUNaLGNBQWMsQ0FBQyxPQUFjLEVBQUUsVUFBYztRQUVoRCxJQUFJLENBQUMsT0FBTyxHQUFHLGVBQU0sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRXJELElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxHQUFHLENBQUMsT0FBVyxFQUFFLElBQVcsRUFBQyxFQUFFO1lBQ3JELElBQUcsSUFBSSxJQUFJLDJCQUFZLENBQUMsa0JBQWtCLEVBQUM7Z0JBQ3ZDLElBQUksQ0FBQyxZQUFZLEdBQUcsV0FBVyxDQUFDLEdBQUUsRUFBRTtvQkFDaEMsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUMzQixDQUFDLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2FBQzVCO1lBRUQsVUFBVSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM5QixDQUFDLENBQUM7UUFFRixJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksR0FBRyxDQUFDLE1BQWlCLEVBQUMsRUFBRTtZQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzNCLENBQUMsQ0FBQztRQUVGLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTlCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxTQUFTO0lBQ0YsTUFBTSxDQUFDLE1BQWEsRUFBQyxRQUFpQjtRQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVELGNBQWM7SUFDZCw4REFBOEQ7SUFDdkQsSUFBSSxDQUFDLE1BQWEsRUFBQyxLQUFZLEVBQUUsT0FBa0IsRUFBRSxRQUFpQjtRQUV6RSxPQUFPO1FBQ1AsSUFBSSxNQUFNLEdBQWMsNkJBQWEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHO1FBQzNELElBQUksU0FBUyxHQUFjLDZCQUFhLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRztRQUNqRSxJQUFJLFdBQVcsR0FBYyw2QkFBYSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHO1FBQzNFLElBQUksYUFBYSxHQUFjLDZCQUFhLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFHOUUsSUFBSSxTQUFTLEdBQWMsSUFBSSxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUN6RSxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RCLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFLLENBQUMsQ0FBQyxDQUFDO1FBQy9CLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNuQyxTQUFTLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFRLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBRTVDLElBQUcsUUFBUSxJQUFJLElBQUksRUFBQztZQUNoQixJQUFJLE9BQU8sR0FBVyxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ3BDLE9BQU8sQ0FBQyxRQUFRLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN4QyxPQUFPLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUM1QixPQUFPLENBQUMsS0FBSyxHQUFHLFNBQVMsQ0FBQztZQUUxQixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDNUM7UUFDRCwyQkFBMkI7UUFDM0IsMkNBQTJDO1FBQzNDLElBQUk7UUFDSix3Q0FBd0M7UUFDeEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVPLE1BQU0sQ0FBQyxLQUFnQjtRQUMzQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRU0sU0FBUyxDQUFDLE1BQWlCO1FBRTlCLElBQUksTUFBTSxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXBDLElBQUksS0FBSyxHQUFHLDZCQUFhLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUQsSUFBSSxNQUFNLEdBQUcsNkJBQWEsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3RCxJQUFJLFFBQVEsR0FBRyw2QkFBYSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9ELElBQUksVUFBVSxHQUFHLDZCQUFhLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFaEUsSUFBSSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUM7UUFDMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUM7UUFFOUIsSUFBSSxRQUFRLEdBQWMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU3QyxJQUFHO1lBQ0MsSUFBSSxTQUFTLEdBQUksZUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFHakQsSUFBRyxLQUFLLElBQUUsU0FBUyxJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUM7Z0JBQ3BELGVBQWU7Z0JBQ2YsSUFBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBQztvQkFDMUIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7b0JBQ3hDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7aUJBQzVCO2FBRUo7aUJBQUk7Z0JBQ0QsSUFBSSxPQUFPLEdBQVcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ3RELE9BQU8sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUVuQyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUV0QztTQUNKO1FBQUEsT0FBTSxDQUFDLEVBQUM7WUFDTCxPQUFPLENBQUMsS0FBSyxDQUFDLDBCQUEwQixHQUFDLE1BQU0sQ0FBQztTQUNuRDtJQUdMLENBQUM7SUFFTyxlQUFlO1FBRW5CLElBQUksUUFBUSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFcEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFFeEMsSUFBRyxLQUFLLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3hDLGFBQWE7Z0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQ0FBbUMsR0FBRyxjQUFjLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNsRixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUNwQztpQkFBSTtnQkFFRCxJQUFHLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFDO29CQUNsRCxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7b0JBQ25CLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO29CQUMxQixNQUFNO29CQUNOLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLDJCQUEyQixHQUFHLGlCQUFpQixLQUFLLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQztpQkFDbEY7YUFDSjtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUdNLFVBQVU7UUFFYixhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRWpDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDM0IsQ0FBQztDQUNKO0FBaEtELGtDQWdLQzs7Ozs7Ozs7Ozs7Ozs7OztBQzdLRCxNQUFhLGFBQWE7SUFHZixNQUFNLENBQUMsU0FBUyxDQUFDLENBQVE7UUFFNUIsSUFBSSxNQUFNLEdBQWMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7UUFFckIsT0FBTyxNQUFNO0lBQ2pCLENBQUM7SUFFTSxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQWlCO1FBRXJDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV2RSxPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFHTSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQVE7UUFFOUIsSUFBSSxNQUFNLEdBQWdCLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3BCLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBRXJCLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFHTSxNQUFNLENBQUMsV0FBVyxDQUFDLE1BQWlCO1FBRXZDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRW5DLE9BQU8sQ0FBQyxDQUFDO0lBQ2IsQ0FBQztJQUdNLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBUTtRQUU3QixJQUFJLE1BQU0sR0FBZ0IsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDO1FBQzNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBRXJCLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFTSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQWlCO1FBRXRDLElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsQixPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7Q0FJSjtBQXpERCxzQ0F5REM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4REEsTUFBYSxZQUFZOztBQUF6QixvQ0FjQztBQVprQiwrQkFBa0IsR0FBVSxNQUFNLENBQUM7QUFFbkMsb0NBQXVCLEdBQVUsTUFBTSxDQUFDO0FBRXhDLCtCQUFrQixHQUFZLE1BQU0sQ0FBQztBQUNyQywrQkFBa0IsR0FBWSxNQUFNLENBQUM7QUFDckMsNEJBQWUsR0FBZSxNQUFNLENBQUM7QUFDckMsZ0NBQW1CLEdBQVcsTUFBTSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDVnpELHNHQUFxRDtBQUNyRCwwR0FBZ0Q7QUFDaEQscUdBQTRDO0FBQzVDLHdHQUE4QztBQUc5QyxNQUFhLGNBQWUsU0FBUSxxQkFBeUI7SUFNekQsSUFBVyxVQUFVO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7SUFDbEMsQ0FBQztJQUVELElBQVcsU0FBUztRQUNoQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO0lBQ2xDLENBQUM7SUFFTSxrQkFBa0IsQ0FBQyxNQUFlLEVBQUUsT0FBZ0I7UUFFdkQsT0FBTztRQUNQLElBQUksQ0FBQyxXQUFXLEdBQUcseUJBQVcsQ0FBQyxRQUFRLENBQUMseUJBQVcsQ0FBQyxDQUFDLGNBQWMsQ0FDL0QsdUJBQVUsQ0FBQyxhQUFhLEdBQUMsR0FBRyxHQUFDLHVCQUFVLENBQUMsZUFBZSxFQUN2RCxDQUFDLE9BQVcsRUFBQyxJQUFXLEVBQUMsRUFBRTtZQUN2QixJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FDSixDQUFDO0lBQ04sQ0FBQztJQUVNLGVBQWUsQ0FBQyxPQUFXLEVBQUUsSUFBVyxFQUFFLE1BQWUsRUFBRSxPQUFnQjtRQUU5RSxJQUFHLElBQUksSUFBSSwyQkFBWSxDQUFDLGtCQUFrQixFQUFDO1lBQ3ZDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7WUFFakMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2hCO2FBQUk7WUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFZCxPQUFPLENBQUMsS0FBSyxDQUFDLDhCQUE4QixHQUFDLElBQUksR0FBRyxNQUFNLEdBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBRTFFO0lBQ0wsQ0FBQztJQUVNLHFCQUFxQjtRQUN4QixJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzlCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFHTSxZQUFZLENBQUMsTUFBYSxFQUFDLEtBQVksRUFBRSxHQUFjLEVBQUMsUUFBaUI7UUFFNUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxRQUFZLEVBQUMsRUFBRTtZQUN0RCxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDdkIsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBR00saUJBQWlCLENBQUMsT0FBYyxFQUFDLE1BQWUsRUFBRSxPQUFnQjtRQUVyRSxJQUFJLENBQUMsV0FBVyxHQUFHLHlCQUFXLENBQUMsUUFBUSxDQUFDLHlCQUFXLENBQUMsQ0FBQyxjQUFjLENBQy9ELE9BQU8sRUFDUCxDQUFDLE9BQVcsRUFBQyxJQUFXLEVBQUMsRUFBRTtZQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixHQUFDLElBQUksQ0FBQyxDQUFDO1lBRXhDLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDekQsQ0FBQyxDQUNKLENBQUM7SUFDTixDQUFDO0lBRU0sZUFBZSxDQUFDLE9BQVcsRUFBRSxJQUFXLEVBQUMsTUFBZSxFQUFFLE9BQWdCO1FBQzdFLElBQUcsSUFBSSxJQUFJLDJCQUFZLENBQUMsa0JBQWtCLEVBQUM7WUFDdkMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEdBQUcsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUVqQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FFaEI7YUFBSTtZQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUVkLE9BQU8sQ0FBQyxLQUFLLENBQUMseUJBQXlCLEdBQUMsSUFBSSxHQUFHLE1BQU0sR0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDckU7SUFFTCxDQUFDO0lBRU0sb0JBQW9CO1FBQ3ZCLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDOUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7SUFDNUIsQ0FBQztJQUVNLFdBQVcsQ0FBQyxNQUFhLEVBQUMsS0FBWSxFQUFFLEdBQWMsRUFBQyxRQUFpQjtRQUUzRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxDQUFDLFFBQVksRUFBQyxFQUFFO1lBRXZELFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUN0QixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSjtBQTdGRCx3Q0E2RkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuR0QsMEdBQWdEO0FBQ2hELDJJQUFrRTtBQUVsRSxJQUFZLFlBV1g7QUFYRCxXQUFZLFlBQVk7SUFDcEIsVUFBVTtJQUNWLCtDQUFRO0lBQ1IsU0FBUztJQUNULCtDQUFRO0lBQ1IsYUFBYTtJQUNiLDJEQUFjO0lBQ2QsYUFBYTtJQUNiLDZEQUFlO0lBQ2YsYUFBYTtJQUNiLDZEQUFlO0FBQ25CLENBQUMsRUFYVyxZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQVd2QjtBQUdELE1BQWEsZUFBZ0IsU0FBUSxxQkFBMEI7SUFZM0Q7UUFDSSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNoQixDQUFDO0lBRU8sSUFBSTtRQUNSLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFRO1FBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZCLHVEQUF1RDtRQUN2RCxJQUFJO1FBQ0osSUFBSSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzRCxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVELElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDaEUsQ0FBQztJQUVEOztNQUVFO0lBQ0kscUJBQXFCLENBQUMsR0FBVyxFQUFFLE1BQWU7UUFDcEQsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLENBQUM7WUFDdkMsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLHVCQUF1QixDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdEQsQ0FBQztJQUdEOztNQUVFO0lBQ00sU0FBUyxDQUFDLEtBQWEsRUFBRSxNQUFjO1FBQzNDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUU7WUFDcEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQixPQUFPO1NBQ1Y7UUFDRCxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDMUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNwQixPQUFPO1NBQ1Y7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQztRQUNsQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7WUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7U0FBRTtRQUNqRSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsU0FBUTtRQUNqQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsYUFBWTtJQUNqRSxDQUFDO0lBRU8sdUJBQXVCLENBQUMsR0FBVyxFQUFFLEtBQWE7UUFDdEQsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssRUFBRTtZQUMxQixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQztZQUN4QixJQUFJLE9BQU8sR0FBVyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQztZQUM1QyxJQUFJLE9BQU8sRUFBRTtnQkFDVCxZQUFZO2dCQUNaLElBQUksS0FBSyxHQUFXLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsWUFBVztnQkFDckQsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVE7YUFDOUk7WUFFRCxZQUFZO1lBQ1osb0RBQW9EO1lBQ3BELFdBQVc7WUFDWCwrQ0FBc0IsQ0FBQyxRQUFRLENBQUMsK0NBQXNCLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2pGO0lBQ0wsQ0FBQztJQUNPLElBQUksQ0FBQyxLQUFhO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQzVCLENBQUM7SUFDTyxJQUFJLENBQUMsS0FBYTtRQUN0QixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBQ0Q7O01BRUU7SUFDSyxjQUFjLENBQUMsR0FBVztRQUM3QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQy9CLENBQUM7O0FBdEZMLDBDQXlGQztBQWxGRzs7RUFFRTtBQUNZLHNDQUFzQixHQUFXLHdCQUF3QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUI1RSwwR0FBZ0Q7QUFDaEQsMEdBQWdEO0FBSWhELE1BQWEsc0JBQXVCLFNBQVEscUJBQWlDO0lBQTdFOztRQUVZLG9CQUFlLEdBQWEsSUFBSSxxQkFBUyxFQUFFLENBQUM7SUEyQnhELENBQUM7SUF4QlUsV0FBVyxDQUFDLE9BQWMsRUFBQyxHQUFPLEVBQUUsUUFBaUI7UUFFeEQsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRU0sY0FBYyxDQUFDLE9BQWMsRUFBRSxRQUFpQjtRQUNuRCxJQUFJLENBQUMsZUFBZSxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUVNLG9CQUFvQixDQUFDLE9BQWM7UUFDdEMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRU0sT0FBTztRQUNWLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkMsQ0FBQztJQUVNLFNBQVMsQ0FBQyxPQUFjLEVBQUMsTUFBVTtRQUd0QyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDO0lBQ25ELENBQUM7Q0FHSjtBQTdCRCx3REE2QkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0QseUhBQTBEO0FBQzFELDZHQUFrRDtBQUdsRCxNQUFzQixTQUFTO0lBTzNCO1FBSE8sZ0JBQVcsR0FBRyxDQUFDLENBQUM7UUFDaEIsZUFBVSxHQUFHLENBQUMsQ0FBQztRQUlsQixJQUFJLENBQUMsc0JBQXNCLEdBQUcsSUFBSSxHQUFHLEVBQWlCLENBQUM7UUFDdkQsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUcsRUFBaUIsQ0FBQztRQUM5QyxJQUFJLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQztJQUN6QixDQUFDO0lBRU0seUJBQXlCLENBQUMsT0FBYyxFQUFFLFdBQWtCO1FBQy9ELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFTSxnQkFBZ0IsQ0FBQyxPQUFjLEVBQUUsU0FBUztRQUM3QyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQU9NLEtBQUssQ0FBQyxTQUFTO1FBRWxCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUM7UUFDcEQsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7UUFFMUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxZQUFZLEdBQUcsV0FBVyxDQUFDO1FBRzdDLElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztRQUVsQixJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxFQUFFO1lBQzlDLElBQUksT0FBTyxHQUFHLHVCQUFVLENBQUMsUUFBUSxDQUFDLHVCQUFVLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFDLEdBQUUsRUFBRTtnQkFDN0UsSUFBSSxDQUFDLFdBQVcsRUFBRyxDQUFDO1lBQ3hCLENBQUMsQ0FBQyxDQUFDO1lBQ0gsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMzQixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxFQUFFO1lBQ3JDLElBQUksT0FBTyxHQUFHLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFDLEdBQUUsRUFBRTtnQkFDeEYsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3ZCLENBQUMsQ0FBQztZQUNGLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0IsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDaEMsQ0FBQztJQUVNLFNBQVM7UUFDWixJQUFJLENBQUMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBQyxFQUFFO1lBRTlDLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLEdBQUMsR0FBRyxDQUFDLENBQUM7WUFFbkMsdUJBQVUsQ0FBQyxRQUFRLENBQUMsdUJBQVUsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xFLENBQUMsQ0FBQyxDQUFDO1FBRUgsUUFBUTtRQUNSLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFHdEQsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDL0IsQ0FBQztDQUNKO0FBckVELDhCQXFFQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3pFRCxNQUFjLFFBQVE7O0FBQXRCLDRCQU9DO0FBTGlCLHFCQUFZLEdBQVUsY0FBYyxDQUFDO0FBQ3JDLG9CQUFXLEdBQVUsYUFBYSxDQUFDO0FBQ25DLGtCQUFTLEdBQVUsV0FBVyxDQUFDO0FBQy9CLG1CQUFVLEdBQVUsWUFBWSxDQUFDO0FBQ2pDLGlCQUFRLEdBQVUsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDTC9DLDhIQUFnRTtBQUNoRSxtSUFBbUU7QUFDbkUsd0lBQXNFO0FBQ3RFLDhGQUFzQztBQUl0QyxNQUFhLFlBQVk7SUFHZCxNQUFNLENBQUMsV0FBVyxDQUFDLFNBQWdCO1FBRXRDLElBQUksS0FBSyxHQUFhLElBQUksQ0FBQztRQUUzQixRQUFRLFNBQVMsRUFBQztZQUNkLEtBQUssbUJBQVEsQ0FBQyxVQUFVO2dCQUNwQixLQUFLLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7Z0JBQ3pCLE1BQU07WUFDVixLQUFLLG1CQUFRLENBQUMsU0FBUztnQkFDbkIsS0FBSyxHQUFHLElBQUkscUJBQVMsRUFBRSxDQUFDO2dCQUN4QixNQUFNO1lBQ1YsS0FBSyxtQkFBUSxDQUFDLFFBQVE7Z0JBQ2xCLEtBQUssR0FBRyxJQUFJLG1CQUFRLEVBQUUsQ0FBQztnQkFDdkIsTUFBTTtTQUNiO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztDQUNKO0FBckJELG9DQXFCQzs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRCw2REFBcUM7QUFDckMsNEZBQWdEO0FBQ2hELDJHQUF1RDtBQUN2RCxnSUFBb0U7QUFDcEUsMEdBQWdEO0FBQ2hELGtHQUE0QztBQUU1QywwR0FBOEM7QUFLOUMsTUFBYSxZQUFhLFNBQVEscUJBQXVCO0lBTXJEO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFFUixvQkFBVyxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFO1lBRXRFLElBQUksSUFBSSxDQUFDLGlCQUFpQixJQUFJLElBQUk7Z0JBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzRSxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFJTSxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQVksRUFBRSxjQUF1QjtRQUV4RCxJQUFHO1lBQ0MsSUFBSSxDQUFDLGlCQUFpQixHQUFHLEtBQUssRUFBRSxTQUFnQixFQUFDLEVBQUU7Z0JBRS9DLElBQUcsU0FBUyxJQUFJLEtBQUssRUFBQztvQkFDbEIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQztvQkFDOUIsSUFBSSxDQUFDLFlBQVksR0FBSSwyQkFBWSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDckQsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQztvQkFFNUIsSUFBSSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsR0FBRSxFQUFFO3dCQUVuQyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQzt3QkFDMUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUMsUUFBUSxHQUFHLEtBQUssR0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsR0FBRyxLQUFLLEdBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFFN0csa0NBQWUsQ0FBQyxRQUFRLENBQUMsa0NBQWUsQ0FBQyxDQUFDLFNBQVMsQ0FDL0MscUJBQVMsQ0FBQyxrQkFBa0IsRUFDNUIsUUFBUSxHQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUVsQixJQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFDOzRCQUM3RCxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs0QkFFaEMsTUFBTTs0QkFDTixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDOzRCQUMvQixJQUFHLGNBQWMsSUFBSSxJQUFJO2dDQUFFLGNBQWMsRUFBRSxDQUFDOzRCQUM1QyxxQkFBUyxDQUFDLFFBQVEsQ0FBQyxxQkFBUyxDQUFDLENBQUMsWUFBWSxDQUFDLGlCQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7eUJBQ3RFO29CQUVMLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztvQkFDUixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO2lCQUVqQztZQUNMLENBQUMsQ0FBQztZQUVGLHFCQUFTLENBQUMsUUFBUSxDQUFDLHFCQUFTLENBQUMsQ0FBQyxXQUFXLENBQUMsaUJBQVEsQ0FBQyxXQUFXLEVBQUUsaUJBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUV4RixPQUFPO1lBQ1AsSUFBRyxJQUFJLENBQUMsWUFBWSxFQUFDO2dCQUNqQixJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUM1QixJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO2FBQ2pDO1lBRUQsTUFBTSxvQkFBVyxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBRW5FO1FBQUEsT0FBTSxFQUFFLEVBQUM7WUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixHQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZDO0lBRUwsQ0FBQztDQUtKO0FBdEVELG9DQXNFQzs7Ozs7Ozs7Ozs7Ozs7OztBQy9FRCxJQUFZLFNBTVg7QUFORCxXQUFZLFNBQVM7SUFDakIsNkNBQVU7SUFDVix5Q0FBUTtJQUNSLDZDQUFRO0lBQ1IsNkNBQVU7SUFDViwrQ0FBVTtBQUNkLENBQUMsRUFOVyxTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQU1wQjtBQUVELE1BQWEsVUFBVTtJQVVaLE1BQU0sQ0FBRSxlQUFlLENBQUMsSUFBYztRQUV6QyxRQUFPLElBQUksRUFBQztZQUNSLEtBQUssU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUM1QyxLQUFLLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDMUMsS0FBSyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1lBQ2hELEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QyxLQUFLLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7WUFDMUMsT0FBTyxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO1NBQy9CO0lBQ0wsQ0FBQzs7QUFwQkwsZ0NBcUJDO0FBbkJpQixxQkFBVSxHQUFVLENBQUMsQ0FBQztBQUN0QixlQUFJLEdBQVUsSUFBSSxDQUFDO0FBQ25CLHVCQUFZLEdBQVUsSUFBSSxDQUFDO0FBQzNCLG9CQUFTLEdBQVUsSUFBSSxDQUFDO0FBQ3hCLGlCQUFNLEdBQVUsSUFBSSxDQUFDO0FBQ3JCLGtCQUFPLEdBQVUsSUFBSSxDQUFDO0FBQ3RCLGlCQUFNLEdBQVUsSUFBSSxDQUFDO0FBZ0J2QyxNQUFhLFNBQVM7O0FBQXRCLDhCQUdDO0FBRmlCLGlCQUFPLEdBQUcsVUFBVSxDQUFDO0FBQ3JCLHdCQUFjLEdBQUcsZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDcENuRCxxSUFBcUU7QUFFckUsZ0lBQWtFO0FBQ2xFLDBHQUE4QztBQUM5Qyx5RkFBOEM7QUFDOUMsNEZBQWdEO0FBQ2hELHNGQUE0QztBQUM1Qyx1R0FBNEM7QUFDNUMsOElBQTJFO0FBQzNFLGdJQUFrRTtBQUNsRSx5RkFBOEM7QUFDOUMsNEhBQWdFO0FBSWhFLE1BQU0sRUFBRSxHQUFHLG1CQUFPLENBQUMsc0JBQVEsQ0FBQyxDQUFDO0FBRzdCLE1BQWEsU0FBUztJQUlYLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBVSxFQUFFLElBQVc7UUFDMUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxjQUFjLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUN4QyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLEtBQUs7UUFFOUQsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFeEMsSUFBRyxDQUFDLEVBQUUsRUFBQztZQUNILFFBQVEsSUFBSSxFQUFDO2dCQUNULFFBQVE7Z0JBQ1IsS0FBSyxpQkFBUSxDQUFDLGFBQWE7b0JBQ3ZCLEVBQUUsR0FBRyxJQUFJLG1CQUFRLEVBQUUsQ0FBQztvQkFDcEIsTUFBTTtnQkFDVixLQUFLLGlCQUFRLENBQUMsYUFBYTtvQkFDdkIsRUFBRSxHQUFHLElBQUkscUJBQVMsRUFBRSxDQUFDO29CQUNyQixNQUFNO2dCQUVOLE9BQU87Z0JBQ1gsS0FBSyxlQUFPLENBQUMsV0FBVztvQkFDcEIsRUFBRSxHQUFHLElBQUkseUJBQVcsRUFBRSxDQUFDO29CQUN2QixNQUFNO2dCQUNWLEtBQUssZUFBTyxDQUFDLGNBQWM7b0JBQ3ZCLEVBQUUsR0FBRyxJQUFJLCtCQUFjLEVBQUUsQ0FBQztvQkFDMUIsTUFBTTtnQkFFTixNQUFNO2dCQUNWLEtBQUssYUFBTSxDQUFDLFVBQVU7b0JBQ2xCLEVBQUUsR0FBRyxJQUFJLHVCQUFVLEVBQUUsQ0FBQztvQkFDdEIsTUFBTTtnQkFDVixLQUFLLGFBQU0sQ0FBQyxVQUFVO29CQUNsQixFQUFFLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7b0JBQ3RCLE1BQU07Z0JBRU4sT0FBTztnQkFDWCxLQUFLLGVBQU8sQ0FBQyxVQUFVO29CQUNuQixFQUFFLEdBQUcsSUFBSSx1QkFBVSxFQUFFLENBQUM7b0JBQ3RCLE1BQU07YUFDYjtZQUVELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztTQUM5QjtRQUVELElBQUcsRUFBRSxJQUFFLElBQUksRUFBQztZQUNSLEVBQUUsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1lBQ2QsRUFBRSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7WUFFZixjQUFjO1lBQ2QsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNmLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUVkO2FBQUk7WUFDRCxPQUFPLENBQUMsS0FBSyxDQUFDLGtCQUFrQixHQUFHLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQztTQUNsRDtRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQzs7QUExREwsOEJBOERDO0FBNURpQixpQkFBTyxHQUF1QixJQUFJLEdBQUcsRUFBa0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCMUUseUZBQXFDO0FBQ3JDLDRGQUF3QztBQUV4Qyx5SEFBb0Q7QUFDcEQsbUlBQXVFO0FBQ3ZFLDhHQUEwRDtBQUkxRCxNQUFjLFNBQVUsU0FBUSxpQkFBTztJQVE1QixPQUFPO0lBRWQsQ0FBQztJQUVELElBQVcsTUFBTTtRQUNiLE9BQU8sb0JBQVMsQ0FBQyxPQUFPLENBQUM7SUFDN0IsQ0FBQztJQUVNLE1BQU0sQ0FBQyxHQUFPO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFbEIsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUVwQyxrQ0FBZSxDQUFDLFFBQVEsQ0FBQyxrQ0FBZSxDQUFDLENBQUMsV0FBVyxDQUNqRCxxQkFBUyxDQUFDLGtCQUFrQixFQUM1QixJQUFJLEVBQ0osQ0FBQyxRQUFlLEVBQUMsRUFBRTtZQUNmLElBQUksQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFFTSxPQUFPLENBQUMsR0FBTztRQUNsQixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5CLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUNyQyxrQ0FBZSxDQUFDLFFBQVEsQ0FBQyxrQ0FBZSxDQUFDLENBQUMsb0JBQW9CLENBQzFELHFCQUFTLENBQUMsa0JBQWtCLENBQy9CLENBQUM7SUFDTixDQUFDO0NBR0o7QUFwQ0c7SUFEQyxzQkFBTSxDQUFDLGtCQUFrQixDQUFDO2tEQUNtQjtBQUpsRCw4QkF3Q0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoREQsc0lBQWlFO0FBQ2pFLDRGQUF1QztBQUV2QyxPQUFPO0FBQ1AsTUFBYSxXQUFXO0lBQXhCO1FBQ1csVUFBSyxHQUFVLEVBQUUsQ0FBQztRQUNsQixZQUFPLEdBQVUsRUFBRSxDQUFDO1FBQ3BCLFlBQU8sR0FBVSxFQUFFLENBQUMsYUFBWTtJQUMzQyxDQUFDO0NBQUE7QUFKRCxrQ0FJQztBQUdELE1BQWEsUUFBUyxTQUFRLG1CQUFRO0lBYTNCLE9BQU87UUFDVixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7UUFFaEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7SUFDdEIsQ0FBQztJQUVNLE1BQU0sQ0FBQyxHQUFPO1FBQ2pCLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFHdEIsQ0FBQztJQUdNLE9BQU8sQ0FBQyxHQUFPO1FBQ2xCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFHdkIsQ0FBQztDQUVKO0FBM0JHO0lBREMsc0JBQU0sQ0FBQyxRQUFRLENBQUM7dUNBQ2E7QUFFOUI7SUFEQyxzQkFBTSxDQUFDLE9BQU8sQ0FBQzt5Q0FDaUI7QUFFakM7SUFEQyxzQkFBTSxDQUFDLFdBQVcsQ0FBQzs2Q0FDaUI7QUFUekMsNEJBZ0NDOzs7Ozs7Ozs7Ozs7Ozs7O0FDM0NELDBHQUFnRDtBQUtoRCw4RkFBd0M7QUFFeEMsc0ZBQTRDO0FBRzVDLE1BQWEsV0FBVztDQUl2QjtBQUpELGtDQUlDO0FBR0QsTUFBYSxTQUFVLFNBQVEscUJBQW9CO0lBUS9DO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFFUixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxLQUFLLEVBQWUsQ0FBQztRQUNqRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxLQUFLLEVBQVcsQ0FBQztJQUVsRCxDQUFDO0lBRU8sbUJBQW1CO1FBRXZCLEtBQUksSUFBSSxDQUFDLEdBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sR0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNsRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFdEMsSUFBRyxLQUFLLENBQUMsTUFBTSxFQUFDO2dCQUNaLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQzthQUNqQjtZQUVELEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNuQjtRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFTSxLQUFLO1FBRVIsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFM0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFDakMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVNLElBQUksQ0FBQyxHQUFVLEVBQUUsSUFBVyxFQUFFLEdBQVE7UUFFekMsSUFBSSxFQUFFLEdBQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU5QixJQUFHLEVBQUUsSUFBSSxJQUFJLEVBQUM7WUFDVixFQUFFLEdBQUcscUJBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ25DLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDbkM7UUFFRCxJQUFHLEVBQUUsSUFBSSxJQUFJLEVBQUM7WUFDVixFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO1FBRUQsT0FBTyxFQUFFLENBQUM7SUFDZCxDQUFDO0lBR00sS0FBSyxDQUFDLElBQVc7UUFFcEIsS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDeEMsSUFBRyxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksRUFBQztnQkFFbEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsR0FBQyxJQUFJLENBQUMsQ0FBQztnQkFFMUMsT0FBTyxLQUFLLENBQUM7YUFDaEI7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFRCwyQkFBMkI7SUFDcEIsZUFBZSxDQUFDLEdBQVUsRUFBRSxJQUFXLEVBQUUsR0FBTztRQUNuRCxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVELHFFQUFxRTtJQUNyRSxhQUFhO0lBQ04sV0FBVyxDQUFDLEdBQVUsRUFBRSxJQUFXLEVBQUUsR0FBUTtRQUVoRCxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFekMsQ0FBQztJQUNELGFBQWE7SUFDTixZQUFZLENBQUMsSUFBVyxFQUFFLEdBQVE7UUFDckMsSUFBSSxFQUFFLEdBQWEsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQWMsQ0FBQztRQUNqRCxJQUFHLEVBQUUsSUFBSSxJQUFJLEVBQUM7WUFDVixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pCO0lBQ0wsQ0FBQztJQUdELGdFQUFnRTtJQUN4RCxjQUFjLENBQUMsR0FBVSxFQUFFLElBQVcsRUFBRSxHQUFPO1FBQ25ELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDN0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDO1FBQy9CLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUU3QixJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUUzQixJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELCtCQUErQjtJQUN4QixRQUFRLENBQUMsR0FBVSxFQUFFLElBQVcsRUFBRSxHQUFRO1FBRTdDLElBQUcsSUFBSSxDQUFDLGFBQWEsSUFBSSxTQUFTLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLElBQUUsSUFBSSxFQUFDO1lBQ2hFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRCxTQUFTO0lBQ0YsVUFBVTtRQUViLElBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUM7WUFDaEMsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ3hDLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUN6RDthQUFJO1lBQ0QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3hCO0lBQ0wsQ0FBQztJQUlELE1BQU07SUFDQyxhQUFhO1FBRWhCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxlQUFlLENBQUMsYUFBTSxDQUFDLFdBQVcsRUFBRSxhQUFNLENBQUMsVUFBVSxFQUFDLElBQUksQ0FBQztJQUNwRSxDQUFDO0lBRUQsb0VBQW9FO0lBQ3BFLE1BQU07SUFDQyxVQUFVLENBQUMsR0FBVSxFQUFFLElBQVcsRUFBRSxHQUFPO1FBRTlDLElBQUksRUFBRSxHQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztRQUU1QyxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCxNQUFNO0lBQ0MsV0FBVyxDQUFDLElBQVcsRUFBRSxHQUFPO1FBRW5DLElBQUksRUFBRSxHQUFZLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFhLENBQUM7UUFDL0MsSUFBRyxFQUFFLElBQUksSUFBSSxFQUFDO1lBQ1YsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNqQjtJQUNMLENBQUM7SUFFRCxvRUFBb0U7SUFDcEUsV0FBVztJQUNKLFVBQVUsQ0FBQyxHQUFVLEVBQUUsSUFBVyxFQUFFLEdBQU87UUFFOUMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRTNDLE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQztJQUVELFlBQVk7SUFDTCxXQUFXLENBQUMsSUFBVyxFQUFFLEdBQU87UUFFbkMsSUFBSSxFQUFFLEdBQVcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQVksQ0FBQztRQUM3QyxJQUFHLEVBQUUsSUFBRSxJQUFJLEVBQUM7WUFDUixFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ2pCO0lBQ0wsQ0FBQztDQUdKO0FBeEtELDhCQXdLQzs7Ozs7Ozs7Ozs7Ozs7OztBQzFMRCx3RkFBb0M7QUFDcEMsMkZBQWtEO0FBQ2xELDhGQUF3QztBQU14QyxNQUFzQixNQUFPLFNBQVEsaUJBQU87SUFDeEMsSUFBVyxNQUFNO1FBQ2IsT0FBTyxvQkFBUyxDQUFDLElBQUksQ0FBQztJQUMxQixDQUFDO0lBS00sT0FBTztRQUVWLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsb0JBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV4RCxJQUFHLElBQUksQ0FBQyxXQUFXLElBQUUsU0FBUyxFQUFDO1lBQzNCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFFLEVBQUU7Z0JBQzdCLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN2QixDQUFDLENBQUMsQ0FBQztTQUNOO0lBQ0wsQ0FBQztJQUdNLE1BQU0sQ0FBQyxFQUFNO1FBQ2hCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFJckIsQ0FBQztJQUNNLE9BQU8sQ0FBQyxHQUFPO1FBQ2xCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdkIsQ0FBQztJQUVPLFdBQVc7UUFDZixxQkFBUyxDQUFDLFFBQVEsQ0FBQyxxQkFBUyxDQUFDLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDL0MsQ0FBQztDQUVKO0FBbkNELHdCQW1DQzs7Ozs7Ozs7Ozs7Ozs7OztBQzNDRCwyRkFBbUQ7QUFDbkQsNkRBQWtDO0FBRWxDLE1BQXNCLE9BQU87SUFBN0I7UUFpQlksWUFBTyxHQUFjLHFCQUFVLENBQUMsTUFBTSxDQUFDO0lBMkRuRCxDQUFDO0lBdEVHLElBQVcsSUFBSSxDQUFDLENBQVE7UUFDcEIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUNELElBQVcsSUFBSTtRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDO0lBRUQsSUFBVyxNQUFNO1FBQ2IsT0FBTyxvQkFBUyxDQUFDLE1BQU0sQ0FBQztJQUM1QixDQUFDO0lBR0QsSUFBVyxLQUFLO1FBQ1osT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDO0lBQ3hCLENBQUM7SUFDRCxJQUFXLEtBQUssQ0FBQyxDQUFjO1FBQzNCLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxJQUFZLE1BQU07UUFFZCxPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO0lBQzVCLENBQUM7SUFHTSxRQUFRLEtBQVEsQ0FBQztJQUVqQixNQUFNLENBQUMsRUFBTTtRQUNoQixJQUFJLENBQUMsS0FBSyxHQUFHLHFCQUFVLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBQ00sT0FBTyxDQUFDLEdBQU8sSUFBTyxDQUFDO0lBRXZCLEtBQUs7UUFDUixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFbkIsQ0FBQztJQUVELGNBQWM7SUFDUCxPQUFPLENBQUMsTUFBVTtRQUNyQixLQUFJLElBQUksQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBQztZQUMzQixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3pDO0lBQ0wsQ0FBQztJQUVNLE1BQU07UUFDVCxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDcEIsQ0FBQztJQUVNLElBQUksQ0FBQyxHQUFPO1FBRWYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVqQixpQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUczQyxDQUFDO0lBRU0sS0FBSyxDQUFDLE1BQVUsSUFBSTtRQUd2QixJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLGlCQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRTlDLENBQUM7SUFFTSxPQUFPO1FBQ1YsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUN2QixDQUFDO0NBQ0o7QUE1RUQsMEJBNEVDOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0VELHdGQUFvQztBQUNwQywyRkFBa0Q7QUFDbEQsNkRBQWtDO0FBR2xDLE1BQXVCLFFBQVMsU0FBUSxpQkFBTztJQUUzQyxJQUFXLE1BQU07UUFDYixPQUFPLG9CQUFTLENBQUMsTUFBTSxDQUFDO0lBQzVCLENBQUM7SUFJTSxPQUFPO1FBRVYsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxvQkFBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBRWxFLENBQUM7SUFFTSxNQUFNLENBQUMsR0FBTztRQUNqQixLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLGlCQUFRLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLEdBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxpQkFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxHQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBQyxDQUFDLENBQUM7UUFFOUQsSUFBRyxJQUFJLENBQUMsVUFBVSxJQUFFLFNBQVMsRUFBQztZQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ2hEO0lBRUwsQ0FBQztJQUNNLE9BQU8sQ0FBQyxHQUFPO1FBQ2xCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFbkIsSUFBRyxJQUFJLENBQUMsVUFBVSxJQUFFLFNBQVMsRUFBQztZQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ25EO0lBQ0wsQ0FBQztJQUVPLFVBQVU7UUFDZCxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7Q0FFSjtBQXJDRCw0QkFxQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q0QsTUFBYSxRQUFRO0lBR1QsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsTUFBTTtRQUVwQyxPQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUMzRCxDQUFDO0lBRUQsdUJBQXVCO0lBQ2hCLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBZ0I7UUFFekMsSUFBRyxPQUFPLElBQUksQ0FBQyxFQUFDO1lBQ1osT0FBTyxVQUFVLENBQUM7U0FDckI7YUFBSTtZQUVELElBQUksSUFBSSxHQUFVLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEQsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFMUMsSUFBSSxPQUFPLEdBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUUsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQ2xELElBQUksU0FBUyxHQUFVLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRXRELElBQUksTUFBTSxHQUFVLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDakMsSUFBSSxTQUFTLEdBQVUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUMsQ0FBQyxDQUFDLENBQUM7WUFFcEQsT0FBTyxHQUFHLE9BQU8sSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFLENBQUM7U0FDakQ7SUFFTCxDQUFDO0lBRUQsb0JBQW9CO0lBQ2IsTUFBTSxDQUFDLGFBQWEsQ0FBQyxPQUFjO1FBRXRDLElBQUcsT0FBTyxJQUFJLENBQUMsRUFBQztZQUNaLE9BQU8sVUFBVSxDQUFDO1NBQ3JCO2FBQUk7WUFDRCxJQUFJLElBQUksR0FBVSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2xELElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRTFDLElBQUksT0FBTyxHQUFVLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFFLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNsRCxJQUFJLFNBQVMsR0FBVSxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQztZQUV0RCxPQUFPLEdBQUcsT0FBTyxJQUFJLFNBQVMsRUFBRSxDQUFDO1NBQ3BDO0lBQ0wsQ0FBQztJQUVELGtCQUFrQjtJQUNYLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFjO1FBRTVDLElBQUcsT0FBTyxJQUFJLENBQUMsRUFBQztZQUNaLE9BQU8sVUFBVSxDQUFDO1NBQ3JCO2FBQUk7WUFFRCxJQUFJLE9BQU8sR0FBVSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDbEQsSUFBSSxTQUFTLEdBQVUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFFdEQsT0FBTyxHQUFHLFNBQVMsRUFBRSxDQUFDO1NBQ3pCO0lBQ0wsQ0FBQztJQUVELGtCQUFrQjtJQUNYLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxPQUFjO1FBRTVDLElBQUcsT0FBTyxJQUFJLENBQUMsRUFBQztZQUNaLE9BQU8sVUFBVSxDQUFDO1NBQ3JCO2FBQUk7WUFDRCxJQUFJLE1BQU0sR0FBVSxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2pDLElBQUksU0FBUyxHQUFVLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxFQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXBELE9BQU8sR0FBRyxTQUFTLEVBQUUsQ0FBQztTQUN6QjtJQUNMLENBQUM7SUFFRCxZQUFZO0lBQ0wsTUFBTSxDQUFDLHNCQUFzQixDQUFDLElBQVc7UUFFNUMsSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVoQixPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsU0FBUztJQUNGLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBVztRQUVoQyxJQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDMUQsT0FBTyxJQUFJLENBQUM7U0FDZjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFJTyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQVcsRUFBRSxLQUFZO1FBQ2xELElBQUcsS0FBSyxJQUFJLENBQUMsRUFBQztZQUNWLElBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7Z0JBQ3BCLE9BQU8sRUFBRSxDQUFDO2lCQUNWO2dCQUNBLE9BQU8sRUFBRSxDQUFDO2FBQ2I7U0FDSjthQUFJO1lBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdCO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxZQUFZLENBQUMsSUFBVztRQUVsQyxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV2QixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFHTSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFTO1FBQy9CLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMzQixVQUFVLENBQUMsR0FBRSxFQUFFO2dCQUNYLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNoQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDWCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFHTSxNQUFNLENBQUMsSUFBSTtRQUVkLElBQUksRUFBRSxHQUFVLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUdoQixJQUFJLEVBQUUsR0FBVSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEIsSUFBSSxFQUFFLEdBQVUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEIsSUFBSSxFQUFFLEdBQVUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9DLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFaEIsSUFBSSxJQUFJLEdBQVUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUV2QyxJQUFJLEVBQUUsR0FBVSxJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbEQsT0FBTyxDQUFDLEdBQUcsQ0FBQywwQkFBMEIsR0FBQyxFQUFFLEdBQUcsU0FBUyxHQUFDLElBQUksQ0FBQyxDQUFDO1FBRTVELElBQUksRUFBRSxHQUFVLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDeEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBQyxFQUFFLENBQUMsQ0FBQztJQUVyQyxDQUFDOztBQWhKTCw0QkFtSkM7QUF6REcsVUFBVTtBQUNGLGVBQU0sR0FBaUIsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0FDN0ZwRix3RkFBK0M7QUFDL0MsNEZBQThDO0FBQzlDLGdJQUFvRTtBQUdwRSxNQUFhLFFBQVE7SUFFVixNQUFNLENBQUMsYUFBYTtRQUd2QixLQUFJLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsQ0FBQyxFQUFDLENBQUMsRUFBRSxFQUFDO1lBQ2pCLElBQUksR0FBRyxHQUFHLFlBQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDckMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7WUFDZixHQUFHLENBQUMsUUFBUSxHQUFHLGdCQUFnQixDQUFDO1lBQ2hDLElBQUksR0FBRyxHQUFHLFlBQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRWpELElBQUksS0FBSyxHQUFHLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFDOUQsTUFBTTtZQUNOLEtBQUssR0FBRyxDQUFDO1lBQ1QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLEdBQUMsS0FBSyxDQUFDO1lBQy9CLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxXQUFXLENBQy9DLGVBQU0sQ0FBQyxhQUFhLEVBQ3BCLEtBQUssRUFDTCxHQUFHLEVBQ0gsQ0FBQyxRQUFZLEVBQUMsRUFBRTtnQkFDWixJQUFJLEdBQUcsR0FBSyxRQUE2QixDQUFDO2dCQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsR0FBQyxHQUFHLENBQUMsS0FBSyxHQUFFLE9BQU8sR0FBQyxHQUFHLENBQUMsT0FBTyxHQUFFLE9BQU8sR0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDbkYsQ0FBQyxDQUNKO1NBQ0o7SUFFTCxDQUFDO0lBR00sTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQWMsRUFBRSxRQUFlLEVBQUUsUUFBaUI7UUFFNUUsSUFBSSxHQUFHLEdBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUNyQyxHQUFHLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN0QixHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN4QixJQUFJLEdBQUcsR0FBRyxZQUFPLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUVqRCxJQUFJLEtBQUssR0FBRywrQkFBYyxDQUFDLFFBQVEsQ0FBQywrQkFBYyxDQUFDLENBQUMsVUFBVSxDQUFDO1FBRWhFLCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxZQUFZLENBQ2hELGVBQU0sQ0FBQyxhQUFhLEVBQ3BCLEtBQUssRUFDTCxHQUFHLEVBQ0gsQ0FBQyxRQUFZLEVBQUMsRUFBRTtZQUNaLElBQUksR0FBRyxHQUFLLFFBQTZCLENBQUM7WUFDMUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLENBQUMsQ0FDSjtJQUVMLENBQUM7SUFHTSxNQUFNLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsUUFBaUI7UUFFNUQsSUFBSSxLQUFLLEdBQUcsK0JBQWMsQ0FBQyxRQUFRLENBQUMsK0JBQWMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUM5RCxJQUFJLEdBQUcsR0FBRyxZQUFPLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQ3pDLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3BCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDO1FBRWxCLElBQUksR0FBRyxHQUFHLFlBQU8sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRXJELCtCQUFjLENBQUMsUUFBUSxDQUFDLCtCQUFjLENBQUMsQ0FBQyxXQUFXLENBQy9DLGVBQU0sQ0FBQyxpQkFBaUIsRUFDeEIsS0FBSyxFQUNMLEdBQUcsRUFDSCxDQUFDLFFBQVksRUFBQyxFQUFFO1lBQ1osSUFBSSxHQUFHLEdBQUcsUUFBaUMsQ0FBQztZQUM1QyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUNKLENBQUM7SUFFTixDQUFDO0NBQ0o7QUF2RUQsNEJBdUVDOzs7Ozs7Ozs7Ozs7Ozs7O0FDekVELE1BQWEsU0FBUzs7QUFBdEIsOEJBUUM7QUFMaUIsMkJBQWlCLEdBQVcsSUFBSSxDQUFDO0FBQ2pDLDRCQUFrQixHQUFVLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1BuRCx1SEFBNkQ7QUFDN0QsdUhBQTZEO0FBRzdELE1BQWEsZUFBZ0IsU0FBUSxxQkFBMEI7SUFBL0Q7O1FBRVksY0FBUyxHQUFhLElBQUkscUJBQVMsRUFBRSxDQUFDO0lBeUJsRCxDQUFDO0lBdEJVLFdBQVcsQ0FBQyxPQUFjLEVBQUMsR0FBTyxFQUFFLFFBQWlCO1FBRXhELElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVNLGNBQWMsQ0FBQyxPQUFjLEVBQUUsUUFBaUI7UUFDbkQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFTSxvQkFBb0IsQ0FBQyxPQUFjO1FBQ3RDLElBQUksQ0FBQyxTQUFTLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVNLE9BQU87UUFDVixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFTSxTQUFTLENBQUMsT0FBYyxFQUFDLE1BQVU7UUFHdEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQztJQUM3QyxDQUFDO0NBQ0o7QUEzQkQsMENBMkJDOzs7Ozs7Ozs7Ozs7Ozs7O0FDL0JELDRGQUFrRDtBQUNsRCwySEFBa0U7QUFDbEUscUhBQStEO0FBQy9ELGdHQUFzQztBQUd0QyxNQUFhLFNBQVUsU0FBUSxxQkFBUztJQUVwQztRQUNJLEtBQUssRUFBRSxDQUFDO0lBR1osQ0FBQztJQUVNLE9BQU87UUFFVixJQUFJLENBQUMseUJBQXlCLENBQUMsYUFBTSxDQUFDLFlBQVksRUFBQyxhQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDM0UsQ0FBQztJQUVNLFVBQVU7UUFFYixJQUFJLEVBQUUsR0FBVSxJQUFJLGVBQU0sRUFBRSxDQUFDO1FBQzdCLEVBQUUsQ0FBQyxJQUFJLEdBQUcsUUFBUSxDQUFDO1FBQ25CLEVBQUUsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDO1FBQ2IsRUFBRSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUM7UUFDYixFQUFFLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUVmLHFCQUFTLENBQUMsUUFBUSxDQUFDLHFCQUFTLENBQUMsQ0FBQyxlQUFlLENBQ3pDLGFBQU0sQ0FBQyxXQUFXLEVBQ2xCLGFBQU0sQ0FBQyxVQUFVLEVBQ2pCLEVBQUUsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUVNLE9BQU87SUFFZCxDQUFDO0NBSUo7QUFqQ0QsOEJBaUNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNELDRHQUF5RDtBQUN6RCx5SUFBb0U7QUFFcEUscUhBQStEO0FBRS9ELGtHQUFzRDtBQUN0RCw0RkFBa0Q7QUFFbEQsa0dBQWlEO0FBQ2pELDZIQUFvRTtBQUNwRSxrR0FBb0Q7QUFLcEQsTUFBYSxVQUFXLFNBQVEsZUFBTTtJQXFCM0IsT0FBTztRQUNWLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVoQixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRSxFQUFFO1lBQzNCLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQixDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFFLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3BCLENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUUsRUFBRTtZQUMzQixJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckIsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRSxFQUFFO1lBQzVCLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUN0QixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFHTSxNQUFNLENBQUMsRUFBUztRQUNuQixLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWpCLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7UUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNyQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFM0MseUJBQVcsQ0FBQyxRQUFRLENBQUMseUJBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxlQUFNLENBQUMsYUFBYSxFQUFDLFVBQVMsR0FBcUI7WUFDeEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsR0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDO1FBQ2xELENBQUMsQ0FBQztJQUNOLENBQUM7SUFDTSxPQUFPLENBQUMsR0FBTztRQUNsQixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXZCLENBQUM7SUFHTSxTQUFTO1FBRVoscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLFVBQVUsQ0FDcEMsaUJBQVEsQ0FBQyxXQUFXLEVBQ3BCLGlCQUFRLENBQUMsYUFBYSxFQUN0QixJQUFJLENBQUMsQ0FBQztRQUNWLE9BQU8sQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUNNLFFBQVE7UUFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBRXpCLGdCQUFnQjtRQUNoQixtQkFBUSxDQUFDLGFBQWEsRUFBRSxDQUFDO0lBRTdCLENBQUM7SUFDTSxTQUFTO1FBRVoscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FDbEMsYUFBTSxDQUFDLFdBQVcsRUFDbEIsYUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFDTSxVQUFVO1FBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUMvQixDQUFDO0NBRUo7QUEvRUc7SUFEQyxzQkFBTSxDQUFDLFNBQVMsQ0FBQzs2Q0FDZ0I7QUFFbEM7SUFEQyxzQkFBTSxDQUFDLFFBQVEsQ0FBQzs0Q0FDZ0I7QUFFakM7SUFEQyxzQkFBTSxDQUFDLFNBQVMsQ0FBQzs2Q0FDZ0I7QUFFbEM7SUFEQyxzQkFBTSxDQUFDLFVBQVUsQ0FBQzs4Q0FDZ0I7QUFHbkM7SUFEQyxzQkFBTSxDQUFDLFNBQVMsQ0FBQzs2Q0FDZTtBQUVqQztJQURDLHNCQUFNLENBQUMsT0FBTyxDQUFDOzJDQUNlO0FBRS9CO0lBREMsc0JBQU0sQ0FBQyxPQUFPLENBQUM7MkNBQ2U7QUFFL0I7SUFEQyxzQkFBTSxDQUFDLFVBQVUsQ0FBQzs4Q0FDZTtBQWxCdEMsZ0NBa0ZDOzs7Ozs7Ozs7Ozs7Ozs7O0FDakdELDRHQUF5RDtBQUl6RCxNQUFhLFVBQVcsU0FBUSxlQUFNO0lBRzNCLE9BQU87UUFDVixLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFcEIsQ0FBQztJQUdNLE1BQU0sQ0FBQyxFQUFNO1FBQ2hCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFHckIsQ0FBQztJQUNNLE9BQU8sQ0FBQyxHQUFPO1FBQ2xCLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdkIsQ0FBQztDQUVKO0FBbkJELGdDQW1CQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3JCRCxNQUFhLE1BQU07Q0FPbEI7QUFQRCx3QkFPQzs7Ozs7Ozs7Ozs7Ozs7OztBQ1JELCtGQUFvRDtBQUNwRCwrRkFBb0Q7QUFDcEQsMkhBQWtFO0FBQ2xFLHFIQUErRDtBQUkvRCxNQUFhLFVBQVcsU0FBUSxxQkFBUztJQUk5QixPQUFPO1FBRVYsU0FBUztRQUNWLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxlQUFPLENBQUMsWUFBWSxFQUFDLGVBQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUN6RSxTQUFTO1FBQ1QsSUFBSSxDQUFDLHlCQUF5QixDQUFDLGVBQU8sQ0FBQyxZQUFZLEVBQUMsZUFBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzVFLENBQUM7SUFFTSxVQUFVO1FBRWIscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLGVBQWUsQ0FDekMsZUFBTyxDQUFDLFdBQVcsRUFDbkIsZUFBTyxDQUFDLFdBQVcsRUFDbkIsSUFBSSxDQUFDLENBQUM7SUFDZCxDQUFDO0lBRU0sT0FBTztJQUlkLENBQUM7Q0FJSjtBQTVCRCxnQ0E0QkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0QsNEdBQXlEO0FBQ3pELHlJQUFvRTtBQUVwRSxzSUFBMEU7QUFDMUUsa0dBQWlEO0FBQ2pELHFIQUErRDtBQUMvRCwrRkFBb0Q7QUFDcEQsdUdBQXdEO0FBQ3hELDhIQUFrRTtBQUNsRSx5R0FBcUQ7QUFDckQsb0lBQXdFO0FBQ3hFLHdIQUFnRTtBQUNoRSwrRkFBb0Q7QUFLcEQsTUFBYSxXQUFZLFNBQVEsZUFBTTtJQW1CNUIsT0FBTztRQUNWLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUVoQixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRSxFQUFFO1lBQzVCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN4QixDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFFLEVBQUU7WUFDNUIscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLFVBQVUsQ0FDcEMsZUFBTyxDQUFDLFdBQVcsRUFDbkIsZUFBTyxDQUFDLFVBQVUsRUFDbEIsSUFBSSxDQUFDLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFFLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDNUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFFaEMsK0JBQWMsQ0FBQyxRQUFRLENBQUMsK0JBQWMsQ0FBQyxDQUFDLGtCQUFrQixDQUN0RCxDQUFDLElBQVcsRUFBQyxFQUFFO1lBQ1AsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBRXRDLENBQUMsRUFBRSxDQUFDLElBQVcsRUFBQyxFQUFFO1FBQ2xCLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQztJQUdPLGNBQWMsQ0FBQyxVQUF1QjtRQUUxQyxPQUFPLENBQUMsR0FBRyxDQUFDLG9CQUFvQixHQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7UUFDdkQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDLFVBQVUsQ0FBQztJQUNyRCxDQUFDO0lBR00sTUFBTSxDQUFDLEVBQU07UUFDaEIsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVoQixRQUFRO1FBQ1Isa0NBQWUsQ0FBQyxRQUFRLENBQUMsa0NBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FDbEQscUJBQVMsQ0FBQyxpQkFBaUIsRUFDM0IsSUFBSSxFQUNKLElBQUksQ0FBQyxjQUFjLENBQ3RCLENBQUM7SUFDTixDQUFDO0lBQ00sT0FBTyxDQUFDLEdBQU87UUFDbEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVuQixrQ0FBZSxDQUFDLFFBQVEsQ0FBQyxrQ0FBZSxDQUFDLENBQUMsY0FBYyxDQUNwRCxxQkFBUyxDQUFDLGlCQUFpQixFQUMzQixJQUFJLENBQUMsY0FBYyxDQUN0QixDQUFDO0lBQ04sQ0FBQztJQUVPLGdCQUFnQjtRQUVwQixPQUFPO1FBQ1AsSUFBSSxRQUFRLEdBQVksSUFBSSxtQkFBUSxFQUFFLENBQUM7UUFDdkMsS0FBSSxJQUFJLENBQUMsR0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNuQixRQUFRLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUMsSUFBSSxHQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxJQUFJLEtBQUssRUFBZ0IsQ0FBQyxDQUFDO1lBRXJELEtBQUksSUFBSSxDQUFDLEdBQUMsQ0FBQyxFQUFFLENBQUMsR0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUM7Z0JBRW5CLElBQUksWUFBWSxHQUFnQixJQUFJLHVCQUFZLEVBQUUsQ0FBQztnQkFDbkQsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7Z0JBQ3hCLFlBQVksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO2dCQUUxQixZQUFZLENBQUMsVUFBVSxHQUFHLE9BQU8sR0FBQyxDQUFDLEdBQUMsR0FBRyxHQUFDLENBQUMsQ0FBQztnQkFDMUMsWUFBWSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRzFELFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQzthQUNoRDtTQUNKO1FBRUQscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLFVBQVUsQ0FDcEMsZUFBTyxDQUFDLFdBQVcsRUFDbkIsZUFBTyxDQUFDLGNBQWMsRUFDdEIsUUFBUSxDQUFDLENBQUM7SUFDbEIsQ0FBQztJQUVPLFlBQVk7UUFFaEIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDbEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7UUFFcEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLE9BQU8sZ0JBQWdCLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFMUQsSUFBRyxPQUFPLElBQUksRUFBRSxJQUFJLFFBQVEsSUFBSSxFQUFFLEVBQUM7WUFFL0IsbUJBQVEsQ0FBQyxnQkFBZ0IsQ0FDckIsT0FBTyxFQUNQLFFBQVEsRUFDUixDQUFDLEdBQXFCLEVBQUMsRUFBRTtnQkFFckIsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDO2dCQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUM7Z0JBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsNkJBQTZCLEdBQUMsR0FBRyxDQUFDLE9BQU8sR0FBRyxPQUFPLEdBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUV6RSwrQkFBYyxDQUFDLFFBQVEsQ0FBQywrQkFBYyxDQUFDLENBQUMscUJBQXFCLEVBQUUsQ0FBQztnQkFFaEUsT0FBTztnQkFDUCwrQkFBYyxDQUFDLFFBQVEsQ0FBQywrQkFBYyxDQUFDLENBQUMsaUJBQWlCLENBQ3JELEdBQUcsQ0FBQyxPQUFPLEVBQ1gsQ0FBQyxJQUFXLEVBQUMsRUFBRSxHQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQzVDLENBQUMsSUFBVyxFQUFDLEVBQUUsR0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUM5QyxDQUFDO1lBRU4sQ0FBQyxDQUFDLENBQUM7U0FFVjtJQUVMLENBQUM7SUFFTyxjQUFjLENBQUMsSUFBVztRQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixHQUFDLElBQUksQ0FBQztRQUV2QyxtQkFBUSxDQUFDLGVBQWUsQ0FDcEIsSUFBSSxDQUFDLE1BQU0sRUFDWCxJQUFJLENBQUMsT0FBTyxFQUNaLENBQUMsR0FBeUIsRUFBQyxFQUFFO1lBRXpCLElBQUksUUFBUSxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUM7WUFDNUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsR0FBRSxRQUFRLENBQUMsQ0FBQztZQUUvQywyQkFBWSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLENBQUMsU0FBUyxDQUFDLG1CQUFRLENBQUMsU0FBUyxFQUFDLEdBQUUsRUFBRSxHQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzdFLENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQUVPLGFBQWEsQ0FBQyxJQUFXO1FBQzdCLE9BQU8sQ0FBQyxHQUFHLENBQUMsb0JBQW9CLEdBQUMsSUFBSSxDQUFDO0lBQzFDLENBQUM7Q0FDSjtBQXRKRztJQURDLHNCQUFNLENBQUMsU0FBUyxDQUFDOzhDQUNtQjtBQUVyQztJQURDLHNCQUFNLENBQUMsVUFBVSxDQUFDOytDQUNtQjtBQUd0QztJQURDLHNCQUFNLENBQUMsY0FBYyxDQUFDO21EQUNnQjtBQUd2QztJQURDLHNCQUFNLENBQUMsVUFBVSxDQUFDOytDQUNnQjtBQUduQztJQURDLHNCQUFNLENBQUMsVUFBVSxDQUFDOytDQUNnQjtBQWR2QyxrQ0F5SkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6S0QseUlBQW9FO0FBQ3BFLGtIQUE2RDtBQUM3RCx5R0FBcUQ7QUFDckQsOEhBQWtFO0FBS2xFLE1BQWEsY0FBZSxTQUFRLG1CQUFRO0lBQTVDOztRQWFhLG1CQUFjLEdBQVUsQ0FBQyxDQUFDO1FBQzFCLHFCQUFnQixHQUFVLENBQUMsQ0FBQztJQWdGekMsQ0FBQztJQTdFVSxPQUFPO1FBQ1YsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWhCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFFLEVBQUU7WUFDekIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2pCLENBQUMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUUsRUFBRTtZQUN2QixJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUEyQixFQUFDLEVBQUU7WUFDekQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFFOUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLEdBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO1lBQ3JGLElBQUksQ0FBQyxVQUFVLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztRQUN6QyxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQTJCLEVBQUMsRUFBRTtZQUUzRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRWxFLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLFNBQVMsR0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7UUFDdEQsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRU8sY0FBYztRQUVsQixJQUFJLE9BQU8sR0FBZ0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLEdBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFckcsa0NBQWUsQ0FBQyxRQUFRLENBQUMsa0NBQWUsQ0FBQyxDQUFDLFNBQVMsQ0FDL0MscUJBQVMsQ0FBQyxpQkFBaUIsRUFDM0IsT0FBTyxDQUNWLENBQUM7UUFFRixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDakIsQ0FBQztJQUdNLE1BQU0sQ0FBQyxFQUFXO1FBQ3JCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUM7UUFFbkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksR0FBRyxDQUFDLEtBQVksRUFBRSxHQUFvQixFQUFDLEVBQUU7WUFDL0QsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN4QyxDQUFDLENBQUM7UUFDRixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUd6QyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQzdCLElBQUksQ0FBQyxVQUFVLENBQUMsWUFBWSxHQUFHLENBQUMsS0FBWSxFQUFFLEdBQW9CLEVBQUMsRUFBRTtZQUNqRSxJQUFJLENBQUMsb0JBQW9CLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBQzFDLENBQUMsQ0FBQztRQUNGLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxHQUFHLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFjLEdBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQzlFLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxLQUFZLEVBQUUsR0FBb0I7UUFFekQsSUFBSSxPQUFPLEdBQW9CLEdBQUcsQ0FBQyxRQUFRLENBQUM7UUFDNUMsT0FBTyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxHQUFDLENBQUMsQ0FBQyxDQUFDO0lBRXRELENBQUM7SUFFTyxvQkFBb0IsQ0FBQyxLQUFZLEVBQUUsR0FBb0I7UUFDM0QsSUFBSSxTQUFTLEdBQW9CLEdBQUcsQ0FBQyxRQUFRLENBQUM7UUFFOUMsU0FBUyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQWMsR0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUM7UUFDdEYsc0NBQXNDO0lBQzFDLENBQUM7SUFFTSxPQUFPLENBQUMsR0FBTztRQUNsQixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBRXZCLENBQUM7Q0FHSjtBQTNGRztJQURDLHNCQUFNLENBQUMsVUFBVSxDQUFDO2dEQUNhO0FBRWhDO0lBREMsc0JBQU0sQ0FBQyxZQUFZLENBQUM7a0RBQ2E7QUFFbEM7SUFEQyxzQkFBTSxDQUFDLFNBQVMsQ0FBQzsrQ0FDZTtBQUVqQztJQURDLHNCQUFNLENBQUMsT0FBTyxDQUFDOzZDQUNlO0FBRS9CO0lBREMsc0JBQU0sQ0FBQyxPQUFPLENBQUM7NkNBQ2M7QUFYbEMsd0NBOEZDOzs7Ozs7Ozs7Ozs7Ozs7O0FDcEdELE1BQWEsWUFBWTtDQU14QjtBQU5ELG9DQU1DO0FBRUQsTUFBYyxRQUFRO0lBQXRCO1FBRVcsY0FBUyxHQUFxQyxJQUFJLEdBQUcsRUFBK0IsQ0FBQztRQUNyRixZQUFPLEdBQXNCLElBQUksR0FBRyxFQUFrQixDQUFDO0lBQ2xFLENBQUM7Q0FBQTtBQUpELDRCQUlDOzs7Ozs7Ozs7Ozs7Ozs7O0FDZkQsMkhBQWtFO0FBR2xFLE1BQWEsUUFBUyxTQUFRLHFCQUFTO0lBRW5DO1FBQ0ksS0FBSyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRU0sT0FBTztJQUVkLENBQUM7SUFDTSxVQUFVO0lBRWpCLENBQUM7SUFDTSxPQUFPO0lBRWQsQ0FBQztDQUlKO0FBbEJELDRCQWtCQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25CRCw0RkFBaUQ7QUFDakQsc0lBQWlFO0FBQ2pFLDZIQUFtRTtBQUNuRSxrSkFBaUY7QUFDakYsa0hBQTREO0FBQzVELCtHQUEwRDtBQUUxRCxNQUFhLFVBQVcsU0FBUSxtQkFBUTtJQUF4Qzs7UUFPWSx1QkFBa0IsR0FBVyxLQUFLLENBQUM7UUFDbkMsZUFBVSxHQUFzQixJQUFJLEdBQUcsRUFBaUIsQ0FBQztJQW1IckUsQ0FBQztJQWhIVSxPQUFPO1FBQ1YsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBRWhCLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLENBQUMsS0FBWSxFQUFFLEdBQW9CLEVBQUMsRUFBRTtZQUNoRSxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBMkIsRUFBQyxFQUFFO1lBQ3pELElBQUksT0FBTyxHQUFVLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvRCxJQUFHLElBQUksQ0FBQyxrQkFBa0IsRUFBQztnQkFDdkIsMkJBQVksQ0FBQyxRQUFRLENBQUMsMkJBQVksQ0FBQyxDQUFDLFlBQVksRUFBRSxDQUFDO2FBQ3REO2lCQUFJO2dCQUNELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ3hCLDJCQUFZLENBQUMsUUFBUSxDQUFDLDJCQUFZLENBQUMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUM3RTtRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVNLE1BQU0sQ0FBQyxFQUFNO1FBQ2hCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFakIseUNBQW1CLENBQUMsUUFBUSxDQUFDLHlDQUFtQixDQUFDLENBQUMsV0FBVyxDQUN6RCx5Q0FBbUIsQ0FBQyxjQUFjLEVBQ2xDLElBQUksRUFDSixJQUFJLENBQUMsY0FBYyxDQUN0QixDQUFDO1FBQ0YseUNBQW1CLENBQUMsUUFBUSxDQUFDLHlDQUFtQixDQUFDLENBQUMsV0FBVyxDQUN6RCx5Q0FBbUIsQ0FBQyxrQkFBa0IsRUFDdEMsSUFBSSxFQUNKLElBQUksQ0FBQyxrQkFBa0IsQ0FDMUIsQ0FBQztRQUNGLHlDQUFtQixDQUFDLFFBQVEsQ0FBQyx5Q0FBbUIsQ0FBQyxDQUFDLFdBQVcsQ0FDekQseUNBQW1CLENBQUMsZUFBZSxFQUNuQyxJQUFJLEVBQ0osSUFBSSxDQUFDLGVBQWUsQ0FDdkIsQ0FBQztRQUVGLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDeEIsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztRQUVoQywyQkFBWSxDQUFDLFFBQVEsQ0FBQywyQkFBWSxDQUFDLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFHTyxjQUFjLENBQ2xCLGNBQXFCLEVBQ3JCLFNBQWdCLEVBQ2hCLFdBQW9CLEVBQ3BCLGNBQXVCO1FBRXZCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztRQUV4QyxJQUFHLDJCQUFZLENBQUMsUUFBUSxDQUFDLDJCQUFZLENBQUMsQ0FBQyxXQUFXLEVBQUM7WUFDL0MsSUFBSSxDQUFDLGtCQUFrQixHQUFHLElBQUksQ0FBQztZQUUvQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7U0FDL0I7UUFFRCxJQUFHLGNBQWMsQ0FBQyxNQUFNLEdBQUMsQ0FBQyxFQUFDO1lBQ3ZCLElBQUksQ0FBQyxVQUFVLEdBQUcsY0FBYyxDQUFDO1lBQ2pDLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxLQUFLLENBQUM7WUFFaEMsSUFBSSxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztZQUNoQyxLQUFJLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFDO2dCQUN0QixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ2xEO1lBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLEdBQUcsR0FBRyxDQUFDO1NBQ2pDO0lBQ0wsQ0FBQztJQUVPLGFBQWEsQ0FBQyxLQUFZLEVBQUUsR0FBb0I7UUFDcEQsSUFBSSxXQUFXLEdBQW9CLEdBQUcsQ0FBQyxRQUFRLENBQUM7UUFFaEQsSUFBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBQyxDQUFDLEVBQUM7WUFDdEIsV0FBVyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUVqRDthQUFJO1lBQ0QsV0FBVyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUM7U0FDN0I7SUFDTCxDQUFDO0lBRU8sa0JBQWtCLENBQUMsY0FBdUI7UUFFOUMsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEtBQUssQ0FBQztRQUNoQyxPQUFPLENBQUMsR0FBRyxDQUFDLDhCQUE4QixDQUFDO0lBQy9DLENBQUM7SUFFTyxlQUFlO1FBRW5CLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUM7UUFFN0IscUJBQVMsQ0FBQyxRQUFRLENBQUMscUJBQVMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxlQUFPLENBQUMsVUFBVSxFQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFHTSxPQUFPLENBQUMsR0FBTztRQUNsQixLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5CLHlDQUFtQixDQUFDLFFBQVEsQ0FBQyx5Q0FBbUIsQ0FBQyxDQUFDLGNBQWMsQ0FDNUQseUNBQW1CLENBQUMsY0FBYyxFQUNsQyxJQUFJLENBQUMsY0FBYyxDQUN0QixDQUFDO1FBQ0YseUNBQW1CLENBQUMsUUFBUSxDQUFDLHlDQUFtQixDQUFDLENBQUMsY0FBYyxDQUM1RCx5Q0FBbUIsQ0FBQyxrQkFBa0IsRUFDdEMsSUFBSSxDQUFDLGtCQUFrQixDQUMxQixDQUFDO1FBQ0YseUNBQW1CLENBQUMsUUFBUSxDQUFDLHlDQUFtQixDQUFDLENBQUMsY0FBYyxDQUM1RCx5Q0FBbUIsQ0FBQyxlQUFlLEVBQ25DLElBQUksQ0FBQyxlQUFlLENBQ3ZCLENBQUM7SUFDTixDQUFDO0NBQ0o7QUF4SEc7SUFEQyxzQkFBTSxDQUFDLFlBQVksQ0FBQztnREFDd0I7QUFFN0M7SUFEQyxzQkFBTSxDQUFDLFNBQVMsQ0FBQzs2Q0FDZTtBQUxyQyxnQ0EySEM7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSUQsTUFBYyxVQUFVOztBQUF4QixnQ0FPQztBQUxpQixnQkFBSyxHQUFXLElBQUksQ0FBQztBQUVyQix3QkFBYSxHQUFVLFdBQVcsQ0FBQztBQUNuQywwQkFBZSxHQUFVLElBQUksQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ0poRCxvSEFBd0Q7QUFFeEQsTUFBYSxhQUFjLFNBQVEscUJBQXdCO0lBSXZEO1FBQ0ksS0FBSyxFQUFFLENBQUM7UUFISixRQUFHLEdBQVUsQ0FBQyxDQUFDO1FBS25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRU0sR0FBRztRQUVOLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFTSxJQUFJO1FBRVAsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBRXBCLENBQUM7Q0FFSjtBQXJCRCxzQ0FxQkM7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6QkQsNkdBQW9EO0FBQ3BELHNHQUE4QztBQUM5QyxvSEFBd0Q7QUFDeEQsdUhBQTREO0FBQzVELDhHQUF5RTtBQUN6RSwrSkFBc0Y7QUFDdEYsMElBQXNGO0FBQ3RGLDRGQUE4QjtBQUM5QixxRkFBNEM7QUFHNUMsTUFBYSxRQUFRO0lBSVYsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNO1FBRXRCLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0NBQXdDLENBQUMsQ0FBQztRQUN0RCxtQkFBUSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRWhCLE9BQU8sQ0FBQyxHQUFHLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUN2RCw2QkFBYSxDQUFDLFFBQVEsQ0FBQyw2QkFBYSxDQUFDLENBQUM7UUFDdEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNuQixJQUFJLEVBQUUsR0FBa0IsNkJBQWEsQ0FBQyxRQUFRLENBQUMsNkJBQWEsQ0FBQyxDQUFDO1FBQzlELElBQUksRUFBRSxHQUFrQiw2QkFBYSxDQUFDLFFBQVEsQ0FBQyw2QkFBYSxDQUFDLENBQUM7UUFFOUQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsS0FBSyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQzNDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNULE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksRUFBRSxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUMzQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLEVBQUUsR0FBRyxLQUFLLEdBQUcsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFHM0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1FBRXRELElBQUksU0FBUyxHQUFhLElBQUkscUJBQVMsRUFBRSxDQUFDO1FBQzFDLElBQUksTUFBTSxHQUFZLFVBQVMsQ0FBUSxFQUFFLENBQVE7WUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1FBQzNDLENBQUM7UUFDRCxJQUFJLE9BQU8sR0FBWSxVQUFTLENBQVEsRUFBRSxDQUFRO1lBQzlDLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQztRQUM1QyxDQUFDO1FBRUQsSUFBSyxVQUFVLEdBQVUsR0FBRyxDQUFDO1FBQzdCLFNBQVMsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFDLElBQUksRUFBRSxNQUFNLENBQUMsQ0FBQztRQUMvQyxTQUFTLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDaEQsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRTlDLFNBQVMsQ0FBQyxjQUFjLENBQUMsVUFBVSxFQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBQyxRQUFRLENBQUMsQ0FBQztRQUU5QyxTQUFTLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEIsU0FBUyxDQUFDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsR0FBRyxFQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRzlDLE9BQU8sQ0FBQyxHQUFHLENBQUMscUNBQXFDLENBQUMsQ0FBQztRQUVuRCxJQUFJLFFBQVEsR0FBRyxXQUFXLENBQUMsR0FBRSxFQUFFO1lBQzNCLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO1FBQzlCLENBQUMsRUFBQyxJQUFJLENBQUMsQ0FBQztRQUNSLElBQUksT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFFLEVBQUU7WUFDekIsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzVCLENBQUMsRUFBQyxJQUFJLENBQUMsQ0FBQztRQU1SLE9BQU8sQ0FBQyxHQUFHLENBQUMsK0NBQStDLENBQUMsQ0FBQztRQUU3RCxJQUFJLE1BQU0sR0FBRyxNQUFNLHVCQUFVLENBQUMsUUFBUSxDQUFDLHVCQUFVLENBQUMsQ0FBQyxVQUFVLENBQUMsOEJBQThCLENBQUMsQ0FBRTtRQUUvRixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXBCLDJEQUEyRDtRQUMzRCx3QkFBd0I7UUFHeEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUFDO1FBQ2xELElBQUksT0FBTyxHQUE2QixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVqQyxJQUFJLElBQUksR0FBaUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVmLElBQUksSUFBSSxHQUFpQixPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7UUFHbEIsd0RBQXdEO1FBQ3hELCtDQUErQztRQUMvQyw4Q0FBOEM7UUFDOUMseUJBQXlCO1FBRXpCLDZEQUE2RDtRQUU3RCw0RkFBNEY7UUFFNUYsMEZBQTBGO1FBQzFGLHlGQUF5RjtRQUN6RixrQ0FBa0M7UUFDbEMsMkZBQTJGO1FBRzNGLE9BQU8sQ0FBQyxHQUFHLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUl2RCxPQUFPLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDeEQsSUFBSSxRQUFRLEdBQUcsMkJBQWEsQ0FBQyxRQUFRLENBQUMsMkJBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQztRQUN6RCxJQUFJLE9BQU8sR0FBaUIsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEtBQUssTUFBTSxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDeEQsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUNyQyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBSXhCLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0NBQXdDLENBQUMsQ0FBQztRQUV0RCxJQUFHO1lBQ0MsSUFBSSxRQUFRLEdBQUc7Z0JBQ1gsU0FBUyxFQUFHLE1BQU07Z0JBQ2xCLFVBQVUsRUFBRyxNQUFNO2FBQ3RCLENBQUM7WUFHRixJQUFJO1lBQ0osSUFBSSxFQUFFLEdBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDNUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLEdBQUUsRUFBRSxDQUFDLENBQUM7WUFFL0IsSUFBSSxHQUFHLEdBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1lBQzVDLEdBQUcsQ0FBQyxPQUFPLEdBQUcsT0FBTztZQUNyQixHQUFHLENBQUMsUUFBUSxHQUFHLE1BQU07WUFDckIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7WUFFaEIsSUFBSSxHQUFHLEdBQUcsWUFBTyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO1lBRWhCLElBQUksTUFBTSxHQUFHLFlBQU8sQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUMxQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7WUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBRy9CO1FBQUEsT0FBTSxFQUFFLEVBQUM7WUFDTixPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ25CO1FBR0QsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1FBRXZELElBQUssVUFBVSxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsR0FBRyxFQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDM0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRS9CLElBQUksV0FBVyxHQUFHLElBQUksVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUV2QyxlQUFlO1FBQ2YsSUFBSSxTQUFTLEdBQUcsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkUsU0FBUyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMzQixTQUFTLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUIsSUFBSSxDQUFDLEdBQVUsSUFBSSxDQUFDO1FBQ3BCLElBQUksTUFBTSxHQUFjLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTFDLDBCQUEwQjtRQUMxQixjQUFjO1FBQ2QsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDcEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUM7UUFHckIsY0FBYztRQUNkLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUdmLENBQUMsR0FBRyxHQUFHLENBQUM7UUFDUixJQUFJLE9BQU8sR0FBYyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyQixPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUV0QixPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3JCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvQixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBR2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sbUJBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUczQiwyREFBMkQ7UUFDM0QsT0FBTztRQUNQLGdIQUFnSDtRQUNoSCx3RUFBd0U7UUFDeEUsNkJBQTZCO1FBQzdCLHVGQUF1RjtRQUN2RixxREFBcUQ7UUFHckQsNkRBQTZEO1FBQzdELGdEQUFnRDtRQUNoRCxpQ0FBaUM7UUFDakMsUUFBUTtRQUVSLGNBQWM7UUFDZCx5QkFBeUI7UUFDekIsSUFBSTtRQUlKLElBQUc7WUFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7WUFFcEQsK0NBQXNCLENBQUMsUUFBUSxDQUFDLCtDQUFzQixDQUFDLENBQUMsV0FBVyxDQUMvRCw4QkFBWSxDQUFDLElBQUksRUFDakIsSUFBSSxFQUNKO2dCQUNJLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQ0osQ0FBQztZQUNGLCtDQUFzQixDQUFDLFFBQVEsQ0FBQywrQ0FBc0IsQ0FBQyxDQUFDLFdBQVcsQ0FDL0QsOEJBQVksQ0FBQyxXQUFXLEVBQ3hCLElBQUksRUFDSjtnQkFDSSxPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixDQUFDLENBQUM7WUFDNUMsQ0FBQyxDQUNKLENBQUM7WUFDRiwrQ0FBc0IsQ0FBQyxRQUFRLENBQUMsK0NBQXNCLENBQUMsQ0FBQyxXQUFXLENBQy9ELDhCQUFZLENBQUMsV0FBVyxFQUN4QixJQUFJLEVBQ0o7Z0JBQ0ksT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQ3JDLENBQUMsQ0FDSixDQUFDO1lBRUYsaUNBQWUsQ0FBQyxRQUFRLENBQUMsaUNBQWUsQ0FBQyxDQUFDLHFCQUFxQixDQUMzRCw4QkFBWSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQ2pDLENBQUM7WUFDRixJQUFJLE1BQU0sR0FBRyxpQ0FBZSxDQUFDLFFBQVEsQ0FBQyxpQ0FBZSxDQUFDLENBQUMsY0FBYyxDQUNqRSw4QkFBWSxDQUFDLElBQUksQ0FDcEIsQ0FBRTtZQUNILElBQUksYUFBYSxHQUFHLGlDQUFlLENBQUMsUUFBUSxDQUFDLGlDQUFlLENBQUMsQ0FBQyxjQUFjLENBQ3hFLDhCQUFZLENBQUMsV0FBVyxDQUMzQixDQUFFO1lBQ0gsSUFBSSxhQUFhLEdBQUcsaUNBQWUsQ0FBQyxRQUFRLENBQUMsaUNBQWUsQ0FBQyxDQUFDLGNBQWMsQ0FDeEUsOEJBQVksQ0FBQyxXQUFXLENBQzNCLENBQUU7WUFDSCxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxhQUFhLEVBQUUsYUFBYSxDQUFDO1NBRXBEO1FBQUEsT0FBTSxLQUFLLEVBQUM7WUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztTQUNyQjtRQUlELElBQUc7WUFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLHlDQUF5QyxDQUFDLENBQUM7WUFHdkQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sdUJBQVUsQ0FBQyxRQUFRLENBQUMsdUJBQVUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1lBQ3BHLElBQUksS0FBSyxHQUFHLElBQUksYUFBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVCLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDdkMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLGtCQUFrQixFQUFDLEdBQUUsRUFBRTtnQkFDOUMsT0FBTyxhQUFhLENBQUM7WUFDekIsQ0FBQyxDQUFDO1lBQ0YsS0FBSyxDQUFDLDJCQUEyQixDQUFDLDhCQUE4QixFQUFDLENBQUMsSUFBTyxFQUFDLEVBQUU7Z0JBQ3hFLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUN6QixPQUFPLE1BQU0sQ0FBQztZQUNsQixDQUFDLENBQUM7WUFFRixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBQzlCLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDOUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUNqQztRQUFBLE9BQU0sS0FBSyxFQUFDO1lBQ1QsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7U0FDckI7SUFHTCxDQUFDOztBQS9RTCw0QkFtUkM7QUFsUmlCLGdCQUFPLEdBQVUsS0FBSyxDQUFDOzs7Ozs7Ozs7Ozs7QUNaekMsbUM7Ozs7Ozs7Ozs7O0FDQUEsbUMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvR2FtZU1haW4udHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQSBtaW5pbWFsIGV2ZW50IGVtaXR0ZXIuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIExpc3RlbmVyXHJcbiAqIEBwYXJhbSB7Kn0gW2N0eF0gTGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xyXG4gICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgZm4gIDogZm4sXHJcbiAgICAgICAgY3R4IDogY3R4IHx8IHRoaXNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBvciBhbnkgbWF0Y2hpbmcgbGlzdGVuZXJzIGlmIGFyZ3VtZW50cyBhcmUgb21pdHRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIEV2ZW50IG5hbWUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBpZiBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIExpc3RlbmVyIHRvIHJlbW92ZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIG9mIGBldnRgIGlmIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XHJcbiAgICBpZiAoZXZ0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdHMgYW4gZXZlbnQgYnkgY2FsbGluZyBpdHMgbGlzdGVuZXJzIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSgodD10fHxzZWxmKS5pbmtqcz17fSl9KHRoaXMsKGZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO2NsYXNzIGV7Y29uc3RydWN0b3IoKXtpZih0aGlzLl9jb21wb25lbnRzPVtdLHRoaXMuX2NvbXBvbmVudHNTdHJpbmc9bnVsbCx0aGlzLl9pc1JlbGF0aXZlPSExLFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2xldCB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXBvbmVudHNTdHJpbmc9dH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZS5Db21wb25lbnQmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZSl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2NvbXBvbmVudHMucHVzaCh0KSx0aGlzLl9jb21wb25lbnRzPXRoaXMuX2NvbXBvbmVudHMuY29uY2F0KGUuX2NvbXBvbmVudHMpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9ISFhcmd1bWVudHNbMV07dGhpcy5fY29tcG9uZW50cz10aGlzLl9jb21wb25lbnRzLmNvbmNhdCh0KSx0aGlzLl9pc1JlbGF0aXZlPWV9fWdldCBpc1JlbGF0aXZlKCl7cmV0dXJuIHRoaXMuX2lzUmVsYXRpdmV9Z2V0IGNvbXBvbmVudENvdW50KCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RofWdldCBoZWFkKCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoPjA/dGhpcy5fY29tcG9uZW50c1swXTpudWxsfWdldCB0YWlsKCl7aWYodGhpcy5fY29tcG9uZW50cy5sZW5ndGg+PTIpe2xldCB0PXRoaXMuX2NvbXBvbmVudHMuc2xpY2UoMSx0aGlzLl9jb21wb25lbnRzLmxlbmd0aCk7cmV0dXJuIG5ldyBlKHQpfXJldHVybiBlLnNlbGZ9Z2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aH1nZXQgbGFzdENvbXBvbmVudCgpe2xldCB0PXRoaXMuX2NvbXBvbmVudHMubGVuZ3RoLTE7cmV0dXJuIHQ+PTA/dGhpcy5fY29tcG9uZW50c1t0XTpudWxsfWdldCBjb250YWluc05hbWVkQ29tcG9uZW50KCl7Zm9yKGxldCB0PTAsZT10aGlzLl9jb21wb25lbnRzLmxlbmd0aDt0PGU7dCsrKWlmKCF0aGlzLl9jb21wb25lbnRzW3RdLmlzSW5kZXgpcmV0dXJuITA7cmV0dXJuITF9c3RhdGljIGdldCBzZWxmKCl7bGV0IHQ9bmV3IGU7cmV0dXJuIHQuX2lzUmVsYXRpdmU9ITAsdH1HZXRDb21wb25lbnQodCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbdF19UGF0aEJ5QXBwZW5kaW5nUGF0aCh0KXtsZXQgbj1uZXcgZSxpPTA7Zm9yKGxldCBlPTA7ZTx0Ll9jb21wb25lbnRzLmxlbmd0aCYmdC5fY29tcG9uZW50c1tlXS5pc1BhcmVudDsrK2UpaSsrO2ZvcihsZXQgdD0wO3Q8dGhpcy5fY29tcG9uZW50cy5sZW5ndGgtaTsrK3Qpbi5fY29tcG9uZW50cy5wdXNoKHRoaXMuX2NvbXBvbmVudHNbdF0pO2ZvcihsZXQgZT1pO2U8dC5fY29tcG9uZW50cy5sZW5ndGg7KytlKW4uX2NvbXBvbmVudHMucHVzaCh0Ll9jb21wb25lbnRzW2VdKTtyZXR1cm4gbn1nZXQgY29tcG9uZW50c1N0cmluZygpe3JldHVybiBudWxsPT10aGlzLl9jb21wb25lbnRzU3RyaW5nJiYodGhpcy5fY29tcG9uZW50c1N0cmluZz10aGlzLl9jb21wb25lbnRzLmpvaW4oXCIuXCIpLHRoaXMuaXNSZWxhdGl2ZSYmKHRoaXMuX2NvbXBvbmVudHNTdHJpbmc9XCIuXCIrdGhpcy5fY29tcG9uZW50c1N0cmluZykpLHRoaXMuX2NvbXBvbmVudHNTdHJpbmd9c2V0IGNvbXBvbmVudHNTdHJpbmcodCl7aWYodGhpcy5fY29tcG9uZW50cy5sZW5ndGg9MCx0aGlzLl9jb21wb25lbnRzU3RyaW5nPXQsbnVsbD09dGhpcy5fY29tcG9uZW50c1N0cmluZ3x8XCJcIj09dGhpcy5fY29tcG9uZW50c1N0cmluZylyZXR1cm47XCIuXCI9PXRoaXMuX2NvbXBvbmVudHNTdHJpbmdbMF0mJih0aGlzLl9pc1JlbGF0aXZlPSEwLHRoaXMuX2NvbXBvbmVudHNTdHJpbmc9dGhpcy5fY29tcG9uZW50c1N0cmluZy5zdWJzdHJpbmcoMSkpO2xldCBuPXRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3BsaXQoXCIuXCIpO2ZvcihsZXQgdCBvZiBuKS9eKFxcLXxcXCspPyhbMC05XSt8SW5maW5pdHkpJC8udGVzdCh0KT90aGlzLl9jb21wb25lbnRzLnB1c2gobmV3IGUuQ29tcG9uZW50KHBhcnNlSW50KHQpKSk6dGhpcy5fY29tcG9uZW50cy5wdXNoKG5ldyBlLkNvbXBvbmVudCh0KSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb21wb25lbnRzU3RyaW5nfUVxdWFscyh0KXtpZihudWxsPT10KXJldHVybiExO2lmKHQuX2NvbXBvbmVudHMubGVuZ3RoIT10aGlzLl9jb21wb25lbnRzLmxlbmd0aClyZXR1cm4hMTtpZih0LmlzUmVsYXRpdmUhPXRoaXMuaXNSZWxhdGl2ZSlyZXR1cm4hMTtmb3IobGV0IGU9MCxuPXQuX2NvbXBvbmVudHMubGVuZ3RoO2U8bjtlKyspaWYoIXQuX2NvbXBvbmVudHNbZV0uRXF1YWxzKHRoaXMuX2NvbXBvbmVudHNbZV0pKXJldHVybiExO3JldHVybiEwfVBhdGhCeUFwcGVuZGluZ0NvbXBvbmVudCh0KXtsZXQgbj1uZXcgZTtyZXR1cm4gbi5fY29tcG9uZW50cy5wdXNoLmFwcGx5KG4uX2NvbXBvbmVudHMsdGhpcy5fY29tcG9uZW50cyksbi5fY29tcG9uZW50cy5wdXNoKHQpLG59fXZhciBuLGkscjtmdW5jdGlvbiBhKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBlP2godCk6bnVsbH1mdW5jdGlvbiBzKHQsZSl7aWYodCBpbnN0YW5jZW9mIGUpcmV0dXJuIGgodCk7dGhyb3cgbmV3IEVycm9yKGAke3R9IGlzIG5vdCBvZiB0eXBlICR7ZX1gKX1mdW5jdGlvbiBsKHQpe3JldHVybiB0Lmhhc1ZhbGlkTmFtZSYmdC5uYW1lP3Q6bnVsbH1mdW5jdGlvbiBvKHQpe3JldHVybiB2b2lkIDA9PT10P251bGw6dH1mdW5jdGlvbiB1KHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0JiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LkVxdWFsc31mdW5jdGlvbiBoKHQsZSl7cmV0dXJuIHR9ZS5wYXJlbnRJZD1cIl5cIixmdW5jdGlvbih0KXtjbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaW5kZXg9LTEsdGhpcy5uYW1lPW51bGwsXCJzdHJpbmdcIj09dHlwZW9mIHQ/dGhpcy5uYW1lPXQ6dGhpcy5pbmRleD10fWdldCBpc0luZGV4KCl7cmV0dXJuIHRoaXMuaW5kZXg+PTB9Z2V0IGlzUGFyZW50KCl7cmV0dXJuIHRoaXMubmFtZT09dC5wYXJlbnRJZH1zdGF0aWMgVG9QYXJlbnQoKXtyZXR1cm4gbmV3IGUodC5wYXJlbnRJZCl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5pc0luZGV4P3RoaXMuaW5kZXgudG9TdHJpbmcoKTp0aGlzLm5hbWV9RXF1YWxzKHQpe3JldHVybiBudWxsIT10JiZ0LmlzSW5kZXg9PXRoaXMuaXNJbmRleCYmKHRoaXMuaXNJbmRleD90aGlzLmluZGV4PT10LmluZGV4OnRoaXMubmFtZT09dC5uYW1lKX19dC5Db21wb25lbnQ9ZX0oZXx8KGU9e30pKSxmdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7aWYoIXQpdGhyb3cgdm9pZCAwIT09ZSYmY29uc29sZS53YXJuKGUpLGNvbnNvbGUudHJhY2UmJmNvbnNvbGUudHJhY2UoKSxuZXcgRXJyb3IoXCJcIil9dC5Bc3NlcnRUeXBlPWZ1bmN0aW9uKHQsbixpKXtlKHQgaW5zdGFuY2VvZiBuLGkpfSx0LkFzc2VydD1lfShufHwobj17fSkpO2NsYXNzIGMgZXh0ZW5kcyBFcnJvcnt9ZnVuY3Rpb24gZCh0KXt0aHJvdyBuZXcgYyh0K1wiIGlzIG51bGwgb3IgdW5kZWZpbmVkXCIpfWNsYXNzIHB7Y29uc3RydWN0b3IoKXt0aGlzLnBhcmVudD1udWxsLHRoaXMuX2RlYnVnTWV0YWRhdGE9bnVsbCx0aGlzLl9wYXRoPW51bGx9Z2V0IGRlYnVnTWV0YWRhdGEoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2RlYnVnTWV0YWRhdGEmJnRoaXMucGFyZW50P3RoaXMucGFyZW50LmRlYnVnTWV0YWRhdGE6dGhpcy5fZGVidWdNZXRhZGF0YX1zZXQgZGVidWdNZXRhZGF0YSh0KXt0aGlzLl9kZWJ1Z01ldGFkYXRhPXR9Z2V0IG93bkRlYnVnTWV0YWRhdGEoKXtyZXR1cm4gdGhpcy5fZGVidWdNZXRhZGF0YX1EZWJ1Z0xpbmVOdW1iZXJPZlBhdGgodCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7bGV0IGU9dGhpcy5yb290Q29udGVudENvbnRhaW5lcjtpZihlKXtsZXQgbj1lLkNvbnRlbnRBdFBhdGgodCkub2JqO2lmKG4pe2xldCB0PW4uZGVidWdNZXRhZGF0YTtpZihudWxsIT09dClyZXR1cm4gdC5zdGFydExpbmVOdW1iZXJ9fXJldHVybiBudWxsfWdldCBwYXRoKCl7aWYobnVsbD09dGhpcy5fcGF0aClpZihudWxsPT10aGlzLnBhcmVudCl0aGlzLl9wYXRoPW5ldyBlO2Vsc2V7bGV0IHQ9W10sbj10aGlzLGk9YShuLnBhcmVudCxOKTtmb3IoO251bGwhPT1pOyl7bGV0IHI9bChuKTtudWxsIT1yJiZyLmhhc1ZhbGlkTmFtZT90LnVuc2hpZnQobmV3IGUuQ29tcG9uZW50KHIubmFtZSkpOnQudW5zaGlmdChuZXcgZS5Db21wb25lbnQoaS5jb250ZW50LmluZGV4T2YobikpKSxuPWksaT1hKGkucGFyZW50LE4pfXRoaXMuX3BhdGg9bmV3IGUodCl9cmV0dXJuIHRoaXMuX3BhdGh9UmVzb2x2ZVBhdGgodCl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJwYXRoXCIpO2lmKHQuaXNSZWxhdGl2ZSl7bGV0IGU9YSh0aGlzLE4pO3JldHVybiBudWxsPT09ZSYmKG4uQXNzZXJ0KG51bGwhPT10aGlzLnBhcmVudCxcIkNhbid0IHJlc29sdmUgcmVsYXRpdmUgcGF0aCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYSBwYXJlbnRcIiksZT1hKHRoaXMucGFyZW50LE4pLG4uQXNzZXJ0KG51bGwhPT1lLFwiRXhwZWN0ZWQgcGFyZW50IHRvIGJlIGEgY29udGFpbmVyXCIpLG4uQXNzZXJ0KHQuR2V0Q29tcG9uZW50KDApLmlzUGFyZW50KSx0PXQudGFpbCksbnVsbD09PWU/ZChcIm5lYXJlc3RDb250YWluZXJcIik6ZS5Db250ZW50QXRQYXRoKHQpfXtsZXQgZT10aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO3JldHVybiBudWxsPT09ZT9kKFwiY29udGVudENvbnRhaW5lclwiKTplLkNvbnRlbnRBdFBhdGgodCl9fUNvbnZlcnRQYXRoVG9SZWxhdGl2ZSh0KXtsZXQgbj10aGlzLnBhdGgsaT1NYXRoLm1pbih0Lmxlbmd0aCxuLmxlbmd0aCkscj0tMTtmb3IobGV0IGU9MDtlPGk7KytlKXtsZXQgaT1uLkdldENvbXBvbmVudChlKSxhPXQuR2V0Q29tcG9uZW50KGUpO2lmKCFpLkVxdWFscyhhKSlicmVhaztyPWV9aWYoLTE9PXIpcmV0dXJuIHQ7bGV0IGE9bi5jb21wb25lbnRDb3VudC0xLXIscz1bXTtmb3IobGV0IHQ9MDt0PGE7Kyt0KXMucHVzaChlLkNvbXBvbmVudC5Ub1BhcmVudCgpKTtmb3IobGV0IGU9cisxO2U8dC5jb21wb25lbnRDb3VudDsrK2Upcy5wdXNoKHQuR2V0Q29tcG9uZW50KGUpKTtyZXR1cm4gbmV3IGUocywhMCl9Q29tcGFjdFBhdGhTdHJpbmcodCl7bGV0IGU9bnVsbCxuPW51bGw7aWYodC5pc1JlbGF0aXZlKW49dC5jb21wb25lbnRzU3RyaW5nLGU9dGhpcy5wYXRoLlBhdGhCeUFwcGVuZGluZ1BhdGgodCkuY29tcG9uZW50c1N0cmluZztlbHNle249dGhpcy5Db252ZXJ0UGF0aFRvUmVsYXRpdmUodCkuY29tcG9uZW50c1N0cmluZyxlPXQuY29tcG9uZW50c1N0cmluZ31yZXR1cm4gbi5sZW5ndGg8ZS5sZW5ndGg/bjplfWdldCByb290Q29udGVudENvbnRhaW5lcigpe2xldCB0PXRoaXM7Zm9yKDt0LnBhcmVudDspdD10LnBhcmVudDtyZXR1cm4gYSh0LE4pfUNvcHkoKXt0aHJvdyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZDogRG9lc24ndCBzdXBwb3J0IGNvcHlpbmdcIil9U2V0Q2hpbGQodCxlLG4pe3RbZV0mJih0W2VdPW51bGwpLHRbZV09bix0W2VdJiYodFtlXS5wYXJlbnQ9dGhpcyl9fWNsYXNzIG17Y29uc3RydWN0b3IodCl7dD12b2lkIDAhPT10P3QudG9TdHJpbmcoKTpcIlwiLHRoaXMuc3RyaW5nPXR9Z2V0IExlbmd0aCgpe3JldHVybiB0aGlzLnN0cmluZy5sZW5ndGh9QXBwZW5kKHQpe251bGwhPT10JiYodGhpcy5zdHJpbmcrPXQpfUFwcGVuZExpbmUodCl7dm9pZCAwIT09dCYmdGhpcy5BcHBlbmQodCksdGhpcy5zdHJpbmcrPVwiXFxuXCJ9QXBwZW5kRm9ybWF0KHQsLi4uZSl7dGhpcy5zdHJpbmcrPXQucmVwbGFjZSgveyhcXGQrKX0vZywodCxuKT0+dm9pZCAwIT09ZVtuXT9lW25dOnQpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RyaW5nfX1jbGFzcyBme2NvbnN0cnVjdG9yKCl7aWYodGhpcy5vcmlnaW5OYW1lPW51bGwsdGhpcy5pdGVtTmFtZT1udWxsLHZvaWQgMCE9PWFyZ3VtZW50c1sxXSl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMub3JpZ2luTmFtZT10LHRoaXMuaXRlbU5hbWU9ZX1lbHNlIGlmKGFyZ3VtZW50c1swXSl7bGV0IHQ9YXJndW1lbnRzWzBdLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO3RoaXMub3JpZ2luTmFtZT10WzBdLHRoaXMuaXRlbU5hbWU9dFsxXX19c3RhdGljIGdldCBOdWxsKCl7cmV0dXJuIG5ldyBmKG51bGwsbnVsbCl9Z2V0IGlzTnVsbCgpe3JldHVybiBudWxsPT10aGlzLm9yaWdpbk5hbWUmJm51bGw9PXRoaXMuaXRlbU5hbWV9Z2V0IGZ1bGxOYW1lKCl7cmV0dXJuKG51bGwhPT10aGlzLm9yaWdpbk5hbWU/dGhpcy5vcmlnaW5OYW1lOlwiP1wiKStcIi5cIit0aGlzLml0ZW1OYW1lfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuZnVsbE5hbWV9RXF1YWxzKHQpe2lmKHQgaW5zdGFuY2VvZiBmKXtsZXQgZT10O3JldHVybiBlLml0ZW1OYW1lPT10aGlzLml0ZW1OYW1lJiZlLm9yaWdpbk5hbWU9PXRoaXMub3JpZ2luTmFtZX1yZXR1cm4hMX1jb3B5KCl7cmV0dXJuIG5ldyBmKHRoaXMub3JpZ2luTmFtZSx0aGlzLml0ZW1OYW1lKX1zZXJpYWxpemVkKCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHtvcmlnaW5OYW1lOnRoaXMub3JpZ2luTmFtZSxpdGVtTmFtZTp0aGlzLml0ZW1OYW1lfSl9c3RhdGljIGZyb21TZXJpYWxpemVkS2V5KHQpe2xldCBlPUpTT04ucGFyc2UodCk7aWYoIWYuaXNMaWtlSW5rTGlzdEl0ZW0oZSkpcmV0dXJuIGYuTnVsbDtsZXQgbj1lO3JldHVybiBuZXcgZihuLm9yaWdpbk5hbWUsbi5pdGVtTmFtZSl9c3RhdGljIGlzTGlrZUlua0xpc3RJdGVtKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0JiYoISghdC5oYXNPd25Qcm9wZXJ0eShcIm9yaWdpbk5hbWVcIil8fCF0Lmhhc093blByb3BlcnR5KFwiaXRlbU5hbWVcIikpJiYoKFwic3RyaW5nXCI9PXR5cGVvZiB0Lm9yaWdpbk5hbWV8fG51bGw9PT10eXBlb2YgdC5vcmlnaW5OYW1lKSYmKFwic3RyaW5nXCI9PXR5cGVvZiB0Lml0ZW1OYW1lfHxudWxsPT09dHlwZW9mIHQuaXRlbU5hbWUpKSl9fWNsYXNzIGcgZXh0ZW5kcyBNYXB7Y29uc3RydWN0b3IoKXtpZihzdXBlcihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGc/YXJndW1lbnRzWzBdOltdKSx0aGlzLm9yaWdpbnM9bnVsbCx0aGlzLl9vcmlnaW5OYW1lcz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe2xldCB0PWFyZ3VtZW50c1swXTt0Ll9vcmlnaW5OYW1lcyYmKHRoaXMuX29yaWdpbk5hbWVzPXQuX29yaWdpbk5hbWVzLnNsaWNlKCkpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuU2V0SW5pdGlhbE9yaWdpbk5hbWUodCk7bGV0IG49ZS5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24odCxudWxsKTtpZighbi5leGlzdHMpdGhyb3cgbmV3IEVycm9yKFwiSW5rTGlzdCBvcmlnaW4gY291bGQgbm90IGJlIGZvdW5kIGluIHN0b3J5IHdoZW4gY29uc3RydWN0aW5nIG5ldyBsaXN0OiBcIit0KTt0aGlzLm9yaWdpbnM9W24ucmVzdWx0XX1lbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJmFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSYmYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiVmFsdWVcIikpe2xldCB0PWFyZ3VtZW50c1swXTt0aGlzLkFkZCh0LktleSx0LlZhbHVlKX19QWRkSXRlbSh0KXtpZih0IGluc3RhbmNlb2YgZil7bGV0IGU9dDtpZihudWxsPT1lLm9yaWdpbk5hbWUpcmV0dXJuIHZvaWQgdGhpcy5BZGRJdGVtKGUuaXRlbU5hbWUpO2lmKG51bGw9PT10aGlzLm9yaWdpbnMpcmV0dXJuIGQoXCJ0aGlzLm9yaWdpbnNcIik7Zm9yKGxldCB0IG9mIHRoaXMub3JpZ2lucylpZih0Lm5hbWU9PWUub3JpZ2luTmFtZSl7bGV0IG49dC5UcnlHZXRWYWx1ZUZvckl0ZW0oZSwwKTtpZihuLmV4aXN0cylyZXR1cm4gdm9pZCB0aGlzLkFkZChlLG4ucmVzdWx0KTt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiK2UrXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgbGlzdCBkZWZpbml0aW9uIGluIGluay5cIil9dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGFkZCBpdGVtIHRvIGxpc3QgYmVjYXVzZSB0aGUgaXRlbSB3YXMgZnJvbSBhIG5ldyBsaXN0IGRlZmluaXRpb24gdGhhdCB3YXNuJ3QgcHJldmlvdXNseSBrbm93biB0byB0aGlzIGxpc3QuIE9ubHkgaXRlbXMgZnJvbSBwcmV2aW91c2x5IGtub3duIGxpc3RzIGNhbiBiZSB1c2VkLCBzbyB0aGF0IHRoZSBpbnQgdmFsdWUgY2FuIGJlIGZvdW5kLlwiKX17bGV0IGU9dCxuPW51bGw7aWYobnVsbD09PXRoaXMub3JpZ2lucylyZXR1cm4gZChcInRoaXMub3JpZ2luc1wiKTtmb3IobGV0IHQgb2YgdGhpcy5vcmlnaW5zKXtpZihudWxsPT09ZSlyZXR1cm4gZChcIml0ZW1OYW1lXCIpO2lmKHQuQ29udGFpbnNJdGVtV2l0aE5hbWUoZSkpe2lmKG51bGwhPW4pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIitlK1wiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGNvdWxkIGNvbWUgZnJvbSBlaXRoZXIgXCIrdC5uYW1lK1wiIG9yIFwiK24ubmFtZSk7bj10fX1pZihudWxsPT1uKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIrZStcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBpc24ndCBrbm93biB0byBhbnkgbGlzdCBkZWZpbml0aW9ucyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QuXCIpO2xldCBpPW5ldyBmKG4ubmFtZSxlKSxyPW4uVmFsdWVGb3JJdGVtKGkpO3RoaXMuQWRkKGkscil9fUNvbnRhaW5zSXRlbU5hbWVkKHQpe2ZvcihsZXRbZV1vZiB0aGlzKXtpZihmLmZyb21TZXJpYWxpemVkS2V5KGUpLml0ZW1OYW1lPT10KXJldHVybiEwfXJldHVybiExfUNvbnRhaW5zS2V5KHQpe3JldHVybiB0aGlzLmhhcyh0LnNlcmlhbGl6ZWQoKSl9QWRkKHQsZSl7bGV0IG49dC5zZXJpYWxpemVkKCk7aWYodGhpcy5oYXMobikpdGhyb3cgbmV3IEVycm9yKFwiVGhlIE1hcCBhbHJlYWR5IGNvbnRhaW5zIGFuIGVudHJ5IGZvciBcIit0KTt0aGlzLnNldChuLGUpfVJlbW92ZSh0KXtyZXR1cm4gdGhpcy5kZWxldGUodC5zZXJpYWxpemVkKCkpfWdldCBDb3VudCgpe3JldHVybiB0aGlzLnNpemV9Z2V0IG9yaWdpbk9mTWF4SXRlbSgpe2lmKG51bGw9PXRoaXMub3JpZ2lucylyZXR1cm4gbnVsbDtsZXQgdD10aGlzLm1heEl0ZW0uS2V5Lm9yaWdpbk5hbWUsZT1udWxsO3JldHVybiB0aGlzLm9yaWdpbnMuZXZlcnkobj0+bi5uYW1lIT10fHwoZT1uLCExKSksZX1nZXQgb3JpZ2luTmFtZXMoKXtpZih0aGlzLkNvdW50PjApe251bGw9PXRoaXMuX29yaWdpbk5hbWVzJiZ0aGlzLkNvdW50PjA/dGhpcy5fb3JpZ2luTmFtZXM9W106KHRoaXMuX29yaWdpbk5hbWVzfHwodGhpcy5fb3JpZ2luTmFtZXM9W10pLHRoaXMuX29yaWdpbk5hbWVzLmxlbmd0aD0wKTtmb3IobGV0W3Rdb2YgdGhpcyl7bGV0IGU9Zi5mcm9tU2VyaWFsaXplZEtleSh0KTtpZihudWxsPT09ZS5vcmlnaW5OYW1lKXJldHVybiBkKFwiaXRlbS5vcmlnaW5OYW1lXCIpO3RoaXMuX29yaWdpbk5hbWVzLnB1c2goZS5vcmlnaW5OYW1lKX19cmV0dXJuIHRoaXMuX29yaWdpbk5hbWVzfVNldEluaXRpYWxPcmlnaW5OYW1lKHQpe3RoaXMuX29yaWdpbk5hbWVzPVt0XX1TZXRJbml0aWFsT3JpZ2luTmFtZXModCl7dGhpcy5fb3JpZ2luTmFtZXM9bnVsbD09dD9udWxsOnQuc2xpY2UoKX1nZXQgbWF4SXRlbSgpe2xldCB0PXtLZXk6Zi5OdWxsLFZhbHVlOjB9O2ZvcihsZXRbZSxuXW9mIHRoaXMpe2xldCBpPWYuZnJvbVNlcmlhbGl6ZWRLZXkoZSk7KHQuS2V5LmlzTnVsbHx8bj50LlZhbHVlKSYmKHQ9e0tleTppLFZhbHVlOm59KX1yZXR1cm4gdH1nZXQgbWluSXRlbSgpe2xldCB0PXtLZXk6Zi5OdWxsLFZhbHVlOjB9O2ZvcihsZXRbZSxuXW9mIHRoaXMpe2xldCBpPWYuZnJvbVNlcmlhbGl6ZWRLZXkoZSk7KHQuS2V5LmlzTnVsbHx8bjx0LlZhbHVlKSYmKHQ9e0tleTppLFZhbHVlOm59KX1yZXR1cm4gdH1nZXQgaW52ZXJzZSgpe2xldCB0PW5ldyBnO2lmKG51bGwhPXRoaXMub3JpZ2lucylmb3IobGV0IGUgb2YgdGhpcy5vcmlnaW5zKWZvcihsZXRbbixpXW9mIGUuaXRlbXMpe2xldCBlPWYuZnJvbVNlcmlhbGl6ZWRLZXkobik7dGhpcy5Db250YWluc0tleShlKXx8dC5BZGQoZSxpKX1yZXR1cm4gdH1nZXQgYWxsKCl7bGV0IHQ9bmV3IGc7aWYobnVsbCE9dGhpcy5vcmlnaW5zKWZvcihsZXQgZSBvZiB0aGlzLm9yaWdpbnMpZm9yKGxldFtuLGldb2YgZS5pdGVtcyl7bGV0IGU9Zi5mcm9tU2VyaWFsaXplZEtleShuKTt0LnNldChlLnNlcmlhbGl6ZWQoKSxpKX1yZXR1cm4gdH1Vbmlvbih0KXtsZXQgZT1uZXcgZyh0aGlzKTtmb3IobGV0W24saV1vZiB0KWUuc2V0KG4saSk7cmV0dXJuIGV9SW50ZXJzZWN0KHQpe2xldCBlPW5ldyBnO2ZvcihsZXRbbixpXW9mIHRoaXMpdC5oYXMobikmJmUuc2V0KG4saSk7cmV0dXJuIGV9V2l0aG91dCh0KXtsZXQgZT1uZXcgZyh0aGlzKTtmb3IobGV0W25db2YgdCllLmRlbGV0ZShuKTtyZXR1cm4gZX1Db250YWlucyh0KXtmb3IobGV0W2Vdb2YgdClpZighdGhpcy5oYXMoZSkpcmV0dXJuITE7cmV0dXJuITB9R3JlYXRlclRoYW4odCl7cmV0dXJuIDAhPXRoaXMuQ291bnQmJigwPT10LkNvdW50fHx0aGlzLm1pbkl0ZW0uVmFsdWU+dC5tYXhJdGVtLlZhbHVlKX1HcmVhdGVyVGhhbk9yRXF1YWxzKHQpe3JldHVybiAwIT10aGlzLkNvdW50JiYoMD09dC5Db3VudHx8dGhpcy5taW5JdGVtLlZhbHVlPj10Lm1pbkl0ZW0uVmFsdWUmJnRoaXMubWF4SXRlbS5WYWx1ZT49dC5tYXhJdGVtLlZhbHVlKX1MZXNzVGhhbih0KXtyZXR1cm4gMCE9dC5Db3VudCYmKDA9PXRoaXMuQ291bnR8fHRoaXMubWF4SXRlbS5WYWx1ZTx0Lm1pbkl0ZW0uVmFsdWUpfUxlc3NUaGFuT3JFcXVhbHModCl7cmV0dXJuIDAhPXQuQ291bnQmJigwPT10aGlzLkNvdW50fHx0aGlzLm1heEl0ZW0uVmFsdWU8PXQubWF4SXRlbS5WYWx1ZSYmdGhpcy5taW5JdGVtLlZhbHVlPD10Lm1pbkl0ZW0uVmFsdWUpfU1heEFzTGlzdCgpe3JldHVybiB0aGlzLkNvdW50PjA/bmV3IGcodGhpcy5tYXhJdGVtKTpuZXcgZ31NaW5Bc0xpc3QoKXtyZXR1cm4gdGhpcy5Db3VudD4wP25ldyBnKHRoaXMubWluSXRlbSk6bmV3IGd9TGlzdFdpdGhTdWJSYW5nZSh0LGUpe2lmKDA9PXRoaXMuQ291bnQpcmV0dXJuIG5ldyBnO2xldCBuPXRoaXMub3JkZXJlZEl0ZW1zLGk9MCxyPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO051bWJlci5pc0ludGVnZXIodCk/aT10OnQgaW5zdGFuY2VvZiBnJiZ0LkNvdW50PjAmJihpPXQubWluSXRlbS5WYWx1ZSksTnVtYmVyLmlzSW50ZWdlcihlKT9yPWU6dCBpbnN0YW5jZW9mIGcmJnQuQ291bnQ+MCYmKHI9ZS5tYXhJdGVtLlZhbHVlKTtsZXQgYT1uZXcgZzthLlNldEluaXRpYWxPcmlnaW5OYW1lcyh0aGlzLm9yaWdpbk5hbWVzKTtmb3IobGV0IHQgb2Ygbil0LlZhbHVlPj1pJiZ0LlZhbHVlPD1yJiZhLkFkZCh0LktleSx0LlZhbHVlKTtyZXR1cm4gYX1FcXVhbHModCl7aWYodCBpbnN0YW5jZW9mIGc9PSExKXJldHVybiExO2lmKHQuQ291bnQhPXRoaXMuQ291bnQpcmV0dXJuITE7Zm9yKGxldFtlXW9mIHRoaXMpaWYoIXQuaGFzKGUpKXJldHVybiExO3JldHVybiEwfWdldCBvcmRlcmVkSXRlbXMoKXtsZXQgdD1uZXcgQXJyYXk7Zm9yKGxldFtlLG5db2YgdGhpcyl7bGV0IGk9Zi5mcm9tU2VyaWFsaXplZEtleShlKTt0LnB1c2goe0tleTppLFZhbHVlOm59KX1yZXR1cm4gdC5zb3J0KCh0LGUpPT5udWxsPT09dC5LZXkub3JpZ2luTmFtZT9kKFwieC5LZXkub3JpZ2luTmFtZVwiKTpudWxsPT09ZS5LZXkub3JpZ2luTmFtZT9kKFwieS5LZXkub3JpZ2luTmFtZVwiKTp0LlZhbHVlPT1lLlZhbHVlP3QuS2V5Lm9yaWdpbk5hbWUubG9jYWxlQ29tcGFyZShlLktleS5vcmlnaW5OYW1lKTp0LlZhbHVlPGUuVmFsdWU/LTE6dC5WYWx1ZT5lLlZhbHVlPzE6MCksdH10b1N0cmluZygpe2xldCB0PXRoaXMub3JkZXJlZEl0ZW1zLGU9bmV3IG07Zm9yKGxldCBuPTA7bjx0Lmxlbmd0aDtuKyspe24+MCYmZS5BcHBlbmQoXCIsIFwiKTtsZXQgaT10W25dLktleTtpZihudWxsPT09aS5pdGVtTmFtZSlyZXR1cm4gZChcIml0ZW0uaXRlbU5hbWVcIik7ZS5BcHBlbmQoaS5pdGVtTmFtZSl9cmV0dXJuIGUudG9TdHJpbmcoKX12YWx1ZU9mKCl7cmV0dXJuIE5hTn19Y2xhc3MgUyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpLHRoaXMudXNlRW5kTGluZU51bWJlcj0hMSx0aGlzLm1lc3NhZ2U9dCx0aGlzLm5hbWU9XCJTdG9yeUV4Y2VwdGlvblwifX1mdW5jdGlvbiB5KHQsZSxuKXtpZihudWxsPT09dClyZXR1cm57cmVzdWx0Om4sZXhpc3RzOiExfTtsZXQgaT10LmdldChlKTtyZXR1cm4gdm9pZCAwPT09aT97cmVzdWx0Om4sZXhpc3RzOiExfTp7cmVzdWx0OmksZXhpc3RzOiEwfX1jbGFzcyBDIGV4dGVuZHMgcHtzdGF0aWMgQ3JlYXRlKHQsbil7aWYobil7aWYobj09PWkuSW50JiZOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih0KSkpcmV0dXJuIG5ldyBiKE51bWJlcih0KSk7aWYobj09PWkuRmxvYXQmJiFpc05hTih0KSlyZXR1cm4gbmV3IF8oTnVtYmVyKHQpKX1pZihcImJvb2xlYW5cIj09dHlwZW9mIHQpe3Q9ISF0PzE6MH1yZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD9uZXcgVChTdHJpbmcodCkpOk51bWJlci5pc0ludGVnZXIoTnVtYmVyKHQpKT9uZXcgYihOdW1iZXIodCkpOmlzTmFOKHQpP3QgaW5zdGFuY2VvZiBlP25ldyBQKHModCxlKSk6dCBpbnN0YW5jZW9mIGc/bmV3IE8ocyh0LGcpKTpudWxsOm5ldyBfKE51bWJlcih0KSl9Q29weSgpe3JldHVybiBzKEMuQ3JlYXRlKHRoaXMpLHApfUJhZENhc3RFeGNlcHRpb24odCl7cmV0dXJuIG5ldyBTKFwiQ2FuJ3QgY2FzdCBcIit0aGlzLnZhbHVlT2JqZWN0K1wiIGZyb20gXCIrdGhpcy52YWx1ZVR5cGUrXCIgdG8gXCIrdCl9fWNsYXNzIHYgZXh0ZW5kcyBDe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy52YWx1ZT10fWdldCB2YWx1ZU9iamVjdCgpe3JldHVybiB0aGlzLnZhbHVlfXRvU3RyaW5nKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlP2QoXCJWYWx1ZS52YWx1ZVwiKTp0aGlzLnZhbHVlLnRvU3RyaW5nKCl9fWNsYXNzIGIgZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHR8fDApfWdldCBpc1RydXRoeSgpe3JldHVybiAwIT10aGlzLnZhbHVlfWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5JbnR9Q2FzdCh0KXtpZihudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gZChcIlZhbHVlLnZhbHVlXCIpO2lmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO2lmKHQ9PWkuRmxvYXQpcmV0dXJuIG5ldyBfKHRoaXMudmFsdWUpO2lmKHQ9PWkuU3RyaW5nKXJldHVybiBuZXcgVChcIlwiK3RoaXMudmFsdWUpO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX19Y2xhc3MgXyBleHRlbmRzIHZ7Y29uc3RydWN0b3IodCl7c3VwZXIodHx8MCl9Z2V0IGlzVHJ1dGh5KCl7cmV0dXJuIDAhPXRoaXMudmFsdWV9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLkZsb2F0fUNhc3QodCl7aWYobnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIGQoXCJWYWx1ZS52YWx1ZVwiKTtpZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpcztpZih0PT1pLkludClyZXR1cm4gbmV3IGIodGhpcy52YWx1ZSk7aWYodD09aS5TdHJpbmcpcmV0dXJuIG5ldyBUKFwiXCIrdGhpcy52YWx1ZSk7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfX1jbGFzcyBUIGV4dGVuZHMgdntjb25zdHJ1Y3Rvcih0KXtpZihzdXBlcih0fHxcIlwiKSx0aGlzLl9pc05ld2xpbmU9XCJcXG5cIj09dGhpcy52YWx1ZSx0aGlzLl9pc0lubGluZVdoaXRlc3BhY2U9ITAsbnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIGQoXCJWYWx1ZS52YWx1ZVwiKTt0aGlzLnZhbHVlLmxlbmd0aD4wJiZ0aGlzLnZhbHVlLnNwbGl0KFwiXCIpLmV2ZXJ5KHQ9PlwiIFwiPT10fHxcIlxcdFwiPT10fHwodGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlPSExLCExKSl9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLlN0cmluZ31nZXQgaXNUcnV0aHkoKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWU/ZChcIlZhbHVlLnZhbHVlXCIpOnRoaXMudmFsdWUubGVuZ3RoPjB9Z2V0IGlzTmV3bGluZSgpe3JldHVybiB0aGlzLl9pc05ld2xpbmV9Z2V0IGlzSW5saW5lV2hpdGVzcGFjZSgpe3JldHVybiB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2V9Z2V0IGlzTm9uV2hpdGVzcGFjZSgpe3JldHVybiF0aGlzLmlzTmV3bGluZSYmIXRoaXMuaXNJbmxpbmVXaGl0ZXNwYWNlfUNhc3QodCl7aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7aWYodD09aS5JbnQpe2xldCBlPWZ1bmN0aW9uKHQsZT0wKXtsZXQgbj1wYXJzZUludCh0KTtyZXR1cm4gTnVtYmVyLmlzTmFOKG4pP3tyZXN1bHQ6ZSxleGlzdHM6ITF9OntyZXN1bHQ6bixleGlzdHM6ITB9fSh0aGlzLnZhbHVlKTtpZihlLmV4aXN0cylyZXR1cm4gbmV3IGIoZS5yZXN1bHQpO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX1pZih0PT1pLkZsb2F0KXtsZXQgZT1mdW5jdGlvbih0LGU9MCl7bGV0IG49cGFyc2VGbG9hdCh0KTtyZXR1cm4gTnVtYmVyLmlzTmFOKG4pP3tyZXN1bHQ6ZSxleGlzdHM6ITF9OntyZXN1bHQ6bixleGlzdHM6ITB9fSh0aGlzLnZhbHVlKTtpZihlLmV4aXN0cylyZXR1cm4gbmV3IF8oZS5yZXN1bHQpO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX10aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9fWNsYXNzIFAgZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHQpfWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5EaXZlcnRUYXJnZXR9Z2V0IHRhcmdldFBhdGgoKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWU/ZChcIlZhbHVlLnZhbHVlXCIpOnRoaXMudmFsdWV9c2V0IHRhcmdldFBhdGgodCl7dGhpcy52YWx1ZT10fWdldCBpc1RydXRoeSgpe3Rocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIGRpdmVydCB0YXJnZXRcIil9Q2FzdCh0KXtpZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpczt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9dG9TdHJpbmcoKXtyZXR1cm5cIkRpdmVydFRhcmdldFZhbHVlKFwiK3RoaXMudGFyZ2V0UGF0aCtcIilcIn19Y2xhc3MgdyBleHRlbmRzIHZ7Y29uc3RydWN0b3IodCxlPS0xKXtzdXBlcih0KSx0aGlzLl9jb250ZXh0SW5kZXg9ZX1nZXQgY29udGV4dEluZGV4KCl7cmV0dXJuIHRoaXMuX2NvbnRleHRJbmRleH1zZXQgY29udGV4dEluZGV4KHQpe3RoaXMuX2NvbnRleHRJbmRleD10fWdldCB2YXJpYWJsZU5hbWUoKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWU/ZChcIlZhbHVlLnZhbHVlXCIpOnRoaXMudmFsdWV9c2V0IHZhcmlhYmxlTmFtZSh0KXt0aGlzLnZhbHVlPXR9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLlZhcmlhYmxlUG9pbnRlcn1nZXQgaXNUcnV0aHkoKXt0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGRuJ3QgYmUgY2hlY2tpbmcgdGhlIHRydXRoaW5lc3Mgb2YgYSB2YXJpYWJsZSBwb2ludGVyXCIpfUNhc3QodCl7aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfXRvU3RyaW5nKCl7cmV0dXJuXCJWYXJpYWJsZVBvaW50ZXJWYWx1ZShcIit0aGlzLnZhcmlhYmxlTmFtZStcIilcIn1Db3B5KCl7cmV0dXJuIG5ldyB3KHRoaXMudmFyaWFibGVOYW1lLHRoaXMuY29udGV4dEluZGV4KX19Y2xhc3MgTyBleHRlbmRzIHZ7Z2V0IGlzVHJ1dGh5KCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlP2QoXCJ0aGlzLnZhbHVlXCIpOnRoaXMudmFsdWUuQ291bnQ+MH1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuTGlzdH1DYXN0KHQpe2lmKG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBkKFwiVmFsdWUudmFsdWVcIik7aWYodD09aS5JbnQpe2xldCB0PXRoaXMudmFsdWUubWF4SXRlbTtyZXR1cm4gdC5LZXkuaXNOdWxsP25ldyBiKDApOm5ldyBiKHQuVmFsdWUpfWlmKHQ9PWkuRmxvYXQpe2xldCB0PXRoaXMudmFsdWUubWF4SXRlbTtyZXR1cm4gdC5LZXkuaXNOdWxsP25ldyBfKDApOm5ldyBfKHQuVmFsdWUpfWlmKHQ9PWkuU3RyaW5nKXtsZXQgdD10aGlzLnZhbHVlLm1heEl0ZW07cmV0dXJuIHQuS2V5LmlzTnVsbD9uZXcgVChcIlwiKTpuZXcgVCh0LktleS50b1N0cmluZygpKX1pZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpczt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9Y29uc3RydWN0b3IodCxlKXtzdXBlcihudWxsKSx0fHxlP3QgaW5zdGFuY2VvZiBnP3RoaXMudmFsdWU9bmV3IGcodCk6dCBpbnN0YW5jZW9mIGYmJlwibnVtYmVyXCI9PXR5cGVvZiBlJiYodGhpcy52YWx1ZT1uZXcgZyh7S2V5OnQsVmFsdWU6ZX0pKTp0aGlzLnZhbHVlPW5ldyBnfXN0YXRpYyBSZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQodCxlKXtsZXQgbj1hKHQsTyksaT1hKGUsTyk7cmV0dXJuIGkmJm51bGw9PT1pLnZhbHVlP2QoXCJuZXdMaXN0LnZhbHVlXCIpOm4mJm51bGw9PT1uLnZhbHVlP2QoXCJvbGRMaXN0LnZhbHVlXCIpOnZvaWQobiYmaSYmMD09aS52YWx1ZS5Db3VudCYmaS52YWx1ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXMobi52YWx1ZS5vcmlnaW5OYW1lcykpfX0hZnVuY3Rpb24odCl7dFt0LkludD0wXT1cIkludFwiLHRbdC5GbG9hdD0xXT1cIkZsb2F0XCIsdFt0Lkxpc3Q9Ml09XCJMaXN0XCIsdFt0LlN0cmluZz0zXT1cIlN0cmluZ1wiLHRbdC5EaXZlcnRUYXJnZXQ9NF09XCJEaXZlcnRUYXJnZXRcIix0W3QuVmFyaWFibGVQb2ludGVyPTVdPVwiVmFyaWFibGVQb2ludGVyXCJ9KGl8fChpPXt9KSk7Y2xhc3MgRXtjb25zdHJ1Y3Rvcigpe3RoaXMub2JqPW51bGwsdGhpcy5hcHByb3hpbWF0ZT0hMX1nZXQgY29ycmVjdE9iaigpe3JldHVybiB0aGlzLmFwcHJveGltYXRlP251bGw6dGhpcy5vYmp9Z2V0IGNvbnRhaW5lcigpe3JldHVybiB0aGlzLm9iaiBpbnN0YW5jZW9mIE4/dGhpcy5vYmo6bnVsbH1jb3B5KCl7bGV0IHQ9bmV3IEU7cmV0dXJuIHQub2JqPXRoaXMub2JqLHQuYXBwcm94aW1hdGU9dGhpcy5hcHByb3hpbWF0ZSx0fX1jbGFzcyBOIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5uYW1lPVwiXCIsdGhpcy5fY29udGVudD1bXSx0aGlzLm5hbWVkQ29udGVudD1uZXcgTWFwLHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkPSExLHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkPSExLHRoaXMuY291bnRpbmdBdFN0YXJ0T25seT0hMSx0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50PW51bGx9Z2V0IGhhc1ZhbGlkTmFtZSgpe3JldHVybiBudWxsIT10aGlzLm5hbWUmJnRoaXMubmFtZS5sZW5ndGg+MH1nZXQgY29udGVudCgpe3JldHVybiB0aGlzLl9jb250ZW50fXNldCBjb250ZW50KHQpe3RoaXMuQWRkQ29udGVudCh0KX1nZXQgbmFtZWRPbmx5Q29udGVudCgpe2xldCB0PW5ldyBNYXA7Zm9yKGxldFtlLG5db2YgdGhpcy5uYW1lZENvbnRlbnQpe2xldCBpPXMobixwKTt0LnNldChlLGkpfWZvcihsZXQgZSBvZiB0aGlzLmNvbnRlbnQpe2xldCBuPWwoZSk7bnVsbCE9biYmbi5oYXNWYWxpZE5hbWUmJnQuZGVsZXRlKG4ubmFtZSl9cmV0dXJuIDA9PXQuc2l6ZSYmKHQ9bnVsbCksdH1zZXQgbmFtZWRPbmx5Q29udGVudCh0KXtsZXQgZT10aGlzLm5hbWVkT25seUNvbnRlbnQ7aWYobnVsbCE9ZSlmb3IobGV0W3Rdb2YgZSl0aGlzLm5hbWVkQ29udGVudC5kZWxldGUodCk7aWYobnVsbCE9dClmb3IobGV0WyxlXW9mIHQpe2xldCB0PWwoZSk7bnVsbCE9dCYmdGhpcy5BZGRUb05hbWVkQ29udGVudE9ubHkodCl9fWdldCBjb3VudEZsYWdzKCl7bGV0IHQ9MDtyZXR1cm4gdGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQmJih0fD1OLkNvdW50RmxhZ3MuVmlzaXRzKSx0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCYmKHR8PU4uQ291bnRGbGFncy5UdXJucyksdGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5JiYodHw9Ti5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KSx0PT1OLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkmJih0PTApLHR9c2V0IGNvdW50RmxhZ3ModCl7bGV0IGU9dDsoZSZOLkNvdW50RmxhZ3MuVmlzaXRzKT4wJiYodGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQ9ITApLChlJk4uQ291bnRGbGFncy5UdXJucyk+MCYmKHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkPSEwKSwoZSZOLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkpPjAmJih0aGlzLmNvdW50aW5nQXRTdGFydE9ubHk9ITApfWdldCBwYXRoVG9GaXJzdExlYWZDb250ZW50KCl7cmV0dXJuIG51bGw9PXRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQmJih0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50PXRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKHRoaXMuaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KSksdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudH1nZXQgaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KCl7bGV0IHQ9W10sbj10aGlzO2Zvcig7biBpbnN0YW5jZW9mIE47KW4uY29udGVudC5sZW5ndGg+MCYmKHQucHVzaChuZXcgZS5Db21wb25lbnQoMCkpLG49bi5jb250ZW50WzBdKTtyZXR1cm4gbmV3IGUodCl9QWRkQ29udGVudCh0KXtpZih0IGluc3RhbmNlb2YgQXJyYXkpe2xldCBlPXQ7Zm9yKGxldCB0IG9mIGUpdGhpcy5BZGRDb250ZW50KHQpfWVsc2V7bGV0IGU9dDtpZih0aGlzLl9jb250ZW50LnB1c2goZSksZS5wYXJlbnQpdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiK2UucGFyZW50KTtlLnBhcmVudD10aGlzLHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KGUpfX1UcnlBZGROYW1lZENvbnRlbnQodCl7bGV0IGU9bCh0KTtudWxsIT1lJiZlLmhhc1ZhbGlkTmFtZSYmdGhpcy5BZGRUb05hbWVkQ29udGVudE9ubHkoZSl9QWRkVG9OYW1lZENvbnRlbnRPbmx5KHQpe24uQXNzZXJ0VHlwZSh0LHAsXCJDYW4gb25seSBhZGQgUnVudGltZS5PYmplY3RzIHRvIGEgUnVudGltZS5Db250YWluZXJcIikscyh0LHApLnBhcmVudD10aGlzLHRoaXMubmFtZWRDb250ZW50LnNldCh0Lm5hbWUsdCl9Q29udGVudEF0UGF0aCh0LGU9MCxuPS0xKXstMT09biYmKG49dC5sZW5ndGgpO2xldCBpPW5ldyBFO2kuYXBwcm94aW1hdGU9ITE7bGV0IHI9dGhpcyxzPXRoaXM7Zm9yKGxldCBsPWU7bDxuOysrbCl7bGV0IGU9dC5HZXRDb21wb25lbnQobCk7aWYobnVsbD09cil7aS5hcHByb3hpbWF0ZT0hMDticmVha31sZXQgbj1yLkNvbnRlbnRXaXRoUGF0aENvbXBvbmVudChlKTtpZihudWxsPT1uKXtpLmFwcHJveGltYXRlPSEwO2JyZWFrfXM9bixyPWEobixOKX1yZXR1cm4gaS5vYmo9cyxpfUluc2VydENvbnRlbnQodCxlKXtpZih0aGlzLmNvbnRlbnRbZV09dCx0LnBhcmVudCl0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIrdC5wYXJlbnQpO3QucGFyZW50PXRoaXMsdGhpcy5UcnlBZGROYW1lZENvbnRlbnQodCl9QWRkQ29udGVudHNPZkNvbnRhaW5lcih0KXt0aGlzLmNvbnRlbnQ9dGhpcy5jb250ZW50LmNvbmNhdCh0LmNvbnRlbnQpO2ZvcihsZXQgZSBvZiB0LmNvbnRlbnQpZS5wYXJlbnQ9dGhpcyx0aGlzLlRyeUFkZE5hbWVkQ29udGVudChlKX1Db250ZW50V2l0aFBhdGhDb21wb25lbnQodCl7aWYodC5pc0luZGV4KXJldHVybiB0LmluZGV4Pj0wJiZ0LmluZGV4PHRoaXMuY29udGVudC5sZW5ndGg/dGhpcy5jb250ZW50W3QuaW5kZXhdOm51bGw7aWYodC5pc1BhcmVudClyZXR1cm4gdGhpcy5wYXJlbnQ7e2lmKG51bGw9PT10Lm5hbWUpcmV0dXJuIGQoXCJjb21wb25lbnQubmFtZVwiKTtsZXQgZT15KHRoaXMubmFtZWRDb250ZW50LHQubmFtZSxudWxsKTtyZXR1cm4gZS5leGlzdHM/cyhlLnJlc3VsdCxwKTpudWxsfX1CdWlsZFN0cmluZ09mSGllcmFyY2h5KCl7bGV0IHQ7aWYoMD09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdD1uZXcgbSx0aGlzLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkodCwwLG51bGwpLHQudG9TdHJpbmcoKTt0PWFyZ3VtZW50c1swXTtsZXQgZT1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl07ZnVuY3Rpb24gcigpe2ZvcihsZXQgbj0wO248NCplOysrbil0LkFwcGVuZChcIiBcIil9cigpLHQuQXBwZW5kKFwiW1wiKSx0aGlzLmhhc1ZhbGlkTmFtZSYmdC5BcHBlbmRGb3JtYXQoXCIgKHswfSlcIix0aGlzLm5hbWUpLHRoaXM9PWkmJnQuQXBwZW5kKFwiICA8LS0tXCIpLHQuQXBwZW5kTGluZSgpLGUrKztmb3IobGV0IG49MDtuPHRoaXMuY29udGVudC5sZW5ndGg7KytuKXtsZXQgYT10aGlzLmNvbnRlbnRbbl07aWYoYSBpbnN0YW5jZW9mIE4pe2EuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSh0LGUsaSl9ZWxzZSByKCksYSBpbnN0YW5jZW9mIFQ/KHQuQXBwZW5kKCdcIicpLHQuQXBwZW5kKGEudG9TdHJpbmcoKS5yZXBsYWNlKFwiXFxuXCIsXCJcXFxcblwiKSksdC5BcHBlbmQoJ1wiJykpOnQuQXBwZW5kKGEudG9TdHJpbmcoKSk7biE9dGhpcy5jb250ZW50Lmxlbmd0aC0xJiZ0LkFwcGVuZChcIixcIiksYSBpbnN0YW5jZW9mIE58fGEhPWl8fHQuQXBwZW5kKFwiICA8LS0tXCIpLHQuQXBwZW5kTGluZSgpfWxldCBhPW5ldyBNYXA7Zm9yKGxldFt0LGVdb2YgdGhpcy5uYW1lZENvbnRlbnQpdGhpcy5jb250ZW50LmluZGV4T2YocyhlLHApKT49MHx8YS5zZXQodCxlKTtpZihhLnNpemU+MCl7cigpLHQuQXBwZW5kTGluZShcIi0tIG5hbWVkOiAtLVwiKTtmb3IobGV0WyxyXW9mIGEpe24uQXNzZXJ0VHlwZShyLE4sXCJDYW4gb25seSBwcmludCBvdXQgbmFtZWQgQ29udGFpbmVyc1wiKSxyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkodCxlLGkpLHQuQXBwZW5kTGluZSgpfX1lLS0scigpLHQuQXBwZW5kKFwiXVwiKX19IWZ1bmN0aW9uKHQpe2xldCBlOyFmdW5jdGlvbih0KXt0W3QuVmlzaXRzPTFdPVwiVmlzaXRzXCIsdFt0LlR1cm5zPTJdPVwiVHVybnNcIix0W3QuQ291bnRTdGFydE9ubHk9NF09XCJDb3VudFN0YXJ0T25seVwifShlPXQuQ291bnRGbGFnc3x8KHQuQ291bnRGbGFncz17fSkpfShOfHwoTj17fSkpO2NsYXNzIHggZXh0ZW5kcyBwe3RvU3RyaW5nKCl7cmV0dXJuXCJHbHVlXCJ9fWNsYXNzIEEgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQ9QS5Db21tYW5kVHlwZS5Ob3RTZXQpe3N1cGVyKCksdGhpcy5fY29tbWFuZFR5cGU9dH1nZXQgY29tbWFuZFR5cGUoKXtyZXR1cm4gdGhpcy5fY29tbWFuZFR5cGV9Q29weSgpe3JldHVybiBuZXcgQSh0aGlzLmNvbW1hbmRUeXBlKX1zdGF0aWMgRXZhbFN0YXJ0KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0KX1zdGF0aWMgRXZhbE91dHB1dCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXQpfXN0YXRpYyBFdmFsRW5kKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRXZhbEVuZCl9c3RhdGljIER1cGxpY2F0ZSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZSl9c3RhdGljIFBvcEV2YWx1YXRlZFZhbHVlKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWUpfXN0YXRpYyBQb3BGdW5jdGlvbigpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uKX1zdGF0aWMgUG9wVHVubmVsKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuUG9wVHVubmVsKX1zdGF0aWMgQmVnaW5TdHJpbmcoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5CZWdpblN0cmluZyl9c3RhdGljIEVuZFN0cmluZygpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkVuZFN0cmluZyl9c3RhdGljIE5vT3AoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5Ob09wKX1zdGF0aWMgQ2hvaWNlQ291bnQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5DaG9pY2VDb3VudCl9c3RhdGljIFR1cm5zKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuVHVybnMpfXN0YXRpYyBUdXJuc1NpbmNlKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSl9c3RhdGljIFJlYWRDb3VudCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlJlYWRDb3VudCl9c3RhdGljIFJhbmRvbSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlJhbmRvbSl9c3RhdGljIFNlZWRSYW5kb20oKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5TZWVkUmFuZG9tKX1zdGF0aWMgVmlzaXRJbmRleCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXgpfXN0YXRpYyBTZXF1ZW5jZVNodWZmbGVJbmRleCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4KX1zdGF0aWMgU3RhcnRUaHJlYWQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5TdGFydFRocmVhZCl9c3RhdGljIERvbmUoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5Eb25lKX1zdGF0aWMgRW5kKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRW5kKX1zdGF0aWMgTGlzdEZyb21JbnQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5MaXN0RnJvbUludCl9c3RhdGljIExpc3RSYW5nZSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkxpc3RSYW5nZSl9c3RhdGljIExpc3RSYW5kb20oKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5MaXN0UmFuZG9tKX10b1N0cmluZygpe3JldHVybiB0aGlzLmNvbW1hbmRUeXBlLnRvU3RyaW5nKCl9fSFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5vdFNldD0tMV09XCJOb3RTZXRcIix0W3QuRXZhbFN0YXJ0PTBdPVwiRXZhbFN0YXJ0XCIsdFt0LkV2YWxPdXRwdXQ9MV09XCJFdmFsT3V0cHV0XCIsdFt0LkV2YWxFbmQ9Ml09XCJFdmFsRW5kXCIsdFt0LkR1cGxpY2F0ZT0zXT1cIkR1cGxpY2F0ZVwiLHRbdC5Qb3BFdmFsdWF0ZWRWYWx1ZT00XT1cIlBvcEV2YWx1YXRlZFZhbHVlXCIsdFt0LlBvcEZ1bmN0aW9uPTVdPVwiUG9wRnVuY3Rpb25cIix0W3QuUG9wVHVubmVsPTZdPVwiUG9wVHVubmVsXCIsdFt0LkJlZ2luU3RyaW5nPTddPVwiQmVnaW5TdHJpbmdcIix0W3QuRW5kU3RyaW5nPThdPVwiRW5kU3RyaW5nXCIsdFt0Lk5vT3A9OV09XCJOb09wXCIsdFt0LkNob2ljZUNvdW50PTEwXT1cIkNob2ljZUNvdW50XCIsdFt0LlR1cm5zPTExXT1cIlR1cm5zXCIsdFt0LlR1cm5zU2luY2U9MTJdPVwiVHVybnNTaW5jZVwiLHRbdC5SYW5kb209MTNdPVwiUmFuZG9tXCIsdFt0LlNlZWRSYW5kb209MTRdPVwiU2VlZFJhbmRvbVwiLHRbdC5WaXNpdEluZGV4PTE1XT1cIlZpc2l0SW5kZXhcIix0W3QuU2VxdWVuY2VTaHVmZmxlSW5kZXg9MTZdPVwiU2VxdWVuY2VTaHVmZmxlSW5kZXhcIix0W3QuU3RhcnRUaHJlYWQ9MTddPVwiU3RhcnRUaHJlYWRcIix0W3QuRG9uZT0xOF09XCJEb25lXCIsdFt0LkVuZD0xOV09XCJFbmRcIix0W3QuTGlzdEZyb21JbnQ9MjBdPVwiTGlzdEZyb21JbnRcIix0W3QuTGlzdFJhbmdlPTIxXT1cIkxpc3RSYW5nZVwiLHRbdC5MaXN0UmFuZG9tPTIyXT1cIkxpc3RSYW5kb21cIix0W3QuUmVhZENvdW50PTIzXT1cIlJlYWRDb3VudFwiLHRbdC5UT1RBTF9WQUxVRVM9MjRdPVwiVE9UQUxfVkFMVUVTXCJ9KGU9dC5Db21tYW5kVHlwZXx8KHQuQ29tbWFuZFR5cGU9e30pKX0oQXx8KEE9e30pKSxmdW5jdGlvbih0KXt0W3QuVHVubmVsPTBdPVwiVHVubmVsXCIsdFt0LkZ1bmN0aW9uPTFdPVwiRnVuY3Rpb25cIix0W3QuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWU9Ml09XCJGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZVwifShyfHwocj17fSkpO2NsYXNzIEl7Y29uc3RydWN0b3IoKXt0aGlzLmNvbnRhaW5lcj1udWxsLHRoaXMuaW5kZXg9LTEsMj09PWFyZ3VtZW50cy5sZW5ndGgmJih0aGlzLmNvbnRhaW5lcj1hcmd1bWVudHNbMF0sdGhpcy5pbmRleD1hcmd1bWVudHNbMV0pfVJlc29sdmUoKXtyZXR1cm4gdGhpcy5pbmRleDwwP3RoaXMuY29udGFpbmVyOm51bGw9PXRoaXMuY29udGFpbmVyP251bGw6MD09dGhpcy5jb250YWluZXIuY29udGVudC5sZW5ndGg/dGhpcy5jb250YWluZXI6dGhpcy5pbmRleD49dGhpcy5jb250YWluZXIuY29udGVudC5sZW5ndGg/bnVsbDp0aGlzLmNvbnRhaW5lci5jb250ZW50W3RoaXMuaW5kZXhdfWdldCBpc051bGwoKXtyZXR1cm4gbnVsbD09dGhpcy5jb250YWluZXJ9Z2V0IHBhdGgoKXtyZXR1cm4gdGhpcy5pc051bGw/bnVsbDp0aGlzLmluZGV4Pj0wP3RoaXMuY29udGFpbmVyLnBhdGguUGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KG5ldyBlLkNvbXBvbmVudCh0aGlzLmluZGV4KSk6dGhpcy5jb250YWluZXIucGF0aH10b1N0cmluZygpe3JldHVybiB0aGlzLmNvbnRhaW5lcj9cIkluayBQb2ludGVyIC0+IFwiK3RoaXMuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKStcIiAtLSBpbmRleCBcIit0aGlzLmluZGV4OlwiSW5rIFBvaW50ZXIgKG51bGwpXCJ9Y29weSgpe3JldHVybiBuZXcgSSh0aGlzLmNvbnRhaW5lcix0aGlzLmluZGV4KX1zdGF0aWMgU3RhcnRPZih0KXtyZXR1cm4gbmV3IEkodCwwKX1zdGF0aWMgZ2V0IE51bGwoKXtyZXR1cm4gbmV3IEkobnVsbCwtMSl9fWNsYXNzIGsgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy5fdGFyZ2V0UGF0aD1udWxsLHRoaXMuX3RhcmdldFBvaW50ZXI9SS5OdWxsLHRoaXMudmFyaWFibGVEaXZlcnROYW1lPW51bGwsdGhpcy5wdXNoZXNUb1N0YWNrPSExLHRoaXMuc3RhY2tQdXNoVHlwZT0wLHRoaXMuaXNFeHRlcm5hbD0hMSx0aGlzLmV4dGVybmFsQXJncz0wLHRoaXMuaXNDb25kaXRpb25hbD0hMSx0aGlzLnB1c2hlc1RvU3RhY2s9ITEsdm9pZCAwIT09dCYmKHRoaXMucHVzaGVzVG9TdGFjaz0hMCx0aGlzLnN0YWNrUHVzaFR5cGU9dCl9Z2V0IHRhcmdldFBhdGgoKXtpZihudWxsIT10aGlzLl90YXJnZXRQYXRoJiZ0aGlzLl90YXJnZXRQYXRoLmlzUmVsYXRpdmUpe2xldCB0PXRoaXMudGFyZ2V0UG9pbnRlci5SZXNvbHZlKCk7dCYmKHRoaXMuX3RhcmdldFBhdGg9dC5wYXRoKX1yZXR1cm4gdGhpcy5fdGFyZ2V0UGF0aH1zZXQgdGFyZ2V0UGF0aCh0KXt0aGlzLl90YXJnZXRQYXRoPXQsdGhpcy5fdGFyZ2V0UG9pbnRlcj1JLk51bGx9Z2V0IHRhcmdldFBvaW50ZXIoKXtpZih0aGlzLl90YXJnZXRQb2ludGVyLmlzTnVsbCl7bGV0IHQ9dGhpcy5SZXNvbHZlUGF0aCh0aGlzLl90YXJnZXRQYXRoKS5vYmo7aWYobnVsbD09PXRoaXMuX3RhcmdldFBhdGgpcmV0dXJuIGQoXCJ0aGlzLl90YXJnZXRQYXRoXCIpO2lmKG51bGw9PT10aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQpcmV0dXJuIGQoXCJ0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnRcIik7aWYodGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmlzSW5kZXgpe2lmKG51bGw9PT10KXJldHVybiBkKFwidGFyZ2V0T2JqXCIpO3RoaXMuX3RhcmdldFBvaW50ZXIuY29udGFpbmVyPXQucGFyZW50IGluc3RhbmNlb2YgTj90LnBhcmVudDpudWxsLHRoaXMuX3RhcmdldFBvaW50ZXIuaW5kZXg9dGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmluZGV4fWVsc2UgdGhpcy5fdGFyZ2V0UG9pbnRlcj1JLlN0YXJ0T2YodCBpbnN0YW5jZW9mIE4/dDpudWxsKX1yZXR1cm4gdGhpcy5fdGFyZ2V0UG9pbnRlci5jb3B5KCl9Z2V0IHRhcmdldFBhdGhTdHJpbmcoKXtyZXR1cm4gbnVsbD09dGhpcy50YXJnZXRQYXRoP251bGw6dGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnRhcmdldFBhdGgpfXNldCB0YXJnZXRQYXRoU3RyaW5nKHQpe3RoaXMudGFyZ2V0UGF0aD1udWxsPT10P251bGw6bmV3IGUodCl9Z2V0IGhhc1ZhcmlhYmxlVGFyZ2V0KCl7cmV0dXJuIG51bGwhPXRoaXMudmFyaWFibGVEaXZlcnROYW1lfUVxdWFscyh0KXtsZXQgZT10O3JldHVybiBlIGluc3RhbmNlb2YgayYmdGhpcy5oYXNWYXJpYWJsZVRhcmdldD09ZS5oYXNWYXJpYWJsZVRhcmdldCYmKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQ/dGhpcy52YXJpYWJsZURpdmVydE5hbWU9PWUudmFyaWFibGVEaXZlcnROYW1lOm51bGw9PT10aGlzLnRhcmdldFBhdGg/ZChcInRoaXMudGFyZ2V0UGF0aFwiKTp0aGlzLnRhcmdldFBhdGguRXF1YWxzKGUudGFyZ2V0UGF0aCkpfXRvU3RyaW5nKCl7aWYodGhpcy5oYXNWYXJpYWJsZVRhcmdldClyZXR1cm5cIkRpdmVydCh2YXJpYWJsZTogXCIrdGhpcy52YXJpYWJsZURpdmVydE5hbWUrXCIpXCI7aWYobnVsbD09dGhpcy50YXJnZXRQYXRoKXJldHVyblwiRGl2ZXJ0KG51bGwpXCI7e2xldCB0PW5ldyBtLGU9dGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCk7cmV0dXJuIHQuQXBwZW5kKFwiRGl2ZXJ0XCIpLHRoaXMuaXNDb25kaXRpb25hbCYmdC5BcHBlbmQoXCI/XCIpLHRoaXMucHVzaGVzVG9TdGFjayYmKHRoaXMuc3RhY2tQdXNoVHlwZT09ci5GdW5jdGlvbj90LkFwcGVuZChcIiBmdW5jdGlvblwiKTp0LkFwcGVuZChcIiB0dW5uZWxcIikpLHQuQXBwZW5kKFwiIC0+IFwiKSx0LkFwcGVuZCh0aGlzLnRhcmdldFBhdGhTdHJpbmcpLHQuQXBwZW5kKFwiIChcIiksdC5BcHBlbmQoZSksdC5BcHBlbmQoXCIpXCIpLHQudG9TdHJpbmcoKX19fWNsYXNzIFcgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQ9ITApe3N1cGVyKCksdGhpcy5fcGF0aE9uQ2hvaWNlPW51bGwsdGhpcy5oYXNDb25kaXRpb249ITEsdGhpcy5oYXNTdGFydENvbnRlbnQ9ITEsdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudD0hMSx0aGlzLmlzSW52aXNpYmxlRGVmYXVsdD0hMSx0aGlzLm9uY2VPbmx5PSEwLHRoaXMub25jZU9ubHk9dH1nZXQgcGF0aE9uQ2hvaWNlKCl7aWYobnVsbCE9dGhpcy5fcGF0aE9uQ2hvaWNlJiZ0aGlzLl9wYXRoT25DaG9pY2UuaXNSZWxhdGl2ZSl7bGV0IHQ9dGhpcy5jaG9pY2VUYXJnZXQ7dCYmKHRoaXMuX3BhdGhPbkNob2ljZT10LnBhdGgpfXJldHVybiB0aGlzLl9wYXRoT25DaG9pY2V9c2V0IHBhdGhPbkNob2ljZSh0KXt0aGlzLl9wYXRoT25DaG9pY2U9dH1nZXQgY2hvaWNlVGFyZ2V0KCl7cmV0dXJuIG51bGw9PT10aGlzLl9wYXRoT25DaG9pY2U/ZChcIkNob2ljZVBvaW50Ll9wYXRoT25DaG9pY2VcIik6dGhpcy5SZXNvbHZlUGF0aCh0aGlzLl9wYXRoT25DaG9pY2UpLmNvbnRhaW5lcn1nZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCl7cmV0dXJuIG51bGw9PT10aGlzLnBhdGhPbkNob2ljZT9kKFwiQ2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlXCIpOnRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoT25DaG9pY2UpfXNldCBwYXRoU3RyaW5nT25DaG9pY2UodCl7dGhpcy5wYXRoT25DaG9pY2U9bmV3IGUodCl9Z2V0IGZsYWdzKCl7bGV0IHQ9MDtyZXR1cm4gdGhpcy5oYXNDb25kaXRpb24mJih0fD0xKSx0aGlzLmhhc1N0YXJ0Q29udGVudCYmKHR8PTIpLHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQmJih0fD00KSx0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCYmKHR8PTgpLHRoaXMub25jZU9ubHkmJih0fD0xNiksdH1zZXQgZmxhZ3ModCl7dGhpcy5oYXNDb25kaXRpb249KDEmdCk+MCx0aGlzLmhhc1N0YXJ0Q29udGVudD0oMiZ0KT4wLHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQ9KDQmdCk+MCx0aGlzLmlzSW52aXNpYmxlRGVmYXVsdD0oOCZ0KT4wLHRoaXMub25jZU9ubHk9KDE2JnQpPjB9dG9TdHJpbmcoKXtpZihudWxsPT09dGhpcy5wYXRoT25DaG9pY2UpcmV0dXJuIGQoXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik7cmV0dXJuXCJDaG9pY2U6IC0+IFwiK3RoaXMucGF0aE9uQ2hvaWNlLnRvU3RyaW5nKCl9fWNsYXNzIEYgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQ9bnVsbCl7c3VwZXIoKSx0aGlzLnBhdGhGb3JDb3VudD1udWxsLHRoaXMubmFtZT10fWdldCBjb250YWluZXJGb3JDb3VudCgpe3JldHVybiBudWxsPT09dGhpcy5wYXRoRm9yQ291bnQ/bnVsbDp0aGlzLlJlc29sdmVQYXRoKHRoaXMucGF0aEZvckNvdW50KS5jb250YWluZXJ9Z2V0IHBhdGhTdHJpbmdGb3JDb3VudCgpe3JldHVybiBudWxsPT09dGhpcy5wYXRoRm9yQ291bnQ/bnVsbDp0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aEZvckNvdW50KX1zZXQgcGF0aFN0cmluZ0ZvckNvdW50KHQpe3RoaXMucGF0aEZvckNvdW50PW51bGw9PT10P251bGw6bmV3IGUodCl9dG9TdHJpbmcoKXtpZihudWxsIT10aGlzLm5hbWUpcmV0dXJuXCJ2YXIoXCIrdGhpcy5uYW1lK1wiKVwiO3JldHVyblwicmVhZF9jb3VudChcIit0aGlzLnBhdGhTdHJpbmdGb3JDb3VudCtcIilcIn19Y2xhc3MgViBleHRlbmRzIHB7Y29uc3RydWN0b3IodCxlKXtzdXBlcigpLHRoaXMudmFyaWFibGVOYW1lPXR8fG51bGwsdGhpcy5pc05ld0RlY2xhcmF0aW9uPSEhZSx0aGlzLmlzR2xvYmFsPSExfXRvU3RyaW5nKCl7cmV0dXJuXCJWYXJBc3NpZ24gdG8gXCIrdGhpcy52YXJpYWJsZU5hbWV9fWNsYXNzIEwgZXh0ZW5kcyBwe31jbGFzcyBSIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcigpe2lmKHN1cGVyKCksdGhpcy5fbmFtZT1udWxsLHRoaXMuX251bWJlck9mUGFyYW1ldGVycz0wLHRoaXMuX3Byb3RvdHlwZT1udWxsLHRoaXMuX2lzUHJvdG90eXBlPSExLHRoaXMuX29wZXJhdGlvbkZ1bmNzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpUi5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdO1IuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpLHRoaXMubmFtZT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9pc1Byb3RvdHlwZT0hMCx0aGlzLm5hbWU9dCx0aGlzLm51bWJlck9mUGFyYW1ldGVycz1lfX1zdGF0aWMgQ2FsbFdpdGhOYW1lKHQpe3JldHVybiBuZXcgUih0KX1zdGF0aWMgQ2FsbEV4aXN0c1dpdGhOYW1lKHQpe3JldHVybiB0aGlzLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKSx0aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KHQpfWdldCBuYW1lKCl7cmV0dXJuIG51bGw9PT10aGlzLl9uYW1lP2QoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hbWVcIik6dGhpcy5fbmFtZX1zZXQgbmFtZSh0KXt0aGlzLl9uYW1lPXQsdGhpcy5faXNQcm90b3R5cGV8fChudWxsPT09Ui5fbmF0aXZlRnVuY3Rpb25zP2QoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTp0aGlzLl9wcm90b3R5cGU9Ui5fbmF0aXZlRnVuY3Rpb25zLmdldCh0aGlzLl9uYW1lKXx8bnVsbCl9Z2V0IG51bWJlck9mUGFyYW1ldGVycygpe3JldHVybiB0aGlzLl9wcm90b3R5cGU/dGhpcy5fcHJvdG90eXBlLm51bWJlck9mUGFyYW1ldGVyczp0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnN9c2V0IG51bWJlck9mUGFyYW1ldGVycyh0KXt0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnM9dH1DYWxsKHQpe2lmKHRoaXMuX3Byb3RvdHlwZSlyZXR1cm4gdGhpcy5fcHJvdG90eXBlLkNhbGwodCk7aWYodGhpcy5udW1iZXJPZlBhcmFtZXRlcnMhPXQubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnNcIik7bGV0IGU9ITE7Zm9yKGxldCBuIG9mIHQpe2lmKG4gaW5zdGFuY2VvZiBMKXRocm93IG5ldyBTKCdBdHRlbXB0aW5nIHRvIHBlcmZvcm0gb3BlcmF0aW9uIG9uIGEgdm9pZCB2YWx1ZS4gRGlkIHlvdSBmb3JnZXQgdG8gXCJyZXR1cm5cIiBhIHZhbHVlIGZyb20gYSBmdW5jdGlvbiB5b3UgY2FsbGVkIGhlcmU/Jyk7biBpbnN0YW5jZW9mIE8mJihlPSEwKX1pZigyPT10Lmxlbmd0aCYmZSlyZXR1cm4gdGhpcy5DYWxsQmluYXJ5TGlzdE9wZXJhdGlvbih0KTtsZXQgbj10aGlzLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSh0KSxyPW5bMF0udmFsdWVUeXBlO3JldHVybiByPT1pLkludHx8cj09aS5GbG9hdHx8cj09aS5TdHJpbmd8fHI9PWkuRGl2ZXJ0VGFyZ2V0fHxyPT1pLkxpc3Q/dGhpcy5DYWxsVHlwZShuKTpudWxsfUNhbGxUeXBlKHQpe2xldCBlPXModFswXSx2KSxuPWUudmFsdWVUeXBlLHI9ZSxhPXQubGVuZ3RoO2lmKDI9PWF8fDE9PWEpe2lmKG51bGw9PT10aGlzLl9vcGVyYXRpb25GdW5jcylyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7bGV0IGw9dGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KG4pO2lmKCFsKXtjb25zdCB0PWlbbl07dGhyb3cgbmV3IFMoXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gXCIrdGhpcy5uYW1lK1wiIG9uIFwiK3QpfWlmKDI9PWEpe2xldCBlPXModFsxXSx2KSxuPWw7aWYobnVsbD09PXIudmFsdWV8fG51bGw9PT1lLnZhbHVlKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGwgQmluYXJ5T3AgdmFsdWVzXCIpO2xldCBpPW4oci52YWx1ZSxlLnZhbHVlKTtyZXR1cm4gdi5DcmVhdGUoaSl9e2xldCB0PWw7aWYobnVsbD09PXIudmFsdWUpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbCBVbmFyeU9wIHZhbHVlXCIpO2xldCBuPXQoci52YWx1ZSk7cmV0dXJuIHRoaXMubmFtZT09PVIuSW50P3YuQ3JlYXRlKG4saS5JbnQpOnRoaXMubmFtZT09PVIuRmxvYXQ/di5DcmVhdGUobixpLkZsb2F0KTp2LkNyZWF0ZShuLGUudmFsdWVUeXBlKX19dGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVycyB0byBOYXRpdmVGdW5jdGlvbkNhbGw6IFwiK3QubGVuZ3RoKX1DYWxsQmluYXJ5TGlzdE9wZXJhdGlvbih0KXtpZigoXCIrXCI9PXRoaXMubmFtZXx8XCItXCI9PXRoaXMubmFtZSkmJnRbMF1pbnN0YW5jZW9mIE8mJnRbMV1pbnN0YW5jZW9mIGIpcmV0dXJuIHRoaXMuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24odCk7bGV0IGU9cyh0WzBdLHYpLG49cyh0WzFdLHYpO2lmKCEoXCImJlwiIT10aGlzLm5hbWUmJlwifHxcIiE9dGhpcy5uYW1lfHxlLnZhbHVlVHlwZT09aS5MaXN0JiZuLnZhbHVlVHlwZT09aS5MaXN0KSl7aWYobnVsbD09PXRoaXMuX29wZXJhdGlvbkZ1bmNzKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtsZXQgdD10aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQoaS5JbnQpO2lmKG51bGw9PT10KXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uIG9wXCIpO2xldCByPXQoZS5pc1RydXRoeT8xOjAsbi5pc1RydXRoeT8xOjApO3JldHVybiBuZXcgYihyKX1pZihlLnZhbHVlVHlwZT09aS5MaXN0JiZuLnZhbHVlVHlwZT09aS5MaXN0KXJldHVybiB0aGlzLkNhbGxUeXBlKFtlLG5dKTt0aHJvdyBuZXcgUyhcIkNhbiBub3QgY2FsbCB1c2UgXCIrdGhpcy5uYW1lK1wiIG9wZXJhdGlvbiBvbiBcIitpW2UudmFsdWVUeXBlXStcIiBhbmQgXCIraVtuLnZhbHVlVHlwZV0pfUNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uKHQpe2xldCBlPXModFswXSxPKSxuPXModFsxXSxiKSxyPW5ldyBnO2lmKG51bGw9PT1lLnZhbHVlKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWVcIik7Zm9yKGxldFt0LGFdb2YgZS52YWx1ZSl7bGV0IHM9Zi5mcm9tU2VyaWFsaXplZEtleSh0KTtpZihudWxsPT09dGhpcy5fb3BlcmF0aW9uRnVuY3MpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO2xldCBsPXRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChpLkludCk7aWYobnVsbD09PW4udmFsdWUpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gaW50VmFsLnZhbHVlXCIpO2xldCBvPWwoYSxuLnZhbHVlKSx1PW51bGw7aWYobnVsbD09PWUudmFsdWUub3JpZ2lucylyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBsaXN0VmFsLnZhbHVlLm9yaWdpbnNcIik7Zm9yKGxldCB0IG9mIGUudmFsdWUub3JpZ2lucylpZih0Lm5hbWU9PXMub3JpZ2luTmFtZSl7dT10O2JyZWFrfWlmKG51bGwhPXUpe2xldCB0PXUuVHJ5R2V0SXRlbVdpdGhWYWx1ZShvLGYuTnVsbCk7dC5leGlzdHMmJnIuQWRkKHQucmVzdWx0LG8pfX1yZXR1cm4gbmV3IE8ocil9Q29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlKHQpe2xldCBlPWkuSW50LG49bnVsbDtmb3IobGV0IHIgb2YgdCl7bGV0IHQ9cyhyLHYpO3QudmFsdWVUeXBlPmUmJihlPXQudmFsdWVUeXBlKSx0LnZhbHVlVHlwZT09aS5MaXN0JiYobj1hKHQsTykpfWxldCByPVtdO2lmKGlbZV09PWlbaS5MaXN0XSlmb3IobGV0IGUgb2YgdCl7bGV0IHQ9cyhlLHYpO2lmKHQudmFsdWVUeXBlPT1pLkxpc3Qpci5wdXNoKHQpO2Vsc2V7aWYodC52YWx1ZVR5cGUhPWkuSW50KXtjb25zdCBlPWlbdC52YWx1ZVR5cGVdO3Rocm93IG5ldyBTKFwiQ2Fubm90IG1peCBMaXN0cyBhbmQgXCIrZStcIiB2YWx1ZXMgaW4gdGhpcyBvcGVyYXRpb25cIil9e2xldCBlPXBhcnNlSW50KHQudmFsdWVPYmplY3QpO2lmKG49cyhuLE8pLG51bGw9PT1uLnZhbHVlKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSBzcGVjaWFsQ2FzZUxpc3QudmFsdWVcIik7bGV0IGk9bi52YWx1ZS5vcmlnaW5PZk1heEl0ZW07aWYobnVsbD09PWkpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIGxpc3RcIik7bGV0IGE9aS5UcnlHZXRJdGVtV2l0aFZhbHVlKGUsZi5OdWxsKTtpZighYS5leGlzdHMpdGhyb3cgbmV3IFMoXCJDb3VsZCBub3QgZmluZCBMaXN0IGl0ZW0gd2l0aCB0aGUgdmFsdWUgXCIrZStcIiBpbiBcIitpLm5hbWUpO3tsZXQgdD1uZXcgTyhhLnJlc3VsdCxlKTtyLnB1c2godCl9fX19ZWxzZSBmb3IobGV0IG4gb2YgdCl7bGV0IHQ9cyhuLHYpLkNhc3QoZSk7ci5wdXNoKHQpfXJldHVybiByfXN0YXRpYyBJZGVudGl0eSh0KXtyZXR1cm4gdH1zdGF0aWMgR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpe2lmKG51bGw9PXRoaXMuX25hdGl2ZUZ1bmN0aW9ucyl7dGhpcy5fbmF0aXZlRnVuY3Rpb25zPW5ldyBNYXAsdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFkZCwodCxlKT0+dCtlKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsKHQsZSk9PnQtZSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCh0LGUpPT50KmUpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5EaXZpZGUsKHQsZSk9Pk1hdGguZmxvb3IodC9lKSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1vZCwodCxlKT0+dCVlKSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5OZWdhdGUsdD0+LXQpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5FcXVhbCwodCxlKT0+dD09ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyLCh0LGUpPT50PmU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzcywodCxlKT0+dDxlPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsKHQsZSk9PnQ+PWU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywodCxlKT0+dDw9ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsKHQsZSk9PnQhPWU/MTowKSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5Ob3QsdD0+MD09dD8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5BbmQsKHQsZSk9PjAhPXQmJjAhPWU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuT3IsKHQsZSk9PjAhPXR8fDAhPWU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTWF4LCh0LGUpPT5NYXRoLm1heCh0LGUpKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTWluLCh0LGUpPT5NYXRoLm1pbih0LGUpKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuUG93LCh0LGUpPT5NYXRoLnBvdyh0LGUpKSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5GbG9vcixSLklkZW50aXR5KSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5DZWlsaW5nLFIuSWRlbnRpdHkpLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkludCxSLklkZW50aXR5KSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5GbG9hdCx0PT50KSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5BZGQsKHQsZSk9PnQrZSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsKHQsZSk9PnQtZSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTXVsdGlwbHksKHQsZSk9PnQqZSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuRGl2aWRlLCh0LGUpPT50L2UpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1vZCwodCxlKT0+dCVlKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLk5lZ2F0ZSx0PT4tdCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuRXF1YWwsKHQsZSk9PnQ9PWU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5HcmVhdGVyLCh0LGUpPT50PmU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzLCh0LGUpPT50PGU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCh0LGUpPT50Pj1lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywodCxlKT0+dDw9ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywodCxlKT0+dCE9ZT8xOjApLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuTm90LHQ9PjA9PXQ/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5BbmQsKHQsZSk9PjAhPXQmJjAhPWU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5PciwodCxlKT0+MCE9dHx8MCE9ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1heCwodCxlKT0+TWF0aC5tYXgodCxlKSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTWluLCh0LGUpPT5NYXRoLm1pbih0LGUpKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Qb3csKHQsZSk9Pk1hdGgucG93KHQsZSkpLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvb3IsdD0+TWF0aC5mbG9vcih0KSksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5DZWlsaW5nLHQ9Pk1hdGguY2VpbCh0KSksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5JbnQsdD0+TWF0aC5mbG9vcih0KSksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5GbG9hdCxSLklkZW50aXR5KSx0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuQWRkLCh0LGUpPT50K2UpLHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5FcXVhbCwodCxlKT0+dD09PWU/MTowKSx0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCh0LGUpPT50IT09ZT8xOjApLHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5IYXMsKHQsZSk9PnQuaW5jbHVkZXMoZSk/MTowKSx0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuSGFzbnQsKHQsZSk9PnQuaW5jbHVkZXMoZSk/MDoxKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkFkZCwodCxlKT0+dC5VbmlvbihlKSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwodCxlKT0+dC5XaXRob3V0KGUpKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkhhcywodCxlKT0+dC5Db250YWlucyhlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSGFzbnQsKHQsZSk9PnQuQ29udGFpbnMoZSk/MDoxKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkludGVyc2VjdCwodCxlKT0+dC5JbnRlcnNlY3QoZSkpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuRXF1YWwsKHQsZSk9PnQuRXF1YWxzKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5HcmVhdGVyLCh0LGUpPT50LkdyZWF0ZXJUaGFuKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5MZXNzLCh0LGUpPT50Lkxlc3NUaGFuKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCh0LGUpPT50LkdyZWF0ZXJUaGFuT3JFcXVhbHMoZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsKHQsZSk9PnQuTGVzc1RoYW5PckVxdWFscyhlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCh0LGUpPT50LkVxdWFscyhlKT8wOjEpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuQW5kLCh0LGUpPT50LkNvdW50PjAmJmUuQ291bnQ+MD8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuT3IsKHQsZSk9PnQuQ291bnQ+MHx8ZS5Db3VudD4wPzE6MCksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLk5vdCx0PT4wPT10LkNvdW50PzE6MCksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkludmVydCx0PT50LmludmVyc2UpLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5BbGwsdD0+dC5hbGwpLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWluLHQ9PnQuTWluQXNMaXN0KCkpLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWF4LHQ9PnQuTWF4QXNMaXN0KCkpLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5Db3VudCx0PT50LkNvdW50KSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuVmFsdWVPZkxpc3QsdD0+dC5tYXhJdGVtLlZhbHVlKTtsZXQgdD0odCxlKT0+dC5FcXVhbHMoZSk/MTowLGU9KHQsZSk9PnQuRXF1YWxzKGUpPzA6MTt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHRoaXMuRXF1YWwsMixpLkRpdmVydFRhcmdldCx0KSx0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHRoaXMuTm90RXF1YWxzLDIsaS5EaXZlcnRUYXJnZXQsZSl9fUFkZE9wRnVuY0ZvclR5cGUodCxlKXtudWxsPT10aGlzLl9vcGVyYXRpb25GdW5jcyYmKHRoaXMuX29wZXJhdGlvbkZ1bmNzPW5ldyBNYXApLHRoaXMuX29wZXJhdGlvbkZ1bmNzLnNldCh0LGUpfXN0YXRpYyBBZGRPcFRvTmF0aXZlRnVuYyh0LGUsbixpKXtpZihudWxsPT09dGhpcy5fbmF0aXZlRnVuY3Rpb25zKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnNcIik7bGV0IHI9dGhpcy5fbmF0aXZlRnVuY3Rpb25zLmdldCh0KTtyfHwocj1uZXcgUih0LGUpLHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5zZXQodCxyKSksci5BZGRPcEZ1bmNGb3JUeXBlKG4saSl9c3RhdGljIEFkZEludEJpbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDIsaS5JbnQsZSl9c3RhdGljIEFkZEludFVuYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMSxpLkludCxlKX1zdGF0aWMgQWRkRmxvYXRCaW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwyLGkuRmxvYXQsZSl9c3RhdGljIEFkZEZsb2F0VW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwxLGkuRmxvYXQsZSl9c3RhdGljIEFkZFN0cmluZ0JpbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDIsaS5TdHJpbmcsZSl9c3RhdGljIEFkZExpc3RCaW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwyLGkuTGlzdCxlKX1zdGF0aWMgQWRkTGlzdFVuYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMSxpLkxpc3QsZSl9dG9TdHJpbmcoKXtyZXR1cm4nTmF0aXZlIFwiJyt0aGlzLm5hbWUrJ1wiJ319Ui5BZGQ9XCIrXCIsUi5TdWJ0cmFjdD1cIi1cIixSLkRpdmlkZT1cIi9cIixSLk11bHRpcGx5PVwiKlwiLFIuTW9kPVwiJVwiLFIuTmVnYXRlPVwiX1wiLFIuRXF1YWw9XCI9PVwiLFIuR3JlYXRlcj1cIj5cIixSLkxlc3M9XCI8XCIsUi5HcmVhdGVyVGhhbk9yRXF1YWxzPVwiPj1cIixSLkxlc3NUaGFuT3JFcXVhbHM9XCI8PVwiLFIuTm90RXF1YWxzPVwiIT1cIixSLk5vdD1cIiFcIixSLkFuZD1cIiYmXCIsUi5Pcj1cInx8XCIsUi5NaW49XCJNSU5cIixSLk1heD1cIk1BWFwiLFIuUG93PVwiUE9XXCIsUi5GbG9vcj1cIkZMT09SXCIsUi5DZWlsaW5nPVwiQ0VJTElOR1wiLFIuSW50PVwiSU5UXCIsUi5GbG9hdD1cIkZMT0FUXCIsUi5IYXM9XCI/XCIsUi5IYXNudD1cIiE/XCIsUi5JbnRlcnNlY3Q9XCJeXCIsUi5MaXN0TWluPVwiTElTVF9NSU5cIixSLkxpc3RNYXg9XCJMSVNUX01BWFwiLFIuQWxsPVwiTElTVF9BTExcIixSLkNvdW50PVwiTElTVF9DT1VOVFwiLFIuVmFsdWVPZkxpc3Q9XCJMSVNUX1ZBTFVFXCIsUi5JbnZlcnQ9XCJMSVNUX0lOVkVSVFwiLFIuX25hdGl2ZUZ1bmN0aW9ucz1udWxsO2NsYXNzIGogZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQpe3N1cGVyKCksdGhpcy50ZXh0PXQudG9TdHJpbmcoKXx8XCJcIn10b1N0cmluZygpe3JldHVyblwiIyBcIit0aGlzLnRleHR9fWNsYXNzIEQgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLnRleHQ9XCJcIix0aGlzLmluZGV4PTAsdGhpcy50aHJlYWRBdEdlbmVyYXRpb249bnVsbCx0aGlzLnNvdXJjZVBhdGg9XCJcIix0aGlzLnRhcmdldFBhdGg9bnVsbCx0aGlzLmlzSW52aXNpYmxlRGVmYXVsdD0hMSx0aGlzLm9yaWdpbmFsVGhyZWFkSW5kZXg9MH1nZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCl7cmV0dXJuIG51bGw9PT10aGlzLnRhcmdldFBhdGg/ZChcIkNob2ljZS50YXJnZXRQYXRoXCIpOnRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpfXNldCBwYXRoU3RyaW5nT25DaG9pY2UodCl7dGhpcy50YXJnZXRQYXRoPW5ldyBlKHQpfX1jbGFzcyBHe2NvbnN0cnVjdG9yKHQsZSl7dGhpcy5fbmFtZT10fHxcIlwiLHRoaXMuX2l0ZW1zPW51bGwsdGhpcy5faXRlbU5hbWVUb1ZhbHVlcz1lfHxuZXcgTWFwfWdldCBuYW1lKCl7cmV0dXJuIHRoaXMuX25hbWV9Z2V0IGl0ZW1zKCl7aWYobnVsbD09dGhpcy5faXRlbXMpe3RoaXMuX2l0ZW1zPW5ldyBNYXA7Zm9yKGxldFt0LGVdb2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcyl7bGV0IG49bmV3IGYodGhpcy5uYW1lLHQpO3RoaXMuX2l0ZW1zLnNldChuLnNlcmlhbGl6ZWQoKSxlKX19cmV0dXJuIHRoaXMuX2l0ZW1zfVZhbHVlRm9ySXRlbSh0KXtpZighdC5pdGVtTmFtZSlyZXR1cm4gMDtsZXQgZT10aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmdldCh0Lml0ZW1OYW1lKTtyZXR1cm4gdm9pZCAwIT09ZT9lOjB9Q29udGFpbnNJdGVtKHQpe3JldHVybiEhdC5pdGVtTmFtZSYmKHQub3JpZ2luTmFtZT09dGhpcy5uYW1lJiZ0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyh0Lml0ZW1OYW1lKSl9Q29udGFpbnNJdGVtV2l0aE5hbWUodCl7cmV0dXJuIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuaGFzKHQpfVRyeUdldEl0ZW1XaXRoVmFsdWUodCxlKXtmb3IobGV0W2Usbl1vZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKWlmKG49PXQpcmV0dXJue3Jlc3VsdDpuZXcgZih0aGlzLm5hbWUsZSksZXhpc3RzOiEwfTtyZXR1cm57cmVzdWx0OmYuTnVsbCxleGlzdHM6ITF9fVRyeUdldFZhbHVlRm9ySXRlbSh0LGUpe2lmKCF0Lml0ZW1OYW1lKXJldHVybntyZXN1bHQ6MCxleGlzdHM6ITF9O2xldCBuPXRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KHQuaXRlbU5hbWUpO3JldHVybiBuP3tyZXN1bHQ6bixleGlzdHM6ITB9OntyZXN1bHQ6MCxleGlzdHM6ITF9fX1jbGFzcyBCe2NvbnN0cnVjdG9yKHQpe3RoaXMuX2xpc3RzPW5ldyBNYXAsdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZT1uZXcgTWFwO2ZvcihsZXQgZSBvZiB0KXt0aGlzLl9saXN0cy5zZXQoZS5uYW1lLGUpO2ZvcihsZXRbdCxuXW9mIGUuaXRlbXMpe2xldCBlPWYuZnJvbVNlcmlhbGl6ZWRLZXkodCksaT1uZXcgTyhlLG4pO2lmKCFlLml0ZW1OYW1lKXRocm93IG5ldyBFcnJvcihcIml0ZW0uaXRlbU5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWQuXCIpO3RoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuc2V0KGUuaXRlbU5hbWUsaSksdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5zZXQoZS5mdWxsTmFtZSxpKX19fWdldCBsaXN0cygpe2xldCB0PVtdO2ZvcihsZXRbLGVdb2YgdGhpcy5fbGlzdHMpdC5wdXNoKGUpO3JldHVybiB0fVRyeUxpc3RHZXREZWZpbml0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJue3Jlc3VsdDplLGV4aXN0czohMX07bGV0IG49dGhpcy5fbGlzdHMuZ2V0KHQpO3JldHVybiBuP3tyZXN1bHQ6bixleGlzdHM6ITB9OntyZXN1bHQ6ZSxleGlzdHM6ITF9fUZpbmRTaW5nbGVJdGVtTGlzdFdpdGhOYW1lKHQpe2lmKG51bGw9PT10KXJldHVybiBkKFwibmFtZVwiKTtsZXQgZT10aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLmdldCh0KTtyZXR1cm4gdm9pZCAwIT09ZT9lOm51bGx9fWNsYXNzIE17c3RhdGljIEpBcnJheVRvUnVudGltZU9iakxpc3QodCxlPSExKXtsZXQgbj10Lmxlbmd0aDtlJiZuLS07bGV0IGk9W107Zm9yKGxldCBlPTA7ZTxuO2UrKyl7bGV0IG49dFtlXSxyPXRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KG4pO2lmKG51bGw9PT1yKXJldHVybiBkKFwicnVudGltZU9ialwiKTtpLnB1c2gocil9cmV0dXJuIGl9c3RhdGljIFdyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHQsZSl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldFtuLGldb2YgZSl0LldyaXRlUHJvcGVydHlTdGFydChuKSx0aGlzLldyaXRlUnVudGltZU9iamVjdCh0LGkpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpO3QuV3JpdGVPYmplY3RFbmQoKX1zdGF0aWMgV3JpdGVMaXN0UnVudGltZU9ianModCxlKXt0LldyaXRlQXJyYXlTdGFydCgpO2ZvcihsZXQgbiBvZiBlKXRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHQsbik7dC5Xcml0ZUFycmF5RW5kKCl9c3RhdGljIFdyaXRlSW50RGljdGlvbmFyeSh0LGUpe3QuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXRbbixpXW9mIGUpdC5Xcml0ZUludFByb3BlcnR5KG4saSk7dC5Xcml0ZU9iamVjdEVuZCgpfXN0YXRpYyBXcml0ZVJ1bnRpbWVPYmplY3QodCxlKXtsZXQgbj1hKGUsTik7aWYobilyZXR1cm4gdm9pZCB0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih0LG4pO2xldCBpPWEoZSxrKTtpZihpKXtsZXQgZSxuPVwiLT5cIjtyZXR1cm4gaS5pc0V4dGVybmFsP249XCJ4KClcIjppLnB1c2hlc1RvU3RhY2smJihpLnN0YWNrUHVzaFR5cGU9PXIuRnVuY3Rpb24/bj1cImYoKVwiOmkuc3RhY2tQdXNoVHlwZT09ci5UdW5uZWwmJihuPVwiLT50LT5cIikpLGU9aS5oYXNWYXJpYWJsZVRhcmdldD9pLnZhcmlhYmxlRGl2ZXJ0TmFtZTppLnRhcmdldFBhdGhTdHJpbmcsdC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5KG4sZSksaS5oYXNWYXJpYWJsZVRhcmdldCYmdC5Xcml0ZVByb3BlcnR5KFwidmFyXCIsITApLGkuaXNDb25kaXRpb25hbCYmdC5Xcml0ZVByb3BlcnR5KFwiY1wiLCEwKSxpLmV4dGVybmFsQXJncz4wJiZ0LldyaXRlSW50UHJvcGVydHkoXCJleEFyZ3NcIixpLmV4dGVybmFsQXJncyksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCl9bGV0IHM9YShlLFcpO2lmKHMpcmV0dXJuIHQuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eShcIipcIixzLnBhdGhTdHJpbmdPbkNob2ljZSksdC5Xcml0ZUludFByb3BlcnR5KFwiZmxnXCIscy5mbGFncyksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCk7bGV0IGw9YShlLGIpO2lmKGwpcmV0dXJuIHZvaWQgdC5Xcml0ZUludChsLnZhbHVlKTtsZXQgbz1hKGUsXyk7aWYobylyZXR1cm4gdm9pZCB0LldyaXRlRmxvYXQoby52YWx1ZSk7bGV0IHU9YShlLFQpO2lmKHUpcmV0dXJuIHZvaWQodS5pc05ld2xpbmU/dC5Xcml0ZShcIlxcblwiLCExKToodC5Xcml0ZVN0cmluZ1N0YXJ0KCksdC5Xcml0ZVN0cmluZ0lubmVyKFwiXlwiKSx0LldyaXRlU3RyaW5nSW5uZXIodS52YWx1ZSksdC5Xcml0ZVN0cmluZ0VuZCgpKSk7bGV0IGg9YShlLE8pO2lmKGgpcmV0dXJuIHZvaWQgdGhpcy5Xcml0ZUlua0xpc3QodCxoKTtsZXQgYz1hKGUsUCk7aWYoYylyZXR1cm4gdC5Xcml0ZU9iamVjdFN0YXJ0KCksbnVsbD09PWMudmFsdWU/ZChcImRpdlRhcmdldFZhbC52YWx1ZVwiKToodC5Xcml0ZVByb3BlcnR5KFwiXi0+XCIsYy52YWx1ZS5jb21wb25lbnRzU3RyaW5nKSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKSk7bGV0IHA9YShlLHcpO2lmKHApcmV0dXJuIHQuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eShcIl52YXJcIixwLnZhbHVlKSx0LldyaXRlSW50UHJvcGVydHkoXCJjaVwiLHAuY29udGV4dEluZGV4KSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKTtpZihhKGUseCkpcmV0dXJuIHZvaWQgdC5Xcml0ZShcIjw+XCIpO2xldCBtPWEoZSxBKTtpZihtKXJldHVybiB2b2lkIHQuV3JpdGUoTS5fY29udHJvbENvbW1hbmROYW1lc1ttLmNvbW1hbmRUeXBlXSk7bGV0IGY9YShlLFIpO2lmKGYpe2xldCBlPWYubmFtZTtyZXR1cm5cIl5cIj09ZSYmKGU9XCJMXlwiKSx2b2lkIHQuV3JpdGUoZSl9bGV0IGc9YShlLEYpO2lmKGcpe3QuV3JpdGVPYmplY3RTdGFydCgpO2xldCBlPWcucGF0aFN0cmluZ0ZvckNvdW50O3JldHVybiBudWxsIT1lP3QuV3JpdGVQcm9wZXJ0eShcIkNOVD9cIixlKTp0LldyaXRlUHJvcGVydHkoXCJWQVI/XCIsZy5uYW1lKSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKX1sZXQgUz1hKGUsVik7aWYoUyl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7bGV0IGU9Uy5pc0dsb2JhbD9cIlZBUj1cIjpcInRlbXA9XCI7cmV0dXJuIHQuV3JpdGVQcm9wZXJ0eShlLFMudmFyaWFibGVOYW1lKSxTLmlzTmV3RGVjbGFyYXRpb258fHQuV3JpdGVQcm9wZXJ0eShcInJlXCIsITApLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpfWlmKGEoZSxMKSlyZXR1cm4gdm9pZCB0LldyaXRlKFwidm9pZFwiKTtsZXQgeT1hKGUsaik7aWYoeSlyZXR1cm4gdC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5KFwiI1wiLHkudGV4dCksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCk7bGV0IEM9YShlLEQpO2lmKCFDKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHJ1bnRpbWUgb2JqZWN0IHRvIEpzb24gdG9rZW46IFwiK2UpO3RoaXMuV3JpdGVDaG9pY2UodCxDKX1zdGF0aWMgSk9iamVjdFRvRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHQpe2xldCBlPW5ldyBNYXA7Zm9yKGxldCBuIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShuKSl7bGV0IGk9dGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3QodFtuXSk7aWYobnVsbD09PWkpcmV0dXJuIGQoXCJpbmtPYmplY3RcIik7ZS5zZXQobixpKX1yZXR1cm4gZX1zdGF0aWMgSk9iamVjdFRvSW50RGljdGlvbmFyeSh0KXtsZXQgZT1uZXcgTWFwO2ZvcihsZXQgbiBpbiB0KXQuaGFzT3duUHJvcGVydHkobikmJmUuc2V0KG4scGFyc2VJbnQodFtuXSkpO3JldHVybiBlfXN0YXRpYyBKVG9rZW5Ub1J1bnRpbWVPYmplY3QodCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQmJiFpc05hTih0KSlyZXR1cm4gdi5DcmVhdGUodCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2xldCBlPXQudG9TdHJpbmcoKSxuPWVbMF07aWYoXCJeXCI9PW4pcmV0dXJuIG5ldyBUKGUuc3Vic3RyaW5nKDEpKTtpZihcIlxcblwiPT1uJiYxPT1lLmxlbmd0aClyZXR1cm4gbmV3IFQoXCJcXG5cIik7aWYoXCI8PlwiPT1lKXJldHVybiBuZXcgeDtmb3IobGV0IHQ9MDt0PE0uX2NvbnRyb2xDb21tYW5kTmFtZXMubGVuZ3RoOysrdCl7aWYoZT09TS5fY29udHJvbENvbW1hbmROYW1lc1t0XSlyZXR1cm4gbmV3IEEodCl9aWYoXCJMXlwiPT1lJiYoZT1cIl5cIiksUi5DYWxsRXhpc3RzV2l0aE5hbWUoZSkpcmV0dXJuIFIuQ2FsbFdpdGhOYW1lKGUpO2lmKFwiLT4tPlwiPT1lKXJldHVybiBBLlBvcFR1bm5lbCgpO2lmKFwifnJldFwiPT1lKXJldHVybiBBLlBvcEZ1bmN0aW9uKCk7aWYoXCJ2b2lkXCI9PWUpcmV0dXJuIG5ldyBMfWlmKFwib2JqZWN0XCI9PXR5cGVvZiB0JiYhQXJyYXkuaXNBcnJheSh0KSl7bGV0IG4saT10O2lmKGlbXCJeLT5cIl0pcmV0dXJuIG49aVtcIl4tPlwiXSxuZXcgUChuZXcgZShuLnRvU3RyaW5nKCkpKTtpZihpW1wiXnZhclwiXSl7bj1pW1wiXnZhclwiXTtsZXQgdD1uZXcgdyhuLnRvU3RyaW5nKCkpO3JldHVyblwiY2lcImluIGkmJihuPWkuY2ksdC5jb250ZXh0SW5kZXg9cGFyc2VJbnQobikpLHR9bGV0IGE9ITEscz0hMSxsPXIuRnVuY3Rpb24sbz0hMTtpZigobj1pW1wiLT5cIl0pP2E9ITA6KG49aVtcImYoKVwiXSk/KGE9ITAscz0hMCxsPXIuRnVuY3Rpb24pOihuPWlbXCItPnQtPlwiXSk/KGE9ITAscz0hMCxsPXIuVHVubmVsKToobj1pW1wieCgpXCJdKSYmKGE9ITAsbz0hMCxzPSExLGw9ci5GdW5jdGlvbiksYSl7bGV0IHQ9bmV3IGs7dC5wdXNoZXNUb1N0YWNrPXMsdC5zdGFja1B1c2hUeXBlPWwsdC5pc0V4dGVybmFsPW87bGV0IGU9bi50b1N0cmluZygpO3JldHVybihuPWkudmFyKT90LnZhcmlhYmxlRGl2ZXJ0TmFtZT1lOnQudGFyZ2V0UGF0aFN0cmluZz1lLHQuaXNDb25kaXRpb25hbD0hIWkuYyxvJiYobj1pLmV4QXJncykmJih0LmV4dGVybmFsQXJncz1wYXJzZUludChuKSksdH1pZihuPWlbXCIqXCJdKXtsZXQgdD1uZXcgVztyZXR1cm4gdC5wYXRoU3RyaW5nT25DaG9pY2U9bi50b1N0cmluZygpLChuPWkuZmxnKSYmKHQuZmxhZ3M9cGFyc2VJbnQobikpLHR9aWYobj1pW1wiVkFSP1wiXSlyZXR1cm4gbmV3IEYobi50b1N0cmluZygpKTtpZihuPWlbXCJDTlQ/XCJdKXtsZXQgdD1uZXcgRjtyZXR1cm4gdC5wYXRoU3RyaW5nRm9yQ291bnQ9bi50b1N0cmluZygpLHR9bGV0IHU9ITEsaD0hMTtpZigobj1pW1wiVkFSPVwiXSk/KHU9ITAsaD0hMCk6KG49aVtcInRlbXA9XCJdKSYmKHU9ITAsaD0hMSksdSl7bGV0IHQ9bi50b1N0cmluZygpLGU9IWkucmUscj1uZXcgVih0LGUpO3JldHVybiByLmlzR2xvYmFsPWgscn1pZih2b2lkIDAhPT1pW1wiI1wiXSlyZXR1cm4gbj1pW1wiI1wiXSxuZXcgaihuLnRvU3RyaW5nKCkpO2lmKG49aS5saXN0KXtsZXQgdD1uLGU9bmV3IGc7aWYobj1pLm9yaWdpbnMpe2xldCB0PW47ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXModCl9Zm9yKGxldCBuIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShuKSl7bGV0IGk9dFtuXSxyPW5ldyBmKG4pLGE9cGFyc2VJbnQoaSk7ZS5BZGQocixhKX1yZXR1cm4gbmV3IE8oZSl9aWYobnVsbCE9aS5vcmlnaW5hbENob2ljZVBhdGgpcmV0dXJuIHRoaXMuSk9iamVjdFRvQ2hvaWNlKGkpfWlmKEFycmF5LmlzQXJyYXkodCkpcmV0dXJuIHRoaXMuSkFycmF5VG9Db250YWluZXIodCk7aWYobnVsbD09dClyZXR1cm4gbnVsbDt0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCB0b2tlbiB0byBydW50aW1lIG9iamVjdDogXCIrSlNPTi5zdHJpbmdpZnkodCkpfXN0YXRpYyBXcml0ZVJ1bnRpbWVDb250YWluZXIodCxlLG49ITEpe2lmKHQuV3JpdGVBcnJheVN0YXJ0KCksbnVsbD09PWUpcmV0dXJuIGQoXCJjb250YWluZXJcIik7Zm9yKGxldCBuIG9mIGUuY29udGVudCl0aGlzLldyaXRlUnVudGltZU9iamVjdCh0LG4pO2xldCBpPWUubmFtZWRPbmx5Q29udGVudCxyPWUuY291bnRGbGFncyxzPW51bGwhPWUubmFtZSYmIW4sbD1udWxsIT1pfHxyPjB8fHM7aWYobCYmdC5Xcml0ZU9iamVjdFN0YXJ0KCksbnVsbCE9aSlmb3IobGV0W2Usbl1vZiBpKXtsZXQgaT1lLHI9YShuLE4pO3QuV3JpdGVQcm9wZXJ0eVN0YXJ0KGkpLHRoaXMuV3JpdGVSdW50aW1lQ29udGFpbmVyKHQsciwhMCksdC5Xcml0ZVByb3BlcnR5RW5kKCl9cyYmdC5Xcml0ZVByb3BlcnR5KFwiI25cIixlLm5hbWUpLGw/dC5Xcml0ZU9iamVjdEVuZCgpOnQuV3JpdGVOdWxsKCksdC5Xcml0ZUFycmF5RW5kKCl9c3RhdGljIEpBcnJheVRvQ29udGFpbmVyKHQpe2xldCBlPW5ldyBOO2UuY29udGVudD10aGlzLkpBcnJheVRvUnVudGltZU9iakxpc3QodCwhMCk7bGV0IG49dFt0Lmxlbmd0aC0xXTtpZihudWxsIT1uKXtsZXQgdD1uZXcgTWFwO2ZvcihsZXQgaSBpbiBuKWlmKFwiI2ZcIj09aSllLmNvdW50RmxhZ3M9cGFyc2VJbnQobltpXSk7ZWxzZSBpZihcIiNuXCI9PWkpZS5uYW1lPW5baV0udG9TdHJpbmcoKTtlbHNle2xldCBlPXRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KG5baV0pLHI9YShlLE4pO3ImJihyLm5hbWU9aSksdC5zZXQoaSxlKX1lLm5hbWVkT25seUNvbnRlbnQ9dH1yZXR1cm4gZX1zdGF0aWMgSk9iamVjdFRvQ2hvaWNlKHQpe2xldCBlPW5ldyBEO3JldHVybiBlLnRleHQ9dC50ZXh0LnRvU3RyaW5nKCksZS5pbmRleD1wYXJzZUludCh0LmluZGV4KSxlLnNvdXJjZVBhdGg9dC5vcmlnaW5hbENob2ljZVBhdGgudG9TdHJpbmcoKSxlLm9yaWdpbmFsVGhyZWFkSW5kZXg9cGFyc2VJbnQodC5vcmlnaW5hbFRocmVhZEluZGV4KSxlLnBhdGhTdHJpbmdPbkNob2ljZT10LnRhcmdldFBhdGgudG9TdHJpbmcoKSxlfXN0YXRpYyBXcml0ZUNob2ljZSh0LGUpe3QuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eShcInRleHRcIixlLnRleHQpLHQuV3JpdGVJbnRQcm9wZXJ0eShcImluZGV4XCIsZS5pbmRleCksdC5Xcml0ZVByb3BlcnR5KFwib3JpZ2luYWxDaG9pY2VQYXRoXCIsZS5zb3VyY2VQYXRoKSx0LldyaXRlSW50UHJvcGVydHkoXCJvcmlnaW5hbFRocmVhZEluZGV4XCIsZS5vcmlnaW5hbFRocmVhZEluZGV4KSx0LldyaXRlUHJvcGVydHkoXCJ0YXJnZXRQYXRoXCIsZS5wYXRoU3RyaW5nT25DaG9pY2UpLHQuV3JpdGVPYmplY3RFbmQoKX1zdGF0aWMgV3JpdGVJbmtMaXN0KHQsZSl7bGV0IG49ZS52YWx1ZTtpZihudWxsPT09bilyZXR1cm4gZChcInJhd0xpc3RcIik7dC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJsaXN0XCIpLHQuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXRbZSxpXW9mIG4pe2xldCBuPWYuZnJvbVNlcmlhbGl6ZWRLZXkoZSkscj1pO2lmKG51bGw9PT1uLml0ZW1OYW1lKXJldHVybiBkKFwiaXRlbS5pdGVtTmFtZVwiKTt0LldyaXRlUHJvcGVydHlOYW1lU3RhcnQoKSx0LldyaXRlUHJvcGVydHlOYW1lSW5uZXIobi5vcmlnaW5OYW1lP24ub3JpZ2luTmFtZTpcIj9cIiksdC5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKFwiLlwiKSx0LldyaXRlUHJvcGVydHlOYW1lSW5uZXIobi5pdGVtTmFtZSksdC5Xcml0ZVByb3BlcnR5TmFtZUVuZCgpLHQuV3JpdGUociksdC5Xcml0ZVByb3BlcnR5RW5kKCl9aWYodC5Xcml0ZU9iamVjdEVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpLDA9PW4uQ291bnQmJm51bGwhPW4ub3JpZ2luTmFtZXMmJm4ub3JpZ2luTmFtZXMubGVuZ3RoPjApe3QuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwib3JpZ2luc1wiKSx0LldyaXRlQXJyYXlTdGFydCgpO2ZvcihsZXQgZSBvZiBuLm9yaWdpbk5hbWVzKXQuV3JpdGUoZSk7dC5Xcml0ZUFycmF5RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCl9dC5Xcml0ZU9iamVjdEVuZCgpfXN0YXRpYyBMaXN0RGVmaW5pdGlvbnNUb0pUb2tlbih0KXtsZXQgZT17fTtmb3IobGV0IG4gb2YgdC5saXN0cyl7bGV0IHQ9e307Zm9yKGxldFtlLGldb2Ygbi5pdGVtcyl7bGV0IG49Zi5mcm9tU2VyaWFsaXplZEtleShlKTtpZihudWxsPT09bi5pdGVtTmFtZSlyZXR1cm4gZChcIml0ZW0uaXRlbU5hbWVcIik7dFtuLml0ZW1OYW1lXT1pfWVbbi5uYW1lXT10fXJldHVybiBlfXN0YXRpYyBKVG9rZW5Ub0xpc3REZWZpbml0aW9ucyh0KXtsZXQgZT10LG49W107Zm9yKGxldCB0IGluIGUpaWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSl7bGV0IGk9dC50b1N0cmluZygpLHI9ZVt0XSxhPW5ldyBNYXA7Zm9yKGxldCBuIGluIHIpaWYoZS5oYXNPd25Qcm9wZXJ0eSh0KSl7bGV0IHQ9cltuXTthLnNldChuLHBhcnNlSW50KHQpKX1sZXQgcz1uZXcgRyhpLGEpO24ucHVzaChzKX1yZXR1cm4gbmV3IEIobil9fU0uX2NvbnRyb2xDb21tYW5kTmFtZXM9KCgpPT57bGV0IHQ9W107dFtBLkNvbW1hbmRUeXBlLkV2YWxTdGFydF09XCJldlwiLHRbQS5Db21tYW5kVHlwZS5FdmFsT3V0cHV0XT1cIm91dFwiLHRbQS5Db21tYW5kVHlwZS5FdmFsRW5kXT1cIi9ldlwiLHRbQS5Db21tYW5kVHlwZS5EdXBsaWNhdGVdPVwiZHVcIix0W0EuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWVdPVwicG9wXCIsdFtBLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uXT1cIn5yZXRcIix0W0EuQ29tbWFuZFR5cGUuUG9wVHVubmVsXT1cIi0+LT5cIix0W0EuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmddPVwic3RyXCIsdFtBLkNvbW1hbmRUeXBlLkVuZFN0cmluZ109XCIvc3RyXCIsdFtBLkNvbW1hbmRUeXBlLk5vT3BdPVwibm9wXCIsdFtBLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50XT1cImNob2ljZUNudFwiLHRbQS5Db21tYW5kVHlwZS5UdXJuc109XCJ0dXJuXCIsdFtBLkNvbW1hbmRUeXBlLlR1cm5zU2luY2VdPVwidHVybnNcIix0W0EuQ29tbWFuZFR5cGUuUmVhZENvdW50XT1cInJlYWRjXCIsdFtBLkNvbW1hbmRUeXBlLlJhbmRvbV09XCJybmRcIix0W0EuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbV09XCJzcm5kXCIsdFtBLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXhdPVwidmlzaXRcIix0W0EuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXhdPVwic2VxXCIsdFtBLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkXT1cInRocmVhZFwiLHRbQS5Db21tYW5kVHlwZS5Eb25lXT1cImRvbmVcIix0W0EuQ29tbWFuZFR5cGUuRW5kXT1cImVuZFwiLHRbQS5Db21tYW5kVHlwZS5MaXN0RnJvbUludF09XCJsaXN0SW50XCIsdFtBLkNvbW1hbmRUeXBlLkxpc3RSYW5nZV09XCJyYW5nZVwiLHRbQS5Db21tYW5kVHlwZS5MaXN0UmFuZG9tXT1cImxybmRcIjtmb3IobGV0IGU9MDtlPEEuQ29tbWFuZFR5cGUuVE9UQUxfVkFMVUVTOysrZSlpZihudWxsPT10W2VdKXRocm93IG5ldyBFcnJvcihcIkNvbnRyb2wgY29tbWFuZCBub3QgYWNjb3VudGVkIGZvciBpbiBzZXJpYWxpc2F0aW9uXCIpO3JldHVybiB0fSkoKTtjbGFzcyBxe2NvbnN0cnVjdG9yKCl7aWYodGhpcy5fdGhyZWFkQ291bnRlcj0wLHRoaXMuX3N0YXJ0T2ZSb290PUkuTnVsbCxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFgpe2xldCB0PWFyZ3VtZW50c1swXTt0aGlzLl9zdGFydE9mUm9vdD1JLlN0YXJ0T2YodC5yb290Q29udGVudENvbnRhaW5lciksdGhpcy5SZXNldCgpfWVsc2V7bGV0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3RocmVhZHM9W107Zm9yKGxldCBlIG9mIHQuX3RocmVhZHMpdGhpcy5fdGhyZWFkcy5wdXNoKGUuQ29weSgpKTt0aGlzLl90aHJlYWRDb3VudGVyPXQuX3RocmVhZENvdW50ZXIsdGhpcy5fc3RhcnRPZlJvb3Q9dC5fc3RhcnRPZlJvb3R9fWdldCBlbGVtZW50cygpe3JldHVybiB0aGlzLmNhbGxTdGFja31nZXQgZGVwdGgoKXtyZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGh9Z2V0IGN1cnJlbnRFbGVtZW50KCl7bGV0IHQ9dGhpcy5fdGhyZWFkc1t0aGlzLl90aHJlYWRzLmxlbmd0aC0xXS5jYWxsc3RhY2s7cmV0dXJuIHRbdC5sZW5ndGgtMV19Z2V0IGN1cnJlbnRFbGVtZW50SW5kZXgoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2subGVuZ3RoLTF9Z2V0IGN1cnJlbnRUaHJlYWQoKXtyZXR1cm4gdGhpcy5fdGhyZWFkc1t0aGlzLl90aHJlYWRzLmxlbmd0aC0xXX1zZXQgY3VycmVudFRocmVhZCh0KXtuLkFzc2VydCgxPT10aGlzLl90aHJlYWRzLmxlbmd0aCxcIlNob3VsZG4ndCBiZSBkaXJlY3RseSBzZXR0aW5nIHRoZSBjdXJyZW50IHRocmVhZCB3aGVuIHdlIGhhdmUgYSBzdGFjayBvZiB0aGVtXCIpLHRoaXMuX3RocmVhZHMubGVuZ3RoPTAsdGhpcy5fdGhyZWFkcy5wdXNoKHQpfWdldCBjYW5Qb3AoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2subGVuZ3RoPjF9UmVzZXQoKXt0aGlzLl90aHJlYWRzPVtdLHRoaXMuX3RocmVhZHMucHVzaChuZXcgcS5UaHJlYWQpLHRoaXMuX3RocmVhZHNbMF0uY2FsbHN0YWNrLnB1c2gobmV3IHEuRWxlbWVudChyLlR1bm5lbCx0aGlzLl9zdGFydE9mUm9vdCkpfVNldEpzb25Ub2tlbih0LGUpe3RoaXMuX3RocmVhZHMubGVuZ3RoPTA7bGV0IG49dC50aHJlYWRzO2ZvcihsZXQgdCBvZiBuKXtsZXQgbj10LGk9bmV3IHEuVGhyZWFkKG4sZSk7dGhpcy5fdGhyZWFkcy5wdXNoKGkpfXRoaXMuX3RocmVhZENvdW50ZXI9cGFyc2VJbnQodC50aHJlYWRDb3VudGVyKSx0aGlzLl9zdGFydE9mUm9vdD1JLlN0YXJ0T2YoZS5yb290Q29udGVudENvbnRhaW5lcil9V3JpdGVKc29uKHQpe3QuV3JpdGVPYmplY3QodD0+e3QuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGhyZWFkc1wiKSx0LldyaXRlQXJyYXlTdGFydCgpO2ZvcihsZXQgZSBvZiB0aGlzLl90aHJlYWRzKWUuV3JpdGVKc29uKHQpO3QuV3JpdGVBcnJheUVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpLHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGhyZWFkQ291bnRlclwiKSx0LldyaXRlSW50KHRoaXMuX3RocmVhZENvdW50ZXIpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfSl9UHVzaFRocmVhZCgpe2xldCB0PXRoaXMuY3VycmVudFRocmVhZC5Db3B5KCk7dGhpcy5fdGhyZWFkQ291bnRlcisrLHQudGhyZWFkSW5kZXg9dGhpcy5fdGhyZWFkQ291bnRlcix0aGlzLl90aHJlYWRzLnB1c2godCl9Rm9ya1RocmVhZCgpe2xldCB0PXRoaXMuY3VycmVudFRocmVhZC5Db3B5KCk7cmV0dXJuIHRoaXMuX3RocmVhZENvdW50ZXIrKyx0LnRocmVhZEluZGV4PXRoaXMuX3RocmVhZENvdW50ZXIsdH1Qb3BUaHJlYWQoKXtpZighdGhpcy5jYW5Qb3BUaHJlYWQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcG9wIHRocmVhZFwiKTt0aGlzLl90aHJlYWRzLnNwbGljZSh0aGlzLl90aHJlYWRzLmluZGV4T2YodGhpcy5jdXJyZW50VGhyZWFkKSwxKX1nZXQgY2FuUG9wVGhyZWFkKCl7cmV0dXJuIHRoaXMuX3RocmVhZHMubGVuZ3RoPjEmJiF0aGlzLmVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWV9Z2V0IGVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWUoKXtyZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC50eXBlPT1yLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lfVB1c2godCxlPTAsbj0wKXtsZXQgaT1uZXcgcS5FbGVtZW50KHQsdGhpcy5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciwhMSk7aS5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkPWUsaS5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW09bix0aGlzLmNhbGxTdGFjay5wdXNoKGkpfUNhblBvcCh0PW51bGwpe3JldHVybiEhdGhpcy5jYW5Qb3AmJihudWxsPT10fHx0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGU9PXQpfVBvcCh0PW51bGwpe2lmKCF0aGlzLkNhblBvcCh0KSl0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHB1c2gvcG9wIGluIENhbGxzdGFja1wiKTt0aGlzLmNhbGxTdGFjay5wb3AoKX1HZXRUZW1wb3JhcnlWYXJpYWJsZVdpdGhOYW1lKHQsZT0tMSl7LTE9PWUmJihlPXRoaXMuY3VycmVudEVsZW1lbnRJbmRleCsxKTtsZXQgbj15KHRoaXMuY2FsbFN0YWNrW2UtMV0udGVtcG9yYXJ5VmFyaWFibGVzLHQsbnVsbCk7cmV0dXJuIG4uZXhpc3RzP24ucmVzdWx0Om51bGx9U2V0VGVtcG9yYXJ5VmFyaWFibGUodCxlLG4saT0tMSl7LTE9PWkmJihpPXRoaXMuY3VycmVudEVsZW1lbnRJbmRleCsxKTtsZXQgcj10aGlzLmNhbGxTdGFja1tpLTFdO2lmKCFuJiYhci50ZW1wb3JhcnlWYXJpYWJsZXMuZ2V0KHQpKXRocm93IG5ldyBTKFwiQ291bGQgbm90IGZpbmQgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIHNldDogXCIrdCk7bGV0IGE9eShyLnRlbXBvcmFyeVZhcmlhYmxlcyx0LG51bGwpO2EuZXhpc3RzJiZPLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChhLnJlc3VsdCxlKSxyLnRlbXBvcmFyeVZhcmlhYmxlcy5zZXQodCxlKX1Db250ZXh0Rm9yVmFyaWFibGVOYW1lZCh0KXtyZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMuZ2V0KHQpP3RoaXMuY3VycmVudEVsZW1lbnRJbmRleCsxOjB9VGhyZWFkV2l0aEluZGV4KHQpe2xldCBlPXRoaXMuX3RocmVhZHMuZmlsdGVyKGU9PntpZihlLnRocmVhZEluZGV4PT10KXJldHVybiBlfSk7cmV0dXJuIGUubGVuZ3RoPjA/ZVswXTpudWxsfWdldCBjYWxsU3RhY2soKXtyZXR1cm4gdGhpcy5jdXJyZW50VGhyZWFkLmNhbGxzdGFja31nZXQgY2FsbFN0YWNrVHJhY2UoKXtsZXQgdD1uZXcgbTtmb3IobGV0IGU9MDtlPHRoaXMuX3RocmVhZHMubGVuZ3RoO2UrKyl7bGV0IG49dGhpcy5fdGhyZWFkc1tlXSxpPWU9PXRoaXMuX3RocmVhZHMubGVuZ3RoLTE7dC5BcHBlbmRGb3JtYXQoXCI9PT0gVEhSRUFEIHswfS97MX0gezJ9PT09XFxuXCIsZSsxLHRoaXMuX3RocmVhZHMubGVuZ3RoLGk/XCIoY3VycmVudCkgXCI6XCJcIik7Zm9yKGxldCBlPTA7ZTxuLmNhbGxzdGFjay5sZW5ndGg7ZSsrKXtuLmNhbGxzdGFja1tlXS50eXBlPT1yLkZ1bmN0aW9uP3QuQXBwZW5kKFwiICBbRlVOQ1RJT05dIFwiKTp0LkFwcGVuZChcIiAgW1RVTk5FTF0gXCIpO2xldCBpPW4uY2FsbHN0YWNrW2VdLmN1cnJlbnRQb2ludGVyO2lmKCFpLmlzTnVsbCl7aWYodC5BcHBlbmQoXCI8U09NRVdIRVJFIElOIFwiKSxudWxsPT09aS5jb250YWluZXIpcmV0dXJuIGQoXCJwb2ludGVyLmNvbnRhaW5lclwiKTt0LkFwcGVuZChpLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkpLHQuQXBwZW5kTGluZShcIj5cIil9fX1yZXR1cm4gdC50b1N0cmluZygpfX0hZnVuY3Rpb24odCl7Y2xhc3Mgbntjb25zdHJ1Y3Rvcih0LGUsbj0hMSl7dGhpcy5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkPTAsdGhpcy5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW09MCx0aGlzLmN1cnJlbnRQb2ludGVyPWUuY29weSgpLHRoaXMuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj1uLHRoaXMudGVtcG9yYXJ5VmFyaWFibGVzPW5ldyBNYXAsdGhpcy50eXBlPXR9Q29weSgpe2xldCB0PW5ldyBuKHRoaXMudHlwZSx0aGlzLmN1cnJlbnRQb2ludGVyLHRoaXMuaW5FeHByZXNzaW9uRXZhbHVhdGlvbik7cmV0dXJuIHQudGVtcG9yYXJ5VmFyaWFibGVzPW5ldyBNYXAodGhpcy50ZW1wb3JhcnlWYXJpYWJsZXMpLHQuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZD10aGlzLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQsdC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW09dGhpcy5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0sdH19dC5FbGVtZW50PW47Y2xhc3MgaXtjb25zdHJ1Y3Rvcigpe2lmKHRoaXMudGhyZWFkSW5kZXg9MCx0aGlzLnByZXZpb3VzUG9pbnRlcj1JLk51bGwsdGhpcy5jYWxsc3RhY2s9W10sYXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMV0pe2xldCB0PWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLnRocmVhZEluZGV4PXBhcnNlSW50KHQudGhyZWFkSW5kZXgpO2xldCByPXQuY2FsbHN0YWNrO2ZvcihsZXQgdCBvZiByKXtsZXQgcixhPXQscz1wYXJzZUludChhLnR5cGUpLGw9SS5OdWxsLG89YS5jUGF0aDtpZih2b2lkIDAhPT1vKXtyPW8udG9TdHJpbmcoKTtsZXQgdD1pLkNvbnRlbnRBdFBhdGgobmV3IGUocikpO2lmKGwuY29udGFpbmVyPXQuY29udGFpbmVyLGwuaW5kZXg9cGFyc2VJbnQoYS5pZHgpLG51bGw9PXQub2JqKXRocm93IG5ldyBFcnJvcihcIldoZW4gbG9hZGluZyBzdGF0ZSwgaW50ZXJuYWwgc3RvcnkgbG9jYXRpb24gY291bGRuJ3QgYmUgZm91bmQ6IFwiK3IrXCIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIik7aWYodC5hcHByb3hpbWF0ZSl7aWYobnVsbD09PWwuY29udGFpbmVyKXJldHVybiBkKFwicG9pbnRlci5jb250YWluZXJcIik7aS5XYXJuaW5nKFwiV2hlbiBsb2FkaW5nIHN0YXRlLCBleGFjdCBpbnRlcm5hbCBzdG9yeSBsb2NhdGlvbiBjb3VsZG4ndCBiZSBmb3VuZDogJ1wiK3IrXCInLCBzbyBpdCB3YXMgYXBwcm94aW1hdGVkIHRvICdcIitsLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkrXCInIHRvIHJlY292ZXIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIil9fWxldCB1PSEhYS5leHAsaD1uZXcgbihzLGwsdSksYz1hLnRlbXA7dm9pZCAwIT09Yz9oLnRlbXBvcmFyeVZhcmlhYmxlcz1NLkpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2JqcyhjKTpoLnRlbXBvcmFyeVZhcmlhYmxlcy5jbGVhcigpLHRoaXMuY2FsbHN0YWNrLnB1c2goaCl9bGV0IGE9dC5wcmV2aW91c0NvbnRlbnRPYmplY3Q7aWYodm9pZCAwIT09YSl7bGV0IHQ9bmV3IGUoYS50b1N0cmluZygpKTt0aGlzLnByZXZpb3VzUG9pbnRlcj1pLlBvaW50ZXJBdFBhdGgodCl9fX1Db3B5KCl7bGV0IHQ9bmV3IGk7dC50aHJlYWRJbmRleD10aGlzLnRocmVhZEluZGV4O2ZvcihsZXQgZSBvZiB0aGlzLmNhbGxzdGFjayl0LmNhbGxzdGFjay5wdXNoKGUuQ29weSgpKTtyZXR1cm4gdC5wcmV2aW91c1BvaW50ZXI9dGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpLHR9V3JpdGVKc29uKHQpe3QuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwiY2FsbHN0YWNrXCIpLHQuV3JpdGVBcnJheVN0YXJ0KCk7Zm9yKGxldCBlIG9mIHRoaXMuY2FsbHN0YWNrKXtpZih0LldyaXRlT2JqZWN0U3RhcnQoKSwhZS5jdXJyZW50UG9pbnRlci5pc051bGwpe2lmKG51bGw9PT1lLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcilyZXR1cm4gZChcImVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lclwiKTt0LldyaXRlUHJvcGVydHkoXCJjUGF0aFwiLGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyLnBhdGguY29tcG9uZW50c1N0cmluZyksdC5Xcml0ZUludFByb3BlcnR5KFwiaWR4XCIsZS5jdXJyZW50UG9pbnRlci5pbmRleCl9dC5Xcml0ZVByb3BlcnR5KFwiZXhwXCIsZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKSx0LldyaXRlSW50UHJvcGVydHkoXCJ0eXBlXCIsZS50eXBlKSxlLnRlbXBvcmFyeVZhcmlhYmxlcy5zaXplPjAmJih0LldyaXRlUHJvcGVydHlTdGFydChcInRlbXBcIiksTS5Xcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh0LGUudGVtcG9yYXJ5VmFyaWFibGVzKSx0LldyaXRlUHJvcGVydHlFbmQoKSksdC5Xcml0ZU9iamVjdEVuZCgpfWlmKHQuV3JpdGVBcnJheUVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpLHQuV3JpdGVJbnRQcm9wZXJ0eShcInRocmVhZEluZGV4XCIsdGhpcy50aHJlYWRJbmRleCksIXRoaXMucHJldmlvdXNQb2ludGVyLmlzTnVsbCl7bGV0IGU9dGhpcy5wcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpO2lmKG51bGw9PT1lKXJldHVybiBkKFwidGhpcy5wcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpXCIpO3QuV3JpdGVQcm9wZXJ0eShcInByZXZpb3VzQ29udGVudE9iamVjdFwiLGUucGF0aC50b1N0cmluZygpKX10LldyaXRlT2JqZWN0RW5kKCl9fXQuVGhyZWFkPWl9KHF8fChxPXt9KSk7Y2xhc3MgSntjb25zdHJ1Y3Rvcih0LGUpe3RoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3M9W10sdGhpcy5wYXRjaD1udWxsLHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzPSExLHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXM9bmV3IE1hcCx0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnM9bmV3IFNldCx0aGlzLl9nbG9iYWxWYXJpYWJsZXM9bmV3IE1hcCx0aGlzLl9jYWxsU3RhY2s9dCx0aGlzLl9saXN0RGVmc09yaWdpbj1lO3RyeXtyZXR1cm4gbmV3IFByb3h5KHRoaXMse2dldDoodCxlKT0+ZSBpbiB0P3RbZV06dC4kKGUpLHNldDoodCxlLG4pPT4oZSBpbiB0P3RbZV09bjp0LiQoZSxuKSwhMCl9KX1jYXRjaCh0KXt9fXZhcmlhYmxlQ2hhbmdlZEV2ZW50KHQsZSl7Zm9yKGxldCBuIG9mIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3Mpbih0LGUpfWdldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcygpe3JldHVybiB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlc31zZXQgYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXModCl7aWYodGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM9dCx0KXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icz1uZXcgU2V0O2Vsc2UgaWYobnVsbCE9dGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKXtmb3IobGV0IHQgb2YgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKXtsZXQgZT10aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHQpO2U/dGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCh0LGUpOmQoXCJjdXJyZW50VmFsdWVcIil9dGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzPW51bGx9fWdldCBjYWxsU3RhY2soKXtyZXR1cm4gdGhpcy5fY2FsbFN0YWNrfXNldCBjYWxsU3RhY2sodCl7dGhpcy5fY2FsbFN0YWNrPXR9JCh0LGUpe2lmKHZvaWQgMD09PWUpe2xldCBlPW51bGw7cmV0dXJuIG51bGwhPT10aGlzLnBhdGNoJiYoZT10aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh0LG51bGwpLGUuZXhpc3RzKT9lLnJlc3VsdC52YWx1ZU9iamVjdDooZT10aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHQpLHZvaWQgMD09PWUmJihlPXRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KHQpKSx2b2lkIDAhPT1lP2UudmFsdWVPYmplY3Q6bnVsbCl9e2lmKHZvaWQgMD09PXRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KHQpKXRocm93IG5ldyBTKFwiQ2Fubm90IGFzc2lnbiB0byBhIHZhcmlhYmxlIChcIit0K1wiKSB0aGF0IGhhc24ndCBiZWVuIGRlY2xhcmVkIGluIHRoZSBzdG9yeVwiKTtsZXQgbj12LkNyZWF0ZShlKTtpZihudWxsPT1uKXRocm93IG5ldyBTKG51bGw9PWU/XCJDYW5ub3QgcGFzcyBudWxsIHRvIFZhcmlhYmxlU3RhdGVcIjpcIkludmFsaWQgdmFsdWUgcGFzc2VkIHRvIFZhcmlhYmxlU3RhdGU6IFwiK2UudG9TdHJpbmcoKSk7dGhpcy5TZXRHbG9iYWwodCxuKX19QXBwbHlQYXRjaCgpe2lmKG51bGw9PT10aGlzLnBhdGNoKXJldHVybiBkKFwidGhpcy5wYXRjaFwiKTtmb3IobGV0W3QsZV1vZiB0aGlzLnBhdGNoLmdsb2JhbHMpdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh0LGUpO2lmKG51bGwhPT10aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpZm9yKGxldCB0IG9mIHRoaXMucGF0Y2guY2hhbmdlZFZhcmlhYmxlcyl0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMuYWRkKHQpO3RoaXMucGF0Y2g9bnVsbH1TZXRKc29uVG9rZW4odCl7dGhpcy5fZ2xvYmFsVmFyaWFibGVzLmNsZWFyKCk7Zm9yKGxldFtlLG5db2YgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyl7bGV0IGk9dFtlXTtpZih2b2lkIDAhPT1pKXtsZXQgdD1NLkpUb2tlblRvUnVudGltZU9iamVjdChpKTtpZihudWxsPT09dClyZXR1cm4gZChcInRva2VuSW5rT2JqZWN0XCIpO3RoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQoZSx0KX1lbHNlIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQoZSxuKX19V3JpdGVKc29uKHQpe3QuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXRbZSxuXW9mIHRoaXMuX2dsb2JhbFZhcmlhYmxlcyl7bGV0IGk9ZSxyPW47aWYoSi5kb250U2F2ZURlZmF1bHRWYWx1ZXMmJnRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKGkpKXtsZXQgdD10aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldChpKTtpZih0aGlzLlJ1bnRpbWVPYmplY3RzRXF1YWwocix0KSljb250aW51ZX10LldyaXRlUHJvcGVydHlTdGFydChpKSxNLldyaXRlUnVudGltZU9iamVjdCh0LHIpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfXQuV3JpdGVPYmplY3RFbmQoKX1SdW50aW1lT2JqZWN0c0VxdWFsKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJvYmoxXCIpO2lmKG51bGw9PT1lKXJldHVybiBkKFwib2JqMlwiKTtpZih0LmNvbnN0cnVjdG9yIT09ZS5jb25zdHJ1Y3RvcilyZXR1cm4hMTtsZXQgbj1hKHQsYik7aWYobnVsbCE9PW4pcmV0dXJuIG4udmFsdWU9PT1zKGUsYikudmFsdWU7bGV0IGk9YSh0LF8pO2lmKG51bGwhPT1pKXJldHVybiBpLnZhbHVlPT09cyhlLF8pLnZhbHVlO2xldCByPWEodCx2KSxsPWEoZSx2KTtpZihudWxsIT09ciYmbnVsbCE9PWwpcmV0dXJuIHUoci52YWx1ZU9iamVjdCkmJnUobC52YWx1ZU9iamVjdCk/ci52YWx1ZU9iamVjdC5FcXVhbHMobC52YWx1ZU9iamVjdCk6ci52YWx1ZU9iamVjdD09PWwudmFsdWVPYmplY3Q7dGhyb3cgbmV3IEVycm9yKFwiRmFzdFJvdWdoRGVmaW5pdGVseUVxdWFsczogVW5zdXBwb3J0ZWQgcnVudGltZSBvYmplY3QgdHlwZTogXCIrdC5jb25zdHJ1Y3Rvci5uYW1lKX1HZXRWYXJpYWJsZVdpdGhOYW1lKHQsZT0tMSl7bGV0IG49dGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKHQsZSksaT1hKG4sdyk7cmV0dXJuIG51bGwhPT1pJiYobj10aGlzLlZhbHVlQXRWYXJpYWJsZVBvaW50ZXIoaSkpLG59VHJ5R2V0RGVmYXVsdFZhcmlhYmxlVmFsdWUodCl7bGV0IGU9eSh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLHQsbnVsbCk7cmV0dXJuIGUuZXhpc3RzP2UucmVzdWx0Om51bGx9R2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh0KXtyZXR1cm4gdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmhhcyh0KXx8bnVsbCE9PXRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMmJnRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKHQpfUdldFJhd1ZhcmlhYmxlV2l0aE5hbWUodCxlKXtsZXQgbj1udWxsO2lmKDA9PWV8fC0xPT1lKXtsZXQgZT1udWxsO2lmKG51bGwhPT10aGlzLnBhdGNoJiYoZT10aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh0LG51bGwpLGUuZXhpc3RzKSlyZXR1cm4gZS5yZXN1bHQ7aWYoZT15KHRoaXMuX2dsb2JhbFZhcmlhYmxlcyx0LG51bGwpLGUuZXhpc3RzKXJldHVybiBlLnJlc3VsdDtpZihudWxsIT09dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyYmKGU9eSh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLHQsbnVsbCksZS5leGlzdHMpKXJldHVybiBlLnJlc3VsdDtpZihudWxsPT09dGhpcy5fbGlzdERlZnNPcmlnaW4pcmV0dXJuIGQoXCJWYXJpYWJsZXNTdGF0ZS5fbGlzdERlZnNPcmlnaW5cIik7bGV0IG49dGhpcy5fbGlzdERlZnNPcmlnaW4uRmluZFNpbmdsZUl0ZW1MaXN0V2l0aE5hbWUodCk7aWYobilyZXR1cm4gbn1yZXR1cm4gbj10aGlzLl9jYWxsU3RhY2suR2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZSh0LGUpLG59VmFsdWVBdFZhcmlhYmxlUG9pbnRlcih0KXtyZXR1cm4gdGhpcy5HZXRWYXJpYWJsZVdpdGhOYW1lKHQudmFyaWFibGVOYW1lLHQuY29udGV4dEluZGV4KX1Bc3NpZ24odCxlKXtsZXQgbj10LnZhcmlhYmxlTmFtZTtpZihudWxsPT09bilyZXR1cm4gZChcIm5hbWVcIik7bGV0IGk9LTEscj0hMTtpZihyPXQuaXNOZXdEZWNsYXJhdGlvbj90LmlzR2xvYmFsOnRoaXMuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZShuKSx0LmlzTmV3RGVjbGFyYXRpb24pe2xldCB0PWEoZSx3KTtpZihudWxsIT09dCl7ZT10aGlzLlJlc29sdmVWYXJpYWJsZVBvaW50ZXIodCl9fWVsc2V7bGV0IHQ9bnVsbDtkb3t0PWEodGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG4saSksdyksbnVsbCE9dCYmKG49dC52YXJpYWJsZU5hbWUsaT10LmNvbnRleHRJbmRleCxyPTA9PWkpfXdoaWxlKG51bGwhPXQpfXI/dGhpcy5TZXRHbG9iYWwobixlKTp0aGlzLl9jYWxsU3RhY2suU2V0VGVtcG9yYXJ5VmFyaWFibGUobixlLHQuaXNOZXdEZWNsYXJhdGlvbixpKX1TbmFwc2hvdERlZmF1bHRHbG9iYWxzKCl7dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcz1uZXcgTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcyl9UmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KHQsZSl7bGV0IG49cyh0LE8pLGk9cyhlLE8pO24udmFsdWUmJmkudmFsdWUmJjA9PWkudmFsdWUuQ291bnQmJmkudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG4udmFsdWUub3JpZ2luTmFtZXMpfVNldEdsb2JhbCh0LGUpe2xldCBuPW51bGw7aWYobnVsbD09PXRoaXMucGF0Y2gmJihuPXkodGhpcy5fZ2xvYmFsVmFyaWFibGVzLHQsbnVsbCkpLG51bGwhPT10aGlzLnBhdGNoJiYobj10aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh0LG51bGwpLG4uZXhpc3RzfHwobj15KHRoaXMuX2dsb2JhbFZhcmlhYmxlcyx0LG51bGwpKSksTy5SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQobi5yZXN1bHQsZSksbnVsbD09PXQpcmV0dXJuIGQoXCJ2YXJpYWJsZU5hbWVcIik7aWYobnVsbCE9PXRoaXMucGF0Y2g/dGhpcy5wYXRjaC5TZXRHbG9iYWwodCxlKTp0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHQsZSksbnVsbCE9PXRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQmJm51bGwhPT1uJiZlIT09bi5yZXN1bHQpaWYodGhpcy5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyl7aWYobnVsbD09PXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icylyZXR1cm4gZChcInRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9ic1wiKTtudWxsIT09dGhpcy5wYXRjaD90aGlzLnBhdGNoLkFkZENoYW5nZWRWYXJpYWJsZSh0KTpudWxsIT09dGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzJiZ0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMuYWRkKHQpfWVsc2UgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCh0LGUpfVJlc29sdmVWYXJpYWJsZVBvaW50ZXIodCl7bGV0IGU9dC5jb250ZXh0SW5kZXg7LTE9PWUmJihlPXRoaXMuR2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHQudmFyaWFibGVOYW1lKSk7bGV0IG49YSh0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUodC52YXJpYWJsZU5hbWUsZSksdyk7cmV0dXJuIG51bGwhPW4/bjpuZXcgdyh0LnZhcmlhYmxlTmFtZSxlKX1HZXRDb250ZXh0SW5kZXhPZlZhcmlhYmxlTmFtZWQodCl7cmV0dXJuIHRoaXMuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh0KT8wOnRoaXMuX2NhbGxTdGFjay5jdXJyZW50RWxlbWVudEluZGV4fU9ic2VydmVWYXJpYWJsZUNoYW5nZSh0KXt0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzLnB1c2godCl9fUouZG9udFNhdmVEZWZhdWx0VmFsdWVzPSEwO2NsYXNzIEt7Y29uc3RydWN0b3IodCl7dGhpcy5zZWVkPXQlMjE0NzQ4MzY0Nyx0aGlzLnNlZWQ8PTAmJih0aGlzLnNlZWQrPTIxNDc0ODM2NDYpfW5leHQoKXtyZXR1cm4gdGhpcy5zZWVkPTE2ODA3KnRoaXMuc2VlZCUyMTQ3NDgzNjQ3fW5leHRGbG9hdCgpe3JldHVybih0aGlzLm5leHQoKS0xKS8yMTQ3NDgzNjQ2fX1jbGFzcyBVe2NvbnN0cnVjdG9yKCl7aWYodGhpcy5fY2hhbmdlZFZhcmlhYmxlcz1uZXcgU2V0LHRoaXMuX3Zpc2l0Q291bnRzPW5ldyBNYXAsdGhpcy5fdHVybkluZGljZXM9bmV3IE1hcCwxPT09YXJndW1lbnRzLmxlbmd0aCYmbnVsbCE9PWFyZ3VtZW50c1swXSl7bGV0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX2dsb2JhbHM9bmV3IE1hcCh0Ll9nbG9iYWxzKSx0aGlzLl9jaGFuZ2VkVmFyaWFibGVzPW5ldyBTZXQodC5fY2hhbmdlZFZhcmlhYmxlcyksdGhpcy5fdmlzaXRDb3VudHM9bmV3IE1hcCh0Ll92aXNpdENvdW50cyksdGhpcy5fdHVybkluZGljZXM9bmV3IE1hcCh0Ll90dXJuSW5kaWNlcyl9ZWxzZSB0aGlzLl9nbG9iYWxzPW5ldyBNYXAsdGhpcy5fY2hhbmdlZFZhcmlhYmxlcz1uZXcgU2V0LHRoaXMuX3Zpc2l0Q291bnRzPW5ldyBNYXAsdGhpcy5fdHVybkluZGljZXM9bmV3IE1hcH1nZXQgZ2xvYmFscygpe3JldHVybiB0aGlzLl9nbG9iYWxzfWdldCBjaGFuZ2VkVmFyaWFibGVzKCl7cmV0dXJuIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXN9Z2V0IHZpc2l0Q291bnRzKCl7cmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzfWdldCB0dXJuSW5kaWNlcygpe3JldHVybiB0aGlzLl90dXJuSW5kaWNlc31UcnlHZXRHbG9iYWwodCxlKXtyZXR1cm4gbnVsbCE9PXQmJnRoaXMuX2dsb2JhbHMuaGFzKHQpP3tyZXN1bHQ6dGhpcy5fZ2xvYmFscy5nZXQodCksZXhpc3RzOiEwfTp7cmVzdWx0OmUsZXhpc3RzOiExfX1TZXRHbG9iYWwodCxlKXt0aGlzLl9nbG9iYWxzLnNldCh0LGUpfUFkZENoYW5nZWRWYXJpYWJsZSh0KXtyZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlcy5hZGQodCl9VHJ5R2V0VmlzaXRDb3VudCh0LGUpe3JldHVybiB0aGlzLl92aXNpdENvdW50cy5oYXModCk/e3Jlc3VsdDp0aGlzLl92aXNpdENvdW50cy5nZXQodCksZXhpc3RzOiEwfTp7cmVzdWx0OmUsZXhpc3RzOiExfX1TZXRWaXNpdENvdW50KHQsZSl7dGhpcy5fdmlzaXRDb3VudHMuc2V0KHQsZSl9U2V0VHVybkluZGV4KHQsZSl7dGhpcy5fdHVybkluZGljZXMuc2V0KHQsZSl9VHJ5R2V0VHVybkluZGV4KHQsZSl7cmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzLmhhcyh0KT97cmVzdWx0OnRoaXMuX3R1cm5JbmRpY2VzLmdldCh0KSxleGlzdHM6ITB9OntyZXN1bHQ6ZSxleGlzdHM6ITF9fX1jbGFzcyB6e3N0YXRpYyBUZXh0VG9EaWN0aW9uYXJ5KHQpe3JldHVybiBuZXcgei5SZWFkZXIodCkuVG9EaWN0aW9uYXJ5KCl9c3RhdGljIFRleHRUb0FycmF5KHQpe3JldHVybiBuZXcgei5SZWFkZXIodCkuVG9BcnJheSgpfX0hZnVuY3Rpb24odCl7dC5SZWFkZXI9Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5fcm9vdE9iamVjdD1KU09OLnBhcnNlKHQpfVRvRGljdGlvbmFyeSgpe3JldHVybiB0aGlzLl9yb290T2JqZWN0fVRvQXJyYXkoKXtyZXR1cm4gdGhpcy5fcm9vdE9iamVjdH19O2NsYXNzIGV7Y29uc3RydWN0b3IoKXt0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lPW51bGwsdGhpcy5fY3VycmVudFN0cmluZz1udWxsLHRoaXMuX3N0YXRlU3RhY2s9W10sdGhpcy5fY29sbGVjdGlvblN0YWNrPVtdLHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrPVtdLHRoaXMuX2pzb25PYmplY3Q9bnVsbH1Xcml0ZU9iamVjdCh0KXt0aGlzLldyaXRlT2JqZWN0U3RhcnQoKSx0KHRoaXMpLHRoaXMuV3JpdGVPYmplY3RFbmQoKX1Xcml0ZU9iamVjdFN0YXJ0KCl7dGhpcy5TdGFydE5ld09iamVjdCghMCk7bGV0IGU9e307aWYodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5KXt0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50Q29sbGVjdGlvbiksdGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudFByb3BlcnR5TmFtZSk7bGV0IHQ9dGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7dGhpcy5jdXJyZW50Q29sbGVjdGlvblt0XT1lLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpfWVsc2UgdGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5Pyh0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50Q29sbGVjdGlvbiksdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKGUpLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpKToodGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk5vbmUpLHRoaXMuX2pzb25PYmplY3Q9ZSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKSk7dGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuT2JqZWN0KSl9V3JpdGVPYmplY3RFbmQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuT2JqZWN0KSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucG9wKCksdGhpcy5fc3RhdGVTdGFjay5wb3AoKX1Xcml0ZVByb3BlcnR5KHQsZSl7aWYodGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQodCksYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBGdW5jdGlvbil7KDAsYXJndW1lbnRzWzFdKSh0aGlzKX1lbHNle2xldCB0PWFyZ3VtZW50c1sxXTt0aGlzLldyaXRlKHQpfXRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpfVdyaXRlSW50UHJvcGVydHkodCxlKXt0aGlzLldyaXRlUHJvcGVydHlTdGFydCh0KSx0aGlzLldyaXRlSW50KGUpLHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpfVdyaXRlRmxvYXRQcm9wZXJ0eSh0LGUpe3RoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KHQpLHRoaXMuV3JpdGVGbG9hdChlKSx0aGlzLldyaXRlUHJvcGVydHlFbmQoKX1Xcml0ZVByb3BlcnR5U3RhcnQoZSl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk9iamVjdCksdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaChlKSx0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKSx0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkpfVdyaXRlUHJvcGVydHlFbmQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpLHRoaXMuQXNzZXJ0KDE9PT10aGlzLmNoaWxkQ291bnQpLHRoaXMuX3N0YXRlU3RhY2sucG9wKCl9V3JpdGVQcm9wZXJ0eU5hbWVTdGFydCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5PYmplY3QpLHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpLHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWU9XCJcIix0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkpLHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSkpfVdyaXRlUHJvcGVydHlOYW1lRW5kKCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSksdGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUpLHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnB1c2godGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSksdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZT1udWxsLHRoaXMuX3N0YXRlU3RhY2sucG9wKCl9V3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihlKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKSx0aGlzLkFzc2VydChudWxsIT09dGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSksdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSs9ZX1Xcml0ZUFycmF5U3RhcnQoKXt0aGlzLlN0YXJ0TmV3T2JqZWN0KCEwKTtsZXQgZT1bXTtpZih0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpe3RoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSx0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50UHJvcGVydHlOYW1lKTtsZXQgdD10aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTt0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3RdPWUsdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSl9ZWxzZSB0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXk/KHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSx0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2goZSksdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSkpOih0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuTm9uZSksdGhpcy5fanNvbk9iamVjdD1lLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpKTt0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5BcnJheSkpfVdyaXRlQXJyYXlFbmQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXkpLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wb3AoKSx0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpfVdyaXRlKHQsZT0hMCl7bnVsbCE9PXQ/KHRoaXMuU3RhcnROZXdPYmplY3QoITEpLHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh0KSk6Y29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpfVdyaXRlSW50KHQpe251bGwhPT10JiYodGhpcy5TdGFydE5ld09iamVjdCghMSksdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KE1hdGguZmxvb3IodCkpKX1Xcml0ZUZsb2F0KHQpe251bGwhPT10JiYodGhpcy5TdGFydE5ld09iamVjdCghMSksdD09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZP3RoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgzNGUzNyk6dD09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZP3RoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgtMzRlMzcpOmlzTmFOKHQpP3RoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgwKTp0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodCkpfVdyaXRlTnVsbCgpe3RoaXMuU3RhcnROZXdPYmplY3QoITEpLHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdChudWxsKX1Xcml0ZVN0cmluZ1N0YXJ0KCl7dGhpcy5TdGFydE5ld09iamVjdCghMSksdGhpcy5fY3VycmVudFN0cmluZz1cIlwiLHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLlN0cmluZykpfVdyaXRlU3RyaW5nRW5kKCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09dC5Xcml0ZXIuU3RhdGUuU3RyaW5nKSx0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpLHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh0aGlzLl9jdXJyZW50U3RyaW5nKSx0aGlzLl9jdXJyZW50U3RyaW5nPW51bGx9V3JpdGVTdHJpbmdJbm5lcihlLG49ITApe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5TdHJpbmcpLG51bGwhPT1lP3RoaXMuX2N1cnJlbnRTdHJpbmcrPWU6Y29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpfVRvU3RyaW5nKCl7cmV0dXJuIG51bGw9PT10aGlzLl9qc29uT2JqZWN0P1wiXCI6SlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbk9iamVjdCl9U3RhcnROZXdPYmplY3QoZSl7ZT90aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuTm9uZXx8dGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5fHx0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXkpOnRoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eXx8dGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5KSx0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkmJnRoaXMuQXNzZXJ0KDA9PT10aGlzLmNoaWxkQ291bnQpLHRoaXMuc3RhdGUhPT10LldyaXRlci5TdGF0ZS5BcnJheSYmdGhpcy5zdGF0ZSE9PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5fHx0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKX1nZXQgc3RhdGUoKXtyZXR1cm4gdGhpcy5fc3RhdGVTdGFjay5sZW5ndGg+MD90aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoLTFdLnR5cGU6dC5Xcml0ZXIuU3RhdGUuTm9uZX1nZXQgY2hpbGRDb3VudCgpe3JldHVybiB0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aD4wP3RoaXMuX3N0YXRlU3RhY2tbdGhpcy5fc3RhdGVTdGFjay5sZW5ndGgtMV0uY2hpbGRDb3VudDowfWdldCBjdXJyZW50Q29sbGVjdGlvbigpe3JldHVybiB0aGlzLl9jb2xsZWN0aW9uU3RhY2subGVuZ3RoPjA/dGhpcy5fY29sbGVjdGlvblN0YWNrW3RoaXMuX2NvbGxlY3Rpb25TdGFjay5sZW5ndGgtMV06bnVsbH1nZXQgY3VycmVudFByb3BlcnR5TmFtZSgpe3JldHVybiB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5sZW5ndGg+MD90aGlzLl9wcm9wZXJ0eU5hbWVTdGFja1t0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5sZW5ndGgtMV06bnVsbH1JbmNyZW1lbnRDaGlsZENvdW50KCl7dGhpcy5Bc3NlcnQodGhpcy5fc3RhdGVTdGFjay5sZW5ndGg+MCk7bGV0IHQ9dGhpcy5fc3RhdGVTdGFjay5wb3AoKTt0LmNoaWxkQ291bnQrKyx0aGlzLl9zdGF0ZVN0YWNrLnB1c2godCl9QXNzZXJ0KHQpe2lmKCF0KXRocm93IEVycm9yKFwiQXNzZXJ0IGZhaWxlZCB3aGlsZSB3cml0aW5nIEpTT05cIil9X2FkZFRvQ3VycmVudE9iamVjdChlKXt0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50Q29sbGVjdGlvbiksdGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5Pyh0aGlzLkFzc2VydChBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKSx0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2goZSkpOnRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSYmKHRoaXMuQXNzZXJ0KCFBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKSx0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50UHJvcGVydHlOYW1lKSx0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3RoaXMuY3VycmVudFByb3BlcnR5TmFtZV09ZSx0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKSl9fXQuV3JpdGVyPWUsZnVuY3Rpb24oZSl7bGV0IG47IWZ1bmN0aW9uKHQpe3RbdC5Ob25lPTBdPVwiTm9uZVwiLHRbdC5PYmplY3Q9MV09XCJPYmplY3RcIix0W3QuQXJyYXk9Ml09XCJBcnJheVwiLHRbdC5Qcm9wZXJ0eT0zXT1cIlByb3BlcnR5XCIsdFt0LlByb3BlcnR5TmFtZT00XT1cIlByb3BlcnR5TmFtZVwiLHRbdC5TdHJpbmc9NV09XCJTdHJpbmdcIn0obj1lLlN0YXRlfHwoZS5TdGF0ZT17fSkpO2UuU3RhdGVFbGVtZW50PWNsYXNze2NvbnN0cnVjdG9yKGUpe3RoaXMudHlwZT10LldyaXRlci5TdGF0ZS5Ob25lLHRoaXMuY2hpbGRDb3VudD0wLHRoaXMudHlwZT1lfX19KGU9dC5Xcml0ZXJ8fCh0LldyaXRlcj17fSkpfSh6fHwoej17fSkpO2NsYXNzIEh7Y29uc3RydWN0b3IodCl7dGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbj04LHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbj04LHRoaXMuX2N1cnJlbnRFcnJvcnM9bnVsbCx0aGlzLl9jdXJyZW50V2FybmluZ3M9bnVsbCx0aGlzLmRpdmVydGVkUG9pbnRlcj1JLk51bGwsdGhpcy5fY3VycmVudFR1cm5JbmRleD0wLHRoaXMuc3RvcnlTZWVkPTAsdGhpcy5wcmV2aW91c1JhbmRvbT0wLHRoaXMuZGlkU2FmZUV4aXQ9ITEsdGhpcy5fY3VycmVudFRleHQ9bnVsbCx0aGlzLl9jdXJyZW50VGFncz1udWxsLHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eT0hMCx0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHk9ITAsdGhpcy5fcGF0Y2g9bnVsbCx0aGlzLnN0b3J5PXQsdGhpcy5fb3V0cHV0U3RyZWFtPVtdLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKSx0aGlzLl9ldmFsdWF0aW9uU3RhY2s9W10sdGhpcy5jYWxsU3RhY2s9bmV3IHEodCksdGhpcy5fdmFyaWFibGVzU3RhdGU9bmV3IEoodGhpcy5jYWxsU3RhY2ssdC5saXN0RGVmaW5pdGlvbnMpLHRoaXMuX3Zpc2l0Q291bnRzPW5ldyBNYXAsdGhpcy5fdHVybkluZGljZXM9bmV3IE1hcCx0aGlzLmN1cnJlbnRUdXJuSW5kZXg9LTE7bGV0IGU9KG5ldyBEYXRlKS5nZXRUaW1lKCk7dGhpcy5zdG9yeVNlZWQ9bmV3IEsoZSkubmV4dCgpJTEwMCx0aGlzLnByZXZpb3VzUmFuZG9tPTAsdGhpcy5fY3VycmVudENob2ljZXM9W10sdGhpcy5Hb1RvU3RhcnQoKX1Ub0pzb24odD0hMSl7bGV0IGU9bmV3IHouV3JpdGVyO3JldHVybiB0aGlzLldyaXRlSnNvbihlKSxlLlRvU3RyaW5nKCl9dG9Kc29uKHQ9ITEpe3JldHVybiB0aGlzLlRvSnNvbih0KX1Mb2FkSnNvbih0KXtsZXQgZT16LlRleHRUb0RpY3Rpb25hcnkodCk7dGhpcy5Mb2FkSnNvbk9iaihlKX1WaXNpdENvdW50QXRQYXRoU3RyaW5nKHQpe2xldCBuO2lmKG51bGwhPT10aGlzLl9wYXRjaCl7bGV0IGk9dGhpcy5zdG9yeS5Db250ZW50QXRQYXRoKG5ldyBlKHQpKS5jb250YWluZXI7aWYobnVsbD09PWkpdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBhdCBwYXRoIG5vdCBmb3VuZDogXCIrdCk7aWYobj10aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KGksMCksbi5leGlzdHMpcmV0dXJuIG4ucmVzdWx0fXJldHVybiBuPXkodGhpcy5fdmlzaXRDb3VudHMsdCxudWxsKSxuLmV4aXN0cz9uLnJlc3VsdDowfVZpc2l0Q291bnRGb3JDb250YWluZXIodCl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJjb250YWluZXJcIik7aWYoIXQudmlzaXRzU2hvdWxkQmVDb3VudGVkKXJldHVybiB0aGlzLnN0b3J5LkVycm9yKFwiUmVhZCBjb3VudCBmb3IgdGFyZ2V0IChcIit0Lm5hbWUrXCIgLSBvbiBcIit0LmRlYnVnTWV0YWRhdGErXCIpIHVua25vd24uIFRoZSBzdG9yeSBtYXkgbmVlZCB0byBiZSBjb21waWxlZCB3aXRoIGNvdW50QWxsVmlzaXRzIGZsYWcgKC1jKS5cIiksMDtpZihudWxsIT09dGhpcy5fcGF0Y2gpe2xldCBlPXRoaXMuX3BhdGNoLlRyeUdldFZpc2l0Q291bnQodCwwKTtpZihlLmV4aXN0cylyZXR1cm4gZS5yZXN1bHR9bGV0IGU9dC5wYXRoLnRvU3RyaW5nKCksbj15KHRoaXMuX3Zpc2l0Q291bnRzLGUsbnVsbCk7cmV0dXJuIG4uZXhpc3RzP24ucmVzdWx0OjB9SW5jcmVtZW50VmlzaXRDb3VudEZvckNvbnRhaW5lcih0KXtpZihudWxsIT09dGhpcy5fcGF0Y2gpe2xldCBlPXRoaXMuVmlzaXRDb3VudEZvckNvbnRhaW5lcih0KTtyZXR1cm4gZSsrLHZvaWQgdGhpcy5fcGF0Y2guU2V0VmlzaXRDb3VudCh0LGUpfWxldCBlPXQucGF0aC50b1N0cmluZygpLG49eSh0aGlzLl92aXNpdENvdW50cyxlLG51bGwpO24uZXhpc3RzP3RoaXMuX3Zpc2l0Q291bnRzLnNldChlLG4ucmVzdWx0KzEpOnRoaXMuX3Zpc2l0Q291bnRzLnNldChlLDEpfVJlY29yZFR1cm5JbmRleFZpc2l0VG9Db250YWluZXIodCl7aWYobnVsbCE9PXRoaXMuX3BhdGNoKXJldHVybiB2b2lkIHRoaXMuX3BhdGNoLlNldFR1cm5JbmRleCh0LHRoaXMuY3VycmVudFR1cm5JbmRleCk7bGV0IGU9dC5wYXRoLnRvU3RyaW5nKCk7dGhpcy5fdHVybkluZGljZXMuc2V0KGUsdGhpcy5jdXJyZW50VHVybkluZGV4KX1UdXJuc1NpbmNlRm9yQ29udGFpbmVyKHQpe2lmKHQudHVybkluZGV4U2hvdWxkQmVDb3VudGVkfHx0aGlzLnN0b3J5LkVycm9yKFwiVFVSTlNfU0lOQ0UoKSBmb3IgdGFyZ2V0IChcIit0Lm5hbWUrXCIgLSBvbiBcIit0LmRlYnVnTWV0YWRhdGErXCIpIHVua25vd24uIFRoZSBzdG9yeSBtYXkgbmVlZCB0byBiZSBjb21waWxlZCB3aXRoIGNvdW50QWxsVmlzaXRzIGZsYWcgKC1jKS5cIiksbnVsbCE9PXRoaXMuX3BhdGNoKXtsZXQgZT10aGlzLl9wYXRjaC5UcnlHZXRUdXJuSW5kZXgodCwwKTtpZihlLmV4aXN0cylyZXR1cm4gdGhpcy5jdXJyZW50VHVybkluZGV4LWUucmVzdWx0fWxldCBlPXQucGF0aC50b1N0cmluZygpLG49eSh0aGlzLl90dXJuSW5kaWNlcyxlLDApO3JldHVybiBuLmV4aXN0cz90aGlzLmN1cnJlbnRUdXJuSW5kZXgtbi5yZXN1bHQ6LTF9Z2V0IGNhbGxzdGFja0RlcHRoKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmRlcHRofWdldCBvdXRwdXRTdHJlYW0oKXtyZXR1cm4gdGhpcy5fb3V0cHV0U3RyZWFtfWdldCBjdXJyZW50Q2hvaWNlcygpe3JldHVybiB0aGlzLmNhbkNvbnRpbnVlP1tdOnRoaXMuX2N1cnJlbnRDaG9pY2VzfWdldCBnZW5lcmF0ZWRDaG9pY2VzKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRDaG9pY2VzfWdldCBjdXJyZW50RXJyb3JzKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRFcnJvcnN9Z2V0IGN1cnJlbnRXYXJuaW5ncygpe3JldHVybiB0aGlzLl9jdXJyZW50V2FybmluZ3N9Z2V0IHZhcmlhYmxlc1N0YXRlKCl7cmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1N0YXRlfXNldCB2YXJpYWJsZXNTdGF0ZSh0KXt0aGlzLl92YXJpYWJsZXNTdGF0ZT10fWdldCBldmFsdWF0aW9uU3RhY2soKXtyZXR1cm4gdGhpcy5fZXZhbHVhdGlvblN0YWNrfWdldCB2aXNpdENvdW50cygpe3JldHVybiB0aGlzLl92aXNpdENvdW50c31nZXQgdHVybkluZGljZXMoKXtyZXR1cm4gdGhpcy5fdHVybkluZGljZXN9Z2V0IGN1cnJlbnRUdXJuSW5kZXgoKXtyZXR1cm4gdGhpcy5fY3VycmVudFR1cm5JbmRleH1zZXQgY3VycmVudFR1cm5JbmRleCh0KXt0aGlzLl9jdXJyZW50VHVybkluZGV4PXR9Z2V0IGN1cnJlbnRQYXRoU3RyaW5nKCl7bGV0IHQ9dGhpcy5jdXJyZW50UG9pbnRlcjtyZXR1cm4gdC5pc051bGw/bnVsbDpudWxsPT09dC5wYXRoP2QoXCJwb2ludGVyLnBhdGhcIik6dC5wYXRoLnRvU3RyaW5nKCl9Z2V0IGN1cnJlbnRQb2ludGVyKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKX1zZXQgY3VycmVudFBvaW50ZXIodCl7dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXI9dC5jb3B5KCl9Z2V0IHByZXZpb3VzUG9pbnRlcigpe3JldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkLnByZXZpb3VzUG9pbnRlci5jb3B5KCl9c2V0IHByZXZpb3VzUG9pbnRlcih0KXt0aGlzLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkLnByZXZpb3VzUG9pbnRlcj10LmNvcHkoKX1nZXQgY2FuQ29udGludWUoKXtyZXR1cm4hdGhpcy5jdXJyZW50UG9pbnRlci5pc051bGwmJiF0aGlzLmhhc0Vycm9yfWdldCBoYXNFcnJvcigpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRFcnJvcnMmJnRoaXMuY3VycmVudEVycm9ycy5sZW5ndGg+MH1nZXQgaGFzV2FybmluZygpe3JldHVybiBudWxsIT10aGlzLmN1cnJlbnRXYXJuaW5ncyYmdGhpcy5jdXJyZW50V2FybmluZ3MubGVuZ3RoPjB9Z2V0IGN1cnJlbnRUZXh0KCl7aWYodGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5KXtsZXQgdD1uZXcgbTtmb3IobGV0IGUgb2YgdGhpcy5fb3V0cHV0U3RyZWFtKXtsZXQgbj1hKGUsVCk7bnVsbCE9PW4mJnQuQXBwZW5kKG4udmFsdWUpfXRoaXMuX2N1cnJlbnRUZXh0PXRoaXMuQ2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHQudG9TdHJpbmcoKSksdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5PSExfXJldHVybiB0aGlzLl9jdXJyZW50VGV4dH1DbGVhbk91dHB1dFdoaXRlc3BhY2UodCl7bGV0IGU9bmV3IG0sbj0tMSxpPTA7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2xldCBhPXQuY2hhckF0KHIpLHM9XCIgXCI9PWF8fFwiXFx0XCI9PWE7cyYmLTE9PW4mJihuPXIpLHN8fChcIlxcblwiIT1hJiZuPjAmJm4hPWkmJmUuQXBwZW5kKFwiIFwiKSxuPS0xKSxcIlxcblwiPT1hJiYoaT1yKzEpLHN8fGUuQXBwZW5kKGEpfXJldHVybiBlLnRvU3RyaW5nKCl9Z2V0IGN1cnJlbnRUYWdzKCl7aWYodGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5KXt0aGlzLl9jdXJyZW50VGFncz1bXTtmb3IobGV0IHQgb2YgdGhpcy5fb3V0cHV0U3RyZWFtKXtsZXQgZT1hKHQsaik7bnVsbCE9PWUmJnRoaXMuX2N1cnJlbnRUYWdzLnB1c2goZS50ZXh0KX10aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHk9ITF9cmV0dXJuIHRoaXMuX2N1cnJlbnRUYWdzfWdldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb259c2V0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24odCl7dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj10fUdvVG9TdGFydCgpe3RoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyPUkuU3RhcnRPZih0aGlzLnN0b3J5Lm1haW5Db250ZW50Q29udGFpbmVyKX1Db3B5QW5kU3RhcnRQYXRjaGluZygpe2xldCB0PW5ldyBIKHRoaXMuc3RvcnkpO3JldHVybiB0Ll9wYXRjaD1uZXcgVSh0aGlzLl9wYXRjaCksdC5vdXRwdXRTdHJlYW0ucHVzaC5hcHBseSh0Lm91dHB1dFN0cmVhbSx0aGlzLl9vdXRwdXRTdHJlYW0pLHQuT3V0cHV0U3RyZWFtRGlydHkoKSx0Ll9jdXJyZW50Q2hvaWNlcy5wdXNoLmFwcGx5KHQuX2N1cnJlbnRDaG9pY2VzLHRoaXMuX2N1cnJlbnRDaG9pY2VzKSx0aGlzLmhhc0Vycm9yJiYodC5fY3VycmVudEVycm9ycz1bXSx0Ll9jdXJyZW50RXJyb3JzLnB1c2guYXBwbHkodC5fY3VycmVudEVycm9ycyx0aGlzLmN1cnJlbnRFcnJvcnN8fFtdKSksdGhpcy5oYXNXYXJuaW5nJiYodC5fY3VycmVudFdhcm5pbmdzPVtdLHQuX2N1cnJlbnRXYXJuaW5ncy5wdXNoLmFwcGx5KHQuX2N1cnJlbnRXYXJuaW5ncyx0aGlzLmN1cnJlbnRXYXJuaW5nc3x8W10pKSx0LmNhbGxTdGFjaz1uZXcgcSh0aGlzLmNhbGxTdGFjayksdC52YXJpYWJsZXNTdGF0ZT10aGlzLnZhcmlhYmxlc1N0YXRlLHQudmFyaWFibGVzU3RhdGUuY2FsbFN0YWNrPXQuY2FsbFN0YWNrLHQudmFyaWFibGVzU3RhdGUucGF0Y2g9dC5fcGF0Y2gsdC5ldmFsdWF0aW9uU3RhY2sucHVzaC5hcHBseSh0LmV2YWx1YXRpb25TdGFjayx0aGlzLmV2YWx1YXRpb25TdGFjayksdGhpcy5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsfHwodC5kaXZlcnRlZFBvaW50ZXI9dGhpcy5kaXZlcnRlZFBvaW50ZXIuY29weSgpKSx0LnByZXZpb3VzUG9pbnRlcj10aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCksdC5fdmlzaXRDb3VudHM9dGhpcy5fdmlzaXRDb3VudHMsdC5fdHVybkluZGljZXM9dGhpcy5fdHVybkluZGljZXMsdC5jdXJyZW50VHVybkluZGV4PXRoaXMuY3VycmVudFR1cm5JbmRleCx0LnN0b3J5U2VlZD10aGlzLnN0b3J5U2VlZCx0LnByZXZpb3VzUmFuZG9tPXRoaXMucHJldmlvdXNSYW5kb20sdC5kaWRTYWZlRXhpdD10aGlzLmRpZFNhZmVFeGl0LHR9UmVzdG9yZUFmdGVyUGF0Y2goKXt0aGlzLnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjaz10aGlzLmNhbGxTdGFjayx0aGlzLnZhcmlhYmxlc1N0YXRlLnBhdGNoPXRoaXMuX3BhdGNofUFwcGx5QW55UGF0Y2goKXtpZihudWxsIT09dGhpcy5fcGF0Y2gpe3RoaXMudmFyaWFibGVzU3RhdGUuQXBwbHlQYXRjaCgpO2ZvcihsZXRbdCxlXW9mIHRoaXMuX3BhdGNoLnZpc2l0Q291bnRzKXRoaXMuQXBwbHlDb3VudENoYW5nZXModCxlLCEwKTtmb3IobGV0W3QsZV1vZiB0aGlzLl9wYXRjaC50dXJuSW5kaWNlcyl0aGlzLkFwcGx5Q291bnRDaGFuZ2VzKHQsZSwhMSk7dGhpcy5fcGF0Y2g9bnVsbH19QXBwbHlDb3VudENoYW5nZXModCxlLG4peyhuP3RoaXMuX3Zpc2l0Q291bnRzOnRoaXMuX3R1cm5JbmRpY2VzKS5zZXQodC5wYXRoLnRvU3RyaW5nKCksZSl9V3JpdGVKc29uKHQpe3QuV3JpdGVPYmplY3RTdGFydCgpO2xldCBlPSExO2ZvcihsZXQgbiBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcyl7aWYobnVsbD09PW4udGhyZWFkQXRHZW5lcmF0aW9uKXJldHVybiBkKFwiYy50aHJlYWRBdEdlbmVyYXRpb25cIik7bi5vcmlnaW5hbFRocmVhZEluZGV4PW4udGhyZWFkQXRHZW5lcmF0aW9uLnRocmVhZEluZGV4LG51bGw9PT10aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgobi5vcmlnaW5hbFRocmVhZEluZGV4KSYmKGV8fChlPSEwLHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwiY2hvaWNlVGhyZWFkc1wiKSx0LldyaXRlT2JqZWN0U3RhcnQoKSksdC5Xcml0ZVByb3BlcnR5U3RhcnQobi5vcmlnaW5hbFRocmVhZEluZGV4KSxuLnRocmVhZEF0R2VuZXJhdGlvbi5Xcml0ZUpzb24odCksdC5Xcml0ZVByb3BlcnR5RW5kKCkpfWlmKGUmJih0LldyaXRlT2JqZWN0RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCkpLHQuV3JpdGVQcm9wZXJ0eShcImNhbGxzdGFja1RocmVhZHNcIix0PT50aGlzLmNhbGxTdGFjay5Xcml0ZUpzb24odCkpLHQuV3JpdGVQcm9wZXJ0eShcInZhcmlhYmxlc1N0YXRlXCIsdD0+dGhpcy52YXJpYWJsZXNTdGF0ZS5Xcml0ZUpzb24odCkpLHQuV3JpdGVQcm9wZXJ0eShcImV2YWxTdGFja1wiLHQ9Pk0uV3JpdGVMaXN0UnVudGltZU9ianModCx0aGlzLmV2YWx1YXRpb25TdGFjaykpLHQuV3JpdGVQcm9wZXJ0eShcIm91dHB1dFN0cmVhbVwiLHQ9Pk0uV3JpdGVMaXN0UnVudGltZU9ianModCx0aGlzLl9vdXRwdXRTdHJlYW0pKSx0LldyaXRlUHJvcGVydHkoXCJjdXJyZW50Q2hvaWNlc1wiLHQ9Pnt0LldyaXRlQXJyYXlTdGFydCgpO2ZvcihsZXQgZSBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcylNLldyaXRlQ2hvaWNlKHQsZSk7dC5Xcml0ZUFycmF5RW5kKCl9KSwhdGhpcy5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKXtpZihudWxsPT09dGhpcy5kaXZlcnRlZFBvaW50ZXIucGF0aClyZXR1cm4gZChcImRpdmVydGVkUG9pbnRlclwiKTt0LldyaXRlUHJvcGVydHkoXCJjdXJyZW50RGl2ZXJ0VGFyZ2V0XCIsdGhpcy5kaXZlcnRlZFBvaW50ZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKX10LldyaXRlUHJvcGVydHkoXCJ2aXNpdENvdW50c1wiLHQ9Pk0uV3JpdGVJbnREaWN0aW9uYXJ5KHQsdGhpcy5fdmlzaXRDb3VudHMpKSx0LldyaXRlUHJvcGVydHkoXCJ0dXJuSW5kaWNlc1wiLHQ9Pk0uV3JpdGVJbnREaWN0aW9uYXJ5KHQsdGhpcy5fdHVybkluZGljZXMpKSx0LldyaXRlSW50UHJvcGVydHkoXCJ0dXJuSWR4XCIsdGhpcy5jdXJyZW50VHVybkluZGV4KSx0LldyaXRlSW50UHJvcGVydHkoXCJzdG9yeVNlZWRcIix0aGlzLnN0b3J5U2VlZCksdC5Xcml0ZUludFByb3BlcnR5KFwicHJldmlvdXNSYW5kb21cIix0aGlzLnByZXZpb3VzUmFuZG9tKSx0LldyaXRlSW50UHJvcGVydHkoXCJpbmtTYXZlVmVyc2lvblwiLHRoaXMua0lua1NhdmVTdGF0ZVZlcnNpb24pLHQuV3JpdGVJbnRQcm9wZXJ0eShcImlua0Zvcm1hdFZlcnNpb25cIixYLmlua1ZlcnNpb25DdXJyZW50KSx0LldyaXRlT2JqZWN0RW5kKCl9TG9hZEpzb25PYmoodCl7bGV0IG49dCxpPW4uaW5rU2F2ZVZlcnNpb247aWYobnVsbD09aSl0aHJvdyBuZXcgUyhcImluayBzYXZlIGZvcm1hdCBpbmNvcnJlY3QsIGNhbid0IGxvYWQuXCIpO2lmKHBhcnNlSW50KGkpPHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbil0aHJvdyBuZXcgUyhcIkluayBzYXZlIGZvcm1hdCBpc24ndCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiAoc2F3ICdcIitpK1wiJywgYnV0IG1pbmltdW0gaXMgXCIrdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uK1wiKSwgc28gY2FuJ3QgbG9hZC5cIik7dGhpcy5jYWxsU3RhY2suU2V0SnNvblRva2VuKG4uY2FsbHN0YWNrVGhyZWFkcyx0aGlzLnN0b3J5KSx0aGlzLnZhcmlhYmxlc1N0YXRlLlNldEpzb25Ub2tlbihuLnZhcmlhYmxlc1N0YXRlKSx0aGlzLl9ldmFsdWF0aW9uU3RhY2s9TS5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KG4uZXZhbFN0YWNrKSx0aGlzLl9vdXRwdXRTdHJlYW09TS5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KG4ub3V0cHV0U3RyZWFtKSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCksdGhpcy5fY3VycmVudENob2ljZXM9TS5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KG4uY3VycmVudENob2ljZXMpO2xldCByPW4uY3VycmVudERpdmVydFRhcmdldDtpZihudWxsIT1yKXtsZXQgdD1uZXcgZShyLnRvU3RyaW5nKCkpO3RoaXMuZGl2ZXJ0ZWRQb2ludGVyPXRoaXMuc3RvcnkuUG9pbnRlckF0UGF0aCh0KX10aGlzLl92aXNpdENvdW50cz1NLkpPYmplY3RUb0ludERpY3Rpb25hcnkobi52aXNpdENvdW50cyksdGhpcy5fdHVybkluZGljZXM9TS5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KG4udHVybkluZGljZXMpLHRoaXMuY3VycmVudFR1cm5JbmRleD1wYXJzZUludChuLnR1cm5JZHgpLHRoaXMuc3RvcnlTZWVkPXBhcnNlSW50KG4uc3RvcnlTZWVkKSx0aGlzLnByZXZpb3VzUmFuZG9tPXBhcnNlSW50KG4ucHJldmlvdXNSYW5kb20pO2xldCBhPW4uY2hvaWNlVGhyZWFkcztmb3IobGV0IHQgb2YgdGhpcy5fY3VycmVudENob2ljZXMpe2xldCBlPXRoaXMuY2FsbFN0YWNrLlRocmVhZFdpdGhJbmRleCh0Lm9yaWdpbmFsVGhyZWFkSW5kZXgpO2lmKG51bGwhPWUpdC50aHJlYWRBdEdlbmVyYXRpb249ZS5Db3B5KCk7ZWxzZXtsZXQgZT1hW3Qub3JpZ2luYWxUaHJlYWRJbmRleC50b1N0cmluZygpXTt0LnRocmVhZEF0R2VuZXJhdGlvbj1uZXcgcS5UaHJlYWQoZSx0aGlzLnN0b3J5KX19fVJlc2V0RXJyb3JzKCl7dGhpcy5fY3VycmVudEVycm9ycz1udWxsLHRoaXMuX2N1cnJlbnRXYXJuaW5ncz1udWxsfVJlc2V0T3V0cHV0KHQ9bnVsbCl7dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aD0wLG51bGwhPT10JiZ0aGlzLl9vdXRwdXRTdHJlYW0ucHVzaC5hcHBseSh0aGlzLl9vdXRwdXRTdHJlYW0sdCksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfVB1c2hUb091dHB1dFN0cmVhbSh0KXtsZXQgZT1hKHQsVCk7aWYobnVsbCE9PWUpe2xldCB0PXRoaXMuVHJ5U3BsaXR0aW5nSGVhZFRhaWxXaGl0ZXNwYWNlKGUpO2lmKG51bGwhPT10KXtmb3IobGV0IGUgb2YgdCl0aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwoZSk7cmV0dXJuIHZvaWQgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfX10aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwodCksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfVBvcEZyb21PdXRwdXRTdHJlYW0odCl7dGhpcy5vdXRwdXRTdHJlYW0uc3BsaWNlKHRoaXMub3V0cHV0U3RyZWFtLmxlbmd0aC10LHQpLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX1UcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2UodCl7bGV0IGU9dC52YWx1ZTtpZihudWxsPT09ZSlyZXR1cm4gZChcInNpbmdsZS52YWx1ZVwiKTtsZXQgbj0tMSxpPS0xO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtsZXQgcj1lW3RdO2lmKFwiXFxuXCIhPXIpe2lmKFwiIFwiPT1yfHxcIlxcdFwiPT1yKWNvbnRpbnVlO2JyZWFrfS0xPT1uJiYobj10KSxpPXR9bGV0IHI9LTEsYT0tMTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoOysrdCl7bGV0IG49ZVt0XTtpZihcIlxcblwiIT1uKXtpZihcIiBcIj09bnx8XCJcXHRcIj09biljb250aW51ZTticmVha30tMT09ciYmKHI9dCksYT10fWlmKC0xPT1uJiYtMT09cilyZXR1cm4gbnVsbDtsZXQgcz1bXSxsPTAsbz1lLmxlbmd0aDtpZigtMSE9bil7aWYobj4wKXtsZXQgdD1uZXcgVChlLnN1YnN0cmluZygwLG4pKTtzLnB1c2godCl9cy5wdXNoKG5ldyBUKFwiXFxuXCIpKSxsPWkrMX1pZigtMSE9ciYmKG89YSksbz5sKXtsZXQgdD1lLnN1YnN0cmluZyhsLG8tbCk7cy5wdXNoKG5ldyBUKHQpKX1pZigtMSE9ciYmYT5pJiYocy5wdXNoKG5ldyBUKFwiXFxuXCIpKSxyPGUubGVuZ3RoLTEpKXtsZXQgdD1lLmxlbmd0aC1yLTEsbj1uZXcgVChlLnN1YnN0cmluZyhyKzEsdCkpO3MucHVzaChuKX1yZXR1cm4gc31QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKHQpe2xldCBlPWEodCx4KSxuPWEodCxUKSxpPSEwO2lmKGUpdGhpcy5UcmltTmV3bGluZXNGcm9tT3V0cHV0U3RyZWFtKCksaT0hMDtlbHNlIGlmKG4pe2xldCB0PS0xLGU9dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQ7ZS50eXBlPT1yLkZ1bmN0aW9uJiYodD1lLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSk7bGV0IGE9LTE7Zm9yKGxldCBlPXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTtlPj0wO2UtLSl7bGV0IG49dGhpcy5fb3V0cHV0U3RyZWFtW2VdLGk9biBpbnN0YW5jZW9mIEE/bjpudWxsO2lmKG51bGwhPShuIGluc3RhbmNlb2YgeD9uOm51bGwpKXthPWU7YnJlYWt9aWYobnVsbCE9aSYmaS5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5CZWdpblN0cmluZyl7ZT49dCYmKHQ9LTEpO2JyZWFrfX1sZXQgcz0tMTtpZihzPS0xIT1hJiYtMSE9dD9NYXRoLm1pbih0LGEpOi0xIT1hP2E6dCwtMSE9cyl7aWYobi5pc05ld2xpbmUpaT0hMTtlbHNlIGlmKG4uaXNOb25XaGl0ZXNwYWNlJiYoYT4tMSYmdGhpcy5SZW1vdmVFeGlzdGluZ0dsdWUoKSx0Pi0xKSl7bGV0IHQ9dGhpcy5jYWxsU3RhY2suZWxlbWVudHM7Zm9yKGxldCBlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe2xldCBuPXRbZV07aWYobi50eXBlIT1yLkZ1bmN0aW9uKWJyZWFrO24uZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtPS0xfX19ZWxzZSBuLmlzTmV3bGluZSYmKCF0aGlzLm91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUmJnRoaXMub3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50fHwoaT0hMSkpfWlmKGkpe2lmKG51bGw9PT10KXJldHVybiBkKFwib2JqXCIpO3RoaXMuX291dHB1dFN0cmVhbS5wdXNoKHQpLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX19VHJpbU5ld2xpbmVzRnJvbU91dHB1dFN0cmVhbSgpe2xldCB0PS0xLGU9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO2Zvcig7ZT49MDspe2xldCBuPXRoaXMuX291dHB1dFN0cmVhbVtlXSxpPWEobixBKSxyPWEobixUKTtpZihudWxsIT1pfHxudWxsIT1yJiZyLmlzTm9uV2hpdGVzcGFjZSlicmVhaztudWxsIT1yJiZyLmlzTmV3bGluZSYmKHQ9ZSksZS0tfWlmKHQ+PTApZm9yKGU9dDtlPHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg7KXthKHRoaXMuX291dHB1dFN0cmVhbVtlXSxUKT90aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGUsMSk6ZSsrfXRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX1SZW1vdmVFeGlzdGluZ0dsdWUoKXtmb3IobGV0IHQ9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO3Q+PTA7dC0tKXtsZXQgZT10aGlzLl9vdXRwdXRTdHJlYW1bdF07aWYoZSBpbnN0YW5jZW9mIHgpdGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZSh0LDEpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIEEpYnJlYWt9dGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfWdldCBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKCl7aWYodGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aD4wKWZvcihsZXQgdD10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7dD49MDt0LS0pe2lmKHRoaXMuX291dHB1dFN0cmVhbVt0XWluc3RhbmNlb2YgQSlicmVhaztsZXQgZT10aGlzLl9vdXRwdXRTdHJlYW1bdF07aWYoZSBpbnN0YW5jZW9mIFQpe2lmKGUuaXNOZXdsaW5lKXJldHVybiEwO2lmKGUuaXNOb25XaGl0ZXNwYWNlKWJyZWFrfX1yZXR1cm4hMX1nZXQgb3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50KCl7Zm9yKGxldCB0PTA7dDx0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoO3QrKylpZih0aGlzLl9vdXRwdXRTdHJlYW1bdF1pbnN0YW5jZW9mIFQpcmV0dXJuITA7cmV0dXJuITF9Z2V0IGluU3RyaW5nRXZhbHVhdGlvbigpe2ZvcihsZXQgdD10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7dD49MDt0LS0pe2xldCBlPWEodGhpcy5fb3V0cHV0U3RyZWFtW3RdLEEpO2lmKGUgaW5zdGFuY2VvZiBBJiZlLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKXJldHVybiEwfXJldHVybiExfVB1c2hFdmFsdWF0aW9uU3RhY2sodCl7bGV0IGU9YSh0LE8pO2lmKGUpe2xldCB0PWUudmFsdWU7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJyYXdMaXN0XCIpO2lmKG51bGwhPXQub3JpZ2luTmFtZXMpe3Qub3JpZ2luc3x8KHQub3JpZ2lucz1bXSksdC5vcmlnaW5zLmxlbmd0aD0wO2ZvcihsZXQgZSBvZiB0Lm9yaWdpbk5hbWVzKXtpZihudWxsPT09dGhpcy5zdG9yeS5saXN0RGVmaW5pdGlvbnMpcmV0dXJuIGQoXCJTdG9yeVN0YXRlLnN0b3J5Lmxpc3REZWZpbml0aW9uc1wiKTtsZXQgbj10aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihlLG51bGwpO2lmKG51bGw9PT1uLnJlc3VsdClyZXR1cm4gZChcIlN0b3J5U3RhdGUgZGVmLnJlc3VsdFwiKTt0Lm9yaWdpbnMuaW5kZXhPZihuLnJlc3VsdCk8MCYmdC5vcmlnaW5zLnB1c2gobi5yZXN1bHQpfX19aWYobnVsbD09PXQpcmV0dXJuIGQoXCJvYmpcIik7dGhpcy5ldmFsdWF0aW9uU3RhY2sucHVzaCh0KX1Qb3BFdmFsdWF0aW9uU3RhY2sodCl7aWYodm9pZCAwPT09dCl7cmV0dXJuIG8odGhpcy5ldmFsdWF0aW9uU3RhY2sucG9wKCkpfWlmKHQ+dGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInRyeWluZyB0byBwb3AgdG9vIG1hbnkgb2JqZWN0c1wiKTtyZXR1cm4gbyh0aGlzLmV2YWx1YXRpb25TdGFjay5zcGxpY2UodGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoLXQsdCkpfVBlZWtFdmFsdWF0aW9uU3RhY2soKXtyZXR1cm4gdGhpcy5ldmFsdWF0aW9uU3RhY2tbdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoLTFdfUZvcmNlRW5kKCl7dGhpcy5jYWxsU3RhY2suUmVzZXQoKSx0aGlzLl9jdXJyZW50Q2hvaWNlcy5sZW5ndGg9MCx0aGlzLmN1cnJlbnRQb2ludGVyPUkuTnVsbCx0aGlzLnByZXZpb3VzUG9pbnRlcj1JLk51bGwsdGhpcy5kaWRTYWZlRXhpdD0hMH1UcmltV2hpdGVzcGFjZUZyb21GdW5jdGlvbkVuZCgpe24uQXNzZXJ0KHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGU9PXIuRnVuY3Rpb24pO2xldCB0PXRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbTstMT09dCYmKHQ9MCk7Zm9yKGxldCBlPXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTtlPj10O2UtLSl7bGV0IHQ9dGhpcy5fb3V0cHV0U3RyZWFtW2VdLG49YSh0LFQpLGk9YSh0LEEpO2lmKG51bGwhPW4pe2lmKGkpYnJlYWs7aWYoIW4uaXNOZXdsaW5lJiYhbi5pc0lubGluZVdoaXRlc3BhY2UpYnJlYWs7dGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShlLDEpLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX19fVBvcENhbGxTdGFjayh0PW51bGwpe3RoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGU9PXIuRnVuY3Rpb24mJnRoaXMuVHJpbVdoaXRlc3BhY2VGcm9tRnVuY3Rpb25FbmQoKSx0aGlzLmNhbGxTdGFjay5Qb3AodCl9U2V0Q2hvc2VuUGF0aCh0LGUpe3RoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aD0wO2xldCBuPXRoaXMuc3RvcnkuUG9pbnRlckF0UGF0aCh0KTtuLmlzTnVsbHx8LTEhPW4uaW5kZXh8fChuLmluZGV4PTApLHRoaXMuY3VycmVudFBvaW50ZXI9bixlJiZ0aGlzLmN1cnJlbnRUdXJuSW5kZXgrK31TdGFydEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKHQsZSl7dGhpcy5jYWxsU3RhY2suUHVzaChyLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lLHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCksdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXI9SS5TdGFydE9mKHQpLHRoaXMuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGUpfVBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayh0KXtpZihudWxsIT10KWZvcihsZXQgZT0wO2U8dC5sZW5ndGg7ZSsrKXtpZihcIm51bWJlclwiIT10eXBlb2YgdFtlXSYmXCJzdHJpbmdcIiE9dHlwZW9mIHRbZV0pdGhyb3cgbmV3IEVycm9yKFwiaW5rIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgRXZhbHVhdGVGdW5jdGlvbiAvIENob29zZVBhdGhTdHJpbmdXaXRoUGFyYW1ldGVycyAgbXVzdCBiZSBpbnQsIGZsb2F0IG9yIHN0cmluZ1wiKTt0aGlzLlB1c2hFdmFsdWF0aW9uU3RhY2sodi5DcmVhdGUodFtlXSkpfX1UcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZT09ci5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSYmKHRoaXMuY3VycmVudFBvaW50ZXI9SS5OdWxsLHRoaXMuZGlkU2FmZUV4aXQ9ITAsITApfUNvbXBsZXRlRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKXtpZih0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlIT1yLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKXRocm93IG5ldyBTKFwiRXhwZWN0ZWQgZXh0ZXJuYWwgZnVuY3Rpb24gZXZhbHVhdGlvbiB0byBiZSBjb21wbGV0ZS4gU3RhY2sgdHJhY2U6IFwiK3RoaXMuY2FsbFN0YWNrLmNhbGxTdGFja1RyYWNlKTtsZXQgdD10aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkLGU9bnVsbDtmb3IoO3RoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aD50Oyl7bGV0IHQ9dGhpcy5Qb3BFdmFsdWF0aW9uU3RhY2soKTtudWxsPT09ZSYmKGU9dCl9aWYodGhpcy5Qb3BDYWxsU3RhY2soci5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSksZSl7aWYoZSBpbnN0YW5jZW9mIEwpcmV0dXJuIG51bGw7bGV0IHQ9cyhlLHYpO3JldHVybiB0LnZhbHVlVHlwZT09aS5EaXZlcnRUYXJnZXQ/dC52YWx1ZU9iamVjdC50b1N0cmluZygpOnQudmFsdWVPYmplY3R9cmV0dXJuIG51bGx9QWRkRXJyb3IodCxlKXtlPyhudWxsPT10aGlzLl9jdXJyZW50V2FybmluZ3MmJih0aGlzLl9jdXJyZW50V2FybmluZ3M9W10pLHRoaXMuX2N1cnJlbnRXYXJuaW5ncy5wdXNoKHQpKToobnVsbD09dGhpcy5fY3VycmVudEVycm9ycyYmKHRoaXMuX2N1cnJlbnRFcnJvcnM9W10pLHRoaXMuX2N1cnJlbnRFcnJvcnMucHVzaCh0KSl9T3V0cHV0U3RyZWFtRGlydHkoKXt0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHk9ITAsdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5PSEwfX1jbGFzcyAke2NvbnN0cnVjdG9yKCl7dGhpcy5zdGFydFRpbWU9dm9pZCAwfWdldCBFbGFwc2VkTWlsbGlzZWNvbmRzKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuc3RhcnRUaW1lPzA6KG5ldyBEYXRlKS5nZXRUaW1lKCktdGhpcy5zdGFydFRpbWV9U3RhcnQoKXt0aGlzLnN0YXJ0VGltZT0obmV3IERhdGUpLmdldFRpbWUoKX1TdG9wKCl7dGhpcy5zdGFydFRpbWU9dm9pZCAwfX1OdW1iZXIuaXNJbnRlZ2VyfHwoTnVtYmVyLmlzSW50ZWdlcj1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCkmJnQ+LTkwMDcxOTkyNTQ3NDA5OTImJnQ8OTAwNzE5OTI1NDc0MDk5MiYmTWF0aC5mbG9vcih0KT09PXR9KTtjbGFzcyBYIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcigpe2xldCB0O3N1cGVyKCksdGhpcy5pbmtWZXJzaW9uTWluaW11bUNvbXBhdGlibGU9MTgsdGhpcy5fcHJldkNvbnRhaW5lcnM9W10sdGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3M9ITEsdGhpcy5fbGlzdERlZmluaXRpb25zPW51bGwsdGhpcy5fdmFyaWFibGVPYnNlcnZlcnM9bnVsbCx0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHM9ITEsdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcj1udWxsLHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmU9ITEsdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU9bnVsbCx0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50PTAsdGhpcy5fYXN5bmNTYXZpbmc9ITEsdGhpcy5fcHJvZmlsZXI9bnVsbDtsZXQgZT1udWxsLG49bnVsbDtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4pdD1hcmd1bWVudHNbMF0sdm9pZCAwIT09YXJndW1lbnRzWzFdJiYoZT1hcmd1bWVudHNbMV0pLHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyPXQ7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtsZXQgdD1hcmd1bWVudHNbMF07bj16LlRleHRUb0RpY3Rpb25hcnkodCl9ZWxzZSBuPWFyZ3VtZW50c1swXTtpZihudWxsIT1lJiYodGhpcy5fbGlzdERlZmluaXRpb25zPW5ldyBCKGUpKSx0aGlzLl9leHRlcm5hbHM9bmV3IE1hcCxudWxsIT09bil7bGV0IHQ9bixlPXQuaW5rVmVyc2lvbjtpZihudWxsPT1lKXRocm93IG5ldyBFcnJvcihcImluayB2ZXJzaW9uIG51bWJlciBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpO2xldCBpPXBhcnNlSW50KGUpO2lmKGk+WC5pbmtWZXJzaW9uQ3VycmVudCl0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IHdhcyBuZXdlciB0aGFuIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGVuZ2luZVwiKTtpZihpPHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlKXRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgaXMgdG9vIG9sZCB0byBiZSBsb2FkZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7aSE9WC5pbmtWZXJzaW9uQ3VycmVudCYmY29uc29sZS53YXJuKFwiV0FSTklORzogVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBkb2Vzbid0IG1hdGNoIGN1cnJlbnQgdmVyc2lvbiBvZiBlbmdpbmUuIE5vbi1jcml0aWNhbCwgYnV0IHJlY29tbWVuZCBzeW5jaHJvbmlzaW5nLlwiKTtsZXQgcixhPXQucm9vdDtpZihudWxsPT1hKXRocm93IG5ldyBFcnJvcihcIlJvb3Qgbm9kZSBmb3IgaW5rIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIGl0J3MgYSB2YWxpZCAuaW5rLmpzb24gZmlsZT9cIik7KHI9dC5saXN0RGVmcykmJih0aGlzLl9saXN0RGVmaW5pdGlvbnM9TS5KVG9rZW5Ub0xpc3REZWZpbml0aW9ucyhyKSksdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXI9cyhNLkpUb2tlblRvUnVudGltZU9iamVjdChhKSxOKSx0aGlzLlJlc2V0U3RhdGUoKX19Z2V0IGN1cnJlbnRDaG9pY2VzKCl7bGV0IHQ9W107aWYobnVsbD09PXRoaXMuX3N0YXRlKXJldHVybiBkKFwidGhpcy5fc3RhdGVcIik7Zm9yKGxldCBlIG9mIHRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzKWUuaXNJbnZpc2libGVEZWZhdWx0fHwoZS5pbmRleD10Lmxlbmd0aCx0LnB1c2goZSkpO3JldHVybiB0fWdldCBjdXJyZW50VGV4dCgpe3JldHVybiB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUZXh0IHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpLHRoaXMuc3RhdGUuY3VycmVudFRleHR9Z2V0IGN1cnJlbnRUYWdzKCl7cmV0dXJuIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgY3VycmVudFRhZ3Mgc2luY2UgaXQncyBhIHdvcmsgaW4gcHJvZ3Jlc3NcIiksdGhpcy5zdGF0ZS5jdXJyZW50VGFnc31nZXQgY3VycmVudEVycm9ycygpe3JldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRFcnJvcnN9Z2V0IGN1cnJlbnRXYXJuaW5ncygpe3JldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRXYXJuaW5nc31nZXQgaGFzRXJyb3IoKXtyZXR1cm4gdGhpcy5zdGF0ZS5oYXNFcnJvcn1nZXQgaGFzV2FybmluZygpe3JldHVybiB0aGlzLnN0YXRlLmhhc1dhcm5pbmd9Z2V0IHZhcmlhYmxlc1N0YXRlKCl7cmV0dXJuIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGV9Z2V0IGxpc3REZWZpbml0aW9ucygpe3JldHVybiB0aGlzLl9saXN0RGVmaW5pdGlvbnN9Z2V0IHN0YXRlKCl7cmV0dXJuIHRoaXMuX3N0YXRlfVN0YXJ0UHJvZmlsaW5nKCl7fUVuZFByb2ZpbGluZygpe31Ub0pzb24odCl7bGV0IGU9ITE7aWYodHx8KGU9ITAsdD1uZXcgei5Xcml0ZXIpLHQuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVJbnRQcm9wZXJ0eShcImlua1ZlcnNpb25cIixYLmlua1ZlcnNpb25DdXJyZW50KSx0LldyaXRlUHJvcGVydHkoXCJyb290XCIsdD0+TS5Xcml0ZVJ1bnRpbWVDb250YWluZXIodCx0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcikpLG51bGwhPXRoaXMuX2xpc3REZWZpbml0aW9ucyl7dC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJsaXN0RGVmc1wiKSx0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0IGUgb2YgdGhpcy5fbGlzdERlZmluaXRpb25zLmxpc3RzKXt0LldyaXRlUHJvcGVydHlTdGFydChlLm5hbWUpLHQuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXRbbixpXW9mIGUuaXRlbXMpe2xldCBlPWYuZnJvbVNlcmlhbGl6ZWRLZXkobikscj1pO3QuV3JpdGVJbnRQcm9wZXJ0eShlLml0ZW1OYW1lLHIpfXQuV3JpdGVPYmplY3RFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKX10LldyaXRlT2JqZWN0RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCl9aWYodC5Xcml0ZU9iamVjdEVuZCgpLGUpcmV0dXJuIHQuVG9TdHJpbmcoKX1SZXNldFN0YXRlKCl7dGhpcy5JZkFzeW5jV2VDYW50KFwiUmVzZXRTdGF0ZVwiKSx0aGlzLl9zdGF0ZT1uZXcgSCh0aGlzKSx0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5PYnNlcnZlVmFyaWFibGVDaGFuZ2UodGhpcy5WYXJpYWJsZVN0YXRlRGlkQ2hhbmdlRXZlbnQuYmluZCh0aGlzKSksdGhpcy5SZXNldEdsb2JhbHMoKX1SZXNldEVycm9ycygpe2lmKG51bGw9PT10aGlzLl9zdGF0ZSlyZXR1cm4gZChcInRoaXMuX3N0YXRlXCIpO3RoaXMuX3N0YXRlLlJlc2V0RXJyb3JzKCl9UmVzZXRDYWxsc3RhY2soKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldENhbGxzdGFja1wiKSxudWxsPT09dGhpcy5fc3RhdGUpcmV0dXJuIGQoXCJ0aGlzLl9zdGF0ZVwiKTt0aGlzLl9zdGF0ZS5Gb3JjZUVuZCgpfVJlc2V0R2xvYmFscygpe2lmKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5nZXQoXCJnbG9iYWwgZGVjbFwiKSl7bGV0IHQ9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7dGhpcy5DaG9vc2VQYXRoKG5ldyBlKFwiZ2xvYmFsIGRlY2xcIiksITEpLHRoaXMuQ29udGludWVJbnRlcm5hbCgpLHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI9dH10aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLlNuYXBzaG90RGVmYXVsdEdsb2JhbHMoKX1Db250aW51ZSgpe3JldHVybiB0aGlzLkNvbnRpbnVlQXN5bmMoMCksdGhpcy5jdXJyZW50VGV4dH1nZXQgY2FuQ29udGludWUoKXtyZXR1cm4gdGhpcy5zdGF0ZS5jYW5Db250aW51ZX1nZXQgYXN5bmNDb250aW51ZUNvbXBsZXRlKCl7cmV0dXJuIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmV9Q29udGludWVBc3luYyh0KXt0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHN8fHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKCksdGhpcy5Db250aW51ZUludGVybmFsKHQpfUNvbnRpbnVlSW50ZXJuYWwodD0wKXtudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUHJlQ29udGludWUoKTtsZXQgZT10PjA7aWYodGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCsrLCF0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlKXtpZih0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlPWUsIXRoaXMuY2FuQ29udGludWUpdGhyb3cgbmV3IFMoXCJDYW4ndCBjb250aW51ZSAtIHNob3VsZCBjaGVjayBjYW5Db250aW51ZSBiZWZvcmUgY2FsbGluZyBDb250aW51ZVwiKTt0aGlzLl9zdGF0ZS5kaWRTYWZlRXhpdD0hMSx0aGlzLl9zdGF0ZS5SZXNldE91dHB1dCgpLDE9PXRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQmJih0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcz0hMCl9bGV0IG49bmV3ICQ7bi5TdGFydCgpO2xldCBpPSExO2Rve3RyeXtpPXRoaXMuQ29udGludWVTaW5nbGVTdGVwKCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdDt0aGlzLkFkZEVycm9yKHQubWVzc2FnZSx2b2lkIDAsdC51c2VFbmRMaW5lTnVtYmVyKTticmVha31pZihpKWJyZWFrO2lmKHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUmJm4uRWxhcHNlZE1pbGxpc2Vjb25kcz50KWJyZWFrfXdoaWxlKHRoaXMuY2FuQ29udGludWUpO24uU3RvcCgpLCFpJiZ0aGlzLmNhbkNvbnRpbnVlfHwobnVsbCE9PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lJiZ0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCksdGhpcy5jYW5Db250aW51ZXx8KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZCYmdGhpcy5BZGRFcnJvcihcIlRocmVhZCBhdmFpbGFibGUgdG8gcG9wLCB0aHJlYWRzIHNob3VsZCBhbHdheXMgYmUgZmxhdCBieSB0aGUgZW5kIG9mIGV2YWx1YXRpb24/XCIpLDAhPXRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5sZW5ndGh8fHRoaXMuc3RhdGUuZGlkU2FmZUV4aXR8fG51bGwhPXRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXJ8fCh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3Aoci5UdW5uZWwpP3RoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4tPicgdG8gcmV0dXJuIGZyb20gYSB0dW5uZWw/XCIpOnRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChyLkZ1bmN0aW9uKT90aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJ34gcmV0dXJuJz9cIik6dGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wP3RoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudCBmb3IgdW5rbm93biByZWFzb24uIFBsZWFzZSBkZWJ1ZyBjb21waWxlciFcIik6dGhpcy5BZGRFcnJvcihcInJhbiBvdXQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4gRE9ORScgb3IgJy0+IEVORCc/XCIpKSksdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdD0hMSwxPT10aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50JiYodGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM9ITEpLHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmU9ITEpLHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQtLSxudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUG9zdENvbnRpbnVlKCl9Q29udGludWVTaW5nbGVTdGVwKCl7aWYobnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlByZVN0ZXAoKSx0aGlzLlN0ZXAoKSxudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUG9zdFN0ZXAoKSx0aGlzLmNhbkNvbnRpbnVlfHx0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lfHx0aGlzLlRyeUZvbGxvd0RlZmF1bHRJbnZpc2libGVDaG9pY2UoKSxudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUHJlU25hcHNob3QoKSwhdGhpcy5zdGF0ZS5pblN0cmluZ0V2YWx1YXRpb24pe2lmKG51bGwhPT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSl7aWYobnVsbD09PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzKXJldHVybiBkKFwidGhpcy5fc3RhdGVBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzXCIpO2lmKG51bGw9PT10aGlzLnN0YXRlLmN1cnJlbnRUYWdzKXJldHVybiBkKFwidGhpcy5zdGF0ZS5jdXJyZW50VGFnc1wiKTtsZXQgdD10aGlzLkNhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGV4dCx0aGlzLnN0YXRlLmN1cnJlbnRUZXh0LHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzLmxlbmd0aCx0aGlzLnN0YXRlLmN1cnJlbnRUYWdzLmxlbmd0aCk7aWYodD09WC5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmUpcmV0dXJuIHRoaXMuUmVzdG9yZVN0YXRlU25hcHNob3QoKSwhMDt0PT1YLk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkJiZ0aGlzLkRpc2NhcmRTbmFwc2hvdCgpfXRoaXMuc3RhdGUub3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSYmKHRoaXMuY2FuQ29udGludWU/bnVsbD09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUmJnRoaXMuU3RhdGVTbmFwc2hvdCgpOnRoaXMuRGlzY2FyZFNuYXBzaG90KCkpfXJldHVybiBudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUG9zdFNuYXBzaG90KCksITF9Q2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHQsZSxuLGkpe2lmKG51bGw9PT10KXJldHVybiBkKFwicHJldlRleHRcIik7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJjdXJyVGV4dFwiKTtsZXQgcj1lLmxlbmd0aD49dC5sZW5ndGgmJlwiXFxuXCI9PWUuY2hhckF0KHQubGVuZ3RoLTEpO2lmKG49PWkmJnQubGVuZ3RoPT1lLmxlbmd0aCYmcilyZXR1cm4gWC5PdXRwdXRTdGF0ZUNoYW5nZS5Ob0NoYW5nZTtpZighcilyZXR1cm4gWC5PdXRwdXRTdGF0ZUNoYW5nZS5OZXdsaW5lUmVtb3ZlZDtpZihpPm4pcmV0dXJuIFguT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lO2ZvcihsZXQgbj10Lmxlbmd0aDtuPGUubGVuZ3RoO24rKyl7bGV0IHQ9ZS5jaGFyQXQobik7aWYoXCIgXCIhPXQmJlwiXFx0XCIhPXQpcmV0dXJuIFguT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lfXJldHVybiBYLk91dHB1dFN0YXRlQ2hhbmdlLk5vQ2hhbmdlfUNvbnRpbnVlTWF4aW1hbGx5KCl7dGhpcy5JZkFzeW5jV2VDYW50KFwiQ29udGludWVNYXhpbWFsbHlcIik7bGV0IHQ9bmV3IG07Zm9yKDt0aGlzLmNhbkNvbnRpbnVlOyl0LkFwcGVuZCh0aGlzLkNvbnRpbnVlKCkpO3JldHVybiB0LnRvU3RyaW5nKCl9Q29udGVudEF0UGF0aCh0KXtyZXR1cm4gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHQpfUtub3RDb250YWluZXJXaXRoTmFtZSh0KXtsZXQgZT10aGlzLm1haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5nZXQodCk7cmV0dXJuIGUgaW5zdGFuY2VvZiBOP2U6bnVsbH1Qb2ludGVyQXRQYXRoKHQpe2lmKDA9PXQubGVuZ3RoKXJldHVybiBJLk51bGw7bGV0IGU9bmV3IEksbj10Lmxlbmd0aCxpPW51bGw7cmV0dXJuIG51bGw9PT10Lmxhc3RDb21wb25lbnQ/ZChcInBhdGgubGFzdENvbXBvbmVudFwiKToodC5sYXN0Q29tcG9uZW50LmlzSW5kZXg/KG49dC5sZW5ndGgtMSxpPXRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aCh0LHZvaWQgMCxuKSxlLmNvbnRhaW5lcj1pLmNvbnRhaW5lcixlLmluZGV4PXQubGFzdENvbXBvbmVudC5pbmRleCk6KGk9dGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHQpLGUuY29udGFpbmVyPWkuY29udGFpbmVyLGUuaW5kZXg9LTEpLG51bGw9PWkub2JqfHxpLm9iaj09dGhpcy5tYWluQ29udGVudENvbnRhaW5lciYmbj4wP3RoaXMuRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBjb250ZW50IGF0IHBhdGggJ1wiK3QrXCInLCBhbmQgbm8gYXBwcm94aW1hdGlvbiBvZiBpdCB3YXMgcG9zc2libGUuXCIpOmkuYXBwcm94aW1hdGUmJnRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIrdCtcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG86ICdcIitpLm9iai5wYXRoK1wiJy5cIiksZSl9U3RhdGVTbmFwc2hvdCgpe3RoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lPXRoaXMuX3N0YXRlLHRoaXMuX3N0YXRlPXRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCl9UmVzdG9yZVN0YXRlU25hcHNob3QoKXtudWxsPT09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUmJmQoXCJfc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmVcIiksdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuUmVzdG9yZUFmdGVyUGF0Y2goKSx0aGlzLl9zdGF0ZT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSx0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZT1udWxsLHRoaXMuX2FzeW5jU2F2aW5nfHx0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCl9RGlzY2FyZFNuYXBzaG90KCl7dGhpcy5fYXN5bmNTYXZpbmd8fHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKSx0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZT1udWxsfUNvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlKCl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwic3RhcnQgc2F2aW5nIG9uIGEgYmFja2dyb3VuZCB0aHJlYWRcIiksdGhpcy5fYXN5bmNTYXZpbmcpdGhyb3cgbmV3IEVycm9yKFwiU3RvcnkgaXMgYWxyZWFkeSBpbiBiYWNrZ3JvdW5kIHNhdmluZyBtb2RlLCBjYW4ndCBjYWxsIENvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlIGFnYWluIVwiKTtsZXQgdD10aGlzLl9zdGF0ZTtyZXR1cm4gdGhpcy5fc3RhdGU9dGhpcy5fc3RhdGUuQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKSx0aGlzLl9hc3luY1NhdmluZz0hMCx0fUJhY2tncm91bmRTYXZlQ29tcGxldGUoKXtudWxsPT09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUmJnRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKSx0aGlzLl9hc3luY1NhdmluZz0hMX1TdGVwKCl7bGV0IHQ9ITAsZT10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtpZihlLmlzTnVsbClyZXR1cm47bGV0IG49YShlLlJlc29sdmUoKSxOKTtmb3IoO24mJih0aGlzLlZpc2l0Q29udGFpbmVyKG4sITApLDAhPW4uY29udGVudC5sZW5ndGgpOyllPUkuU3RhcnRPZihuKSxuPWEoZS5SZXNvbHZlKCksTik7dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcj1lLmNvcHkoKSxudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuU3RlcCh0aGlzLnN0YXRlLmNhbGxTdGFjayk7bGV0IGk9ZS5SZXNvbHZlKCkscj10aGlzLlBlcmZvcm1Mb2dpY0FuZEZsb3dDb250cm9sKGkpO2lmKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKXJldHVybjtyJiYodD0hMSk7bGV0IHM9YShpLFcpO2lmKHMpe2xldCBlPXRoaXMuUHJvY2Vzc0Nob2ljZShzKTtlJiZ0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMucHVzaChlKSxpPW51bGwsdD0hMX1pZihpIGluc3RhbmNlb2YgTiYmKHQ9ITEpLHQpe2xldCB0PWEoaSx3KTtpZih0JiYtMT09dC5jb250ZXh0SW5kZXgpe2xldCBlPXRoaXMuc3RhdGUuY2FsbFN0YWNrLkNvbnRleHRGb3JWYXJpYWJsZU5hbWVkKHQudmFyaWFibGVOYW1lKTtpPW5ldyB3KHQudmFyaWFibGVOYW1lLGUpfXRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj90aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soaSk6dGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oaSl9dGhpcy5OZXh0Q29udGVudCgpO2xldCBsPWEoaSxBKTtsJiZsLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkJiZ0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoVGhyZWFkKCl9VmlzaXRDb250YWluZXIodCxlKXt0LmNvdW50aW5nQXRTdGFydE9ubHkmJiFlfHwodC52aXNpdHNTaG91bGRCZUNvdW50ZWQmJnRoaXMuc3RhdGUuSW5jcmVtZW50VmlzaXRDb3VudEZvckNvbnRhaW5lcih0KSx0LnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCYmdGhpcy5zdGF0ZS5SZWNvcmRUdXJuSW5kZXhWaXNpdFRvQ29udGFpbmVyKHQpKX1WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKXtsZXQgdD10aGlzLnN0YXRlLnByZXZpb3VzUG9pbnRlci5jb3B5KCksZT10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtpZihlLmlzTnVsbHx8LTE9PWUuaW5kZXgpcmV0dXJuO2lmKHRoaXMuX3ByZXZDb250YWluZXJzLmxlbmd0aD0wLCF0LmlzTnVsbCl7bGV0IGU9YSh0LlJlc29sdmUoKSxOKXx8YSh0LmNvbnRhaW5lcixOKTtmb3IoO2U7KXRoaXMuX3ByZXZDb250YWluZXJzLnB1c2goZSksZT1hKGUucGFyZW50LE4pfWxldCBuPWUuUmVzb2x2ZSgpO2lmKG51bGw9PW4pcmV0dXJuO2xldCBpPWEobi5wYXJlbnQsTik7Zm9yKDtpJiYodGhpcy5fcHJldkNvbnRhaW5lcnMuaW5kZXhPZihpKTwwfHxpLmNvdW50aW5nQXRTdGFydE9ubHkpOyl7bGV0IHQ9aS5jb250ZW50Lmxlbmd0aD4wJiZuPT1pLmNvbnRlbnRbMF07dGhpcy5WaXNpdENvbnRhaW5lcihpLHQpLG49aSxpPWEoaS5wYXJlbnQsTil9fVByb2Nlc3NDaG9pY2UodCl7bGV0IGU9ITA7aWYodC5oYXNDb25kaXRpb24pe2xldCB0PXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7dGhpcy5Jc1RydXRoeSh0KXx8KGU9ITEpfWxldCBuPVwiXCIsaT1cIlwiO2lmKHQuaGFzQ2hvaWNlT25seUNvbnRlbnQpe2k9cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLFQpLnZhbHVlfHxcIlwifWlmKHQuaGFzU3RhcnRDb250ZW50KXtuPXModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxUKS52YWx1ZXx8XCJcIn1pZih0Lm9uY2VPbmx5KXt0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIodC5jaG9pY2VUYXJnZXQpPjAmJihlPSExKX1pZighZSlyZXR1cm4gbnVsbDtsZXQgcj1uZXcgRDtyZXR1cm4gci50YXJnZXRQYXRoPXQucGF0aE9uQ2hvaWNlLHIuc291cmNlUGF0aD10LnBhdGgudG9TdHJpbmcoKSxyLmlzSW52aXNpYmxlRGVmYXVsdD10LmlzSW52aXNpYmxlRGVmYXVsdCxyLnRocmVhZEF0R2VuZXJhdGlvbj10aGlzLnN0YXRlLmNhbGxTdGFjay5Gb3JrVGhyZWFkKCksci50ZXh0PShuK2kpLnJlcGxhY2UoL15bIFxcdF0rfFsgXFx0XSskL2csXCJcIikscn1Jc1RydXRoeSh0KXtpZih0IGluc3RhbmNlb2Ygdil7bGV0IGU9dDtpZihlIGluc3RhbmNlb2YgUCl7bGV0IHQ9ZTtyZXR1cm4gdGhpcy5FcnJvcihcIlNob3VsZG4ndCB1c2UgYSBkaXZlcnQgdGFyZ2V0ICh0byBcIit0LnRhcmdldFBhdGgrXCIpIGFzIGEgY29uZGl0aW9uYWwgdmFsdWUuIERpZCB5b3UgaW50ZW5kIGEgZnVuY3Rpb24gY2FsbCAnbGlrZVRoaXMoKScgb3IgYSByZWFkIGNvdW50IGNoZWNrICdsaWtlVGhpcyc/IChubyBhcnJvd3MpXCIpLCExfXJldHVybiBlLmlzVHJ1dGh5fXJldHVybiExfVBlcmZvcm1Mb2dpY0FuZEZsb3dDb250cm9sKHQpe2lmKG51bGw9PXQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIGspe2xldCBlPXQ7aWYoZS5pc0NvbmRpdGlvbmFsKXtsZXQgdD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO2lmKCF0aGlzLklzVHJ1dGh5KHQpKXJldHVybiEwfWlmKGUuaGFzVmFyaWFibGVUYXJnZXQpe2xldCB0PWUudmFyaWFibGVEaXZlcnROYW1lLG49dGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKHQpO2lmKG51bGw9PW4pdGhpcy5FcnJvcihcIlRyaWVkIHRvIGRpdmVydCB1c2luZyBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUgdGhhdCBjb3VsZCBub3QgYmUgZm91bmQgKFwiK3QrXCIpXCIpO2Vsc2UgaWYoIShuIGluc3RhbmNlb2YgUCkpe2xldCBlPWEobixiKSxpPVwiVHJpZWQgdG8gZGl2ZXJ0IHRvIGEgdGFyZ2V0IGZyb20gYSB2YXJpYWJsZSwgYnV0IHRoZSB2YXJpYWJsZSAoXCIrdCtcIikgZGlkbid0IGNvbnRhaW4gYSBkaXZlcnQgdGFyZ2V0LCBpdCBcIjtlIGluc3RhbmNlb2YgYiYmMD09ZS52YWx1ZT9pKz1cIndhcyBlbXB0eS9udWxsICh0aGUgdmFsdWUgMCkuXCI6aSs9XCJjb250YWluZWQgJ1wiK24rXCInLlwiLHRoaXMuRXJyb3IoaSl9bGV0IGk9cyhuLFApO3RoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyPXRoaXMuUG9pbnRlckF0UGF0aChpLnRhcmdldFBhdGgpfWVsc2V7aWYoZS5pc0V4dGVybmFsKXJldHVybiB0aGlzLkNhbGxFeHRlcm5hbEZ1bmN0aW9uKGUudGFyZ2V0UGF0aFN0cmluZyxlLmV4dGVybmFsQXJncyksITA7dGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXI9ZS50YXJnZXRQb2ludGVyLmNvcHkoKX1yZXR1cm4gZS5wdXNoZXNUb1N0YWNrJiZ0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKGUuc3RhY2tQdXNoVHlwZSx2b2lkIDAsdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKSx0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwmJiFlLmlzRXh0ZXJuYWwmJihlJiZlLmRlYnVnTWV0YWRhdGEmJm51bGwhPWUuZGVidWdNZXRhZGF0YS5zb3VyY2VOYW1lP3RoaXMuRXJyb3IoXCJEaXZlcnQgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Q6IFwiK2UuZGVidWdNZXRhZGF0YS5zb3VyY2VOYW1lKTp0aGlzLkVycm9yKFwiRGl2ZXJ0IHJlc29sdXRpb24gZmFpbGVkOiBcIitlKSksITB9aWYodCBpbnN0YW5jZW9mIEEpe2xldCBlPXQ7c3dpdGNoKGUuY29tbWFuZFR5cGUpe2Nhc2UgQS5Db21tYW5kVHlwZS5FdmFsU3RhcnQ6dGhpcy5Bc3NlcnQoITE9PT10aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24sXCJBbHJlYWR5IGluIGV4cHJlc3Npb24gZXZhbHVhdGlvbj9cIiksdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPSEwO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5FdmFsRW5kOnRoaXMuQXNzZXJ0KCEwPT09dGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uLFwiTm90IGluIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBtb2RlXCIpLHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj0hMTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRXZhbE91dHB1dDppZih0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg+MCl7bGV0IHQ9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtpZighKHQgaW5zdGFuY2VvZiBMKSl7bGV0IGU9bmV3IFQodC50b1N0cmluZygpKTt0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShlKX19YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLk5vT3A6YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZTp0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sodGhpcy5zdGF0ZS5QZWVrRXZhbHVhdGlvblN0YWNrKCkpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZTp0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbjpjYXNlIEEuQ29tbWFuZFR5cGUuUG9wVHVubmVsOmxldCB0PWUuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb24/ci5GdW5jdGlvbjpyLlR1bm5lbCxuPW51bGw7aWYodD09ci5UdW5uZWwpe2xldCB0PXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7bj1hKHQsUCksbnVsbD09PW4mJnRoaXMuQXNzZXJ0KHQgaW5zdGFuY2VvZiBMLFwiRXhwZWN0ZWQgdm9pZCBpZiAtPi0+IGRvZXNuJ3Qgb3ZlcnJpZGUgdGFyZ2V0XCIpfWlmKHRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCkpYnJlYWs7aWYodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZT09dCYmdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKXRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKCksbiYmKHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyPXRoaXMuUG9pbnRlckF0UGF0aChuLnRhcmdldFBhdGgpKTtlbHNle2xldCBlPW5ldyBNYXA7ZS5zZXQoci5GdW5jdGlvbixcImZ1bmN0aW9uIHJldHVybiBzdGF0ZW1lbnQgKH4gcmV0dXJuKVwiKSxlLnNldChyLlR1bm5lbCxcInR1bm5lbCBvbndhcmRzIHN0YXRlbWVudCAoLT4tPilcIik7bGV0IG49ZS5nZXQodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSk7dGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wfHwobj1cImVuZCBvZiBmbG93ICgtPiBFTkQgb3IgY2hvaWNlKVwiKTtsZXQgaT1cIkZvdW5kIFwiK2UuZ2V0KHQpK1wiLCB3aGVuIGV4cGVjdGVkIFwiK247dGhpcy5FcnJvcihpKX1icmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmc6dGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oZSksdGhpcy5Bc3NlcnQoITA9PT10aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24sXCJFeHBlY3RlZCB0byBiZSBpbiBhbiBleHByZXNzaW9uIHdoZW4gZXZhbHVhdGluZyBhIHN0cmluZ1wiKSx0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb249ITE7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkVuZFN0cmluZzpsZXQgaT1bXSxsPTA7Zm9yKGxldCB0PXRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aC0xO3Q+PTA7LS10KXtsZXQgZT10aGlzLnN0YXRlLm91dHB1dFN0cmVhbVt0XTtsKys7bGV0IG49YShlLEEpO2lmKG4mJm4uY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpYnJlYWs7ZSBpbnN0YW5jZW9mIFQmJmkucHVzaChlKX10aGlzLnN0YXRlLlBvcEZyb21PdXRwdXRTdHJlYW0obCksaT1pLnJldmVyc2UoKTtsZXQgbz1uZXcgbTtmb3IobGV0IHQgb2YgaSlvLkFwcGVuZCh0LnRvU3RyaW5nKCkpO3RoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj0hMCx0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFQoby50b1N0cmluZygpKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50OmxldCB1PXRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5sZW5ndGg7dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKHUpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuVHVybnM6dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKHRoaXMuc3RhdGUuY3VycmVudFR1cm5JbmRleCsxKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlR1cm5zU2luY2U6Y2FzZSBBLkNvbW1hbmRUeXBlLlJlYWRDb3VudDpsZXQgaD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO2lmKCEoaCBpbnN0YW5jZW9mIFApKXtsZXQgdD1cIlwiO2ggaW5zdGFuY2VvZiBiJiYodD1cIi4gRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIHJlYWQgY291bnQgKCdrbm90X25hbWUnKSBpbnN0ZWFkIG9mIGEgdGFyZ2V0ICgnLT4ga25vdF9uYW1lJyk/XCIpLHRoaXMuRXJyb3IoXCJUVVJOU19TSU5DRSAvIFJFQURfQ09VTlQgZXhwZWN0ZWQgYSBkaXZlcnQgdGFyZ2V0IChrbm90LCBzdGl0Y2gsIGxhYmVsIG5hbWUpLCBidXQgc2F3IFwiK2grdCk7YnJlYWt9bGV0IGMscD1zKGgsUCkseT1hKHRoaXMuQ29udGVudEF0UGF0aChwLnRhcmdldFBhdGgpLmNvcnJlY3RPYmosTik7bnVsbCE9eT9jPWUuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuVHVybnNTaW5jZT90aGlzLnN0YXRlLlR1cm5zU2luY2VGb3JDb250YWluZXIoeSk6dGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHkpOihjPWUuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuVHVybnNTaW5jZT8tMTowLHRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRhaW5lciBmb3IgXCIrZS50b1N0cmluZygpK1wiIGxvb2t1cCBhdCBcIitwLnRhcmdldFBhdGgudG9TdHJpbmcoKSkpLHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYihjKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlJhbmRvbTp7bGV0IHQ9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpLGU9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpO2lmKG51bGw9PWV8fGUgaW5zdGFuY2VvZiBiPT0hMSlyZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG1pbmltdW0gcGFyYW1ldGVyIG9mIFJBTkRPTShtaW4sIG1heClcIik7aWYobnVsbD09dHx8ZSBpbnN0YW5jZW9mIGI9PSExKXJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgbWF4aW11bSBwYXJhbWV0ZXIgb2YgUkFORE9NKG1pbiwgbWF4KVwiKTtpZihudWxsPT09dC52YWx1ZSlyZXR1cm4gZChcIm1heEludC52YWx1ZVwiKTtpZihudWxsPT09ZS52YWx1ZSlyZXR1cm4gZChcIm1pbkludC52YWx1ZVwiKTtsZXQgbj10LnZhbHVlLWUudmFsdWUrMTtuPD0wJiZ0aGlzLkVycm9yKFwiUkFORE9NIHdhcyBjYWxsZWQgd2l0aCBtaW5pbXVtIGFzIFwiK2UudmFsdWUrXCIgYW5kIG1heGltdW0gYXMgXCIrdC52YWx1ZStcIi4gVGhlIG1heGltdW0gbXVzdCBiZSBsYXJnZXJcIik7bGV0IGk9dGhpcy5zdGF0ZS5zdG9yeVNlZWQrdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSxyPW5ldyBLKGkpLm5leHQoKSxzPXIlbitlLnZhbHVlO3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYihzKSksdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbT1yO2JyZWFrfWNhc2UgQS5Db21tYW5kVHlwZS5TZWVkUmFuZG9tOmxldCBDPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKTtpZihudWxsPT1DfHxDIGluc3RhbmNlb2YgYj09ITEpcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBTRUVEX1JBTkRPTVwiKTtpZihudWxsPT09Qy52YWx1ZSlyZXR1cm4gZChcIm1pbkludC52YWx1ZVwiKTt0aGlzLnN0YXRlLnN0b3J5U2VlZD1DLnZhbHVlLHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb209MCx0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IEwpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5WaXNpdEluZGV4OmxldCBfPXRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcih0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lciktMTt0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIoXykpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleDpsZXQgdz10aGlzLk5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpO3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYih3KSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkOmJyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5Eb25lOnRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZD90aGlzLnN0YXRlLmNhbGxTdGFjay5Qb3BUaHJlYWQoKToodGhpcy5zdGF0ZS5kaWRTYWZlRXhpdD0hMCx0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyPUkuTnVsbCk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkVuZDp0aGlzLnN0YXRlLkZvcmNlRW5kKCk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50OmxldCBFPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKSx4PXModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxUKTtpZihudWxsPT09RSl0aHJvdyBuZXcgUyhcIlBhc3NlZCBub24taW50ZWdlciB3aGVuIGNyZWF0aW5nIGEgbGlzdCBlbGVtZW50IGZyb20gYSBudW1lcmljYWwgdmFsdWUuXCIpO2xldCBrPW51bGw7aWYobnVsbD09PXRoaXMubGlzdERlZmluaXRpb25zKXJldHVybiBkKFwidGhpcy5saXN0RGVmaW5pdGlvbnNcIik7bGV0IFc9dGhpcy5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24oeC52YWx1ZSxudWxsKTtpZighVy5leGlzdHMpdGhyb3cgbmV3IFMoXCJGYWlsZWQgdG8gZmluZCBMSVNUIGNhbGxlZCBcIit4LnZhbHVlKTt7aWYobnVsbD09PUUudmFsdWUpcmV0dXJuIGQoXCJtaW5JbnQudmFsdWVcIik7bGV0IHQ9Vy5yZXN1bHQuVHJ5R2V0SXRlbVdpdGhWYWx1ZShFLnZhbHVlLGYuTnVsbCk7dC5leGlzdHMmJihrPW5ldyBPKHQucmVzdWx0LEUudmFsdWUpKX1udWxsPT1rJiYoaz1uZXcgTyksdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGspO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5MaXN0UmFuZ2U6bGV0IEY9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLHYpLFY9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLHYpLFI9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLE8pO2lmKG51bGw9PT1SfHxudWxsPT09Vnx8bnVsbD09PUYpdGhyb3cgbmV3IFMoXCJFeHBlY3RlZCBsaXN0LCBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciBMSVNUX1JBTkdFXCIpO2lmKG51bGw9PT1SLnZhbHVlKXJldHVybiBkKFwidGFyZ2V0TGlzdC52YWx1ZVwiKTtsZXQgaj1SLnZhbHVlLkxpc3RXaXRoU3ViUmFuZ2UoVi52YWx1ZU9iamVjdCxGLnZhbHVlT2JqZWN0KTt0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IE8oaikpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5MaXN0UmFuZG9tOntsZXQgdD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO2lmKG51bGw9PT10KXRocm93IG5ldyBTKFwiRXhwZWN0ZWQgbGlzdCBmb3IgTElTVF9SQU5ET01cIik7bGV0IGU9dC52YWx1ZSxuPW51bGw7aWYobnVsbD09PWUpdGhyb3cgZChcImxpc3RcIik7aWYoMD09ZS5Db3VudCluPW5ldyBnO2Vsc2V7bGV0IHQ9dGhpcy5zdGF0ZS5zdG9yeVNlZWQrdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSxpPW5ldyBLKHQpLm5leHQoKSxyPWklZS5Db3VudCxhPWUuZW50cmllcygpO2ZvcihsZXQgdD0wO3Q8PXItMTt0KyspYS5uZXh0KCk7bGV0IHM9YS5uZXh0KCkudmFsdWUsbD17S2V5OmYuZnJvbVNlcmlhbGl6ZWRLZXkoc1swXSksVmFsdWU6c1sxXX07aWYobnVsbD09PWwuS2V5Lm9yaWdpbk5hbWUpcmV0dXJuIGQoXCJyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lXCIpO249bmV3IGcobC5LZXkub3JpZ2luTmFtZSx0aGlzKSxuLkFkZChsLktleSxsLlZhbHVlKSx0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tPWl9dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBPKG4pKTticmVha31kZWZhdWx0OnRoaXMuRXJyb3IoXCJ1bmhhbmRsZWQgQ29udHJvbENvbW1hbmQ6IFwiK2UpfXJldHVybiEwfWlmKHQgaW5zdGFuY2VvZiBWKXtsZXQgZT10LG49dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtyZXR1cm4gdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5Bc3NpZ24oZSxuKSwhMH1pZih0IGluc3RhbmNlb2YgRil7bGV0IGU9dCxuPW51bGw7aWYobnVsbCE9ZS5wYXRoRm9yQ291bnQpe2xldCB0PWUuY29udGFpbmVyRm9yQ291bnQsaT10aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIodCk7bj1uZXcgYihpKX1lbHNlIG49dGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKGUubmFtZSksbnVsbD09biYmKHRoaXMuV2FybmluZyhcIlZhcmlhYmxlIG5vdCBmb3VuZDogJ1wiK2UubmFtZStcIicuIFVzaW5nIGRlZmF1bHQgdmFsdWUgb2YgMCAoZmFsc2UpLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCB0ZW1wb3JhcnkgdmFyaWFibGVzIGlmIHRoZSBkZWNsYXJhdGlvbiBoYXNuJ3QgeWV0IGJlZW4gaGl0LiBHbG9iYWxzIGFyZSBhbHdheXMgZ2l2ZW4gYSBkZWZhdWx0IHZhbHVlIG9uIGxvYWQgaWYgYSB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzYXZlIHN0YXRlLlwiKSxuPW5ldyBiKDApKTtyZXR1cm4gdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG4pLCEwfWlmKHQgaW5zdGFuY2VvZiBSKXtsZXQgZT10LG49dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soZS5udW1iZXJPZlBhcmFtZXRlcnMpLGk9ZS5DYWxsKG4pO3JldHVybiB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soaSksITB9cmV0dXJuITF9Q2hvb3NlUGF0aFN0cmluZyh0LG49ITAsaT1bXSl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBDaG9vc2VQYXRoU3RyaW5nIHJpZ2h0IG5vd1wiKSxuKXRoaXMuUmVzZXRDYWxsc3RhY2soKTtlbHNlIGlmKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGU9PXIuRnVuY3Rpb24pe2xldCBlPVwiXCIsbj10aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb250YWluZXI7dGhyb3cgbnVsbCE9biYmKGU9XCIoXCIrbi5wYXRoLnRvU3RyaW5nKCkrXCIpIFwiKSxuZXcgRXJyb3IoXCJTdG9yeSB3YXMgcnVubmluZyBhIGZ1bmN0aW9uIFwiK2UrXCJ3aGVuIHlvdSBjYWxsZWQgQ2hvb3NlUGF0aFN0cmluZyhcIit0K1wiKSAtIHRoaXMgaXMgYWxtb3N0IGNlcnRhaW5seSBub3Qgbm90IHdoYXQgeW91IHdhbnQhIEZ1bGwgc3RhY2sgdHJhY2U6IFxcblwiK3RoaXMuc3RhdGUuY2FsbFN0YWNrLmNhbGxTdGFja1RyYWNlKX10aGlzLnN0YXRlLlBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhpKSx0aGlzLkNob29zZVBhdGgobmV3IGUodCkpfUlmQXN5bmNXZUNhbnQodCl7aWYodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBcIit0K1wiLiBTdG9yeSBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgQ29udGludWVBc3luYygpLiBNYWtlIG1vcmUgQ29udGludWVBc3luYygpIGNhbGxzIG9yIGEgc2luZ2xlIENvbnRpbnVlKCkgY2FsbCBiZWZvcmVoYW5kLlwiKX1DaG9vc2VQYXRoKHQsZT0hMCl7dGhpcy5zdGF0ZS5TZXRDaG9zZW5QYXRoKHQsZSksdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKX1DaG9vc2VDaG9pY2VJbmRleCh0KXt0PXQ7bGV0IGU9dGhpcy5jdXJyZW50Q2hvaWNlczt0aGlzLkFzc2VydCh0Pj0wJiZ0PGUubGVuZ3RoLFwiY2hvaWNlIG91dCBvZiByYW5nZVwiKTtsZXQgbj1lW3RdO3JldHVybiBudWxsPT09bi50aHJlYWRBdEdlbmVyYXRpb24/ZChcImNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvblwiKTpudWxsPT09bi50YXJnZXRQYXRoP2QoXCJjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoXCIpOih0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkPW4udGhyZWFkQXRHZW5lcmF0aW9uLHZvaWQgdGhpcy5DaG9vc2VQYXRoKG4udGFyZ2V0UGF0aCkpfUhhc0Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gbnVsbCE9dGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUodCl9Y2F0Y2godCl7cmV0dXJuITF9fUV2YWx1YXRlRnVuY3Rpb24odCxlPVtdLG49ITEpe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcImV2YWx1YXRlIGEgZnVuY3Rpb25cIiksbnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBudWxsXCIpO2lmKFwiXCI9PXR8fFwiXCI9PXQudHJpbSgpKXRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlzIGVtcHR5IG9yIHdoaXRlIHNwYWNlLlwiKTtsZXQgaT10aGlzLktub3RDb250YWluZXJXaXRoTmFtZSh0KTtpZihudWxsPT1pKXRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3Q6ICdcIit0K1wiJ1wiKTtsZXQgcj1bXTtyLnB1c2guYXBwbHkocix0aGlzLnN0YXRlLm91dHB1dFN0cmVhbSksdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKSx0aGlzLnN0YXRlLlN0YXJ0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoaSxlKTtsZXQgYT1uZXcgbTtmb3IoO3RoaXMuY2FuQ29udGludWU7KWEuQXBwZW5kKHRoaXMuQ29udGludWUoKSk7bGV0IHM9YS50b1N0cmluZygpO3RoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KHIpO2xldCBsPXRoaXMuc3RhdGUuQ29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpO3JldHVybiBuP3tyZXR1cm5lZDpsLG91dHB1dDpzfTpsfUV2YWx1YXRlRXhwcmVzc2lvbih0KXtsZXQgZT10aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGg7dGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChyLlR1bm5lbCksdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcj10LHRoaXMuc3RhdGUuR29Ub1N0YXJ0KCk7bGV0IG49dGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoO3JldHVybiB0aGlzLkNvbnRpbnVlKCksdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcj1udWxsLHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aD5lJiZ0aGlzLnN0YXRlLlBvcENhbGxTdGFjaygpLHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aD5uP3RoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk6bnVsbH1DYWxsRXh0ZXJuYWxGdW5jdGlvbih0LGUpe2lmKG51bGw9PT10KXJldHVybiBkKFwiZnVuY05hbWVcIik7bGV0IG49dGhpcy5fZXh0ZXJuYWxzLmdldCh0KSxpPW51bGw7aWYoISh2b2lkIDAhPT1uKSl7aWYodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MpcmV0dXJuIGk9dGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUodCksdGhpcy5Bc3NlcnQobnVsbCE9PWksXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIrdCtcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kLCBhbmQgZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGNvdWxkIG5vdCBiZSBmb3VuZC5cIiksdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChyLkZ1bmN0aW9uLHZvaWQgMCx0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgpLHZvaWQodGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXI9SS5TdGFydE9mKGkpKTt0aGlzLkFzc2VydCghMSxcIlRyeWluZyB0byBjYWxsIEVYVEVSTkFMIGZ1bmN0aW9uICdcIit0K1wiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQgKGFuZCBpbmsgZmFsbGJhY2tzIGRpc2FibGVkKS5cIil9bGV0IGE9W107Zm9yKGxldCB0PTA7dDxlOysrdCl7bGV0IHQ9cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLHYpLnZhbHVlT2JqZWN0O2EucHVzaCh0KX1hLnJldmVyc2UoKTtsZXQgbD1uKGEpLG89bnVsbDtudWxsIT1sPyhvPXYuQ3JlYXRlKGwpLHRoaXMuQXNzZXJ0KG51bGwhPT1vLFwiQ291bGQgbm90IGNyZWF0ZSBpbmsgdmFsdWUgZnJvbSByZXR1cm5lZCBvYmplY3Qgb2YgdHlwZSBcIit0eXBlb2YgbCkpOm89bmV3IEwsdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG8pfUJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbCh0LGUpe3RoaXMuSWZBc3luY1dlQ2FudChcImJpbmQgYW4gZXh0ZXJuYWwgZnVuY3Rpb25cIiksdGhpcy5Bc3NlcnQoIXRoaXMuX2V4dGVybmFscy5oYXModCksXCJGdW5jdGlvbiAnXCIrdCtcIicgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cIiksdGhpcy5fZXh0ZXJuYWxzLnNldCh0LGUpfVRyeUNvZXJjZSh0KXtyZXR1cm4gdH1CaW5kRXh0ZXJuYWxGdW5jdGlvbih0LGUpe3RoaXMuQXNzZXJ0KG51bGwhPWUsXCJDYW4ndCBiaW5kIGEgbnVsbCBmdW5jdGlvblwiKSx0aGlzLkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbCh0LHQ9Pnt0aGlzLkFzc2VydCh0Lmxlbmd0aD49ZS5sZW5ndGgsXCJFeHRlcm5hbCBmdW5jdGlvbiBleHBlY3RlZCBcIitlLmxlbmd0aCtcIiBhcmd1bWVudHNcIik7bGV0IG49W107Zm9yKGxldCBlPTAsaT10Lmxlbmd0aDtlPGk7ZSsrKW5bZV09dGhpcy5UcnlDb2VyY2UodFtlXSk7cmV0dXJuIGUuYXBwbHkobnVsbCxuKX0pfVVuYmluZEV4dGVybmFsRnVuY3Rpb24odCl7dGhpcy5JZkFzeW5jV2VDYW50KFwidW5iaW5kIGFuIGV4dGVybmFsIGEgZnVuY3Rpb25cIiksdGhpcy5Bc3NlcnQodGhpcy5fZXh0ZXJuYWxzLmhhcyh0KSxcIkZ1bmN0aW9uICdcIit0K1wiJyBoYXMgbm90IGJlZW4gYm91bmQuXCIpLHRoaXMuX2V4dGVybmFscy5kZWxldGUodCl9VmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKCl7bGV0IHQ9bnVsbCxlPW51bGwsbj1hcmd1bWVudHNbMV18fG5ldyBTZXQ7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOJiYodD1hcmd1bWVudHNbMF0pLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcCYmKGU9YXJndW1lbnRzWzBdKSxudWxsPT09dCYmbnVsbD09PWUpaWYodGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3ModGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIsbiksdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzPSEwLDA9PW4uc2l6ZSl0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHM9ITA7ZWxzZXtsZXQgdD1cIkVycm9yOiBNaXNzaW5nIGZ1bmN0aW9uIGJpbmRpbmcgZm9yIGV4dGVybmFsXCI7dCs9bi5zaXplPjE/XCJzXCI6XCJcIix0Kz1cIjogJ1wiLHQrPUFycmF5LmZyb20obikuam9pbihcIicsICdcIiksdCs9XCInIFwiLHQrPXRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzP1wiLCBhbmQgbm8gZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGZvdW5kLlwiOlwiIChpbmsgZmFsbGJhY2tzIGRpc2FibGVkKVwiLHRoaXMuRXJyb3IodCl9ZWxzZSBpZihudWxsIT10KXtmb3IobGV0IGUgb2YgdC5jb250ZW50KXtsZXQgdD1lO251bGwhPXQmJnQuaGFzVmFsaWROYW1lfHx0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyhlLG4pfWZvcihsZXRbLGVdb2YgdC5uYW1lZENvbnRlbnQpdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoYShlLHApLG4pfWVsc2UgaWYobnVsbCE9ZSl7bGV0IHQ9YShlLGspO2lmKHQmJnQuaXNFeHRlcm5hbCl7bGV0IGU9dC50YXJnZXRQYXRoU3RyaW5nO2lmKG51bGw9PT1lKXJldHVybiBkKFwibmFtZVwiKTtpZighdGhpcy5fZXh0ZXJuYWxzLmhhcyhlKSlpZih0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcyl7dGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuaGFzKGUpfHxuLmFkZChlKX1lbHNlIG4uYWRkKGUpfX19T2JzZXJ2ZVZhcmlhYmxlKHQsZSl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwib2JzZXJ2ZSBhIG5ldyB2YXJpYWJsZVwiKSxudWxsPT09dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMmJih0aGlzLl92YXJpYWJsZU9ic2VydmVycz1uZXcgTWFwKSwhdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHQpKXRocm93IG5ldyBTKFwiQ2Fubm90IG9ic2VydmUgdmFyaWFibGUgJ1wiK3QrXCInIGJlY2F1c2UgaXQgd2Fzbid0IGRlY2xhcmVkIGluIHRoZSBpbmsgc3RvcnkuXCIpO3RoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyh0KT90aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodCkucHVzaChlKTp0aGlzLl92YXJpYWJsZU9ic2VydmVycy5zZXQodCxbZV0pfU9ic2VydmVWYXJpYWJsZXModCxlKXtmb3IobGV0IG49MCxpPXQubGVuZ3RoO248aTtuKyspdGhpcy5PYnNlcnZlVmFyaWFibGUodFtuXSxlW25dKX1SZW1vdmVWYXJpYWJsZU9ic2VydmVyKHQsZSl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwicmVtb3ZlIGEgdmFyaWFibGUgb2JzZXJ2ZXJcIiksbnVsbCE9PXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzKWlmKHZvaWQgMCE9PWUpe2lmKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyhlKSl7bGV0IG49dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KGUpO251bGwhPT10P24uc3BsaWNlKG4uaW5kZXhPZih0KSwxKTp0aGlzLl92YXJpYWJsZU9ic2VydmVycy5kZWxldGUoZSl9fWVsc2UgaWYobnVsbCE9PXQpe2xldCBlPXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmtleXMoKTtmb3IobGV0IG4gb2YgZSl7bGV0IGU9dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KG4pO2Uuc3BsaWNlKGUuaW5kZXhPZih0KSwxKX19fVZhcmlhYmxlU3RhdGVEaWRDaGFuZ2VFdmVudCh0LGUpe2lmKG51bGw9PT10aGlzLl92YXJpYWJsZU9ic2VydmVycylyZXR1cm47bGV0IG49dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHQpO2lmKHZvaWQgMCE9PW4pe2lmKCEoZSBpbnN0YW5jZW9mIHYpKXRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGdldCB0aGUgdmFsdWUgb2YgYSB2YXJpYWJsZSB0aGF0IGlzbid0IGEgc3RhbmRhcmQgdHlwZVwiKTtsZXQgaT1zKGUsdik7Zm9yKGxldCBlIG9mIG4pZSh0LGkudmFsdWVPYmplY3QpfX1nZXQgZ2xvYmFsVGFncygpe3JldHVybiB0aGlzLlRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcoXCJcIil9VGFnc0ZvckNvbnRlbnRBdFBhdGgodCl7cmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyh0KX1UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHQpe2xldCBuPW5ldyBlKHQpLGk9dGhpcy5Db250ZW50QXRQYXRoKG4pLmNvbnRhaW5lcjtpZihudWxsPT09aSlyZXR1cm4gZChcImZsb3dDb250YWluZXJcIik7Zm9yKDs7KXtsZXQgdD1pLmNvbnRlbnRbMF07aWYoISh0IGluc3RhbmNlb2YgTikpYnJlYWs7aT10fWxldCByPW51bGw7Zm9yKGxldCB0IG9mIGkuY29udGVudCl7bGV0IGU9YSh0LGopO2lmKCFlKWJyZWFrO251bGw9PXImJihyPVtdKSxyLnB1c2goZS50ZXh0KX1yZXR1cm4gcn1CdWlsZFN0cmluZ09mSGllcmFyY2h5KCl7bGV0IHQ9bmV3IG07cmV0dXJuIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSh0LDAsdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpLHQudG9TdHJpbmcoKX1CdWlsZFN0cmluZ09mQ29udGFpbmVyKHQpe2xldCBlPW5ldyBtO3JldHVybiB0LkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoZSwwLHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuUmVzb2x2ZSgpKSxlLnRvU3RyaW5nKCl9TmV4dENvbnRlbnQoKXtpZih0aGlzLnN0YXRlLnByZXZpb3VzUG9pbnRlcj10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKSwhdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsJiYodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcj10aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5jb3B5KCksdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXI9SS5OdWxsLHRoaXMuVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCksIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSlyZXR1cm47aWYoIXRoaXMuSW5jcmVtZW50Q29udGVudFBvaW50ZXIoKSl7bGV0IHQ9ITE7dGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKHIuRnVuY3Rpb24pPyh0aGlzLnN0YXRlLlBvcENhbGxTdGFjayhyLkZ1bmN0aW9uKSx0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24mJnRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgTCksdD0hMCk6dGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkPyh0aGlzLnN0YXRlLmNhbGxTdGFjay5Qb3BUaHJlYWQoKSx0PSEwKTp0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpLHQmJiF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCYmdGhpcy5OZXh0Q29udGVudCgpfX1JbmNyZW1lbnRDb250ZW50UG9pbnRlcigpe2xldCB0PSEwLGU9dGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29weSgpO2lmKGUuaW5kZXgrKyxudWxsPT09ZS5jb250YWluZXIpcmV0dXJuIGQoXCJwb2ludGVyLmNvbnRhaW5lclwiKTtmb3IoO2UuaW5kZXg+PWUuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoOyl7dD0hMTtsZXQgbj1hKGUuY29udGFpbmVyLnBhcmVudCxOKTtpZihuIGluc3RhbmNlb2YgTj09ITEpYnJlYWs7bGV0IGk9bi5jb250ZW50LmluZGV4T2YoZS5jb250YWluZXIpO2lmKC0xPT1pKWJyZWFrO2lmKGU9bmV3IEkobixpKSxlLmluZGV4KyssdD0hMCxudWxsPT09ZS5jb250YWluZXIpcmV0dXJuIGQoXCJwb2ludGVyLmNvbnRhaW5lclwiKX1yZXR1cm4gdHx8KGU9SS5OdWxsKSx0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlcj1lLmNvcHkoKSx0fVRyeUZvbGxvd0RlZmF1bHRJbnZpc2libGVDaG9pY2UoKXtsZXQgdD10aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcyxlPXQuZmlsdGVyKHQ9PnQuaXNJbnZpc2libGVEZWZhdWx0KTtpZigwPT1lLmxlbmd0aHx8dC5sZW5ndGg+ZS5sZW5ndGgpcmV0dXJuITE7bGV0IG49ZVswXTtyZXR1cm4gbnVsbD09PW4udGFyZ2V0UGF0aD9kKFwiY2hvaWNlLnRhcmdldFBhdGhcIik6bnVsbD09PW4udGhyZWFkQXRHZW5lcmF0aW9uP2QoXCJjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpOih0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkPW4udGhyZWFkQXRHZW5lcmF0aW9uLHRoaXMuQ2hvb3NlUGF0aChuLnRhcmdldFBhdGgsITEpLCEwKX1OZXh0U2VxdWVuY2VTaHVmZmxlSW5kZXgoKXtsZXQgdD1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYik7aWYoISh0IGluc3RhbmNlb2YgYikpcmV0dXJuIHRoaXMuRXJyb3IoXCJleHBlY3RlZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gc2VxdWVuY2UgZm9yIHNodWZmbGUgaW5kZXhcIiksMDtsZXQgZT10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcjtpZihudWxsPT09ZSlyZXR1cm4gZChcInNlcUNvbnRhaW5lclwiKTtpZihudWxsPT09dC52YWx1ZSlyZXR1cm4gZChcIm51bUVsZW1lbnRzSW50VmFsLnZhbHVlXCIpO2xldCBuPXQudmFsdWUsaT1zKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYikudmFsdWU7aWYobnVsbD09PWkpcmV0dXJuIGQoXCJzZXFDb3VudFwiKTtsZXQgcj1pL24sbD1pJW4sbz1lLnBhdGgudG9TdHJpbmcoKSx1PTA7Zm9yKGxldCB0PTAsZT1vLmxlbmd0aDt0PGU7dCsrKXUrPW8uY2hhckNvZGVBdCh0KXx8MDtsZXQgaD11K3IrdGhpcy5zdGF0ZS5zdG9yeVNlZWQsYz1uZXcgSyhNYXRoLmZsb29yKGgpKSxwPVtdO2ZvcihsZXQgdD0wO3Q8bjsrK3QpcC5wdXNoKHQpO2ZvcihsZXQgdD0wO3Q8PWw7Kyt0KXtsZXQgZT1jLm5leHQoKSVwLmxlbmd0aCxuPXBbZV07aWYocC5zcGxpY2UoZSwxKSx0PT1sKXJldHVybiBufXRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIpfUVycm9yKHQsZT0hMSl7bGV0IG49bmV3IFModCk7dGhyb3cgbi51c2VFbmRMaW5lTnVtYmVyPWUsbn1XYXJuaW5nKHQpe3RoaXMuQWRkRXJyb3IodCwhMCl9QWRkRXJyb3IodCxlPSExLG49ITEpe2xldCBpPXRoaXMuY3VycmVudERlYnVnTWV0YWRhdGEscj1lP1wiV0FSTklOR1wiOlwiRVJST1JcIjtpZihudWxsIT1pKXtsZXQgZT1uP2kuZW5kTGluZU51bWJlcjppLnN0YXJ0TGluZU51bWJlcjt0PVwiUlVOVElNRSBcIityK1wiOiAnXCIraS5maWxlTmFtZStcIicgbGluZSBcIitlK1wiOiBcIit0fWVsc2UgdD10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbD9cIlJVTlRJTUUgXCIrcitcIjogXCIrdDpcIlJVTlRJTUUgXCIrcitcIjogKFwiK3RoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIrXCIpOiBcIit0O3RoaXMuc3RhdGUuQWRkRXJyb3IodCxlKSxlfHx0aGlzLnN0YXRlLkZvcmNlRW5kKCl9QXNzZXJ0KHQsZT1udWxsKXtpZigwPT10KXRocm93IG51bGw9PWUmJihlPVwiU3RvcnkgYXNzZXJ0XCIpLG5ldyBFcnJvcihlK1wiIFwiK3RoaXMuY3VycmVudERlYnVnTWV0YWRhdGEpfWdldCBjdXJyZW50RGVidWdNZXRhZGF0YSgpe2xldCB0LGU9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcjtpZighZS5pc051bGwmJm51bGwhPT1lLlJlc29sdmUoKSYmKHQ9ZS5SZXNvbHZlKCkuZGVidWdNZXRhZGF0YSxudWxsIT09dCkpcmV0dXJuIHQ7Zm9yKGxldCBuPXRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aC0xO24+PTA7LS1uKWlmKGU9dGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHNbbl0uY3VycmVudFBvaW50ZXIsIWUuaXNOdWxsJiZudWxsIT09ZS5SZXNvbHZlKCkmJih0PWUuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGEsbnVsbCE9PXQpKXJldHVybiB0O2ZvcihsZXQgZT10aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgtMTtlPj0wOy0tZSl7aWYodD10aGlzLnN0YXRlLm91dHB1dFN0cmVhbVtlXS5kZWJ1Z01ldGFkYXRhLG51bGwhPT10KXJldHVybiB0fXJldHVybiBudWxsfWdldCBtYWluQ29udGVudENvbnRhaW5lcigpe3JldHVybiB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyP3RoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI6dGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXJ9fVguaW5rVmVyc2lvbkN1cnJlbnQ9MTksZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5Ob0NoYW5nZT0wXT1cIk5vQ2hhbmdlXCIsdFt0LkV4dGVuZGVkQmV5b25kTmV3bGluZT0xXT1cIkV4dGVuZGVkQmV5b25kTmV3bGluZVwiLHRbdC5OZXdsaW5lUmVtb3ZlZD0yXT1cIk5ld2xpbmVSZW1vdmVkXCJ9KGU9dC5PdXRwdXRTdGF0ZUNoYW5nZXx8KHQuT3V0cHV0U3RhdGVDaGFuZ2U9e30pKX0oWHx8KFg9e30pKSx0Lklua0xpc3Q9Zyx0LlN0b3J5PVgsT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmstZXMyMDE1LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbGxTdGFjayA9IHZvaWQgMDtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgU3RvcnlfMSA9IHJlcXVpcmUoXCIuL1N0b3J5XCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBDYWxsU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgU3RvcnlfMS5TdG9yeSkge1xuICAgICAgICAgICAgbGV0IHN0b3J5Q29udGV4dCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihzdG9yeUNvbnRleHQucm9vdENvbnRlbnRDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5SZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvQ29weSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuX3RocmVhZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IG90aGVyVGhyZWFkIG9mIHRvQ29weS5fdGhyZWFkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RocmVhZHMucHVzaChvdGhlclRocmVhZC5Db3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IHRvQ29weS5fdGhyZWFkQ291bnRlcjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gdG9Db3B5Ll9zdGFydE9mUm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjaztcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RWxlbWVudCgpIHtcbiAgICAgICAgbGV0IHRocmVhZCA9IHRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IGNzID0gdGhyZWFkLmNhbGxzdGFjaztcbiAgICAgICAgcmV0dXJuIGNzW2NzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVsZW1lbnRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGhyZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyZWFkc1t0aGlzLl90aHJlYWRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFRocmVhZCh2YWx1ZSkge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydCh0aGlzLl90aHJlYWRzLmxlbmd0aCA9PSAxLCBcIlNob3VsZG4ndCBiZSBkaXJlY3RseSBzZXR0aW5nIHRoZSBjdXJyZW50IHRocmVhZCB3aGVuIHdlIGhhdmUgYSBzdGFjayBvZiB0aGVtXCIpO1xuICAgICAgICB0aGlzLl90aHJlYWRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3RocmVhZHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBjYW5Qb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGggPiAxO1xuICAgIH1cbiAgICBSZXNldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkcyA9IFtdO1xuICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2gobmV3IENhbGxTdGFjay5UaHJlYWQoKSk7XG4gICAgICAgIHRoaXMuX3RocmVhZHNbMF0uY2FsbHN0YWNrLnB1c2gobmV3IENhbGxTdGFjay5FbGVtZW50KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwsIHRoaXMuX3N0YXJ0T2ZSb290KSk7XG4gICAgfVxuICAgIFNldEpzb25Ub2tlbihqT2JqZWN0LCBzdG9yeUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBUT0RPOiAoTGlzdDxvYmplY3Q+KSBqT2JqZWN0IFtcInRocmVhZHNcIl07XG4gICAgICAgIGxldCBqVGhyZWFkcyA9IGpPYmplY3RbXCJ0aHJlYWRzXCJdO1xuICAgICAgICBmb3IgKGxldCBqVGhyZWFkVG9rIG9mIGpUaHJlYWRzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB2YXIgalRocmVhZE9iaiA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0PilqVGhyZWFkVG9rO1xuICAgICAgICAgICAgbGV0IGpUaHJlYWRPYmogPSBqVGhyZWFkVG9rO1xuICAgICAgICAgICAgbGV0IHRocmVhZCA9IG5ldyBDYWxsU3RhY2suVGhyZWFkKGpUaHJlYWRPYmosIHN0b3J5Q29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2godGhyZWFkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiAoaW50KWpPYmplY3QgW1widGhyZWFkQ291bnRlclwiXTtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IHBhcnNlSW50KGpPYmplY3RbXCJ0aHJlYWRDb3VudGVyXCJdKTtcbiAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHN0b3J5Q29udGV4dC5yb290Q29udGVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIFdyaXRlSnNvbih3KSB7XG4gICAgICAgIHcuV3JpdGVPYmplY3QoKHdyaXRlcikgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZHNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0aHJlYWQgb2YgdGhpcy5fdGhyZWFkcykge1xuICAgICAgICAgICAgICAgIHRocmVhZC5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZENvdW50ZXJcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnQodGhpcy5fdGhyZWFkQ291bnRlcik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgUHVzaFRocmVhZCgpIHtcbiAgICAgICAgbGV0IG5ld1RocmVhZCA9IHRoaXMuY3VycmVudFRocmVhZC5Db3B5KCk7XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIrKztcbiAgICAgICAgbmV3VGhyZWFkLnRocmVhZEluZGV4ID0gdGhpcy5fdGhyZWFkQ291bnRlcjtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKG5ld1RocmVhZCk7XG4gICAgfVxuICAgIEZvcmtUaHJlYWQoKSB7XG4gICAgICAgIGxldCBmb3JrZWRUaHJlYWQgPSB0aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyKys7XG4gICAgICAgIGZvcmtlZFRocmVhZC50aHJlYWRJbmRleCA9IHRoaXMuX3RocmVhZENvdW50ZXI7XG4gICAgICAgIHJldHVybiBmb3JrZWRUaHJlYWQ7XG4gICAgfVxuICAgIFBvcFRocmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUG9wVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzLnNwbGljZSh0aGlzLl90aHJlYWRzLmluZGV4T2YodGhpcy5jdXJyZW50VGhyZWFkKSwgMSk7IC8vIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIGEgcG9wKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBvcCB0aHJlYWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhblBvcFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVhZHMubGVuZ3RoID4gMSAmJiAhdGhpcy5lbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWU7XG4gICAgfVxuICAgIFB1c2godHlwZSwgZXh0ZXJuYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQgPSAwLCBvdXRwdXRTdHJlYW1MZW5ndGhXaXRoUHVzaGVkID0gMCkge1xuICAgICAgICBsZXQgZWxlbWVudCA9IG5ldyBDYWxsU3RhY2suRWxlbWVudCh0eXBlLCB0aGlzLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IGV4dGVybmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0O1xuICAgICAgICBlbGVtZW50LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IG91dHB1dFN0cmVhbUxlbmd0aFdpdGhQdXNoZWQ7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIENhblBvcCh0eXBlID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUG9wKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gdHlwZTtcbiAgICB9XG4gICAgUG9wKHR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLkNhblBvcCh0eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHB1c2gvcG9wIGluIENhbGxzdGFja1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHZXRUZW1wb3JhcnlWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICBsZXQgY29udGV4dEVsZW1lbnQgPSB0aGlzLmNhbGxTdGFja1tjb250ZXh0SW5kZXggLSAxXTtcbiAgICAgICAgbGV0IHZhclZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgIGlmICh2YXJWYWx1ZS5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTZXRUZW1wb3JhcnlWYXJpYWJsZShuYW1lLCB2YWx1ZSwgZGVjbGFyZU5ldywgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IHRoaXMuY3VycmVudEVsZW1lbnRJbmRleCArIDE7XG4gICAgICAgIGxldCBjb250ZXh0RWxlbWVudCA9IHRoaXMuY2FsbFN0YWNrW2NvbnRleHRJbmRleCAtIDFdO1xuICAgICAgICBpZiAoIWRlY2xhcmVOZXcgJiYgIWNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ291bGQgbm90IGZpbmQgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIHNldDogXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAoY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgIFZhbHVlXzEuTGlzdFZhbHVlLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZS5yZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIENvbnRleHRGb3JWYXJpYWJsZU5hbWVkKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLmdldChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUaHJlYWRXaXRoSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gdGhpcy5fdGhyZWFkcy5maWx0ZXIoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0LnRocmVhZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjYWxsU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaHJlYWQuY2FsbHN0YWNrO1xuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrVHJhY2UoKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuX3RocmVhZHMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aHJlYWQgPSB0aGlzLl90aHJlYWRzW3RdO1xuICAgICAgICAgICAgbGV0IGlzQ3VycmVudCA9IHQgPT0gdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgc2IuQXBwZW5kRm9ybWF0KFwiPT09IFRIUkVBRCB7MH0vezF9IHsyfT09PVxcblwiLCB0ICsgMSwgdGhpcy5fdGhyZWFkcy5sZW5ndGgsIGlzQ3VycmVudCA/IFwiKGN1cnJlbnQpIFwiIDogXCJcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRocmVhZC5jYWxsc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyZWFkLmNhbGxzdGFja1tpXS50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiICBbRlVOQ1RJT05dIFwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgW1RVTk5FTF0gXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhyZWFkLmNhbGxzdGFja1tpXS5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIjxTT01FV0hFUkUgSU4gXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKHBvaW50ZXIuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoXCI+XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxTdGFjayA9IENhbGxTdGFjaztcbihmdW5jdGlvbiAoQ2FsbFN0YWNrKSB7XG4gICAgY2xhc3MgRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBvaW50ZXIsIGluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBwb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGluRXhwcmVzc2lvbkV2YWx1YXRpb247XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgQ29weSgpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IEVsZW1lbnQodGhpcy50eXBlLCB0aGlzLmN1cnJlbnRQb2ludGVyLCB0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pO1xuICAgICAgICAgICAgY29weS50ZW1wb3JhcnlWYXJpYWJsZXMgPSBuZXcgTWFwKHRoaXMudGVtcG9yYXJ5VmFyaWFibGVzKTtcbiAgICAgICAgICAgIGNvcHkuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IHRoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZDtcbiAgICAgICAgICAgIGNvcHkuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gdGhpcy5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsU3RhY2suRWxlbWVudCA9IEVsZW1lbnQ7XG4gICAgY2xhc3MgVGhyZWFkIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnRocmVhZEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2FsbHN0YWNrID0gW107XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgICAgICAgIGxldCBqVGhyZWFkT2JqID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBzdG9yeUNvbnRleHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogKGludCkgalRocmVhZE9ialsndGhyZWFkSW5kZXgnXSBjYW4gcmFpc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJlYWRJbmRleCA9IHBhcnNlSW50KGpUaHJlYWRPYmpbXCJ0aHJlYWRJbmRleFwiXSk7XG4gICAgICAgICAgICAgICAgbGV0IGpUaHJlYWRDYWxsc3RhY2sgPSBqVGhyZWFkT2JqW1wiY2FsbHN0YWNrXCJdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGpFbFRvayBvZiBqVGhyZWFkQ2FsbHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqRWxlbWVudE9iaiA9IGpFbFRvaztcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogKGludCkgakVsZW1lbnRPYmpbJ3R5cGUnXSBjYW4gcmFpc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwdXNoUG9wVHlwZSA9IHBhcnNlSW50KGpFbGVtZW50T2JqW1widHlwZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXJQYXRoU3RyO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBqRWxlbWVudE9iai5UcnlHZXRWYWx1ZSAoXCJjUGF0aFwiLCBvdXQgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuID0gakVsZW1lbnRPYmpbXCJjUGF0aFwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyUGF0aFN0ciA9IGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aHJlYWRQb2ludGVyUmVzdWx0ID0gc3RvcnlDb250ZXh0LkNvbnRlbnRBdFBhdGgobmV3IFBhdGhfMS5QYXRoKGN1cnJlbnRDb250YWluZXJQYXRoU3RyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmNvbnRhaW5lciA9IHRocmVhZFBvaW50ZXJSZXN1bHQuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5pbmRleCA9IHBhcnNlSW50KGpFbGVtZW50T2JqW1wiaWR4XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJlYWRQb2ludGVyUmVzdWx0Lm9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gbG9hZGluZyBzdGF0ZSwgaW50ZXJuYWwgc3RvcnkgbG9jYXRpb24gY291bGRuJ3QgYmUgZm91bmQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRocmVhZFBvaW50ZXJSZXN1bHQuYXBwcm94aW1hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcnlDb250ZXh0Lldhcm5pbmcoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGV4YWN0IGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyUGF0aFN0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0byAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicgdG8gcmVjb3Zlci4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9ICEhakVsZW1lbnRPYmpbXCJleHBcIl07XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IG5ldyBFbGVtZW50KHB1c2hQb3BUeXBlLCBwb2ludGVyLCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBzID0gakVsZW1lbnRPYmpbXCJ0ZW1wXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50ZW1wb3JhcnlWYXJpYWJsZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2Jqcyh0ZW1wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50ZW1wb3JhcnlWYXJpYWJsZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxzdGFjay5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHByZXZDb250ZW50T2JqUGF0aCA9IGpUaHJlYWRPYmpbXCJwcmV2aW91c0NvbnRlbnRPYmplY3RcIl07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2Q29udGVudE9ialBhdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHByZXZDb250ZW50T2JqUGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1BvaW50ZXIgPSBzdG9yeUNvbnRleHQuUG9pbnRlckF0UGF0aChwcmV2UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENvcHkoKSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBUaHJlYWQoKTtcbiAgICAgICAgICAgIGNvcHkudGhyZWFkSW5kZXggPSB0aGlzLnRocmVhZEluZGV4O1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0aGlzLmNhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgIGNvcHkuY2FsbHN0YWNrLnB1c2goZS5Db3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImNhbGxzdGFja1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuY2FsbHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuY3VycmVudFBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImNQYXRoXCIsIGVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlkeFwiLCBlbC5jdXJyZW50UG9pbnRlci5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiZXhwXCIsIGVsLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidHlwZVwiLCBlbC50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGVtcG9yYXJ5VmFyaWFibGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0ZW1wXCIpO1xuICAgICAgICAgICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHdyaXRlciwgZWwudGVtcG9yYXJ5VmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidGhyZWFkSW5kZXhcIiwgdGhpcy50aHJlYWRJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCByZXNvbHZlZFBvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUG9pbnRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMucHJldmlvdXNQb2ludGVyLlJlc29sdmUoKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJwcmV2aW91c0NvbnRlbnRPYmplY3RcIiwgcmVzb2x2ZWRQb2ludGVyLnBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsU3RhY2suVGhyZWFkID0gVGhyZWFkO1xufSkoQ2FsbFN0YWNrID0gZXhwb3J0cy5DYWxsU3RhY2sgfHwgKGV4cG9ydHMuQ2FsbFN0YWNrID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGxTdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hvaWNlID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIENob2ljZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRocmVhZEF0R2VuZXJhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlUGF0aCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxUaHJlYWRJbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBwYXRoU3RyaW5nT25DaG9pY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldFBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldCBwYXRoU3RyaW5nT25DaG9pY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkNob2ljZSA9IENob2ljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNob2ljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hvaWNlUG9pbnQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgQ2hvaWNlUG9pbnQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKG9uY2VPbmx5ID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wYXRoT25DaG9pY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N0YXJ0Q29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25jZU9ubHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gb25jZU9ubHk7XG4gICAgfVxuICAgIGdldCBwYXRoT25DaG9pY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoT25DaG9pY2UgIT0gbnVsbCAmJiB0aGlzLl9wYXRoT25DaG9pY2UuaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGNob2ljZVRhcmdldE9iaiA9IHRoaXMuY2hvaWNlVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGNob2ljZVRhcmdldE9iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGhPbkNob2ljZSA9IGNob2ljZVRhcmdldE9iai5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoT25DaG9pY2U7XG4gICAgfVxuICAgIHNldCBwYXRoT25DaG9pY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcGF0aE9uQ2hvaWNlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjaG9pY2VUYXJnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoT25DaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZVBvaW50Ll9wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzLlJlc29sdmVQYXRoKHRoaXMuX3BhdGhPbkNob2ljZSkuY29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoT25DaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZVBvaW50LnBhdGhPbkNob2ljZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoT25DaG9pY2UpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGF0aE9uQ2hvaWNlID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGZsYWdzKCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAwO1xuICAgICAgICBpZiAodGhpcy5oYXNDb25kaXRpb24pXG4gICAgICAgICAgICBmbGFncyB8PSAxO1xuICAgICAgICBpZiAodGhpcy5oYXNTdGFydENvbnRlbnQpXG4gICAgICAgICAgICBmbGFncyB8PSAyO1xuICAgICAgICBpZiAodGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudClcbiAgICAgICAgICAgIGZsYWdzIHw9IDQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW52aXNpYmxlRGVmYXVsdClcbiAgICAgICAgICAgIGZsYWdzIHw9IDg7XG4gICAgICAgIGlmICh0aGlzLm9uY2VPbmx5KVxuICAgICAgICAgICAgZmxhZ3MgfD0gMTY7XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG4gICAgc2V0IGZsYWdzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGFzQ29uZGl0aW9uID0gKHZhbHVlICYgMSkgPiAwO1xuICAgICAgICB0aGlzLmhhc1N0YXJ0Q29udGVudCA9ICh2YWx1ZSAmIDIpID4gMDtcbiAgICAgICAgdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudCA9ICh2YWx1ZSAmIDQpID4gMDtcbiAgICAgICAgdGhpcy5pc0ludmlzaWJsZURlZmF1bHQgPSAodmFsdWUgJiA4KSA+IDA7XG4gICAgICAgIHRoaXMub25jZU9ubHkgPSAodmFsdWUgJiAxNikgPiAwO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIC8vIGludD8gdGFyZ2V0TGluZU51bSA9IERlYnVnTGluZU51bWJlck9mUGF0aCAocGF0aE9uQ2hvaWNlKTtcbiAgICAgICAgbGV0IHRhcmdldExpbmVOdW0gPSBudWxsO1xuICAgICAgICBsZXQgdGFyZ2V0U3RyaW5nID0gdGhpcy5wYXRoT25DaG9pY2UudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRhcmdldExpbmVOdW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGFyZ2V0U3RyaW5nID0gXCIgbGluZSBcIiArIHRhcmdldExpbmVOdW0gKyBcIihcIiArIHRhcmdldFN0cmluZyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkNob2ljZTogLT4gXCIgKyB0YXJnZXRTdHJpbmc7XG4gICAgfVxufVxuZXhwb3J0cy5DaG9pY2VQb2ludCA9IENob2ljZVBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hvaWNlUG9pbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRhaW5lciA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBTZWFyY2hSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaFJlc3VsdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMubmFtZWRDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBoYXNWYWxpZE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgIT0gbnVsbCAmJiB0aGlzLm5hbWUubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICBzZXQgY29udGVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLkFkZENvbnRlbnQodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbmFtZWRPbmx5Q29udGVudCgpIHtcbiAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnREaWN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBpbmtPYmplY3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnREaWN0LnNldChrZXksIGlua09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBuYW1lZCA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwoYyk7XG4gICAgICAgICAgICBpZiAobmFtZWQgIT0gbnVsbCAmJiBuYW1lZC5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdC5kZWxldGUobmFtZWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVkT25seUNvbnRlbnREaWN0LnNpemUgPT0gMClcbiAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnREaWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5hbWVkT25seUNvbnRlbnREaWN0O1xuICAgIH1cbiAgICBzZXQgbmFtZWRPbmx5Q29udGVudCh2YWx1ZSkge1xuICAgICAgICBsZXQgZXhpc3RpbmdOYW1lZE9ubHkgPSB0aGlzLm5hbWVkT25seUNvbnRlbnQ7XG4gICAgICAgIGlmIChleGlzdGluZ05hbWVkT25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5XSBvZiBleGlzdGluZ05hbWVkT25seSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRDb250ZW50LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBbLCB2YWxdIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbmFtZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKHZhbCk7XG4gICAgICAgICAgICBpZiAobmFtZWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvdW50RmxhZ3MoKSB7XG4gICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgIGlmICh0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgIGZsYWdzIHw9IENvbnRhaW5lci5Db3VudEZsYWdzLlZpc2l0cztcbiAgICAgICAgaWYgKHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgZmxhZ3MgfD0gQ29udGFpbmVyLkNvdW50RmxhZ3MuVHVybnM7XG4gICAgICAgIGlmICh0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkpXG4gICAgICAgICAgICBmbGFncyB8PSBDb250YWluZXIuQ291bnRGbGFncy5Db3VudFN0YXJ0T25seTtcbiAgICAgICAgaWYgKGZsYWdzID09IENvbnRhaW5lci5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KSB7XG4gICAgICAgICAgICBmbGFncyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cbiAgICBzZXQgY291bnRGbGFncyh2YWx1ZSkge1xuICAgICAgICBsZXQgZmxhZyA9IHZhbHVlO1xuICAgICAgICBpZiAoKGZsYWcgJiBDb250YWluZXIuQ291bnRGbGFncy5WaXNpdHMpID4gMClcbiAgICAgICAgICAgIHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuVHVybnMpID4gMClcbiAgICAgICAgICAgIHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkpID4gMClcbiAgICAgICAgICAgIHRoaXMuY291bnRpbmdBdFN0YXJ0T25seSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBwYXRoVG9GaXJzdExlYWZDb250ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9IHRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKHRoaXMuaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBpbnRlcm5hbFBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQoKSB7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gW107XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY29udGFpbmVyIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KDApKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY29udGVudFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGhfMS5QYXRoKGNvbXBvbmVudHMpO1xuICAgIH1cbiAgICBBZGRDb250ZW50KGNvbnRlbnRPYmpPckxpc3QpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmpPckxpc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRMaXN0ID0gY29udGVudE9iak9yTGlzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29udGVudExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZENvbnRlbnQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudE9iaiA9IGNvbnRlbnRPYmpPckxpc3Q7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnB1c2goY29udGVudE9iaik7XG4gICAgICAgICAgICBpZiAoY29udGVudE9iai5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIgKyBjb250ZW50T2JqLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50T2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChjb250ZW50T2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaikge1xuICAgICAgICBsZXQgbmFtZWRDb250ZW50T2JqID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbChjb250ZW50T2JqKTtcbiAgICAgICAgaWYgKG5hbWVkQ29udGVudE9iaiAhPSBudWxsICYmIG5hbWVkQ29udGVudE9iai5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuQWRkVG9OYW1lZENvbnRlbnRPbmx5KG5hbWVkQ29udGVudE9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkVG9OYW1lZENvbnRlbnRPbmx5KG5hbWVkQ29udGVudE9iaikge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydFR5cGUobmFtZWRDb250ZW50T2JqLCBPYmplY3RfMS5JbmtPYmplY3QsIFwiQ2FuIG9ubHkgYWRkIFJ1bnRpbWUuT2JqZWN0cyB0byBhIFJ1bnRpbWUuQ29udGFpbmVyXCIpO1xuICAgICAgICBsZXQgcnVudGltZU9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG5hbWVkQ29udGVudE9iaiwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICAgICAgcnVudGltZU9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWVkQ29udGVudC5zZXQobmFtZWRDb250ZW50T2JqLm5hbWUsIG5hbWVkQ29udGVudE9iaik7XG4gICAgfVxuICAgIENvbnRlbnRBdFBhdGgocGF0aCwgcGFydGlhbFBhdGhTdGFydCA9IDAsIHBhcnRpYWxQYXRoTGVuZ3RoID0gLTEpIHtcbiAgICAgICAgaWYgKHBhcnRpYWxQYXRoTGVuZ3RoID09IC0xKVxuICAgICAgICAgICAgcGFydGlhbFBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTZWFyY2hSZXN1bHRfMS5TZWFyY2hSZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdGhpcztcbiAgICAgICAgbGV0IGN1cnJlbnRPYmogPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gcGFydGlhbFBhdGhTdGFydDsgaSA8IHBhcnRpYWxQYXRoTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjb21wID0gcGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZE9iaiA9IGN1cnJlbnRDb250YWluZXIuQ29udGVudFdpdGhQYXRoQ29tcG9uZW50KGNvbXApO1xuICAgICAgICAgICAgaWYgKGZvdW5kT2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwcm94aW1hdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE9iaiA9IGZvdW5kT2JqO1xuICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChmb3VuZE9iaiwgQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub2JqID0gY3VycmVudE9iajtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgSW5zZXJ0Q29udGVudChjb250ZW50T2JqLCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRbaW5kZXhdID0gY29udGVudE9iajtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmoucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIgKyBjb250ZW50T2JqLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudE9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChjb250ZW50T2JqKTtcbiAgICB9XG4gICAgQWRkQ29udGVudHNPZkNvbnRhaW5lcihvdGhlckNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuY29uY2F0KG90aGVyQ29udGFpbmVyLmNvbnRlbnQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2Ygb3RoZXJDb250YWluZXIuY29udGVudCkge1xuICAgICAgICAgICAgb2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnRlbnRXaXRoUGF0aENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmluZGV4ID49IDAgJiYgY29tcG9uZW50LmluZGV4IDwgdGhpcy5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbY29tcG9uZW50LmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5pc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb21wb25lbnQubmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZENvbnRlbnQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5uYW1lZENvbnRlbnQsIGNvbXBvbmVudC5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChmb3VuZENvbnRlbnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGZvdW5kQ29udGVudC5yZXN1bHQsIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBCdWlsZFN0cmluZ09mSGllcmFyY2h5KCkge1xuICAgICAgICBsZXQgc2I7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIDAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2IgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgbGV0IHBvaW50ZWRPYmogPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZEluZGVudGF0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VzUGVySW5kZW50ID0gNDsgLy8gVHJ1bHkgY29uc3QgaW4gdGhlIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhY2VzUGVySW5kZW50ICogaW5kZW50YXRpb247ICsraSkge1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgc2IuQXBwZW5kKFwiW1wiKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmRGb3JtYXQoXCIgKHswfSlcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBwb2ludGVkT2JqKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgIDwtLS1cIik7XG4gICAgICAgIH1cbiAgICAgICAgc2IuQXBwZW5kTGluZSgpO1xuICAgICAgICBpbmRlbnRhdGlvbisrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb2JqO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCBpbmRlbnRhdGlvbiwgcG9pbnRlZE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCgnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKG9iai50b1N0cmluZygpLnJlcGxhY2UoXCJcXG5cIiwgXCJcXFxcblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCgnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChvYmoudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ29udGFpbmVyKSAmJiBvYmogPT0gcG9pbnRlZE9iaikge1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgPC0tLVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25seU5hbWVkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaW5kZXhPZihUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25seU5hbWVkLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25seU5hbWVkLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgc2IuQXBwZW5kTGluZShcIi0tIG5hbWVkOiAtLVwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiBvbmx5TmFtZWQpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydFR5cGUodmFsdWUsIENvbnRhaW5lciwgXCJDYW4gb25seSBwcmludCBvdXQgbmFtZWQgQ29udGFpbmVyc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIGluZGVudGF0aW9uLCBwb2ludGVkT2JqKTtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmRMaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZW50YXRpb24tLTtcbiAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgc2IuQXBwZW5kKFwiXVwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcbihmdW5jdGlvbiAoQ29udGFpbmVyKSB7XG4gICAgbGV0IENvdW50RmxhZ3M7XG4gICAgKGZ1bmN0aW9uIChDb3VudEZsYWdzKSB7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIlZpc2l0c1wiXSA9IDFdID0gXCJWaXNpdHNcIjtcbiAgICAgICAgQ291bnRGbGFnc1tDb3VudEZsYWdzW1wiVHVybnNcIl0gPSAyXSA9IFwiVHVybnNcIjtcbiAgICAgICAgQ291bnRGbGFnc1tDb3VudEZsYWdzW1wiQ291bnRTdGFydE9ubHlcIl0gPSA0XSA9IFwiQ291bnRTdGFydE9ubHlcIjtcbiAgICB9KShDb3VudEZsYWdzID0gQ29udGFpbmVyLkNvdW50RmxhZ3MgfHwgKENvbnRhaW5lci5Db3VudEZsYWdzID0ge30pKTtcbn0pKENvbnRhaW5lciA9IGV4cG9ydHMuQ29udGFpbmVyIHx8IChleHBvcnRzLkNvbnRhaW5lciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyb2xDb21tYW5kID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBDb250cm9sQ29tbWFuZCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZFR5cGUgPSBDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob3RTZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29tbWFuZFR5cGUgPSBjb21tYW5kVHlwZTtcbiAgICB9XG4gICAgZ2V0IGNvbW1hbmRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZFR5cGU7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQodGhpcy5jb21tYW5kVHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0KTtcbiAgICB9XG4gICAgc3RhdGljIEV2YWxPdXRwdXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbE91dHB1dCk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsRW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmQpO1xuICAgIH1cbiAgICBzdGF0aWMgRHVwbGljYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BFdmFsdWF0ZWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BUdW5uZWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsKTtcbiAgICB9XG4gICAgc3RhdGljIEJlZ2luU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIEVuZFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRTdHJpbmcpO1xuICAgIH1cbiAgICBzdGF0aWMgTm9PcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob09wKTtcbiAgICB9XG4gICAgc3RhdGljIENob2ljZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50KTtcbiAgICB9XG4gICAgc3RhdGljIFR1cm5zKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zKTtcbiAgICB9XG4gICAgc3RhdGljIFR1cm5zU2luY2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSk7XG4gICAgfVxuICAgIHN0YXRpYyBSZWFkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50KTtcbiAgICB9XG4gICAgc3RhdGljIFJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SYW5kb20pO1xuICAgIH1cbiAgICBzdGF0aWMgU2VlZFJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZWVkUmFuZG9tKTtcbiAgICB9XG4gICAgc3RhdGljIFZpc2l0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTZXF1ZW5jZVNodWZmbGVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTdGFydFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZCk7XG4gICAgfVxuICAgIHN0YXRpYyBEb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgRW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0RnJvbUludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlKTtcbiAgICB9XG4gICAgc3RhdGljIExpc3RSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kVHlwZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJvbENvbW1hbmQgPSBDb250cm9sQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29udHJvbENvbW1hbmQpIHtcbiAgICBsZXQgQ29tbWFuZFR5cGU7XG4gICAgKGZ1bmN0aW9uIChDb21tYW5kVHlwZSkge1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIk5vdFNldFwiXSA9IC0xXSA9IFwiTm90U2V0XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRXZhbFN0YXJ0XCJdID0gMF0gPSBcIkV2YWxTdGFydFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxPdXRwdXRcIl0gPSAxXSA9IFwiRXZhbE91dHB1dFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxFbmRcIl0gPSAyXSA9IFwiRXZhbEVuZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkR1cGxpY2F0ZVwiXSA9IDNdID0gXCJEdXBsaWNhdGVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJQb3BFdmFsdWF0ZWRWYWx1ZVwiXSA9IDRdID0gXCJQb3BFdmFsdWF0ZWRWYWx1ZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlBvcEZ1bmN0aW9uXCJdID0gNV0gPSBcIlBvcEZ1bmN0aW9uXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUG9wVHVubmVsXCJdID0gNl0gPSBcIlBvcFR1bm5lbFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkJlZ2luU3RyaW5nXCJdID0gN10gPSBcIkJlZ2luU3RyaW5nXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRW5kU3RyaW5nXCJdID0gOF0gPSBcIkVuZFN0cmluZ1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIk5vT3BcIl0gPSA5XSA9IFwiTm9PcFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkNob2ljZUNvdW50XCJdID0gMTBdID0gXCJDaG9pY2VDb3VudFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlR1cm5zXCJdID0gMTFdID0gXCJUdXJuc1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlR1cm5zU2luY2VcIl0gPSAxMl0gPSBcIlR1cm5zU2luY2VcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJSYW5kb21cIl0gPSAxM10gPSBcIlJhbmRvbVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlNlZWRSYW5kb21cIl0gPSAxNF0gPSBcIlNlZWRSYW5kb21cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJWaXNpdEluZGV4XCJdID0gMTVdID0gXCJWaXNpdEluZGV4XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiU2VxdWVuY2VTaHVmZmxlSW5kZXhcIl0gPSAxNl0gPSBcIlNlcXVlbmNlU2h1ZmZsZUluZGV4XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiU3RhcnRUaHJlYWRcIl0gPSAxN10gPSBcIlN0YXJ0VGhyZWFkXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRG9uZVwiXSA9IDE4XSA9IFwiRG9uZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkVuZFwiXSA9IDE5XSA9IFwiRW5kXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdEZyb21JbnRcIl0gPSAyMF0gPSBcIkxpc3RGcm9tSW50XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdFJhbmdlXCJdID0gMjFdID0gXCJMaXN0UmFuZ2VcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJMaXN0UmFuZG9tXCJdID0gMjJdID0gXCJMaXN0UmFuZG9tXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUmVhZENvdW50XCJdID0gMjNdID0gXCJSZWFkQ291bnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUT1RBTF9WQUxVRVNcIl0gPSAyNF0gPSBcIlRPVEFMX1ZBTFVFU1wiO1xuICAgIH0pKENvbW1hbmRUeXBlID0gQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUgfHwgKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlID0ge30pKTtcbn0pKENvbnRyb2xDb21tYW5kID0gZXhwb3J0cy5Db250cm9sQ29tbWFuZCB8fCAoZXhwb3J0cy5Db250cm9sQ29tbWFuZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sQ29tbWFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVidWcgPSB2b2lkIDA7XG52YXIgRGVidWc7XG4oZnVuY3Rpb24gKERlYnVnKSB7XG4gICAgZnVuY3Rpb24gQXNzZXJ0VHlwZSh2YXJpYWJsZSwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBBc3NlcnQodmFyaWFibGUgaW5zdGFuY2VvZiB0eXBlLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgRGVidWcuQXNzZXJ0VHlwZSA9IEFzc2VydFR5cGU7XG4gICAgZnVuY3Rpb24gQXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVidWcuQXNzZXJ0ID0gQXNzZXJ0O1xufSkoRGVidWcgPSBleHBvcnRzLkRlYnVnIHx8IChleHBvcnRzLkRlYnVnID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlYnVnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXZlcnQgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBEaXZlcnQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrUHVzaFR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrUHVzaFR5cGUgPSAwO1xuICAgICAgICB0aGlzLmlzRXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEFyZ3MgPSAwO1xuICAgICAgICB0aGlzLmlzQ29uZGl0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoZXNUb1N0YWNrID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tQdXNoVHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5wdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tQdXNoVHlwZSA9IHN0YWNrUHVzaFR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoICE9IG51bGwgJiYgdGhpcy5fdGFyZ2V0UGF0aC5pc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0T2JqID0gdGhpcy50YXJnZXRQb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRPYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQYXRoID0gdGFyZ2V0T2JqLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBhdGg7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFBhdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgfVxuICAgIGdldCB0YXJnZXRQb2ludGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPYmogPSB0aGlzLlJlc29sdmVQYXRoKHRoaXMuX3RhcmdldFBhdGgpLm9iajtcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fdGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0T2JqID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRhcmdldE9ialwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyLmNvbnRhaW5lciA9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE9iai5wYXJlbnQgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIgPyB0YXJnZXRPYmoucGFyZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyLmluZGV4ID0gdGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YodGFyZ2V0T2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGFyZ2V0T2JqIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UGF0aFN0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMudGFyZ2V0UGF0aCk7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzVmFyaWFibGVUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSAhPSBudWxsO1xuICAgIH1cbiAgICBFcXVhbHMob2JqKSB7XG4gICAgICAgIGxldCBvdGhlckRpdmVydCA9IG9iajtcbiAgICAgICAgaWYgKG90aGVyRGl2ZXJ0IGluc3RhbmNlb2YgRGl2ZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCA9PSBvdGhlckRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSA9PSBvdGhlckRpdmVydC52YXJpYWJsZURpdmVydE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnRhcmdldFBhdGhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFBhdGguRXF1YWxzKG90aGVyRGl2ZXJ0LnRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRGl2ZXJ0KHZhcmlhYmxlOiBcIiArIHRoaXMudmFyaWFibGVEaXZlcnROYW1lICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXRQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkRpdmVydChudWxsKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0U3RyID0gdGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBpbnQ/IHRhcmdldExpbmVOdW0gPSBEZWJ1Z0xpbmVOdW1iZXJPZlBhdGggKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldExpbmVOdW0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRhcmdldExpbmVOdW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFN0ciA9IFwibGluZSBcIiArIHRhcmdldExpbmVOdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCJEaXZlcnRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbmRpdGlvbmFsKVxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIj9cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoZXNUb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIHR1bm5lbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgLT4gXCIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKHRoaXMudGFyZ2V0UGF0aFN0cmluZyk7XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgKFwiKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0YXJnZXRTdHIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EaXZlcnQgPSBEaXZlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdsdWUgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIEdsdWUgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJHbHVlXCI7XG4gICAgfVxufVxuZXhwb3J0cy5HbHVlID0gR2x1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklua0xpc3QgPSBleHBvcnRzLklua0xpc3RJdGVtID0gdm9pZCAwO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jbGFzcyBJbmtMaXN0SXRlbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIElua0xpc3RJdGVtIGlzIGEgc3RydWN0XG4gICAgICAgIHRoaXMub3JpZ2luTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlbU5hbWUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9yaWdpbk5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbk5hbWUgPSBvcmlnaW5OYW1lO1xuICAgICAgICAgICAgdGhpcy5pdGVtTmFtZSA9IGl0ZW1OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgbGV0IGZ1bGxOYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IG5hbWVQYXJ0cyA9IGZ1bGxOYW1lLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5OYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5pdGVtTmFtZSA9IG5hbWVQYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE51bGwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5rTGlzdEl0ZW0obnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGdldCBpc051bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbk5hbWUgPT0gbnVsbCAmJiB0aGlzLml0ZW1OYW1lID09IG51bGw7XG4gICAgfVxuICAgIGdldCBmdWxsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5vcmlnaW5OYW1lICE9PSBudWxsID8gdGhpcy5vcmlnaW5OYW1lIDogXCI/XCIpICsgXCIuXCIgKyB0aGlzLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bGxOYW1lO1xuICAgIH1cbiAgICBFcXVhbHMob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBJbmtMaXN0SXRlbSkge1xuICAgICAgICAgICAgbGV0IG90aGVySXRlbSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXJJdGVtLml0ZW1OYW1lID09IHRoaXMuaXRlbU5hbWUgJiZcbiAgICAgICAgICAgICAgICBvdGhlckl0ZW0ub3JpZ2luTmFtZSA9PSB0aGlzLm9yaWdpbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlc2UgbWV0aG9kcyBkaWQgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLiBUaGVpciBwdXJwb3NlIGlzIHRvXG4gICAgLy8gbWFrZSBgSW5rTGlzdEl0ZW1gIG1pbWljcyB0aGUgdmFsdWUtdHlwZSBzZW1hbnRpY3Mgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gc3RydWN0LiBQbGVhc2UgcmVmZXIgdG8gdGhlIGVuZCBvZiB0aGlzIGZpbGUsIGZvciBhIG1vcmUgaW4tZGVwdGhcbiAgICAvLyBleHBsYW5hdGlvbi5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKHRoaXMub3JpZ2luTmFtZSwgdGhpcy5pdGVtTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgU2VyaWFsaXplZElua0xpc3RJdGVtYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnRcbiAgICAgKiBpbnN0YW5jZS4gVGhlIHJlc3VsdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEga2V5IGluc2lkZSBhIE1hcC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVkKCkge1xuICAgICAgICAvLyBXZSBhcmUgc2ltcGx5IHVzaW5nIGEgSlNPTiByZXByZXNlbnRhdGlvbiBhcyBhIHZhbHVlLXR5cGVkIGtleS5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG9yaWdpbk5hbWU6IHRoaXMub3JpZ2luTmFtZSxcbiAgICAgICAgICAgIGl0ZW1OYW1lOiB0aGlzLml0ZW1OYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb25zdHJ1Y3RzIGEgYElua0xpc3RJdGVtYCBmcm9tIHRoZSBnaXZlbiBTZXJpYWxpemVkSW5rTGlzdEl0ZW0uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJpYWxpemVkS2V5KGtleSkge1xuICAgICAgICBsZXQgb2JqID0gSlNPTi5wYXJzZShrZXkpO1xuICAgICAgICBpZiAoIUlua0xpc3RJdGVtLmlzTGlrZUlua0xpc3RJdGVtKG9iaikpXG4gICAgICAgICAgICByZXR1cm4gSW5rTGlzdEl0ZW0uTnVsbDtcbiAgICAgICAgbGV0IGlua0xpc3RJdGVtID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKGlua0xpc3RJdGVtLm9yaWdpbk5hbWUsIGlua0xpc3RJdGVtLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBpdGVtIGlzIHN1ZmZpY2llbnRseSBgSW5rTGlzdEl0ZW1gLWxpa2VcbiAgICAgKiB0byBiZSB1c2VkIGFzIGEgdGVtcGxhdGUgd2hlbiByZWNvbnN0cnVjdGluZyB0aGUgSW5rTGlzdEl0ZW0uXG4gICAgICovXG4gICAgc3RhdGljIGlzTGlrZUlua0xpc3RJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWl0ZW0uaGFzT3duUHJvcGVydHkoXCJvcmlnaW5OYW1lXCIpIHx8ICFpdGVtLmhhc093blByb3BlcnR5KFwiaXRlbU5hbWVcIikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vcmlnaW5OYW1lICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtLm9yaWdpbk5hbWUgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5pdGVtTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbS5pdGVtTmFtZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbmtMaXN0SXRlbSA9IElua0xpc3RJdGVtO1xuY2xhc3MgSW5rTGlzdCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFRyeWluZyB0byBiZSBzbWFydCBoZXJlLCB0aGlzIGVtdWxhdGVzIHRoZSBjb25zdHJ1Y3RvciBpbmhlcml0YW5jZSBmb3VuZFxuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgY29kZSwgYnV0IG9ubHkgaWYgb3RoZXJMaXN0IGlzIGFuIElua0xpc3QuIElJRkUgRlRXLlxuICAgICAgICBzdXBlcigoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIElua0xpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKTtcbiAgICAgICAgdGhpcy5vcmlnaW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIElua0xpc3QpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckxpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpZiAob3RoZXJMaXN0Ll9vcmlnaW5OYW1lcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gb3RoZXJMaXN0Ll9vcmlnaW5OYW1lcy5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBzaW5nbGVPcmlnaW5MaXN0TmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5TdG9yeSA9IGFyZ3VtZW50c1sxXTsgLyogYXMgU3RvcnkgKi9cbiAgICAgICAgICAgIHRoaXMuU2V0SW5pdGlhbE9yaWdpbk5hbWUoc2luZ2xlT3JpZ2luTGlzdE5hbWUpO1xuICAgICAgICAgICAgbGV0IGRlZiA9IG9yaWdpblN0b3J5Lmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihzaW5nbGVPcmlnaW5MaXN0TmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoZGVmLmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2lucyA9IFtkZWYucmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklua0xpc3Qgb3JpZ2luIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBzdG9yeSB3aGVuIGNvbnN0cnVjdGluZyBuZXcgbGlzdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVPcmlnaW5MaXN0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiS2V5XCIpICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoXCJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgbGV0IHNpbmdsZUVsZW1lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLkFkZChzaW5nbGVFbGVtZW50LktleSwgc2luZ2xlRWxlbWVudC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkSXRlbShpdGVtT3JJdGVtTmFtZSkge1xuICAgICAgICBpZiAoaXRlbU9ySXRlbU5hbWUgaW5zdGFuY2VvZiBJbmtMaXN0SXRlbSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBpdGVtT3JJdGVtTmFtZTtcbiAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkSXRlbShpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBpdGVtLm9yaWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IG9yaWdpbi5UcnlHZXRWYWx1ZUZvckl0ZW0oaXRlbSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZChpdGVtLCBpbnRWYWwucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGxpc3QgZGVmaW5pdGlvbiBpbiBpbmsuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGFkZCBpdGVtIHRvIGxpc3QgYmVjYXVzZSB0aGUgaXRlbSB3YXMgZnJvbSBhIG5ldyBsaXN0IGRlZmluaXRpb24gdGhhdCB3YXNuJ3QgcHJldmlvdXNseSBrbm93biB0byB0aGlzIGxpc3QuIE9ubHkgaXRlbXMgZnJvbSBwcmV2aW91c2x5IGtub3duIGxpc3RzIGNhbiBiZSB1c2VkLCBzbyB0aGF0IHRoZSBpbnQgdmFsdWUgY2FuIGJlIGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpdGVtTmFtZSA9IGl0ZW1Pckl0ZW1OYW1lO1xuICAgICAgICAgICAgbGV0IGZvdW5kTGlzdERlZiA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtTmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLkNvbnRhaW5zSXRlbVdpdGhOYW1lKGl0ZW1OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1OYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBjb3VsZCBjb21lIGZyb20gZWl0aGVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4ubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGlzdERlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGlzdERlZiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZExpc3REZWYgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgaXRlbU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBpc24ndCBrbm93biB0byBhbnkgbGlzdCBkZWZpbml0aW9ucyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QuXCIpO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSW5rTGlzdEl0ZW0oZm91bmRMaXN0RGVmLm5hbWUsIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgIGxldCBpdGVtVmFsID0gZm91bmRMaXN0RGVmLlZhbHVlRm9ySXRlbShpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuQWRkKGl0ZW0sIGl0ZW1WYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbU5hbWVkKGl0ZW1OYW1lKSB7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09IGl0ZW1OYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ29udGFpbnNLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkuc2VyaWFsaXplZCgpKTtcbiAgICB9XG4gICAgQWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWRLZXkgPSBrZXkuc2VyaWFsaXplZCgpO1xuICAgICAgICBpZiAodGhpcy5oYXMoc2VyaWFsaXplZEtleSkpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiB0byBtYXRjaCB0aGUgQyMgYmVoYXZpb3IuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBNYXAgYWxyZWFkeSBjb250YWlucyBhbiBlbnRyeSBmb3IgJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoc2VyaWFsaXplZEtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBSZW1vdmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkuc2VyaWFsaXplZCgpKTtcbiAgICB9XG4gICAgZ2V0IENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luT2ZNYXhJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1heE9yaWdpbk5hbWUgPSB0aGlzLm1heEl0ZW0uS2V5Lm9yaWdpbk5hbWU7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbnMuZXZlcnkoKG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgaWYgKG9yaWdpbi5uYW1lID09IG1heE9yaWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IG9yaWdpbk5hbWVzKCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW5OYW1lcyA9PSBudWxsICYmIHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW107XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29yaWdpbk5hbWVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5XSBvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzLnB1c2goaXRlbS5vcmlnaW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luTmFtZXM7XG4gICAgfVxuICAgIFNldEluaXRpYWxPcmlnaW5OYW1lKGluaXRpYWxPcmlnaW5OYW1lKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW2luaXRpYWxPcmlnaW5OYW1lXTtcbiAgICB9XG4gICAgU2V0SW5pdGlhbE9yaWdpbk5hbWVzKGluaXRpYWxPcmlnaW5OYW1lcykge1xuICAgICAgICBpZiAoaW5pdGlhbE9yaWdpbk5hbWVzID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gaW5pdGlhbE9yaWdpbk5hbWVzLnNsaWNlKCk7IC8vIHN0b3JlIGEgY29weVxuICAgIH1cbiAgICBnZXQgbWF4SXRlbSgpIHtcbiAgICAgICAgbGV0IG1heCA9IHtcbiAgICAgICAgICAgIEtleTogSW5rTGlzdEl0ZW0uTnVsbCxcbiAgICAgICAgICAgIFZhbHVlOiAwLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsIHx8IHZhbHVlID4gbWF4LlZhbHVlKVxuICAgICAgICAgICAgICAgIG1heCA9IHsgS2V5OiBpdGVtLCBWYWx1ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgbWluSXRlbSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IHtcbiAgICAgICAgICAgIEtleTogSW5rTGlzdEl0ZW0uTnVsbCxcbiAgICAgICAgICAgIFZhbHVlOiAwLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKG1pbi5LZXkuaXNOdWxsIHx8IHZhbHVlIDwgbWluLlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWluID0geyBLZXk6IGl0ZW0sIFZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBpbnZlcnNlKCkge1xuICAgICAgICBsZXQgbGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvcmlnaW4uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuQ29udGFpbnNLZXkoaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LkFkZChpdGVtLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBnZXQgYWxsKCkge1xuICAgICAgICBsZXQgbGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvcmlnaW4uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNldChpdGVtLnNlcmlhbGl6ZWQoKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgVW5pb24ob3RoZXJMaXN0KSB7XG4gICAgICAgIGxldCB1bmlvbiA9IG5ldyBJbmtMaXN0KHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3RoZXJMaXN0KSB7XG4gICAgICAgICAgICB1bmlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaW9uO1xuICAgIH1cbiAgICBJbnRlcnNlY3Qob3RoZXJMaXN0KSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKG90aGVyTGlzdC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuICAgIFdpdGhvdXQobGlzdFRvUmVtb3ZlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW5rTGlzdCh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgbGlzdFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29udGFpbnMob3RoZXJMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIG90aGVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgR3JlYXRlclRoYW4ob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5taW5JdGVtLlZhbHVlID4gb3RoZXJMaXN0Lm1heEl0ZW0uVmFsdWU7XG4gICAgfVxuICAgIEdyZWF0ZXJUaGFuT3JFcXVhbHMob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRoaXMubWluSXRlbS5WYWx1ZSA+PSBvdGhlckxpc3QubWluSXRlbS5WYWx1ZSAmJlxuICAgICAgICAgICAgdGhpcy5tYXhJdGVtLlZhbHVlID49IG90aGVyTGlzdC5tYXhJdGVtLlZhbHVlKTtcbiAgICB9XG4gICAgTGVzc1RoYW4ob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhJdGVtLlZhbHVlIDwgb3RoZXJMaXN0Lm1pbkl0ZW0uVmFsdWU7XG4gICAgfVxuICAgIExlc3NUaGFuT3JFcXVhbHMob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4SXRlbS5WYWx1ZSA8PSBvdGhlckxpc3QubWF4SXRlbS5WYWx1ZSAmJlxuICAgICAgICAgICAgdGhpcy5taW5JdGVtLlZhbHVlIDw9IG90aGVyTGlzdC5taW5JdGVtLlZhbHVlKTtcbiAgICB9XG4gICAgTWF4QXNMaXN0KCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QodGhpcy5tYXhJdGVtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KCk7XG4gICAgfVxuICAgIE1pbkFzTGlzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KHRoaXMubWluSXRlbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgIH1cbiAgICBMaXN0V2l0aFN1YlJhbmdlKG1pbkJvdW5kLCBtYXhCb3VuZCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGxldCBvcmRlcmVkID0gdGhpcy5vcmRlcmVkSXRlbXM7XG4gICAgICAgIGxldCBtaW5WYWx1ZSA9IDA7XG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtaW5Cb3VuZCkpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gbWluQm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWluQm91bmQgaW5zdGFuY2VvZiBJbmtMaXN0ICYmIG1pbkJvdW5kLkNvdW50ID4gMClcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1pbkJvdW5kLm1pbkl0ZW0uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4Qm91bmQpKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IG1heEJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pbkJvdW5kIGluc3RhbmNlb2YgSW5rTGlzdCAmJiBtaW5Cb3VuZC5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBtYXhCb3VuZC5tYXhJdGVtLlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJMaXN0ID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgc3ViTGlzdC5TZXRJbml0aWFsT3JpZ2luTmFtZXModGhpcy5vcmlnaW5OYW1lcyk7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygb3JkZXJlZCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uVmFsdWUgPj0gbWluVmFsdWUgJiYgaXRlbS5WYWx1ZSA8PSBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHN1Ykxpc3QuQWRkKGl0ZW0uS2V5LCBpdGVtLlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViTGlzdDtcbiAgICB9XG4gICAgRXF1YWxzKG90aGVySW5rTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJJbmtMaXN0IGluc3RhbmNlb2YgSW5rTGlzdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlcklua0xpc3QuQ291bnQgIT0gdGhpcy5Db3VudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKCFvdGhlcklua0xpc3QuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBHZXRIYXNoQ29kZSBub3QgaW1wbGVtZW50ZWRcbiAgICBnZXQgb3JkZXJlZEl0ZW1zKCkge1xuICAgICAgICAvLyBMaXN0PEtleVZhbHVlUGFpcjxJbmtMaXN0SXRlbSwgaW50Pj5cbiAgICAgICAgbGV0IG9yZGVyZWQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIG9yZGVyZWQucHVzaCh7IEtleTogaXRlbSwgVmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9yZGVyZWQuc29ydCgoeCwgeSkgPT4ge1xuICAgICAgICAgICAgaWYgKHguS2V5Lm9yaWdpbk5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInguS2V5Lm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeS5LZXkub3JpZ2luTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwieS5LZXkub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LlZhbHVlID09IHkuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5LZXkub3JpZ2luTmFtZS5sb2NhbGVDb21wYXJlKHkuS2V5Lm9yaWdpbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBiaXQgaW50byBhIG51bWJlckNvbXBhcmVUbyBtZXRob2Q/XG4gICAgICAgICAgICAgICAgaWYgKHguVmFsdWUgPCB5LlZhbHVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguVmFsdWUgPiB5LlZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3JkZXJlZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBvcmRlcmVkID0gdGhpcy5vcmRlcmVkSXRlbXM7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIsIFwiKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gb3JkZXJlZFtpXS5LZXk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0uaXRlbU5hbWVcIik7XG4gICAgICAgICAgICBzYi5BcHBlbmQoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGNhc3RpbmcgYSBJbmtMaXN0IHRvIGEgTnVtYmVyLCBmb3Igc29tZXJlYXNvbiwgYWN0dWFsbHkgZ2l2ZXMgYSBudW1iZXIuXG4gICAgLy8gVGhpcyBtZXNzZXMgdXAgdGhlIHR5cGUgZGV0ZWN0aW9uIHdoZW4gY3JlYXRpbmcgYSBWYWx1ZSBmcm9tIGEgSW5rTGlzdC5cbiAgICAvLyBSZXR1cm5pbmcgTmFOIGhlcmUgcHJldmVudHMgdGhhdC5cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5rTGlzdCA9IElua0xpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmtMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uU2VyaWFsaXNhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgR2x1ZV8xID0gcmVxdWlyZShcIi4vR2x1ZVwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBEaXZlcnRfMSA9IHJlcXVpcmUoXCIuL0RpdmVydFwiKTtcbmNvbnN0IENob2ljZVBvaW50XzEgPSByZXF1aXJlKFwiLi9DaG9pY2VQb2ludFwiKTtcbmNvbnN0IFZhcmlhYmxlUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZVJlZmVyZW5jZVwiKTtcbmNvbnN0IFZhcmlhYmxlQXNzaWdubWVudF8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVBc3NpZ25tZW50XCIpO1xuY29uc3QgTmF0aXZlRnVuY3Rpb25DYWxsXzEgPSByZXF1aXJlKFwiLi9OYXRpdmVGdW5jdGlvbkNhbGxcIik7XG5jb25zdCBWb2lkXzEgPSByZXF1aXJlKFwiLi9Wb2lkXCIpO1xuY29uc3QgVGFnXzEgPSByZXF1aXJlKFwiLi9UYWdcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgQ2hvaWNlXzEgPSByZXF1aXJlKFwiLi9DaG9pY2VcIik7XG5jb25zdCBMaXN0RGVmaW5pdGlvbl8xID0gcmVxdWlyZShcIi4vTGlzdERlZmluaXRpb25cIik7XG5jb25zdCBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMSA9IHJlcXVpcmUoXCIuL0xpc3REZWZpbml0aW9uc09yaWdpblwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIEpzb25TZXJpYWxpc2F0aW9uIHtcbiAgICBzdGF0aWMgSkFycmF5VG9SdW50aW1lT2JqTGlzdChqQXJyYXksIHNraXBMYXN0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gakFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKHNraXBMYXN0KVxuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgalRvayA9IGpBcnJheVtpXTtcbiAgICAgICAgICAgIGxldCBydW50aW1lT2JqID0gdGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3QoalRvayk7XG4gICAgICAgICAgICBpZiAocnVudGltZU9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicnVudGltZU9ialwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChydW50aW1lT2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHdyaXRlciwgZGljdGlvbmFyeSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZGljdGlvbmFyeSkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChrZXkpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVMaXN0UnVudGltZU9ianMod3JpdGVyLCBsaXN0KSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlSW50RGljdGlvbmFyeSh3cml0ZXIsIGRpY3QpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRpY3QpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgb2JqKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpdmVydCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIERpdmVydF8xLkRpdmVydCk7XG4gICAgICAgIGlmIChkaXZlcnQpIHtcbiAgICAgICAgICAgIGxldCBkaXZUeXBlS2V5ID0gXCItPlwiO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwieCgpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZlcnQucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkaXZlcnQuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwiZigpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmVydC5zdGFja1B1c2hUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwiLT50LT5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFyZ2V0U3RyO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFN0ciA9IGRpdmVydC52YXJpYWJsZURpdmVydE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShkaXZUeXBlS2V5LCB0YXJnZXRTdHIpO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidmFyXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpdmVydC5pc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpdmVydC5leHRlcm5hbEFyZ3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJleEFyZ3NcIiwgZGl2ZXJ0LmV4dGVybmFsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hvaWNlUG9pbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KTtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50KSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIqXCIsIGNob2ljZVBvaW50LnBhdGhTdHJpbmdPbkNob2ljZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImZsZ1wiLCBjaG9pY2VQb2ludC5mbGFncyk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGlmIChpbnRWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludChpbnRWYWwudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbG9hdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuRmxvYXRWYWx1ZSk7XG4gICAgICAgIGlmIChmbG9hdFZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlRmxvYXQoZmxvYXRWYWwudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgaWYgKHN0clZhbCkge1xuICAgICAgICAgICAgaWYgKHN0clZhbC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCJcXG5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdJbm5lcihcIl5cIik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nSW5uZXIoc3RyVmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGlzdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKGxpc3RWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVJbmtMaXN0KHdyaXRlciwgbGlzdFZhbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpdlRhcmdldFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoZGl2VGFyZ2V0VmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgaWYgKGRpdlRhcmdldFZhbC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZGl2VGFyZ2V0VmFsLnZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJeLT5cIiwgZGl2VGFyZ2V0VmFsLnZhbHVlLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhclB0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICBpZiAodmFyUHRyVmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJedmFyXCIsIHZhclB0clZhbC52YWx1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImNpXCIsIHZhclB0clZhbC5jb250ZXh0SW5kZXgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdsdWUgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBHbHVlXzEuR2x1ZSk7XG4gICAgICAgIGlmIChnbHVlKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCI8PlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udHJvbENtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICBpZiAoY29udHJvbENtZCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKEpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzW2NvbnRyb2xDbWQuY29tbWFuZFR5cGVdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmF0aXZlRnVuYyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChuYXRpdmVGdW5jKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IG5hdGl2ZUZ1bmMubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiXlwiKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBcIkxeXCI7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhclJlZiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UpO1xuICAgICAgICBpZiAodmFyUmVmKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgbGV0IHJlYWRDb3VudFBhdGggPSB2YXJSZWYucGF0aFN0cmluZ0ZvckNvdW50O1xuICAgICAgICAgICAgaWYgKHJlYWRDb3VudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiQ05UP1wiLCByZWFkQ291bnRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiVkFSP1wiLCB2YXJSZWYubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFyQXNzID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KTtcbiAgICAgICAgaWYgKHZhckFzcykge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSB2YXJBc3MuaXNHbG9iYWwgPyBcIlZBUj1cIiA6IFwidGVtcD1cIjtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KGtleSwgdmFyQXNzLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbm1lbnQ/XG4gICAgICAgICAgICBpZiAoIXZhckFzcy5pc05ld0RlY2xhcmF0aW9uKVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicmVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdm9pZE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZvaWRfMS5Wb2lkKTtcbiAgICAgICAgaWYgKHZvaWRPYmopIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShcInZvaWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhZyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFRhZ18xLlRhZyk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIiNcIiwgdGFnLnRleHQpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENob2ljZV8xLkNob2ljZSk7XG4gICAgICAgIGlmIChjaG9pY2UpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVDaG9pY2Uod3JpdGVyLCBjaG9pY2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHJ1bnRpbWUgb2JqZWN0IHRvIEpzb24gdG9rZW46IFwiICsgb2JqKTtcbiAgICB9XG4gICAgc3RhdGljIEpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2JqcyhqT2JqZWN0KSB7XG4gICAgICAgIGxldCBkaWN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gak9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGpPYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmtPYmplY3QgPSB0aGlzLkpUb2tlblRvUnVudGltZU9iamVjdChqT2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmtPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpbmtPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpY3Quc2V0KGtleSwgaW5rT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gICAgc3RhdGljIEpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdCkge1xuICAgICAgICBsZXQgZGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGpPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChqT2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkaWN0LnNldChrZXksIHBhcnNlSW50KGpPYmplY3Rba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH1cbiAgICBzdGF0aWMgSlRva2VuVG9SdW50aW1lT2JqZWN0KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgbGV0IGZpcnN0Q2hhciA9IHN0clswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT0gXCJeXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3RDaGFyID09IFwiXFxuXCIgJiYgc3RyLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShcIlxcblwiKTtcbiAgICAgICAgICAgIC8vIEdsdWVcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCI8PlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR2x1ZV8xLkdsdWUoKTtcbiAgICAgICAgICAgIC8vIENvbnRyb2wgY29tbWFuZHMgKHdvdWxkIGxvb2tpbmcgdXAgaW4gYSBoYXNoIHNldCBiZSBmYXN0ZXI/KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBKc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjbWROYW1lID0gSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBjbWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOYXRpdmUgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoc3RyID09IFwiTF5cIilcbiAgICAgICAgICAgICAgICBzdHIgPSBcIl5cIjtcbiAgICAgICAgICAgIGlmIChOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbEV4aXN0c1dpdGhOYW1lKHN0cikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsV2l0aE5hbWUoc3RyKTtcbiAgICAgICAgICAgIC8vIFBvcFxuICAgICAgICAgICAgaWYgKHN0ciA9PSBcIi0+LT5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Qb3BUdW5uZWwoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIn5yZXRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Qb3BGdW5jdGlvbigpO1xuICAgICAgICAgICAgLy8gVm9pZFxuICAgICAgICAgICAgaWYgKHN0ciA9PSBcInZvaWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZvaWRfMS5Wb2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0b2tlbjtcbiAgICAgICAgICAgIGxldCBwcm9wVmFsdWU7XG4gICAgICAgICAgICAvLyBEaXZlcnQgdGFyZ2V0IHZhbHVlIHRvIHBhdGhcbiAgICAgICAgICAgIGlmIChvYmpbXCJeLT5cIl0pIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCJeLT5cIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKG5ldyBQYXRoXzEuUGF0aChwcm9wVmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGVQb2ludGVyVmFsdWVcbiAgICAgICAgICAgIGlmIChvYmpbXCJedmFyXCJdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiXnZhclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyUHRyID0gbmV3IFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChcImNpXCIgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcImNpXCJdO1xuICAgICAgICAgICAgICAgICAgICB2YXJQdHIuY29udGV4dEluZGV4ID0gcGFyc2VJbnQocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhclB0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpdmVydFxuICAgICAgICAgICAgbGV0IGlzRGl2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgbGV0IGV4dGVybmFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIi0+XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJmKClcIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNEaXZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2hlc1RvU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIi0+dC0+XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wieCgpXCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGl2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpdmVydCA9IG5ldyBEaXZlcnRfMS5EaXZlcnQoKTtcbiAgICAgICAgICAgICAgICBkaXZlcnQucHVzaGVzVG9TdGFjayA9IHB1c2hlc1RvU3RhY2s7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LnN0YWNrUHVzaFR5cGUgPSBkaXZQdXNoVHlwZTtcbiAgICAgICAgICAgICAgICBkaXZlcnQuaXNFeHRlcm5hbCA9IGV4dGVybmFsO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcInZhclwiXSkpXG4gICAgICAgICAgICAgICAgICAgIGRpdmVydC52YXJpYWJsZURpdmVydE5hbWUgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZyA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXZlcnQuaXNDb25kaXRpb25hbCA9ICEhb2JqW1wiY1wiXTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJleEFyZ3NcIl0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0LmV4dGVybmFsQXJncyA9IHBhcnNlSW50KHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaXZlcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaG9pY2VcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiKlwiXSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZVBvaW50XzEuQ2hvaWNlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBjaG9pY2UucGF0aFN0cmluZ09uQ2hvaWNlID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJmbGdcIl0pKVxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UuZmxhZ3MgPSBwYXJzZUludChwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiVkFSP1wiXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIkNOVD9cIl0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRDb3VudFZhclJlZiA9IG5ldyBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgcmVhZENvdW50VmFyUmVmLnBhdGhTdHJpbmdGb3JDb3VudCA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ291bnRWYXJSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSBhc3NpZ25tZW50XG4gICAgICAgICAgICBsZXQgaXNWYXJBc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc0dsb2JhbFZhciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJWQVI9XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzVmFyQXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc0dsb2JhbFZhciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1widGVtcD1cIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNWYXJBc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzR2xvYmFsVmFyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYXJBc3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFyTmFtZSA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBpc05ld0RlY2wgPSAhb2JqW1wicmVcIl07XG4gICAgICAgICAgICAgICAgbGV0IHZhckFzcyA9IG5ldyBWYXJpYWJsZUFzc2lnbm1lbnRfMS5WYXJpYWJsZUFzc2lnbm1lbnQodmFyTmFtZSwgaXNOZXdEZWNsKTtcbiAgICAgICAgICAgICAgICB2YXJBc3MuaXNHbG9iYWwgPSBpc0dsb2JhbFZhcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ialtcIiNcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcIiNcIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWdfMS5UYWcocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJsaXN0XCJdKSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0Q29udGVudCA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0Pilwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RDb250ZW50ID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCByYXdMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJvcmlnaW5zXCJdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbmFtZXNBc09ianMgPSAoTGlzdDxvYmplY3Q+KXByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVzQXNPYmpzID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyByYXdMaXN0LlNldEluaXRpYWxPcmlnaW5OYW1lcyhuYW1lc0FzT2Jqcy5DYXN0PHN0cmluZz4oKS5Ub0xpc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0xpc3QuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG5hbWVzQXNPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGxpc3RDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0Q29udGVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZVRvVmFsID0gbGlzdENvbnRlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RfMS5JbmtMaXN0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHBhcnNlSW50KG5hbWVUb1ZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdMaXN0LkFkZChpdGVtLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5MaXN0VmFsdWUocmF3TGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqW1wib3JpZ2luYWxDaG9pY2VQYXRoXCJdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuSk9iamVjdFRvQ2hvaWNlKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgaXMgYWx3YXlzIGEgUnVudGltZS5Db250YWluZXJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KQXJyYXlUb0NvbnRhaW5lcih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgdG9rZW4gdG8gcnVudGltZSBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIGNvbnRhaW5lciwgd2l0aG91dE5hbWUgPSBmYWxzZSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29udGFpbmVyLmNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIGMpO1xuICAgICAgICBsZXQgbmFtZWRPbmx5Q29udGVudCA9IGNvbnRhaW5lci5uYW1lZE9ubHlDb250ZW50O1xuICAgICAgICBsZXQgY291bnRGbGFncyA9IGNvbnRhaW5lci5jb3VudEZsYWdzO1xuICAgICAgICBsZXQgaGFzTmFtZVByb3BlcnR5ID0gY29udGFpbmVyLm5hbWUgIT0gbnVsbCAmJiAhd2l0aG91dE5hbWU7XG4gICAgICAgIGxldCBoYXNUZXJtaW5hdG9yID0gbmFtZWRPbmx5Q29udGVudCAhPSBudWxsIHx8IGNvdW50RmxhZ3MgPiAwIHx8IGhhc05hbWVQcm9wZXJ0eTtcbiAgICAgICAgaWYgKGhhc1Rlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVkT25seUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG5hbWVkT25seUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZWRDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIG5hbWVkQ29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOYW1lUHJvcGVydHkpXG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIiNuXCIsIGNvbnRhaW5lci5uYW1lKTtcbiAgICAgICAgaWYgKGhhc1Rlcm1pbmF0b3IpXG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlTnVsbCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgSkFycmF5VG9Db250YWluZXIoakFycmF5KSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIGNvbnRhaW5lci5jb250ZW50ID0gdGhpcy5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpBcnJheSwgdHJ1ZSk7XG4gICAgICAgIGxldCB0ZXJtaW5hdGluZ09iaiA9IGpBcnJheVtqQXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0ZXJtaW5hdGluZ09iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbmFtZWRPbmx5Q29udGVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0ZXJtaW5hdGluZ09iaikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIjZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jb3VudEZsYWdzID0gcGFyc2VJbnQodGVybWluYXRpbmdPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSBcIiNuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgPSB0ZXJtaW5hdGluZ09ialtrZXldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZWRDb250ZW50SXRlbSA9IHRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KHRlcm1pbmF0aW5nT2JqW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbmFtZWRTdWJDb250YWluZXIgPSBuYW1lZENvbnRlbnRJdGVtIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkU3ViQ29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG5hbWVkQ29udGVudEl0ZW0sIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lZFN1YkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVkU3ViQ29udGFpbmVyLm5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnQuc2V0KGtleSwgbmFtZWRDb250ZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLm5hbWVkT25seUNvbnRlbnQgPSBuYW1lZE9ubHlDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9DaG9pY2Uoak9iaikge1xuICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZV8xLkNob2ljZSgpO1xuICAgICAgICBjaG9pY2UudGV4dCA9IGpPYmpbXCJ0ZXh0XCJdLnRvU3RyaW5nKCk7XG4gICAgICAgIGNob2ljZS5pbmRleCA9IHBhcnNlSW50KGpPYmpbXCJpbmRleFwiXSk7XG4gICAgICAgIGNob2ljZS5zb3VyY2VQYXRoID0gak9ialtcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiXS50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2Uub3JpZ2luYWxUaHJlYWRJbmRleCA9IHBhcnNlSW50KGpPYmpbXCJvcmlnaW5hbFRocmVhZEluZGV4XCJdKTtcbiAgICAgICAgY2hvaWNlLnBhdGhTdHJpbmdPbkNob2ljZSA9IGpPYmpbXCJ0YXJnZXRQYXRoXCJdLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUNob2ljZSh3cml0ZXIsIGNob2ljZSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInRleHRcIiwgY2hvaWNlLnRleHQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImluZGV4XCIsIGNob2ljZS5pbmRleCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwib3JpZ2luYWxDaG9pY2VQYXRoXCIsIGNob2ljZS5zb3VyY2VQYXRoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJvcmlnaW5hbFRocmVhZEluZGV4XCIsIGNob2ljZS5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ0YXJnZXRQYXRoXCIsIGNob2ljZS5wYXRoU3RyaW5nT25DaG9pY2UpO1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlSW5rTGlzdCh3cml0ZXIsIGxpc3RWYWwpIHtcbiAgICAgICAgbGV0IHJhd0xpc3QgPSBsaXN0VmFsLnZhbHVlO1xuICAgICAgICBpZiAocmF3TGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYXdMaXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJsaXN0XCIpO1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIHJhd0xpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBsZXQgaXRlbVZhbCA9IHZhbDtcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lU3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKGl0ZW0ub3JpZ2luTmFtZSA/IGl0ZW0ub3JpZ2luTmFtZSA6IFwiP1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKFwiLlwiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lRW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoaXRlbVZhbCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICBpZiAocmF3TGlzdC5Db3VudCA9PSAwICYmXG4gICAgICAgICAgICByYXdMaXN0Lm9yaWdpbk5hbWVzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2luTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcIm9yaWdpbnNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHJhd0xpc3Qub3JpZ2luTmFtZXMpXG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlKG5hbWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0RGVmaW5pdGlvbnNUb0pUb2tlbihvcmlnaW4pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBkZWYgb2Ygb3JpZ2luLmxpc3RzKSB7XG4gICAgICAgICAgICBsZXQgbGlzdERlZkpzb24gPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZGVmLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0uaXRlbU5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3REZWZKc29uW2l0ZW0uaXRlbU5hbWVdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RlZi5uYW1lXSA9IGxpc3REZWZKc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBKVG9rZW5Ub0xpc3REZWZpbml0aW9ucyhvYmopIHtcbiAgICAgICAgLy8gdmFyIGRlZnNPYmogPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pb2JqO1xuICAgICAgICBsZXQgZGVmc09iaiA9IG9iajtcbiAgICAgICAgbGV0IGFsbERlZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGRlZnNPYmopIHtcbiAgICAgICAgICAgIGlmIChkZWZzT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0RGVmSnNvbiA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0Pilrdi5WYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdERlZkpzb24gPSBkZWZzT2JqW2tleV07XG4gICAgICAgICAgICAgICAgLy8gQ2FzdCAoc3RyaW5nLCBvYmplY3QpIHRvIChzdHJpbmcsIGludCkgZm9yIGl0ZW1zXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5hbWVWYWx1ZUtleSBpbiBsaXN0RGVmSnNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmc09iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZVZhbHVlID0gbGlzdERlZkpzb25bbmFtZVZhbHVlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldChuYW1lVmFsdWVLZXksIHBhcnNlSW50KG5hbWVWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBuZXcgTGlzdERlZmluaXRpb25fMS5MaXN0RGVmaW5pdGlvbihuYW1lLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgYWxsRGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMS5MaXN0RGVmaW5pdGlvbnNPcmlnaW4oYWxsRGVmcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uU2VyaWFsaXNhdGlvbiA9IEpzb25TZXJpYWxpc2F0aW9uO1xuSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXMgPSAoKCkgPT4ge1xuICAgIGxldCBfY29udHJvbENvbW1hbmROYW1lcyA9IFtdO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0XSA9IFwiZXZcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXRdID0gXCJvdXRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmRdID0gXCIvZXZcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZV0gPSBcImR1XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZV0gPSBcInBvcFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb25dID0gXCJ+cmV0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BUdW5uZWxdID0gXCItPi0+XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZ10gPSBcInN0clwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kU3RyaW5nXSA9IFwiL3N0clwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm9PcF0gPSBcIm5vcFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnRdID0gXCJjaG9pY2VDbnRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zXSA9IFwidHVyblwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZV0gPSBcInR1cm5zXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SZWFkQ291bnRdID0gXCJyZWFkY1wiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tXSA9IFwicm5kXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZWVkUmFuZG9tXSA9IFwic3JuZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleF0gPSBcInZpc2l0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleF0gPVxuICAgICAgICBcInNlcVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWRdID0gXCJ0aHJlYWRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmVdID0gXCJkb25lXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRdID0gXCJlbmRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50XSA9IFwibGlzdEludFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlXSA9IFwicmFuZ2VcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb21dID0gXCJscm5kXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlRPVEFMX1ZBTFVFUzsgKytpKSB7XG4gICAgICAgIGlmIChfY29udHJvbENvbW1hbmROYW1lc1tpXSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbCBjb21tYW5kIG5vdCBhY2NvdW50ZWQgZm9yIGluIHNlcmlhbGlzYXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBfY29udHJvbENvbW1hbmROYW1lcztcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uU2VyaWFsaXNhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY2xhc3MgTGlzdERlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcyA9IGl0ZW1zIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSW5rTGlzdF8xLklua0xpc3RJdGVtKHRoaXMubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5zZXQoaXRlbS5zZXJpYWxpemVkKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuICAgIFZhbHVlRm9ySXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgaW50VmFsID0gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5nZXQoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgaW50VmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuIGludFZhbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luTmFtZSAhPSB0aGlzLm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyhpdGVtLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgQ29udGFpbnNJdGVtV2l0aE5hbWUoaXRlbU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuaGFzKGl0ZW1OYW1lKTtcbiAgICB9XG4gICAgVHJ5R2V0SXRlbVdpdGhWYWx1ZSh2YWwsIFxuICAgIC8qIG91dCAqLyBpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0odGhpcy5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogaXRlbSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGl0ZW0sIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgVHJ5R2V0VmFsdWVGb3JJdGVtKGl0ZW0sIFxuICAgIC8qIG91dCAqLyBpbnRWYWwpIHtcbiAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiAwLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiAwLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdERlZmluaXRpb24gPSBMaXN0RGVmaW5pdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3REZWZpbml0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbnNPcmlnaW4gPSB2b2lkIDA7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIExpc3REZWZpbml0aW9uc09yaWdpbiB7XG4gICAgY29uc3RydWN0b3IobGlzdHMpIHtcbiAgICAgICAgdGhpcy5fbGlzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGxpc3Qgb2YgbGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RzLnNldChsaXN0Lm5hbWUsIGxpc3QpO1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIml0ZW0uaXRlbU5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChpdGVtLml0ZW1OYW1lLCBsaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuc2V0KGl0ZW0uZnVsbE5hbWUsIGxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxpc3RzKCkge1xuICAgICAgICBsZXQgbGlzdE9mTGlzdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgWywgdmFsdWVdIG9mIHRoaXMuX2xpc3RzKSB7XG4gICAgICAgICAgICBsaXN0T2ZMaXN0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdE9mTGlzdHM7XG4gICAgfVxuICAgIFRyeUxpc3RHZXREZWZpbml0aW9uKG5hbWUsIFxuICAgIC8qIG91dCAqLyBkZWYpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGx5LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib29sZWFuIGFuZCB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhbiBvdXQuXG4gICAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5fbGlzdHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZiwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZmluaXRpb24sIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBGaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkxpc3REZWZpbml0aW9uc09yaWdpbiA9IExpc3REZWZpbml0aW9uc09yaWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3REZWZpbml0aW9uc09yaWdpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmF0aXZlRnVuY3Rpb25DYWxsID0gdm9pZCAwO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgTmF0aXZlRnVuY3Rpb25DYWxsIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bWJlck9mUGFyYW1ldGVycyA9IDA7XG4gICAgICAgIHRoaXMuX3Byb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUHJvdG90eXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBudW1iZXJPZlBhcmFtZXRlcnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9pc1Byb3RvdHlwZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZlBhcmFtZXRlcnMgPSBudW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIENhbGxXaXRoTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lKTtcbiAgICB9XG4gICAgc3RhdGljIENhbGxFeGlzdHNXaXRoTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdGhpcy5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5fbmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYW1lXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuX2lzUHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvdHlwZSA9XG4gICAgICAgICAgICAgICAgICAgIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zLmdldCh0aGlzLl9uYW1lKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBudW1iZXJPZlBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b3R5cGUubnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlck9mUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX251bWJlck9mUGFyYW1ldGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBDYWxsKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvdHlwZS5DYWxsKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm51bWJlck9mUGFyYW1ldGVycyAhPSBwYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFzTGlzdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oJ0F0dGVtcHRpbmcgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24gYSB2b2lkIHZhbHVlLiBEaWQgeW91IGZvcmdldCB0byBcInJldHVyblwiIGEgdmFsdWUgZnJvbSBhIGZ1bmN0aW9uIHlvdSBjYWxsZWQgaGVyZT8nKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgVmFsdWVfMS5MaXN0VmFsdWUpXG4gICAgICAgICAgICAgICAgaGFzTGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoID09IDIgJiYgaGFzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24ocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZXJjZWRQYXJhbXMgPSB0aGlzLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZShwYXJhbWV0ZXJzKTtcbiAgICAgICAgbGV0IGNvZXJjZWRUeXBlID0gY29lcmNlZFBhcmFtc1swXS52YWx1ZVR5cGU7XG4gICAgICAgIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIENhbGxUeXBlKHBhcmFtZXRlcnNPZlNpbmdsZVR5cGUpIHtcbiAgICAgICAgbGV0IHBhcmFtMSA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNPZlNpbmdsZVR5cGVbMF0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdmFsVHlwZSA9IHBhcmFtMS52YWx1ZVR5cGU7XG4gICAgICAgIGxldCB2YWwxID0gcGFyYW0xO1xuICAgICAgICBsZXQgcGFyYW1Db3VudCA9IHBhcmFtZXRlcnNPZlNpbmdsZVR5cGUubGVuZ3RoO1xuICAgICAgICBpZiAocGFyYW1Db3VudCA9PSAyIHx8IHBhcmFtQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBvcEZvclR5cGVPYmogPSB0aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQodmFsVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW9wRm9yVHlwZU9iaikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFZhbHVlXzEuVmFsdWVUeXBlW3ZhbFR5cGVdO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIFwiICsgdGhpcy5uYW1lICsgXCIgb24gXCIgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtQ291bnQgPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbTIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlWzFdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsMiA9IHBhcmFtMjtcbiAgICAgICAgICAgICAgICBsZXQgb3BGb3JUeXBlID0gb3BGb3JUeXBlT2JqO1xuICAgICAgICAgICAgICAgIGlmICh2YWwxLnZhbHVlID09PSBudWxsIHx8IHZhbDIudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGwgQmluYXJ5T3AgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRWYWwgPSBvcEZvclR5cGUodmFsMS52YWx1ZSwgdmFsMi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3BGb3JUeXBlID0gb3BGb3JUeXBlT2JqO1xuICAgICAgICAgICAgICAgIGlmICh2YWwxLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIFVuYXJ5T3AgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFZhbCA9IG9wRm9yVHlwZSh2YWwxLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgZGlmZmVyZW50IGZyb20gdXBzdHJlYW0uIFNpbmNlIEphdmFTY3JpcHQgdHJlYXRzXG4gICAgICAgICAgICAgICAgLy8gaW50ZWdlcnMgYW5kIGZsb2F0cyBhcyB0aGUgc2FtZSBudW1iZXJzLCBpdCdzIGltcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyB0byBmb3JjZSBhbiBudW1iZXIgdG8gYmUgZWl0aGVyIGFuIGludGVnZXIgb3IgYSBmbG9hdC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEl0IGNhbiBiZSB1c2VmdWwgdG8gZm9yY2UgYSBzcGVjaWZpYyBudW1iZXIgdHlwZVxuICAgICAgICAgICAgICAgIC8vIChlc3BlY2lhbGx5IGZvciBkaXZpc2lvbnMpLCBzbyB0aGUgcmVzdWx0IG9mIElOVCgpICYgRkxPQVQoKVxuICAgICAgICAgICAgICAgIC8vIGlzIGNvZXJjZWQgdG8gdGhlIHRoZSBwcm9wZXIgdmFsdWUgdHlwZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHNvIGZvcmNlIGFsbCBvdGhlciB1bmFyeSBvcGVyYXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHNhbWUgdmFsdWUgdHlwZSwgYWx0aG91Z2ggdGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBmb3IgbnVtYmVycy4gU2VlIGBWYWx1ZS5DcmVhdGVgLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT09IE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgVmFsdWVfMS5WYWx1ZVR5cGUuSW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lID09PSBOYXRpdmVGdW5jdGlvbkNhbGwuRmxvYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgcGFyYW0xLnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVycyB0byBOYXRpdmVGdW5jdGlvbkNhbGw6IFwiICtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBpZiAoKHRoaXMubmFtZSA9PSBcIitcIiB8fCB0aGlzLm5hbWUgPT0gXCItXCIpICYmXG4gICAgICAgICAgICBwYXJhbWV0ZXJzWzBdIGluc3RhbmNlb2YgVmFsdWVfMS5MaXN0VmFsdWUgJiZcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbMV0gaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24ocGFyYW1ldGVycyk7XG4gICAgICAgIGxldCB2MSA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNbMF0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdjIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzWzFdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgaWYgKCh0aGlzLm5hbWUgPT0gXCImJlwiIHx8IHRoaXMubmFtZSA9PSBcInx8XCIpICYmXG4gICAgICAgICAgICAodjEudmFsdWVUeXBlICE9IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QgfHwgdjIudmFsdWVUeXBlICE9IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO1xuICAgICAgICAgICAgbGV0IG9wID0gdGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KFZhbHVlXzEuVmFsdWVUeXBlLkludCk7XG4gICAgICAgICAgICBpZiAob3AgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24gb3BcIik7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gb3AodjEuaXNUcnV0aHkgPyAxIDogMCwgdjIuaXNUcnV0aHkgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuSW50VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodjEudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QgJiYgdjIudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShbdjEsIHYyXSk7XG4gICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuIG5vdCBjYWxsIHVzZSBcIiArXG4gICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgXCIgb3BlcmF0aW9uIG9uIFwiICtcbiAgICAgICAgICAgIFZhbHVlXzEuVmFsdWVUeXBlW3YxLnZhbHVlVHlwZV0gK1xuICAgICAgICAgICAgXCIgYW5kIFwiICtcbiAgICAgICAgICAgIFZhbHVlXzEuVmFsdWVUeXBlW3YyLnZhbHVlVHlwZV0pO1xuICAgIH1cbiAgICBDYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbihsaXN0SW50UGFyYW1zKSB7XG4gICAgICAgIGxldCBsaXN0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobGlzdEludFBhcmFtc1swXSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobGlzdEludFBhcmFtc1sxXSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGxldCByZXN1bHRJbmtMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgIGlmIChsaXN0VmFsLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZVwiKTtcbiAgICAgICAgZm9yIChsZXQgW2xpc3RJdGVtS2V5LCBsaXN0SXRlbVZhbHVlXSBvZiBsaXN0VmFsLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbGlzdEl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkobGlzdEl0ZW1LZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBpbnRPcCA9IHRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpO1xuICAgICAgICAgICAgaWYgKGludFZhbC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBpbnRWYWwudmFsdWVcIik7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SW50ID0gaW50T3AobGlzdEl0ZW1WYWx1ZSwgaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIGxldCBpdGVtT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsaXN0VmFsLnZhbHVlLm9yaWdpbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZS5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIGxpc3RWYWwudmFsdWUub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBsaXN0SXRlbS5vcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtT3JpZ2luICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5jcmVtZW50ZWRJdGVtID0gaXRlbU9yaWdpbi5UcnlHZXRJdGVtV2l0aFZhbHVlKHRhcmdldEludCwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnRlZEl0ZW0uZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbmtMaXN0LkFkZChpbmNyZW1lbnRlZEl0ZW0ucmVzdWx0LCB0YXJnZXRJbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5MaXN0VmFsdWUocmVzdWx0SW5rTGlzdCk7XG4gICAgfVxuICAgIENvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZShwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgbGV0IHZhbFR5cGUgPSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQ7XG4gICAgICAgIGxldCBzcGVjaWFsQ2FzZUxpc3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWwudmFsdWVUeXBlID4gdmFsVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhbFR5cGUgPSB2YWwudmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxDYXNlTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWwsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1ldGVyc091dCA9IFtdO1xuICAgICAgICBpZiAoVmFsdWVfMS5WYWx1ZVR5cGVbdmFsVHlwZV0gPT0gVmFsdWVfMS5WYWx1ZVR5cGVbVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdF0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlua09iamVjdFZhbCBvZiBwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoaW5rT2JqZWN0VmFsLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50VmFsID0gcGFyc2VJbnQodmFsLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbENhc2VMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Moc3BlY2lhbENhc2VMaXN0LCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsQ2FzZUxpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUgc3BlY2lhbENhc2VMaXN0LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHNwZWNpYWxDYXNlTGlzdC52YWx1ZS5vcmlnaW5PZk1heEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIGxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdC5UcnlHZXRJdGVtV2l0aFZhbHVlKGludFZhbCwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYXN0ZWRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShpdGVtLnJlc3VsdCwgaW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaChjYXN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDb3VsZCBub3QgZmluZCBMaXN0IGl0ZW0gd2l0aCB0aGUgdmFsdWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFZhbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBWYWx1ZV8xLlZhbHVlVHlwZVt2YWwudmFsdWVUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgbWl4IExpc3RzIGFuZCBcIiArIGtleSArIFwiIHZhbHVlcyBpbiB0aGlzIG9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmtPYmplY3RWYWwgb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGlua09iamVjdFZhbCwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNhc3RlZFZhbHVlID0gdmFsLkNhc3QodmFsVHlwZSk7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc091dC5wdXNoKGNhc3RlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc091dDtcbiAgICB9XG4gICAgc3RhdGljIElkZW50aXR5KHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHN0YXRpYyBHZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCkge1xuICAgICAgICBpZiAodGhpcy5fbmF0aXZlRnVuY3Rpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8vIEludCBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geCArIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geCAtIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCAoeCwgeSkgPT4geCAqIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkRpdmlkZSwgKHgsIHkpID0+IE1hdGguZmxvb3IoeCAvIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Nb2QsICh4LCB5KSA9PiB4ICUgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5OZWdhdGUsICh4KSA9PiAteCk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeCA9PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyLCAoeCwgeSkgPT4gKHggPiB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5MZXNzLCAoeCwgeSkgPT4gKHggPCB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4gKHggPj0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywgKHgsIHkpID0+ICh4IDw9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICh4ICE9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTm90LCAoeCkgPT4gKHggPT0gMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQW5kLCAoeCwgeSkgPT4gKHggIT0gMCAmJiB5ICE9IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk9yLCAoeCwgeSkgPT4gKHggIT0gMCB8fCB5ICE9IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1heCwgKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NaW4sICh4LCB5KSA9PiBNYXRoLm1pbih4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuUG93LCAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvb3IsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5DZWlsaW5nLCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuSW50LCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvYXQsICh4KSA9PiB4KTtcbiAgICAgICAgICAgIC8vIEZsb2F0IG9wZXJhdGlvbnNcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geCAtIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTXVsdGlwbHksICh4LCB5KSA9PiB4ICogeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5EaXZpZGUsICh4LCB5KSA9PiB4IC8geSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Nb2QsICh4LCB5KSA9PiB4ICUgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLk5lZ2F0ZSwgKHgpID0+IC14KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHggPT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5HcmVhdGVyLCAoeCwgeSkgPT4gKHggPiB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3MsICh4LCB5KSA9PiAoeCA8IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+IHggPj0geSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiAoeCA8PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICh4ICE9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5Ob3QsICh4KSA9PiAoeCA9PSAwLjAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuQW5kLCAoeCwgeSkgPT4gKHggIT0gMC4wICYmIHkgIT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk9yLCAoeCwgeSkgPT4gKHggIT0gMC4wIHx8IHkgIT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1heCwgKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1pbiwgKHgsIHkpID0+IE1hdGgubWluKHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlBvdywgKHgsIHkpID0+IE1hdGgucG93KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvb3IsICh4KSA9PiBNYXRoLmZsb29yKHgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuQ2VpbGluZywgKHgpID0+IE1hdGguY2VpbCh4KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkludCwgKHgpID0+IE1hdGguZmxvb3IoeCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5GbG9hdCwgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIC8vIFN0cmluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geCArIHkpOyAvLyBjb25jYXRcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4ID09PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoISh4ID09PSB5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuSGFzLCAoeCwgeSkgPT4gKHguaW5jbHVkZXMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhc250LCAoeCwgeSkgPT4gKHguaW5jbHVkZXMoeSkgPyAwIDogMSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4LlVuaW9uKHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsICh4LCB5KSA9PiB4LldpdGhvdXQoeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXMsICh4LCB5KSA9PiAoeC5Db250YWlucyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkhhc250LCAoeCwgeSkgPT4gKHguQ29udGFpbnMoeSkgPyAwIDogMSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5JbnRlcnNlY3QsICh4LCB5KSA9PiB4LkludGVyc2VjdCh5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHguRXF1YWxzKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4LkdyZWF0ZXJUaGFuKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzcywgKHgsIHkpID0+ICh4Lkxlc3NUaGFuKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+IHguR3JlYXRlclRoYW5PckVxdWFscyh5KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywgKHgsIHkpID0+IHguTGVzc1RoYW5PckVxdWFscyh5KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKCF4LkVxdWFscyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+IHguQ291bnQgPiAwICYmIHkuQ291bnQgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+IHguQ291bnQgPiAwIHx8IHkuQ291bnQgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLk5vdCwgKHgpID0+ICh4LkNvdW50ID09IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkludmVydCwgKHgpID0+IHguaW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQWxsLCAoeCkgPT4geC5hbGwpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkxpc3RNaW4sICh4KSA9PiB4Lk1pbkFzTGlzdCgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWF4LCAoeCkgPT4geC5NYXhBc0xpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQ291bnQsICh4KSA9PiB4LkNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5WYWx1ZU9mTGlzdCwgKHgpID0+IHgubWF4SXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0c0VxdWFsID0gKGQxLCBkMikgPT4gKGQxLkVxdWFscyhkMikgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0c05vdEVxdWFsID0gKGQxLCBkMikgPT4gZDEuRXF1YWxzKGQyKSA/IDAgOiAxO1xuICAgICAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLkVxdWFsLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQsIGRpdmVydFRhcmdldHNFcXVhbCk7XG4gICAgICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHRoaXMuTm90RXF1YWxzLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQsIGRpdmVydFRhcmdldHNOb3RFcXVhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkT3BGdW5jRm9yVHlwZSh2YWxUeXBlLCBvcCkge1xuICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fb3BlcmF0aW9uRnVuY3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uRnVuY3Muc2V0KHZhbFR5cGUsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIGFyZ3MsIHZhbFR5cGUsIG9wKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYXRpdmVGdW5jdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpO1xuICAgICAgICBsZXQgbmF0aXZlRnVuYyA9IHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbmF0aXZlRnVuYykge1xuICAgICAgICAgICAgbmF0aXZlRnVuYyA9IG5ldyBOYXRpdmVGdW5jdGlvbkNhbGwobmFtZSwgYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuc2V0KG5hbWUsIG5hdGl2ZUZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIG5hdGl2ZUZ1bmMuQWRkT3BGdW5jRm9yVHlwZSh2YWxUeXBlLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRJbnRCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkludCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkSW50VW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDEsIFZhbHVlXzEuVmFsdWVUeXBlLkludCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkRmxvYXRCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRGbG9hdFVuYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAxLCBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkU3RyaW5nQmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5TdHJpbmcsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZExpc3RCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZExpc3RVbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMSwgVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCwgb3ApO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdOYXRpdmUgXCInICsgdGhpcy5uYW1lICsgJ1wiJztcbiAgICB9XG59XG5leHBvcnRzLk5hdGl2ZUZ1bmN0aW9uQ2FsbCA9IE5hdGl2ZUZ1bmN0aW9uQ2FsbDtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5BZGQgPSBcIitcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5TdWJ0cmFjdCA9IFwiLVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkRpdmlkZSA9IFwiL1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk11bHRpcGx5ID0gXCIqXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTW9kID0gXCIlXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTmVnYXRlID0gXCJfXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRXF1YWwgPSBcIj09XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuR3JlYXRlciA9IFwiPlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxlc3MgPSBcIjxcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5HcmVhdGVyVGhhbk9yRXF1YWxzID0gXCI+PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxlc3NUaGFuT3JFcXVhbHMgPSBcIjw9XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTm90RXF1YWxzID0gXCIhPVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5vdCA9IFwiIVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkFuZCA9IFwiJiZcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5PciA9IFwifHxcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NaW4gPSBcIk1JTlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk1heCA9IFwiTUFYXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuUG93ID0gXCJQT1dcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5GbG9vciA9IFwiRkxPT1JcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DZWlsaW5nID0gXCJDRUlMSU5HXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW50ID0gXCJJTlRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5GbG9hdCA9IFwiRkxPQVRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5IYXMgPSBcIj9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5IYXNudCA9IFwiIT9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnRlcnNlY3QgPSBcIl5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MaXN0TWluID0gXCJMSVNUX01JTlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxpc3RNYXggPSBcIkxJU1RfTUFYXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQWxsID0gXCJMSVNUX0FMTFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkNvdW50ID0gXCJMSVNUX0NPVU5UXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuVmFsdWVPZkxpc3QgPSBcIkxJU1RfVkFMVUVcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnZlcnQgPSBcIkxJU1RfSU5WRVJUXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9ucyA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OYXRpdmVGdW5jdGlvbkNhbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRocm93TnVsbEV4Y2VwdGlvbiA9IGV4cG9ydHMuTnVsbEV4Y2VwdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogSW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUsIGEgU3lzdGVtRXhjZXB0aW9uIHdvdWxkIGJlIHRocm93biB3aGVuIHBhc3NpbmdcbiAqIG51bGwgdG8gbWV0aG9kcyBleHBlY3RlZCBhIHZhbGlkIGluc3RhbmNlLiBKYXZhc2NyaXB0IGhhcyBubyBzdWNoXG4gKiBjb25jZXB0LCBidXQgVHlwZVNjcmlwdCB3aWxsIG5vdCBhbGxvdyBgbnVsbGAgdG8gYmUgcGFzc2VkIHRvIG1ldGhvZHNcbiAqIGV4cGxpY2l0ZWx5IHJlcXVpcmluZyBhIHZhbGlkIHR5cGUuXG4gKlxuICogV2hlbmV2ZXIgVHlwZVNjcmlwdCBjb21wbGFpbiBhYm91dCB0aGUgcG9zc2liaWxpdHkgb2YgYSBgbnVsbGAgdmFsdWUsXG4gKiBjaGVjayB0aGUgb2ZmZW5kaW5nIHZhbHVlIGFuZCBpdCBpdCdzIG51bGwsIHRocm93IHRoaXMgZXhjZXB0aW9uIHVzaW5nXG4gKiBgdGhyb3dOdWxsRXhjZXB0aW9uKG5hbWU6IHN0cmluZylgLlxuICovXG5jbGFzcyBOdWxsRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5OdWxsRXhjZXB0aW9uID0gTnVsbEV4Y2VwdGlvbjtcbi8qKlxuICogVGhyb3cgYSBOdWxsRXhjZXB0aW9uLlxuICpcbiAqIEBwYXJhbSBuYW1lIGEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIG9mZmVuZGluZyB2YWx1ZSAob2Z0ZW4gaXRzIG5hbWUgd2l0aGluIHRoZSBjb2RlKS5cbiAqL1xuZnVuY3Rpb24gdGhyb3dOdWxsRXhjZXB0aW9uKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgTnVsbEV4Y2VwdGlvbihgJHtuYW1lfSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xufVxuZXhwb3J0cy50aHJvd051bGxFeGNlcHRpb24gPSB0aHJvd051bGxFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdWxsRXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmtPYmplY3QgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIElua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVidWdNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhdGggPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnTWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z01ldGFkYXRhO1xuICAgIH1cbiAgICBzZXQgZGVidWdNZXRhZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWJ1Z01ldGFkYXRhID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvd25EZWJ1Z01ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdNZXRhZGF0YTtcbiAgICB9XG4gICAgRGVidWdMaW5lTnVtYmVyT2ZQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBhIGxpbmUgbnVtYmVyIGZyb20gZGVidWcgbWV0YWRhdGFcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldENvbnRlbnQgPSByb290LkNvbnRlbnRBdFBhdGgocGF0aCkub2JqO1xuICAgICAgICAgICAgaWYgKHRhcmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZG0gPSB0YXJnZXRDb250ZW50LmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkbS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoID0gbmV3IFBhdGhfMS5QYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY2hpbGQucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkQ2hpbGQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVkQ2hpbGQgIT0gbnVsbCAmJiBuYW1lZENoaWxkLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHMudW5zaGlmdChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KG5hbWVkQ2hpbGQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHMudW5zaGlmdChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KGNvbnRhaW5lci5jb250ZW50LmluZGV4T2YoY2hpbGQpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjb250YWluZXIucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoID0gbmV3IFBhdGhfMS5QYXRoKGNvbXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICB9XG4gICAgUmVzb2x2ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicGF0aFwiKTtcbiAgICAgICAgaWYgKHBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcywgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5wYXJlbnQgIT09IG51bGwsIFwiQ2FuJ3QgcmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudFwiKTtcbiAgICAgICAgICAgICAgICBuZWFyZXN0Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KG5lYXJlc3RDb250YWluZXIgIT09IG51bGwsIFwiRXhwZWN0ZWQgcGFyZW50IHRvIGJlIGEgY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHBhdGguR2V0Q29tcG9uZW50KDApLmlzUGFyZW50KTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC50YWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lYXJlc3RDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5lYXJlc3RDb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmVhcmVzdENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRDb250YWluZXIgPSB0aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRlbnRDb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnZlcnRQYXRoVG9SZWxhdGl2ZShnbG9iYWxQYXRoKSB7XG4gICAgICAgIGxldCBvd25QYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBsZXQgbWluUGF0aExlbmd0aCA9IE1hdGgubWluKGdsb2JhbFBhdGgubGVuZ3RoLCBvd25QYXRoLmxlbmd0aCk7XG4gICAgICAgIGxldCBsYXN0U2hhcmVkUGF0aENvbXBJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pblBhdGhMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG93bkNvbXAgPSBvd25QYXRoLkdldENvbXBvbmVudChpKTtcbiAgICAgICAgICAgIGxldCBvdGhlckNvbXAgPSBnbG9iYWxQYXRoLkdldENvbXBvbmVudChpKTtcbiAgICAgICAgICAgIGlmIChvd25Db21wLkVxdWFscyhvdGhlckNvbXApKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc2hhcmVkIHBhdGggY29tcG9uZW50cywgc28ganVzdCB1c2UgZ2xvYmFsIHBhdGhcbiAgICAgICAgaWYgKGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFBhdGg7XG4gICAgICAgIGxldCBudW1VcHdhcmRzTW92ZXMgPSBvd25QYXRoLmNvbXBvbmVudENvdW50IC0gMSAtIGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4O1xuICAgICAgICBsZXQgbmV3UGF0aENvbXBzID0gW107XG4gICAgICAgIGZvciAobGV0IHVwID0gMDsgdXAgPCBudW1VcHdhcmRzTW92ZXM7ICsrdXApXG4gICAgICAgICAgICBuZXdQYXRoQ29tcHMucHVzaChQYXRoXzEuUGF0aC5Db21wb25lbnQuVG9QYXJlbnQoKSk7XG4gICAgICAgIGZvciAobGV0IGRvd24gPSBsYXN0U2hhcmVkUGF0aENvbXBJbmRleCArIDE7IGRvd24gPCBnbG9iYWxQYXRoLmNvbXBvbmVudENvdW50OyArK2Rvd24pXG4gICAgICAgICAgICBuZXdQYXRoQ29tcHMucHVzaChnbG9iYWxQYXRoLkdldENvbXBvbmVudChkb3duKSk7XG4gICAgICAgIGxldCByZWxhdGl2ZVBhdGggPSBuZXcgUGF0aF8xLlBhdGgobmV3UGF0aENvbXBzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aDtcbiAgICB9XG4gICAgQ29tcGFjdFBhdGhTdHJpbmcob3RoZXJQYXRoKSB7XG4gICAgICAgIGxldCBnbG9iYWxQYXRoU3RyID0gbnVsbDtcbiAgICAgICAgbGV0IHJlbGF0aXZlUGF0aFN0ciA9IG51bGw7XG4gICAgICAgIGlmIChvdGhlclBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoU3RyID0gb3RoZXJQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgICAgICBnbG9iYWxQYXRoU3RyID0gdGhpcy5wYXRoLlBhdGhCeUFwcGVuZGluZ1BhdGgob3RoZXJQYXRoKS5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aCA9IHRoaXMuQ29udmVydFBhdGhUb1JlbGF0aXZlKG90aGVyUGF0aCk7XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGhTdHIgPSByZWxhdGl2ZVBhdGguY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgICAgIGdsb2JhbFBhdGhTdHIgPSBvdGhlclBhdGguY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmVQYXRoU3RyLmxlbmd0aCA8IGdsb2JhbFBhdGhTdHIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aFN0cjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFBhdGhTdHI7XG4gICAgfVxuICAgIGdldCByb290Q29udGVudENvbnRhaW5lcigpIHtcbiAgICAgICAgbGV0IGFuY2VzdG9yID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yLnBhcmVudCkge1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChhbmNlc3RvciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWQ6IERvZXNuJ3Qgc3VwcG9ydCBjb3B5aW5nXCIpO1xuICAgIH1cbiAgICAvLyBTZXRDaGlsZCB3b3JrcyBzbGlnaHRseSBkaWZlcmVudGx5IGluIHRoZSBqcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBwYXNzIGFuIG9iamV0cyBwcm9wZXJ0eSBieSByZWZlcmVuY2UsIHdlIGluc3RlYWQgcGFzc1xuICAgIC8vIHRoZSBvYmplY3QgYW5kIHRoZSBwcm9wZXJ0eSBzdHJpbmcuXG4gICAgLy8gVE9ETzogVGhpcyBtZXRob2QgY2FuIHByb2JhYmx5IGJlIHJld3JpdHRlbiB3aXRoIHR5cGUtc2FmZXR5IGluIG1pbmQuXG4gICAgU2V0Q2hpbGQob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2JqW3Byb3BdKVxuICAgICAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcbiAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChvYmpbcHJvcF0pXG4gICAgICAgICAgICBvYmpbcHJvcF0ucGFyZW50ID0gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLklua09iamVjdCA9IElua09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUFJORyA9IHZvaWQgMDtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmxpeHQvZjE3YjQ3YzYyNTA4YmU1OTk4N2Jcbi8vIEluayB1c2VzIGEgc2VlZGFibGUgUFJORyBvZiB3aGljaCB0aGVyZSBpcyBub25lIGluIG5hdGl2ZSBqYXZhc2NyaXB0LlxuY2xhc3MgUFJORyB7XG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkICUgMjE0NzQ4MzY0NztcbiAgICAgICAgaWYgKHRoaXMuc2VlZCA8PSAwKVxuICAgICAgICAgICAgdGhpcy5zZWVkICs9IDIxNDc0ODM2NDY7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zZWVkID0gKHRoaXMuc2VlZCAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpO1xuICAgIH1cbiAgICBuZXh0RmxvYXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uZXh0KCkgLSAxKSAvIDIxNDc0ODM2NDY7XG4gICAgfVxufVxuZXhwb3J0cy5QUk5HID0gUFJORztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBSTkcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGggPSB2b2lkIDA7XG5jbGFzcyBQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50c1N0cmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1N0cmluZyA9IGNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUGF0aC5Db21wb25lbnQgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgICAgICAgIGxldCBoZWFkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLnB1c2goaGVhZCk7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5jb25jYXQodGFpbC5fY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBoZWFkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlID0gISFhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5jb25jYXQoaGVhZCk7XG4gICAgICAgICAgICB0aGlzLl9pc1JlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzUmVsYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1JlbGF0aXZlO1xuICAgIH1cbiAgICBnZXQgY29tcG9uZW50Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBjYXJlZnVsLCB0aGUgb3JpZ2luYWwgY29kZSB1c2VzIGxlbmd0aC0xIGhlcmUuIFRoaXMgaXMgYmVjYXVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mXG4gICAgICAgICAgICAvLyBMaXN0LkdldFJhbmdlIGlzIGEgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4dHJhY3QsIHdoZXJlYXNlIEFycmF5LnNsaWNlIHVzZXMgYW4gaW5kZXhcbiAgICAgICAgICAgIGxldCB0YWlsQ29tcHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKDEsIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aCh0YWlsQ29tcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguc2VsZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBsYXN0Q29tcG9uZW50KCkge1xuICAgICAgICBsZXQgbGFzdENvbXBvbmVudElkeCA9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3RDb21wb25lbnRJZHggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbbGFzdENvbXBvbmVudElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29udGFpbnNOYW1lZENvbXBvbmVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzW2ldLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc2VsZigpIHtcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgICBwYXRoLl9pc1JlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIEdldENvbXBvbmVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG4gICAgfVxuICAgIFBhdGhCeUFwcGVuZGluZ1BhdGgocGF0aFRvQXBwZW5kKSB7XG4gICAgICAgIGxldCBwID0gbmV3IFBhdGgoKTtcbiAgICAgICAgbGV0IHVwd2FyZE1vdmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHNbaV0uaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB1cHdhcmRNb3ZlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCAtIHVwd2FyZE1vdmVzOyArK2kpIHtcbiAgICAgICAgICAgIHAuX2NvbXBvbmVudHMucHVzaCh0aGlzLl9jb21wb25lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdXB3YXJkTW92ZXM7IGkgPCBwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHAuX2NvbXBvbmVudHMucHVzaChwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBnZXQgY29tcG9uZW50c1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHRoaXMuX2NvbXBvbmVudHMuam9pbihcIi5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSBcIi5cIiArIHRoaXMuX2NvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNTdHJpbmc7XG4gICAgfVxuICAgIHNldCBjb21wb25lbnRzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1N0cmluZyA9PSBudWxsIHx8IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmdbMF0gPT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVsYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb25lbnRTdHJpbmdzID0gdGhpcy5fY29tcG9uZW50c1N0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAobGV0IHN0ciBvZiBjb21wb25lbnRTdHJpbmdzKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gbmFtZWQgY29tcG9uZW50cyB0aGF0IHN0YXJ0IHdpdGggYSBudW1iZXIsIGVnIFwiNDJzb21ld2hlcmVcIiwgYW5kIGluZGV4ZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gdGhlIG5vcm1hbCBwYXJzZUludCB3b24ndCBkbyBmb3IgdGhlIGRldGVjdGlvbiBiZWNhdXNlIGl0J3MgdG9vIHJlbGF4ZWQuXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcGFyc2VJbnRcbiAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT8oWzAtOV0rfEluZmluaXR5KSQvLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgUGF0aC5Db21wb25lbnQocGFyc2VJbnQoc3RyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKG5ldyBQYXRoLkNvbXBvbmVudChzdHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50c1N0cmluZztcbiAgICB9XG4gICAgRXF1YWxzKG90aGVyUGF0aCkge1xuICAgICAgICBpZiAob3RoZXJQYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlclBhdGguX2NvbXBvbmVudHMubGVuZ3RoICE9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJQYXRoLmlzUmVsYXRpdmUgIT0gdGhpcy5pc1JlbGF0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgY29kZSB1c2VzIFNlcXVlbmNlRXF1YWwgaGVyZSwgc28gd2UgbmVlZCB0byBpdGVyYXRlIG92ZXIgdGhlIGNvbXBvbmVudHMgbWFudWFsbHkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3RoZXJQYXRoLl9jb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gaXQncyBub3QgcXVpdGUgY2xlYXIgd2hldGhlciB0aGlzIHRlc3Qgc2hvdWxkIHVzZSBFcXVhbHMgb3IgYSBzaW1wbGUgPT0gb3BlcmF0b3IsXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ktbG9oc2UvaW5ranMvaXNzdWVzLzIyXG4gICAgICAgICAgICBpZiAoIW90aGVyUGF0aC5fY29tcG9uZW50c1tpXS5FcXVhbHModGhpcy5fY29tcG9uZW50c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBQYXRoQnlBcHBlbmRpbmdDb21wb25lbnQoYykge1xuICAgICAgICBsZXQgcCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIHAuX2NvbXBvbmVudHMucHVzaC5hcHBseShwLl9jb21wb25lbnRzLCB0aGlzLl9jb21wb25lbnRzKTtcbiAgICAgICAgcC5fY29tcG9uZW50cy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG59XG5leHBvcnRzLlBhdGggPSBQYXRoO1xuUGF0aC5wYXJlbnRJZCA9IFwiXlwiO1xuKGZ1bmN0aW9uIChQYXRoKSB7XG4gICAgY2xhc3MgQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5kZXhPck5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JOYW1lID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBpbmRleE9yTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleE9yTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzUGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PSBQYXRoLnBhcmVudElkO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBUb1BhcmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KFBhdGgucGFyZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEVxdWFscyhvdGhlckNvbXApIHtcbiAgICAgICAgICAgIGlmIChvdGhlckNvbXAgIT0gbnVsbCAmJiBvdGhlckNvbXAuaXNJbmRleCA9PSB0aGlzLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09IG90aGVyQ29tcC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT0gb3RoZXJDb21wLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhdGguQ29tcG9uZW50ID0gQ29tcG9uZW50O1xufSkoUGF0aCA9IGV4cG9ydHMuUGF0aCB8fCAoZXhwb3J0cy5QYXRoID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvaW50ZXIgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY2xhc3MgUG9pbnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5jb250ZW50W3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBnZXQgaXNOdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnBhdGguUGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KG5ldyBQYXRoXzEuUGF0aC5Db21wb25lbnQodGhpcy5pbmRleCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIucGF0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIpXG4gICAgICAgICAgICByZXR1cm4gXCJJbmsgUG9pbnRlciAobnVsbClcIjtcbiAgICAgICAgcmV0dXJuIChcIkluayBQb2ludGVyIC0+IFwiICtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSArXG4gICAgICAgICAgICBcIiAtLSBpbmRleCBcIiArXG4gICAgICAgICAgICB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUsIGJ1dCBpcyBoZXJlIHRvIG1haW50YWluIHRoZVxuICAgIC8vIHZhbHVlIHNlbWFudGljcyBvZiBQb2ludGVyLlxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnRlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTdGFydE9mKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIoY29udGFpbmVyLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOdWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIobnVsbCwgLTEpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9pbnRlciA9IFBvaW50ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QdXNoUG9wVHlwZSA9IHZvaWQgMDtcbnZhciBQdXNoUG9wVHlwZTtcbihmdW5jdGlvbiAoUHVzaFBvcFR5cGUpIHtcbiAgICBQdXNoUG9wVHlwZVtQdXNoUG9wVHlwZVtcIlR1bm5lbFwiXSA9IDBdID0gXCJUdW5uZWxcIjtcbiAgICBQdXNoUG9wVHlwZVtQdXNoUG9wVHlwZVtcIkZ1bmN0aW9uXCJdID0gMV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZVwiXSA9IDJdID0gXCJGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZVwiO1xufSkoUHVzaFBvcFR5cGUgPSBleHBvcnRzLlB1c2hQb3BUeXBlIHx8IChleHBvcnRzLlB1c2hQb3BUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVB1c2hQb3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlYXJjaFJlc3VsdCA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY2xhc3MgU2VhcmNoUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vYmogPSBudWxsO1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjb3JyZWN0T2JqKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHByb3hpbWF0ZSA/IG51bGwgOiB0aGlzLm9iajtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGhpcy5vYmogOiBudWxsO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgc2VhcmNoUmVzdWx0ID0gbmV3IFNlYXJjaFJlc3VsdCgpO1xuICAgICAgICBzZWFyY2hSZXN1bHQub2JqID0gdGhpcy5vYmo7XG4gICAgICAgIHNlYXJjaFJlc3VsdC5hcHByb3hpbWF0ZSA9IHRoaXMuYXBwcm94aW1hdGU7XG4gICAgICAgIHJldHVybiBzZWFyY2hSZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TZWFyY2hSZXN1bHQgPSBTZWFyY2hSZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWFyY2hSZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUpzb24gPSB2b2lkIDA7XG5jbGFzcyBTaW1wbGVKc29uIHtcbiAgICBzdGF0aWMgVGV4dFRvRGljdGlvbmFyeSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlSnNvbi5SZWFkZXIodGV4dCkuVG9EaWN0aW9uYXJ5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBUZXh0VG9BcnJheSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlSnNvbi5SZWFkZXIodGV4dCkuVG9BcnJheSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlSnNvbiA9IFNpbXBsZUpzb247XG4oZnVuY3Rpb24gKFNpbXBsZUpzb24pIHtcbiAgICBjbGFzcyBSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290T2JqZWN0ID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBUb0RpY3Rpb25hcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBUb0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RPYmplY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2ltcGxlSnNvbi5SZWFkZXIgPSBSZWFkZXI7XG4gICAgLy8gSW4gQyMsIHRoaXMgY2xhc3Mgd3JpdGVzIGpzb24gdG9rZW5zIGRpcmVjdGx5IHRvIGEgU3RyaW5nV3JpdGVyIG9yXG4gICAgLy8gYW5vdGhlciBzdHJlYW0uIEhlcmUsIGEgdGVtcG9yYXJ5IGhpZXJhcmNoeSBpcyBjcmVhdGVkIGluIHRoZSBmb3JtXG4gICAgLy8gb2YgYSBqYXZhc2NyaXB0IG9iamVjdCwgd2hpY2ggaXMgc2VyaWFsaXNlZCBpbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QuXG4gICAgLy8gU2VlIGluZGl2aWR1YWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICBjbGFzcyBXcml0ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIEluIGFkZGl0aW9uIHRvIGBfc3RhdGVTdGFja2AgcHJlc2VudCBpbiB0aGUgb3JpZ2luYWwgY29kZSxcbiAgICAgICAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gb2YgU2ltcGxlSnNvbiB1c2UgdHdvIG90aGVyIHN0YWNrcyBhbmQgdHdvXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGVzIGhvbGRpbmcgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgICAgIC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBuYW1lIGJlaW5nIGJ1aWx0XG4gICAgICAgICAgICAvLyB3aXRoIGBXcml0ZVByb3BlcnR5TmFtZVN0YXJ0YCwgYFdyaXRlUHJvcGVydHlOYW1lSW5uZXJgIGFuZFxuICAgICAgICAgICAgLy8gYFdyaXRlUHJvcGVydHlOYW1lRW5kYC5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHN0cmluZyB2YWx1ZSBiZWluZyBidWlsdFxuICAgICAgICAgICAgLy8gd2l0aCBgV3JpdGVTdHJpbmdTdGFydGAsIGBXcml0ZVN0cmluZ0lubmVyYCBhbmRcbiAgICAgICAgICAgIC8vIGBXcml0ZVN0cmluZ0VuZGAuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiBiZWluZyBidWlsdCAoZWl0aGVyIGFuIGFycmF5XG4gICAgICAgICAgICAvLyBvciBhbiBvYmplY3QpLiBGb3IgaW5zdGFuY2UsIGF0IHRoZSAnPycgc3RlcCBkdXJpbmcgdGhlIGhpYXJjaHlcbiAgICAgICAgICAgIC8vIGNyZWF0aW9uLCB0aGlzIGhpZXJhcmNoeTpcbiAgICAgICAgICAgIC8vIFszLCB7YTogW2IsID9dfV0gd2lsbCBoYXZlIHRoaXMgY29ycmVzcG9uZGluZyBzdGFjazpcbiAgICAgICAgICAgIC8vIChib3R0b20pIFtBcnJheSwgT2JqZWN0LCBBcnJheV0gKHRvcClcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBiZWluZyBhc3NpZ25lZC4gRm9yIGluc3RhbmNlLCBhdFxuICAgICAgICAgICAgLy8gdGhlICc/JyBzdGVwIGR1cmluZyB0aGUgaGlhcmNoeSBjcmVhdGlvbiwgdGhpcyBoaWVyYXJjaHk6XG4gICAgICAgICAgICAvLyBbMywge2E6IFtiLCB7YzogP31dfV0gd2lsbCBoYXZlIHRoaXMgY29ycmVzcG9uZGluZyBzdGFjazpcbiAgICAgICAgICAgIC8vIChib3R0b20pIFthLCBjXSAodG9wKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIE9iamVjdCBjb250YWluaW5nIHRoZSBlbnRpcmUgaGllYXJjaHkuXG4gICAgICAgICAgICB0aGlzLl9qc29uT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZU9iamVjdChpbm5lcikge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBpbm5lcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBuZXcgb2JqZWN0LlxuICAgICAgICBXcml0ZU9iamVjdFN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdCh0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgYXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIG90aGVyIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eU5hbWUgPSB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3Byb3BlcnR5TmFtZV0gPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgY3JlYXRlZCBhcyB0aGUgY2hpbGQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIHRoZSByb290IG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc29uT2JqZWN0ID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZU9iamVjdEVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIGEgcHJvcGVydHkgbmFtZSAvIHZhbHVlIHBhaXIgdG8gdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgICAgICBXcml0ZVByb3BlcnR5KG5hbWUsIGlubmVyT3JDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpbm5lcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuV3JpdGUoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnQgYW5kIEZsb2F0IGFyZSBzZXBhcmF0ZSBjYWxscywgc2luY2UgdGhlcmUgYm90aCBhcmVcbiAgICAgICAgLy8gbnVtYmVycyBpbiBKYXZhU2NyaXB0LCBidXQgbmVlZCB0byBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LlxuICAgICAgICBXcml0ZUludFByb3BlcnR5KG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZUludChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlRmxvYXRQcm9wZXJ0eShuYW1lLCBjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVGbG9hdChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgYSBuZXcgcHJvcGVydHkgbmFtZSwgd2hpY2ggd2lsbCBiZSB1c2UgdG8gYWRkIHRoZVxuICAgICAgICAvLyBuZXcgb2JqZWN0IHdoZW4gY2FsbGluZyBfYWRkVG9DdXJyZW50T2JqZWN0KCkgZnJvbSBhIFdyaXRlXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlUHJvcGVydHlFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmNoaWxkQ291bnQgPT09IDEpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIGEgbmV3IHByb3BlcnR5IG5hbWUsIGV4Y2VwdCB0aGlzIHRpbWUsIHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIC8vIHdpbGwgYmUgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIGFsbCB0aGUgc3RyaW5ncyBwYXNzZWQgdG9cbiAgICAgICAgLy8gV3JpdGVQcm9wZXJ0eU5hbWVJbm5lci5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eU5hbWVTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlUHJvcGVydHlOYW1lRW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5TmFtZUlubmVyKHN0cikge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSArPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgbmV3IGFycmF5LlxuICAgICAgICBXcml0ZUFycmF5U3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgbGV0IG5ld09iamVjdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyBjcmVhdGVkIGFzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlOYW1lID0gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbltwcm9wZXJ0eU5hbWVdID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgY3JlYXRlZCBhcyB0aGUgY2hpbGQgb2YgYW5vdGhlciBhcnJheS5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB0aGUgcm9vdCBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUFycmF5RW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIHRvIHRoZSBhcHByb3ByaWF0ZSBjb2xsZWN0aW9uIChhcnJheSAvIG9iamVjdCksIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGNvbnRleHQuXG4gICAgICAgIFdyaXRlKHZhbHVlLCBlc2NhcGUgPSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogdHJ5aW5nIHRvIHdyaXRlIGEgbnVsbCBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlSW50KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgaXMgdXNlZCBhcyBhIHByZWNhdXRpb246XG4gICAgICAgICAgICAvLyAgICAgMS4gdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIHdyaXR0ZW4gYXMgYW4gaW50ZWdlclxuICAgICAgICAgICAgLy8gICAgICAgICh3aXRob3V0IGEgZnJhY3Rpb25hbCBwYXJ0IC0+IDEgaW5zdGVhZCBvZiAxLjApLCBldmVuXG4gICAgICAgICAgICAvLyAgICAgICAgdGhvdWdoIGl0IHNob3VsZCBiZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2ZcbiAgICAgICAgICAgIC8vICAgICAgICBKU09OLnNlcmlhbGl6ZTtcbiAgICAgICAgICAgIC8vICAgICAyLiB0byBlbnN1cmUgdGhhdCBpZiBhIGZsb2F0aW5nIG51bWJlciBpcyBwYXNzZWRcbiAgICAgICAgICAgIC8vICAgICAgICBhY2NpZGVudGFsbHksIGl0J3MgY29udmVydGVkIHRvIGFuIGludGVnZXIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHNhdmVnYW1lIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdChNYXRoLmZsb29yKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgSlNPTiBkb2Vzbid0IHN1cHBvcnQgTmFOIGFuZCBJbmZpbml0eSwgdGhlc2UgdmFsdWVzXG4gICAgICAgIC8vIGFyZSBjb252ZXJ0ZWQgaGVyZS5cbiAgICAgICAgV3JpdGVGbG9hdCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDMuNGUzOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoLTMuNGUzOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoMC4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVOdWxsKCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBhIHN0cmluZyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaW5cbiAgICAgICAgLy8gV3JpdGVTdHJpbmdFbmQoKS4gVGhlIHN0cmluZyB3aWxsIGJlIGEgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGhlXG4gICAgICAgIC8vIHN0cmluZ3MgcGFzc2VkIHRvIFdyaXRlU3RyaW5nSW5uZXIuXG4gICAgICAgIFdyaXRlU3RyaW5nU3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVTdHJpbmdFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHRoaXMuX2N1cnJlbnRTdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVTdHJpbmdJbm5lcihzdHIsIGVzY2FwZSA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZyk7XG4gICAgICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGlzZSB0aGUgcm9vdCBvYmplY3QgaW50byBhIEpTT04gc3RyaW5nLlxuICAgICAgICBUb1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc29uT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbk9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgc3RhdGUgc3RhY2sgd2hlbiBhZGRpbmcgbmV3IG9iamVjdHMgLyB2YWx1ZXMuXG4gICAgICAgIFN0YXJ0TmV3T2JqZWN0KGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmUgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jaGlsZENvdW50ID09PSAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgZ2V0dGVycyBwZWVrIGFsbCB0aGUgZGlmZmVyZW50IHN0YWNrcy5cbiAgICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoIC0gMV0udHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjaGlsZENvdW50KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoIC0gMV0uY2hpbGRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjdXJyZW50Q29sbGVjdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uU3RhY2tbdGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGN1cnJlbnRQcm9wZXJ0eU5hbWUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFja1t0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEluY3JlbWVudENoaWxkQ291bnQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgbGV0IGN1cnJFbCA9IHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjdXJyRWwuY2hpbGRDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKGN1cnJFbCk7XG4gICAgICAgIH1cbiAgICAgICAgQXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBc3NlcnQgZmFpbGVkIHdoaWxlIHdyaXRpbmcgSlNPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBkaWQgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLiBJdCBhZGRzXG4gICAgICAgIC8vIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgY3VycmVudCBjb2xsZWN0aW9uICh1c2VkIGJ5IFdyaXRlIG1ldGhvZHMpLlxuICAgICAgICBfYWRkVG9DdXJyZW50T2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KEFycmF5LmlzQXJyYXkodGhpcy5jdXJyZW50Q29sbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KCFBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb25bdGhpcy5jdXJyZW50UHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFNpbXBsZUpzb24uV3JpdGVyID0gV3JpdGVyO1xuICAgIChmdW5jdGlvbiAoV3JpdGVyKSB7XG4gICAgICAgIGxldCBTdGF0ZTtcbiAgICAgICAgKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiT2JqZWN0XCJdID0gMV0gPSBcIk9iamVjdFwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJBcnJheVwiXSA9IDJdID0gXCJBcnJheVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJQcm9wZXJ0eVwiXSA9IDNdID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJQcm9wZXJ0eU5hbWVcIl0gPSA0XSA9IFwiUHJvcGVydHlOYW1lXCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlN0cmluZ1wiXSA9IDVdID0gXCJTdHJpbmdcIjtcbiAgICAgICAgfSkoU3RhdGUgPSBXcml0ZXIuU3RhdGUgfHwgKFdyaXRlci5TdGF0ZSA9IHt9KSk7XG4gICAgICAgIGNsYXNzIFN0YXRlRWxlbWVudCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVyLlN0YXRlRWxlbWVudCA9IFN0YXRlRWxlbWVudDtcbiAgICB9KShXcml0ZXIgPSBTaW1wbGVKc29uLldyaXRlciB8fCAoU2ltcGxlSnNvbi5Xcml0ZXIgPSB7fSkpO1xufSkoU2ltcGxlSnNvbiA9IGV4cG9ydHMuU2ltcGxlSnNvbiB8fCAoZXhwb3J0cy5TaW1wbGVKc29uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZUpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXRlUGF0Y2ggPSB2b2lkIDA7XG5jbGFzcyBTdGF0ZVBhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB0b0NvcHkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxzID0gbmV3IE1hcCh0b0NvcHkuX2dsb2JhbHMpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQodG9Db3B5Ll9jaGFuZ2VkVmFyaWFibGVzKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCh0b0NvcHkuX3Zpc2l0Q291bnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCh0b0NvcHkuX3R1cm5JbmRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2xvYmFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbHM7XG4gICAgfVxuICAgIGdldCBjaGFuZ2VkVmFyaWFibGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlcztcbiAgICB9XG4gICAgZ2V0IHZpc2l0Q291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgfVxuICAgIGdldCB0dXJuSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgIH1cbiAgICBUcnlHZXRHbG9iYWwobmFtZSwgLyogb3V0ICovIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsICYmIHRoaXMuX2dsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX2dsb2JhbHMuZ2V0KG5hbWUpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFNldEdsb2JhbChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9nbG9iYWxzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIEFkZENoYW5nZWRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzLmFkZChuYW1lKTtcbiAgICB9XG4gICAgVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIC8qIG91dCAqLyBjb3VudCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaXRDb3VudHMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fdmlzaXRDb3VudHMuZ2V0KGNvbnRhaW5lciksIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogY291bnQsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgU2V0VmlzaXRDb3VudChjb250YWluZXIsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXIsIGNvdW50KTtcbiAgICB9XG4gICAgU2V0VHVybkluZGV4KGNvbnRhaW5lciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMuc2V0KGNvbnRhaW5lciwgaW5kZXgpO1xuICAgIH1cbiAgICBUcnlHZXRUdXJuSW5kZXgoY29udGFpbmVyLCAvKiBvdXQgKi8gaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R1cm5JbmRpY2VzLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX3R1cm5JbmRpY2VzLmdldChjb250YWluZXIpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGluZGV4LCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0ZVBhdGNoID0gU3RhdGVQYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlUGF0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3B3YXRjaCA9IHZvaWQgMDtcbi8vIFRoaXMgaXMgc2ltcGxlIHJlcGxhY2VtZW50IG9mIHRoZSBTdG9wd2F0Y2ggY2xhc3MgZnJvbSB0aGUgLk5FVCBGcmFtZXdvcmsuXG4vLyBUaGUgb3JpZ2luYWwgY2xhc3MgY2FuIGNvdW50IHRpbWUgd2l0aCBtdWNoIG1vcmUgYWNjdXJhY3kgdGhhbiB0aGUgSmF2YXNjcmlwdCB2ZXJzaW9uLlxuLy8gSXQgbWlnaHQgYmUgd29ydGggY29uc2lkZXJpbmcgdXNpbmcgYHdpbmRvdy5wZXJmb3JtYW5jZWAgaW4gdGhlIGJyb3dzZXJcbi8vIG9yIGBwcm9jZXNzLmhydGltZSgpYCBpbiBub2RlLlxuY2xhc3MgU3RvcHdhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBFbGFwc2VkTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RhcnRUaW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIFN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcHdhdGNoID0gU3RvcHdhdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcFdhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yeSA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBTdG9yeVN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdG9yeVN0YXRlXCIpO1xuY29uc3QgQ29udHJvbENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xDb21tYW5kXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IENob2ljZVBvaW50XzEgPSByZXF1aXJlKFwiLi9DaG9pY2VQb2ludFwiKTtcbmNvbnN0IENob2ljZV8xID0gcmVxdWlyZShcIi4vQ2hvaWNlXCIpO1xuY29uc3QgRGl2ZXJ0XzEgPSByZXF1aXJlKFwiLi9EaXZlcnRcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgVmFyaWFibGVBc3NpZ25tZW50XzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZUFzc2lnbm1lbnRcIik7XG5jb25zdCBWYXJpYWJsZVJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVSZWZlcmVuY2VcIik7XG5jb25zdCBOYXRpdmVGdW5jdGlvbkNhbGxfMSA9IHJlcXVpcmUoXCIuL05hdGl2ZUZ1bmN0aW9uQ2FsbFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFBSTkdfMSA9IHJlcXVpcmUoXCIuL1BSTkdcIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25zT3JpZ2luXzEgPSByZXF1aXJlKFwiLi9MaXN0RGVmaW5pdGlvbnNPcmlnaW5cIik7XG5jb25zdCBTdG9wV2F0Y2hfMSA9IHJlcXVpcmUoXCIuL1N0b3BXYXRjaFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTaW1wbGVKc29uXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVKc29uXCIpO1xudmFyIElua0xpc3RfMiA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmtMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbmtMaXN0XzIuSW5rTGlzdDsgfSB9KTtcbmlmICghTnVtYmVyLmlzSW50ZWdlcikge1xuICAgIE51bWJlci5pc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIoblZhbCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBuVmFsID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBpc0Zpbml0ZShuVmFsKSAmJlxuICAgICAgICAgICAgblZhbCA+IC05MDA3MTk5MjU0NzQwOTkyICYmXG4gICAgICAgICAgICBuVmFsIDwgOTAwNzE5OTI1NDc0MDk5MiAmJlxuICAgICAgICAgICAgTWF0aC5mbG9vcihuVmFsKSA9PT0gblZhbCk7XG4gICAgfTtcbn1cbmNsYXNzIFN0b3J5IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbmtWZXJzaW9uTWluaW11bUNvbXBhdGlibGUgPSAxODtcbiAgICAgICAgdGhpcy5fcHJldkNvbnRhaW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fYXN5bmNTYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvZmlsZXIgPSBudWxsOyAvLyBUT0RPOiBQcm9maWxlclxuICAgICAgICAvLyBEaXNjcmltaW5hdGlvbiBiZXR3ZWVuIGNvbnN0cnVjdG9yc1xuICAgICAgICBsZXQgY29udGVudENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGxpc3RzID0gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSBudWxsO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250ZW50Q29udGFpbmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBsaXN0cyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLSBTdG9yeSAoQ29udGFpbmVyIGNvbnRlbnRDb250YWluZXIsIExpc3Q8UnVudGltZS5MaXN0RGVmaW5pdGlvbj4gbGlzdHMgPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIgPSBjb250ZW50Q29udGFpbmVyO1xuICAgICAgICAgICAgLy8gLS0tLS0tXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxldCBqc29uU3RyaW5nID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGpzb24gPSBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5UZXh0VG9EaWN0aW9uYXJ5KGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAganNvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0gU3RvcnkgKENvbnRhaW5lciBjb250ZW50Q29udGFpbmVyLCBMaXN0PFJ1bnRpbWUuTGlzdERlZmluaXRpb24+IGxpc3RzID0gbnVsbClcbiAgICAgICAgaWYgKGxpc3RzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9saXN0RGVmaW5pdGlvbnMgPSBuZXcgTGlzdERlZmluaXRpb25zT3JpZ2luXzEuTGlzdERlZmluaXRpb25zT3JpZ2luKGxpc3RzKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAtLS0tLS1cbiAgICAgICAgLy8gLS0tLS0tIFN0b3J5KHN0cmluZyBqc29uU3RyaW5nKSA6IHRoaXMoKENvbnRhaW5lciludWxsKVxuICAgICAgICBpZiAoanNvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJvb3RPYmplY3QgPSBqc29uO1xuICAgICAgICAgICAgbGV0IHZlcnNpb25PYmogPSByb290T2JqZWN0W1wiaW5rVmVyc2lvblwiXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uT2JqID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5rIHZlcnNpb24gbnVtYmVyIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIGl0J3MgYSB2YWxpZCAuaW5rLmpzb24gZmlsZT9cIik7XG4gICAgICAgICAgICBsZXQgZm9ybWF0RnJvbUZpbGUgPSBwYXJzZUludCh2ZXJzaW9uT2JqKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRGcm9tRmlsZSA+IFN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSB3YXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXRGcm9tRmlsZSA8IHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBpcyB0b28gb2xkIHRvIGJlIGxvYWRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGVuZ2luZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdEZyb21GaWxlICE9IFN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBkb2Vzbid0IG1hdGNoIGN1cnJlbnQgdmVyc2lvbiBvZiBlbmdpbmUuIE5vbi1jcml0aWNhbCwgYnV0IHJlY29tbWVuZCBzeW5jaHJvbmlzaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb290VG9rZW4gPSByb290T2JqZWN0W1wicm9vdFwiXTtcbiAgICAgICAgICAgIGlmIChyb290VG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IG5vZGUgZm9yIGluayBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpO1xuICAgICAgICAgICAgbGV0IGxpc3REZWZzT2JqO1xuICAgICAgICAgICAgaWYgKChsaXN0RGVmc09iaiA9IHJvb3RPYmplY3RbXCJsaXN0RGVmc1wiXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0RGVmaW5pdGlvbnMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpUb2tlblRvTGlzdERlZmluaXRpb25zKGxpc3REZWZzT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub1J1bnRpbWVPYmplY3Qocm9vdFRva2VuKSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuUmVzZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLVxuICAgIH1cbiAgICBnZXQgY3VycmVudENob2ljZXMoKSB7XG4gICAgICAgIGxldCBjaG9pY2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBpZiAoIWMuaXNJbnZpc2libGVEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgYy5pbmRleCA9IGNob2ljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNob2ljZXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUZXh0KCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUZXh0IHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50VGV4dDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUYWdzKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUYWdzIHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50VGFncztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRFcnJvcnM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50V2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRXYXJuaW5ncztcbiAgICB9XG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXNFcnJvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1dhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhc1dhcm5pbmc7XG4gICAgfVxuICAgIGdldCB2YXJpYWJsZXNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGU7XG4gICAgfVxuICAgIGdldCBsaXN0RGVmaW5pdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0RGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgUHJvZmlsZXJcbiAgICBTdGFydFByb2ZpbGluZygpIHtcbiAgICAgICAgLyogKi9cbiAgICB9XG4gICAgRW5kUHJvZmlsaW5nKCkge1xuICAgICAgICAvKiAqL1xuICAgIH1cbiAgICAvLyBNZXJnZSB0b2dldGhlciBgcHVibGljIHN0cmluZyBUb0pzb24oKWAgYW5kIGB2b2lkIFRvSnNvbihTaW1wbGVKc29uLldyaXRlciB3cml0ZXIpYC5cbiAgICAvLyBXaWxsIG9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgd3JpdGVyIHdhcyBub3QgcHJvdmlkZWQuXG4gICAgVG9Kc29uKHdyaXRlcikge1xuICAgICAgICBsZXQgc2hvdWxkUmV0dXJuID0gZmFsc2U7XG4gICAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgICAgICBzaG91bGRSZXR1cm4gPSB0cnVlO1xuICAgICAgICAgICAgd3JpdGVyID0gbmV3IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLldyaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rVmVyc2lvblwiLCBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicm9vdFwiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZVJ1bnRpbWVDb250YWluZXIodywgdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIpKTtcbiAgICAgICAgaWYgKHRoaXMuX2xpc3REZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdERlZnNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVmIG9mIHRoaXMuX2xpc3REZWZpbml0aW9ucy5saXN0cykge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRlZi5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KGl0ZW0uaXRlbU5hbWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIGlmIChzaG91bGRSZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLlRvU3RyaW5nKCk7XG4gICAgfVxuICAgIFJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0U3RhdGVcIik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IFN0b3J5U3RhdGVfMS5TdG9yeVN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5PYnNlcnZlVmFyaWFibGVDaGFuZ2UodGhpcy5WYXJpYWJsZVN0YXRlRGlkQ2hhbmdlRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuUmVzZXRHbG9iYWxzKCk7XG4gICAgfVxuICAgIFJlc2V0RXJyb3JzKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRFcnJvcnMoKTtcbiAgICB9XG4gICAgUmVzZXRDYWxsc3RhY2soKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0Q2FsbHN0YWNrXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuRm9yY2VFbmQoKTtcbiAgICB9XG4gICAgUmVzZXRHbG9iYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldChcImdsb2JhbCBkZWNsXCIpKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxQb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLkNob29zZVBhdGgobmV3IFBhdGhfMS5QYXRoKFwiZ2xvYmFsIGRlY2xcIiksIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuQ29udGludWVJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IG9yaWdpbmFsUG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLlNuYXBzaG90RGVmYXVsdEdsb2JhbHMoKTtcbiAgICB9XG4gICAgQ29udGludWUoKSB7XG4gICAgICAgIHRoaXMuQ29udGludWVBc3luYygwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRleHQ7XG4gICAgfVxuICAgIGdldCBjYW5Db250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2FuQ29udGludWU7XG4gICAgfVxuICAgIGdldCBhc3luY0NvbnRpbnVlQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZTtcbiAgICB9XG4gICAgQ29udGludWVBc3luYyhtaWxsaXNlY3NMaW1pdEFzeW5jKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzKVxuICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKTtcbiAgICAgICAgdGhpcy5Db250aW51ZUludGVybmFsKG1pbGxpc2Vjc0xpbWl0QXN5bmMpO1xuICAgIH1cbiAgICBDb250aW51ZUludGVybmFsKG1pbGxpc2Vjc0xpbWl0QXN5bmMgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlQ29udGludWUoKTtcbiAgICAgICAgbGV0IGlzQXN5bmNUaW1lTGltaXRlZCA9IG1pbGxpc2Vjc0xpbWl0QXN5bmMgPiAwO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50Kys7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSA9IGlzQXN5bmNUaW1lTGltaXRlZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuJ3QgY29udGludWUgLSBzaG91bGQgY2hlY2sgY2FuQ29udGludWUgYmVmb3JlIGNhbGxpbmcgQ29udGludWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5kaWRTYWZlRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID09IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkdXJhdGlvblN0b3B3YXRjaCA9IG5ldyBTdG9wV2F0Y2hfMS5TdG9wd2F0Y2goKTtcbiAgICAgICAgZHVyYXRpb25TdG9wd2F0Y2guU3RhcnQoKTtcbiAgICAgICAgbGV0IG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lID0gdGhpcy5Db250aW51ZVNpbmdsZVN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoZS5tZXNzYWdlLCB1bmRlZmluZWQsIGUudXNlRW5kTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlICYmXG4gICAgICAgICAgICAgICAgZHVyYXRpb25TdG9wd2F0Y2guRWxhcHNlZE1pbGxpc2Vjb25kcyA+IG1pbGxpc2Vjc0xpbWl0QXN5bmMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5Db250aW51ZSk7XG4gICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLlN0b3AoKTtcbiAgICAgICAgaWYgKG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgfHwgIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuUmVzdG9yZVN0YXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJUaHJlYWQgYXZhaWxhYmxlIHRvIHBvcCwgdGhyZWFkcyBzaG91bGQgYWx3YXlzIGJlIGZsYXQgYnkgdGhlIGVuZCBvZiBldmFsdWF0aW9uP1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLmRpZFNhZmVFeGl0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICctPi0+JyB0byByZXR1cm4gZnJvbSBhIHR1bm5lbD9cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICd+IHJldHVybic/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInJhbiBvdXQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4gRE9ORScgb3IgJy0+IEVORCc/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQgZm9yIHVua25vd24gcmVhc29uLiBQbGVhc2UgZGVidWcgY29tcGlsZXIhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID09IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50LS07XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUG9zdENvbnRpbnVlKCk7XG4gICAgfVxuICAgIENvbnRpbnVlU2luZ2xlU3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5QcmVTdGVwKCk7XG4gICAgICAgIHRoaXMuU3RlcCgpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RTdGVwKCk7XG4gICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSAmJiAhdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhpcy5UcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5QcmVTbmFwc2hvdCgpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaW5TdHJpbmdFdmFsdWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZUF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRUYWdzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5zdGF0ZS5jdXJyZW50VGFnc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZSA9IHRoaXMuQ2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUZXh0LCB0aGlzLnN0YXRlLmN1cnJlbnRUZXh0LCB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGFncy5sZW5ndGgsIHRoaXMuc3RhdGUuY3VycmVudFRhZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlID09IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UgPT0gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5EaXNjYXJkU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlN0YXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRGlzY2FyZFNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUG9zdFNuYXBzaG90KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHByZXZUZXh0LCBjdXJyVGV4dCwgcHJldlRhZ0NvdW50LCBjdXJyVGFnQ291bnQpIHtcbiAgICAgICAgaWYgKHByZXZUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInByZXZUZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjdXJyVGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3bGluZVN0aWxsRXhpc3RzID0gY3VyclRleHQubGVuZ3RoID49IHByZXZUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgY3VyclRleHQuY2hhckF0KHByZXZUZXh0Lmxlbmd0aCAtIDEpID09IFwiXFxuXCI7XG4gICAgICAgIGlmIChwcmV2VGFnQ291bnQgPT0gY3VyclRhZ0NvdW50ICYmXG4gICAgICAgICAgICBwcmV2VGV4dC5sZW5ndGggPT0gY3VyclRleHQubGVuZ3RoICYmXG4gICAgICAgICAgICBuZXdsaW5lU3RpbGxFeGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2U7XG4gICAgICAgIGlmICghbmV3bGluZVN0aWxsRXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJUYWdDb3VudCA+IHByZXZUYWdDb3VudClcbiAgICAgICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwcmV2VGV4dC5sZW5ndGg7IGkgPCBjdXJyVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMgPSBjdXJyVGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyAhPSBcIiBcIiAmJiBjICE9IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5Ob0NoYW5nZTtcbiAgICB9XG4gICAgQ29udGludWVNYXhpbWFsbHkoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIkNvbnRpbnVlTWF4aW1hbGx5XCIpO1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0aGlzLkNvbnRpbnVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBDb250ZW50QXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICB9XG4gICAgS25vdENvbnRhaW5lcldpdGhOYW1lKG5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWVkQ29udGFpbmVyID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobmFtZWRDb250YWluZXIgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpXG4gICAgICAgICAgICByZXR1cm4gbmFtZWRDb250YWluZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBQb2ludGVyQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgbGV0IHAgPSBuZXcgUG9pbnRlcl8xLlBvaW50ZXIoKTtcbiAgICAgICAgbGV0IHBhdGhMZW5ndGhUb1VzZSA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHBhdGgubGFzdENvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwYXRoLmxhc3RDb21wb25lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGFzdENvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICBwYXRoTGVuZ3RoVG9Vc2UgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCwgdW5kZWZpbmVkLCBwYXRoTGVuZ3RoVG9Vc2UpO1xuICAgICAgICAgICAgcC5jb250YWluZXIgPSByZXN1bHQuY29udGFpbmVyO1xuICAgICAgICAgICAgcC5pbmRleCA9IHBhdGgubGFzdENvbXBvbmVudC5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgICAgIHAuY29udGFpbmVyID0gcmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHAuaW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lm9iaiA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmVzdWx0Lm9iaiA9PSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyICYmIHBhdGhMZW5ndGhUb1VzZSA+IDApKSB7XG4gICAgICAgICAgICB0aGlzLkVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY29udGVudCBhdCBwYXRoICdcIiArXG4gICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgXCInLCBhbmQgbm8gYXBwcm94aW1hdGlvbiBvZiBpdCB3YXMgcG9zc2libGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5hcHByb3hpbWF0ZSlcbiAgICAgICAgICAgIHRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIgK1xuICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgIFwiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0bzogJ1wiICtcbiAgICAgICAgICAgICAgICByZXN1bHQub2JqLnBhdGggK1xuICAgICAgICAgICAgICAgIFwiJy5cIik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBTdGF0ZVNuYXBzaG90KCkge1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCk7XG4gICAgfVxuICAgIFJlc3RvcmVTdGF0ZVNuYXBzaG90KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJfc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuUmVzdG9yZUFmdGVyUGF0Y2goKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jU2F2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzY2FyZFNuYXBzaG90KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jU2F2aW5nKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IG51bGw7XG4gICAgfVxuICAgIENvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJzdGFydCBzYXZpbmcgb24gYSBiYWNrZ3JvdW5kIHRocmVhZFwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2FzeW5jU2F2aW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RvcnkgaXMgYWxyZWFkeSBpbiBiYWNrZ3JvdW5kIHNhdmluZyBtb2RlLCBjYW4ndCBjYWxsIENvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlIGFnYWluIVwiKTtcbiAgICAgICAgbGV0IHN0YXRlVG9TYXZlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fc3RhdGUuQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKTtcbiAgICAgICAgdGhpcy5fYXN5bmNTYXZpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RhdGVUb1NhdmU7XG4gICAgfVxuICAgIEJhY2tncm91bmRTYXZlQ29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFN0ZXAoKSB7XG4gICAgICAgIGxldCBzaG91bGRBZGRUb1N0cmVhbSA9IHRydWU7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRhaW5lciBjb250YWluZXJUb0VudGVyID0gcG9pbnRlci5SZXNvbHZlICgpIGFzIENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGNvbnRhaW5lclRvRW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5SZXNvbHZlKCksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIHdoaWxlIChjb250YWluZXJUb0VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLlZpc2l0Q29udGFpbmVyKGNvbnRhaW5lclRvRW50ZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gTm8gY29udGVudD8gdGhlIG1vc3Qgd2UgY2FuIGRvIGlzIHN0ZXAgcGFzdCBpdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclRvRW50ZXIuY29udGVudC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoY29udGFpbmVyVG9FbnRlcik7XG4gICAgICAgICAgICAvLyBjb250YWluZXJUb0VudGVyID0gcG9pbnRlci5SZXNvbHZlKCkgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgY29udGFpbmVyVG9FbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb2ludGVyLlJlc29sdmUoKSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuU3RlcCh0aGlzLnN0YXRlLmNhbGxTdGFjayk7XG4gICAgICAgIC8vIElzIHRoZSBjdXJyZW50IGNvbnRlbnQgb2JqZWN0OlxuICAgICAgICAvLyAgLSBOb3JtYWwgY29udGVudFxuICAgICAgICAvLyAgLSBPciBhIGxvZ2ljL2Zsb3cgc3RhdGVtZW50IC0gaWYgc28sIGRvIGl0XG4gICAgICAgIC8vIFN0b3AgZmxvdyBpZiB3ZSBoaXQgYSBzdGFjayBwb3Agd2hlbiB3ZSdyZSB1bmFibGUgdG8gcG9wIChlLmcuIHJldHVybi9kb25lIHN0YXRlbWVudCBpbiBrbm90XG4gICAgICAgIC8vIHRoYXQgd2FzIGRpdmVydGVkIHRvIHJhdGhlciB0aGFuIGNhbGxlZCBhcyBhIGZ1bmN0aW9uKVxuICAgICAgICBsZXQgY3VycmVudENvbnRlbnRPYmogPSBwb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgbGV0IGlzTG9naWNPckZsb3dDb250cm9sID0gdGhpcy5QZXJmb3JtTG9naWNBbmRGbG93Q29udHJvbChjdXJyZW50Q29udGVudE9iaik7XG4gICAgICAgIC8vIEhhcyBmbG93IGJlZW4gZm9yY2VkIHRvIGVuZCBieSBmbG93IGNvbnRyb2wgYWJvdmU/XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xvZ2ljT3JGbG93Q29udHJvbCkge1xuICAgICAgICAgICAgc2hvdWxkQWRkVG9TdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaG9pY2Ugd2l0aCBjb25kaXRpb24/XG4gICAgICAgIC8vIHZhciBjaG9pY2VQb2ludCA9IGN1cnJlbnRDb250ZW50T2JqIGFzIENob2ljZVBvaW50O1xuICAgICAgICBsZXQgY2hvaWNlUG9pbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIENob2ljZVBvaW50XzEuQ2hvaWNlUG9pbnQpO1xuICAgICAgICBpZiAoY2hvaWNlUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCBjaG9pY2UgPSB0aGlzLlByb2Nlc3NDaG9pY2UoY2hvaWNlUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGNob2ljZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5wdXNoKGNob2ljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGVudE9iaiA9IG51bGw7XG4gICAgICAgICAgICBzaG91bGRBZGRUb1N0cmVhbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIG5vIGNvbnRlbnQsIHRoZW4gaXQgd2lsbCBiZVxuICAgICAgICAvLyB0aGUgXCJjb250ZW50XCIgaXRzZWxmLCBidXQgd2Ugc2tpcCBvdmVyIGl0LlxuICAgICAgICBpZiAoY3VycmVudENvbnRlbnRPYmogaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIHNob3VsZEFkZFRvU3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udGVudCB0byBhZGQgdG8gZXZhbHVhdGlvbiBzdGFjayBvciB0aGUgb3V0cHV0IHN0cmVhbVxuICAgICAgICBpZiAoc2hvdWxkQWRkVG9TdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHB1c2hpbmcgYSB2YXJpYWJsZSBwb2ludGVyIG9udG8gdGhlIGV2YWx1YXRpb24gc3RhY2ssIGVuc3VyZSB0aGF0IGl0J3Mgc3BlY2lmaWNcbiAgICAgICAgICAgIC8vIHRvIG91ciBjdXJyZW50IChwb3NzaWJseSB0ZW1wb3JhcnkpIGNvbnRleHQgaW5kZXguIEFuZCBtYWtlIGEgY29weSBvZiB0aGUgcG9pbnRlclxuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSdyZSBub3QgZWRpdGluZyB0aGUgb3JpZ2luYWwgcnVudGltZSBvYmplY3QuXG4gICAgICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IGN1cnJlbnRDb250ZW50T2JqIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhclBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhclBvaW50ZXIgJiYgdmFyUG9pbnRlci5jb250ZXh0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IG9iamVjdCBzbyB3ZSdyZSBub3Qgb3ZlcndyaXRpbmcgdGhlIHN0b3J5J3Mgb3duIGRhdGFcbiAgICAgICAgICAgICAgICBsZXQgY29udGV4dElkeCA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNvbnRleHRGb3JWYXJpYWJsZU5hbWVkKHZhclBvaW50ZXIudmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGVudE9iaiA9IG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHZhclBvaW50ZXIudmFyaWFibGVOYW1lLCBjb250ZXh0SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cHJlc3Npb24gZXZhbHVhdGlvbiBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGN1cnJlbnRDb250ZW50T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE91dHB1dCBzdHJlYW0gY29udGVudCAoaS5lLiBub3QgZXhwcmVzc2lvbiBldmFsdWF0aW9uKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oY3VycmVudENvbnRlbnRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUgY29udGVudCBwb2ludGVyLCBmb2xsb3dpbmcgZGl2ZXJ0cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5OZXh0Q29udGVudCgpO1xuICAgICAgICAvLyBTdGFydGluZyBhIHRocmVhZCBzaG91bGQgYmUgZG9uZSBhZnRlciB0aGUgaW5jcmVtZW50IHRvIHRoZSBjb250ZW50IHBvaW50ZXIsXG4gICAgICAgIC8vIHNvIHRoYXQgd2hlbiByZXR1cm5pbmcgZnJvbSB0aGUgdGhyZWFkLCBpdCByZXR1cm5zIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoaXMgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIC8vIHZhciBjb250cm9sQ21kID0gY3VycmVudENvbnRlbnRPYmogYXMgO1xuICAgICAgICBsZXQgY29udHJvbENtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGVudE9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgIGlmIChjb250cm9sQ21kICYmXG4gICAgICAgICAgICBjb250cm9sQ21kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2hUaHJlYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaXNpdENvbnRhaW5lcihjb250YWluZXIsIGF0U3RhcnQpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY291bnRpbmdBdFN0YXJ0T25seSB8fCBhdFN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnZpc2l0c1Nob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLkluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzUG9pbnRlciA9IHRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNOdWxsIHx8IHBvaW50ZXIuaW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICghcHJldmlvdXNQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgLy8gQ29udGFpbmVyIHByZXZBbmNlc3RvciA9IHByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCkgYXMgQ29udGFpbmVyID8/IHByZXZpb3VzUG9pbnRlci5jb250YWluZXIgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkUHJldmlvdXNBbmNlc3RvciA9IHByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICBsZXQgcHJldkFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHJlc29sdmVkUHJldmlvdXNBbmNlc3RvciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB8fFxuICAgICAgICAgICAgICAgIFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwcmV2aW91c1BvaW50ZXIuY29udGFpbmVyLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgd2hpbGUgKHByZXZBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzLnB1c2gocHJldkFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2QW5jZXN0b3IgPSBwcmV2QW5jZXN0b3IucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBwcmV2QW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocHJldkFuY2VzdG9yLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudENoaWxkT2ZDb250YWluZXIgPSBwb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENvbnRhaW5lciBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDb250YWluZXJBbmNlc3RvciAmJlxuICAgICAgICAgICAgKHRoaXMuX3ByZXZDb250YWluZXJzLmluZGV4T2YoY3VycmVudENvbnRhaW5lckFuY2VzdG9yKSA8IDAgfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY291bnRpbmdBdFN0YXJ0T25seSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBhbmNlc3RvciBjb250YWluZXIgaXMgYmVpbmcgZW50ZXJlZCBhdCB0aGUgc3RhcnQsXG4gICAgICAgICAgICAvLyBieSBjaGVja2luZyB3aGV0aGVyIHRoZSBjaGlsZCBvYmplY3QgaXMgdGhlIGZpcnN0LlxuICAgICAgICAgICAgbGV0IGVudGVyaW5nQXRTdGFydCA9IGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5jb250ZW50Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9PSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY29udGVudFswXTtcbiAgICAgICAgICAgIC8vIE1hcmsgYSB2aXNpdCB0byB0aGlzIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5WaXNpdENvbnRhaW5lcihjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IsIGVudGVyaW5nQXRTdGFydCk7XG4gICAgICAgICAgICBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9IGN1cnJlbnRDb250YWluZXJBbmNlc3RvcjtcbiAgICAgICAgICAgIC8vIGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJvY2Vzc0Nob2ljZShjaG9pY2VQb2ludCkge1xuICAgICAgICBsZXQgc2hvd0Nob2ljZSA9IHRydWU7XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBjaG9pY2UgaWYgY2hvaWNlIHBvaW50IGRvZXNuJ3QgcGFzcyBjb25kaXRpb25hbFxuICAgICAgICBpZiAoY2hvaWNlUG9pbnQuaGFzQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uVmFsdWUgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLklzVHJ1dGh5KGNvbmRpdGlvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNob3dDaG9pY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRUZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IGNob2ljZU9ubHlUZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc0Nob2ljZU9ubHlDb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgY2hvaWNlT25seVN0clZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGxldCBjaG9pY2VPbmx5U3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBjaG9pY2VPbmx5VGV4dCA9IGNob2ljZU9ubHlTdHJWYWwudmFsdWUgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlUG9pbnQuaGFzU3RhcnRDb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgc3RhcnRTdHJWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBsZXQgc3RhcnRTdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHN0YXJ0VGV4dCA9IHN0YXJ0U3RyVmFsLnZhbHVlIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGNob2ljZSBpZiBwbGF5ZXIgaGFzIGFscmVhZHkgcmVhZCB0aGlzIGNvbnRlbnRcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lm9uY2VPbmx5KSB7XG4gICAgICAgICAgICBsZXQgdmlzaXRDb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjaG9pY2VQb2ludC5jaG9pY2VUYXJnZXQpO1xuICAgICAgICAgICAgaWYgKHZpc2l0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Nob2ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGdvIHRocm91Z2ggdGhlIGZ1bGwgcHJvY2VzcyBvZiBjcmVhdGluZyB0aGUgY2hvaWNlIGFib3ZlIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgY29uc3VtZSB0aGUgY29udGVudCBmb3IgaXQsIHNpbmNlIG90aGVyd2lzZSBpdCdsbFxuICAgICAgICAvLyBiZSBzaG93biBvbiB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgaWYgKCFzaG93Q2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZV8xLkNob2ljZSgpO1xuICAgICAgICBjaG9pY2UudGFyZ2V0UGF0aCA9IGNob2ljZVBvaW50LnBhdGhPbkNob2ljZTtcbiAgICAgICAgY2hvaWNlLnNvdXJjZVBhdGggPSBjaG9pY2VQb2ludC5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGNob2ljZS5pc0ludmlzaWJsZURlZmF1bHQgPSBjaG9pY2VQb2ludC5pc0ludmlzaWJsZURlZmF1bHQ7XG4gICAgICAgIGNob2ljZS50aHJlYWRBdEdlbmVyYXRpb24gPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5Gb3JrVGhyZWFkKCk7XG4gICAgICAgIGNob2ljZS50ZXh0ID0gKHN0YXJ0VGV4dCArIGNob2ljZU9ubHlUZXh0KS5yZXBsYWNlKC9eWyBcXHRdK3xbIFxcdF0rJC9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICB9XG4gICAgSXNUcnV0aHkob2JqKSB7XG4gICAgICAgIGxldCB0cnV0aHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBvYmo7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXZUYXJnZXQgPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlNob3VsZG4ndCB1c2UgYSBkaXZlcnQgdGFyZ2V0ICh0byBcIiArXG4gICAgICAgICAgICAgICAgICAgIGRpdlRhcmdldC50YXJnZXRQYXRoICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIGFzIGEgY29uZGl0aW9uYWwgdmFsdWUuIERpZCB5b3UgaW50ZW5kIGEgZnVuY3Rpb24gY2FsbCAnbGlrZVRoaXMoKScgb3IgYSByZWFkIGNvdW50IGNoZWNrICdsaWtlVGhpcyc/IChubyBhcnJvd3MpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWwuaXNUcnV0aHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydXRoeTtcbiAgICB9XG4gICAgUGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2woY29udGVudE9iaikge1xuICAgICAgICBpZiAoY29udGVudE9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGl2ZXJ0XG4gICAgICAgIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgRGl2ZXJ0XzEuRGl2ZXJ0KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudERpdmVydCA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBpZiAoY3VycmVudERpdmVydC5pc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvblZhbHVlID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAvLyBGYWxzZSBjb25kaXRpb25hbD8gQ2FuY2VsIGRpdmVydFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Jc1RydXRoeShjb25kaXRpb25WYWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFyTmFtZSA9IGN1cnJlbnREaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgICAgIGxldCB2YXJDb250ZW50cyA9IHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyQ29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiVHJpZWQgdG8gZGl2ZXJ0IHVzaW5nIGEgdGFyZ2V0IGZyb20gYSB2YXJpYWJsZSB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZCAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFyQ29udGVudHMgaW5zdGFuY2VvZiBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgaW50Q29udGVudCA9IHZhckNvbnRlbnRzIGFzIEludFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50Q29udGVudCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YXJDb250ZW50cywgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlRyaWVkIHRvIGRpdmVydCB0byBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUsIGJ1dCB0aGUgdmFyaWFibGUgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpIGRpZG4ndCBjb250YWluIGEgZGl2ZXJ0IHRhcmdldCwgaXQgXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRDb250ZW50IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSAmJiBpbnRDb250ZW50LnZhbHVlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBcIndhcyBlbXB0eS9udWxsICh0aGUgdmFsdWUgMCkuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gXCJjb250YWluZWQgJ1wiICsgdmFyQ29udGVudHMgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFyQ29udGVudHMsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5Qb2ludGVyQXRQYXRoKHRhcmdldC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnREaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuQ2FsbEV4dGVybmFsRnVuY3Rpb24oY3VycmVudERpdmVydC50YXJnZXRQYXRoU3RyaW5nLCBjdXJyZW50RGl2ZXJ0LmV4dGVybmFsQXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IGN1cnJlbnREaXZlcnQudGFyZ2V0UG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudERpdmVydC5wdXNoZXNUb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChjdXJyZW50RGl2ZXJ0LnN0YWNrUHVzaFR5cGUsIHVuZGVmaW5lZCwgdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwgJiYgIWN1cnJlbnREaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXZlcnQuZGVidWdNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJEaXZlcnQgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXZlcnQuZGVidWdNZXRhZGF0YS5zb3VyY2VOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJEaXZlcnQgcmVzb2x1dGlvbiBmYWlsZWQ6IFwiICsgY3VycmVudERpdmVydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQvZW5kIGFuIGV4cHJlc3Npb24gZXZhbHVhdGlvbj8gT3IgcHJpbnQgb3V0IHRoZSByZXN1bHQ/XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKSB7XG4gICAgICAgICAgICBsZXQgZXZhbENvbW1hbmQgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgc3dpdGNoIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gZmFsc2UsIFwiQWxyZWFkeSBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24/XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbEVuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID09PSB0cnVlLCBcIk5vdCBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24gbW9kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsT3V0cHV0OlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiB0dXJuZWQgb3V0IHRvIGJlIGVtcHR5LCB0aGVyZSBtYXkgbm90IGJlIGFueXRoaW5nIG9uIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbnMgbWF5IGV2YWx1YXRlIHRvIFZvaWQsIGluIHdoaWNoIGNhc2Ugd2Ugc2tpcCBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG91dHB1dCBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSByZWFsbHkgYWx3YXlzIGJsYW5rZXQgY29udmVydCB0byBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgd291bGQgYmUgb2theSB0byBoYXZlIG51bWJlcnMgaW4gdGhlIG91dHB1dCBzdHJlYW0gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwcm9ibGVtIGlzIHdoZW4gZXhwb3J0aW5nIHRleHQgZm9yIHZpZXdpbmcsIGl0IHNraXBzIG92ZXIgbnVtYmVycyBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShvdXRwdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vT3A6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayh0aGlzLnN0YXRlLlBlZWtFdmFsdWF0aW9uU3RhY2soKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BUdW5uZWw6XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3BUeXBlID0gZXZhbENvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIDogUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcHBlZCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IHBvcHBlZCBhcyBEaXZlcnRUYXJnZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvcHBlZCwgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChwb3BwZWQgaW5zdGFuY2VvZiBWb2lkXzEuVm9pZCwgXCJFeHBlY3RlZCB2b2lkIGlmIC0+LT4gZG9lc24ndCBvdmVycmlkZSB0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgIT0gcG9wVHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuc2V0KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbiwgXCJmdW5jdGlvbiByZXR1cm4gc3RhdGVtZW50ICh+IHJldHVybilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5zZXQoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCwgXCJ0dW5uZWwgb253YXJkcyBzdGF0ZW1lbnQgKC0+LT4pXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV4cGVjdGVkID0gbmFtZXMuZ2V0KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFwiZW5kIG9mIGZsb3cgKC0+IEVORCBvciBjaG9pY2UpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSBcIkZvdW5kIFwiICsgbmFtZXMuZ2V0KHBvcFR5cGUpICsgXCIsIHdoZW4gZXhwZWN0ZWQgXCIgKyBleHBlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IHRoaXMuUG9pbnRlckF0UGF0aChvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGV2YWxDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID09PSB0cnVlLCBcIkV4cGVjdGVkIHRvIGJlIGluIGFuIGV4cHJlc3Npb24gd2hlbiBldmFsdWF0aW5nIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZFN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRTdGFja0ZvclN0cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0Q291bnRDb25zdW1lZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q291bnRDb25zdW1lZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGNvbW1hbmQgPSBvYmogYXMgQ29udHJvbENvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0YWNrRm9yU3RyaW5nLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdW1lIHRoZSBjb250ZW50IHRoYXQgd2FzIHByb2R1Y2VkIGZvciB0aGlzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcEZyb21PdXRwdXRTdHJlYW0ob3V0cHV0Q291bnRDb25zdW1lZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBDIyB2ZXJzaW9uIHVzZXMgYSBTdGFjayBmb3IgY29udGVudFN0YWNrRm9yU3RyaW5nLCBidXQgd2UncmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYSBzaW1wbGUgYXJyYXksIHNvIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdCBiZWZvcmUgdXNpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFN0YWNrRm9yU3RyaW5nID0gY29udGVudFN0YWNrRm9yU3RyaW5nLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgc3RyaW5nIG91dCBvZiB0aGUgY29udGVudCB3ZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29udGVudFN0YWNrRm9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoYy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdG8gZXhwcmVzc2lvbiBldmFsdWF0aW9uIChmcm9tIGNvbnRlbnQgbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHNiLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50OlxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hvaWNlQ291bnQgPSB0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY2hvaWNlQ291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUodGhpcy5zdGF0ZS5jdXJyZW50VHVybkluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZTpcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHRyYU5vdGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFOb3RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSByZWFkIGNvdW50ICgna25vdF9uYW1lJykgaW5zdGVhZCBvZiBhIHRhcmdldCAoJy0+IGtub3RfbmFtZScpP1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlRVUk5TX1NJTkNFIC8gUkVBRF9DT1VOVCBleHBlY3RlZCBhIGRpdmVydCB0YXJnZXQgKGtub3QsIHN0aXRjaCwgbGFiZWwgbmFtZSksIGJ1dCBzYXcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFOb3RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBkaXZlcnRUYXJnZXQgPSB0YXJnZXQgYXMgRGl2ZXJ0VGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXZlcnRUYXJnZXQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0YXJnZXQsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgY29udGFpbmVyID0gQ29udGVudEF0UGF0aCAoZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgpLmNvcnJlY3RPYmogYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuQ29udGVudEF0UGF0aChkaXZlcnRUYXJnZXQudGFyZ2V0UGF0aCkuY29ycmVjdE9iaiwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVpdGhlckNvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSB0aGlzLnN0YXRlLlR1cm5zU2luY2VGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRhaW5lciBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxDb21tYW5kLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGxvb2t1cCBhdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGVpdGhlckNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SYW5kb206IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heEludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkludCA9PSBudWxsIHx8IG1pbkludCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtaW5pbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SW50ID09IG51bGwgfHwgbWluSW50IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG1heGltdW0gcGFyYW1ldGVyIG9mIFJBTkRPTShtaW4sIG1heClcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhJbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWF4SW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5JbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWluSW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21SYW5nZSA9IG1heEludC52YWx1ZSAtIG1pbkludC52YWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5kb21SYW5nZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlJBTkRPTSB3YXMgY2FsbGVkIHdpdGggbWluaW11bSBhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSW50LnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBhbmQgbWF4aW11bSBhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SW50LnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4gVGhlIG1heGltdW0gbXVzdCBiZSBsYXJnZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRTZWVkID0gdGhpcy5zdGF0ZS5zdG9yeVNlZWQgKyB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tID0gbmV3IFBSTkdfMS5QUk5HKHJlc3VsdFNlZWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFJhbmRvbSA9IHJhbmRvbS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaG9zZW5WYWx1ZSA9IChuZXh0UmFuZG9tICUgcmFuZG9tUmFuZ2UpICsgbWluSW50LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY2hvc2VuVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCByYW5kb20gbnVtYmVyIChyYXRoZXIgdGhhbiBrZWVwaW5nIHRoZSBSYW5kb20gb2JqZWN0IGFyb3VuZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSA9IG5leHRSYW5kb207XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVkID09IG51bGwgfHwgc2VlZCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBTRUVEX1JBTkRPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWluSW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RvcnlTZWVkID0gc2VlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVm9pZF8xLlZvaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5WaXNpdEluZGV4OlxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXIpIC0gMTsgLy8gaW5kZXggbm90IGNvdW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXg6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaHVmZmxlSW5kZXggPSB0aGlzLk5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoc2h1ZmZsZUluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBpbiBtYWluIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmU6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG1heSBleGlzdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAvLyBhY3Qgb2YgY3JlYXRpbmcgdGhlIHRocmVhZCwgb3IgaW4gdGhlIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGluZyB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gbm9ybWFsIGZsb3cgLSBhbGxvdyBzYWZlIGV4aXQgd2l0aG91dCB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGZsb3cgaW4gY3VycmVudCB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGZsb3cgdG8gZW5kIGNvbXBsZXRlbHlcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLkZvcmNlRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludDpcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGludFZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBJbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGxpc3ROYW1lVmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdE5hbWVWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludFZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJQYXNzZWQgbm9uLWludGVnZXIgd2hlbiBjcmVhdGluZyBhIGxpc3QgZWxlbWVudCBmcm9tIGEgbnVtZXJpY2FsIHZhbHVlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZ2VuZXJhdGVkTGlzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdERlZmluaXRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMubGlzdERlZmluaXRpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZExpc3REZWYgPSB0aGlzLmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihsaXN0TmFtZVZhbC52YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZExpc3REZWYuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEl0ZW0gPSBmb3VuZExpc3REZWYucmVzdWx0LlRyeUdldEl0ZW1XaXRoVmFsdWUoaW50VmFsLnZhbHVlLCBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRJdGVtLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZExpc3RWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShmb3VuZEl0ZW0ucmVzdWx0LCBpbnRWYWwudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJGYWlsZWQgdG8gZmluZCBMSVNUIGNhbGxlZCBcIiArIGxpc3ROYW1lVmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTGlzdFZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRMaXN0VmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGdlbmVyYXRlZExpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZ2U6XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXggPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW4gPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciB0YXJnZXRMaXN0ID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIExpc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldExpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGlzdCA9PT0gbnVsbCB8fCBtaW4gPT09IG51bGwgfHwgbWF4ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBsaXN0LCBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciBMSVNUX1JBTkdFXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGlzdC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0YXJnZXRMaXN0LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0YXJnZXRMaXN0LnZhbHVlLkxpc3RXaXRoU3ViUmFuZ2UobWluLnZhbHVlT2JqZWN0LCBtYXgudmFsdWVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbToge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdFZhbCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0VmFsID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBsaXN0IGZvciBMSVNUX1JBTkRPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBsaXN0VmFsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5Db3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBpbmRleCBmb3IgdGhlIGVsZW1lbnQgdG8gdGFrZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFNlZWQgPSB0aGlzLnN0YXRlLnN0b3J5U2VlZCArIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb207XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tID0gbmV3IFBSTkdfMS5QUk5HKHJlc3VsdFNlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRSYW5kb20gPSByYW5kb20ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RJdGVtSW5kZXggPSBuZXh0UmFuZG9tICUgbGlzdC5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYml0IGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQyMgY29kZSwgc2luY2UgaXRlcmF0b3JzIGRvIG5vdCB3b3JrIGluIHRoZSBzYW1lIHdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB3ZSBpdGVyYXRlIGxpc3RJdGVtSW5kZXggLSAxIHRpbWVzLCBjYWxsaW5nIG5leHQoKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsaXN0SXRlbUluZGV4LXRoIHRpbWUgaXMgbWFkZSBvdXRzaWRlIG9mIHRoZSBsb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gcmV0cmlldmUgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RFbnVtZXJhdG9yID0gbGlzdC5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaXN0SXRlbUluZGV4IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEVudW1lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbGlzdEVudW1lcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS2V5OiBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkodmFsdWVbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW4gbGlzdCBpcyBzaW1wbHkgdGhlIG9yaWdpbiBvZiB0aGUgb25lIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdChyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QuQWRkKHJhbmRvbUl0ZW0uS2V5LCByYW5kb21JdGVtLlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSBuZXh0UmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5MaXN0VmFsdWUobmV3TGlzdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcInVuaGFuZGxlZCBDb250cm9sQ29tbWFuZDogXCIgKyBldmFsQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFyaWFibGUgYXNzaWdubWVudFxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBsZXQgdmFyQXNzID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGxldCBhc3NpZ25lZFZhbCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkFzc2lnbih2YXJBc3MsIGFzc2lnbmVkVmFsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgbGV0IHZhclJlZiA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgZm91bmRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCByZWFkIGNvdW50IHZhbHVlXG4gICAgICAgICAgICBpZiAodmFyUmVmLnBhdGhGb3JDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHZhclJlZi5jb250YWluZXJGb3JDb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBmb3VuZFZhbHVlID0gbmV3IFZhbHVlXzEuSW50VmFsdWUoY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJWYXJpYWJsZSBub3QgZm91bmQ6ICdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJSZWYubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicuIFVzaW5nIGRlZmF1bHQgdmFsdWUgb2YgMCAoZmFsc2UpLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCB0ZW1wb3JhcnkgdmFyaWFibGVzIGlmIHRoZSBkZWNsYXJhdGlvbiBoYXNuJ3QgeWV0IGJlZW4gaGl0LiBHbG9iYWxzIGFyZSBhbHdheXMgZ2l2ZW4gYSBkZWZhdWx0IHZhbHVlIG9uIGxvYWQgaWYgYSB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzYXZlIHN0YXRlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkludFZhbHVlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhmb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5hdGl2ZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGxldCBmdW5jID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGxldCBmdW5jUGFyYW1zID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soZnVuYy5udW1iZXJPZlBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZ1bmMuQ2FsbChmdW5jUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gY29udHJvbCBjb250ZW50LCBtdXN0IGJlIG9yZGluYXJ5IGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDaG9vc2VQYXRoU3RyaW5nKHBhdGgsIHJlc2V0Q2FsbHN0YWNrID0gdHJ1ZSwgYXJncyA9IFtdKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgQ2hvb3NlUGF0aFN0cmluZyByaWdodCBub3dcIik7XG4gICAgICAgIGlmIChyZXNldENhbGxzdGFjaykge1xuICAgICAgICAgICAgdGhpcy5SZXNldENhbGxzdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmNEZXRhaWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jRGV0YWlsID0gXCIoXCIgKyBjb250YWluZXIucGF0aC50b1N0cmluZygpICsgXCIpIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9yeSB3YXMgcnVubmluZyBhIGZ1bmN0aW9uIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY0RldGFpbCArXG4gICAgICAgICAgICAgICAgICAgIFwid2hlbiB5b3UgY2FsbGVkIENob29zZVBhdGhTdHJpbmcoXCIgK1xuICAgICAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIC0gdGhpcyBpcyBhbG1vc3QgY2VydGFpbmx5IG5vdCBub3Qgd2hhdCB5b3Ugd2FudCEgRnVsbCBzdGFjayB0cmFjZTogXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soYXJncyk7XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChuZXcgUGF0aF8xLlBhdGgocGF0aCkpO1xuICAgIH1cbiAgICBJZkFzeW5jV2VDYW50KGFjdGl2aXR5U3RyKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgXCIgK1xuICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RyICtcbiAgICAgICAgICAgICAgICBcIi4gU3RvcnkgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIENvbnRpbnVlQXN5bmMoKS4gTWFrZSBtb3JlIENvbnRpbnVlQXN5bmMoKSBjYWxscyBvciBhIHNpbmdsZSBDb250aW51ZSgpIGNhbGwgYmVmb3JlaGFuZC5cIik7XG4gICAgfVxuICAgIENob29zZVBhdGgocCwgaW5jcmVtZW50aW5nVHVybkluZGV4ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0YXRlLlNldENob3NlblBhdGgocCwgaW5jcmVtZW50aW5nVHVybkluZGV4KTtcbiAgICAgICAgLy8gVGFrZSBhIG5vdGUgb2YgbmV3bHkgdmlzaXRlZCBjb250YWluZXJzIGZvciByZWFkIGNvdW50cyBldGNcbiAgICAgICAgdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKTtcbiAgICB9XG4gICAgQ2hvb3NlQ2hvaWNlSW5kZXgoY2hvaWNlSWR4KSB7XG4gICAgICAgIGNob2ljZUlkeCA9IGNob2ljZUlkeDtcbiAgICAgICAgbGV0IGNob2ljZXMgPSB0aGlzLmN1cnJlbnRDaG9pY2VzO1xuICAgICAgICB0aGlzLkFzc2VydChjaG9pY2VJZHggPj0gMCAmJiBjaG9pY2VJZHggPCBjaG9pY2VzLmxlbmd0aCwgXCJjaG9pY2Ugb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgY2hvaWNlVG9DaG9vc2UgPSBjaG9pY2VzW2Nob2ljZUlkeF07XG4gICAgICAgIGlmIChjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZCA9IGNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvbjtcbiAgICAgICAgdGhpcy5DaG9vc2VQYXRoKGNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBIYXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jdGlvbk5hbWUpICE9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFdmFsdWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgYXJncyA9IFtdLCByZXR1cm5UZXh0T3V0cHV0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gRXZhbHVhdGVGdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IHRoYW4gdGhlIEMjIHZlcnNpb24uXG4gICAgICAgIC8vIEluIEMjLCB5b3UgY2FuIHBhc3MgYSAoc2Vjb25kKSBwYXJhbWV0ZXIgYG91dCB0ZXh0T3V0cHV0YCB0byBnZXQgdGhlXG4gICAgICAgIC8vIHRleHQgb3V0cHV0dGVkIGJ5IHRoZSBmdW5jdGlvbi4gVGhpcyBpcyBub3QgcG9zc2libGUgaW4ganMuIEluc3RlYWQsXG4gICAgICAgIC8vIHdlIG1haW50YWluIHRoZSByZWd1bGFyIHNpZ25hdHVyZSAoZnVuY3Rpb25OYW1lLCBhcmdzKSwgcGx1cyBhblxuICAgICAgICAvLyBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIgcmV0dXJuVGV4dE91dHB1dC4gSWYgc2V0IHRvIHRydWUsIHdlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIGJvdGggdGhlIHRleHRPdXRwdXQgYW5kIHRoZSByZXR1cm5lZCB2YWx1ZSwgYXMgYW4gb2JqZWN0LlxuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJldmFsdWF0ZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlzIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25OYW1lID09IFwiXCIgfHwgZnVuY3Rpb25OYW1lLnRyaW0oKSA9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBlbXB0eSBvciB3aGl0ZSBzcGFjZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmNDb250YWluZXIgPSB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jdGlvbk5hbWUpO1xuICAgICAgICBpZiAoZnVuY0NvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBkb2Vzbid0IGV4aXN0OiAnXCIgKyBmdW5jdGlvbk5hbWUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dFN0cmVhbUJlZm9yZSA9IFtdO1xuICAgICAgICBvdXRwdXRTdHJlYW1CZWZvcmUucHVzaC5hcHBseShvdXRwdXRTdHJlYW1CZWZvcmUsIHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5TdGFydEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKGZ1bmNDb250YWluZXIsIGFyZ3MpO1xuICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgZnVuY3Rpb24sIGFuZCBjb2xsZWN0IHRoZSBzdHJpbmcgb3V0cHV0XG4gICAgICAgIGxldCBzdHJpbmdPdXRwdXQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIHN0cmluZ091dHB1dC5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dE91dHB1dCA9IHN0cmluZ091dHB1dC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5SZXNldE91dHB1dChvdXRwdXRTdHJlYW1CZWZvcmUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdGF0ZS5Db21wbGV0ZUZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCk7XG4gICAgICAgIHJldHVybiByZXR1cm5UZXh0T3V0cHV0ID8geyByZXR1cm5lZDogcmVzdWx0LCBvdXRwdXQ6IHRleHRPdXRwdXQgfSA6IHJlc3VsdDtcbiAgICB9XG4gICAgRXZhbHVhdGVFeHByZXNzaW9uKGV4cHJDb250YWluZXIpIHtcbiAgICAgICAgbGV0IHN0YXJ0Q2FsbFN0YWNrSGVpZ2h0ID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID0gZXhwckNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5zdGF0ZS5Hb1RvU3RhcnQoKTtcbiAgICAgICAgbGV0IGV2YWxTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgICAgdGhpcy5Db250aW51ZSgpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgZmFsbGVuIG9mZiB0aGUgZW5kIG9mIHRoZSBDb250YWluZXIsIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGF1dG8tcG9wcGVkLCBidXQganVzdCBpbiBjYXNlIHdlIGRpZG4ndCBmb3Igc29tZSByZWFzb24sXG4gICAgICAgIC8vIG1hbnVhbGx5IHBvcCB0byByZXN0b3JlIHRoZSBzdGF0ZSAoaW5jbHVkaW5nIGN1cnJlbnRQYXRoKS5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aCA+IHN0YXJ0Q2FsbFN0YWNrSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlBvcENhbGxTdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZFN0YWNrSGVpZ2h0ID4gZXZhbFN0YWNrSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lLCBudW1iZXJPZkFyZ3VtZW50cykge1xuICAgICAgICBpZiAoZnVuY05hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZnVuY05hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLl9leHRlcm5hbHMuZ2V0KGZ1bmNOYW1lKTtcbiAgICAgICAgbGV0IGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgPSBudWxsO1xuICAgICAgICBsZXQgZm91bmRFeHRlcm5hbCA9IHR5cGVvZiBmdW5jICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAvLyBUcnkgdG8gdXNlIGZhbGxiYWNrIGZ1bmN0aW9uP1xuICAgICAgICBpZiAoIWZvdW5kRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgPSB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lciAhPT0gbnVsbCwgXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQsIGFuZCBmYWxsYmFjayBpbmsgZnVuY3Rpb24gY291bGQgbm90IGJlIGZvdW5kLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBEaXZlcnQgZGlyZWN0IGludG8gZmFsbGJhY2sgZnVuY3Rpb24gYW5kIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbiwgdW5kZWZpbmVkLCB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChmYWxzZSwgXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQgKGFuZCBpbmsgZmFsbGJhY2tzIGRpc2FibGVkKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wIGFyZ3VtZW50c1xuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQXJndW1lbnRzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHZhciBwb3BwZWRPYmogPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgVmFsdWU7XG4gICAgICAgICAgICBsZXQgcG9wcGVkT2JqID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWVPYmogPSBwb3BwZWRPYmoudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICBhcmdzLnB1c2godmFsdWVPYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldmVyc2UgYXJndW1lbnRzIGZyb20gdGhlIG9yZGVyIHRoZXkgd2VyZSBwb3BwZWQsXG4gICAgICAgIC8vIHNvIHRoZXkncmUgdGhlIHJpZ2h0IHdheSByb3VuZCBhZ2Fpbi5cbiAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIC8vIFJ1biB0aGUgZnVuY3Rpb24hXG4gICAgICAgIGxldCBmdW5jUmVzdWx0ID0gZnVuYyhhcmdzKTtcbiAgICAgICAgLy8gQ29udmVydCByZXR1cm4gdmFsdWUgKGlmIGFueSkgdG8gdGhlIGEgdHlwZSB0aGF0IHRoZSBpbmsgZW5naW5lIGNhbiB1c2VcbiAgICAgICAgbGV0IHJldHVybk9iaiA9IG51bGw7XG4gICAgICAgIGlmIChmdW5jUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybk9iaiA9IFZhbHVlXzEuVmFsdWUuQ3JlYXRlKGZ1bmNSZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQocmV0dXJuT2JqICE9PSBudWxsLCBcIkNvdWxkIG5vdCBjcmVhdGUgaW5rIHZhbHVlIGZyb20gcmV0dXJuZWQgb2JqZWN0IG9mIHR5cGUgXCIgK1xuICAgICAgICAgICAgICAgIHR5cGVvZiBmdW5jUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk9iaiA9IG5ldyBWb2lkXzEuVm9pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhyZXR1cm5PYmopO1xuICAgIH1cbiAgICBCaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiYmluZCBhbiBleHRlcm5hbCBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5Bc3NlcnQoIXRoaXMuX2V4dGVybmFscy5oYXMoZnVuY05hbWUpLCBcIkZ1bmN0aW9uICdcIiArIGZ1bmNOYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXCIpO1xuICAgICAgICB0aGlzLl9leHRlcm5hbHMuc2V0KGZ1bmNOYW1lLCBmdW5jKTtcbiAgICB9XG4gICAgVHJ5Q29lcmNlKHZhbHVlKSB7XG4gICAgICAgIC8vIFdlJ3JlIHNraXBwaW5nIHR5cGUgY29lcmNpdGlvbiBpbiB0aGlzIGltcGxlbWVudGF0aW9uLiBGaXJzdCBvZiwganNcbiAgICAgICAgLy8gaXMgbG9vc2VseSB0eXBlZCwgc28gaXQncyBub3QgdGhhdCBpbXBvcnRhbnQuIFNlY29uZGx5LCB0aGVyZSBpcyBub1xuICAgICAgICAvLyBjbGVhbiB3YXkgKEFGQUlLKSBmb3IgdGhlIHVzZXIgdG8gZGVzY3JpYmUgd2hhdCB0eXBlIG9mIHBhcmFtZXRlcnNcbiAgICAgICAgLy8gdGhleSBleHBlY3QuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgQmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5Bc3NlcnQoZnVuYyAhPSBudWxsLCBcIkNhbid0IGJpbmQgYSBudWxsIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChmdW5jTmFtZSwgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KGFyZ3MubGVuZ3RoID49IGZ1bmMubGVuZ3RoLCBcIkV4dGVybmFsIGZ1bmN0aW9uIGV4cGVjdGVkIFwiICsgZnVuYy5sZW5ndGggKyBcIiBhcmd1bWVudHNcIik7XG4gICAgICAgICAgICBsZXQgY29lcmNlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2VyY2VkQXJnc1tpXSA9IHRoaXMuVHJ5Q29lcmNlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgY29lcmNlZEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW5iaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJ1bmJpbmQgYW4gZXh0ZXJuYWwgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fZXh0ZXJuYWxzLmhhcyhmdW5jTmFtZSksIFwiRnVuY3Rpb24gJ1wiICsgZnVuY05hbWUgKyBcIicgaGFzIG5vdCBiZWVuIGJvdW5kLlwiKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzLmRlbGV0ZShmdW5jTmFtZSk7XG4gICAgfVxuICAgIFZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncygpIHtcbiAgICAgICAgbGV0IGMgPSBudWxsO1xuICAgICAgICBsZXQgbyA9IG51bGw7XG4gICAgICAgIGxldCBtaXNzaW5nRXh0ZXJuYWxzID0gYXJndW1lbnRzWzFdIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgYyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0XzEuSW5rT2JqZWN0KSB7XG4gICAgICAgICAgICBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBudWxsICYmIG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLCBtaXNzaW5nRXh0ZXJuYWxzKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICAvLyBObyBwcm9ibGVtISBWYWxpZGF0aW9uIGNvbXBsZXRlXG4gICAgICAgICAgICBpZiAobWlzc2luZ0V4dGVybmFscy5zaXplID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkVycm9yOiBNaXNzaW5nIGZ1bmN0aW9uIGJpbmRpbmcgZm9yIGV4dGVybmFsXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBtaXNzaW5nRXh0ZXJuYWxzLnNpemUgPiAxID8gXCJzXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCI6ICdcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IEFycmF5LmZyb20obWlzc2luZ0V4dGVybmFscykuam9pbihcIicsICdcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIicgXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSB0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICA/IFwiLCBhbmQgbm8gZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGZvdW5kLlwiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgKGluayBmYWxsYmFja3MgZGlzYWJsZWQpXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5FcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlubmVyQ29udGVudCBvZiBjLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCB8fCAhY29udGFpbmVyLmhhc1ZhbGlkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoaW5uZXJDb250ZW50LCBtaXNzaW5nRXh0ZXJuYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiBjLm5hbWVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KSwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobyAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG8sIERpdmVydF8xLkRpdmVydCk7XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0ICYmIGRpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZztcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZXh0ZXJuYWxzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmYWxsYmFja0ZvdW5kID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuaGFzKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmYWxsYmFja0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0V4dGVybmFscy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nRXh0ZXJuYWxzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZlVmFyaWFibGUodmFyaWFibGVOYW1lLCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJvYnNlcnZlIGEgbmV3IHZhcmlhYmxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodmFyaWFibGVOYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IG9ic2VydmUgdmFyaWFibGUgJ1wiICtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWUgK1xuICAgICAgICAgICAgICAgIFwiJyBiZWNhdXNlIGl0IHdhc24ndCBkZWNsYXJlZCBpbiB0aGUgaW5rIHN0b3J5LlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodmFyaWFibGVOYW1lKS5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLnNldCh2YXJpYWJsZU5hbWUsIFtvYnNlcnZlcl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9ic2VydmVWYXJpYWJsZXModmFyaWFibGVOYW1lcywgb2JzZXJ2ZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFyaWFibGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuT2JzZXJ2ZVZhcmlhYmxlKHZhcmlhYmxlTmFtZXNbaV0sIG9ic2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVtb3ZlVmFyaWFibGVPYnNlcnZlcihvYnNlcnZlciwgc3BlY2lmaWNWYXJpYWJsZU5hbWUpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwicmVtb3ZlIGEgdmFyaWFibGUgb2JzZXJ2ZXJcIik7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpY1ZhcmlhYmxlTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyhzcGVjaWZpY1ZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHNwZWNpZmljVmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZGVsZXRlKHNwZWNpZmljVmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBrZXlzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMua2V5cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFyTmFtZSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50KHZhcmlhYmxlTmFtZSwgbmV3VmFsdWVPYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoIShuZXdWYWx1ZU9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIHZhcmlhYmxlIHRoYXQgaXNuJ3QgYSBzdGFuZGFyZCB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIHZhbCA9IG5ld1ZhbHVlT2JqIGFzIFZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG5ld1ZhbHVlT2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyKHZhcmlhYmxlTmFtZSwgdmFsLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2xvYmFsVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhcIlwiKTtcbiAgICB9XG4gICAgVGFnc0ZvckNvbnRlbnRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHBhdGgpO1xuICAgIH1cbiAgICBUYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZyk7XG4gICAgICAgIGxldCBmbG93Q29udGFpbmVyID0gdGhpcy5Db250ZW50QXRQYXRoKHBhdGgpLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGZsb3dDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZmxvd0NvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0Q29udGVudCA9IGZsb3dDb250YWluZXIuY29udGVudFswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdENvbnRlbnQgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpXG4gICAgICAgICAgICAgICAgZmxvd0NvbnRhaW5lciA9IGZpcnN0Q29udGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFncyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGMgb2YgZmxvd0NvbnRhaW5lci5jb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgdGFnID0gYyBhcyBSdW50aW1lLlRhZztcbiAgICAgICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoYywgVGFnXzEuVGFnKTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFncyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0YWdzID0gW107XG4gICAgICAgICAgICAgICAgdGFncy5wdXNoKHRhZy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgMCwgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCAwLCB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLlJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBOZXh0Q29udGVudCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLlZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VjY2Vzc2Z1bFBvaW50ZXJJbmNyZW1lbnQgPSB0aGlzLkluY3JlbWVudENvbnRlbnRQb2ludGVyKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc2Z1bFBvaW50ZXJJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBkaWRQb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3AoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZvaWRfMS5Wb2lkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWRQb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCk7XG4gICAgICAgICAgICAgICAgZGlkUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkUG9wICYmICF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuTmV4dENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJbmNyZW1lbnRDb250ZW50UG9pbnRlcigpIHtcbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxJbmNyZW1lbnQgPSB0cnVlO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgcG9pbnRlci5pbmRleCsrO1xuICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBvaW50ZXIuaW5kZXggPj0gcG9pbnRlci5jb250YWluZXIuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxJbmNyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENvbnRhaW5lciBuZXh0QW5jZXN0b3IgPSBwb2ludGVyLmNvbnRhaW5lci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgbGV0IG5leHRBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb2ludGVyLmNvbnRhaW5lci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobmV4dEFuY2VzdG9yIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4SW5BbmNlc3RvciA9IG5leHRBbmNlc3Rvci5jb250ZW50LmluZGV4T2YocG9pbnRlci5jb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4SW5BbmNlc3RvciA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IG5ldyBQb2ludGVyXzEuUG9pbnRlcihuZXh0QW5jZXN0b3IsIGluZGV4SW5BbmNlc3Rvcik7XG4gICAgICAgICAgICBwb2ludGVyLmluZGV4Kys7XG4gICAgICAgICAgICBzdWNjZXNzZnVsSW5jcmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWNjZXNzZnVsSW5jcmVtZW50KVxuICAgICAgICAgICAgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgIHJldHVybiBzdWNjZXNzZnVsSW5jcmVtZW50O1xuICAgIH1cbiAgICBUcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCkge1xuICAgICAgICBsZXQgYWxsQ2hvaWNlcyA9IHRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzO1xuICAgICAgICBsZXQgaW52aXNpYmxlQ2hvaWNlcyA9IGFsbENob2ljZXMuZmlsdGVyKChjKSA9PiBjLmlzSW52aXNpYmxlRGVmYXVsdCk7XG4gICAgICAgIGlmIChpbnZpc2libGVDaG9pY2VzLmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhbGxDaG9pY2VzLmxlbmd0aCA+IGludmlzaWJsZUNob2ljZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hvaWNlID0gaW52aXNpYmxlQ2hvaWNlc1swXTtcbiAgICAgICAgaWYgKGNob2ljZS50YXJnZXRQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZS50aHJlYWRBdEdlbmVyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZCA9IGNob2ljZS50aHJlYWRBdEdlbmVyYXRpb247XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChjaG9pY2UudGFyZ2V0UGF0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTmV4dFNlcXVlbmNlU2h1ZmZsZUluZGV4KCkge1xuICAgICAgICAvLyB2YXIgbnVtRWxlbWVudHNJbnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgIGxldCBudW1FbGVtZW50c0ludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgaWYgKCEobnVtRWxlbWVudHNJbnRWYWwgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5FcnJvcihcImV4cGVjdGVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBzZXF1ZW5jZSBmb3Igc2h1ZmZsZSBpbmRleFwiKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXFDb250YWluZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHNlcUNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzZXFDb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgaWYgKG51bUVsZW1lbnRzSW50VmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm51bUVsZW1lbnRzSW50VmFsLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1FbGVtZW50cyA9IG51bUVsZW1lbnRzSW50VmFsLnZhbHVlO1xuICAgICAgICAvLyB2YXIgc2VxQ291bnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgIGxldCBzZXFDb3VudFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBsZXQgc2VxQ291bnQgPSBzZXFDb3VudFZhbC52YWx1ZTtcbiAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgaWYgKHNlcUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInNlcUNvdW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb29wSW5kZXggPSBzZXFDb3VudCAvIG51bUVsZW1lbnRzO1xuICAgICAgICBsZXQgaXRlcmF0aW9uSW5kZXggPSBzZXFDb3VudCAlIG51bUVsZW1lbnRzO1xuICAgICAgICBsZXQgc2VxUGF0aFN0ciA9IHNlcUNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBzZXF1ZW5jZUhhc2ggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNlcVBhdGhTdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzZXF1ZW5jZUhhc2ggKz0gc2VxUGF0aFN0ci5jaGFyQ29kZUF0KGkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmRvbVNlZWQgPSBzZXF1ZW5jZUhhc2ggKyBsb29wSW5kZXggKyB0aGlzLnN0YXRlLnN0b3J5U2VlZDtcbiAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhNYXRoLmZsb29yKHJhbmRvbVNlZWQpKTtcbiAgICAgICAgbGV0IHVucGlja2VkSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVsZW1lbnRzOyArK2kpIHtcbiAgICAgICAgICAgIHVucGlja2VkSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGl0ZXJhdGlvbkluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaG9zZW4gPSByYW5kb20ubmV4dCgpICUgdW5waWNrZWRJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaG9zZW5JbmRleCA9IHVucGlja2VkSW5kaWNlc1tjaG9zZW5dO1xuICAgICAgICAgICAgdW5waWNrZWRJbmRpY2VzLnNwbGljZShjaG9zZW4sIDEpO1xuICAgICAgICAgICAgaWYgKGkgPT0gaXRlcmF0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvc2VuSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIik7XG4gICAgfVxuICAgIEVycm9yKG1lc3NhZ2UsIHVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZSA9IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKG1lc3NhZ2UpO1xuICAgICAgICBlLnVzZUVuZExpbmVOdW1iZXIgPSB1c2VFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5BZGRFcnJvcihtZXNzYWdlLCB0cnVlKTtcbiAgICB9XG4gICAgQWRkRXJyb3IobWVzc2FnZSwgaXNXYXJuaW5nID0gZmFsc2UsIHVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZG0gPSB0aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhO1xuICAgICAgICBsZXQgZXJyb3JUeXBlU3RyID0gaXNXYXJuaW5nID8gXCJXQVJOSU5HXCIgOiBcIkVSUk9SXCI7XG4gICAgICAgIGlmIChkbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbGluZU51bSA9IHVzZUVuZExpbmVOdW1iZXIgPyBkbS5lbmRMaW5lTnVtYmVyIDogZG0uc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgXCJSVU5USU1FIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeXBlU3RyICtcbiAgICAgICAgICAgICAgICAgICAgXCI6ICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGRtLmZpbGVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCInIGxpbmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtICtcbiAgICAgICAgICAgICAgICAgICAgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIFwiUlVOVElNRSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZVN0ciArXG4gICAgICAgICAgICAgICAgICAgIFwiOiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyICtcbiAgICAgICAgICAgICAgICAgICAgXCIpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJSVU5USU1FIFwiICsgZXJyb3JUeXBlU3RyICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLkFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZyk7XG4gICAgICAgIC8vIEluIGEgYnJva2VuIHN0YXRlIGRvbid0IG5lZWQgdG8ga25vdyBhYm91dCBhbnkgb3RoZXIgZXJyb3JzLlxuICAgICAgICBpZiAoIWlzV2FybmluZylcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuRm9yY2VFbmQoKTtcbiAgICB9XG4gICAgQXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlN0b3J5IGFzc2VydFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIHRoaXMuY3VycmVudERlYnVnTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50RGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgbGV0IGRtO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI7XG4gICAgICAgIGlmICghcG9pbnRlci5pc051bGwgJiYgcG9pbnRlci5SZXNvbHZlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRtID0gcG9pbnRlci5SZXNvbHZlKCkuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50c1tpXS5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgICAgIGlmICghcG9pbnRlci5pc051bGwgJiYgcG9pbnRlci5SZXNvbHZlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkbSA9IHBvaW50ZXIuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0T2JqID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBkbSA9IG91dHB1dE9iai5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWFpbkNvbnRlbnRDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RvcnkgPSBTdG9yeTtcblN0b3J5Lmlua1ZlcnNpb25DdXJyZW50ID0gMTk7XG4oZnVuY3Rpb24gKFN0b3J5KSB7XG4gICAgbGV0IE91dHB1dFN0YXRlQ2hhbmdlO1xuICAgIChmdW5jdGlvbiAoT3V0cHV0U3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJOb0NoYW5nZVwiXSA9IDBdID0gXCJOb0NoYW5nZVwiO1xuICAgICAgICBPdXRwdXRTdGF0ZUNoYW5nZVtPdXRwdXRTdGF0ZUNoYW5nZVtcIkV4dGVuZGVkQmV5b25kTmV3bGluZVwiXSA9IDFdID0gXCJFeHRlbmRlZEJleW9uZE5ld2xpbmVcIjtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJOZXdsaW5lUmVtb3ZlZFwiXSA9IDJdID0gXCJOZXdsaW5lUmVtb3ZlZFwiO1xuICAgIH0pKE91dHB1dFN0YXRlQ2hhbmdlID0gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UgfHwgKFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlID0ge30pKTtcbn0pKFN0b3J5ID0gZXhwb3J0cy5TdG9yeSB8fCAoZXhwb3J0cy5TdG9yeSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnlFeGNlcHRpb24gPSB2b2lkIDA7XG5jbGFzcyBTdG9yeUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTdG9yeUV4Y2VwdGlvblwiO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcnlFeGNlcHRpb24gPSBTdG9yeUV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3J5RXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yeVN0YXRlID0gdm9pZCAwO1xuY29uc3QgQ2FsbFN0YWNrXzEgPSByZXF1aXJlKFwiLi9DYWxsU3RhY2tcIik7XG5jb25zdCBWYXJpYWJsZXNTdGF0ZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVzU3RhdGVcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgVGFnXzEgPSByZXF1aXJlKFwiLi9UYWdcIik7XG5jb25zdCBHbHVlXzEgPSByZXF1aXJlKFwiLi9HbHVlXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBQUk5HXzEgPSByZXF1aXJlKFwiLi9QUk5HXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU3RvcnlfMSA9IHJlcXVpcmUoXCIuL1N0b3J5XCIpO1xuY29uc3QgU3RhdGVQYXRjaF8xID0gcmVxdWlyZShcIi4vU3RhdGVQYXRjaFwiKTtcbmNvbnN0IFNpbXBsZUpzb25fMSA9IHJlcXVpcmUoXCIuL1NpbXBsZUpzb25cIik7XG5jbGFzcyBTdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yeSkge1xuICAgICAgICB0aGlzLmtJbmtTYXZlU3RhdGVWZXJzaW9uID0gODtcbiAgICAgICAgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uID0gODtcbiAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGl2ZXJ0ZWRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFR1cm5JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3RvcnlTZWVkID0gMDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1JhbmRvbSA9IDA7XG4gICAgICAgIHRoaXMuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFncyA9IG51bGw7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yeSA9IHN0b3J5O1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSBbXTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICB0aGlzLl9ldmFsdWF0aW9uU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2sgPSBuZXcgQ2FsbFN0YWNrXzEuQ2FsbFN0YWNrKHN0b3J5KTtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzU3RhdGUgPSBuZXcgVmFyaWFibGVzU3RhdGVfMS5WYXJpYWJsZXNTdGF0ZSh0aGlzLmNhbGxTdGFjaywgc3RvcnkubGlzdERlZmluaXRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUdXJuSW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHRpbWVTZWVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuc3RvcnlTZWVkID0gbmV3IFBSTkdfMS5QUk5HKHRpbWVTZWVkKS5uZXh0KCkgJSAxMDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLkdvVG9TdGFydCgpO1xuICAgIH1cbiAgICBUb0pzb24oaW5kZW50ZWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgd3JpdGVyID0gbmV3IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLldyaXRlcigpO1xuICAgICAgICB0aGlzLldyaXRlSnNvbih3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLlRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSnNvbihpbmRlbnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRvSnNvbihpbmRlbnRlZCk7XG4gICAgfVxuICAgIExvYWRKc29uKGpzb24pIHtcbiAgICAgICAgbGV0IGpPYmplY3QgPSBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5UZXh0VG9EaWN0aW9uYXJ5KGpzb24pO1xuICAgICAgICB0aGlzLkxvYWRKc29uT2JqKGpPYmplY3QpO1xuICAgIH1cbiAgICBWaXNpdENvdW50QXRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgbGV0IHZpc2l0Q291bnRPdXQ7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuc3RvcnkuQ29udGVudEF0UGF0aChuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZykpLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBhdCBwYXRoIG5vdCBmb3VuZDogXCIgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgICAgIHZpc2l0Q291bnRPdXQgPSB0aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBpZiAodmlzaXRDb3VudE91dC5leGlzdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0Q291bnRPdXQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0Q291bnRPdXQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIHBhdGhTdHJpbmcsIG51bGwpO1xuICAgICAgICBpZiAodmlzaXRDb3VudE91dC5leGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRDb3VudE91dC5yZXN1bHQ7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lci52aXNpdHNTaG91bGRCZUNvdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcnkuRXJyb3IoXCJSZWFkIGNvdW50IGZvciB0YXJnZXQgKFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSArXG4gICAgICAgICAgICAgICAgXCIgLSBvbiBcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmRlYnVnTWV0YWRhdGEgK1xuICAgICAgICAgICAgICAgIFwiKSB1bmtub3duLiBUaGUgc3RvcnkgbWF5IG5lZWQgdG8gYmUgY29tcGlsZWQgd2l0aCBjb3VudEFsbFZpc2l0cyBmbGFnICgtYykuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBpZiAoY291bnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjb3VudDIgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIGNvbnRhaW5lclBhdGhTdHIsIG51bGwpO1xuICAgICAgICBpZiAoY291bnQyLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50Mi5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIEluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGN1cnJDb3VudCA9IHRoaXMuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgY3VyckNvdW50Kys7XG4gICAgICAgICAgICB0aGlzLl9wYXRjaC5TZXRWaXNpdENvdW50KGNvbnRhaW5lciwgY3VyckNvdW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjb3VudCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl92aXNpdENvdW50cywgY29udGFpbmVyUGF0aFN0ciwgbnVsbCk7XG4gICAgICAgIGlmIChjb3VudC5leGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXJQYXRoU3RyLCBjb3VudC5yZXN1bHQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXJQYXRoU3RyLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZWNvcmRUdXJuSW5kZXhWaXNpdFRvQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGNoLlNldFR1cm5JbmRleChjb250YWluZXIsIHRoaXMuY3VycmVudFR1cm5JbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcy5zZXQoY29udGFpbmVyUGF0aFN0ciwgdGhpcy5jdXJyZW50VHVybkluZGV4KTtcbiAgICB9XG4gICAgVHVybnNTaW5jZUZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3J5LkVycm9yKFwiVFVSTlNfU0lOQ0UoKSBmb3IgdGFyZ2V0IChcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiIC0gb24gXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kZWJ1Z01ldGFkYXRhICtcbiAgICAgICAgICAgICAgICBcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3BhdGNoLlRyeUdldFR1cm5JbmRleChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKGluZGV4LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUdXJuSW5kZXggLSBpbmRleC5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgaW5kZXgyID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3R1cm5JbmRpY2VzLCBjb250YWluZXJQYXRoU3RyLCAwKTtcbiAgICAgICAgaWYgKGluZGV4Mi5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUdXJuSW5kZXggLSBpbmRleDIucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYWxsc3RhY2tEZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmRlcHRoO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0U3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0U3RyZWFtO1xuICAgIH1cbiAgICBnZXQgY3VycmVudENob2ljZXMoKSB7XG4gICAgICAgIC8vIElmIHdlIGNhbiBjb250aW51ZSBnZW5lcmF0aW5nIHRleHQgY29udGVudCByYXRoZXIgdGhhbiBjaG9pY2VzLFxuICAgICAgICAvLyB0aGVuIHdlIHJlZmxlY3QgdGhlIGNob2ljZSBsaXN0IGFzIGJlaW5nIGVtcHR5LCBzaW5jZSBjaG9pY2VzXG4gICAgICAgIC8vIHNob3VsZCBhbHdheXMgY29tZSBhdCB0aGUgZW5kLlxuICAgICAgICBpZiAodGhpcy5jYW5Db250aW51ZSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaG9pY2VzO1xuICAgIH1cbiAgICBnZXQgZ2VuZXJhdGVkQ2hvaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaG9pY2VzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFcnJvcnM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50V2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50V2FybmluZ3M7XG4gICAgfVxuICAgIGdldCB2YXJpYWJsZXNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1N0YXRlO1xuICAgIH1cbiAgICBzZXQgdmFyaWFibGVzU3RhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzU3RhdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGV2YWx1YXRpb25TdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRpb25TdGFjaztcbiAgICB9XG4gICAgZ2V0IHZpc2l0Q291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgfVxuICAgIGdldCB0dXJuSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFR1cm5JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXg7XG4gICAgfVxuICAgIHNldCBjdXJyZW50VHVybkluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQYXRoU3RyaW5nKCkge1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuY3VycmVudFBvaW50ZXI7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLnBhdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb2ludGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFBvaW50ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSB2YWx1ZS5jb3B5KCk7XG4gICAgfVxuICAgIGdldCBwcmV2aW91c1BvaW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgfVxuICAgIHNldCBwcmV2aW91c1BvaW50ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXIgPSB2YWx1ZS5jb3B5KCk7XG4gICAgfVxuICAgIGdldCBjYW5Db250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmN1cnJlbnRQb2ludGVyLmlzTnVsbCAmJiAhdGhpcy5oYXNFcnJvcjtcbiAgICB9XG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RXJyb3JzICE9IG51bGwgJiYgdGhpcy5jdXJyZW50RXJyb3JzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBoYXNXYXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50V2FybmluZ3MgIT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRXYXJuaW5ncy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkpIHtcbiAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3V0cHV0T2JqIG9mIHRoaXMuX291dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciB0ZXh0Q29udGVudCA9IG91dHB1dE9iaiBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob3V0cHV0T2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKHRleHRDb250ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGV4dCA9IHRoaXMuQ2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHNiLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUZXh0O1xuICAgIH1cbiAgICBDbGVhbk91dHB1dFdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBsZXQgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9IC0xO1xuICAgICAgICBsZXQgc3RhcnRPZkxpbmUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgbGV0IGlzSW5saW5lV2hpdGVzcGFjZSA9IGMgPT0gXCIgXCIgfHwgYyA9PSBcIlxcdFwiO1xuICAgICAgICAgICAgaWYgKGlzSW5saW5lV2hpdGVzcGFjZSAmJiBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID09IC0xKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKCFpc0lubGluZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPSBcIlxcblwiICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgIT0gc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICBzdGFydE9mTGluZSA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKCFpc0lubGluZVdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRhZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYWdzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBvdXRwdXRPYmogb2YgdGhpcy5fb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHRhZyA9IG91dHB1dE9iaiBhcyBUYWc7XG4gICAgICAgICAgICAgICAgbGV0IHRhZyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvdXRwdXRPYmosIFRhZ18xLlRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFncy5wdXNoKHRhZy50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRhZ3M7XG4gICAgfVxuICAgIGdldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbjtcbiAgICB9XG4gICAgc2V0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBHb1RvU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZih0aGlzLnN0b3J5Lm1haW5Db250ZW50Q29udGFpbmVyKTtcbiAgICB9XG4gICAgQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKSB7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFN0b3J5U3RhdGUodGhpcy5zdG9yeSk7XG4gICAgICAgIGNvcHkuX3BhdGNoID0gbmV3IFN0YXRlUGF0Y2hfMS5TdGF0ZVBhdGNoKHRoaXMuX3BhdGNoKTtcbiAgICAgICAgY29weS5vdXRwdXRTdHJlYW0ucHVzaC5hcHBseShjb3B5Lm91dHB1dFN0cmVhbSwgdGhpcy5fb3V0cHV0U3RyZWFtKTtcbiAgICAgICAgY29weS5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICBjb3B5Ll9jdXJyZW50Q2hvaWNlcy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRDaG9pY2VzLCB0aGlzLl9jdXJyZW50Q2hvaWNlcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50RXJyb3JzID0gW107XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50RXJyb3JzLnB1c2guYXBwbHkoY29weS5fY3VycmVudEVycm9ycywgdGhpcy5jdXJyZW50RXJyb3JzIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNXYXJuaW5nKSB7XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50V2FybmluZ3MgPSBbXTtcbiAgICAgICAgICAgIGNvcHkuX2N1cnJlbnRXYXJuaW5ncy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRXYXJuaW5ncywgdGhpcy5jdXJyZW50V2FybmluZ3MgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvcHkuY2FsbFN0YWNrID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjayh0aGlzLmNhbGxTdGFjayk7XG4gICAgICAgIGNvcHkudmFyaWFibGVzU3RhdGUgPSB0aGlzLnZhcmlhYmxlc1N0YXRlO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjayA9IGNvcHkuY2FsbFN0YWNrO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlLnBhdGNoID0gY29weS5fcGF0Y2g7XG4gICAgICAgIGNvcHkuZXZhbHVhdGlvblN0YWNrLnB1c2guYXBwbHkoY29weS5ldmFsdWF0aW9uU3RhY2ssIHRoaXMuZXZhbHVhdGlvblN0YWNrKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGwpXG4gICAgICAgICAgICBjb3B5LmRpdmVydGVkUG9pbnRlciA9IHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgY29weS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGNvcHkuX3Zpc2l0Q291bnRzID0gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgICAgIGNvcHkuX3R1cm5JbmRpY2VzID0gdGhpcy5fdHVybkluZGljZXM7XG4gICAgICAgIGNvcHkuY3VycmVudFR1cm5JbmRleCA9IHRoaXMuY3VycmVudFR1cm5JbmRleDtcbiAgICAgICAgY29weS5zdG9yeVNlZWQgPSB0aGlzLnN0b3J5U2VlZDtcbiAgICAgICAgY29weS5wcmV2aW91c1JhbmRvbSA9IHRoaXMucHJldmlvdXNSYW5kb207XG4gICAgICAgIGNvcHkuZGlkU2FmZUV4aXQgPSB0aGlzLmRpZFNhZmVFeGl0O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgUmVzdG9yZUFmdGVyUGF0Y2goKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUuY2FsbFN0YWNrID0gdGhpcy5jYWxsU3RhY2s7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUucGF0Y2ggPSB0aGlzLl9wYXRjaDtcbiAgICB9XG4gICAgQXBwbHlBbnlQYXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLkFwcGx5UGF0Y2goKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX3BhdGNoLnZpc2l0Q291bnRzKVxuICAgICAgICAgICAgdGhpcy5BcHBseUNvdW50Q2hhbmdlcyhrZXksIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX3BhdGNoLnR1cm5JbmRpY2VzKVxuICAgICAgICAgICAgdGhpcy5BcHBseUNvdW50Q2hhbmdlcyhrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3BhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgQXBwbHlDb3VudENoYW5nZXMoY29udGFpbmVyLCBuZXdDb3VudCwgaXNWaXNpdCkge1xuICAgICAgICBsZXQgY291bnRzID0gaXNWaXNpdCA/IHRoaXMuX3Zpc2l0Q291bnRzIDogdGhpcy5fdHVybkluZGljZXM7XG4gICAgICAgIGNvdW50cy5zZXQoY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSwgbmV3Q291bnQpO1xuICAgIH1cbiAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGxldCBoYXNDaG9pY2VUaHJlYWRzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpIHtcbiAgICAgICAgICAgIGlmIChjLnRocmVhZEF0R2VuZXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiYy50aHJlYWRBdEdlbmVyYXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLm9yaWdpbmFsVGhyZWFkSW5kZXggPSBjLnRocmVhZEF0R2VuZXJhdGlvbi50aHJlYWRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgoYy5vcmlnaW5hbFRocmVhZEluZGV4KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzQ2hvaWNlVGhyZWFkcykge1xuICAgICAgICAgICAgICAgICAgICBoYXNDaG9pY2VUaHJlYWRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImNob2ljZVRocmVhZHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoYy5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjLnRocmVhZEF0R2VuZXJhdGlvbi5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDaG9pY2VUaHJlYWRzKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGZvbGxvd2luZyB0d28gY2FsbHMsIGBXcml0ZUpzb25gIGlzIGNhbGxlZCBpbnNpZGUgYW4gYXJyb3dcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gbWFrZSBzdXJlIGB0aGlzYCBpcyBjb3JyZWN0bHkgYm91bmQgYW5kIHBhc3NlZCBkb3duXG4gICAgICAgIC8vIHRoZSBjYWxsIGhpZXJhcmNoeS5cbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjYWxsc3RhY2tUaHJlYWRzXCIsICh3KSA9PiB0aGlzLmNhbGxTdGFjay5Xcml0ZUpzb24odykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZhcmlhYmxlc1N0YXRlXCIsICh3KSA9PiB0aGlzLnZhcmlhYmxlc1N0YXRlLldyaXRlSnNvbih3KSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiZXZhbFN0YWNrXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHcsIHRoaXMuZXZhbHVhdGlvblN0YWNrKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwib3V0cHV0U3RyZWFtXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHcsIHRoaXMuX291dHB1dFN0cmVhbSkpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnRDaG9pY2VzXCIsICh3KSA9PiB7XG4gICAgICAgICAgICB3LldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcylcbiAgICAgICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlQ2hvaWNlKHcsIGMpO1xuICAgICAgICAgICAgdy5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImRpdmVydGVkUG9pbnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY3VycmVudERpdmVydFRhcmdldFwiLCB0aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidmlzaXRDb3VudHNcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVJbnREaWN0aW9uYXJ5KHcsIHRoaXMuX3Zpc2l0Q291bnRzKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidHVybkluZGljZXNcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVJbnREaWN0aW9uYXJ5KHcsIHRoaXMuX3R1cm5JbmRpY2VzKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidHVybklkeFwiLCB0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInN0b3J5U2VlZFwiLCB0aGlzLnN0b3J5U2VlZCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwicHJldmlvdXNSYW5kb21cIiwgdGhpcy5wcmV2aW91c1JhbmRvbSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rU2F2ZVZlcnNpb25cIiwgdGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbik7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rRm9ybWF0VmVyc2lvblwiLCBTdG9yeV8xLlN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIExvYWRKc29uT2JqKHZhbHVlKSB7XG4gICAgICAgIGxldCBqT2JqZWN0ID0gdmFsdWU7XG4gICAgICAgIGxldCBqU2F2ZVZlcnNpb24gPSBqT2JqZWN0W1wiaW5rU2F2ZVZlcnNpb25cIl07XG4gICAgICAgIGlmIChqU2F2ZVZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJpbmsgc2F2ZSBmb3JtYXQgaW5jb3JyZWN0LCBjYW4ndCBsb2FkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZUludChqU2F2ZVZlcnNpb24pIDwgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkluayBzYXZlIGZvcm1hdCBpc24ndCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiAoc2F3ICdcIiArXG4gICAgICAgICAgICAgICAgalNhdmVWZXJzaW9uICtcbiAgICAgICAgICAgICAgICBcIicsIGJ1dCBtaW5pbXVtIGlzIFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24gK1xuICAgICAgICAgICAgICAgIFwiKSwgc28gY2FuJ3QgbG9hZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsU3RhY2suU2V0SnNvblRva2VuKGpPYmplY3RbXCJjYWxsc3RhY2tUaHJlYWRzXCJdLCB0aGlzLnN0b3J5KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5TZXRKc29uVG9rZW4oak9iamVjdFtcInZhcmlhYmxlc1N0YXRlXCJdKTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGlvblN0YWNrID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpPYmplY3RbXCJldmFsU3RhY2tcIl0pO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpBcnJheVRvUnVudGltZU9iakxpc3Qoak9iamVjdFtcIm91dHB1dFN0cmVhbVwiXSk7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgLy8gY3VycmVudENob2ljZXMgPSBKc29uLkpBcnJheVRvUnVudGltZU9iakxpc3Q8Q2hvaWNlPigoSkFycmF5KWpPYmplY3QgW1wiY3VycmVudENob2ljZXNcIl0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdChqT2JqZWN0W1wiY3VycmVudENob2ljZXNcIl0pO1xuICAgICAgICBsZXQgY3VycmVudERpdmVydFRhcmdldFBhdGggPSBqT2JqZWN0W1wiY3VycmVudERpdmVydFRhcmdldFwiXTtcbiAgICAgICAgaWYgKGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkaXZlcnRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgoZGl2ZXJ0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdFtcInZpc2l0Q291bnRzXCJdKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdFtcInR1cm5JbmRpY2VzXCJdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4ID0gcGFyc2VJbnQoak9iamVjdFtcInR1cm5JZHhcIl0pO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IHBhcnNlSW50KGpPYmplY3RbXCJzdG9yeVNlZWRcIl0pO1xuICAgICAgICB0aGlzLnByZXZpb3VzUmFuZG9tID0gcGFyc2VJbnQoak9iamVjdFtcInByZXZpb3VzUmFuZG9tXCJdKTtcbiAgICAgICAgLy8gdmFyIGpDaG9pY2VUaHJlYWRzID0gak9iamVjdFtcImNob2ljZVRocmVhZHNcIl0gYXMgSk9iamVjdDtcbiAgICAgICAgbGV0IGpDaG9pY2VUaHJlYWRzID0gak9iamVjdFtcImNob2ljZVRocmVhZHNcIl07XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEFjdGl2ZVRocmVhZCA9IHRoaXMuY2FsbFN0YWNrLlRocmVhZFdpdGhJbmRleChjLm9yaWdpbmFsVGhyZWFkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZvdW5kQWN0aXZlVGhyZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLnRocmVhZEF0R2VuZXJhdGlvbiA9IGZvdW5kQWN0aXZlVGhyZWFkLkNvcHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBqU2F2ZWRDaG9pY2VUaHJlYWQgPSBqQ2hvaWNlVGhyZWFkc1tjLm9yaWdpbmFsVGhyZWFkSW5kZXgudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24gPSBuZXcgQ2FsbFN0YWNrXzEuQ2FsbFN0YWNrLlRocmVhZChqU2F2ZWRDaG9pY2VUaHJlYWQsIHRoaXMuc3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJlc2V0RXJyb3JzKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzID0gbnVsbDtcbiAgICB9XG4gICAgUmVzZXRPdXRwdXQob2JqcyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChvYmpzICE9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnB1c2guYXBwbHkodGhpcy5fb3V0cHV0U3RyZWFtLCBvYmpzKTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBQdXNoVG9PdXRwdXRTdHJlYW0ob2JqKSB7XG4gICAgICAgIC8vIHZhciB0ZXh0ID0gb2JqIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGxpc3RUZXh0ID0gdGhpcy5UcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2UodGV4dCk7XG4gICAgICAgICAgICBpZiAobGlzdFRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ZXh0T2JqIG9mIGxpc3RUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbCh0ZXh0T2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwob2JqKTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBQb3BGcm9tT3V0cHV0U3RyZWFtKGNvdW50KSB7XG4gICAgICAgIHRoaXMub3V0cHV0U3RyZWFtLnNwbGljZSh0aGlzLm91dHB1dFN0cmVhbS5sZW5ndGggLSBjb3VudCwgY291bnQpO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIFRyeVNwbGl0dGluZ0hlYWRUYWlsV2hpdGVzcGFjZShzaW5nbGUpIHtcbiAgICAgICAgbGV0IHN0ciA9IHNpbmdsZS52YWx1ZTtcbiAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzaW5nbGUudmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhlYWRGaXJzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgbGV0IGhlYWRMYXN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGhlYWRGaXJzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgICAgIGhlYWRMYXN0TmV3bGluZUlkeCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09IFwiIFwiIHx8IGMgPT0gXCJcXHRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFpbExhc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGxldCB0YWlsRmlyc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHN0cltpXTtcbiAgICAgICAgICAgIGlmIChjID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0YWlsTGFzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgICAgIHRhaWxGaXJzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSBcIiBcIiB8fCBjID09IFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc3BsaXR0aW5nIHRvIGJlIGRvbmU/XG4gICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID09IC0xICYmIHRhaWxMYXN0TmV3bGluZUlkeCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFRleHRzID0gW107XG4gICAgICAgIGxldCBpbm5lclN0clN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGlubmVyU3RyRW5kID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggIT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsZWFkaW5nU3BhY2VzID0gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoc3RyLnN1YnN0cmluZygwLCBoZWFkRmlyc3ROZXdsaW5lSWR4KSk7XG4gICAgICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0VGV4dHMucHVzaChuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShcIlxcblwiKSk7XG4gICAgICAgICAgICBpbm5lclN0clN0YXJ0ID0gaGVhZExhc3ROZXdsaW5lSWR4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ICE9IC0xKSB7XG4gICAgICAgICAgICBpbm5lclN0ckVuZCA9IHRhaWxGaXJzdE5ld2xpbmVJZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlubmVyU3RyRW5kID4gaW5uZXJTdHJTdGFydCkge1xuICAgICAgICAgICAgbGV0IGlubmVyU3RyVGV4dCA9IHN0ci5zdWJzdHJpbmcoaW5uZXJTdHJTdGFydCwgaW5uZXJTdHJFbmQgLSBpbm5lclN0clN0YXJ0KTtcbiAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKGlubmVyU3RyVGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggIT0gLTEgJiYgdGFpbEZpcnN0TmV3bGluZUlkeCA+IGhlYWRMYXN0TmV3bGluZUlkeCkge1xuICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIikpO1xuICAgICAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCA8IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bVNwYWNlcyA9IHN0ci5sZW5ndGggLSB0YWlsTGFzdE5ld2xpbmVJZHggLSAxO1xuICAgICAgICAgICAgICAgIGxldCB0cmFpbGluZ1NwYWNlcyA9IG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcodGFpbExhc3ROZXdsaW5lSWR4ICsgMSwgbnVtU3BhY2VzKSk7XG4gICAgICAgICAgICAgICAgbGlzdFRleHRzLnB1c2godHJhaWxpbmdTcGFjZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0VGV4dHM7XG4gICAgfVxuICAgIFB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwob2JqKSB7XG4gICAgICAgIGxldCBnbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgR2x1ZV8xLkdsdWUpO1xuICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICBsZXQgaW5jbHVkZUluT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuVHJpbU5ld2xpbmVzRnJvbU91dHB1dFN0cmVhbSgpO1xuICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25UcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxldCBjdXJyRWwgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChjdXJyRWwudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblRyaW1JbmRleCA9IGN1cnJFbC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2x1ZVRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBvID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGxldCBjID0gbyBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQgPyBvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZyA9IG8gaW5zdGFuY2VvZiBHbHVlXzEuR2x1ZSA/IG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x1ZVRyaW1JbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgYy5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IGZ1bmN0aW9uVHJpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmIChnbHVlVHJpbUluZGV4ICE9IC0xICYmIGZ1bmN0aW9uVHJpbUluZGV4ICE9IC0xKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRleCA9IE1hdGgubWluKGZ1bmN0aW9uVHJpbUluZGV4LCBnbHVlVHJpbUluZGV4KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGdsdWVUcmltSW5kZXggIT0gLTEpXG4gICAgICAgICAgICAgICAgdHJpbUluZGV4ID0gZ2x1ZVRyaW1JbmRleDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cmltSW5kZXggPSBmdW5jdGlvblRyaW1JbmRleDtcbiAgICAgICAgICAgIGlmICh0cmltSW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQuaXNOb25XaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbHVlVHJpbUluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlJlbW92ZUV4aXN0aW5nR2x1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25UcmltSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGxTdGFja0VsZW1lbnRzID0gdGhpcy5jYWxsU3RhY2suZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2FsbFN0YWNrRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBjYWxsU3RhY2tFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0LmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgfHwgIXRoaXMub3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlSW5PdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZUluT3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0ucHVzaChvYmopO1xuICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKSB7XG4gICAgICAgIGxldCByZW1vdmVXaGl0ZXNwYWNlRnJvbSA9IC0xO1xuICAgICAgICBsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgbGV0IHR4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNtZCAhPSBudWxsIHx8ICh0eHQgIT0gbnVsbCAmJiB0eHQuaXNOb25XaGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHh0ICE9IG51bGwgJiYgdHh0LmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVdoaXRlc3BhY2VGcm9tID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHJlbW92ZVdoaXRlc3BhY2VGcm9tID49IDApIHtcbiAgICAgICAgICAgIGkgPSByZW1vdmVXaGl0ZXNwYWNlRnJvbTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuX291dHB1dFN0cmVhbVtpXSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBSZW1vdmVFeGlzdGluZ0dsdWUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBHbHVlXzEuR2x1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5pc05ld2xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dC5pc05vbldoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX291dHB1dFN0cmVhbVtpXSBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaW5TdHJpbmdFdmFsdWF0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyB2YXIgY21kID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldIGFzIENvbnRyb2xDb21tYW5kO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLl9vdXRwdXRTdHJlYW1baV0sIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKGNtZCBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQgJiZcbiAgICAgICAgICAgICAgICBjbWQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUHVzaEV2YWx1YXRpb25TdGFjayhvYmopIHtcbiAgICAgICAgLy8gdmFyIGxpc3RWYWx1ZSA9IG9iaiBhcyBMaXN0VmFsdWU7XG4gICAgICAgIGxldCBsaXN0VmFsdWUgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChsaXN0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvcmlnaW4gd2hlbiBsaXN0IGlzIGhhcyBzb21ldGhpbmcgdG8gaW5kaWNhdGUgdGhlIGxpc3Qgb3JpZ2luXG4gICAgICAgICAgICBsZXQgcmF3TGlzdCA9IGxpc3RWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYXdMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYXdMaXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0xpc3Qub3JpZ2luTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghcmF3TGlzdC5vcmlnaW5zKVxuICAgICAgICAgICAgICAgICAgICByYXdMaXN0Lm9yaWdpbnMgPSBbXTtcbiAgICAgICAgICAgICAgICByYXdMaXN0Lm9yaWdpbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIHJhd0xpc3Qub3JpZ2luTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJTdG9yeVN0YXRlLnN0b3J5Lmxpc3REZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKG4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiU3RvcnlTdGF0ZSBkZWYucmVzdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3TGlzdC5vcmlnaW5zLmluZGV4T2YoZGVmLnJlc3VsdCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zLnB1c2goZGVmLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvblN0YWNrLnB1c2gob2JqKTtcbiAgICB9XG4gICAgUG9wRXZhbHVhdGlvblN0YWNrKG51bWJlck9mT2JqZWN0cykge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlck9mT2JqZWN0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuZXZhbHVhdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5udWxsSWZVbmRlZmluZWQob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZk9iamVjdHMgPiB0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnlpbmcgdG8gcG9wIHRvbyBtYW55IG9iamVjdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9wcGVkID0gdGhpcy5ldmFsdWF0aW9uU3RhY2suc3BsaWNlKHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCAtIG51bWJlck9mT2JqZWN0cywgbnVtYmVyT2ZPYmplY3RzKTtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEubnVsbElmVW5kZWZpbmVkKHBvcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGVla0V2YWx1YXRpb25TdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGlvblN0YWNrW3RoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBGb3JjZUVuZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suUmVzZXQoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgfVxuICAgIFRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCkge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydCh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbik7XG4gICAgICAgIGxldCBmdW5jdGlvblN0YXJ0UG9pbnQgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudFxuICAgICAgICAgICAgLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uU3RhcnRQb2ludCA9PSAtMSkge1xuICAgICAgICAgICAgZnVuY3Rpb25TdGFydFBvaW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gZnVuY3Rpb25TdGFydFBvaW50OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBsZXQgdHh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBsZXQgY21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgICAgICBpZiAodHh0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY21kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR4dC5pc05ld2xpbmUgfHwgdHh0LmlzSW5saW5lV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9wQ2FsbFN0YWNrKHBvcFR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbilcbiAgICAgICAgICAgIHRoaXMuVHJpbVdoaXRlc3BhY2VGcm9tRnVuY3Rpb25FbmQoKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suUG9wKHBvcFR5cGUpO1xuICAgIH1cbiAgICBTZXRDaG9zZW5QYXRoKHBhdGgsIGluY3JlbWVudGluZ1R1cm5JbmRleCkge1xuICAgICAgICAvLyBDaGFuZ2luZyBkaXJlY3Rpb24sIGFzc3VtZSB3ZSBuZWVkIHRvIGNsZWFyIGN1cnJlbnQgc2V0IG9mIGNob2ljZXNcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IG5ld1BvaW50ZXIgPSB0aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgocGF0aCk7XG4gICAgICAgIGlmICghbmV3UG9pbnRlci5pc051bGwgJiYgbmV3UG9pbnRlci5pbmRleCA9PSAtMSlcbiAgICAgICAgICAgIG5ld1BvaW50ZXIuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gbmV3UG9pbnRlcjtcbiAgICAgICAgaWYgKGluY3JlbWVudGluZ1R1cm5JbmRleCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZShmdW5jQ29udGFpbmVyLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlB1c2goUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lLCB0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoZnVuY0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpO1xuICAgIH1cbiAgICBQYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soYXJncykge1xuICAgICAgICAvLyBQYXNzIGFyZ3VtZW50cyBvbnRvIHRoZSBldmFsdWF0aW9uIHN0YWNrXG4gICAgICAgIGlmIChhcmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBhcmdzW2ldID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcmdzW2ldID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmsgYXJndW1lbnRzIHdoZW4gY2FsbGluZyBFdmFsdWF0ZUZ1bmN0aW9uIC8gQ2hvb3NlUGF0aFN0cmluZ1dpdGhQYXJhbWV0ZXJzICBtdXN0IGJlIGludCwgZmxvYXQgb3Igc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLlB1c2hFdmFsdWF0aW9uU3RhY2soVmFsdWVfMS5WYWx1ZS5DcmVhdGUoYXJnc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT1cbiAgICAgICAgICAgIFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLmRpZFNhZmVFeGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgIT1cbiAgICAgICAgICAgIFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBleHRlcm5hbCBmdW5jdGlvbiBldmFsdWF0aW9uIHRvIGJlIGNvbXBsZXRlLiBTdGFjayB0cmFjZTogXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0YWNrLmNhbGxTdGFja1RyYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudFxuICAgICAgICAgICAgLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ7XG4gICAgICAgIGxldCByZXR1cm5lZE9iaiA9IG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggPiBvcmlnaW5hbEV2YWx1YXRpb25TdGFja0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHBvcHBlZE9iaiA9IHRoaXMuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWRPYmogPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuZWRPYmogPSBwb3BwZWRPYmo7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Qb3BDYWxsU3RhY2soUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKTtcbiAgICAgICAgaWYgKHJldHVybmVkT2JqKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWRPYmogaW5zdGFuY2VvZiBWb2lkXzEuVm9pZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIFNvbWUga2luZCBvZiB2YWx1ZSwgaWYgbm90IHZvaWRcbiAgICAgICAgICAgIC8vIHZhciByZXR1cm5WYWwgPSByZXR1cm5lZE9iaiBhcyBSdW50aW1lLlZhbHVlO1xuICAgICAgICAgICAgbGV0IHJldHVyblZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHJldHVybmVkT2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIC8vIERpdmVydFRhcmdldHMgZ2V0IHJldHVybmVkIGFzIHRoZSBzdHJpbmcgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gKHJhdGhlciB0aGFuIGEgUGF0aCwgd2hpY2ggaXNuJ3QgcHVibGljKVxuICAgICAgICAgICAgaWYgKHJldHVyblZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbC52YWx1ZU9iamVjdC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXIgdHlwZXMgY2FuIGp1c3QgaGF2ZSB0aGVpciBleGFjdCBvYmplY3QgdHlwZTpcbiAgICAgICAgICAgIC8vIGludCwgZmxvYXQsIHN0cmluZy4gVmFyaWFibGVQb2ludGVycyBnZXQgcmV0dXJuZWQgYXMgc3RyaW5ncy5cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWwudmFsdWVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIEFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZykge1xuICAgICAgICBpZiAoIWlzV2FybmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFcnJvcnMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFdhcm5pbmdzID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPdXRwdXRTdHJlYW1EaXJ0eSgpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlN0b3J5U3RhdGUgPSBTdG9yeVN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcnlTdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IHZvaWQgMDtcbmNsYXNzIFN0cmluZ0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cikge1xuICAgICAgICBzdHIgPSB0eXBlb2Ygc3RyICE9PSBcInVuZGVmaW5lZFwiID8gc3RyLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cjtcbiAgICB9XG4gICAgZ2V0IExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgQXBwZW5kKHN0cikge1xuICAgICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmluZyArPSBzdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXBwZW5kTGluZShzdHIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICB0aGlzLkFwcGVuZChzdHIpO1xuICAgICAgICB0aGlzLnN0cmluZyArPSBcIlxcblwiO1xuICAgIH1cbiAgICBBcHBlbmRGb3JtYXQoZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MTA0MDYvamF2YXNjcmlwdC1lcXVpdmFsZW50LXRvLXByaW50Zi1zdHJpbmctZm9ybWF0XG4gICAgICAgIHRoaXMuc3RyaW5nICs9IGZvcm1hdC5yZXBsYWNlKC97KFxcZCspfS9nLCAobWF0Y2gsIG51bSkgPT4gdHlwZW9mIGFyZ3NbbnVtXSAhPSBcInVuZGVmaW5lZFwiID8gYXJnc1tudW1dIDogbWF0Y2gpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdCdWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWcgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFRhZyBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IodGFnVGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0YWdUZXh0LnRvU3RyaW5nKCkgfHwgXCJcIjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiMgXCIgKyB0aGlzLnRleHQ7XG4gICAgfVxufVxuZXhwb3J0cy5UYWcgPSBUYWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyeVBhcnNlRmxvYXQgPSBleHBvcnRzLnRyeVBhcnNlSW50ID0gZXhwb3J0cy50cnlHZXRWYWx1ZUZyb21NYXAgPSB2b2lkIDA7XG5mdW5jdGlvbiB0cnlHZXRWYWx1ZUZyb21NYXAobWFwLCBrZXksIFxuLyogb3V0ICovIHZhbHVlKSB7XG4gICAgaWYgKG1hcCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIGxldCB2YWwgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJ5R2V0VmFsdWVGcm9tTWFwID0gdHJ5R2V0VmFsdWVGcm9tTWFwO1xuZnVuY3Rpb24gdHJ5UGFyc2VJbnQodmFsdWUsIFxuLyogb3V0ICovIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgICBsZXQgdmFsID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZhdWx0VmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeVBhcnNlSW50ID0gdHJ5UGFyc2VJbnQ7XG5mdW5jdGlvbiB0cnlQYXJzZUZsb2F0KHZhbHVlLCBcbi8qIG91dCAqLyBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gICAgbGV0IHZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZhdWx0VmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeVBhcnNlRmxvYXQgPSB0cnlQYXJzZUZsb2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJ5R2V0UmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0VxdWF0YWJsZSA9IGV4cG9ydHMubnVsbElmVW5kZWZpbmVkID0gZXhwb3J0cy5hc0lOYW1lZENvbnRlbnRPck51bGwgPSBleHBvcnRzLmFzTnVtYmVyT3JUaHJvd3MgPSBleHBvcnRzLmFzT3JUaHJvd3MgPSBleHBvcnRzLmFzT3JOdWxsID0gdm9pZCAwO1xuZnVuY3Rpb24gYXNPck51bGwob2JqLCB0eXBlKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNPck51bGwgPSBhc09yTnVsbDtcbmZ1bmN0aW9uIGFzT3JUaHJvd3Mob2JqLCB0eXBlKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmp9IGlzIG5vdCBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzT3JUaHJvd3MgPSBhc09yVGhyb3dzO1xuZnVuY3Rpb24gYXNOdW1iZXJPclRocm93cyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29ian0gaXMgbm90IGEgbnVtYmVyYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc051bWJlck9yVGhyb3dzID0gYXNOdW1iZXJPclRocm93cztcbi8vIFNvIGhlcmUsIGluIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24sIGNvbnRlbnRPYmogaXMgY2FzdGVkIHRvIGFuIElOYW1lZENvbnRlbnRcbi8vIGJ1dCBoZXJlIHdlIHVzZSBqcy1zdHlsZSBkdWNrIHR5cGluZzogaWYgaXQgaW1wbGVtZW50cyB0aGUgc2FtZSBwcm9wcyBhcyB0aGUgaW50ZXJmYWNlLFxuLy8gd2UgdHJlYXQgaXQgYXMgdmFsaWQuXG5mdW5jdGlvbiBhc0lOYW1lZENvbnRlbnRPck51bGwob2JqKSB7XG4gICAgaWYgKG9iai5oYXNWYWxpZE5hbWUgJiYgb2JqLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmFzSU5hbWVkQ29udGVudE9yTnVsbCA9IGFzSU5hbWVkQ29udGVudE9yTnVsbDtcbmZ1bmN0aW9uIG51bGxJZlVuZGVmaW5lZChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMubnVsbElmVW5kZWZpbmVkID0gbnVsbElmVW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNFcXVhdGFibGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdHlwZS5FcXVhbHMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNFcXVhdGFibGUgPSBpc0VxdWF0YWJsZTtcbmZ1bmN0aW9uIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKSB7XG4gICAgcmV0dXJuIG9iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVBc3NlcnRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlVHlwZSA9IGV4cG9ydHMuTGlzdFZhbHVlID0gZXhwb3J0cy5WYXJpYWJsZVBvaW50ZXJWYWx1ZSA9IGV4cG9ydHMuRGl2ZXJ0VGFyZ2V0VmFsdWUgPSBleHBvcnRzLlN0cmluZ1ZhbHVlID0gZXhwb3J0cy5GbG9hdFZhbHVlID0gZXhwb3J0cy5JbnRWYWx1ZSA9IGV4cG9ydHMuVmFsdWUgPSBleHBvcnRzLkFic3RyYWN0VmFsdWUgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIEFic3RyYWN0VmFsdWUgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIHN0YXRpYyBDcmVhdGUodmFsLCBwcmVmZXJyZWROdW1iZXJUeXBlKSB7XG4gICAgICAgIC8vIFRoaXMgY29kZSBkb2Vzbid0IGV4aXN0IGluIHVwc3RyZWFtIGFuZCBpcyBzaW1wbHkgaGVyZSB0byBlbmZvcmNlXG4gICAgICAgIC8vIHRoZSBjcmVhdGlvbiBvZiB0aGUgcHJvcGVyIG51bWJlciB2YWx1ZS5cbiAgICAgICAgLy8gSWYgYHByZWZlcnJlZE51bWJlclR5cGVgIGlzIG5vdCBwcm92aWRlZCBvciBpZiB2YWx1ZSBkb2Vzbid0IG1hdGNoXG4gICAgICAgIC8vIGBwcmVmZXJyZWROdW1iZXJUeXBlYCwgdGhpcyBjb25kaXRpb25hbCBkb2VzIG5vdGhpbmcuXG4gICAgICAgIGlmIChwcmVmZXJyZWROdW1iZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSA9PT0gVmFsdWVUeXBlLkludCAmJlxuICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmZXJyZWROdW1iZXJUeXBlID09PSBWYWx1ZVR5cGUuRmxvYXQgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW1wbGljaXRseSBjb252ZXJ0IGJvb2xzIGludG8gaW50c1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGxldCBiID0gISF2YWw7XG4gICAgICAgICAgICB2YWwgPSBiID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ktbG9oc2UvaW5ranMvaXNzdWVzLzQyNVxuICAgICAgICAvLyBDaGFuZ2VkIGNvbmRpdGlvbiBzZXF1ZW5jZSwgYmVjYXVzZSBOdW1iZXIoJycpIGlzXG4gICAgICAgIC8vIHBhcnNlZCB0byAwLCB3aGljaCBtYWRlIHNldHRpbmcgc3RyaW5nIHRvIGVtcHR5XG4gICAgICAgIC8vIGltcG9zc2libGVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoU3RyaW5nKHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBQYXRoXzEuUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXZlcnRUYXJnZXRWYWx1ZShUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWwsIFBhdGhfMS5QYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdFZhbHVlKFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhbCwgSW5rTGlzdF8xLklua0xpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKEFic3RyYWN0VmFsdWUuQ3JlYXRlKHRoaXMpLCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgIH1cbiAgICBCYWRDYXN0RXhjZXB0aW9uKHRhcmdldFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuJ3QgY2FzdCBcIiArXG4gICAgICAgICAgICB0aGlzLnZhbHVlT2JqZWN0ICtcbiAgICAgICAgICAgIFwiIGZyb20gXCIgK1xuICAgICAgICAgICAgdGhpcy52YWx1ZVR5cGUgK1xuICAgICAgICAgICAgXCIgdG8gXCIgK1xuICAgICAgICAgICAgdGFyZ2V0VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdFZhbHVlID0gQWJzdHJhY3RWYWx1ZTtcbmNsYXNzIFZhbHVlIGV4dGVuZHMgQWJzdHJhY3RWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgfVxuICAgIGdldCB2YWx1ZU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZSA9IFZhbHVlO1xuY2xhc3MgSW50VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKHZhbCB8fCAwKTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSAwO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkludDtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIiArIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkludFZhbHVlID0gSW50VmFsdWU7XG5jbGFzcyBGbG9hdFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgMC4wKTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSAwLjA7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuRmxvYXQ7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIiArIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0VmFsdWUgPSBGbG9hdFZhbHVlO1xuY2xhc3MgU3RyaW5nVmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKHZhbCB8fCBcIlwiKTtcbiAgICAgICAgdGhpcy5faXNOZXdsaW5lID0gdGhpcy52YWx1ZSA9PSBcIlxcblwiO1xuICAgICAgICB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuc3BsaXQoXCJcIikuZXZlcnkoKGMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPSBcIiBcIiAmJiBjICE9IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLlN0cmluZztcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBpc05ld2xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc05ld2xpbmU7XG4gICAgfVxuICAgIGdldCBpc0lubGluZVdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2U7XG4gICAgfVxuICAgIGdldCBpc05vbldoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc05ld2xpbmUgJiYgIXRoaXMuaXNJbmxpbmVXaGl0ZXNwYWNlO1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRJbnQgPSBUcnlHZXRSZXN1bHRfMS50cnlQYXJzZUludCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShwYXJzZWRJbnQucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRGbG9hdCA9IFRyeUdldFJlc3VsdF8xLnRyeVBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRmxvYXQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKHBhcnNlZEZsb2F0LnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nVmFsdWUgPSBTdHJpbmdWYWx1ZTtcbmNsYXNzIERpdmVydFRhcmdldFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldFBhdGgpIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0UGF0aCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgc2V0IHRhcmdldFBhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIGRpdmVydCB0YXJnZXRcIik7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJEaXZlcnRUYXJnZXRWYWx1ZShcIiArIHRoaXMudGFyZ2V0UGF0aCArIFwiKVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRGl2ZXJ0VGFyZ2V0VmFsdWUgPSBEaXZlcnRUYXJnZXRWYWx1ZTtcbmNsYXNzIFZhcmlhYmxlUG9pbnRlclZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhcmlhYmxlTmFtZSwgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgc3VwZXIodmFyaWFibGVOYW1lKTtcbiAgICAgICAgdGhpcy5fY29udGV4dEluZGV4ID0gY29udGV4dEluZGV4O1xuICAgIH1cbiAgICBnZXQgY29udGV4dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dEluZGV4O1xuICAgIH1cbiAgICBzZXQgY29udGV4dEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5WYXJpYWJsZVBvaW50ZXI7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkbid0IGJlIGNoZWNraW5nIHRoZSB0cnV0aGluZXNzIG9mIGEgdmFyaWFibGUgcG9pbnRlclwiKTtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlZhcmlhYmxlUG9pbnRlclZhbHVlKFwiICsgdGhpcy52YXJpYWJsZU5hbWUgKyBcIilcIjtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZVBvaW50ZXJWYWx1ZSh0aGlzLnZhcmlhYmxlTmFtZSwgdGhpcy5jb250ZXh0SW5kZXgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVQb2ludGVyVmFsdWUgPSBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbmNsYXNzIExpc3RWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMudmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuQ291bnQgPiAwO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkxpc3Q7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heEl0ZW07XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZSgwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKG1heC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heEl0ZW07XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKDAuMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKG1heC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG1heC5LZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihsaXN0T3JTaW5nbGVJdGVtLCBzaW5nbGVWYWx1ZSkge1xuICAgICAgICBzdXBlcihudWxsKTtcbiAgICAgICAgaWYgKCFsaXN0T3JTaW5nbGVJdGVtICYmICFzaW5nbGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RPclNpbmdsZUl0ZW0gaW5zdGFuY2VvZiBJbmtMaXN0XzEuSW5rTGlzdCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdChsaXN0T3JTaW5nbGVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0T3JTaW5nbGVJdGVtIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3RJdGVtICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2luZ2xlVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3Qoe1xuICAgICAgICAgICAgICAgIEtleTogbGlzdE9yU2luZ2xlSXRlbSxcbiAgICAgICAgICAgICAgICBWYWx1ZTogc2luZ2xlVmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvbGRWYWx1ZSwgTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IG5ld0xpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwobmV3VmFsdWUsIExpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChuZXdMaXN0ICYmIG5ld0xpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5ld0xpc3QudmFsdWVcIik7XG4gICAgICAgIGlmIChvbGRMaXN0ICYmIG9sZExpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9sZExpc3QudmFsdWVcIik7XG4gICAgICAgIC8vIFdoZW4gYXNzaWduaW5nIHRoZSBlbXB0eSBsaXN0LCB0cnkgdG8gcmV0YWluIGFueSBpbml0aWFsIG9yaWdpbiBuYW1lc1xuICAgICAgICBpZiAob2xkTGlzdCAmJiBuZXdMaXN0ICYmIG5ld0xpc3QudmFsdWUuQ291bnQgPT0gMClcbiAgICAgICAgICAgIG5ld0xpc3QudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG9sZExpc3QudmFsdWUub3JpZ2luTmFtZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdFZhbHVlID0gTGlzdFZhbHVlO1xudmFyIFZhbHVlVHlwZTtcbihmdW5jdGlvbiAoVmFsdWVUeXBlKSB7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkludFwiXSA9IDBdID0gXCJJbnRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiRmxvYXRcIl0gPSAxXSA9IFwiRmxvYXRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiTGlzdFwiXSA9IDJdID0gXCJMaXN0XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIlN0cmluZ1wiXSA9IDNdID0gXCJTdHJpbmdcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiRGl2ZXJ0VGFyZ2V0XCJdID0gNF0gPSBcIkRpdmVydFRhcmdldFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJWYXJpYWJsZVBvaW50ZXJcIl0gPSA1XSA9IFwiVmFyaWFibGVQb2ludGVyXCI7XG59KShWYWx1ZVR5cGUgPSBleHBvcnRzLlZhbHVlVHlwZSB8fCAoZXhwb3J0cy5WYWx1ZVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlQXNzaWdubWVudCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgVmFyaWFibGVBc3NpZ25tZW50IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZU5hbWUsIGlzTmV3RGVjbGFyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWUgPSB2YXJpYWJsZU5hbWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pc05ld0RlY2xhcmF0aW9uID0gISFpc05ld0RlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLmlzR2xvYmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJWYXJBc3NpZ24gdG8gXCIgKyB0aGlzLnZhcmlhYmxlTmFtZTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlQXNzaWdubWVudCA9IFZhcmlhYmxlQXNzaWdubWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlQXNzaWdubWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVSZWZlcmVuY2UgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jbGFzcyBWYXJpYWJsZVJlZmVyZW5jZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IobmFtZSA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXRoRm9yQ291bnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQgY29udGFpbmVyRm9yQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhGb3JDb3VudCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLnBhdGhGb3JDb3VudCkuY29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ0ZvckNvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoRm9yQ291bnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoRm9yQ291bnQpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ0ZvckNvdW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXRoRm9yQ291bnQgPSBuZXcgUGF0aF8xLlBhdGgodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2YXIoXCIgKyB0aGlzLm5hbWUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwYXRoU3RyID0gdGhpcy5wYXRoU3RyaW5nRm9yQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gXCJyZWFkX2NvdW50KFwiICsgcGF0aFN0ciArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZVJlZmVyZW5jZSA9IFZhcmlhYmxlUmVmZXJlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVSZWZlcmVuY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlc1N0YXRlID0gdm9pZCAwO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIFZhcmlhYmxlc1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsU3RhY2ssIGxpc3REZWZzT3JpZ2luKSB7XG4gICAgICAgIC8vIFRoZSB3YXkgdmFyaWFibGVDaGFuZ2VkRXZlbnQgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gT3JpZ2luYWxseSBpdCB1c2VzIHRoZSBDIyArPSBvcGVyYXRvciB0byBhZGQgZGVsZWdhdGVzLCBidXQgaW4ganMgd2UgbmVlZCB0byBtYWludGFpblxuICAgICAgICAvLyBhbiBhY3R1YWwgY29sbGVjdGlvbiBvZiBkZWxlZ2F0ZXMgKGllLiBjYWxsYmFja3MpIHRvIHJlZ2lzdGVyIGEgbmV3IG9uZSwgdGhlcmUgaXMgYVxuICAgICAgICAvLyBzcGVjaWFsIE9ic2VydmVWYXJpYWJsZUNoYW5nZSBtZXRob2QgYmVsb3cuXG4gICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5wYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWxsU3RhY2sgPSBjYWxsU3RhY2s7XG4gICAgICAgIHRoaXMuX2xpc3REZWZzT3JpZ2luID0gbGlzdERlZnNPcmlnaW47XG4gICAgICAgIC8vIGlmIGVzNiBwcm94aWVzIGFyZSBhdmFpbGFibGUsIHVzZSB0aGVtLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGhlIHByb3h5IGlzIHVzZWQgdG8gYWxsb3cgZGlyZWN0IG1hbmlwdWxhdGlvbiBvZiBnbG9iYWwgdmFyaWFibGVzLlxuICAgICAgICAgICAgLy8gSXQgZmlyc3QgdHJpZXMgdG8gYWNjZXNzIHRoZSBvYmplY3RzIG93biBwcm9wZXJ0eSwgYW5kIGlmIG5vbmUgaXNcbiAgICAgICAgICAgIC8vIGZvdW5kIGl0IGRlbGVnYXRlcyB0aGUgY2FsbCB0byB0aGUgJCBtZXRob2QsIGRlZmluZWQgYmVsb3dcbiAgICAgICAgICAgIGxldCBwID0gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIHRhcmdldCA/IHRhcmdldFtuYW1lXSA6IHRhcmdldC4kKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gdGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC4kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHJldHVybmluZyBhIGZhbHN5IHZhbHVlIG1ha2UgdGhlIHRyYXAgZmFpbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyB0aHIgcHJveHkgb2JqZWN0IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBjb250ZXh0LiB3ZSBzaG91bGQgd2FybiB0aGVcbiAgICAgICAgICAgIC8vIGRldiBidXQgd3JpdHRpbmcgdG8gdGhlIGNvbnNvbGUgZmVlbHMgYSBiaXQgaW50cnVzaXZlLlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFUzYgUHJveHkgbm90IGF2YWlsYWJsZSAtIGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgZ2xvYmFsIHZhcmlhYmxlcyBjYW4ndCB3b3JrLCB1c2UgJCgpIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2YgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2sodmFyaWFibGVOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM7XG4gICAgfVxuICAgIHNldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhcmlhYmxlTmFtZSBvZiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjdXJyZW50VmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYWxsU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhY2s7XG4gICAgfVxuICAgIHNldCBjYWxsU3RhY2soY2FsbFN0YWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxTdGFjayA9IGNhbGxTdGFjaztcbiAgICB9XG4gICAgLy8gdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBhIG1hZ2ljIGdldHRlciBhbmQgc2V0dGVyIGZvciBnbG9iYWwgdmFyaWFibGVzLFxuICAgIC8vIGFsbG93aW5nIHRoaW5ncyBsaWtlIHZhcmlhYmxlU3RhdGVbJ3Zhcm5hbWVdLiBUaGlzIGlzIG5vdCBxdWl0ZSBwb3NzaWJsZVxuICAgIC8vIGluIGpzIHdpdGhvdXQgYSBQcm94eSwgc28gaXQgaXMgcmVwbGFjZWQgd2l0aCB0aGlzICQgZnVuY3Rpb24uXG4gICAgJCh2YXJpYWJsZU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCB2YXJDb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyQ29udGVudHMuZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29udGVudHMucmVzdWx0LnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyQ29udGVudHMgPSB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhckNvbnRlbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyQ29udGVudHMgPSB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJDb250ZW50cyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29udGVudHMudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgYXNzaWduIHRvIGEgdmFyaWFibGUgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIHRoYXQgaGFzbid0IGJlZW4gZGVjbGFyZWQgaW4gdGhlIHN0b3J5XCIpO1xuICAgICAgICAgICAgbGV0IHZhbCA9IFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IHBhc3MgbnVsbCB0byBWYXJpYWJsZVN0YXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBWYXJpYWJsZVN0YXRlOiBcIiArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcHBseVBhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnBhdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtuYW1lZFZhcktleSwgbmFtZWRWYXJWYWx1ZV0gb2YgdGhpcy5wYXRjaC5nbG9iYWxzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KG5hbWVkVmFyS2V5LCBuYW1lZFZhclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHRoaXMucGF0Y2guY2hhbmdlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IG51bGw7XG4gICAgfVxuICAgIFNldEpzb25Ub2tlbihqVG9rZW4pIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmNsZWFyKCk7XG4gICAgICAgIGZvciAobGV0IFt2YXJWYWxLZXksIHZhclZhbFZhbHVlXSBvZiB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzKSB7XG4gICAgICAgICAgICBsZXQgbG9hZGVkVG9rZW4gPSBqVG9rZW5bdmFyVmFsS2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVkVG9rZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5JbmtPYmplY3QgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpUb2tlblRvUnVudGltZU9iamVjdChsb2FkZWRUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuSW5rT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidG9rZW5JbmtPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodmFyVmFsS2V5LCB0b2tlbklua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhclZhbEtleSwgdmFyVmFsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFdyaXRlSnNvbih3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleVZhbEtleSwga2V5VmFsVmFsdWVdIG9mIHRoaXMuX2dsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXlWYWxLZXk7XG4gICAgICAgICAgICBsZXQgdmFsID0ga2V5VmFsVmFsdWU7XG4gICAgICAgICAgICBpZiAoVmFyaWFibGVzU3RhdGUuZG9udFNhdmVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLlJ1bnRpbWVPYmplY3RzRXF1YWwodmFsLCBkZWZhdWx0VmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIHZhbCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBSdW50aW1lT2JqZWN0c0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKG9iajEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmoyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBpZiAoaW50VmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50VmFsLnZhbHVlID09PSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvYmoyLCBWYWx1ZV8xLkludFZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxvYXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMSwgVmFsdWVfMS5GbG9hdFZhbHVlKTtcbiAgICAgICAgaWYgKGZsb2F0VmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRWYWwudmFsdWUgPT09IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9iajIsIFZhbHVlXzEuRmxvYXRWYWx1ZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbDEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGxldCB2YWwyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajIsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBpZiAodmFsMSAhPT0gbnVsbCAmJiB2YWwyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoVHlwZUFzc2VydGlvbl8xLmlzRXF1YXRhYmxlKHZhbDEudmFsdWVPYmplY3QpICYmIFR5cGVBc3NlcnRpb25fMS5pc0VxdWF0YWJsZSh2YWwyLnZhbHVlT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwxLnZhbHVlT2JqZWN0LkVxdWFscyh2YWwyLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwxLnZhbHVlT2JqZWN0ID09PSB2YWwyLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhc3RSb3VnaERlZmluaXRlbHlFcXVhbHM6IFVuc3VwcG9ydGVkIHJ1bnRpbWUgb2JqZWN0IHR5cGU6IFwiICtcbiAgICAgICAgICAgIG9iajEuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxuICAgIEdldFZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgbGV0IHZhclZhbHVlID0gdGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIC8vIHZhciB2YXJQb2ludGVyID0gdmFyVmFsdWUgYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhclZhbHVlLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKHZhclBvaW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhclZhbHVlID0gdGhpcy5WYWx1ZUF0VmFyaWFibGVQb2ludGVyKHZhclBvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJWYWx1ZTtcbiAgICB9XG4gICAgVHJ5R2V0RGVmYXVsdFZhcmlhYmxlVmFsdWUobmFtZSkge1xuICAgICAgICBsZXQgdmFsID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICByZXR1cm4gdmFsLmV4aXN0cyA/IHZhbC5yZXN1bHQgOiBudWxsO1xuICAgIH1cbiAgICBHbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpKSk7XG4gICAgfVxuICAgIEdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KSB7XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gMCB8fCBjb250ZXh0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCB2YXJpYWJsZVZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IHRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbmRpdGlvbmFsIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUuZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdERlZnNPcmlnaW4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYXJpYWJsZXNTdGF0ZS5fbGlzdERlZnNPcmlnaW5cIik7XG4gICAgICAgICAgICBsZXQgbGlzdEl0ZW1WYWx1ZSA9IHRoaXMuX2xpc3REZWZzT3JpZ2luLkZpbmRTaW5nbGVJdGVtTGlzdFdpdGhOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RJdGVtVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RJdGVtVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyVmFsdWUgPSB0aGlzLl9jYWxsU3RhY2suR2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdmFyVmFsdWU7XG4gICAgfVxuICAgIFZhbHVlQXRWYXJpYWJsZVBvaW50ZXIocG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5HZXRWYXJpYWJsZVdpdGhOYW1lKHBvaW50ZXIudmFyaWFibGVOYW1lLCBwb2ludGVyLmNvbnRleHRJbmRleCk7XG4gICAgfVxuICAgIEFzc2lnbih2YXJBc3MsIHZhbHVlKSB7XG4gICAgICAgIGxldCBuYW1lID0gdmFyQXNzLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGV4dEluZGV4ID0gLTE7XG4gICAgICAgIGxldCBzZXRHbG9iYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhckFzcy5pc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBzZXRHbG9iYWwgPSB2YXJBc3MuaXNHbG9iYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRHbG9iYWwgPSB0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhckFzcy5pc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IHZhbHVlIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhclBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhclBvaW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbHlSZXNvbHZlZFZhcmlhYmxlUG9pbnRlciA9IHRoaXMuUmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bGx5UmVzb2x2ZWRWYXJpYWJsZVBvaW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZ1BvaW50ZXIgPSBHZXRSYXdWYXJpYWJsZVdpdGhOYW1lIChuYW1lLCBjb250ZXh0SW5kZXgpIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KSwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUG9pbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBleGlzdGluZ1BvaW50ZXIudmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0SW5kZXggPSBleGlzdGluZ1BvaW50ZXIuY29udGV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWwgPSBjb250ZXh0SW5kZXggPT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChleGlzdGluZ1BvaW50ZXIgIT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldEdsb2JhbCkge1xuICAgICAgICAgICAgdGhpcy5TZXRHbG9iYWwobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FsbFN0YWNrLlNldFRlbXBvcmFyeVZhcmlhYmxlKG5hbWUsIHZhbHVlLCB2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbiwgY29udGV4dEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTbmFwc2hvdERlZmF1bHRHbG9iYWxzKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMpO1xuICAgIH1cbiAgICBSZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCBvbGRMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2xkVmFsdWUsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IG5ld0xpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuZXdWYWx1ZSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBpZiAob2xkTGlzdC52YWx1ZSAmJiBuZXdMaXN0LnZhbHVlICYmIG5ld0xpc3QudmFsdWUuQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgbmV3TGlzdC52YWx1ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXMob2xkTGlzdC52YWx1ZS5vcmlnaW5OYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcywgdmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSB0aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsIHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVmFsdWVfMS5MaXN0VmFsdWUuUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLnJlc3VsdCwgdmFsdWUpO1xuICAgICAgICBpZiAodmFyaWFibGVOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInZhcmlhYmxlTmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXRjaC5TZXRHbG9iYWwodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IE5vdCBzdXJlICE9PSBpcyBlcXVpdmFsZW50IHRvICF2YWx1ZS5FcXVhbHMob2xkVmFsdWUpXG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICBvbGRWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG9sZFZhbHVlLnJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGNoLkFkZENoYW5nZWRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzLmFkZCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKSB7XG4gICAgICAgIGxldCBjb250ZXh0SW5kZXggPSB2YXJQb2ludGVyLmNvbnRleHRJbmRleDtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IHRoaXMuR2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHZhclBvaW50ZXIudmFyaWFibGVOYW1lKTtcbiAgICAgICAgbGV0IHZhbHVlT2ZWYXJpYWJsZVBvaW50ZWRUbyA9IHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZSh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgLy8gdmFyIGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciA9IHZhbHVlT2ZWYXJpYWJsZVBvaW50ZWRUbyBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgbGV0IGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8sIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICBpZiAoZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUodmFyUG9pbnRlci52YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHZhck5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh2YXJOYW1lKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc3BlY2lmaWMgdG8gdGhlIGpzIHZlcnNpb24gb2YgaW5rLiBJdCBhbGxvd3MgdG8gcmVnaXN0ZXIgYVxuICAgICAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHZhcmlhYmxlIGNoYW5nZXMuIFRoZSBvcmlnaW5hbCBjb2RlIHVzZXNcbiAgICAgKiBgc3RhdGUudmFyaWFibGVDaGFuZ2VkRXZlbnQgKz0gY2FsbGJhY2tgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIE9ic2VydmVWYXJpYWJsZUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVzU3RhdGUgPSBWYXJpYWJsZXNTdGF0ZTtcblZhcmlhYmxlc1N0YXRlLmRvbnRTYXZlRGVmYXVsdFZhbHVlcyA9IHRydWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZXNTdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVm9pZCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgVm9pZCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG59XG5leHBvcnRzLlZvaWQgPSBWb2lkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vm9pZC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IExvbmc7XHJcblxyXG4vKipcclxuICogd2FzbSBvcHRpbWl6YXRpb25zLCB0byBkbyBuYXRpdmUgaTY0IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpZGVcclxuICovXHJcbnZhciB3YXNtID0gbnVsbDtcclxuXHJcbnRyeSB7XHJcbiAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFtcclxuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXHJcbiAgXSkpLCB7fSkuZXhwb3J0cztcclxufSBjYXRjaCAoZSkge1xyXG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cclxuICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAqIEBleHBvcnRzIExvbmdcclxuICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxufVxyXG5cclxuLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcclxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbi8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcclxuLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbi8vXHJcbi8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcclxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbi8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4vLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXHJcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4vL1xyXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbi8qKlxyXG4gKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAY29uc3RcclxuICogQHByaXZhdGVcclxuICovXHJcbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKGlzTmFOKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcclxuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcclxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcclxuICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICB9XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgdmFyIHA7XHJcbiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgZWxzZSBpZiAocCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFpFUk87XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XHJcbiAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcclxuLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBaRVJPID0gZnJvbUludCgwKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVaRVJPID0gVVpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuT05FID0gT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVPTkUgPSBVT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTkVHX09ORSA9IE5FR19PTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHhGRkZGRkZGRnwwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQG92ZXJyaWRlXHJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiAnMCc7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcclxuICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy5lcShvdGhlcikpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xyXG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcclxuICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxyXG4gICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSB3YXNtLm11bCh0aGlzLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5oaWdoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcclxuXHJcbiAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKiBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKiBiMDA7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEwMCAqIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXHJcbiAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICByZXMgPSBVWkVSTztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xyXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXHJcbiAgICByZW0gPSB0aGlzO1xyXG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXHJcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXHJcbiAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcclxuXHJcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgaWYgKG51bUJpdHMgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcclxuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDI0XHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGhpID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZlxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcclxuICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzBdICAgICAgIHxcclxuICAgICAgICBieXRlc1sxXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzNdIDw8IDI0LFxyXG4gICAgICAgIGJ5dGVzWzRdICAgICAgIHxcclxuICAgICAgICBieXRlc1s1XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzddIDw8IDI0LFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbNF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbN10sXHJcbiAgICAgICAgYnl0ZXNbMF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1syXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbM10sXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcbiIsIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBleHBvcnRzO1xuXG4vKipcbiAqIEJ1aWxkIHR5cGUsIG9uZSBvZiBgXCJmdWxsXCJgLCBgXCJsaWdodFwiYCBvciBgXCJtaW5pbWFsXCJgLlxuICogQG5hbWUgYnVpbGRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xucHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyX2J1ZmZlclwiKTtcbnByb3RvYnVmLlJlYWRlciAgICAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcbnByb3RvYnVmLnJwYyAgICAgICAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcbnByb3RvYnVmLnJvb3RzICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBSZWNvbmZpZ3VyZXMgdGhlIGxpYnJhcnkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcbiAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xuICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG59XG5cbi8vIFNldCB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50XG5jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjY3Jvc3MgbW9kdWxlcy5cbiAqIEBuYW1lIHJvb3RzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XG4gKiBAZXhhbXBsZVxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXG4gKlxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcbiAqXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xuICovXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5hbWU7IH0gfSk7XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJcclxuaW1wb3J0IHtVbml0VGVzdH0gZnJvbSAnLi91bml0dGVzdC9Vbml0VGVzdCc7XHJcbmltcG9ydCB7IEdhbWVPYmplY3RQb29sIH0gZnJvbSAnLi9mcmFtZXdvcmsvY29tbW9uL0dhbWVPYmplY3RQb29sJztcclxuaW1wb3J0IHsgVUlNYW5hZ2VyIH0gZnJvbSAnLi9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyJztcclxuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gJy4vZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyJztcclxuXHJcbmltcG9ydCB7IEpzTWFuYWdlciAsR2FtZUxhdW5jaCwgTmljZVRTIH0gZnJvbSAnY3NoYXJwJztcclxuaW1wb3J0IHsgU2NlbmVEZWYgfSBmcm9tICcuL2ZyYW1ld29yay9zY2VuZS9TY2VuZURlZic7XHJcbmltcG9ydCB7IFNjZW5lTWFuYWdlciB9IGZyb20gJy4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlcic7XHJcbmltcG9ydCB7IFN0b3J5TWFuYWdlciB9IGZyb20gJy4vZnJhbWV3b3JrL2luay9TdG9yeU1hbmFnZXInO1xyXG5cclxuXHJcblxyXG5jbGFzcyBHYW1lTWFpbntcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkFwcGxpY2F0aW9uUXVpdCA9ICgpID0+IHRoaXMub25BcHBsaWNhdGlvblF1aXQoKTtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkRpc3Bvc2UgPSAoKSA9PiB0aGlzLm9uRGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICBcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR2FtZSBzdGFydCBpbiBKUy4uLi5cIik7XHJcblxyXG4gICAgICAgICAgICAvL+WQr+WKqOWNleS+i1xyXG4gICAgICAgICAgICBHYW1lT2JqZWN0UG9vbC5JbnN0YW5jZShHYW1lT2JqZWN0UG9vbCk7XHJcbiAgICBcclxuICAgICAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcik7XHJcbiAgICAgICAgICAgIFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcik7XHJcbiAgICAgICAgICAgIFN0b3J5TWFuYWdlci5JbnN0YW5jZShTdG9yeU1hbmFnZXIpLmluaXRpYWxpemUoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL+mihOWKoOi9vWV4Y2Vs5pWw5o2uXHJcbiAgICAgICAgICAgIC8vRXhjZWxNYW5hZ2VyLkluc3RhbmNlKEV4Y2VsTWFuYWdlcik7XHJcbiAgICAgIFxyXG4gICAgICAgICAgICAvL2RvIFVuaXQgVGVzdFxyXG4gICAgICAgICAgICBVbml0VGVzdC5kb1Rlc3QoKTtcclxuXHJcbiAgICAgICAgICAgIC8v6L+b5YWl55m75b2V5qih5Z2XXHJcbiAgICAgICAgICAgIFNjZW5lTWFuYWdlci5JbnN0YW5jZShTY2VuZU1hbmFnZXIpLmxvYWRTY2VuZShTY2VuZURlZi5Mb2dpblNjZW5lLCgpPT57fSk7XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9KU+WQr+WKqOWujOaIkO+8jOmAmuefpUMj5bGCXHJcbiAgICAgICAgICAgIEdhbWVMYXVuY2guSW5zdGFuY2UuSnNMdWFuY2hGaW5pc2goKTtcclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25BcHBsaWNhdGlvblF1aXQoKTp2b2lkIHtcclxuXHJcbiAgICAgICAgR2FtZU9iamVjdFBvb2wuSW5zdGFuY2UoR2FtZU9iamVjdFBvb2wpLmNsZWFudXAodHJ1ZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIG9uQXBwbGljYXRpb25RdWl0IGluIEpTLi4uLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25EaXNwb3NlKCk6dm9pZCB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIG9uRGlzcG9zZSBpbiBKUy4uLi5cIik7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxubmV3IEdhbWVNYWluKCkuc3RhcnQoKTtcclxuXHJcbiIsImltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvblwiO1xyXG5leHBvcnQgY2xhc3MgU2tpbGxDb25maWdUUntcclxuXHQgcHVibGljIF9pZDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX05hbWU6c3RyaW5nIDtcclxuXHQgcHVibGljIF9EZXNjcmlwdGlvbjpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0Nvb2xUaW1lOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQ29zdFNQOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXR0YWNrRGlzdGFuY2U6bnVtYmVyIDtcclxuXHQgcHVibGljIF9BdHRhY2tBbmdsZTpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0F0dGFja1RhcmdldFRhZ3M6QXJyYXk8c3RyaW5nPiA7XHJcblx0IHB1YmxpYyBfSW1wYWN0VHlwZTpBcnJheTxzdHJpbmc+IDtcclxuXHQgcHVibGljIF9OZXh0QmF0dGxlcklkOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXRrUmF0aW86bnVtYmVyIDtcclxuXHQgcHVibGljIF9EdXJhdGlvblRpbWU6bnVtYmVyIDtcclxuXHQgcHVibGljIF9BdGtJbnRlcnZhbDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX1NraWxsUHJlZmFiOnN0cmluZyA7XHJcblx0IHB1YmxpYyBfQW5pbWF0aW9uTmFtZTpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0hpdEZ4UHJlZmFiOnN0cmluZyA7XHJcblx0IHB1YmxpYyBfTGV2ZWw6bnVtYmVyIDtcclxuXHQgcHVibGljIF9BdHRhY2tUeXBlOm51bWJlciA7XHJcblx0IHB1YmxpYyBfU2VsZWN0b3JUeXBlOm51bWJlciA7XHJcblxyXG5cdGNvbnN0cnVjdG9yKF9pZDpudW1iZXIsIF9OYW1lOnN0cmluZywgX0Rlc2NyaXB0aW9uOnN0cmluZywgX0Nvb2xUaW1lOm51bWJlciwgX0Nvc3RTUDpudW1iZXIsIF9BdHRhY2tEaXN0YW5jZTpudW1iZXIsIF9BdHRhY2tBbmdsZTpudW1iZXIsIF9BdHRhY2tUYXJnZXRUYWdzOkFycmF5PHN0cmluZz4sIF9JbXBhY3RUeXBlOkFycmF5PHN0cmluZz4sIF9OZXh0QmF0dGxlcklkOm51bWJlciwgX0F0a1JhdGlvOm51bWJlciwgX0R1cmF0aW9uVGltZTpudW1iZXIsIF9BdGtJbnRlcnZhbDpudW1iZXIsIF9Ta2lsbFByZWZhYjpzdHJpbmcsIF9BbmltYXRpb25OYW1lOnN0cmluZywgX0hpdEZ4UHJlZmFiOnN0cmluZywgX0xldmVsOm51bWJlciwgX0F0dGFja1R5cGU6bnVtYmVyLCBfU2VsZWN0b3JUeXBlOm51bWJlcil7XHJcblx0XHR0aGlzLl9pZCA9IF9pZDtcclxuXHRcdHRoaXMuX05hbWUgPSBfTmFtZTtcclxuXHRcdHRoaXMuX0Rlc2NyaXB0aW9uID0gX0Rlc2NyaXB0aW9uO1xyXG5cdFx0dGhpcy5fQ29vbFRpbWUgPSBfQ29vbFRpbWU7XHJcblx0XHR0aGlzLl9Db3N0U1AgPSBfQ29zdFNQO1xyXG5cdFx0dGhpcy5fQXR0YWNrRGlzdGFuY2UgPSBfQXR0YWNrRGlzdGFuY2U7XHJcblx0XHR0aGlzLl9BdHRhY2tBbmdsZSA9IF9BdHRhY2tBbmdsZTtcclxuXHRcdHRoaXMuX0F0dGFja1RhcmdldFRhZ3MgPSBfQXR0YWNrVGFyZ2V0VGFncztcclxuXHRcdHRoaXMuX0ltcGFjdFR5cGUgPSBfSW1wYWN0VHlwZTtcclxuXHRcdHRoaXMuX05leHRCYXR0bGVySWQgPSBfTmV4dEJhdHRsZXJJZDtcclxuXHRcdHRoaXMuX0F0a1JhdGlvID0gX0F0a1JhdGlvO1xyXG5cdFx0dGhpcy5fRHVyYXRpb25UaW1lID0gX0R1cmF0aW9uVGltZTtcclxuXHRcdHRoaXMuX0F0a0ludGVydmFsID0gX0F0a0ludGVydmFsO1xyXG5cdFx0dGhpcy5fU2tpbGxQcmVmYWIgPSBfU2tpbGxQcmVmYWI7XHJcblx0XHR0aGlzLl9BbmltYXRpb25OYW1lID0gX0FuaW1hdGlvbk5hbWU7XHJcblx0XHR0aGlzLl9IaXRGeFByZWZhYiA9IF9IaXRGeFByZWZhYjtcclxuXHRcdHRoaXMuX0xldmVsID0gX0xldmVsO1xyXG5cdFx0dGhpcy5fQXR0YWNrVHlwZSA9IF9BdHRhY2tUeXBlO1xyXG5cdFx0dGhpcy5fU2VsZWN0b3JUeXBlID0gX1NlbGVjdG9yVHlwZTtcclxuXHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU2tpbGxDb25maWdUQiBleHRlbmRzIFNpbmdsZXRvbjxTa2lsbENvbmZpZ1RCPnsgXHJcblx0cHVibGljIHRyczpNYXA8bnVtYmVyLCBTa2lsbENvbmZpZ1RSPiA9IG5ldyBNYXA8bnVtYmVyLCBTa2lsbENvbmZpZ1RSPigpO1xyXG5cdGNvbnN0cnVjdG9yKCl7XHJcblx0XHRzdXBlcigpO1xyXG5cdFx0dGhpcy50cnMuc2V0KDEwMDEsIG5ldyBTa2lsbENvbmZpZ1RSKDEwMDEsIFwi6ZmN6b6Z5Y2B5YWr5o6MXCIsIFwi5bim5pyJ5by65Yqb5pS75Ye75oqA6IO9XCIsIDEwLCAxNzgsIDEsIDMwLCBbXCJFbmVteVwiXSwgW1wiQ29zdFNQXCIsIFwiRGFtYWdlXCJdLCAwLCAyLCAyLCAxLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgXCJza2lsbDFcIiwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIDEsIDEsIDEpKTtcclxuXHRcdHRoaXMudHJzLnNldCgxMDAyLCBuZXcgU2tpbGxDb25maWdUUigxMDAyLCBcIuaatOmbqOaiqOiKsVwiLCBcIuW4puacieW8uuWKm+aUu+WHu+aKgOiDvVwiLCAxMCwgMTc4LCAxLCAzMCwgW1wiRW5lbXlcIl0sIFtcIkNvc3RTUFwiLCBcIkRhbWFnZVwiXSwgMCwgMiwgMiwgMSwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIFwic2tpbGwyXCIsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCAxLCAxLCAxKSk7XHJcblx0XHR0aGlzLnRycy5zZXQoMTAwMywgbmV3IFNraWxsQ29uZmlnVFIoMTAwMywgXCLmjpLlsbHlgJLmtbdcIiwgXCLluKbmnInlvLrlipvmlLvlh7vmioDog71cIiwgMTAsIDE3OCwgMSwgMzAsIFtcIkVuZW15XCJdLCBbXCJDb3N0U1BcIiwgXCJEYW1hZ2VcIl0sIDAsIDIsIDIsIDEsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCBcInNraWxsM1wiLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgMSwgMSwgMSkpO1xyXG5cdFx0dGhpcy50cnMuc2V0KDEwMDQsIG5ldyBTa2lsbENvbmZpZ1RSKDEwMDQsIFwi6JG16Iqx54K556m05omLXCIsIFwi5bim5pyJ5by65Yqb5pS75Ye75oqA6IO9XCIsIDEwLCAxNzgsIDEsIDMwLCBbXCJFbmVteVwiXSwgW1wiQ29zdFNQXCIsIFwiRGFtYWdlXCJdLCAwLCAyLCAyLCAxLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgXCJza2lsbDRcIiwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIDEsIDEsIDEpKTtcclxuXHQgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBuaWNlX3RzIH0gZnJvbSBcIi4vZ2VuL3BiXCI7XHJcbmV4cG9ydCBjbGFzcyBEZWNvZGVNc2d7XHJcblx0cHVibGljIHJwY0lkOm51bWJlcjtcclxuXHRwdWJsaWMgbXNnT2JqOmFueTtcclxufVxyXG5leHBvcnQgY2xhc3MgT3Bjb2Rle1xyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX0MyUl9Mb2dpbjpudW1iZXIgPSAxMDAwO1xyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX1IyQ19Mb2dpbjpudW1iZXIgPSAxMDAxO1xyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX0MyR19Mb2dpbkdhdGU6bnVtYmVyID0gMTAwMjtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19HMkNfTG9naW5HYXRlOm51bWJlciA9IDEwMDM7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX0MyR1NfVGVzdDpudW1iZXIgPSAyMDAxO1xyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX0dTMkNfVGVzdDpudW1iZXIgPSAyMDAyO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIG1hcCA9IHtcclxuXHRcdDEwMDAgOiBuaWNlX3RzLkMyUl9Mb2dpbi5kZWNvZGUsXHJcblx0XHQxMDAxIDogbmljZV90cy5SMkNfTG9naW4uZGVjb2RlLFxyXG5cdFx0MTAwMiA6IG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS5kZWNvZGUsXHJcblx0XHQxMDAzIDogbmljZV90cy5HMkNfTG9naW5HYXRlLmRlY29kZSxcclxuXHJcblx0XHQyMDAxIDogbmljZV90cy5DMkdTX1Rlc3QuZGVjb2RlLFxyXG5cdFx0MjAwMiA6IG5pY2VfdHMuR1MyQ19UZXN0LmRlY29kZSxcclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBkZWNvZGUob3Bjb2RlOm51bWJlciwgbXNnOlVpbnQ4QXJyYXkpOkRlY29kZU1zZyB7XHJcblx0XHRsZXQgbXNnT2JqID0gdGhpcy5tYXBbb3Bjb2RlXShtc2cpO1xyXG5cdFx0bGV0IGRlY29kZU1zZyA9IG5ldyBEZWNvZGVNc2coKTtcclxuXHRcdGRlY29kZU1zZy5ycGNJZCA9IG1zZ09iai5ScGNJZDtcclxuXHRcdGRlY29kZU1zZy5tc2dPYmogPSBtc2dPYmo7XHJcblx0XHRyZXR1cm4gZGVjb2RlTXNnO1xyXG5cdH1cclxufVxyXG4iLCIvKmVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIGlkLWxlbmd0aCwgbm8tY29udHJvbC1yZWdleCwgbm8tbWFnaWMtbnVtYmVycywgbm8tcHJvdG90eXBlLWJ1aWx0aW5zLCBuby1yZWRlY2xhcmUsIG5vLXNoYWRvdywgbm8tdmFyLCBzb3J0LXZhcnMqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpO1xuXG4vLyBDb21tb24gYWxpYXNlc1xudmFyICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyLCAkV3JpdGVyID0gJHByb3RvYnVmLldyaXRlciwgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcblxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcbiRwcm90b2J1Zi51dGlsLkxvbmcgPSBMb25nO1xuJHByb3RvYnVmLmNvbmZpZ3VyZSgpO1xuXG5cbi8vIEV4cG9ydGVkIHJvb3QgbmFtZXNwYWNlXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xuXG4kcm9vdC5uaWNlX3RzID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIG5pY2VfdHMuXG4gICAgICogQGV4cG9ydHMgbmljZV90c1xuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKi9cbiAgICB2YXIgbmljZV90cyA9IHt9O1xuXG4gICAgbmljZV90cy5DMlJfTG9naW4gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBDMlJfTG9naW4uXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUMyUl9Mb2dpblxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbQWNjb3VudF0gQzJSX0xvZ2luIEFjY291bnRcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW1Bhc3N3b3JkXSBDMlJfTG9naW4gUGFzc3dvcmRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJSX0xvZ2luLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMlJfTG9naW4uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMlJfTG9naW5cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDMlJfTG9naW4ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDMlJfTG9naW4gQWNjb3VudC5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBBY2NvdW50XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUuQWNjb3VudCA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEMyUl9Mb2dpbiBQYXNzd29yZC5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXNzd29yZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4ucHJvdG90eXBlLlBhc3N3b3JkID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDMlJfTG9naW4gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJSX0xvZ2luKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJSX0xvZ2luIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJSX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWNjb3VudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiQWNjb3VudFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLkFjY291bnQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBhc3N3b3JkXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UuUGFzc3dvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyUl9Mb2dpbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyUl9Mb2dpbn0gbWVzc2FnZSBDMlJfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMlJfTG9naW4oKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5BY2NvdW50ID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGFzc3dvcmQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW5cbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQzJSX0xvZ2luIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWNjb3VudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJBY2NvdW50XCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BY2NvdW50KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWNjb3VudDogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QYXNzd29yZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQYXNzd29yZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuUGFzc3dvcmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJQYXNzd29yZDogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW5cbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMlJfTG9naW4oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuQWNjb3VudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWNjb3VudCA9IFN0cmluZyhvYmplY3QuQWNjb3VudCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LlBhc3N3b3JkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5QYXNzd29yZCA9IFN0cmluZyhvYmplY3QuUGFzc3dvcmQpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEMyUl9Mb2dpbiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpblxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5BY2NvdW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBvYmplY3QuUGFzc3dvcmQgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWNjb3VudCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJBY2NvdW50XCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5BY2NvdW50ID0gbWVzc2FnZS5BY2NvdW50O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGFzc3dvcmRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LlBhc3N3b3JkID0gbWVzc2FnZS5QYXNzd29yZDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJSX0xvZ2luIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDMlJfTG9naW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDMlJfTG9naW47XG4gICAgfSkoKTtcblxuICAgIG5pY2VfdHMuUjJDX0xvZ2luID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgUjJDX0xvZ2luLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElSMkNfTG9naW5cbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBSMkNfTG9naW4gRXJyb3JcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIFIyQ19Mb2dpbiBNZXNzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtBZGRyZXNzXSBSMkNfTG9naW4gQWRkcmVzc1xuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtLZXldIFIyQ19Mb2dpbiBLZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbR2F0ZUlkXSBSMkNfTG9naW4gR2F0ZUlkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFIyQ19Mb2dpbi5cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUjJDX0xvZ2luLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJUjJDX0xvZ2luXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUjJDX0xvZ2luKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUjJDX0xvZ2luIEVycm9yLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEVycm9yXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuRXJyb3IgPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSMkNfTG9naW4gTWVzc2FnZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBNZXNzYWdlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuTWVzc2FnZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFIyQ19Mb2dpbiBBZGRyZXNzLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEFkZHJlc3NcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5BZGRyZXNzID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUjJDX0xvZ2luIEtleS5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IEtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLktleSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSMkNfTG9naW4gR2F0ZUlkLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gR2F0ZUlkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuR2F0ZUlkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgUjJDX0xvZ2luIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpbiBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFIyQ19Mb2dpbihwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFIyQ19Mb2dpbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLlIyQ19Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbn0gbWVzc2FnZSBSMkNfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkFkZHJlc3NcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5BZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiS2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50NjQobWVzc2FnZS5LZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQ2NChtZXNzYWdlLkdhdGVJZCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiRXJyb3JcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5MSwgd2lyZVR5cGUgMCA9Ki83MjgpLmludDMyKG1lc3NhZ2UuRXJyb3IpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkyLCB3aXJlVHlwZSAyID0qLzczOCkuc3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUjJDX0xvZ2luIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuUjJDX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLlIyQ19Mb2dpbigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5BZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBSMkNfTG9naW4gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2U6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWRkcmVzcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJBZGRyZXNzXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BZGRyZXNzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWRkcmVzczogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5KSAmJiAhKG1lc3NhZ2UuS2V5ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIktleTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiR2F0ZUlkXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkKSAmJiAhKG1lc3NhZ2UuR2F0ZUlkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdhdGVJZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuUjJDX0xvZ2lufSBSMkNfTG9naW5cbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLlIyQ19Mb2dpbilcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5SMkNfTG9naW4oKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuRXJyb3IgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuTWVzc2FnZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IFN0cmluZyhvYmplY3QuTWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LkFkZHJlc3MgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkFkZHJlc3MgPSBTdHJpbmcob2JqZWN0LkFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5LZXkgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuS2V5ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LktleSkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcGFyc2VJbnQob2JqZWN0LktleSwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IG9iamVjdC5LZXk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5LZXkubG93ID4+PiAwLCBvYmplY3QuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LkdhdGVJZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5HYXRlSWQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuR2F0ZUlkKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBwYXJzZUludChvYmplY3QuR2F0ZUlkLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gb2JqZWN0LkdhdGVJZDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LkdhdGVJZC5sb3cgPj4+IDAsIG9iamVjdC5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBSMkNfTG9naW4gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLlIyQ19Mb2dpbn0gbWVzc2FnZSBSMkNfTG9naW5cbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QuQWRkcmVzcyA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWRkcmVzc1wiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuQWRkcmVzcyA9IG1lc3NhZ2UuQWRkcmVzcztcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLktleSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLktleSkgOiBtZXNzYWdlLktleTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuS2V5KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLktleS5sb3cgPj4+IDAsIG1lc3NhZ2UuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLktleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLkdhdGVJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLkdhdGVJZCkgOiBtZXNzYWdlLkdhdGVJZDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuR2F0ZUlkKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLkdhdGVJZC5sb3cgPj4+IDAsIG1lc3NhZ2UuR2F0ZUlkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLkdhdGVJZDtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IG1lc3NhZ2UuRXJyb3I7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBtZXNzYWdlLk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFIyQ19Mb2dpbiB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gUjJDX0xvZ2luO1xuICAgIH0pKCk7XG5cbiAgICBuaWNlX3RzLkMyR19Mb2dpbkdhdGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBDMkdfTG9naW5HYXRlLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElDMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0tleV0gQzJHX0xvZ2luR2F0ZSBLZXlcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbR2F0ZUlkXSBDMkdfTG9naW5HYXRlIEdhdGVJZFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDMkdfTG9naW5HYXRlLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMkdfTG9naW5HYXRlLlxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDMkdfTG9naW5HYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQzJHX0xvZ2luR2F0ZSBLZXkuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBLZXlcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLktleSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDMkdfTG9naW5HYXRlIEdhdGVJZC5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IEdhdGVJZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuR2F0ZUlkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQzJHX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHX0xvZ2luR2F0ZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEMyR19Mb2dpbkdhdGUocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlfSBtZXNzYWdlIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIktleVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5LZXkpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLkdhdGVJZCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyR19Mb2dpbkdhdGUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHX0xvZ2luR2F0ZX0gbWVzc2FnZSBDMkdfTG9naW5HYXRlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IEMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMkdfTG9naW5HYXRlIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5KSAmJiAhKG1lc3NhZ2UuS2V5ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIktleTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiR2F0ZUlkXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkKSAmJiAhKG1lc3NhZ2UuR2F0ZUlkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdhdGVJZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdfTG9naW5HYXRlKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LktleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5LZXkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuS2V5KSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBwYXJzZUludChvYmplY3QuS2V5LCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gb2JqZWN0LktleTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LktleS5sb3cgPj4+IDAsIG9iamVjdC5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuR2F0ZUlkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLkdhdGVJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5HYXRlSWQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHBhcnNlSW50KG9iamVjdC5HYXRlSWQsIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBvYmplY3QuR2F0ZUlkO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuR2F0ZUlkLmxvdyA+Pj4gMCwgb2JqZWN0LkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBtZXNzYWdlIEMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLktleSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLktleSkgOiBtZXNzYWdlLktleTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuS2V5KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLktleS5sb3cgPj4+IDAsIG1lc3NhZ2UuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLktleTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLkdhdGVJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLkdhdGVJZCkgOiBtZXNzYWdlLkdhdGVJZDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuR2F0ZUlkKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLkdhdGVJZC5sb3cgPj4+IDAsIG1lc3NhZ2UuR2F0ZUlkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLkdhdGVJZDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHX0xvZ2luR2F0ZSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDMkdfTG9naW5HYXRlO1xuICAgIH0pKCk7XG5cbiAgICBuaWNlX3RzLkcyQ19Mb2dpbkdhdGUgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHMkNfTG9naW5HYXRlLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElHMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtFcnJvcl0gRzJDX0xvZ2luR2F0ZSBFcnJvclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbTWVzc2FnZV0gRzJDX0xvZ2luR2F0ZSBNZXNzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW1BsYXllcklkXSBHMkNfTG9naW5HYXRlIFBsYXllcklkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEcyQ19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEcyQ19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEcyQ19Mb2dpbkdhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHMkNfTG9naW5HYXRlIEVycm9yLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEVycm9yXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5FcnJvciA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgTWVzc2FnZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBNZXNzYWdlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5NZXNzYWdlID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRzJDX0xvZ2luR2F0ZSBQbGF5ZXJJZC5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IFBsYXllcklkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5QbGF5ZXJJZCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEcyQ19Mb2dpbkdhdGUgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHMkNfTG9naW5HYXRlKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkcyQ19Mb2dpbkdhdGUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBsYXllcklkXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLlBsYXllcklkKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHMkNfTG9naW5HYXRlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlfSBtZXNzYWdlIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HMkNfTG9naW5HYXRlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLlBsYXllcklkID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2U6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGxheWVySWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5QbGF5ZXJJZCkgJiYgIShtZXNzYWdlLlBsYXllcklkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLlBsYXllcklkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuUGxheWVySWQuaGlnaCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJQbGF5ZXJJZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HMkNfTG9naW5HYXRlKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IG9iamVjdC5FcnJvciB8IDA7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lk1lc3NhZ2UgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5QbGF5ZXJJZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5QbGF5ZXJJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5QbGF5ZXJJZCkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5QbGF5ZXJJZCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IHBhcnNlSW50KG9iamVjdC5QbGF5ZXJJZCwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSBvYmplY3QuUGxheWVySWQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5QbGF5ZXJJZCA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuUGxheWVySWQubG93ID4+PiAwLCBvYmplY3QuUGxheWVySWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QbGF5ZXJJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQbGF5ZXJJZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLlBsYXllcklkKSA6IG1lc3NhZ2UuUGxheWVySWQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuUGxheWVySWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuUGxheWVySWQubG93ID4+PiAwLCBtZXNzYWdlLlBsYXllcklkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLlBsYXllcklkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gbWVzc2FnZS5FcnJvcjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IG1lc3NhZ2UuTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgRzJDX0xvZ2luR2F0ZSB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBHMkNfTG9naW5HYXRlO1xuICAgIH0pKCk7XG5cbiAgICBuaWNlX3RzLkMyR1NfVGVzdCA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEMyR1NfVGVzdC5cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJHU19UZXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFt0ZXN0SURdIEMyR1NfVGVzdCB0ZXN0SURcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3Rlc3ROYW1lXSBDMkdTX1Rlc3QgdGVzdE5hbWVcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJHU19UZXN0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMkdTX1Rlc3QuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMkdTX1Rlc3RcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHU19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBDMkdTX1Rlc3QocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDMkdTX1Rlc3QgdGVzdElELlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRlc3RJRFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRlc3RJRCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEMyR1NfVGVzdCB0ZXN0TmFtZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0TmFtZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRlc3ROYW1lID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDMkdTX1Rlc3QgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHU19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0IGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJHU19UZXN0KHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHU19UZXN0IG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHU19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHU19UZXN0fSBtZXNzYWdlIEMyR1NfVGVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZXN0SURcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDMyKG1lc3NhZ2UudGVzdElEKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3ROYW1lICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZXN0TmFtZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLnRlc3ROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdTX1Rlc3QgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMkdTX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdElEID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0TmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR1NfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0SUQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdElEXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UudGVzdElEKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdElEOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0TmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0TmFtZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudGVzdE5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0TmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyR1NfVGVzdCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHU19UZXN0fSBDMkdTX1Rlc3RcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkMyR1NfVGVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdElEICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0SUQgPSBvYmplY3QudGVzdElEIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdE5hbWUgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3ROYW1lID0gU3RyaW5nKG9iamVjdC50ZXN0TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHU19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5DMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0XG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3RJRCA9IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3ROYW1lID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0SURcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3RJRCA9IG1lc3NhZ2UudGVzdElEO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdE5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdE5hbWVcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3ROYW1lID0gbWVzc2FnZS50ZXN0TmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHU19UZXN0IHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBDMkdTX1Rlc3Q7XG4gICAgfSkoKTtcblxuICAgIG5pY2VfdHMuR1MyQ19UZXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgR1MyQ19UZXN0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElHUzJDX1Rlc3RcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBHUzJDX1Rlc3QgRXJyb3JcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIEdTMkNfVGVzdCBNZXNzYWdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt0ZXN0UmVzcG9uc2VdIEdTMkNfVGVzdCB0ZXN0UmVzcG9uc2VcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgR1MyQ19UZXN0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHUzJDX1Rlc3QuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHUzJDX1Rlc3RcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBHUzJDX1Rlc3QocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHUzJDX1Rlc3QgRXJyb3IuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gRXJyb3JcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS5FcnJvciA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdTMkNfVGVzdCBNZXNzYWdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS5NZXNzYWdlID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR1MyQ19UZXN0IHRlc3RSZXNwb25zZS5cbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0UmVzcG9uc2VcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS50ZXN0UmVzcG9uc2UgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEdTMkNfVGVzdCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHUzJDX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3QgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBHUzJDX1Rlc3QocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHUzJDX1Rlc3QgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HUzJDX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHUzJDX1Rlc3R9IG1lc3NhZ2UgR1MyQ19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0UmVzcG9uc2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3RSZXNwb25zZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLnRlc3RSZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiRXJyb3JcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5MSwgd2lyZVR5cGUgMCA9Ki83MjgpLmludDMyKG1lc3NhZ2UuRXJyb3IpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkyLCB3aXJlVHlwZSAyID0qLzczOCkuc3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR1MyQ19UZXN0IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuR1MyQ19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0fSBtZXNzYWdlIEdTMkNfVGVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HUzJDX1Rlc3R9IEdTMkNfVGVzdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdCgpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0UmVzcG9uc2UgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZlcmlmaWVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UuXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5FcnJvcikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLk1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RSZXNwb25zZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0UmVzcG9uc2VcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRlc3RSZXNwb25zZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlc3RSZXNwb25zZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HUzJDX1Rlc3QoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuRXJyb3IgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuTWVzc2FnZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IFN0cmluZyhvYmplY3QuTWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlc3RSZXNwb25zZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdFJlc3BvbnNlID0gU3RyaW5nKG9iamVjdC50ZXN0UmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEdTMkNfVGVzdCBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuR1MyQ19UZXN0fSBtZXNzYWdlIEdTMkNfVGVzdFxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0UmVzcG9uc2UgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdFJlc3BvbnNlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RSZXNwb25zZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdFJlc3BvbnNlID0gbWVzc2FnZS50ZXN0UmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSBtZXNzYWdlLkVycm9yO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gbWVzc2FnZS5NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBHUzJDX1Rlc3QgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEdTMkNfVGVzdDtcbiAgICB9KSgpO1xuXG4gICAgcmV0dXJuIG5pY2VfdHM7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICRyb290O1xuIiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIGNvbW1vblVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImNvbW1vblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiY29tbW9uX2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlMb2FkaW5nUGFnZTpzdHJpbmcgPSBcIkxvYWRpbmdQYWdlXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVVJTm90aWNlV2luOnN0cmluZyA9IFwiVUlOb3RpY2VXaW5cIjtcbn0iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3MgaG9tZVVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImhvbWVcIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImhvbWVfZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUhvbWVQYWdlOnN0cmluZyA9IFwiSG9tZVBhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJTGV2ZWxQYWdlOnN0cmluZyA9IFwiTGV2ZWxQYWdlXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVNob3BQYWdlOnN0cmluZyA9IFwiU2hvcFBhZ2VcIjtcbn0iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3MgbG9naW5VSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJsb2dpblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwibG9naW5fZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUxvZ2luUGFnZTpzdHJpbmcgPSBcIkxvZ2luUGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlTZWxTZXJ2ZXJXaW46c3RyaW5nID0gXCJTZWxTZXJ2ZXJXaW5cIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJQXJlYUl0ZW06c3RyaW5nID0gXCJBcmVhSXRlbVwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBzdG9yeVVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcInN0b3J5XCI7XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlQnl0ZXM6c3RyaW5nID0gXCJzdG9yeV9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJU3RvcnlXaW46c3RyaW5nID0gXCJTdG9yeVdpblwiO1xufSIsIlxyXG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tICcuL1NpbmdsZXRvbic7XHJcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tICcuL1Jlc01hbmFnZXInO1xyXG5pbXBvcnQgeyBVbml0eUVuZ2luZSB9IGZyb20gJ2NzaGFycCc7XHJcblxyXG5cclxuXHJcbi8vIC0tIEdhbWVPYmplY3TnvJPlrZjmsaBcclxuLy8gLS0g5rOo5oSP77yaXHJcbi8vIC0tIDHjgIHmiYDmnInpnIDopoHpooTorr7pg73ku47ov5nph4zliqDovb3vvIzkuI3opoHnm7TmjqXliLBSZXNvdXJjZXNNYW5hZ2Vy5Y675Yqg6L2977yM55Sx6L+Z6YeM57uf5LiA5YGa57yT5a2Y566h55CGXHJcbi8vIC0tIDLjgIHnvJPlrZjliIbkuLrkuKTpg6jliIbvvJrku47otYTmupDlsYLliqDovb3nmoTljp/lp4tHYW1lT2JqZWN0KEFzc2V0Ke+8jOS7jkdhbWVPYmplY3Tlrp7kvovljJblh7rmnaXnmoTlpJrkuKpJbnN0XHJcbmV4cG9ydCBjbGFzcyBHYW1lT2JqZWN0UG9vbCBleHRlbmRzIFNpbmdsZXRvbjxHYW1lT2JqZWN0UG9vbD57XHJcblxyXG4gICAgcHJpdmF0ZSBfX2NhY2hlVHJhbnNSb290ID0gbnVsbDtcclxuICAgIHByaXZhdGUgX19nb1Bvb2wgPSBuZXcgTWFwKCk7XHJcbiAgICBwcml2YXRlIF9faW5zdENhY2hlOk1hcDxzdHJpbmcsQXJyYXk8YW55Pj4gPSBuZXcgTWFwPHN0cmluZyxBcnJheTxhbnk+PigpO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIGxldCBnbyA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuRmluZChcIkdhbWVPYmplY3RDYWNoZVJvb3RcIik7XHJcblxyXG4gICAgICAgIGlmKGdvID09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGdvID0gbmV3IFVuaXR5RW5naW5lLkdhbWVPYmplY3QoXCJHYW1lT2JqZWN0Q2FjaGVSb290XCIpO1xyXG4gICAgICAgICAgICBVbml0eUVuZ2luZS5PYmplY3QuRG9udERlc3Ryb3lPbkxvYWQoZ28pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fX2NhY2hlVHJhbnNSb290ID0gZ28udHJhbnNmb3JtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0g5qOA5rWL5piv5ZCm5bey57uP6KKr57yT5a2YXHJcbiAgICBwdWJsaWMgY2hlY2tIYXNDYWNoZWQocGF0aDpzdHJpbmcpe1xyXG5cclxuICAgICAgICBsZXQgY2FjaGVkSW5zdDpBcnJheTxhbnk+ID0gdGhpcy5fX2luc3RDYWNoZS5nZXQocGF0aCk7XHJcbiAgICAgICAgaWYoY2FjaGVkSW5zdCAhPSB1bmRlZmluZWQgJiYgY2FjaGVkSW5zdC5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcG9vbGVkR28gPSB0aGlzLl9fZ29Qb29sLmdldChwYXRoKTtcclxuICAgICAgICByZXR1cm4gcG9vbGVkR28gIT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOe8k+WtmOW5tuWunuS+i+WMlkdhbWVPYmplY3RcclxuICAgIHB1YmxpYyBjYWNoZUFuZEluc3RHYW1lT2JqZWN0KHBhdGg6c3RyaW5nLCBnbzphbnksIGluc3RfY291bnQ6bnVtYmVyID0gMSl7XHJcblxyXG4gICAgICAgIHRoaXMuX19nb1Bvb2wuc2V0KHBhdGgsIGdvKTtcclxuICAgICAgICBpZihpbnN0X2NvdW50ID4gMCl7XHJcblxyXG4gICAgICAgICAgICBsZXQgY2FjaGVkSW5zdDpBcnJheTxhbnk+ID0gdGhpcy5fX2luc3RDYWNoZS5nZXQocGF0aCk7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaTpudW1iZXIgPTA7IGkgPCBpbnN0X2NvdW50OyBpKyspe1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpbnN0ID0gVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5JbnN0YW50aWF0ZShnbykgYXMgVW5pdHlFbmdpbmUuR2FtZU9iamVjdDtcclxuICAgICAgICAgICAgICAgIGluc3QudHJhbnNmb3JtLlNldFBhcmVudCh0aGlzLl9fY2FjaGVUcmFuc1Jvb3QpO1xyXG4gICAgICAgICAgICAgICAgaW5zdC5TZXRBY3RpdmUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhY2hlZEluc3QucHVzaChpbnN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy0tIOWwneivleS7jue8k+WtmOS4reiOt+WPllxyXG4gICAgcHVibGljIHRyeUdldEZyb21DYWNoZShwYXRoOnN0cmluZyk6YW55e1xyXG5cclxuICAgICAgICBpZighdGhpcy5jaGVja0hhc0NhY2hlZChwYXRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjYWNoZWRJbnN0OkFycmF5PG9iamVjdD4gID0gdGhpcy5fX2luc3RDYWNoZS5nZXQocGF0aCk7XHJcbiAgICAgICAgaWYoY2FjaGVkSW5zdCAhPSB1bmRlZmluZWQgJiYgY2FjaGVkSW5zdC5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgaW5zdCA9IGNhY2hlZEluc3QucG9wKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBvb2xlZEdvID0gdGhpcy5fX2dvUG9vbC5nZXQocGF0aCk7XHJcbiAgICAgICAgaWYocG9vbGVkR28gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbGV0IGluc3QgPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKHBvb2xlZEdvKTtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvL+mihOWKoOi9ve+8muWPr+aPkOS+m+WIneWni+WunuS+i+WMluS4quaVsFxyXG4gICAgcHVibGljIGFzeW5jIHByZUxvYWRHYW1lT2JqZWN0QXN5bmMocGF0aDpzdHJpbmcsIGluc3RfY291bnQ6bnVtYmVyLCBjYWxsYmFjazpGdW5jdGlvbiwuLi5wYXJhbXMpe1xyXG5cclxuICAgICAgICBpZih0aGlzLmNoZWNrSGFzQ2FjaGVkKHBhdGgpKXtcclxuICAgICAgICAgICAgaWYoY2FsbGJhY2shPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socGFyYW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZ28gPSBhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRQcmVmYWIocGF0aCk7XHJcbiAgICAgICAgaWYoZ28hPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVBbmRJbnN0R2FtZU9iamVjdChwYXRoLCBnbyxpbnN0X2NvdW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKGNhbGxiYWNrIT1udWxsKXtcclxuICAgICAgICAgICAgY2FsbGJhY2socGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g5byC5q2l6I635Y+W77ya5b+F6KaB5pe25Yqg6L29XHJcbiAgICBwdWJsaWMgYXN5bmMgZ2V0R2FtZU9iamVjdEFzeW5jKHBhdGg6c3RyaW5nLCBjYWxsYmFjazpGdW5jdGlvbiwuLi5wYXJhbXMpe1xyXG5cclxuICAgICAgICBsZXQgaW5zdDphbnkgPSB0aGlzLnRyeUdldEZyb21DYWNoZShwYXRoKTtcclxuICAgICAgICBpZihpbnN0ID09bnVsbCl7XHJcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucHJlTG9hZEdhbWVPYmplY3RBc3luYyhwYXRoLCAxLCBjYWxsYmFjaywgcGFyYW1zKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGluc3QgPSB0aGlzLnRyeUdldEZyb21DYWNoZShwYXRoKTtcclxuICAgICAgICBpbnN0LlNldEFjdGl2ZSh0cnVlKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g5Zue5pS2XHJcbiAgICBwdWJsaWMgcmVjeWNsZUdhbWVPYmplY3QocGF0aDpzdHJpbmcsIGluc3Q6YW55KXtcclxuXHJcbiAgICAgICAgaW5zdC50cmFuc2Zvcm0uU2V0UGFyZW50KHRoaXMuX19jYWNoZVRyYW5zUm9vdCk7XHJcbiAgICAgICAgaW5zdC5TZXRBY3RpdmUoZmFsc2UpO1xyXG5cclxuICAgICAgICBsZXQgY2FjaGVkSW5zdCA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpIHx8IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIGNhY2hlZEluc3QucHVzaChpbnN0KTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2luc3RDYWNoZS5zZXQocGF0aCwgY2FjaGVkSW5zdCk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOa4heeQhue8k+WtmFxyXG4gICAgcHVibGljIGNsZWFudXAoaW5jbHVkZVBvb2xlZEdvOmJvb2xlYW4gPSBmYWxzZSl7XHJcblxyXG4gICAgICAgIHRoaXMuX19pbnN0Q2FjaGUuZm9yRWFjaCgodmFsdWVzLCBrZXkpPT57XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGluc3Qgb2YgdmFsdWVzKXtcclxuICAgICAgICAgICAgICAgIGlmKGluc3QgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5EZXN0cm95KGluc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2luc3RDYWNoZS5jbGVhcigpOyBcclxuXHJcbiAgICAgICAgaWYoaW5jbHVkZVBvb2xlZEdvKXtcclxuICAgICAgICAgICAgdGhpcy5fX2dvUG9vbC5mb3JFYWNoKChnbywga2V5KT0+e1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGdvICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikucmVsZWFzZUFkZHJlc3NHTyhnbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fX2dvUG9vbC5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxufSIsIlxyXG5cclxuZXhwb3J0IGNsYXNzIE1lc09iantcclxuICAgIHB1YmxpYyBsaXN0ZW5lcnM6QXJyYXk8RnVuY3Rpb24+O1xyXG4gICAgcHVibGljIG9iajphbnk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTWVzc2VuZ2Vye1xyXG5cclxuICAgIHByaXZhdGUgbGlzdGVuZXJNYXAgPSBuZXcgTWFwPG51bWJlcixNZXNPYmo+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZExpc3RlbmVyKGVfdHlwZTpudW1iZXIsIGVfb2JqOmFueSwgZV9saXN0bmVyOkZ1bmN0aW9uKTp2b2lke1xyXG5cclxuICAgICAgICBsZXQgbXNnT2JqID0gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mKG1zZ09iaikgPT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIG1zZ09iaiA9IG5ldyBNZXNPYmooKTtcclxuICAgICAgICAgICAgbXNnT2JqLm9iaiA9IGVfb2JqO1xyXG4gICAgICAgICAgICBtc2dPYmoubGlzdGVuZXJzID0gbmV3IEFycmF5PEZ1bmN0aW9uPigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtc2dPYmoubGlzdGVuZXJzLnB1c2goZV9saXN0bmVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lck1hcC5zZXQoZV90eXBlLCBtc2dPYmopO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXRMaXN0ZW5lcihlX3R5cGU6bnVtYmVyKTpNZXNPYmp7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGJyb2FkY2FzdChlX3R5cGU6bnVtYmVyLCAuLi5wYXJhbXM6YW55W10pIDogdm9pZCB7XHJcblxyXG4gICAgICAgIGxldCBtc2dPYmogPSB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHR5cGVvZihtc2dPYmopICE9IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGwgb2YgbXNnT2JqLmxpc3RlbmVycyl7XHJcbiAgICAgICAgICAgICAgIGwuYXBwbHkobXNnT2JqLm9iaiwgcGFyYW1zKTtcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXJCeVR5cGUoZV90eXBlOm51bWJlcikgOnZvaWQge1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyTWFwLmRlbGV0ZShlX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXIoZV90eXBlOm51bWJlciwgZV9saXN0ZW5lcjpGdW5jdGlvbiApOnZvaWR7XHJcblxyXG4gICAgICAgIGxldCBtc2dPYmogPSB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YobXNnT2JqKSAhPSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcihsZXQgaTpudW1iZXIgPTA7IGk8IG1zZ09iai5saXN0ZW5lcnMubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICAgICAgaWYobXNnT2JqLmxpc3RlbmVyc1tpXSA9PSBlX2xpc3RlbmVyKXtcclxuICAgICAgICAgICAgICAgICAgICBtc2dPYmoubGlzdGVuZXJzLnNwbGljZShpLDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhcnVwKCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lck1hcC5jbGVhcigpO1xyXG4gICAgfVxyXG5cclxufSIsIlxyXG5cclxuXHJcbi8vIEZhaXJ5R1VJIOWFg+S7tiDnu5HlrprlmahcclxuZXhwb3J0IGZ1bmN0aW9uIGJpbmRlcihuYW1lOnN0cmluZyl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0OmFueSwga2V5OnN0cmluZyB8IHN5bWJvbCl7XHJcbiAgICAgICAgdGFyZ2V0W1wiYmluZGVyc1wiXSA9IHRhcmdldFtcImJpbmRlcnNcIl0gfHwge307XHJcbiAgICAgICAgdGFyZ2V0W1wiYmluZGVyc1wiXVtrZXldID0gbmFtZTtcclxuICAgIH1cclxufSIsIlxyXG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tICcuL1NpbmdsZXRvbic7XHJcbmltcG9ydCB7ICRwcm9taXNlIH0gZnJvbSAncHVlcnRzJztcclxuaW1wb3J0IHtOaWNlVFN9IGZyb20gJ2NzaGFycCc7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVzTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZXNNYW5hZ2VyPntcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFByZWZhYihhZGRyZXNzOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2s9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFByZWZhYihhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTG9hZCBwcmVmYWIgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRUZXh0QXNzZXQoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkVGV4dEFzc2V0KGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExvYWQgdGV4dGFzc2V0IDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBhc3luYyBsb2FkVGV4dEJ5dGVzKGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFRleHRCeXRlcyhhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGJ5dGVzID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBMb2FkVGV4dEJ5dGVzIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkU3ByaXRlKGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFNwcml0ZShhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTG9hZCBzcHJpdGUgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZEZhaXJ5R1VJUGFja2FnZShhZGRyZXNzOnN0cmluZywgcGFja2FnZU5hbWU6c3RyaW5nLCBjYWxsYmFjaz86RnVuY3Rpb24pe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkRmFpcnlHVUlQYWNrYWdlKGFkZHJlc3MscGFja2FnZU5hbWUpO1xyXG4gICAgICAgICAgICBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExvYWQgZmFpcnlHVUkgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWxlYXNlQWRkcmVzc0dPKGdvOmFueSl7XHJcblxyXG4gICAgICAgIE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuUmVsZWFzZUFkZHJlc3NHTyhnbyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbGVhc2VGYWlyeUdVSVBhY2thZ2UocGFja2FnZU5hbWUpe1xyXG4gICAgICAgIE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuUmVsZWFzZUZHVUlQYWNrYWdlKHBhY2thZ2VOYW1lKTtcclxuICAgIH1cclxufSIsIlxyXG5cclxuZXhwb3J0IGNsYXNzIFNpbmdsZXRvbjxUPntcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTphbnkgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSW5zdGFuY2U8VD4oIGM6IHsgbmV3KCk6IFQgfSApIDogVHtcclxuXHJcbiAgICAgICAgaWYodGhpcy5pbnN0YW5jZSA9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBjKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgeyBTdG9yeSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvU3RvcnlcIjtcblxuZXhwb3J0IGNsYXNzIElua1N0YXRlSW5zcGVjdG9ye1xuXG4gICAgcHVibGljIEJpbmRJbmtNZXRob2RzKGlua1N0b3J5OlN0b3J5KTp2b2lke1xuICAgICAgICBcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiL6YeH55So5q2k5pa55byPXG4gICAgICAgIHRoaXMuYmluZElua01ldGhvZE9uY2UoaW5rU3RvcnksXCJHZXRDaGFyYWN0ZXJOYW1lXCIsdGhpcy5nZXRDaGFyYWN0ZXJOYW1lKTtcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiK6YeH55So5q2k5pa55byPIFxuICAgICAgICB0aGlzLmJpbmRJbmtNZXRob2RPbmNlR2VuZXJhbChpbmtTdG9yeSxcIkdldENoYXJhY3Rlck5hbWVCeU11dGlQYXJhbXNcIix0aGlzLmdldENoYXJhY3Rlck5hbWVNdXRpUGFyYW1zKTtcbiAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENoYXJhY3Rlck5hbWUoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIkp1c3RpbiBUZXN0IFB1ZXJ0c1wiO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2hhcmFjdGVyTmFtZU11dGlQYXJhbXMocDE6bnVtYmVyLHAyOm51bWJlcixwMzpudW1iZXIpOnN0cmluZ3tcbiAgICAgICAgcmV0dXJuIFwiSnVzdGluIE11dGkgUGFyYW1zXCI7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGJpbmRJbmtNZXRob2RPbmNlKGlua1N0b3J5OlN0b3J5LGZ1bmNOYW1lOnN0cmluZyxmdW5jOlN0b3J5LkV4dGVybmFsRnVuY3Rpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgZnVuYyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBiaW5kSW5rTWV0aG9kT25jZUdlbmVyYWwoaW5rU3Rvcnk6U3RvcnksIGZ1bmNOYW1lOnN0cmluZyxmdW5jOlN0b3J5LkV4dGVybmFsRnVuY3Rpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIGZ1bmMpO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9ICAgICBcbiAgICB9XG5cbiAgICBwdWJsaWMgdW5iaW5kSW5rTWV0aG9kKGlua1N0b3J5OlN0b3J5LGZ1bmNOYW1lOnN0cmluZyl7XG4gICAgICAgIFxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5VbmJpbmRFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lKTtcbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxufSIsImltcG9ydCB7IFN0b3J5IH0gZnJvbSBcImlua2pzL2VuZ2luZS9TdG9yeVwiO1xuaW1wb3J0IHsgSW5rU3RhdGVJbnNwZWN0b3IgfSBmcm9tIFwiLi9JbmtTdGF0ZUluc3BlY3RvclwiO1xuaW1wb3J0IHsgU3RvcnlNZXNzYWdlTWFuYWdlciB9IGZyb20gXCIuL1N0b3J5TWVzc2FnZU1hbmFnZXJcIjtcblxuZXhwb3J0IGNsYXNzIElua1dyaXRlcntcblxuICAgIHB1YmxpYyBzdGF0aWMgREVCVUdfU1RPUllfSUQ6c3RyaW5nID0gXCJERUJVR19TVE9SWVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgQ09NTUFORF9QUkVGSVg6c3RyaW5nID0gXCI+Pj5cIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfREVMSU1JVEVSOnN0cmluZyA9IFwiOlwiO1xuICAgIHB1YmxpYyBzdGF0aWMgQ09NTUFORF9BUkdfREVMSU1JVEVSOnN0cmluZyA9ICcsJztcblxuICAgIHByaXZhdGUgX2N1cnJlbnRTdG9yeTpTdG9yeTtcbiAgICBwcml2YXRlIF9hbGxJbmtDb21tYW5kczpNYXA8c3RyaW5nLEZ1bmN0aW9uPiA9IG5ldyBNYXA8c3RyaW5nLEZ1bmN0aW9uPigpO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihzdG9yeUpzb246c3RyaW5nKXtcbiAgICAgICAgdGhpcy5zZXR1cElua0NvbW1hbmRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlU3Ryb3koc3RvcnlKc29uKTtcbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGxvYWQoKTp2b2lke1xuICAgICAgICBsZXQgc3RvcnlTdGF0ZTpzdHJpbmcgPSBcIlwiO1xuICAgICAgICBpZihzdG9yeVN0YXRlIT1udWxsICYmIHN0b3J5U3RhdGUhPVwiXCIpe1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LnN0YXRlLkxvYWRKc29uKHN0b3J5U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVTdHJveShqc29uOnN0cmluZyl7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeSA9IG5ldyBTdG9yeShqc29uKTtcblxuICAgICAgIFxuICAgIH1cblxuICAgIHB1YmxpYyBiZWdpblN0b3J5KGtub3ROYW1lOnN0cmluZyl7XG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRTdG9yeSA9PSBudWxsKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlRyeWluZyB0byBBZHZhbmNlU3RvcnkgaW4gSW5rV3JpdGVyIHdoZW4gbm8gc3RvcnkgaGFzIGJlZW4gY3JlYXRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5DaG9vc2VQYXRoU3RyaW5nKGtub3ROYW1lLCB0cnVlKTtcblxuICAgICAgICAgbGV0IGlua1N0YXRlOklua1N0YXRlSW5zcGVjdG9yID0gbmV3IElua1N0YXRlSW5zcGVjdG9yKCk7XG4gICAgICAgICBpbmtTdGF0ZS5CaW5kSW5rTWV0aG9kcyh0aGlzLl9jdXJyZW50U3RvcnkpO1xuXG4gICAgICAgIHRoaXMuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdpdmVSZXdhcmQoKTpib29sZWFue1xuICAgICAgICBjb25zb2xlLmxvZyhcImdpdmUgcmV3YXJkLi4uXCIpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0dXBJbmtDb21tYW5kcygpOnZvaWR7XG4gICAgICAgIHRoaXMuX2FsbElua0NvbW1hbmRzLnNldChcIkdJVkVfUkVXQVJEXCIsdGhpcy5naXZlUmV3YXJkKVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ29tbWFuZChjb21tYW5kOnN0cmluZywgYXJnczpzdHJpbmdbXSk6Ym9vbGVhbntcbiAgICAgICAgaWYodGhpcy5fYWxsSW5rQ29tbWFuZHMuaGFzKGNvbW1hbmQpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxJbmtDb21tYW5kcy5nZXQoY29tbWFuZCkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBmaW5kIElua0NvbW1hbmQgd2l0aCBuYW1lOlwiK2NvbW1hbmQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBhcnNlQ29tbWFuZE5hbWUodGV4dDpzdHJpbmcpOnN0cmluZ3tcbiAgICAgICAgbGV0IG51bTpudW1iZXIgPSB0ZXh0LmluZGV4T2YoSW5rV3JpdGVyLkNPTU1BTkRfUFJFRklYKTtcbiAgICAgICAgbGV0IG51bTI6bnVtYmVyID0gdGV4dC5pbmRleE9mKElua1dyaXRlci5DT01NQU5EX0RFTElNSVRFUik7XG4gICAgICAgIGlmKG51bTIgPT0gLTEpe1xuICAgICAgICAgICAgbnVtMiA9IHRleHQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlbmd0aDpudW1iZXIgPSBudW0yIC0gKG51bSArIElua1dyaXRlci5DT01NQU5EX1BSRUZJWC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHIobnVtICsgSW5rV3JpdGVyLkNPTU1BTkRfUFJFRklYLmxlbmd0aCwgbGVuZ3RoKS50cmltKCk7XG4gICAgfVxuXG4gICAgcHVibGljIHBhcnNlQ29tbWFuZEFyZ3ModGV4dDpzdHJpbmcpOnN0cmluZ1tde1xuICAgICAgICBsZXQgbnVtOm51bWJlciA9IHRleHQuaW5kZXhPZihJbmtXcml0ZXIuQ09NTUFORF9ERUxJTUlURVIpO1xuICAgICAgICBpZihudW0gPT0gLTEpe1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5ndGg6bnVtYmVyID0gdGV4dC5sZW5ndGggLSAobnVtICsgMSk7XG4gICAgICAgIGxldCBsaXN0OnN0cmluZ1tdID0gdGV4dC5zdWJzdHIobnVtKzEsIGxlbmd0aCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpbSgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0KElua1dyaXRlci5DT01NQU5EX0FSR19ERUxJTUlURVIpO1xuICAgICAgICBmb3IgKGxldCBpOm51bWJlcj0wOyBpPGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RbaV0gPSBsaXN0W2ldLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZXh0cmFjdFNwZWFrZXIobGluZTpzdHJpbmcpOltzdHJpbmcsc3RyaW5nXXtcbiAgICAgICAgaWYobGluZS5zdGFydHNXaXRoKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCkpe1xuICAgICAgICAgICAgcmV0dXJuIFtcIjBcIixsaW5lLnRyaW0oKV07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgYXJyYXk6c3RyaW5nW10gPSBsaW5lLnNwbGl0KCc6JywyKTtcbiAgICAgICAgaWYoYXJyYXkubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICBsZXQgc3BlYWtJRDpzdHJpbmcgPSBhcnJheVswXS50cmltKCk7XG4gICAgICAgICAgICBsZXQgc3BlYWtDb250ZW50OnN0cmluZyA9IGFycmF5WzFdLnRyaW0oKTtcblxuICAgICAgICAgICAgcmV0dXJuIFtzcGVha0lELCBzcGVha0NvbnRlbnRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcIjBcIixsaW5lLnRyaW0oKV07XG4gICAgfVxuXG4gICAgcHVibGljIHNhdmVDdXJyZW50U3RvcnkoKTp2b2lke1xuICAgICAgICBsZXQgY3VyclN0YXRlID0gdGhpcy5fY3VycmVudFN0b3J5LnN0YXRlLnRvSnNvbigpO1xuICAgICAgICAvL1RPRE/vvZPvvYHvvZbvvYVcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FuQ29udGludWUoKTpib29sZWFue1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0b3J5LmNhbkNvbnRpbnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZHZhbmNlU3RvcnkoKTp2b2lke1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gQWR2YW5jZVN0b3J5IGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWVuIGNyZWF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9jdXJyZW50U3RvcnkuY2FuQ29udGludWUpe1xuICAgICAgICAgICAgbGV0IHRleHQ6c3RyaW5nID0gdGhpcy5fY3VycmVudFN0b3J5LkNvbnRpbnVlKCkudHJpbSgpO1xuICAgICAgICAgICAgaWYodGV4dCA9PSBcIlwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3BlYWtJRDpzdHJpbmc7XG4gICAgICAgICAgICBsZXQgc3BlYWtDb250ZW50OnN0cmluZztcblxuICAgICAgICAgICAgW3NwZWFrSUQsIHNwZWFrQ29udGVudF0gPSB0aGlzLmV4dHJhY3RTcGVha2VyKHRleHQpO1xuXG4gICAgICAgICAgICBsZXQgY29tbWFuZE5hbWU6c3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzOnN0cmluZ1tdID0gbnVsbDtcbiAgICAgICAgICAgIGlmKHNwZWFrQ29udGVudC5zdGFydHNXaXRoKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCkpe1xuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lID0gdGhpcy5wYXJzZUNvbW1hbmROYW1lKHNwZWFrQ29udGVudCk7XG4gICAgICAgICAgICAgICAgYXJncyA9IHRoaXMucGFyc2VDb21tYW5kQXJncyhzcGVha0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmKGNvbW1hbmROYW1lICE9IG51bGwgJiYgY29tbWFuZE5hbWUgIT1cIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5oYW5kbGVDb21tYW5kKGNvbW1hbmROYW1lLCBhcmdzKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy9PbkNvbnRlbnRSZWFkeVxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikuYnJvYWRjYXN0Q29udGVudFJlYWR5KFxuICAgICAgICAgICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgICAgICAgICBzcGVha0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWFrSUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50VGFncyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIC8vT25DaG9pY2VzUHJlc2VudGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdENob2ljZXNQcmVzZW50ZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdFN0b3J5RmluaXNoZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRURcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3RDaG9pY2UoY2hvaWNlSW5kZXg6bnVtYmVyKTp2b2lke1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gQ2hvb3NlQ2hvaWNlIGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWd1blwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuQ2hvb3NlQ2hvaWNlSW5kZXgoY2hvaWNlSW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nKTphbnl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RvcnkudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJpYWJsZU5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nLCB2YWx1ZTphbnkpe1xuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkudmFyaWFibGVzU3RhdGUuJCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tIFwiLi4vY29tbW9uL1Jlc01hbmFnZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBJbmtXcml0ZXIgfSBmcm9tIFwiLi9JbmtXcml0ZXJcIjtcblxuZXhwb3J0IGNsYXNzIFN0b3J5TWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxTdG9yeU1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBfaW5rV3JpdGVyOklua1dyaXRlcjtcbiAgICBwcml2YXRlIHN0b3J5QWRkcmVzczpzdHJpbmcgPSBcIlN0b3J5L1Rlc3RTdG9yeS5qc29uXCI7XG5cbiAgICBwdWJsaWMgZ2V0IGlua1dyaXRlcigpOklua1dyaXRlcntcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lua1dyaXRlcjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKCl7XG5cbiAgICAgICAgaWYodGhpcy5faW5rV3JpdGVyID09IG51bGwpe1xuXG4gICAgICAgICAgICB2YXIganNvbiA9ICAoYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkVGV4dEFzc2V0KHRoaXMuc3RvcnlBZGRyZXNzKSkudGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2lua1dyaXRlciA9IG5ldyBJbmtXcml0ZXIoanNvbik7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBiZWdpblN0b3J5KGtub3ROYW1lOnN0cmluZyk6dm9pZHtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLmJlZ2luU3Rvcnkoa25vdE5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5Db250aW51ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyLmNhbkNvbnRpbnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZHZhbmNlU3RvcnkoKXtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3RDaG9pY2UoY2hvaWNlOkNob2ljZSk6dm9pZHtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLnNlbGVjdENob2ljZShjaG9pY2UuaW5kZXgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkQ3VycmVudCgpOnZvaWR7XG4gICAgICAgIGlmKHRoaXMuX2lua1dyaXRlciE9bnVsbCkgdGhpcy5faW5rV3JpdGVyLmxvYWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZyk6YW55e1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyLmdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcsIHZhbHVlOmFueSl7XG4gICAgICAgIHRoaXMuaW5rV3JpdGVyLnNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH1cblxufSIsImltcG9ydCB7IENob2ljZSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvQ2hvaWNlXCI7XG5pbXBvcnQgeyBNZXNzZW5nZXIgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NlbmdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcblxuZXhwb3J0IGNsYXNzIFN0b3J5TWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U3RvcnlNZXNzYWdlTWFuYWdlcj57XG5cbiAgICBwdWJsaWMgc3RhdGljIE9OQ09OVEVOVFJFQURZOm51bWJlciA9IDEwMDE7XG4gICAgcHVibGljIHN0YXRpYyBPTkNIT0lDRVNQUkVTRU5URUQ6bnVtYmVyID0gMTAwMjtcbiAgICBwdWJsaWMgc3RhdGljIE9OU1RPUllGSU5JU0hFRDpudW1iZXIgPSAxMDAzO1xuXG4gICAgcHJpdmF0ZSBzdG9yeU1lc3NhZ2U6TWVzc2VuZ2VyID0gbmV3IE1lc3NlbmdlcigpO1xuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsb2JqOmFueSwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmFkZExpc3RlbmVyKG1zZ0NvZGUsIG9iaiwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihtc2dDb2RlOm51bWJlciwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihtc2dDb2RlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlDb2RlKG1zZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXJCeVR5cGUobXNnQ29kZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFydXAoKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuY2xlYXJ1cCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RDb250ZW50UmVhZHkoXG4gICAgICAgIG1zZ0NvZGU6bnVtYmVyLFxuICAgICAgICBzcGVha2VyQ29udGVudDpzdHJpbmcsXG4gICAgICAgIHNwZWFrZXJJZDpzdHJpbmcsXG4gICAgICAgIGN1cnJlbnRUYWdzOnN0cmluZ1tdLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXVxuICAgICAgICApXG4gICAge1xuXG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmJyb2FkY2FzdChtc2dDb2RlLCBzcGVha2VyQ29udGVudCxzcGVha2VySWQsY3VycmVudFRhZ3MsY3VycmVudENob2ljZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RDaG9pY2VzUHJlc2VudGVkKFxuICAgICAgICBtZXNnQ29kZTpudW1iZXIsXG4gICAgICAgIGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdXG4gICAgKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYnJvYWRjYXN0KG1lc2dDb2RlLGN1cnJlbnRDaG9pY2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0U3RvcnlGaW5pc2hlZChtZXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5icm9hZGNhc3QobWVzZ0NvZGUpOyAgIFxuICAgIH1cbn0iLCJpbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgTmV0RXJyb3JDb2RlIH0gZnJvbSBcIi4vTmV0RXJyb3JDb2RlXCI7XHJcbmltcG9ydCB7IE5pY2VUUyB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgTWVzc2FnZVBhcnNlciB9IGZyb20gXCIuL01lc3NhZ2VQYXJzZXJcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTXNnUGFja3tcclxuICAgIHB1YmxpYyBzZW5kVGltZTpudW1iZXI7XHJcbiAgICBwdWJsaWMgY2FsbGJhY2s6RnVuY3Rpb247XHJcbiAgICBwdWJsaWMgcmV0cnlUaW1lczpudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIGJ5dGVzOlVpbnQ4QXJyYXk7XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHYW1lU2Vzc2lvbiBleHRlbmRzIFNpbmdsZXRvbjxHYW1lU2Vzc2lvbj57XHJcblxyXG4gICAgcHVibGljIGlkOm51bWJlciA9IDA7ICAvL3Nlc3Npb24gSURcclxuICAgIHByaXZhdGUgcmVTZW5kSW50ZXJ2YWw6bnVtYmVyID0gMTAwMDA7IC8vMTDnp5Lph43lj5HkuIDmrKFcclxuICAgIHByaXZhdGUgdGltZW91dEludGVydmFsOm51bWJlciA9IDUwMDA7IC8vNeenkuajgOafpeS4gOasoeaYr+WQpui2heaXtlxyXG4gICAgcHJpdmF0ZSBtYXhSZVNlbmRUaW1lczpudW1iZXIgPSA1OyAvL+acgOWkp+mHjeWPkeasoeaVsFxyXG4gICAgcHJpdmF0ZSB0aW1lb3V0SWltZXI6YW55O1xyXG5cclxuICAgIHByaXZhdGUgX3JwY0lkOm51bWJlciA9IDE7XHJcbiAgICBwcml2YXRlIGNoYW5uZWw6YW55O1xyXG4gICAgcHJpdmF0ZSByZXF1ZXN0Q2FsbGJhY2s6TWFwPG51bWJlcixNc2dQYWNrPiA9IG5ldyBNYXA8bnVtYmVyLE1zZ1BhY2s+KCk7XHJcbiAgICBwcml2YXRlIGxpc3RlbmVyczpNYXA8bnVtYmVyLEZ1bmN0aW9uPiA9IG5ldyBNYXA8bnVtYmVyLEZ1bmN0aW9uPigpO1xyXG5cclxuICAgIC8v6L+U5Zue55qE5pyN5Yqh5ZmoSUQsIOexu+Wei1xyXG4gICAgcHJpdmF0ZSBfc2VydmVySWQ6bnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9zZXJ2ZXJUeXBlOm51bWJlciA9IDE7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgcnBjSWQoKTpudW1iZXJ7XHJcbiAgICAgICAgcmV0dXJuICsrdGhpcy5fcnBjSWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy9hZGRyZXNzLT4gaXA6cG9ydFxyXG4gICAgcHVibGljIGNvbm5lY3RDaGFubmVsKGFkZHJlc3M6c3RyaW5nLCBjb25uQ2FiYWNrOmFueSl7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IE5pY2VUUy5UU2VydmljZS5JbnN0YW5jZS5HZXRDaGFubmVsKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLmVycm9yQ2FsbGJhY2sgPSAoY2hhbm5lbDphbnksIGNvZGU6bnVtYmVyKT0+e1xyXG4gICAgICAgICAgICBpZihjb2RlID09IE5ldEVycm9yQ29kZS5FUlJfU29ja2V0Q29ublN1Y2Mpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lb3V0SWltZXIgPSBzZXRJbnRlcnZhbCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tUaW1lb3V0TXNnKCk7XHJcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnRpbWVvdXRJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbm5DYWJhY2soY2hhbm5lbCwgY29kZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNoYW5uZWwucmVhZENhbGxiYWNrID0gKGJ1ZmZlcjpVaW50OEFycmF5KT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVjZWl2ZShidWZmZXIpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5Db25uZWN0KGFkZHJlc3MpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvL+aOpeaUtuacjeWKoeWZqOmAmuefpVxyXG4gICAgcHVibGljIGxpc3RlbihvcGNvZGU6bnVtYmVyLGNhbGxiYWNrOkZ1bmN0aW9uKXtcclxuICAgICAgICB0aGlzLmxpc3RlbmVycy5zZXQob3Bjb2RlLCBjYWxsYmFjayk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/lj5HpgIFwcm90b3ViZua2iOaBr1xyXG4gICAgLy/mtojmga/vvJogcnBjX2lkWzRdIC0gb3Bjb2RlWzJdIC0gc2VydmVyX2lkWzJdIC0gc2VydmVyX3R5cGVbMV0gLSBcclxuICAgIHB1YmxpYyBzZW5kKG9wY29kZTpudW1iZXIscnBjaWQ6bnVtYmVyLCBtZXNzYWdlOlVpbnQ4QXJyYXksIGNhbGxCYWNrOkZ1bmN0aW9uKXtcclxuICAgICAgICBcclxuICAgICAgICAvL+Wwgeijhea2iOaBr++8mlxyXG4gICAgICAgIGxldCBycGNCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlSW50KHJwY2lkKTsgLy80XHJcbiAgICAgICAgbGV0IG9wY29kZUJ1ZjpVaW50OEFycmF5ID0gTWVzc2FnZVBhcnNlci5lbmNvZGVTaG9ydChvcGNvZGUpOyAvLzJcclxuICAgICAgICBsZXQgc2VydmVyaWRCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlU2hvcnQodGhpcy5fc2VydmVySWQpOyAvLzJcclxuICAgICAgICBsZXQgc2VydmVydHlwZUJ1ZjpVaW50OEFycmF5ID0gTWVzc2FnZVBhcnNlci5lbmNvZGVCeXRlKHRoaXMuX3NlcnZlclR5cGUpOyAvLzFcclxuXHJcblxyXG4gICAgICAgIGxldCBzZW5kQXJyYXk6VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQgKyAyICsgMiArIDEgK21lc3NhZ2UubGVuZ3RoKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KHJwY0J1Zik7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChvcGNvZGVCdWYsICAgIDQpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQoc2VydmVyaWRCdWYsICA0ICsgMik7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChzZXJ2ZXJ0eXBlQnVmLCA0ICsgMiArIDIpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQobWVzc2FnZSwgICAgICAgNCArIDIgKyAyICsgMSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYoY2FsbEJhY2sgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIGxldCBtc2dQYWNrOk1zZ1BhY2sgPSBuZXcgTXNnUGFjaygpO1xyXG4gICAgICAgICAgICBtc2dQYWNrLnNlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIG1zZ1BhY2suY2FsbGJhY2sgPSBjYWxsQmFjaztcclxuICAgICAgICAgICAgbXNnUGFjay5ieXRlcyA9IHNlbmRBcnJheTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLnNldChycGNpZCwgbXNnUGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZvcihsZXQgaSBpbiBzZW5kQXJyYXkpe1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyhcIlRTIC0tIHNlbmQgYXJyYXk6IFwiK2kpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvL0NvbnNvbGUubG9nKFwic2VuZCBhcnJheTogXCIrc2VuZEFycmF5KTtcclxuICAgICAgICB0aGlzLmNoYW5uZWwuU2VuZChzZW5kQXJyYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVTZW5kKGJ5dGVzOlVpbnQ4QXJyYXkpe1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5TZW5kKGJ5dGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25SZWNlaXZlKGJ1ZmZlcjpVaW50OEFycmF5KXtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbXNnQnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuXHJcbiAgICAgICAgbGV0IHJwY2lkID0gTWVzc2FnZVBhcnNlci5kZWNvZGVJbnQobXNnQnVmLnN1YmFycmF5KDAsNCkpO1xyXG4gICAgICAgIGxldCBvcGNvZGUgPSBNZXNzYWdlUGFyc2VyLmRlY29kZVNob3J0KG1zZ0J1Zi5zdWJhcnJheSg0LDYpKTtcclxuICAgICAgICBsZXQgc2VydmVyaWQgPSBNZXNzYWdlUGFyc2VyLmRlY29kZVNob3J0KG1zZ0J1Zi5zdWJhcnJheSg2LDgpKTtcclxuICAgICAgICBsZXQgc2VydmVydHlwZSA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlQnl0ZShtc2dCdWYuc3ViYXJyYXkoOCw5KSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NlcnZlcklkID0gc2VydmVyaWQ7XHJcbiAgICAgICAgdGhpcy5fc2VydmVyVHlwZSA9IHNlcnZlcnR5cGU7XHJcblxyXG4gICAgICAgIGxldCBtc2dCeXRlczpVaW50OEFycmF5ID0gbXNnQnVmLnN1YmFycmF5KDkpO1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBkZWNvZGVNc2cgPSAgT3Bjb2RlLmRlY29kZShvcGNvZGUsIG1zZ0J5dGVzKTtcclxuXHJcblxyXG4gICAgICAgICAgICBpZihycGNpZD09dW5kZWZpbmVkIHx8ICF0aGlzLnJlcXVlc3RDYWxsYmFjay5oYXMocnBjaWQpKXtcclxuICAgICAgICAgICAgICAgIC8v5qOA5p+l5piv5ZCm5piv5pyN5Yqh5Zmo5LiL5Y+R55qE5raI5oGvXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpc3RlbmVycy5oYXMob3Bjb2RlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RlbiA9IHRoaXMubGlzdGVuZXJzLmdldChvcGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbihkZWNvZGVNc2cubXNnT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGxldCBtc2dQYWNrOk1zZ1BhY2sgPSB0aGlzLnJlcXVlc3RDYWxsYmFjay5nZXQocnBjaWQpO1xyXG4gICAgICAgICAgICAgICAgbXNnUGFjay5jYWxsYmFjayhkZWNvZGVNc2cubXNnT2JqKTsgIFxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5kZWxldGUocnBjaWQpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJwYXJzZSBtc2cgZXJyb3IsIG9wY29kZTpcIitvcGNvZGUpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNoZWNrVGltZW91dE1zZygpe1xyXG5cclxuICAgICAgICBsZXQgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q2FsbGJhY2suZm9yRWFjaCgodmFsdWUsIGtleSkgPT57XHJcblxyXG4gICAgICAgICAgICBpZih2YWx1ZS5yZXRyeVRpbWVzID49IHRoaXMubWF4UmVTZW5kVGltZXMpIHtcclxuICAgICAgICAgICAgICAgIC8v6LaF6L+H5pyA5aSn6YeN5Y+R5qyh5pWw77yM5Lii5byDXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWVzc2FnZSByZXNlbmQgdG9vIG1vcmUsIG9wY29kZToke2tleX0sIGxhc3RzZW5kOiR7dmFsdWUuc2VuZFRpbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5kZWxldGUoa2V5KTsgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKChjdXJyVGltZSAtIHZhbHVlLnNlbmRUaW1lKSA+PSB0aGlzLnJlU2VuZEludGVydmFsKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXRyeVRpbWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2VuZFRpbWUgPSBjdXJyVGltZTtcclxuICAgICAgICAgICAgICAgICAgICAvL+mHjeWPkea2iOaBr1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVTZW5kKHZhbHVlLmJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgcmVzZW5kIG1lc3NhZ2U6LCBvcGNvZGU6JHtrZXl9LCByZXRyeSB0aW1lczoke3ZhbHVlLnJldHJ5VGltZXN9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoKTp2b2lke1xyXG5cclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZW91dElpbWVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLkRpc3Bvc2UoKTtcclxuICAgIH1cclxufSIsIlxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VQYXJzZXJ7XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlSW50KG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXI6VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBidWZmZXJbMF0gPSBuID4+PiAyNDtcbiAgICAgICAgYnVmZmVyWzFdID0gbiA+Pj4gMTY7XG4gICAgICAgIGJ1ZmZlclsyXSA9IG4gPj4+IDg7XG4gICAgICAgIGJ1ZmZlclszXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUludChidWZmZXI6VWludDhBcnJheSk6bnVtYmVye1xuICAgICAgICBcbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF0gPDwgMjQgfCBidWZmZXJbMV0gPDwgMTYgfCBidWZmZXJbMl0gPDwgOCB8IGJ1ZmZlclszXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlU2hvcnQobjpudW1iZXIpOlVpbnQ4QXJyYXl7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gODtcbiAgICAgICAgYnVmZmVyWzFdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb2RlU2hvcnQoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXSA8PCA4IHwgYnVmZmVyWzFdO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuXG4gICAgcHVibGljIHN0YXRpYyBlbmNvZGVCeXRlKG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXIgOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICAgICAgYnVmZmVyWzBdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUJ5dGUoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuXG59IiwiXG5cbiBleHBvcnQgY2xhc3MgTmV0RXJyb3JDb2RlXG4ge1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ublN1Y2M6bnVtYmVyID0gMTAwMDAwO1xuXG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Db25uZWN0R2F0ZUtleUVycm9yOm51bWJlciA9IDEwMDAwNjtcblxuICAgICBwdWJsaWMgc3RhdGljICBFUlJfUGVlckRpc2Nvbm5lY3Q6bnVtYmVyICAgPSAxMDIwMDg7XG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Tb2NrZXRDYW50U2VuZDpudW1iZXIgICA9IDEwMjAwOTtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldEVycm9yOm51bWJlciAgICAgID0gMTAyMDEwO1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ubkVycm9yOm51bWJlciAgPSAxMDIwMTE7XG5cblxuICAgICBcblxuIH0iLCJcbmltcG9ydCB7IEdhbWVDb25maWcgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuL0dhbWVTZXNzaW9uXCI7XG5pbXBvcnQgeyBOZXRFcnJvckNvZGUgfSBmcm9tIFwiLi9OZXRFcnJvckNvZGVcIjtcblxuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbk1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2Vzc2lvbk1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBzZXNzaW9uUmVhbTpHYW1lU2Vzc2lvbjtcbiAgICBwcml2YXRlIHNlc3Npb25HYXRlOkdhbWVTZXNzaW9uO1xuXG5cbiAgICBwdWJsaWMgZ2V0IHJlYWxtUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblJlYW0ucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnYXRlUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkdhdGUucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbm5lY3RSZWFsbVNlcnZlcihvblN1Y2M6RnVuY3Rpb24sIG9uRXJyb3I6RnVuY3Rpb24pe1xuXG4gICAgICAgIC8v55m75b2V6aqM6K+B5pyNXG4gICAgICAgIHRoaXMuc2Vzc2lvblJlYW0gPSBHYW1lU2Vzc2lvbi5JbnN0YW5jZShHYW1lU2Vzc2lvbikuY29ubmVjdENoYW5uZWwoXG4gICAgICAgICAgICBHYW1lQ29uZmlnLnJlYWxtU2VydmVySVArXCI6XCIrR2FtZUNvbmZpZy5yZWFsbVNlcnZlclBvcnQsXG4gICAgICAgICAgICAoY2hhbm5lbDphbnksY29kZTpudW1iZXIpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5vblJlYW1Tb2NrZXRFcnIoY2hhbm5lbCwgY29kZSwgb25TdWNjLCBvbkVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25SZWFtU29ja2V0RXJyKGNoYW5uZWw6YW55LCBjb2RlOm51bWJlciwgb25TdWNjOkZ1bmN0aW9uLCBvbkVycm9yOkZ1bmN0aW9uKXtcbiAgICAgICBcbiAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYW0uaWQgPSBjaGFubmVsLklkO1xuICAgICAgXG4gICAgICAgICAgICBvblN1Y2MoY29kZSk7XG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICBvbkVycm9yKGNvZGUpO1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwibG9naW4gcmVhbXNlcnZlciBlcnIsIGNvZGU6IFwiK2NvZGUgKyBcIixpZDpcIitjaGFubmVsLklkKTtcblxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHB1YmxpYyBkaXNjb25uZWN0UmVhbG1TZXJ2ZXIoKXtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblJlYW0gPSBudWxsO1xuICAgIH1cblxuXG4gICAgcHVibGljIHNlbmRSZWFsbU1zZyhvcGNvZGU6bnVtYmVyLHJwY0lEOm51bWJlciwgYnVmOlVpbnQ4QXJyYXksY2FsbGJhY2s6RnVuY3Rpb24pe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5zZW5kKG9wY29kZSwgcnBjSUQsIGJ1ZiwgKHJlc3BvbnNlOmFueSk9PntcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgY29ubmVjdEdhdGVTZXJ2ZXIoYWRkcmVzczpzdHJpbmcsb25TdWNjOkZ1bmN0aW9uLCBvbkVycm9yOkZ1bmN0aW9uKXtcblxuICAgICAgICB0aGlzLnNlc3Npb25HYXRlID0gR2FtZVNlc3Npb24uSW5zdGFuY2UoR2FtZVNlc3Npb24pLmNvbm5lY3RDaGFubmVsKFxuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIChjaGFubmVsOmFueSxjb2RlOm51bWJlcik9PntcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luIEdhdGUgU2VydmVyOiBcIitjb2RlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub25HYXRlU29ja2V0RXJyKGNoYW5uZWwsIGNvZGUsIG9uU3VjYywgb25FcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHVibGljIG9uR2F0ZVNvY2tldEVycihjaGFubmVsOmFueSwgY29kZTpudW1iZXIsb25TdWNjOkZ1bmN0aW9uLCBvbkVycm9yOkZ1bmN0aW9uKXtcbiAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUuaWQgPSBjaGFubmVsLklkO1xuICAgICAgICBcbiAgICAgICAgICAgIG9uU3VjYyhjb2RlKTtcblxuICAgICAgICB9ZWxzZXtcblxuICAgICAgICAgICAgb25FcnJvcihjb2RlKTtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdhdGUgc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgZGlzY29ubmVjdEdhdGVTZXJ2ZXIoKXtcbiAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZW5kR2F0ZU1zZyhvcGNvZGU6bnVtYmVyLHJwY0lEOm51bWJlciwgYnVmOlVpbnQ4QXJyYXksY2FsbGJhY2s6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUuc2VuZChvcGNvZGUsIHJwY0lELCBidWYsIChyZXNwb25zZTphbnkpPT57XG5cbiAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59ICAgXG4iLCJpbXBvcnQgeyBlbWl0IH0gZnJvbSBcInB1ZXJ0c1wiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi9SZWRIaW50c01lc3NhZ2VNYW5hZ2VyXCI7XG5cbmV4cG9ydCBlbnVtIGVudW1SZWRIaW50cyB7XG4gICAgLyoqIOagh+iusOS9jSAqL1xuICAgIG5vbmUgPSAwLFxuICAgIC8qKiDogYrlpKkgKi9cbiAgICBjaGF0ID0gMSxcbiAgICAvKiog6IGK5aSp5LiW55WM6aKR6YGTICovXG4gICAgY2hhdF93b3JsZCA9IDIsXG4gICAgLyoqIOiBiuWkqeWFrOS8mumikemBkyAqL1xuICAgIGNoYXRfZmFtaWx5ID0gMyxcbiAgICAvKiog6IGK5aSp57O757uf6aKR6YGTICovXG4gICAgY2hhdF9zeXN0ZW0gPSA0LFxufVxuXG5cbmV4cG9ydCBjbGFzcyBSZWRIaW50c01hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248UmVkSGludHNNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgX2RhdGE6IEFycmF5PG51bWJlcj47Ly/orrDlvZXmr4/kuKrnuqLngrnnmoTmlbDlgLxcbiAgICBwcml2YXRlIF9wYXJlbnRJbmRleDogQXJyYXk8bnVtYmVyPjsvL+iusOW9leeItue6p+e0ouW8lVxuICAgIHByaXZhdGUgX2NoaWxkTnVtOiBBcnJheTxudW1iZXI+Oy8v6K6w5b2V5a2Q6aG55pWw6YePXG4gICAgcHJpdmF0ZSBfY2hpbGRJbmRleDogQXJyYXk8bnVtYmVyPjsvL+iusOW9leWtkOmhueWcqOeItue6p+S4reeahOaOkuW6j+e0ouW8lVxuXG4gICAgLyoqXG4gICAgICog57qi54K55YC85pS55Y+YXG4gICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIFJFRF9ISU5UX1ZBTFVFX0NIQU5HRUQ6IHN0cmluZyA9IFwiUkVEX0hJTlRfVkFMVUVfQ0hBTkdFRFwiO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0KCkge1xuICAgICAgICB0aGlzLl9kYXRhID0gWzBdOy8v56ys5LiA5L2N5peg5oSP5LmJXG4gICAgICAgIHRoaXMuX3BhcmVudEluZGV4ID0gWzBdO1xuICAgICAgICB0aGlzLl9jaGlsZE51bSA9IFswXTtcbiAgICAgICAgdGhpcy5fY2hpbGRJbmRleCA9IFswXTtcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS3orrDlvZXniLblrZDlhbPns7stLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvL+iBiuWkqVxuICAgICAgICB0aGlzLnNldFBhcmVudChlbnVtUmVkSGludHMuY2hhdF93b3JsZCwgZW51bVJlZEhpbnRzLmNoYXQpO1xuICAgICAgICB0aGlzLnNldFBhcmVudChlbnVtUmVkSGludHMuY2hhdF9mYW1pbHksIGVudW1SZWRIaW50cy5jaGF0KTtcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQoZW51bVJlZEhpbnRzLmNoYXRfc3lzdGVtLCBlbnVtUmVkSGludHMuY2hhdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog6K6+572u57qi54K555qE5byA5ZCv5ZKM5YWz6ZetXG4gICAgKi9cbiAgIHB1YmxpYyBzZXRSZWRIaW50T3Blbk9yQ2xvc2UocmVkOiBudW1iZXIsIGlzT3BlbjogYm9vbGVhbikge1xuICAgICAgICBpZiAodGhpcy5fY2hpbGROdW1bcmVkXSA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi57qi54K55pWw5o2u6K6+572u6ZSZ6K+v77ya5LiN6IO955u05o6l5a+56auY57qn55qE57qi54K55pWw5o2u5pON5L2cXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9TZXRSZWRIaW50T3Blbk9yQ2xvc2UocmVkLCBpc09wZW4gPyAxIDogMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiDorrDlvZXniLblrZDlhbPns7vvvJrlrZAtLS3niLZcbiAgICAqL1xuICAgIHByaXZhdGUgc2V0UGFyZW50KGNoaWxkOiBudW1iZXIsIHBhcmVudDogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRJbmRleFtwYXJlbnRdID09IGNoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuWFs+ezu+WPjeS6hlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50SW5kZXhbY2hpbGRdKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIumHjeWkjeiuvue9rlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJlbnRJbmRleFtjaGlsZF0gPSBwYXJlbnQ7XG4gICAgICAgIGlmIChpc05hTih0aGlzLl9jaGlsZE51bVtwYXJlbnRdKSkgeyB0aGlzLl9jaGlsZE51bVtwYXJlbnRdID0gMCB9XG4gICAgICAgIHRoaXMuX2NoaWxkTnVtW3BhcmVudF0rKzsvL+WtkOmhueaVsOmHj+WinuWKoFxuICAgICAgICB0aGlzLl9jaGlsZEluZGV4W2NoaWxkXSA9IHRoaXMuX2NoaWxkTnVtW3BhcmVudF07Ly/lrZDpobnnmoTntKLlvJUg5LuOMeW8gOWni1xuICAgIH1cblxuICAgIHByaXZhdGUgZG9TZXRSZWRIaW50T3Blbk9yQ2xvc2UocmVkOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RhdGFbcmVkXSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YVtyZWRdID0gdmFsdWU7XG4gICAgICAgICAgICBsZXQgX3BhcmVudDogbnVtYmVyID0gdGhpcy5fcGFyZW50SW5kZXhbcmVkXVxuICAgICAgICAgICAgaWYgKF9wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAvL+WmguaenOacieeItue6p++8jOabtOaWsOeItue6p1xuICAgICAgICAgICAgICAgIGxldCBpbmRleDogbnVtYmVyID0gdGhpcy5fY2hpbGRJbmRleFtyZWRdOy8v6I635Y+W5Zyo54i257qn5Lit55qE57Si5byVXG4gICAgICAgICAgICAgICAgdGhpcy5kb1NldFJlZEhpbnRPcGVuT3JDbG9zZShfcGFyZW50LCB2YWx1ZSA+IDAgPyB0aGlzLl9kYXRhW19wYXJlbnRdIHwgdGhpcy5hZGRWKGluZGV4KSA6IHRoaXMuX2RhdGFbX3BhcmVudF0gJiB0aGlzLnN1YlYoaW5kZXgpKTsvL+iuvue9rueItue6p+eahOWAvFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL+WPkeaUueWPmOS6i+S7tjrlhajlsYDkuovku7ZcbiAgICAgICAgICAgIC8vZW1pdChSZWRIaW50c01hbmFnZXIuUkVEX0hJTlRfVkFMVUVfQ0hBTkdFRCwgcmVkKTtcbiAgICAgICAgICAgIC8v57qi54K55LqL5Lu277yM5bGA6YOo5LqL5Lu2XG4gICAgICAgICAgICBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdChyZWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIGFkZFYoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiAxIDw8IChpbmRleCAtIDEpO1xuICAgIH1cbiAgICBwcml2YXRlIHN1YlYoaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB+dGhpcy5hZGRWKGluZGV4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICog5p+l55yL57qi54K55piv5ZCm5byA5ZCvXG4gICAgKi9cbiAgICBwdWJsaWMgY2hlY2tSZWRJc09wZW4ocmVkOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbcmVkXSA+IDA7XG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgeyBNZXNzZW5nZXIgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NlbmdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcblxuXG5cbmV4cG9ydCBjbGFzcyBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFJlZEhpbnRzTWVzc2FnZU1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSByZWRoaW50c01lc3NhZ2U6TWVzc2VuZ2VyID0gbmV3IE1lc3NlbmdlcigpO1xuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsb2JqOmFueSwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMucmVkaGludHNNZXNzYWdlLmFkZExpc3RlbmVyKG1zZ0NvZGUsIG9iaiwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihtc2dDb2RlOm51bWJlciwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLnJlZGhpbnRzTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihtc2dDb2RlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlDb2RlKG1zZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy5yZWRoaW50c01lc3NhZ2UucmVtb3ZlTGlzdGVuZXJCeVR5cGUobXNnQ29kZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFydXAoKXtcbiAgICAgICAgdGhpcy5yZWRoaW50c01lc3NhZ2UuY2xlYXJ1cCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3QobXNnQ29kZTpudW1iZXIscGFyYW1zOmFueSl7XG5cblxuICAgICAgICB0aGlzLnJlZGhpbnRzTWVzc2FnZS5icm9hZGNhc3QobXNnQ29kZSwgcGFyYW1zKVxuICAgIH1cbiAgICBcblxufSIsImltcG9ydCB7IEdhbWVPYmplY3RQb29sIH0gZnJvbSBcIi4uL2NvbW1vbi9HYW1lT2JqZWN0UG9vbFwiO1xuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gXCIuLi9jb21tb24vUmVzTWFuYWdlclwiO1xuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlU2NlbmV7XG5cbiAgICBwcml2YXRlIHByZWxvYWRGYWlyeUdVSVBhY2thZ2U6TWFwPHN0cmluZyxzdHJpbmc+O1xuICAgIHByaXZhdGUgcHJlbG9hZFByZWZhYjpNYXA8c3RyaW5nLG51bWJlcj47XG4gICAgcHVibGljIGZpbmlzaENvdW50ID0gMDtcbiAgICBwdWJsaWMgdG90YWxDb3VudCA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuXG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZSA9IG5ldyBNYXA8c3RyaW5nLHN0cmluZz4oKTtcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiID0gbmV3IE1hcDxzdHJpbmcsbnVtYmVyPigpO1xuICAgICAgICB0aGlzLmZpbmlzaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUHJlbG9hZEZhaXJ5R1VJUGFja2FnZShhZGRyZXNzOnN0cmluZywgcGFja2FnZU5hbWU6c3RyaW5nKXtcbiAgICAgICAgdGhpcy5wcmVsb2FkRmFpcnlHVUlQYWNrYWdlLnNldChhZGRyZXNzLHBhY2thZ2VOYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUHJlbG9hZFByZWZhYihhZGRyZXNzOnN0cmluZywgaW5zdENvdW50KXtcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLnNldChhZGRyZXNzLCBpbnN0Q291bnQpO1xuICAgIH1cblxuXG4gICAgcHVibGljIGFic3RyYWN0IG9uRW50ZXIoKTtcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25Db21wbGV0ZSgpO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkxlYXZlKCk7XG5cbiAgICBwdWJsaWMgYXN5bmMgb25QcmVwYXJlKCl7XG5cbiAgICAgICAgbGV0IGZndWlQa2dDb3VudCA9IHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5zaXplO1xuICAgICAgICBsZXQgcHJlZmFiQ291bnQgPSB0aGlzLnByZWxvYWRQcmVmYWIuc2l6ZTtcblxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSBmZ3VpUGtnQ291bnQgKyBwcmVmYWJDb3VudDtcblxuXG4gICAgICAgIGxldCBwcmVtaXNlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgbGV0IHByZW1pc2UgPSBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRGYWlyeUdVSVBhY2thZ2Uoa2V5LCB2YWx1ZSwoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoQ291bnQgKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZW1pc2VzLnB1c2gocHJlbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJlbG9hZFByZWZhYi5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgbGV0IHByZW1pc2UgPSBHYW1lT2JqZWN0UG9vbC5JbnN0YW5jZShHYW1lT2JqZWN0UG9vbCkucHJlTG9hZEdhbWVPYmplY3RBc3luYyhrZXksIHZhbHVlLCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hDb3VudCsrO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHByZW1pc2VzLnB1c2gocHJlbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZW1pc2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25EZXN0cm95KCl7XG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRlc3Ryb3kgc2NlbmU6IFwiK2tleSk7XG5cbiAgICAgICAgICAgIFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikucmVsZWFzZUZhaXJ5R1VJUGFja2FnZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8v5riF55CG6LWE5rqQ57yT5a2YXG4gICAgICAgIEdhbWVPYmplY3RQb29sLkluc3RhbmNlKEdhbWVPYmplY3RQb29sKS5jbGVhbnVwKHRydWUpO1xuXG4gICAgICAgIFxuICAgICAgICB0aGlzLnByZWxvYWRGYWlyeUdVSVBhY2thZ2UuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLmNsZWFyKCk7XG4gICAgfVxufSIsImV4cG9ydCAgY2xhc3MgU2NlbmVEZWZ7XG5cbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmdTY2VuZTpzdHJpbmcgPSBcIkxvYWRpbmdTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgTGF1bmNoU2NlbmU6c3RyaW5nID0gXCJMYXVuY2hTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgSG9tZVNjZW5lOnN0cmluZyA9IFwiSG9tZVNjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBMb2dpblNjZW5lOnN0cmluZyA9IFwiTG9naW5TY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUHZlU2NlbmU6c3RyaW5nID0gXCJQdmVTY2VuZVwiO1xufVxuIiwiaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4vQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFB2ZVNjZW5lIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL3B2ZS9zY2VuZS9QdmVTY2VuZVwiO1xyXG5pbXBvcnQgeyBIb21lU2NlbmUgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvaG9tZS9zY2VuZS9Ib21lU2NlbmVcIjtcclxuaW1wb3J0IHsgTG9naW5TY2VuZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi9zY2VuZS9Mb2dpblNjZW5lXCI7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSBcIi4vU2NlbmVEZWZcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lRmFjdG9yeXtcclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVTY2VuZShzY2VuZU5hbWU6c3RyaW5nKTpCYXNlU2NlbmV7XHJcblxyXG4gICAgICAgIGxldCBzY2VuZTpCYXNlU2NlbmUgPSBudWxsO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHNjZW5lTmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuTG9naW5TY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IExvZ2luU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjZW5lRGVmLkhvbWVTY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IEhvbWVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuUHZlU2NlbmU6XHJcbiAgICAgICAgICAgICAgICBzY2VuZSA9IG5ldyBQdmVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBVbml0eUVuZ2luZSB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vZ2FtZS9ldmVudC9VSU1lc3NhZ2VcIjtcbmltcG9ydCB7IFVJTWVzc2FnZU1hbmdlciB9IGZyb20gXCIuLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vdWkvVUlNYW5hZ2VyXCI7XG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi9CYXNlU2NlbmVcIjtcbmltcG9ydCB7IFNjZW5lRmFjdG9yeSB9IGZyb20gXCIuL1NjZW5lRmFjdG9yeVwiO1xuXG5cblxuXG5leHBvcnQgY2xhc3MgU2NlbmVNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFNjZW5lTWFuYWdlcj57XG5cbiAgICBwcml2YXRlIG9uU2NlbmVMb2FkZWRPbmx5OkZ1bmN0aW9uO1xuICAgIHByaXZhdGUgY3VycmVudFNjZW5lOkJhc2VTY2VuZTtcblxuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBVbml0eUVuZ2luZS5TY2VuZU1hbmFnZW1lbnQuU2NlbmVNYW5hZ2VyLmFkZF9zY2VuZUxvYWRlZCgoc2NlbmUsIF9tb2RlKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5vblNjZW5lTG9hZGVkT25seSAhPSBudWxsKSB0aGlzLm9uU2NlbmVMb2FkZWRPbmx5KHNjZW5lLm5hbWUpO1xuICAgICAgICB9KTsgXG4gICAgfVxuXG5cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2NlbmUoc2NlbmU6c3RyaW5nLCBvbkxvYWRDb21wbGV0ZTpGdW5jdGlvbil7XG4gICAgICAgIFxuICAgICAgICB0cnl7XG4gICAgICAgICAgICB0aGlzLm9uU2NlbmVMb2FkZWRPbmx5ID0gYXN5bmMgKHNjZW5lTmFtZTpzdHJpbmcpPT57XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNjZW5lTmFtZSA9PSBzY2VuZSl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25TY2VuZUxvYWRlZE9ubHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9ICBTY2VuZUZhY3RvcnkuY3JlYXRlU2NlbmUoc2NlbmUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkVudGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSB0aGlzLmN1cnJlbnRTY2VuZS5maW5pc2hDb3VudC90aGlzLmN1cnJlbnRTY2VuZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwcm9ncmVzczpcIitwcm9ncmVzcyArIFwiID0gXCIrdGhpcy5jdXJyZW50U2NlbmUuZmluaXNoQ291bnQgKyBcIiA9IFwiK3RoaXMuY3VycmVudFNjZW5lLnRvdGFsQ291bnQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIFVJTWVzc2FnZU1hbmdlci5JbnN0YW5jZShVSU1lc3NhZ2VNYW5nZXIpLmJyb2FkY2FzdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKjEwMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudFNjZW5lLmZpbmlzaENvdW50ID09IHRoaXMuY3VycmVudFNjZW5lLnRvdGFsQ291bnQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NJbnRlcnZhbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+WKoOi9veWujOaIkFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihvbkxvYWRDb21wbGV0ZSAhPSBudWxsKSBvbkxvYWRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpLmNsb3NlTG9hZGluZyhjb21tb25VSS5VSUxvYWRpbmdQYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vblByZXBhcmUoKTsgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikub3BlbkxvYWRpbmcoY29tbW9uVUkuUGFja2FnZU5hbWUsIGNvbW1vblVJLlVJTG9hZGluZ1BhZ2UpO1xuICAgICAgIFxuICAgICAgICAgICAgLy/muIXnkIbml6flnLrmma9cbiAgICAgICAgICAgIGlmKHRoaXMuY3VycmVudFNjZW5lKXtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkxlYXZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25EZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IFVuaXR5RW5naW5lLlNjZW5lTWFuYWdlbWVudC5TY2VuZU1hbmFnZXIuTG9hZFNjZW5lKHNjZW5lKTtcblxuICAgICAgICB9Y2F0Y2goZXgpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsb2FkIHNjZW5lIGV4Y2VwOlwiK2V4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cblxuXG4gICAgXG59IiwiXHJcblxyXG5cclxuZXhwb3J0IGVudW0gVUlUeXBlRGVme1xyXG4gICAgVW5rb3duID0gMCxcclxuICAgIFBhZ2UgPSAxLFxyXG4gICAgV2luZG93PTIsXHJcbiAgICBXaWRnZXQgPSAzLFxyXG4gICAgTG9hZGluZyA9NFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVUlMYXllckRlZntcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIEJhY2tncm91bmQ6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgUGFnZTpudW1iZXIgPSAxMDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBOb3JtYWxXaW5kb3c6bnVtYmVyID0gMjAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgVG9wV2luZG93Om51bWJlciA9IDMwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIFdpZGdldDpudW1iZXIgPSA0MDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkaW5nOm51bWJlciA9IDUwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVua293bjpudW1iZXIgPSA5OTk5O1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgIGdldERlZmF1bHRMYXllcih0eXBlOlVJVHlwZURlZik6bnVtYmVye1xyXG5cclxuICAgICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLkxvYWRpbmc6IHJldHVybiB0aGlzLkxvYWRpbmc7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLldpZGdldDogcmV0dXJuIHRoaXMuV2lkZ2V0O1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5XaW5kb3c6IHJldHVybiB0aGlzLk5vcm1hbFdpbmRvdztcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuUGFnZTogcmV0dXJuIHRoaXMuUGFnZTtcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuVW5rb3duOiByZXR1cm4gdGhpcy5Vbmtvd247XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLlVua293bjsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJQ29tRGVmc3tcclxuICAgIHB1YmxpYyBzdGF0aWMgQmFja0J0biA9IFwiYmFja19idG5cIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgV2luZG93Q2xvc2VCdG4gPSBcIndpbl9jbG9zZV9idG5cIjtcclxufVxyXG5cclxuXHJcblxyXG4iLCJcclxuaW1wb3J0IHsgVUlMb2dpblBhZ2UgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlMb2dpblBhZ2VcIjtcclxuaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlIb21lUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9ob21lL3VpL1VJSG9tZVBhZ2VcIjtcclxuaW1wb3J0IHsgVUlMb2FkaW5nIH0gZnJvbSBcIi4vVUlMaWIvVUlMb2FkaW5nXCI7XHJcbmltcG9ydCB7IGxvZ2luVUkgfSBmcm9tIFwiLi4vLi4vZGF0YS91aS9sb2dpblwiO1xyXG5pbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IFVJTXNnQm94IH0gZnJvbSBcIi4vVUlMaWIvVUlNc2dCb3hcIjtcclxuaW1wb3J0IHsgVUlTZWxTZXJ2ZXJXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlTZWxTZXJ2ZXJXaW5cIjtcclxuaW1wb3J0IHsgVUlTaG9wUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9ob21lL3VpL1VJU2hvcFBhZ2VcIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IFVJU3RvcnlXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvc3RvcnkvVUlTdG9yeVdpblwiO1xyXG5cclxuXHJcblxyXG5jb25zdCBDUyA9IHJlcXVpcmUoJ2NzaGFycCcpO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUZhY3Rvcnl7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB1aUNhY2hlOk1hcDxzdHJpbmcsVUlQYW5lbD4gPSBuZXcgTWFwPHN0cmluZyxVSVBhbmVsPigpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlVUkocGtnOnN0cmluZywgbmFtZTpzdHJpbmcpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBjcmVhdGUgVUk6ICR7cGtnfToke25hbWV9YClcclxuICAgICAgICBsZXQgY29tcCA9IENTLkZhaXJ5R1VJLlVJUGFja2FnZS5DcmVhdGVPYmplY3QocGtnLCBuYW1lKS5hc0NvbVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB1aTpVSVBhbmVsID0gdGhpcy51aUNhY2hlLmdldChuYW1lKTtcclxuXHJcbiAgICAgICAgaWYoIXVpKXtcclxuICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgIC8vY29tbW9uXHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbW1vblVJLlVJVUlOb3RpY2VXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlNc2dCb3goKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlMb2FkaW5nUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vbG9naW5cclxuICAgICAgICAgICAgICAgIGNhc2UgbG9naW5VSS5VSUxvZ2luUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSUxvZ2luUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBsb2dpblVJLlVJU2VsU2VydmVyV2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU2VsU2VydmVyV2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ob21lXHJcbiAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5VSUhvbWVQYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJSG9tZVBhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgaG9tZVVJLlVJU2hvcFBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlTaG9wUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3N0b3J5XHJcbiAgICAgICAgICAgICAgICBjYXNlIHN0b3J5VUkuVUlTdG9yeVdpbjpcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVN0b3J5V2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudWlDYWNoZS5zZXQobmFtZSwgdWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih1aSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmZ1aSA9IGNvbXA7XHJcbiAgICAgICAgICAgIHVpLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgICAgICAgICAgLy/nu5HlrppGYWlyeUdVSeaOp+S7tlxyXG4gICAgICAgICAgICB1aS5iaW5kQWxsKHVpKTtcclxuICAgICAgICAgICAgdWkuYXdha2UoKTtcclxuICAgICAgICBcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgbm90IGNyZWF0ZSB1aTogJHtwa2d9LSR7bmFtZX1gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB1aTtcclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFuZWwgfSBmcm9tIFwiLi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYgfSBmcm9tIFwiLi4vVUlEZWZpbmVcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2VNYW5nZXIgfSBmcm9tIFwiLi4vLi4vLi4vZ2FtZS9ldmVudC9VSU1lc3NhZ2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgIFVJTG9hZGluZyBleHRlbmRzIFVJUGFuZWx7XHJcblxyXG5cclxuICAgIEBiaW5kZXIoXCJsb2FkaW5nX3ByZWdyZXNzXCIpXHJcbiAgICBwdWJsaWMgcHJvZ3Jlc3NMb2FkaW5nOiBGYWlyeUdVSS5HUHJvZ3Jlc3NCYXI7XHJcblxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOiB2b2lkIHtcclxuICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLkxvYWRpbmc7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uT3Blbihhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uT3BlbihhcmcpO1xyXG5cclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52YWx1ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIFVJTWVzc2FnZU1hbmdlci5JbnN0YW5jZShVSU1lc3NhZ2VNYW5nZXIpLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAocHJvZ3Jlc3M6bnVtYmVyKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcuVHdlZW5WYWx1ZShwcm9ncmVzcywgMC4xKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NMb2FkaW5nLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKS5yZW1vdmVMaXN0ZW5lckJ5Q29kZShcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TQ0VORV9QUk9HUkVTU1xyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uL1VJV2luZG93XCI7XHJcblxyXG4vLyDpgJrnlKjlvLnnqpdcclxuZXhwb3J0IGNsYXNzIFVJTXNnQm94QXJne1xyXG4gICAgcHVibGljIHRpdGxlOnN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgY29udGVudDpzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGJ0blRleHQ6c3RyaW5nID0gXCJcIjsvL1wi56Gu5a6afOWPlua2iHzlhbPpl61cIlxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJTXNnQm94IGV4dGVuZHMgVUlXaW5kb3d7XHJcblxyXG4gICAgcHJpdmF0ZSBtX2FyZzpVSU1zZ0JveEFyZztcclxuXHJcbiAgICBAYmluZGVyKFwibXNnVHh0XCIpXHJcbiAgICBwcml2YXRlIG1fdHh0OkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJva0J0blwiKVxyXG4gICAgcHJpdmF0ZSBtX29rQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwiY2FuY2VsQnRuXCIpXHJcbiAgICBwcml2YXRlIG1fY2FuY2VsQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmJpbmRBbGwodGhpcylcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKGFyZyk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICAgXHJcbiAgICB9XHJcblxyXG59IiwiXHJcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gJy4uL2NvbW1vbi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyBVSUxvYWRpbmcgfSBmcm9tICcuL1VJTGliL1VJTG9hZGluZyc7XHJcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSAnLi9VSVdpbmRvdyc7XHJcbmltcG9ydCB7IFVJV2lkZ2UgfSBmcm9tICcuL1VJV2lkZ2UnO1xyXG5pbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSAnLi9VSVBhbmVsJztcclxuaW1wb3J0IHsgVUlGYWN0b3J5IH0gZnJvbSAnLi9VSUZhY3RvcnknO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gJy4uL3NjZW5lL1NjZW5lRGVmJztcclxuaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSAnLi4vLi4vZGF0YS91aS9ob21lJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlQYWdlVHJhY2t7XHJcbiAgICBwdWJsaWMgcGtnOnN0cmluZztcclxuICAgIHB1YmxpYyBuYW1lOnN0cmluZztcclxuICAgIHB1YmxpYyBhcmc6YW55O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxVSU1hbmFnZXI+e1xyXG5cclxuICAgIHByaXZhdGUgIG1fcGFnZVRyYWNrU3RhY2s6QXJyYXk8VUlQYWdlVHJhY2s+O1xyXG4gICAgcHJpdmF0ZSBtX2N1cnJlbnRQYWdlOlVJUGFnZVRyYWNrO1xyXG5cclxuICAgIHByaXZhdGUgbV9saXN0TG9hZGVkUGFuZWw6QXJyYXk8VUlQYW5lbD47XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrID0gbmV3IEFycmF5PFVJUGFnZVRyYWNrPigpO1xyXG4gICAgICAgIHRoaXMubV9saXN0TG9hZGVkUGFuZWwgPSBuZXcgQXJyYXk8VUlQYW5lbD4oKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjbG9zZUFsbExvYWRlZFBhbmVsKCk6dm9pZHtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xyXG4gICAgICAgICAgICBsZXQgcGFuZWwgPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYocGFuZWwuaXNPcGVuKXtcclxuICAgICAgICAgICAgICAgIHBhbmVsLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHBhbmVsLmRpc3Bvc2UoKTsgIFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFuKCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZUFsbExvYWRlZFBhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMubV9saXN0TG9hZGVkUGFuZWwubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb3Blbihwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnPzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6YW55ID0gdGhpcy5nZXRVSShuYW1lKTtcclxuXHJcbiAgICAgICAgaWYodWkgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHVpID0gVUlGYWN0b3J5LmNyZWF0ZVVJKHBrZywgbmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMubV9saXN0TG9hZGVkUGFuZWwucHVzaCh1aSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih1aSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdWkub3BlbihhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZ2V0VUkobmFtZTpzdHJpbmcpOlVJUGFuZWx7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgcGFuZWwgb2YgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbCkge1xyXG4gICAgICAgICAgICBpZihwYW5lbC5uYW1lID09IG5hbWUpe1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmluZCBwYW5lbCBpbiBjYWNoZTogXCIrbmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhbmVsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5omT5byA5Zy65pmv6aG16Z2iLOatpOmhtemdouS4jeiuoeWFpemhtemdouagiCzml6Dov5Tlm57kuIrkuIDpnaLmjInpkq5cclxuICAgIHB1YmxpYyBvcGVuUGFnZUluU2NlbmUocGtnOnN0cmluZywgcGFnZTpzdHJpbmcsIGFyZzphbnkpe1xyXG4gICAgICAgIHRoaXMub3BlblBhZ2VXb3JrZXIocGtnLCBwYWdlLCBhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVVJTG9hZGluZ1xyXG4gICAgLy/miZPlvIBMb2FkaW5n55WM6Z2iXHJcbiAgICBwdWJsaWMgb3BlbkxvYWRpbmcocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZz86YW55KXtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVuUGFnZUluU2NlbmUocGtnLCBuYW1lLCBhcmcpO1xyXG5cclxuICAgIH1cclxuICAgIC8v5YWz6ZetTG9hZGluZ+eVjOmdolxyXG4gICAgcHVibGljIGNsb3NlTG9hZGluZyhuYW1lOnN0cmluZywgYXJnPzphbnkpOnZvaWR7XHJcbiAgICAgICAgbGV0IHVpOlVJTG9hZGluZyA9IHRoaXMuZ2V0VUkobmFtZSkgYXMgVUlMb2FkaW5nO1xyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICB1aS5jbG9zZShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09UGFnZVxyXG4gICAgcHJpdmF0ZSBvcGVuUGFnZVdvcmtlcihwa2c6c3RyaW5nLCBwYWdlOnN0cmluZywgYXJnOmFueSl7XHJcbiAgICAgICAgdGhpcy5tX2N1cnJlbnRQYWdlID0gbmV3IFVJUGFnZVRyYWNrKCk7XHJcbiAgICAgICAgdGhpcy5tX2N1cnJlbnRQYWdlLnBrZyA9IHBrZztcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UubmFtZSA9IHBhZ2U7XHJcbiAgICAgICAgdGhpcy5tX2N1cnJlbnRQYWdlLmFyZyA9IGFyZztcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZUFsbExvYWRlZFBhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMub3Blbihwa2csIHBhZ2UsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/miZPlvIDpobXpnaIsIOS8muWFs+mXreS4iuS4gOS4qumhtemdouS4iueahOaJgOacieeql+WPoyxXaWRpZ2V0562JXHJcbiAgICBwdWJsaWMgb3BlblBhZ2UocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZz86YW55KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2N1cnJlbnRQYWdlICE9IHVuZGVmaW5lZCAmJiB0aGlzLm1fY3VycmVudFBhZ2UubmFtZSE9bmFtZSl7XHJcbiAgICAgICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5wdXNoKHRoaXMubV9jdXJyZW50UGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHBrZywgbmFtZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+i/lOWbnuS4iuS4gOS4qumhtemdolxyXG4gICAgcHVibGljIGdvQmFja1BhZ2UoKTp2b2lke1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fcGFnZVRyYWNrU3RhY2subGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMubV9wYWdlVHJhY2tTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcih0cmFjay5wa2cgLHRyYWNrLm5hbWUsIHRyYWNrLmFyZyk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJNYWluUGFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8v5Zue5Yiw5Li75Z+OXHJcbiAgICBwdWJsaWMgZW50ZXJNYWluUGFnZSgpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMub3BlblBhZ2VJblNjZW5lKGhvbWVVSS5QYWNrYWdlTmFtZSAsaG9tZVVJLlVJSG9tZVBhZ2UsbnVsbClcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpbmRvd1xyXG4gICAgLy/miZPlvIDnqpflj6NcclxuICAgIHB1YmxpYyBvcGVuV2luZG93KHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc6YW55KTpVSVdpbmRvd3tcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2luZG93ID0gdGhpcy5vcGVuKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5YWz6Zet56qX5Y+jXHJcbiAgICBwdWJsaWMgY2xvc2VXaW5kb3cobmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaW5kb3cgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJV2luZG93O1xyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICB1aS5jbG9zZShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpZGdldFxyXG4gICAgLy/miZPlvIBXaWRpZ2V0XHJcbiAgICBwdWJsaWMgb3BlbldpZGdldChwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnOmFueSk6VUlXaWRnZXtcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2lkZ2UgPSB0aGlzLm9wZW4ocGtnLCBuYW1lLCBhcmcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG4gICAgLy915YWz6ZetV2lkaWdldFxyXG4gICAgcHVibGljIGNsb3NlV2lkZ2V0KG5hbWU6c3RyaW5nLCBhcmc6YW55KXtcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2lkZ2UgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJV2lkZ2U7XHJcbiAgICAgICAgaWYodWkhPW51bGwpe1xyXG4gICAgICAgICAgICB1aS5jbG9zZShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlUeXBlRGVmLCBVSUNvbURlZnMgfSBmcm9tIFwiLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi9VSU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgVUlQYWdlIGV4dGVuZHMgVUlQYW5lbHtcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuUGFnZTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1fYnRuR29CYWNrOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fYnRuR29CYWNrID0gdGhpcy5mdWkuR2V0Q2hpbGQoVUlDb21EZWZzLkJhY2tCdG4pO1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fYnRuR29CYWNrIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm1fYnRuR29CYWNrLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQnRuR29CYWNrKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIG9uT3Blbih2bzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKHZvKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICBcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQnRuR29CYWNrKCl7XHJcbiAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikuZ29CYWNrUGFnZSgpO1xyXG4gICAgfVxyXG5cclxufSAiLCJpbXBvcnQgeyBVSVR5cGVEZWYsIFVJTGF5ZXJEZWYgfSBmcm9tIFwiLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVSVBhbmVsIHtcclxuXHJcbiAgICBwdWJsaWMgZnVpOmFueTsgIC8vRmFpcnlHVUkg5a+56LGhXHJcblxyXG5cclxuICAgIHByaXZhdGUgX25hbWU6c3RyaW5nO1xyXG4gICAgcHVibGljIHNldCBuYW1lKHY6c3RyaW5nKXtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgbmFtZSgpOnN0cmluZ3tcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLlVua293bjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBtX2xheWVyOlVJTGF5ZXJEZWYgPSBVSUxheWVyRGVmLlVua293bjtcclxuICAgIHB1YmxpYyBnZXQgbGF5ZXIoKSA6IFVJTGF5ZXJEZWYge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fbGF5ZXI7IFxyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBsYXllcih2IDogVUlMYXllckRlZikge1xyXG4gICAgICAgIHRoaXMubV9sYXllciA9IHY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyAgZ2V0IGlzT3BlbigpIDogYm9vbGVhbntcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVpLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQXdha2UoKTp2b2lkO1xyXG4gICAgcHVibGljIG9uVXBkYXRlKCk6dm9pZHt9XHJcblxyXG4gICAgcHVibGljIG9uT3Blbih2bzphbnkpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5sYXllciA9IFVJTGF5ZXJEZWYuZ2V0RGVmYXVsdExheWVyKHRoaXMudWlUeXBlKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7fVxyXG5cclxuICAgIHB1YmxpYyBhd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5vbkF3YWtlKCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8v57uR5a6aRmFpcnlHVUnlhYPku7ZcclxuICAgIHB1YmxpYyBiaW5kQWxsKHRhcmdldDphbnkpOnZvaWR7XHJcbiAgICAgICAgZm9yKGxldCBrIGluIHRhcmdldFtcImJpbmRlcnNcIl0pe1xyXG4gICAgICAgICAgICBsZXQgZmd1aU5hbWUgPSB0aGlzW1wiYmluZGVyc1wiXVtrXTtcclxuICAgICAgICAgICAgdGhpc1trXSA9IHRoaXMuZnVpLkdldENoaWxkKGZndWlOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZSgpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVuKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5vbk9wZW4oYXJnKTtcclxuXHJcbiAgICAgICAgRmFpcnlHVUkuR1Jvb3QuaW5zdC5BZGRDaGlsZCh0aGlzLmZ1aSk7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xvc2UoYXJnOmFueSA9IG51bGwpOnZvaWR7XHJcblxyXG5cclxuICAgICAgICB0aGlzLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICAgICAgRmFpcnlHVUkuR1Jvb3QuaW5zdC5SZW1vdmVDaGlsZCh0aGlzLmZ1aSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLmZ1aS5EaXNwb3NlKCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYsIFVJQ29tRGVmcyB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyAgVUlXaW5kb3cgZXh0ZW5kcyBVSVBhbmVse1xyXG4gICBcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbV9idG5DbG9zZTpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fYnRuQ2xvc2UgPSB0aGlzLmZ1aS5HZXRDaGlsZChVSUNvbURlZnMuV2luZG93Q2xvc2VCdG4pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKGFyZyk7XHJcblxyXG4gICAgICAgIHRoaXMuZnVpLnggPSBGYWlyeUdVSS5HUm9vdC5pbnN0LndpZHRoLzIgLSB0aGlzLmZ1aS53aWR0aC8yO1xyXG4gICAgICAgIHRoaXMuZnVpLnkgPSBGYWlyeUdVSS5HUm9vdC5pbnN0LmhlaWdodC8yIC0gdGhpcy5mdWkuaGVpZ2h0LzI7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9idG5DbG9zZSE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5tX2J0bkNsb3NlLm9uQ2xpY2suQWRkKHRoaXMub25CdG5DbG9zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2J0bkNsb3NlIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm1fYnRuQ2xvc2Uub25DbGljay5SZW1vdmUodGhpcy5vbkJ0bkNsb3NlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkJ0bkNsb3NlKCl7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgwKTtcclxuICAgIH1cclxuXHJcbn0iLCJcclxuXHJcbmV4cG9ydCBjbGFzcyBUaW1lVXRpbHtcclxuXHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgcHJlZml4SW50ZWdlcihudW0sIGxlbmd0aCk6c3RyaW5ne1xyXG5cclxuICAgICAgICByZXR1cm4gIChBcnJheShsZW5ndGgpLmpvaW4oJzAnKSArIG51bSkuc2xpY2UoLWxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/lsIbkuIDkuKrml7bpl7TmlbDovazmjaLmiJBcIjAwOjAwOjAwXCLmoLzlvI9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGltZVN0cmluZzEodGltZUludCA6IG51bWJlcik6c3RyaW5nIHtcclxuXHJcbiAgICAgICAgaWYodGltZUludCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMDA6MDA6MDBcIjtcclxuICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgIGxldCBob3VyOm51bWJlciA9IE1hdGguZmxvb3IodGltZUludCAvICg2MCAqIDYwKSk7XHJcbiAgICAgICAgICAgIGxldCBob3Vyc3RyID0gdGhpcy5wcmVmaXhJbnRlZ2VyKGhvdXIsIDIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG1pbm51dGU6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50LyA2MCkgJSA2MDtcclxuICAgICAgICAgICAgbGV0IG1pbnV0ZXN0cjpzdHJpbmcgPSB0aGlzLnByZWZpeEludGVnZXIobWlubnV0ZSwgMik7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2Vjb25kOm51bWJlciA9IHRpbWVJbnQgJSA2MDtcclxuICAgICAgICAgICAgbGV0IHNlY29uZHN0cjpzdHJpbmcgPSB0aGlzLnByZWZpeEludGVnZXIoc2Vjb25kLDIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAke2hvdXJzdHJ9OiR7bWludXRlc3RyfToke3NlY29uZHN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDA6MDBcIuagvOW8j1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRUaW1lU3RyaW5nKHRpbWVJbnQ6bnVtYmVyKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIGlmKHRpbWVJbnQgPD0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjAwOjAwOjAwXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGxldCBob3VyOm51bWJlciA9IE1hdGguZmxvb3IodGltZUludCAvICg2MCAqIDYwKSk7XHJcbiAgICAgICAgICAgIGxldCBob3Vyc3RyID0gdGhpcy5wcmVmaXhJbnRlZ2VyKGhvdXIsIDIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG1pbm51dGU6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50LyA2MCkgJSA2MDtcclxuICAgICAgICAgICAgbGV0IG1pbnV0ZXN0cjpzdHJpbmcgPSB0aGlzLnByZWZpeEludGVnZXIobWlubnV0ZSwgMik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN0cn06JHttaW51dGVzdHJ9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy/lsIbkuIDkuKrml7bpl7TmlbDovazmjaLmiJBcIjAwXCLliIbmoLzlvI9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGltZU1pbnV0ZVN0cmluZyh0aW1lSW50Om51bWJlcik6c3RyaW5ne1xyXG5cclxuICAgICAgICBpZih0aW1lSW50IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMDowMDowMFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgbWlubnV0ZTpudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVJbnQvIDYwKSAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihtaW5udXRlLCAyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBgJHttaW51dGVzdHJ9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy/lsIbkuIDkuKrml7bpl7TmlbDovazmjaLmiJBcIjAw4oCc56eS5qC85byPXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpbWVTZWNvbmRTdHJpbmcodGltZUludDpudW1iZXIpOnN0cmluZ3tcclxuXHJcbiAgICAgICAgaWYodGltZUludCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMDA6MDA6MDBcIjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbGV0IHNlY29uZDpudW1iZXIgPSB0aW1lSW50ICUgNjA7XHJcbiAgICAgICAgICAgIGxldCBzZWNvbmRzdHI6c3RyaW5nID0gdGhpcy5wcmVmaXhJbnRlZ2VyKHNlY29uZCwyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBgJHtzZWNvbmRzdHJ9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy/ojrflj5bmnKzmnIgx5Y+35piv5pif5pyf5YegXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFdlZWtPZk1vbnRoRmlyc3REYXkodGltZTpudW1iZXIpOm51bWJlcntcclxuXHJcbiAgICAgICAgbGV0IGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcclxuICAgICAgICBkYXRlLnNldERhdGUoMSk7XHJcblxyXG4gICAgICAgIHJldHVybiBkYXRlLmdldERheSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5Yik5pat5piv5ZCm5Li66Zew5bm0XHJcbiAgICBwdWJsaWMgc3RhdGljIGlzTGVhcFllYXIoeWVhcjpudW1iZXIpXHJcbiAgICB7XHJcbiAgICAgICAgaWYgKCAoeWVhciAlIDQgPT0gMCAmJiB5ZWFyICUgMTAwICE9IDApIHx8ICh5ZWFyICUgNDAwID09IDApICl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy/mr4/kuKrmnIjlr7nlupTnmoTlpKnmlbBcclxuICAgIHN0YXRpYyAgbW9udGhzOkFycmF5PG51bWJlcj4gPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XHJcbiAgICBwcml2YXRlIHN0YXRpYyBnZXRNb250aERheXNfKHllYXI6bnVtYmVyLCBtb250aDpudW1iZXIpOm51bWJlcntcclxuICAgICAgICBpZihtb250aCA9PSAyKXtcclxuICAgICAgICAgICAgaWYodGhpcy5pc0xlYXBZZWFyKHllYXIpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI5O1xyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDI4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vbnRoc1ttb250aF07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0TW9udGhEYXlzKHRpbWU6bnVtYmVyKTpudW1iZXIge1xyXG5cclxuICAgICAgICBsZXQgdCA9IG5ldyBEYXRlKHRpbWUpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aERheXNfKHQuZ2V0RnVsbFllYXIoKSwgdC5nZXRNb250aCgpKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBzbGVlcChtczpudW1iZXIpe1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT57XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCk9PntcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoJycpO1xyXG4gICAgICAgICAgICB9LCBtcyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgdGVzdCgpOnZvaWR7XHJcblxyXG4gICAgICAgIGxldCB0MTpzdHJpbmcgPSB0aGlzLmdldFRpbWVTdHJpbmcxKDUwMDApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHQxKTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgbGV0IHQyOnN0cmluZyA9IHRoaXMuZ2V0VGltZVN0cmluZyg1MDAwKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0Mik7XHJcblxyXG4gICAgICAgIGxldCB0MzpzdHJpbmcgPSB0aGlzLmdldFRpbWVNaW51dGVTdHJpbmcoNTAwMCk7XHJcbiAgICAgICAgY29uc29sZS5sb2codDMpO1xyXG5cclxuICAgICAgICBsZXQgdDQ6c3RyaW5nID0gdGhpcy5nZXRUaW1lU2Vjb25kU3RyaW5nKDUwMDApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHQ0KTtcclxuXHJcbiAgICAgICAgbGV0IHRpbWU6bnVtYmVyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIGxldCB0NTpudW1iZXIgPSB0aGlzLmdldFdlZWtPZk1vbnRoRmlyc3REYXkodGltZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJnZXRXZWVrT2ZNb250aEZpcnN0RGF5OiBcIit0NSArIFwiICx0aW1lOlwiK3RpbWUpO1xyXG5cclxuICAgICAgICBsZXQgdDY6bnVtYmVyID0gdGhpcy5nZXRNb250aERheXModGltZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJnZXRNb250aERheXM6IFwiK3Q2KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCB7IG5pY2VfdHMgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9nZW4vcGJcIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IFNlc3Npb25NYW5hZ2VyIH0gZnJvbSBcIi4uLy4uL2ZyYW1ld29yay9uZXQvU2Vzc2lvbk1hbmFnZXJcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTG9naW5BUEl7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBiZW5jaG1hcmtUZXN0KCl7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcihsZXQgaT0xOyBpPDI7aSsrKXtcclxuICAgICAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJHU19UZXN0LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBtc2cudGVzdElEID0gaTtcclxuICAgICAgICAgICAgbXNnLnRlc3ROYW1lID0gXCJiZW5jaG1hcmsgdGVzdFwiO1xyXG4gICAgICAgICAgICBsZXQgYnVmID0gbmljZV90cy5DMkdTX1Rlc3QuZW5jb2RlKG1zZykuZmluaXNoKCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgcnBjSWQgPSBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuZ2F0ZVJwY0lEO1xyXG4gICAgICAgICAgICAvL3Rlc3RcclxuICAgICAgICAgICAgcnBjSWQgPSBpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2VuZCBtc2c6IFwiK3JwY0lkKVxyXG4gICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgICAgICBPcGNvZGUuTVNHX0MyR1NfVGVzdCxcclxuICAgICAgICAgICAgICAgIHJwY0lkLFxyXG4gICAgICAgICAgICAgICAgYnVmLFxyXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlOmFueSk9PntcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbXNnICA9ICByZXNwb25zZSBhcyBuaWNlX3RzLkdTMkNfVGVzdDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvZGU6IFwiK21zZy5FcnJvciArXCIsbXNnOlwiK21zZy5NZXNzYWdlICtcIixyZXM6XCIrbXNnLnRlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgbG9naW5SZWFsbVNlcnZlcihhY2NvdW50OnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nLCBjYWxsYmFjazpGdW5jdGlvbil7XHJcblxyXG4gICAgICAgICBsZXQgbXNnID0gbmljZV90cy5DMlJfTG9naW4uY3JlYXRlKCk7XHJcbiAgICAgICAgIG1zZy5BY2NvdW50ID0gYWNjb3VudDtcclxuICAgICAgICAgbXNnLlBhc3N3b3JkID0gcGFzc3dvcmQ7XHJcbiAgICAgICAgIGxldCBidWYgPSBuaWNlX3RzLkMyUl9Mb2dpbi5lbmNvZGUobXNnKS5maW5pc2goKTtcclxuICAgICAgICBcclxuICAgICAgICAgbGV0IHJwY0lkID0gU2Vzc2lvbk1hbmFnZXIuSW5zdGFuY2UoU2Vzc2lvbk1hbmFnZXIpLnJlYWxtUnBjSUQ7XHJcblxyXG4gICAgICAgIFNlc3Npb25NYW5hZ2VyLkluc3RhbmNlKFNlc3Npb25NYW5hZ2VyKS5zZW5kUmVhbG1Nc2coXHJcbiAgICAgICAgICAgIE9wY29kZS5NU0dfQzJSX0xvZ2luLFxyXG4gICAgICAgICAgICBycGNJZCxcclxuICAgICAgICAgICAgYnVmLFxyXG4gICAgICAgICAgICAocmVzcG9uc2U6YW55KT0+e1xyXG4gICAgICAgICAgICAgICAgbGV0IG1zZyAgPSAgcmVzcG9uc2UgYXMgbmljZV90cy5SMkNfTG9naW47XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKVxyXG5cclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgbG9naW5HYXRlU2VydmVyKGdhdGVJZCwgZ2F0ZUtleSwgY2FsbGJhY2s6RnVuY3Rpb24pe1xyXG5cclxuICAgICAgICBsZXQgcnBjSWQgPSBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuZ2F0ZVJwY0lEO1xyXG4gICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyR19Mb2dpbkdhdGUuY3JlYXRlKCk7XHJcbiAgICAgICAgbXNnLkdhdGVJZCA9IGdhdGVJZDtcclxuICAgICAgICBtc2cuS2V5ID0gZ2F0ZUtleTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgYnVmID0gbmljZV90cy5DMkdfTG9naW5HYXRlLmVuY29kZShtc2cpLmZpbmlzaCgpO1xyXG5cclxuICAgICAgICBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgIE9wY29kZS5NU0dfQzJHX0xvZ2luR2F0ZSxcclxuICAgICAgICAgICAgcnBjSWQsXHJcbiAgICAgICAgICAgIGJ1ZixcclxuICAgICAgICAgICAgKHJlc3BvbnNlOmFueSk9PntcclxuICAgICAgICAgICAgICAgIGxldCBtc2cgPSByZXNwb25zZSBhcyBuaWNlX3RzLkcyQ19Mb2dpbkdhdGU7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhtc2cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICB9XHJcbn0iLCJcblxuXG5leHBvcnQgY2xhc3MgVUlNZXNzYWdle1xuXG5cbiAgICBwdWJsaWMgc3RhdGljIE1TR19TRUxFQ1RfU0VSVkVSOm51bWJlciAgPSAxMDAwO1xuICAgIHB1YmxpYyBzdGF0aWMgTVNHX1NDRU5FX1BST0dSRVNTOm51bWJlciA9IDEwMDE7XG4gICAgXG5cblxufSIsImltcG9ydCB7IE1lc3NlbmdlciB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvY29tbW9uL01lc3NlbmdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uLy4uL2ZyYW1ld29yay9jb21tb24vU2luZ2xldG9uXCI7XG5cblxuZXhwb3J0IGNsYXNzIFVJTWVzc2FnZU1hbmdlciBleHRlbmRzIFNpbmdsZXRvbjxVSU1lc3NhZ2VNYW5nZXI+e1xuXG4gICAgcHJpdmF0ZSB1aU1lc3NhZ2U6TWVzc2VuZ2VyID0gbmV3IE1lc3NlbmdlcigpO1xuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsb2JqOmFueSwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMudWlNZXNzYWdlLmFkZExpc3RlbmVyKG1zZ0NvZGUsIG9iaiwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihtc2dDb2RlOm51bWJlciwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLnVpTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihtc2dDb2RlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlDb2RlKG1zZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXJCeVR5cGUobXNnQ29kZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFydXAoKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UuY2xlYXJ1cCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3QobXNnQ29kZTpudW1iZXIscGFyYW1zOmFueSl7XG5cblxuICAgICAgICB0aGlzLnVpTWVzc2FnZS5icm9hZGNhc3QobXNnQ29kZSwgcGFyYW1zKVxuICAgIH1cbn0iLCJpbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFVJTWFuYWdlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFZvSG9tZSB9IGZyb20gXCIuLi92by9Wb0hvbWVcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSG9tZVNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcblxyXG4gICAgICAgIHRoaXMuYWRkUHJlbG9hZEZhaXJ5R1VJUGFja2FnZShob21lVUkuUGFja2FnZUJ5dGVzLGhvbWVVSS5QYWNrYWdlTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ29tcGxldGUoKSB7XHJcblxyXG4gICAgICAgIGxldCB2bzpWb0hvbWUgPSBuZXcgVm9Ib21lKCk7XHJcbiAgICAgICAgdm8ubmFtZSA9IFwiSnVzdGluXCI7XHJcbiAgICAgICAgdm8uaHAgPSAxMjAwO1xyXG4gICAgICAgIHZvLm1wID0gMzMwMDtcclxuICAgICAgICB2by5tb25leSA9IDY2NjtcclxuXHJcbiAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikub3BlblBhZ2VJblNjZW5lKFxyXG4gICAgICAgICAgICBob21lVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGhvbWVVSS5VSUhvbWVQYWdlLFxyXG4gICAgICAgICAgICB2byk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJUGFnZVwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBjb21tb24gfSBmcm9tIFwicHJvdG9idWZqc1wiO1xyXG5pbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IFZvSG9tZSB9IGZyb20gXCIuLi92by9Wb0hvbWVcIjtcclxuaW1wb3J0IHsgTG9naW5BUEkgfSBmcm9tIFwiLi4vLi4vLi4vYXBpL0xvZ2luQVBJXCI7XHJcbmltcG9ydCB7IEdhbWVTZXNzaW9uIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9uZXQvR2FtZVNlc3Npb25cIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IG5pY2VfdHMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS9wYi9nZW4vcGJcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJSG9tZVBhZ2UgZXh0ZW5kcyBVSVBhZ2V7XHJcblxyXG4gICAgQGJpbmRlcihcImNoYXRCdG5cIilcclxuICAgIHB1YmxpYyBtX2NoYXRCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJiYWdCdG5cIilcclxuICAgIHB1YmxpYyBtX2JhZ0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcInNob3BCdG5cIilcclxuICAgIHB1YmxpYyBtX3Nob3BCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJsZXZlbEJ0blwiKVxyXG4gICAgcHVibGljIG1fbGV2ZWxCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBAYmluZGVyKFwibmFtZVR4dFwiKVxyXG4gICAgcHVibGljIG1fbmFtZUxibDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwiaHBUeHRcIilcclxuICAgIHB1YmxpYyBtX2hwTGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJtcFR4dFwiKVxyXG4gICAgcHVibGljIG1fbXBMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm1vbmV5VHh0XCIpXHJcbiAgICBwdWJsaWMgbV9tb25leUxibDpGYWlyeUdVSS5HTGFiZWw7XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMubV9jaGF0QnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25jaGF0QnRuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tX2JhZ0J0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uYmFnQnRuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tX3Nob3BCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbnNob3BCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fbGV2ZWxCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbmxldmVsQnRuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICBwdWJsaWMgb25PcGVuKHZvOlZvSG9tZSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4odm8pO1xyXG5cclxuICAgICAgICB0aGlzLm1fbmFtZUxibC50ZXh0ID0gdm8ubmFtZTtcclxuICAgICAgICB0aGlzLm1fbXBMYmwudGV4dCA9IHZvLm1wLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tX2hwTGJsLnRleHQgPSB2by5ocC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubV9tb25leUxibC50ZXh0ID0gdm8ubW9uZXkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgR2FtZVNlc3Npb24uSW5zdGFuY2UoR2FtZVNlc3Npb24pLmxpc3RlbihPcGNvZGUuTVNHX0dTMkNfVGVzdCxmdW5jdGlvbihtc2c6bmljZV90cy5HUzJDX1Rlc3Qpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuaUtuWIsOacjeWKoeWZqOS4i+WPkeeahOa2iOaBr+OAguOAguOAguOAglwiK21zZy50ZXN0UmVzcG9uc2UpXHJcbiAgICAgICAgfSlcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIG9uY2hhdEJ0bigpe1xyXG5cclxuICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICBjb21tb25VSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgY29tbW9uVUkuVUlVSU5vdGljZVdpbixcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbiBjaGF0Li4uXCIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uYmFnQnRuKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbiBiYWcgLi5cIik7XHJcblxyXG4gICAgICAgIC8vYmVuY2htYXJrIHRlc3RcclxuICAgICAgICBMb2dpbkFQSS5iZW5jaG1hcmtUZXN0KCk7XHJcblxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uc2hvcEJ0bigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpLm9wZW5QYWdlKFxyXG4gICAgICAgICAgICBob21lVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGhvbWVVSS5VSVNob3BQYWdlKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbmxldmVsQnRuKCl7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJvbiBsZXZlbC4uLlwiKTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJUGFnZVwiO1xuXG5cblxuZXhwb3J0IGNsYXNzIFVJU2hvcFBhZ2UgZXh0ZW5kcyBVSVBhZ2V7XG5cblxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xuXG4gICAgfVxuXG4gICAgXG4gICAgcHVibGljIG9uT3Blbih2bzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uT3Blbih2byk7XG5cbiAgICAgICAgXG4gICAgfVxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcblxuICAgIH1cblxufSIsIlxuXG5leHBvcnQgY2xhc3MgVm9Ib21le1xuXG4gICAgcHVibGljIG5hbWU6c3RyaW5nO1xuICAgIHB1YmxpYyBocDpudW1iZXI7XG4gICAgcHVibGljIG1wOm51bWJlcjtcbiAgICBwdWJsaWMgbW9uZXk6bnVtYmVyO1xuXG59IiwiXHJcbmltcG9ydCB7IGxvZ2luVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9sb2dpblwiO1xyXG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcclxuaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmVcIjtcclxuaW1wb3J0IHsgVUlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSU1hbmFnZXJcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIExvZ2luU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuXHJcbiAgICAgICAgLy/mt7vliqDpooTliqDovb3otYTmupBcclxuICAgICAgIHRoaXMuYWRkUHJlbG9hZEZhaXJ5R1VJUGFja2FnZShsb2dpblVJLlBhY2thZ2VCeXRlcyxsb2dpblVJLlBhY2thZ2VOYW1lKTtcclxuICAgICAgIC8v5rWL6K+VU3RvcnlcclxuICAgICAgIHRoaXMuYWRkUHJlbG9hZEZhaXJ5R1VJUGFja2FnZShzdG9yeVVJLlBhY2thZ2VCeXRlcyxzdG9yeVVJLlBhY2thZ2VOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Db21wbGV0ZSgpIHtcclxuICAgICAgICBcclxuICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuUGFnZUluU2NlbmUoXHJcbiAgICAgICAgICAgIGxvZ2luVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGxvZ2luVUkuVUlMb2dpblBhZ2UsXHJcbiAgICAgICAgICAgIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gIFxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IFNlc3Npb25NYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9uZXQvU2Vzc2lvbk1hbmFnZXJcIjtcclxuaW1wb3J0IHsgTG9naW5BUEkgfSBmcm9tIFwiLi4vLi4vLi4vYXBpL0xvZ2luQVBJXCI7XHJcbmltcG9ydCB7IFVJTWFuYWdlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IGxvZ2luVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9sb2dpblwiO1xyXG5pbXBvcnQgeyBWb1NlcnZlciwgVm9TZXJ2ZXJJdGVtIH0gZnJvbSBcIi4uL3ZvL1ZvU2VydmVyXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZU1hbmdlciB9IGZyb20gXCIuLi8uLi8uLi9ldmVudC9VSU1lc3NhZ2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi8uLi9ldmVudC9VSU1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgU2NlbmVNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9TY2VuZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgU2NlbmVEZWYgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lRGVmXCI7XHJcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xyXG5pbXBvcnQgeyBuaWNlX3RzIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvcGIvZ2VuL3BiXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxvZ2luUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiYWNjb3VudFwiKVxyXG4gICAgcHVibGljIG1fYWNjb3VudDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG4gICAgQGJpbmRlcihcInBhc3N3b3JkXCIpXHJcbiAgICBwdWJsaWMgbV9wYXNzd29yZDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG5cclxuICAgIEBiaW5kZXIoXCJzZWxzZXJ2ZXJCdG5cIilcclxuICAgIHB1YmxpYyBtX3NlbHNlcnZlckJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJsb2dpbkJ0blwiKVxyXG4gICAgcHVibGljIG1fbG9naW5CdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBAYmluZGVyKFwic3RvcnlCdG5cIilcclxuICAgIHB1YmxpYyBtX3N0b3J5QnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgcHJpdmF0ZSBnYXRlSWQ6YW55O1xyXG4gICAgcHJpdmF0ZSBnYXRlS2V5Om51bWJlcnxMb25nO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2dpbkNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubV9zdG9yeUJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICAgICAgc3RvcnlVSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgICAgICBzdG9yeVVJLlVJU3RvcnlXaW4sXHJcbiAgICAgICAgICAgICAgICBudWxsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TZWxTZXJ2ZXJXaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLmVuYWJsZWQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgU2Vzc2lvbk1hbmFnZXIuSW5zdGFuY2UoU2Vzc2lvbk1hbmFnZXIpLmNvbm5lY3RSZWFsbVNlcnZlcihcclxuICAgICAgICAgICAgKGNvZGU6bnVtYmVyKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubV9sb2dpbkJ0bi5lbmFibGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICB9ICwoY29kZTpudW1iZXIpPT57XHJcbiAgICAgICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHByaXZhdGUgb25TZWxlY3RTZXJ2ZXIoc2VydmVySXRlbTpWb1NlcnZlckl0ZW0pe1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIiBzZXJ2ZXIgc2VsZWN0ZWQ6IFwiK3NlcnZlckl0ZW0uc2VydmVyTmFtZSlcclxuICAgICAgICB0aGlzLm1fc2Vsc2VydmVyQnRuLnRleHQgPSBzZXJ2ZXJJdGVtLnNlcnZlck5hbWU7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4odm86YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uT3Blbih2byk7XHJcblxyXG4gICAgICAgICAvL+ebkeWQrOmAieacjea2iOaBr1xyXG4gICAgICAgICBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKS5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICAgICBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKS5yZW1vdmVMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9wZW5TZWxTZXJ2ZXJXaW4oKXtcclxuXHJcbiAgICAgICAgLy8g5rWL6K+V5pWw5o2uXHJcbiAgICAgICAgbGV0IHZvU2VydmVyOlZvU2VydmVyID0gbmV3IFZvU2VydmVyKCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTE7IGk8MTA7IGkrKyl7XHJcbiAgICAgICAgICAgIHZvU2VydmVyLmFyZWFNYXAuc2V0KGksXCLliIbljLpcIitpKTtcclxuICAgICAgICAgICAgdm9TZXJ2ZXIuc2VydmVyTWFwLnNldChpLCBuZXcgQXJyYXk8Vm9TZXJ2ZXJJdGVtPigpKTtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaj0xOyBqPDIwOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2b1NlcnZlckl0ZW06Vm9TZXJ2ZXJJdGVtID0gbmV3IFZvU2VydmVySXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLmFyZWFJZCA9IGk7XHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVySWQgPSBqO1xyXG5cclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5zZXJ2ZXJOYW1lID0gXCLmtYvor5XmnI3liqHlmahcIitpK1wiOlwiK2o7XHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVyU3RhdHVzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjMrMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KGkpLnB1c2godm9TZXJ2ZXJJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikub3BlbldpbmRvdyhcclxuICAgICAgICAgICAgbG9naW5VSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgIGxvZ2luVUkuVUlTZWxTZXJ2ZXJXaW4sXHJcbiAgICAgICAgICAgIHZvU2VydmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uTG9naW5DbGljaygpe1xyXG5cclxuICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMubV9hY2NvdW50LnRleHQ7XHJcbiAgICAgICAgbGV0IHBhc3N3b3JkID0gdGhpcy5tX3Bhc3N3b3JkLnRleHQ7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBhY2NvdW50OiR7YWNjb3VudH0gLSBwYXNzd29yZDogJHtwYXNzd29yZH1gKTtcclxuXHJcbiAgICAgICAgaWYoYWNjb3VudCAhPSBcIlwiICYmIHBhc3N3b3JkICE9IFwiXCIpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgTG9naW5BUEkubG9naW5SZWFsbVNlcnZlcihcclxuICAgICAgICAgICAgICAgIGFjY291bnQsIFxyXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQsXHJcbiAgICAgICAgICAgICAgICAobXNnOm5pY2VfdHMuUjJDX0xvZ2luKT0+e1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhdGVJZCA9IG1zZy5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXRlS2V5ID0gbXNnLktleTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luIHJlYW0gc3VjYywgZ2F0ZSBhZGRyOlwiK21zZy5BZGRyZXNzICsgXCIsa2V5OlwiK21zZy5LZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuZGlzY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy/nmbvlvZXnvZHlhbPmnI1cclxuICAgICAgICAgICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuY29ubmVjdEdhdGVTZXJ2ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1zZy5BZGRyZXNzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29kZTpudW1iZXIpPT57dGhpcy5vbkNvbm5HYXRlU3VjYyhjb2RlKTsgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvZGU6bnVtYmVyKT0+e3RoaXMub25Db25uR2F0ZUVycihjb2RlKTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25Db25uR2F0ZVN1Y2MoY29kZTpudW1iZXIpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiY29ubmVjdCBnYXRlIHN1Y2M6IFwiK2NvZGUpXHJcblxyXG4gICAgICAgIExvZ2luQVBJLmxvZ2luR2F0ZVNlcnZlcihcclxuICAgICAgICAgICAgdGhpcy5nYXRlSWQsXHJcbiAgICAgICAgICAgIHRoaXMuZ2F0ZUtleSxcclxuICAgICAgICAgICAgKG1zZzpuaWNlX3RzLkcyQ19Mb2dpbkdhdGUpPT57XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHBsYXllcklEID0gbXNnLlBsYXllcklkO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJsb2dpbiBnYXRlIHJlc3BvbnNlLi5cIiArcGxheWVySUQpO1xyXG5cclxuICAgICAgICAgICAgICAgIFNjZW5lTWFuYWdlci5JbnN0YW5jZShTY2VuZU1hbmFnZXIpLmxvYWRTY2VuZShTY2VuZURlZi5Ib21lU2NlbmUsKCk9Pnt9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkNvbm5HYXRlRXJyKGNvZGU6bnVtYmVyKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3QgZ2F0ZSBlcnI6IFwiK2NvZGUpXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlXaW5kb3dcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2VNYW5nZXIgfSBmcm9tIFwiLi4vLi4vLi4vZXZlbnQvVUlNZXNzYWdlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBWb1NlcnZlciwgVm9TZXJ2ZXJJdGVtIH0gZnJvbSBcIi4uL3ZvL1ZvU2VydmVyXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSVNlbFNlcnZlcldpbiBleHRlbmRzIFVJV2luZG93e1xyXG5cclxuICAgIEBiaW5kZXIoXCJhcmVhTGlzdFwiKVxyXG4gICAgcHJpdmF0ZSBhcmVhTGlzdDpGYWlyeUdVSS5HTGlzdDtcclxuICAgIEBiaW5kZXIoXCJzZXJ2ZXJMaXN0XCIpXHJcbiAgICBwcml2YXRlIHNlcnZlckxpc3Q6RmFpcnlHVUkuR0xpc3Q7XHJcbiAgICBAYmluZGVyKFwiYmFja0J0blwiKVxyXG4gICAgcHJpdmF0ZSBiYWNrQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwib2tCdG5cIilcclxuICAgIHByaXZhdGUgb2tCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJ0aXRsZVwiKVxyXG4gICAgcHJpdmF0ZSB0aXRsZTpGYWlyeUdVSS5HTGFiZWw7XHJcblxyXG4gICAgcHJpdmF0ZSAgY2xpY2tBcmVhSW5kZXg6bnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgIGNsaWNrU2VydmVySW5kZXg6bnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgdm9TZXJ2ZXI6Vm9TZXJ2ZXI7XHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYWNrQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5va0J0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYXJlYUxpc3Qub25DbGlja0l0ZW0uQWRkKChldmVudDpGYWlyeUdVSS5FdmVudENvbnRleHQpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tBcmVhSW5kZXggPSB0aGlzLmFyZWFMaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNlcnZlckxpc3QubnVtSXRlbXMgPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyTGlzdC5SZWZyZXNoVmlydHVhbExpc3QoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGlja1NlcnZlckluZGV4ID0gdGhpcy5zZXJ2ZXJMaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpdGxlLnRleHQgPSBcIuW3sumAieaLqeacjeWKoeWZqO+8mlwiK3RoaXMuY2xpY2tTZXJ2ZXJJbmRleDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBvblNlbGVjdFNlcnZlcigpe1xyXG5cclxuICAgICAgICBsZXQgc2VsSXRlbTpWb1NlcnZlckl0ZW0gPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKVt0aGlzLmNsaWNrU2VydmVySW5kZXhdO1xyXG5cclxuICAgICAgICBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKS5icm9hZGNhc3QoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0VMRUNUX1NFUlZFUixcclxuICAgICAgICAgICAgc2VsSXRlbVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIG9uT3Blbih2bzpWb1NlcnZlcik6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4odm8pO1xyXG4gICAgICAgIHRoaXMudm9TZXJ2ZXIgPSB2bztcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhTGlzdC5TZXRWaXJ0dWFsKCk7XHJcbiAgICAgICAgdGhpcy5hcmVhTGlzdC5pdGVtUmVuZGVyZXIgPSAoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCk9PntcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBcmVhTGlzdEl0ZW0oaW5kZXgsIG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lm51bUl0ZW1zID0gdm8uYXJlYU1hcC5zaXplO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICB0aGlzLnNlcnZlckxpc3QuU2V0VmlydHVhbCgpO1xyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5pdGVtUmVuZGVyZXIgPSAoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCk9PntcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZXJ2ZXJMaXN0SXRlbShpbmRleCwgb2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5udW1JdGVtcyA9IHZvLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKS5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJBcmVhTGlzdEl0ZW0oaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCl7XHJcblxyXG4gICAgICAgIGxldCBhcmVhQnRuOkZhaXJ5R1VJLkdCdXR0b24gPSBvYmouYXNCdXR0b247XHJcbiAgICAgICAgYXJlYUJ0bi50ZXh0ID0gdGhpcy52b1NlcnZlci5hcmVhTWFwLmdldChpbmRleCsxKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZW5kZXJTZXJ2ZXJMaXN0SXRlbShpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KXtcclxuICAgICAgICBsZXQgc2VydmVyQnRuOkZhaXJ5R1VJLkdCdXR0b24gPSBvYmouYXNCdXR0b247XHJcblxyXG4gICAgICAgIHNlcnZlckJ0bi50ZXh0ID0gdGhpcy52b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KHRoaXMuY2xpY2tBcmVhSW5kZXgrMSlbaW5kZXhdLnNlcnZlck5hbWU7XHJcbiAgICAgICAgLy9zZXJ2ZXJCdG4uaWNvbiA9IEZhaXJ5R1VJLlVJUGFja2FnZS5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxufSIsIlxuXG5cbmV4cG9ydCBjbGFzcyBWb1NlcnZlckl0ZW17XG5cbiAgICBwdWJsaWMgYXJlYUlkOm51bWJlcjtcbiAgICBwdWJsaWMgc2VydmVySWQ6bnVtYmVyO1xuICAgIHB1YmxpYyBzZXJ2ZXJOYW1lOnN0cmluZztcbiAgICBwdWJsaWMgc2VydmVyU3RhdHVzOm51bWJlcjtcbn1cblxuZXhwb3J0ICBjbGFzcyBWb1NlcnZlcntcblxuICAgIHB1YmxpYyBzZXJ2ZXJNYXA6IE1hcDxudW1iZXIsIEFycmF5PFZvU2VydmVySXRlbT4+ID0gbmV3IE1hcDxudW1iZXIsIEFycmF5PFZvU2VydmVySXRlbT4+KCk7XG4gICAgcHVibGljIGFyZWFNYXA6TWFwPG51bWJlcixzdHJpbmc+ID0gbmV3IE1hcDxudW1iZXIsIHN0cmluZz4oKTtcbn0iLCJpbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBQdmVTY2VuZSBleHRlbmRzIEJhc2VTY2VuZXtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25Db21wbGV0ZSgpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XG5pbXBvcnQgeyBDaG9pY2UgfSBmcm9tIFwiaW5ranMvZW5naW5lL0Nob2ljZVwiO1xuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi8uLi9kYXRhL3VpL3N0b3J5XCI7XG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XG5pbXBvcnQgeyBTdG9yeU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2luay9TdG9yeU1hbmFnZXJcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2luay9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJTWFuYWdlclwiO1xuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJV2luZG93XCI7XG5cbmV4cG9ydCBjbGFzcyBVSVN0b3J5V2luIGV4dGVuZHMgVUlXaW5kb3d7XG5cbiAgICBAYmluZGVyKFwic3BlYWtlclR4dFwiKVxuICAgIHByaXZhdGUgbV9zcGVha2VyVHh0OkZhaXJ5R1VJLkdSaWNoVGV4dEZpZWxkO1xuICAgIEBiaW5kZXIoXCJidG5MaXN0XCIpXG4gICAgcHJpdmF0ZSBtX2J0bkxpc3Q6RmFpcnlHVUkuR0xpc3Q7XG5cbiAgICBwcml2YXRlIHNob3VsZENvbnRpbmVTdG9yeTpib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBvcHRpb25zTWFwOk1hcDxudW1iZXIsc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLHN0cmluZz4oKTtcbiAgICBwcml2YXRlIGFsbENob2ljZXM6Q2hvaWNlW107XG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgICAgICB0aGlzLm1fYnRuTGlzdC5pdGVtUmVuZGVyZXIgPSAoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCk9PntcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQnRuTGlzdChpbmRleCwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubV9idG5MaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xuICAgICAgICAgICAgIGxldCBjbGlja0lkOm51bWJlciA9IHRoaXMubV9idG5MaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLnNob3VsZENvbnRpbmVTdG9yeSl7XG4gICAgICAgICAgICAgICAgU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcikuYWR2YW5jZVN0b3J5KCk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBTdG9yeU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNYW5hZ2VyKS5zZWxlY3RDaG9pY2UodGhpcy5hbGxDaG9pY2VzW2NsaWNrSWRdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25PcGVuKHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25PcGVuKHZvKTtcblxuICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNPTlRFTlRSRUFEWSxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLk9uQ29udGVudFJlYWR5XG4gICAgICAgICk7XG4gICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ0hPSUNFU1BSRVNFTlRFRCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLk9uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICApO1xuICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PblN0b3J5RmluaXNoZWRcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub3B0aW9uc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IGZhbHNlO1xuXG4gICAgICAgIFN0b3J5TWFuYWdlci5JbnN0YW5jZShTdG9yeU1hbmFnZXIpLmJlZ2luU3RvcnkoXCJzdG9yeTJcIik7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIE9uQ29udGVudFJlYWR5KFxuICAgICAgICBzcGVha2VyQ29udGVudDpzdHJpbmcsXG4gICAgICAgIHNwZWFrZXJJZDpzdHJpbmcsXG4gICAgICAgIGN1cnJlbnRUYWdzOnN0cmluZ1tdLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSlcbiAgICB7XG4gICAgICAgIHRoaXMubV9zcGVha2VyVHh0LnRleHQgPSBzcGVha2VyQ29udGVudDtcblxuICAgICAgICBpZihTdG9yeU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNYW5hZ2VyKS5jYW5Db250aW51ZSl7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnRDaG9pY2VzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hvaWNlcyA9IGN1cnJlbnRDaG9pY2VzO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IGxlbiA9IGN1cnJlbnRDaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hcC5zZXQoaSwgY3VycmVudENob2ljZXNbaV0udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJCdG5MaXN0KGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3Qpe1xuICAgICAgICBsZXQgY29udGludWVCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9uc01hcC5zaXplPjApe1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IHRoaXMub3B0aW9uc01hcC5nZXQoaW5kZXgpO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IFwi54K55Ye757un57utXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIE9uQ2hvaWNlc1ByZXNlbnRlZChjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSl7XG4gICAgICBcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcbiAgICAgICAgY29uc29sZS5sb2coXCIuLi4uT25DaG9pY2VzUHJlc2VudGVkLi4uLi4uXCIpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBPblN0b3J5RmluaXNoZWQoKTp2b2lke1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RvcnkgRmluaXNoZWRcIilcblxuICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5jbG9zZVdpbmRvdyhzdG9yeVVJLlVJU3RvcnlXaW4sbnVsbCk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XG5cbiAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DT05URU5UUkVBRFksXG4gICAgICAgICAgICB0aGlzLk9uQ29udGVudFJlYWR5XG4gICAgICAgICk7XG4gICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ0hPSUNFU1BSRVNFTlRFRCxcbiAgICAgICAgICAgIHRoaXMuT25DaG9pY2VzUHJlc2VudGVkXG4gICAgICAgICk7XG4gICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OU1RPUllGSU5JU0hFRCxcbiAgICAgICAgICAgIHRoaXMuT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICk7XG4gICAgfVxufSIsIlxyXG5leHBvcnQgIGNsYXNzIEdhbWVDb25maWd7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWJ1Zzpib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVySVA6c3RyaW5nID0gXCIxMjcuMC4wLjFcIjsgXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVyUG9ydDpudW1iZXIgPSA5MDAxO1xyXG5cclxufSIsIlxyXG5cclxuaW1wb3J0IHtTaW5nbGV0b259IGZyb20gJy4uL2ZyYW1ld29yay9jb21tb24vU2luZ2xldG9uJztcclxuXHJcbmV4cG9ydCBjbGFzcyBTaW5nbGV0b25UZXN0IGV4dGVuZHMgU2luZ2xldG9uPFNpbmdsZXRvblRlc3Q+e1xyXG5cclxuICAgIHByaXZhdGUgbnVtOm51bWJlciA9IDA7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNpbmdsZXRvblRlc3QgY2FsbCBjb25zdHJ1Y3RvclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKCkgOiB2b2lkIHtcclxuXHJcbiAgICAgICAgdGhpcy5udW0gKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdGVzdCgpIDogbnVtYmVye1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5udW07XHJcblxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7VGltZVV0aWx9IGZyb20gJy4uL2ZyYW1ld29yay91dGlsL1RpbWVVdGlsJztcclxuaW1wb3J0IHtTaW5nbGV0b25UZXN0fSBmcm9tICcuL1NpbmdsZXRvblRlc3QnO1xyXG5pbXBvcnQge01lc3Nlbmdlcn0gZnJvbSAnLi4vZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXInO1xyXG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSAnLi4vZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyJztcclxuaW1wb3J0IHsgU2tpbGxDb25maWdUQiwgU2tpbGxDb25maWdUUiB9IGZyb20gJy4uL2RhdGEvZXhjZWwvU2tpbGxDb25maWcnO1xyXG5pbXBvcnQgeyBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyIH0gZnJvbSAnLi4vZnJhbWV3b3JrL3JlZGhpbnRzL1JlZEhpbnRzTWVzc2FnZU1hbmFnZXInO1xyXG5pbXBvcnQgeyBlbnVtUmVkSGludHMsIFJlZEhpbnRzTWFuYWdlciB9IGZyb20gJy4uL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01hbmFnZXInO1xyXG5pbXBvcnQgeyBTdG9yeSB9IGZyb20gJ2lua2pzJztcclxuaW1wb3J0IHsgbmljZV90cyB9IGZyb20gJy4uL2RhdGEvcGIvZ2VuL3BiJztcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVW5pdFRlc3R7XHJcbiAgICBwdWJsaWMgc3RhdGljIHRlc3RWYXI6bnVtYmVyID0gMTAwMDA7XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgZG9UZXN0KCl7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGltZVV0aWwgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgVGltZVV0aWwudGVzdCgpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlNpbmdsZXRvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBTaW5nbGV0b25UZXN0Lkluc3RhbmNlKFNpbmdsZXRvblRlc3QpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiPT09XCIpO1xyXG4gICAgICAgIGxldCB0MTogU2luZ2xldG9uVGVzdCA9IFNpbmdsZXRvblRlc3QuSW5zdGFuY2UoU2luZ2xldG9uVGVzdCk7XHJcbiAgICAgICAgbGV0IHQyOiBTaW5nbGV0b25UZXN0ID0gU2luZ2xldG9uVGVzdC5JbnN0YW5jZShTaW5nbGV0b25UZXN0KTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2codDEudGVzdCgpICsgXCIgOiBcIiArIHQyLnRlc3QoKSk7XHJcbiAgICAgICAgdDEuYWRkKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2codDEudGVzdCgpICsgXCIgOiBcIiArIHQyLnRlc3QoKSk7XHJcbiAgICAgICAgdDIuYWRkKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2codDEudGVzdCgpICsgXCIgOiBcIiArIHQyLnRlc3QoKSk7XHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIk1lc3NhZ2VyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICBsZXQgbWVzc2VuZ2VyOk1lc3NlbmdlciA9IG5ldyBNZXNzZW5nZXIoKTtcclxuICAgICAgICBsZXQgbGlzdGVuOkZ1bmN0aW9uID0gZnVuY3Rpb24oYTpudW1iZXIsIGI6c3RyaW5nKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYGxpc3RlbiBjYWxsOiAke2F9ICwgJHtifWApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsaXN0ZW4yOkZ1bmN0aW9uID0gZnVuY3Rpb24oYTpudW1iZXIsIGI6c3RyaW5nKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYGxpc3RlbiBjYWxsMjogJHthfSAsICR7Yn1gKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0ICBFVkVOVF9DT0RFOm51bWJlciA9IDEwMDtcclxuICAgICAgICBtZXNzZW5nZXIuYWRkTGlzdGVuZXIoRVZFTlRfQ09ERSx0aGlzLCBsaXN0ZW4pO1xyXG4gICAgICAgIG1lc3Nlbmdlci5hZGRMaXN0ZW5lcihFVkVOVF9DT0RFLHRoaXMsIGxpc3RlbjIpO1xyXG4gICAgICAgIG1lc3Nlbmdlci5icm9hZGNhc3QoRVZFTlRfQ09ERSwgOTk5LFwiIEhlbGxvXCIpO1xyXG5cclxuICAgICAgICBtZXNzZW5nZXIucmVtb3ZlTGlzdGVuZXIoRVZFTlRfQ09ERSxsaXN0ZW4pO1xyXG4gICAgICAgIG1lc3Nlbmdlci5icm9hZGNhc3QoRVZFTlRfQ09ERSwgOTk5LFwiIEhlbGxvXCIpO1xyXG5cclxuICAgICAgICBtZXNzZW5nZXIuY2xlYXJ1cCgpO1xyXG4gICAgICAgIG1lc3Nlbmdlci5icm9hZGNhc3QoRVZFTlRfQ09ERSwgOTk5LFwiIEhlbGxvXCIpO1xyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUaW1lciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgbGV0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnRlciB2YWwuLlwiKVxyXG4gICAgICAgIH0sMTAwMCk7XHJcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sNTAwMCk7IFxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXNvdXJjZU1hbmFnZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgIGxldCBwcmVmYWIgPSBhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRQcmVmYWIoXCJNb2RlbHMvMTAwMS9DaGFyYWN0ZXIucHJlZmFiXCIpIDtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhwcmVmYWIpO1xyXG5cclxuICAgICAgICAvL2xldCBpbnN0ID0gQ1MuVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5JbnN0YW50aWF0ZShwcmVmYWIpO1xyXG4gICAgICAgIC8vaW5zdC5uYW1lID0gXCJUZXN0IENoXCI7XHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIuW8leeUqOexu+WeiyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBsZXQgdGVzdE1hcDpNYXA8c3RyaW5nLEFycmF5PG51bWJlcj4+ID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRlc3RNYXAuc2V0KFwia2V5MVwiICxuZXcgQXJyYXkoKSk7XHJcblxyXG4gICAgICAgIGxldCBhcnIxOkFycmF5PG51bWJlcj4gPSB0ZXN0TWFwLmdldChcImtleTFcIik7XHJcbiAgICAgICAgYXJyMS5wdXNoKDEyKTtcclxuICAgICAgICBhcnIxLnB1c2goMzMzKTtcclxuXHJcbiAgICAgICAgbGV0IGFycjI6QXJyYXk8bnVtYmVyPiA9IHRlc3RNYXAuZ2V0KFwia2V5MVwiKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhhcnIyKTtcclxuXHJcblxyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJGYXJpeUdVSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICAvLyAgbGV0IHBhZ2U6VUlfTG9naW5QYWdlID0gbmV3IFVJX0xvZ2luUGFnZSgpO1xyXG4gICAgICAgIC8vICBDUy5GYWlyeUdVSS5HUm9vdC5pbnN0LkFkZENoaWxkKHBhZ2UuX3VpKTtcclxuICAgICAgICAvLyAgTG9nZ2VyLmxvZyhwYWdlLl91aSk7XHJcblxyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJNb2R1bGVNYW5hZ2VyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICAvLyBNb2R1bGVNYW5hZ2VyLkluc3RhbmNlKE1vZHVsZU1hbmFnZXIpLmNyZWF0ZU1vZHVsZShNb2R1bGVEZWYuTG9naW5Nb2R1bGUsXCJjcmVhdGUgbG9naW5cIik7XHJcblxyXG4gICAgICAgIC8vIE1vZHVsZU1hbmFnZXIuSW5zdGFuY2UoTW9kdWxlTWFuYWdlcikuc2VuZE1lc3NhZ2UoTW9kdWxlRGVmLkxvZ2luTW9kdWxlLCBcInRlc3QxXCIsMjIzMyk7XHJcbiAgICAgICAgLy8gTW9kdWxlTWFuYWdlci5JbnN0YW5jZShNb2R1bGVNYW5hZ2VyKS5zZW5kTWVzc2FnZShNb2R1bGVEZWYuSG9tZU1vZHVsZSwgXCJ0ZXN0MlwiLDIyMzMpO1xyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJ0aGVuIGNyZWF0ZSBIb21lXCIpO1xyXG4gICAgICAgIC8vIE1vZHVsZU1hbmFnZXIuSW5zdGFuY2UoTW9kdWxlTWFuYWdlcikuY3JlYXRlTW9kdWxlKE1vZHVsZURlZi5Ib21lTW9kdWxlLFwiY3JlYXRlIGxvZ2luXCIpO1xyXG4gICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJVSU1hbmFnZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJleGNlbCBkYXRhID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIGxldCBza2lsbE1hcCA9IFNraWxsQ29uZmlnVEIuSW5zdGFuY2UoU2tpbGxDb25maWdUQikudHJzO1xyXG4gICAgICAgIGxldCBza2lsbHRyOlNraWxsQ29uZmlnVFIgPSBza2lsbE1hcC5nZXQoMTAwMyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYCR7c2tpbGx0ci5fTmFtZX0gOiAke3NraWxsdHIuX0F0dGFja1R5cGV9YClcclxuICAgICAgICBsZXQgaW1wYWN0dHlwZSA9IHNraWxsdHIuX0ltcGFjdFR5cGU7XHJcbiAgICAgICAgY29uc29sZS5sb2coaW1wYWN0dHlwZSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJQcm90b2J1ZiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgYzJyTG9naW4gPSB7XHJcbiAgICAgICAgICAgICAgICBcIkFjY291bnRcIiA6IFwidGVzdFwiLFxyXG4gICAgICAgICAgICAgICAgXCJQYXNzd29yZFwiIDogXCIxMjM0XCJcclxuICAgICAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgICAgICAvL+mqjOivgVxyXG4gICAgICAgICAgICBsZXQgdjEgPSBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnkoYzJyTG9naW4pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInZlcmlmeSBwYjogXCIrIHYxKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyUl9Mb2dpbi5jcmVhdGUoYzJyTG9naW4pXHJcbiAgICAgICAgICAgIG1zZy5BY2NvdW50ID0gXCJ0ZXN0MVwiXHJcbiAgICAgICAgICAgIG1zZy5QYXNzd29yZCA9IFwiMTEyMlwiXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZylcclxuXHJcbiAgICAgICAgICAgIGxldCBidWYgPSBuaWNlX3RzLkMyUl9Mb2dpbi5lbmNvZGUobXNnKS5maW5pc2goKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhidWYpXHJcblxyXG4gICAgICAgICAgICBsZXQgZGVfYnVmID0gbmljZV90cy5DMlJfTG9naW4uZGVjb2RlKGJ1ZilcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGVfYnVmLkFjY291bnQpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRlX2J1Zi5QYXNzd29yZClcclxuXHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlVpbnRBcnJheSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgbGV0ICBvcGNvZGVfYXJyID0gbmV3IFVpbnQ4QXJyYXkoWzI1NywyNV0pO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG9wY29kZV9hcnIuc3ViYXJyYXkoMCwxKSk7XHJcbiAgICAgICAgY29uc29sZS5sb2cob3Bjb2RlX2Fyci5sZW5ndGgpO1xyXG5cclxuICAgICAgICBsZXQgb3Bjb2RlX2FycjIgPSBuZXcgVWludDhBcnJheShbMzNdKTtcclxuXHJcbiAgICAgICAgLy/lkIjlubYgVWludDhBcnJheVxyXG4gICAgICAgIGxldCBtZXJnZV9hcnIgPSBuZXcgVWludDhBcnJheShvcGNvZGVfYXJyLmxlbmd0aCArIG9wY29kZV9hcnIyLmxlbmd0aCk7XHJcbiAgICAgICAgbWVyZ2VfYXJyLnNldChvcGNvZGVfYXJyMik7XHJcbiAgICAgICAgbWVyZ2VfYXJyLnNldChvcGNvZGVfYXJyLCBvcGNvZGVfYXJyMi5sZW5ndGgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG1lcmdlX2Fyci5sZW5ndGgpO1xyXG4gICAgIFxyXG4gICAgICAgIGxldCBuOm51bWJlciA9IDU2Nzg7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjpVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcblxyXG4gICAgICAgIC8vIDw8IOW3puenuyAgPj4g5Y+z56e7ICA+Pj4g5peg56ym5Y+35Y+z56e7XHJcbiAgICAgICAgLy9u6L2sdWludDhBcnJheVxyXG4gICAgICAgIGJ1ZmZlclswXSA9IG4gPj4+IDI0O1xyXG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gPj4+IDE2O1xyXG4gICAgICAgIGJ1ZmZlclsyXSA9IG4gPj4+IDg7XHJcbiAgICAgICAgYnVmZmVyWzNdID0gbiAmIDB4ZmY7XHJcblxyXG5cclxuICAgICAgICAvL3VuaXQ4QXJyYXnovaxuXHJcbiAgICAgICAgbiA9IGJ1ZmZlclswXSA8PCAyNCB8IGJ1ZmZlclsxXSA8PCAxNiB8IGJ1ZmZlclsyXSA8PCA4IHwgYnVmZmVyWzNdO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKG4pO1xyXG5cclxuXHJcbiAgICAgICAgbiA9IDMwMDtcclxuICAgICAgICBsZXQgYnVmZmVyMTpVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMik7XHJcbiAgICAgICAgYnVmZmVyMVswXSA9IG4gPj4+IDg7XHJcbiAgICAgICAgYnVmZmVyMVsxXSA9IG4gJiAweGZmO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhidWZmZXIxKTtcclxuICAgICAgICBuID0gYnVmZmVyMVswXTw8OCB8IGJ1ZmZlcjFbMV07XHJcbiAgICAgICAgY29uc29sZS5sb2cobik7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic2xlZXAgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgYXdhaXQgVGltZVV0aWwuc2xlZXAoMTAwMCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzbGVlcCAuLmVuZFwiKTtcclxuXHJcblxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKFwiZmxhdGJ1ZmZlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICAvLyB0cnl7XHJcbiAgICAgICAgLy8gICAgIGxldCBieXRlczpBcnJheUJ1ZmZlciA9IGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFRleHRCeXRlcyhcIkNvbmZpZy9mYi91bml0Y29uZmlnLmJ5dGVzXCIpXHJcbiAgICAgICAgLy8gICAgIGxldCB1bml0Qnl0ZSA9IG5ldyBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKHVuaXRCeXRlKTtcclxuICAgICAgICAvLyAgICAgbGV0IHVuaXRjb25maWc6ZmIudW5pdGNvbmZpZ1RCID0gZmIudW5pdGNvbmZpZ1RCLmdldFJvb3RBc3VuaXRjb25maWdUQih1bml0Qnl0ZSlcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2codW5pdGNvbmZpZy51bml0Y29uZmlnVFJTTGVuZ3RoKCkpO1xyXG4gICAgICAgICAgICBcclxuICAgIFxyXG4gICAgICAgIC8vICAgICBmb3IobGV0IGk9MDsgaTx1bml0Y29uZmlnLnVuaXRjb25maWdUUlNMZW5ndGgoKTsgaSsrKXtcclxuICAgICAgICAvLyAgICAgICAgIGxldCBhID0gIHVuaXRjb25maWcudW5pdGNvbmZpZ1RSUyhpKTtcclxuICAgICAgICAvLyAgICAgICAgIGNvbnNvbGUubG9nKGEuTmFtZSgpKTtcclxuICAgICAgICAvLyAgICAgfVxyXG5cclxuICAgICAgICAvLyB9Y2F0Y2goZXgpe1xyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmVycm9yKGV4KTtcclxuICAgICAgICAvLyB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIua1i+ivlee6oueCueezu+e7nyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgICAgIFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNZXNzYWdlTWFuYWdlcikuYWRkTGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdCxcclxuICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVkIGhpbnRzIGNoYXQuLi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNZXNzYWdlTWFuYWdlcikuYWRkTGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdF9mYW1pbHksXHJcbiAgICAgICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlZCBoaW50cyBjaGF0X2ZhbWlseS4uLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgUmVkSGludHNNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01lc3NhZ2VNYW5hZ2VyKS5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0X3N5c3RlbSxcclxuICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVkIGhpbnRzIGNoYXQuLi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBSZWRIaW50c01hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNYW5hZ2VyKS5zZXRSZWRIaW50T3Blbk9yQ2xvc2UoXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdF9mYW1pbHksIHRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgbGV0IHJfY2hhdCA9IFJlZEhpbnRzTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01hbmFnZXIpLmNoZWNrUmVkSXNPcGVuKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRcclxuICAgICAgICAgICAgKSA7XHJcbiAgICAgICAgICAgIGxldCByX2NoYXRfZmFtaWx5ID0gUmVkSGludHNNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWFuYWdlcikuY2hlY2tSZWRJc09wZW4oXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdF9mYW1pbHlcclxuICAgICAgICAgICAgKSA7XHJcbiAgICAgICAgICAgIGxldCByX2NoYXRfc3lzdGVtID0gUmVkSGludHNNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWFuYWdlcikuY2hlY2tSZWRJc09wZW4oXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdF9zeXN0ZW1cclxuICAgICAgICAgICAgKSA7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJfY2hhdCwgcl9jaGF0X2ZhbWlseSwgcl9jaGF0X3N5c3RlbSlcclxuXHJcbiAgICAgICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkluayBTdG9yeSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcblxyXG4gICAgICAgICAgICB2YXIganNvbiA9IGF3YWl0IChhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRUZXh0QXNzZXQoXCJTdG9yeS9UZXN0U3RvcnkuanNvblwiKSkudGV4dDtcclxuICAgICAgICAgICAgbGV0IHN0b3J5ID0gbmV3IFN0b3J5KGpzb24pO1xyXG4gICAgICAgICAgICBzdG9yeS5DaG9vc2VQYXRoU3RyaW5nKFwic3RvcnkxXCIsIHRydWUpO1xyXG4gICAgICAgICAgICBzdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbihcIkdldENoYXJhY3Rlck5hbWVcIiwoKT0+e1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSnVzdGluIFRlc3RcIjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgc3RvcnkuQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKFwiR2V0Q2hhcmFjdGVyTmFtZUJ5TXV0aVBhcmFtc1wiLChhcmdzOltdKT0+e1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYXJncy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVFRUVFwiO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RvcnkuQ29udGludWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0b3J5LkNvbnRpbnVlKCkpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdG9yeS5Db250aW51ZSgpKTtcclxuICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBcclxuXHJcbn1cclxuXHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNzaGFycFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwdWVydHNcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==