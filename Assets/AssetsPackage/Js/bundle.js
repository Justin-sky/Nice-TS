/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/GameMain.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/inkjs/engine/CallStack.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/CallStack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStack = void 0;
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class CallStack {
    constructor() {
        this._threadCounter = 0;
        this._startOfRoot = Pointer_1.Pointer.Null;
        if (arguments[0] instanceof Story_1.Story) {
            let storyContext = arguments[0];
            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
            this.Reset();
        }
        else {
            let toCopy = arguments[0];
            this._threads = [];
            for (let otherThread of toCopy._threads) {
                this._threads.push(otherThread.Copy());
            }
            this._threadCounter = toCopy._threadCounter;
            this._startOfRoot = toCopy._startOfRoot;
        }
    }
    get elements() {
        return this.callStack;
    }
    get depth() {
        return this.elements.length;
    }
    get currentElement() {
        let thread = this._threads[this._threads.length - 1];
        let cs = thread.callstack;
        return cs[cs.length - 1];
    }
    get currentElementIndex() {
        return this.callStack.length - 1;
    }
    get currentThread() {
        return this._threads[this._threads.length - 1];
    }
    set currentThread(value) {
        Debug_1.Debug.Assert(this._threads.length == 1, "Shouldn't be directly setting the current thread when we have a stack of them");
        this._threads.length = 0;
        this._threads.push(value);
    }
    get canPop() {
        return this.callStack.length > 1;
    }
    Reset() {
        this._threads = [];
        this._threads.push(new CallStack.Thread());
        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));
    }
    SetJsonToken(jObject, storyContext) {
        this._threads.length = 0;
        // TODO: (List<object>) jObject ["threads"];
        let jThreads = jObject["threads"];
        for (let jThreadTok of jThreads) {
            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;
            let jThreadObj = jThreadTok;
            let thread = new CallStack.Thread(jThreadObj, storyContext);
            this._threads.push(thread);
        }
        // TODO: (int)jObject ["threadCounter"];
        this._threadCounter = parseInt(jObject["threadCounter"]);
        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
    }
    WriteJson(w) {
        w.WriteObject((writer) => {
            writer.WritePropertyStart("threads");
            writer.WriteArrayStart();
            for (let thread of this._threads) {
                thread.WriteJson(writer);
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WritePropertyStart("threadCounter");
            writer.WriteInt(this._threadCounter);
            writer.WritePropertyEnd();
        });
    }
    PushThread() {
        let newThread = this.currentThread.Copy();
        this._threadCounter++;
        newThread.threadIndex = this._threadCounter;
        this._threads.push(newThread);
    }
    ForkThread() {
        let forkedThread = this.currentThread.Copy();
        this._threadCounter++;
        forkedThread.threadIndex = this._threadCounter;
        return forkedThread;
    }
    PopThread() {
        if (this.canPopThread) {
            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()
        }
        else {
            throw new Error("Can't pop thread");
        }
    }
    get canPopThread() {
        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;
    }
    get elementIsEvaluateFromGame() {
        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;
    }
    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {
        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);
        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;
        element.functionStartInOutputStream = outputStreamLengthWithPushed;
        this.callStack.push(element);
    }
    CanPop(type = null) {
        if (!this.canPop)
            return false;
        if (type == null)
            return true;
        return this.currentElement.type == type;
    }
    Pop(type = null) {
        if (this.CanPop(type)) {
            this.callStack.pop();
            return;
        }
        else {
            throw new Error("Mismatched push/pop in Callstack");
        }
    }
    GetTemporaryVariableWithName(name, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        let varValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (varValue.exists) {
            return varValue.result;
        }
        else {
            return null;
        }
    }
    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        if (!declareNew && !contextElement.temporaryVariables.get(name)) {
            throw new StoryException_1.StoryException("Could not find temporary variable to set: " + name);
        }
        let oldValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (oldValue.exists)
            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        contextElement.temporaryVariables.set(name, value);
    }
    ContextForVariableNamed(name) {
        if (this.currentElement.temporaryVariables.get(name)) {
            return this.currentElementIndex + 1;
        }
        else {
            return 0;
        }
    }
    ThreadWithIndex(index) {
        let filtered = this._threads.filter((t) => {
            if (t.threadIndex == index)
                return t;
        });
        return filtered.length > 0 ? filtered[0] : null;
    }
    get callStack() {
        return this.currentThread.callstack;
    }
    get callStackTrace() {
        let sb = new StringBuilder_1.StringBuilder();
        for (let t = 0; t < this._threads.length; t++) {
            let thread = this._threads[t];
            let isCurrent = t == this._threads.length - 1;
            sb.AppendFormat("=== THREAD {0}/{1} {2}===\n", t + 1, this._threads.length, isCurrent ? "(current) " : "");
            for (let i = 0; i < thread.callstack.length; i++) {
                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)
                    sb.Append("  [FUNCTION] ");
                else
                    sb.Append("  [TUNNEL] ");
                let pointer = thread.callstack[i].currentPointer;
                if (!pointer.isNull) {
                    sb.Append("<SOMEWHERE IN ");
                    if (pointer.container === null) {
                        return NullException_1.throwNullException("pointer.container");
                    }
                    sb.Append(pointer.container.path.toString());
                    sb.AppendLine(">");
                }
            }
        }
        return sb.toString();
    }
}
exports.CallStack = CallStack;
(function (CallStack) {
    class Element {
        constructor(type, pointer, inExpressionEvaluation = false) {
            this.evaluationStackHeightWhenPushed = 0;
            this.functionStartInOutputStream = 0;
            this.currentPointer = pointer.copy();
            this.inExpressionEvaluation = inExpressionEvaluation;
            this.temporaryVariables = new Map();
            this.type = type;
        }
        Copy() {
            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);
            copy.temporaryVariables = new Map(this.temporaryVariables);
            copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;
            copy.functionStartInOutputStream = this.functionStartInOutputStream;
            return copy;
        }
    }
    CallStack.Element = Element;
    class Thread {
        constructor() {
            this.threadIndex = 0;
            this.previousPointer = Pointer_1.Pointer.Null;
            this.callstack = [];
            if (arguments[0] && arguments[1]) {
                let jThreadObj = arguments[0];
                let storyContext = arguments[1];
                // TODO: (int) jThreadObj['threadIndex'] can raise;
                this.threadIndex = parseInt(jThreadObj["threadIndex"]);
                let jThreadCallstack = jThreadObj["callstack"];
                for (let jElTok of jThreadCallstack) {
                    let jElementObj = jElTok;
                    // TODO: (int) jElementObj['type'] can raise;
                    let pushPopType = parseInt(jElementObj["type"]);
                    let pointer = Pointer_1.Pointer.Null;
                    let currentContainerPathStr;
                    // TODO: jElementObj.TryGetValue ("cPath", out currentContainerPathStrToken);
                    let currentContainerPathStrToken = jElementObj["cPath"];
                    if (typeof currentContainerPathStrToken !== "undefined") {
                        currentContainerPathStr = currentContainerPathStrToken.toString();
                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));
                        pointer.container = threadPointerResult.container;
                        pointer.index = parseInt(jElementObj["idx"]);
                        if (threadPointerResult.obj == null)
                            throw new Error("When loading state, internal story location couldn't be found: " +
                                currentContainerPathStr +
                                ". Has the story changed since this save data was created?");
                        else if (threadPointerResult.approximate) {
                            if (pointer.container === null) {
                                return NullException_1.throwNullException("pointer.container");
                            }
                            storyContext.Warning("When loading state, exact internal story location couldn't be found: '" +
                                currentContainerPathStr +
                                "', so it was approximated to '" +
                                pointer.container.path.toString() +
                                "' to recover. Has the story changed since this save data was created?");
                        }
                    }
                    let inExpressionEvaluation = !!jElementObj["exp"];
                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);
                    let temps = jElementObj["temp"];
                    if (typeof temps !== "undefined") {
                        el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);
                    }
                    else {
                        el.temporaryVariables.clear();
                    }
                    this.callstack.push(el);
                }
                let prevContentObjPath = jThreadObj["previousContentObject"];
                if (typeof prevContentObjPath !== "undefined") {
                    let prevPath = new Path_1.Path(prevContentObjPath.toString());
                    this.previousPointer = storyContext.PointerAtPath(prevPath);
                }
            }
        }
        Copy() {
            let copy = new Thread();
            copy.threadIndex = this.threadIndex;
            for (let e of this.callstack) {
                copy.callstack.push(e.Copy());
            }
            copy.previousPointer = this.previousPointer.copy();
            return copy;
        }
        WriteJson(writer) {
            writer.WriteObjectStart();
            writer.WritePropertyStart("callstack");
            writer.WriteArrayStart();
            for (let el of this.callstack) {
                writer.WriteObjectStart();
                if (!el.currentPointer.isNull) {
                    if (el.currentPointer.container === null) {
                        return NullException_1.throwNullException("el.currentPointer.container");
                    }
                    writer.WriteProperty("cPath", el.currentPointer.container.path.componentsString);
                    writer.WriteIntProperty("idx", el.currentPointer.index);
                }
                writer.WriteProperty("exp", el.inExpressionEvaluation);
                writer.WriteIntProperty("type", el.type);
                if (el.temporaryVariables.size > 0) {
                    writer.WritePropertyStart("temp");
                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);
                    writer.WritePropertyEnd();
                }
                writer.WriteObjectEnd();
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WriteIntProperty("threadIndex", this.threadIndex);
            if (!this.previousPointer.isNull) {
                let resolvedPointer = this.previousPointer.Resolve();
                if (resolvedPointer === null) {
                    return NullException_1.throwNullException("this.previousPointer.Resolve()");
                }
                writer.WriteProperty("previousContentObject", resolvedPointer.path.toString());
            }
            writer.WriteObjectEnd();
        }
    }
    CallStack.Thread = Thread;
})(CallStack = exports.CallStack || (exports.CallStack = {}));
//# sourceMappingURL=CallStack.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Choice.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Choice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Choice = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Choice extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.text = "";
        this.index = 0;
        this.threadAtGeneration = null;
        this.sourcePath = "";
        this.targetPath = null;
        this.isInvisibleDefault = false;
        this.originalThreadIndex = 0;
    }
    get pathStringOnChoice() {
        if (this.targetPath === null)
            return NullException_1.throwNullException("Choice.targetPath");
        return this.targetPath.toString();
    }
    set pathStringOnChoice(value) {
        this.targetPath = new Path_1.Path(value);
    }
}
exports.Choice = Choice;
//# sourceMappingURL=Choice.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ChoicePoint.js":
/*!**************************************************!*\
  !*** ./node_modules/inkjs/engine/ChoicePoint.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoicePoint = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ChoicePoint extends Object_1.InkObject {
    constructor(onceOnly = true) {
        super();
        this._pathOnChoice = null;
        this.hasCondition = false;
        this.hasStartContent = false;
        this.hasChoiceOnlyContent = false;
        this.isInvisibleDefault = false;
        this.onceOnly = true;
        this.onceOnly = onceOnly;
    }
    get pathOnChoice() {
        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {
            let choiceTargetObj = this.choiceTarget;
            if (choiceTargetObj) {
                this._pathOnChoice = choiceTargetObj.path;
            }
        }
        return this._pathOnChoice;
    }
    set pathOnChoice(value) {
        this._pathOnChoice = value;
    }
    get choiceTarget() {
        if (this._pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint._pathOnChoice");
        return this.ResolvePath(this._pathOnChoice).container;
    }
    get pathStringOnChoice() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        return this.CompactPathString(this.pathOnChoice);
    }
    set pathStringOnChoice(value) {
        this.pathOnChoice = new Path_1.Path(value);
    }
    get flags() {
        let flags = 0;
        if (this.hasCondition)
            flags |= 1;
        if (this.hasStartContent)
            flags |= 2;
        if (this.hasChoiceOnlyContent)
            flags |= 4;
        if (this.isInvisibleDefault)
            flags |= 8;
        if (this.onceOnly)
            flags |= 16;
        return flags;
    }
    set flags(value) {
        this.hasCondition = (value & 1) > 0;
        this.hasStartContent = (value & 2) > 0;
        this.hasChoiceOnlyContent = (value & 4) > 0;
        this.isInvisibleDefault = (value & 8) > 0;
        this.onceOnly = (value & 16) > 0;
    }
    toString() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);
        let targetLineNum = null;
        let targetString = this.pathOnChoice.toString();
        if (targetLineNum != null) {
            targetString = " line " + targetLineNum + "(" + targetString + ")";
        }
        return "Choice: -> " + targetString;
    }
}
exports.ChoicePoint = ChoicePoint;
//# sourceMappingURL=ChoicePoint.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Container.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/Container.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const SearchResult_1 = __webpack_require__(/*! ./SearchResult */ "./node_modules/inkjs/engine/SearchResult.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
class Container extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.name = "";
        this._content = [];
        this.namedContent = new Map();
        this.visitsShouldBeCounted = false;
        this.turnIndexShouldBeCounted = false;
        this.countingAtStartOnly = false;
        this._pathToFirstLeafContent = null;
    }
    get hasValidName() {
        return this.name != null && this.name.length > 0;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this.AddContent(value);
    }
    get namedOnlyContent() {
        let namedOnlyContentDict = new Map();
        for (let [key, value] of this.namedContent) {
            let inkObject = TypeAssertion_1.asOrThrows(value, Object_1.InkObject);
            namedOnlyContentDict.set(key, inkObject);
        }
        for (let c of this.content) {
            let named = TypeAssertion_1.asINamedContentOrNull(c);
            if (named != null && named.hasValidName) {
                namedOnlyContentDict.delete(named.name);
            }
        }
        if (namedOnlyContentDict.size == 0)
            namedOnlyContentDict = null;
        return namedOnlyContentDict;
    }
    set namedOnlyContent(value) {
        let existingNamedOnly = this.namedOnlyContent;
        if (existingNamedOnly != null) {
            for (let [key] of existingNamedOnly) {
                this.namedContent.delete(key);
            }
        }
        if (value == null)
            return;
        for (let [, val] of value) {
            let named = TypeAssertion_1.asINamedContentOrNull(val);
            if (named != null)
                this.AddToNamedContentOnly(named);
        }
    }
    get countFlags() {
        let flags = 0;
        if (this.visitsShouldBeCounted)
            flags |= Container.CountFlags.Visits;
        if (this.turnIndexShouldBeCounted)
            flags |= Container.CountFlags.Turns;
        if (this.countingAtStartOnly)
            flags |= Container.CountFlags.CountStartOnly;
        if (flags == Container.CountFlags.CountStartOnly) {
            flags = 0;
        }
        return flags;
    }
    set countFlags(value) {
        let flag = value;
        if ((flag & Container.CountFlags.Visits) > 0)
            this.visitsShouldBeCounted = true;
        if ((flag & Container.CountFlags.Turns) > 0)
            this.turnIndexShouldBeCounted = true;
        if ((flag & Container.CountFlags.CountStartOnly) > 0)
            this.countingAtStartOnly = true;
    }
    get pathToFirstLeafContent() {
        if (this._pathToFirstLeafContent == null)
            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);
        return this._pathToFirstLeafContent;
    }
    get internalPathToFirstLeafContent() {
        let components = [];
        let container = this;
        while (container instanceof Container) {
            if (container.content.length > 0) {
                components.push(new Path_1.Path.Component(0));
                container = container.content[0];
            }
        }
        return new Path_1.Path(components);
    }
    AddContent(contentObjOrList) {
        if (contentObjOrList instanceof Array) {
            let contentList = contentObjOrList;
            for (let c of contentList) {
                this.AddContent(c);
            }
        }
        else {
            let contentObj = contentObjOrList;
            this._content.push(contentObj);
            if (contentObj.parent) {
                throw new Error("content is already in " + contentObj.parent);
            }
            contentObj.parent = this;
            this.TryAddNamedContent(contentObj);
        }
    }
    TryAddNamedContent(contentObj) {
        let namedContentObj = TypeAssertion_1.asINamedContentOrNull(contentObj);
        if (namedContentObj != null && namedContentObj.hasValidName) {
            this.AddToNamedContentOnly(namedContentObj);
        }
    }
    AddToNamedContentOnly(namedContentObj) {
        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, "Can only add Runtime.Objects to a Runtime.Container");
        let runtimeObj = TypeAssertion_1.asOrThrows(namedContentObj, Object_1.InkObject);
        runtimeObj.parent = this;
        this.namedContent.set(namedContentObj.name, namedContentObj);
    }
    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {
        if (partialPathLength == -1)
            partialPathLength = path.length;
        let result = new SearchResult_1.SearchResult();
        result.approximate = false;
        let currentContainer = this;
        let currentObj = this;
        for (let i = partialPathStart; i < partialPathLength; ++i) {
            let comp = path.GetComponent(i);
            if (currentContainer == null) {
                result.approximate = true;
                break;
            }
            let foundObj = currentContainer.ContentWithPathComponent(comp);
            if (foundObj == null) {
                result.approximate = true;
                break;
            }
            currentObj = foundObj;
            currentContainer = TypeAssertion_1.asOrNull(foundObj, Container);
        }
        result.obj = currentObj;
        return result;
    }
    InsertContent(contentObj, index) {
        this.content[index] = contentObj;
        if (contentObj.parent) {
            throw new Error("content is already in " + contentObj.parent);
        }
        contentObj.parent = this;
        this.TryAddNamedContent(contentObj);
    }
    AddContentsOfContainer(otherContainer) {
        this.content = this.content.concat(otherContainer.content);
        for (let obj of otherContainer.content) {
            obj.parent = this;
            this.TryAddNamedContent(obj);
        }
    }
    ContentWithPathComponent(component) {
        if (component.isIndex) {
            if (component.index >= 0 && component.index < this.content.length) {
                return this.content[component.index];
            }
            else {
                return null;
            }
        }
        else if (component.isParent) {
            return this.parent;
        }
        else {
            if (component.name === null) {
                return NullException_1.throwNullException("component.name");
            }
            let foundContent = TryGetResult_1.tryGetValueFromMap(this.namedContent, component.name, null);
            if (foundContent.exists) {
                return TypeAssertion_1.asOrThrows(foundContent.result, Object_1.InkObject);
            }
            else {
                return null;
            }
        }
    }
    BuildStringOfHierarchy() {
        let sb;
        if (arguments.length == 0) {
            sb = new StringBuilder_1.StringBuilder();
            this.BuildStringOfHierarchy(sb, 0, null);
            return sb.toString();
        }
        sb = arguments[0];
        let indentation = arguments[1];
        let pointedObj = arguments[2];
        function appendIndentation() {
            const spacesPerIndent = 4; // Truly const in the original code
            for (let i = 0; i < spacesPerIndent * indentation; ++i) {
                sb.Append(" ");
            }
        }
        appendIndentation();
        sb.Append("[");
        if (this.hasValidName) {
            sb.AppendFormat(" ({0})", this.name);
        }
        if (this == pointedObj) {
            sb.Append("  <---");
        }
        sb.AppendLine();
        indentation++;
        for (let i = 0; i < this.content.length; ++i) {
            let obj = this.content[i];
            if (obj instanceof Container) {
                let container = obj;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
            }
            else {
                appendIndentation();
                if (obj instanceof Value_1.StringValue) {
                    sb.Append('"');
                    sb.Append(obj.toString().replace("\n", "\\n"));
                    sb.Append('"');
                }
                else {
                    sb.Append(obj.toString());
                }
            }
            if (i != this.content.length - 1) {
                sb.Append(",");
            }
            if (!(obj instanceof Container) && obj == pointedObj) {
                sb.Append("  <---");
            }
            sb.AppendLine();
        }
        let onlyNamed = new Map();
        for (let [key, value] of this.namedContent) {
            if (this.content.indexOf(TypeAssertion_1.asOrThrows(value, Object_1.InkObject)) >= 0) {
                continue;
            }
            else {
                onlyNamed.set(key, value);
            }
        }
        if (onlyNamed.size > 0) {
            appendIndentation();
            sb.AppendLine("-- named: --");
            for (let [, value] of onlyNamed) {
                Debug_1.Debug.AssertType(value, Container, "Can only print out named Containers");
                let container = value;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
                sb.AppendLine();
            }
        }
        indentation--;
        appendIndentation();
        sb.Append("]");
    }
}
exports.Container = Container;
(function (Container) {
    let CountFlags;
    (function (CountFlags) {
        CountFlags[CountFlags["Visits"] = 1] = "Visits";
        CountFlags[CountFlags["Turns"] = 2] = "Turns";
        CountFlags[CountFlags["CountStartOnly"] = 4] = "CountStartOnly";
    })(CountFlags = Container.CountFlags || (Container.CountFlags = {}));
})(Container = exports.Container || (exports.Container = {}));
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ControlCommand.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ControlCommand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlCommand = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class ControlCommand extends Object_1.InkObject {
    constructor(commandType = ControlCommand.CommandType.NotSet) {
        super();
        this._commandType = commandType;
    }
    get commandType() {
        return this._commandType;
    }
    Copy() {
        return new ControlCommand(this.commandType);
    }
    static EvalStart() {
        return new ControlCommand(ControlCommand.CommandType.EvalStart);
    }
    static EvalOutput() {
        return new ControlCommand(ControlCommand.CommandType.EvalOutput);
    }
    static EvalEnd() {
        return new ControlCommand(ControlCommand.CommandType.EvalEnd);
    }
    static Duplicate() {
        return new ControlCommand(ControlCommand.CommandType.Duplicate);
    }
    static PopEvaluatedValue() {
        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);
    }
    static PopFunction() {
        return new ControlCommand(ControlCommand.CommandType.PopFunction);
    }
    static PopTunnel() {
        return new ControlCommand(ControlCommand.CommandType.PopTunnel);
    }
    static BeginString() {
        return new ControlCommand(ControlCommand.CommandType.BeginString);
    }
    static EndString() {
        return new ControlCommand(ControlCommand.CommandType.EndString);
    }
    static NoOp() {
        return new ControlCommand(ControlCommand.CommandType.NoOp);
    }
    static ChoiceCount() {
        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);
    }
    static Turns() {
        return new ControlCommand(ControlCommand.CommandType.Turns);
    }
    static TurnsSince() {
        return new ControlCommand(ControlCommand.CommandType.TurnsSince);
    }
    static ReadCount() {
        return new ControlCommand(ControlCommand.CommandType.ReadCount);
    }
    static Random() {
        return new ControlCommand(ControlCommand.CommandType.Random);
    }
    static SeedRandom() {
        return new ControlCommand(ControlCommand.CommandType.SeedRandom);
    }
    static VisitIndex() {
        return new ControlCommand(ControlCommand.CommandType.VisitIndex);
    }
    static SequenceShuffleIndex() {
        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);
    }
    static StartThread() {
        return new ControlCommand(ControlCommand.CommandType.StartThread);
    }
    static Done() {
        return new ControlCommand(ControlCommand.CommandType.Done);
    }
    static End() {
        return new ControlCommand(ControlCommand.CommandType.End);
    }
    static ListFromInt() {
        return new ControlCommand(ControlCommand.CommandType.ListFromInt);
    }
    static ListRange() {
        return new ControlCommand(ControlCommand.CommandType.ListRange);
    }
    static ListRandom() {
        return new ControlCommand(ControlCommand.CommandType.ListRandom);
    }
    toString() {
        return this.commandType.toString();
    }
}
exports.ControlCommand = ControlCommand;
(function (ControlCommand) {
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["NotSet"] = -1] = "NotSet";
        CommandType[CommandType["EvalStart"] = 0] = "EvalStart";
        CommandType[CommandType["EvalOutput"] = 1] = "EvalOutput";
        CommandType[CommandType["EvalEnd"] = 2] = "EvalEnd";
        CommandType[CommandType["Duplicate"] = 3] = "Duplicate";
        CommandType[CommandType["PopEvaluatedValue"] = 4] = "PopEvaluatedValue";
        CommandType[CommandType["PopFunction"] = 5] = "PopFunction";
        CommandType[CommandType["PopTunnel"] = 6] = "PopTunnel";
        CommandType[CommandType["BeginString"] = 7] = "BeginString";
        CommandType[CommandType["EndString"] = 8] = "EndString";
        CommandType[CommandType["NoOp"] = 9] = "NoOp";
        CommandType[CommandType["ChoiceCount"] = 10] = "ChoiceCount";
        CommandType[CommandType["Turns"] = 11] = "Turns";
        CommandType[CommandType["TurnsSince"] = 12] = "TurnsSince";
        CommandType[CommandType["Random"] = 13] = "Random";
        CommandType[CommandType["SeedRandom"] = 14] = "SeedRandom";
        CommandType[CommandType["VisitIndex"] = 15] = "VisitIndex";
        CommandType[CommandType["SequenceShuffleIndex"] = 16] = "SequenceShuffleIndex";
        CommandType[CommandType["StartThread"] = 17] = "StartThread";
        CommandType[CommandType["Done"] = 18] = "Done";
        CommandType[CommandType["End"] = 19] = "End";
        CommandType[CommandType["ListFromInt"] = 20] = "ListFromInt";
        CommandType[CommandType["ListRange"] = 21] = "ListRange";
        CommandType[CommandType["ListRandom"] = 22] = "ListRandom";
        CommandType[CommandType["ReadCount"] = 23] = "ReadCount";
        CommandType[CommandType["TOTAL_VALUES"] = 24] = "TOTAL_VALUES";
    })(CommandType = ControlCommand.CommandType || (ControlCommand.CommandType = {}));
})(ControlCommand = exports.ControlCommand || (exports.ControlCommand = {}));
//# sourceMappingURL=ControlCommand.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Debug.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Debug.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Debug = void 0;
var Debug;
(function (Debug) {
    function AssertType(variable, type, message) {
        Assert(variable instanceof type, message);
    }
    Debug.AssertType = AssertType;
    function Assert(condition, message) {
        if (!condition) {
            if (typeof message !== "undefined") {
                console.warn(message);
            }
            if (console.trace) {
                console.trace();
            }
            throw new Error("");
        }
    }
    Debug.Assert = Assert;
})(Debug = exports.Debug || (exports.Debug = {}));
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Divert.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Divert.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Divert = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class Divert extends Object_1.InkObject {
    constructor(stackPushType) {
        super();
        this._targetPath = null;
        this._targetPointer = Pointer_1.Pointer.Null;
        this.variableDivertName = null;
        this.pushesToStack = false;
        this.stackPushType = 0;
        this.isExternal = false;
        this.externalArgs = 0;
        this.isConditional = false;
        this.pushesToStack = false;
        if (typeof stackPushType !== "undefined") {
            this.pushesToStack = true;
            this.stackPushType = stackPushType;
        }
    }
    get targetPath() {
        if (this._targetPath != null && this._targetPath.isRelative) {
            let targetObj = this.targetPointer.Resolve();
            if (targetObj) {
                this._targetPath = targetObj.path;
            }
        }
        return this._targetPath;
    }
    set targetPath(value) {
        this._targetPath = value;
        this._targetPointer = Pointer_1.Pointer.Null;
    }
    get targetPointer() {
        if (this._targetPointer.isNull) {
            let targetObj = this.ResolvePath(this._targetPath).obj;
            if (this._targetPath === null)
                return NullException_1.throwNullException("this._targetPath");
            if (this._targetPath.lastComponent === null)
                return NullException_1.throwNullException("this._targetPath.lastComponent");
            if (this._targetPath.lastComponent.isIndex) {
                if (targetObj === null)
                    return NullException_1.throwNullException("targetObj");
                this._targetPointer.container =
                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;
                this._targetPointer.index = this._targetPath.lastComponent.index;
            }
            else {
                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);
            }
        }
        return this._targetPointer.copy();
    }
    get targetPathString() {
        if (this.targetPath == null)
            return null;
        return this.CompactPathString(this.targetPath);
    }
    set targetPathString(value) {
        if (value == null) {
            this.targetPath = null;
        }
        else {
            this.targetPath = new Path_1.Path(value);
        }
    }
    get hasVariableTarget() {
        return this.variableDivertName != null;
    }
    Equals(obj) {
        let otherDivert = obj;
        if (otherDivert instanceof Divert) {
            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {
                if (this.hasVariableTarget) {
                    return this.variableDivertName == otherDivert.variableDivertName;
                }
                else {
                    if (this.targetPath === null)
                        return NullException_1.throwNullException("this.targetPath");
                    return this.targetPath.Equals(otherDivert.targetPath);
                }
            }
        }
        return false;
    }
    toString() {
        if (this.hasVariableTarget) {
            return "Divert(variable: " + this.variableDivertName + ")";
        }
        else if (this.targetPath == null) {
            return "Divert(null)";
        }
        else {
            let sb = new StringBuilder_1.StringBuilder();
            let targetStr = this.targetPath.toString();
            // int? targetLineNum = DebugLineNumberOfPath (targetPath);
            let targetLineNum = null;
            if (targetLineNum != null) {
                targetStr = "line " + targetLineNum;
            }
            sb.Append("Divert");
            if (this.isConditional)
                sb.Append("?");
            if (this.pushesToStack) {
                if (this.stackPushType == PushPop_1.PushPopType.Function) {
                    sb.Append(" function");
                }
                else {
                    sb.Append(" tunnel");
                }
            }
            sb.Append(" -> ");
            sb.Append(this.targetPathString);
            sb.Append(" (");
            sb.Append(targetStr);
            sb.Append(")");
            return sb.toString();
        }
    }
}
exports.Divert = Divert;
//# sourceMappingURL=Divert.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Glue.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Glue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Glue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Glue extends Object_1.InkObject {
    toString() {
        return "Glue";
    }
}
exports.Glue = Glue;
//# sourceMappingURL=Glue.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/InkList.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/InkList.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkList = exports.InkListItem = void 0;
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
class InkListItem {
    constructor() {
        // InkListItem is a struct
        this.originName = null;
        this.itemName = null;
        if (typeof arguments[1] !== "undefined") {
            let originName = arguments[0];
            let itemName = arguments[1];
            this.originName = originName;
            this.itemName = itemName;
        }
        else if (arguments[0]) {
            let fullName = arguments[0];
            let nameParts = fullName.toString().split(".");
            this.originName = nameParts[0];
            this.itemName = nameParts[1];
        }
    }
    static get Null() {
        return new InkListItem(null, null);
    }
    get isNull() {
        return this.originName == null && this.itemName == null;
    }
    get fullName() {
        return ((this.originName !== null ? this.originName : "?") + "." + this.itemName);
    }
    toString() {
        return this.fullName;
    }
    Equals(obj) {
        if (obj instanceof InkListItem) {
            let otherItem = obj;
            return (otherItem.itemName == this.itemName &&
                otherItem.originName == this.originName);
        }
        return false;
    }
    // These methods did not exist in the original C# code. Their purpose is to
    // make `InkListItem` mimics the value-type semantics of the original
    // struct. Please refer to the end of this file, for a more in-depth
    // explanation.
    /**
     * Returns a shallow clone of the current instance.
     */
    copy() {
        return new InkListItem(this.originName, this.itemName);
    }
    /**
     * Returns a `SerializedInkListItem` representing the current
     * instance. The result is intended to be used as a key inside a Map.
     */
    serialized() {
        // We are simply using a JSON representation as a value-typed key.
        return JSON.stringify({
            originName: this.originName,
            itemName: this.itemName,
        });
    }
    /**
     * Reconstructs a `InkListItem` from the given SerializedInkListItem.
     */
    static fromSerializedKey(key) {
        let obj = JSON.parse(key);
        if (!InkListItem.isLikeInkListItem(obj))
            return InkListItem.Null;
        let inkListItem = obj;
        return new InkListItem(inkListItem.originName, inkListItem.itemName);
    }
    /**
     * Determines whether the given item is sufficiently `InkListItem`-like
     * to be used as a template when reconstructing the InkListItem.
     */
    static isLikeInkListItem(item) {
        if (typeof item !== "object")
            return false;
        if (!item.hasOwnProperty("originName") || !item.hasOwnProperty("itemName"))
            return false;
        if (typeof item.originName !== "string" && typeof item.originName !== null)
            return false;
        if (typeof item.itemName !== "string" && typeof item.itemName !== null)
            return false;
        return true;
    }
}
exports.InkListItem = InkListItem;
class InkList extends Map {
    constructor() {
        // Trying to be smart here, this emulates the constructor inheritance found
        // in the original code, but only if otherList is an InkList. IIFE FTW.
        super((() => {
            if (arguments[0] instanceof InkList) {
                return arguments[0];
            }
            else {
                return [];
            }
        })());
        this.origins = null;
        this._originNames = [];
        if (arguments[0] instanceof InkList) {
            let otherList = arguments[0];
            if (otherList._originNames) {
                this._originNames = otherList._originNames.slice();
            }
        }
        else if (typeof arguments[0] === "string") {
            let singleOriginListName = arguments[0];
            let originStory = arguments[1]; /* as Story */
            this.SetInitialOriginName(singleOriginListName);
            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);
            if (def.exists) {
                this.origins = [def.result];
            }
            else {
                throw new Error("InkList origin could not be found in story when constructing new list: " +
                    singleOriginListName);
            }
        }
        else if (typeof arguments[0] === "object" &&
            arguments[0].hasOwnProperty("Key") &&
            arguments[0].hasOwnProperty("Value")) {
            let singleElement = arguments[0];
            this.Add(singleElement.Key, singleElement.Value);
        }
    }
    AddItem(itemOrItemName) {
        if (itemOrItemName instanceof InkListItem) {
            let item = itemOrItemName;
            if (item.originName == null) {
                this.AddItem(item.itemName);
                return;
            }
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (origin.name == item.originName) {
                    let intVal = origin.TryGetValueForItem(item, 0);
                    if (intVal.exists) {
                        this.Add(item, intVal.result);
                        return;
                    }
                    else {
                        throw new Error("Could not add the item " +
                            item +
                            " to this list because it doesn't exist in the original list definition in ink.");
                    }
                }
            }
            throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.");
        }
        else {
            let itemName = itemOrItemName;
            let foundListDef = null;
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (itemName === null)
                    return NullException_1.throwNullException("itemName");
                if (origin.ContainsItemWithName(itemName)) {
                    if (foundListDef != null) {
                        throw new Error("Could not add the item " +
                            itemName +
                            " to this list because it could come from either " +
                            origin.name +
                            " or " +
                            foundListDef.name);
                    }
                    else {
                        foundListDef = origin;
                    }
                }
            }
            if (foundListDef == null)
                throw new Error("Could not add the item " +
                    itemName +
                    " to this list because it isn't known to any list definitions previously associated with this list.");
            let item = new InkListItem(foundListDef.name, itemName);
            let itemVal = foundListDef.ValueForItem(item);
            this.Add(item, itemVal);
        }
    }
    ContainsItemNamed(itemName) {
        for (let [key] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (item.itemName == itemName)
                return true;
        }
        return false;
    }
    ContainsKey(key) {
        return this.has(key.serialized());
    }
    Add(key, value) {
        let serializedKey = key.serialized();
        if (this.has(serializedKey)) {
            // Throw an exception to match the C# behavior.
            throw new Error(`The Map already contains an entry for ${key}`);
        }
        this.set(serializedKey, value);
    }
    Remove(key) {
        return this.delete(key.serialized());
    }
    get Count() {
        return this.size;
    }
    get originOfMaxItem() {
        if (this.origins == null)
            return null;
        let maxOriginName = this.maxItem.Key.originName;
        let result = null;
        this.origins.every((origin) => {
            if (origin.name == maxOriginName) {
                result = origin;
                return false;
            }
            else
                return true;
        });
        return result;
    }
    get originNames() {
        if (this.Count > 0) {
            if (this._originNames == null && this.Count > 0)
                this._originNames = [];
            else {
                if (!this._originNames)
                    this._originNames = [];
                this._originNames.length = 0;
            }
            for (let [key] of this) {
                let item = InkListItem.fromSerializedKey(key);
                if (item.originName === null)
                    return NullException_1.throwNullException("item.originName");
                this._originNames.push(item.originName);
            }
        }
        return this._originNames;
    }
    SetInitialOriginName(initialOriginName) {
        this._originNames = [initialOriginName];
    }
    SetInitialOriginNames(initialOriginNames) {
        if (initialOriginNames == null)
            this._originNames = null;
        else
            this._originNames = initialOriginNames.slice(); // store a copy
    }
    get maxItem() {
        let max = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (max.Key.isNull || value > max.Value)
                max = { Key: item, Value: value };
        }
        return max;
    }
    get minItem() {
        let min = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (min.Key.isNull || value < min.Value) {
                min = { Key: item, Value: value };
            }
        }
        return min;
    }
    get inverse() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    if (!this.ContainsKey(item))
                        list.Add(item, value);
                }
            }
        }
        return list;
    }
    get all() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    list.set(item.serialized(), value);
                }
            }
        }
        return list;
    }
    Union(otherList) {
        let union = new InkList(this);
        for (let [key, value] of otherList) {
            union.set(key, value);
        }
        return union;
    }
    Intersect(otherList) {
        let intersection = new InkList();
        for (let [key, value] of this) {
            if (otherList.has(key))
                intersection.set(key, value);
        }
        return intersection;
    }
    Without(listToRemove) {
        let result = new InkList(this);
        for (let [key] of listToRemove) {
            result.delete(key);
        }
        return result;
    }
    Contains(otherList) {
        for (let [key] of otherList) {
            if (!this.has(key))
                return false;
        }
        return true;
    }
    GreaterThan(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return this.minItem.Value > otherList.maxItem.Value;
    }
    GreaterThanOrEquals(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return (this.minItem.Value >= otherList.minItem.Value &&
            this.maxItem.Value >= otherList.maxItem.Value);
    }
    LessThan(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return this.maxItem.Value < otherList.minItem.Value;
    }
    LessThanOrEquals(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return (this.maxItem.Value <= otherList.maxItem.Value &&
            this.minItem.Value <= otherList.minItem.Value);
    }
    MaxAsList() {
        if (this.Count > 0)
            return new InkList(this.maxItem);
        else
            return new InkList();
    }
    MinAsList() {
        if (this.Count > 0)
            return new InkList(this.minItem);
        else
            return new InkList();
    }
    ListWithSubRange(minBound, maxBound) {
        if (this.Count == 0)
            return new InkList();
        let ordered = this.orderedItems;
        let minValue = 0;
        let maxValue = Number.MAX_SAFE_INTEGER;
        if (Number.isInteger(minBound)) {
            minValue = minBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                minValue = minBound.minItem.Value;
        }
        if (Number.isInteger(maxBound)) {
            maxValue = maxBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                maxValue = maxBound.maxItem.Value;
        }
        let subList = new InkList();
        subList.SetInitialOriginNames(this.originNames);
        for (let item of ordered) {
            if (item.Value >= minValue && item.Value <= maxValue) {
                subList.Add(item.Key, item.Value);
            }
        }
        return subList;
    }
    Equals(otherInkList) {
        if (otherInkList instanceof InkList === false)
            return false;
        if (otherInkList.Count != this.Count)
            return false;
        for (let [key] of this) {
            if (!otherInkList.has(key))
                return false;
        }
        return true;
    }
    // GetHashCode not implemented
    get orderedItems() {
        // List<KeyValuePair<InkListItem, int>>
        let ordered = new Array();
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            ordered.push({ Key: item, Value: value });
        }
        ordered.sort((x, y) => {
            if (x.Key.originName === null) {
                return NullException_1.throwNullException("x.Key.originName");
            }
            if (y.Key.originName === null) {
                return NullException_1.throwNullException("y.Key.originName");
            }
            if (x.Value == y.Value) {
                return x.Key.originName.localeCompare(y.Key.originName);
            }
            else {
                // TODO: refactor this bit into a numberCompareTo method?
                if (x.Value < y.Value)
                    return -1;
                return x.Value > y.Value ? 1 : 0;
            }
        });
        return ordered;
    }
    toString() {
        let ordered = this.orderedItems;
        let sb = new StringBuilder_1.StringBuilder();
        for (let i = 0; i < ordered.length; i++) {
            if (i > 0)
                sb.Append(", ");
            let item = ordered[i].Key;
            if (item.itemName === null)
                return NullException_1.throwNullException("item.itemName");
            sb.Append(item.itemName);
        }
        return sb.toString();
    }
    // casting a InkList to a Number, for somereason, actually gives a number.
    // This messes up the type detection when creating a Value from a InkList.
    // Returning NaN here prevents that.
    valueOf() {
        return NaN;
    }
}
exports.InkList = InkList;
//# sourceMappingURL=InkList.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/JsonSerialisation.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/JsonSerialisation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerialisation = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const ListDefinition_1 = __webpack_require__(/*! ./ListDefinition */ "./node_modules/inkjs/engine/ListDefinition.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class JsonSerialisation {
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException("runtimeObj");
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static WriteDictionaryRuntimeObjs(writer, dictionary) {
        writer.WriteObjectStart();
        for (let [key, value] of dictionary) {
            writer.WritePropertyStart(key);
            this.WriteRuntimeObject(writer, value);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static WriteListRuntimeObjs(writer, list) {
        writer.WriteArrayStart();
        for (let value of list) {
            this.WriteRuntimeObject(writer, value);
        }
        writer.WriteArrayEnd();
    }
    static WriteIntDictionary(writer, dict) {
        writer.WriteObjectStart();
        for (let [key, value] of dict) {
            writer.WriteIntProperty(key, value);
        }
        writer.WriteObjectEnd();
    }
    static WriteRuntimeObject(writer, obj) {
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            this.WriteRuntimeContainer(writer, container);
            return;
        }
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = "->";
            if (divert.isExternal) {
                divTypeKey = "x()";
            }
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function) {
                    divTypeKey = "f()";
                }
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {
                    divTypeKey = "->t->";
                }
            }
            let targetStr;
            if (divert.hasVariableTarget) {
                targetStr = divert.variableDivertName;
            }
            else {
                targetStr = divert.targetPathString;
            }
            writer.WriteObjectStart();
            writer.WriteProperty(divTypeKey, targetStr);
            if (divert.hasVariableTarget) {
                writer.WriteProperty("var", true);
            }
            if (divert.isConditional) {
                writer.WriteProperty("c", true);
            }
            if (divert.externalArgs > 0) {
                writer.WriteIntProperty("exArgs", divert.externalArgs);
            }
            writer.WriteObjectEnd();
            return;
        }
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            writer.WriteObjectStart();
            writer.WriteProperty("*", choicePoint.pathStringOnChoice);
            writer.WriteIntProperty("flg", choicePoint.flags);
            writer.WriteObjectEnd();
            return;
        }
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal) {
            writer.WriteInt(intVal.value);
            return;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal) {
            writer.WriteFloat(floatVal.value);
            return;
        }
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline) {
                writer.Write("\n", false);
            }
            else {
                writer.WriteStringStart();
                writer.WriteStringInner("^");
                writer.WriteStringInner(strVal.value);
                writer.WriteStringEnd();
            }
            return;
        }
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            this.WriteInkList(writer, listVal);
            return;
        }
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            writer.WriteObjectStart();
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException("divTargetVal.value");
            }
            writer.WriteProperty("^->", divTargetVal.value.componentsString);
            writer.WriteObjectEnd();
            return;
        }
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            writer.WriteObjectStart();
            writer.WriteProperty("^var", varPtrVal.value);
            writer.WriteIntProperty("ci", varPtrVal.contextIndex);
            writer.WriteObjectEnd();
            return;
        }
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue) {
            writer.Write("<>");
            return;
        }
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);
            return;
        }
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == "^")
                name = "L^";
            writer.Write(name);
            return;
        }
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            writer.WriteObjectStart();
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                writer.WriteProperty("CNT?", readCountPath);
            }
            else {
                writer.WriteProperty("VAR?", varRef.name);
            }
            writer.WriteObjectEnd();
            return;
        }
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            writer.WriteObjectStart();
            let key = varAss.isGlobal ? "VAR=" : "temp=";
            writer.WriteProperty(key, varAss.variableName);
            // Reassignment?
            if (!varAss.isNewDeclaration)
                writer.WriteProperty("re", true);
            writer.WriteObjectEnd();
            return;
        }
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj) {
            writer.Write("void");
            return;
        }
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            writer.WriteObjectStart();
            writer.WriteProperty("#", tag.text);
            writer.WriteObjectEnd();
            return;
        }
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice) {
            this.WriteChoice(writer, choice);
            return;
        }
        throw new Error("Failed to convert runtime object to Json token: " + obj);
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException("inkObject");
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === "number" && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === "string") {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == "^")
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == "\n" && str.length == 1)
                return new Value_1.StringValue("\n");
            // Glue
            if (str == "<>")
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == "L^")
                str = "^";
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == "->->")
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == "~ret")
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == "void")
                return new Void_1.Void();
        }
        if (typeof token === "object" && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj["^->"]) {
                propValue = obj["^->"];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj["^var"]) {
                propValue = obj["^var"];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ("ci" in obj) {
                    propValue = obj["ci"];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if ((propValue = obj["->"])) {
                isDivert = true;
            }
            else if ((propValue = obj["f()"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if ((propValue = obj["->t->"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if ((propValue = obj["x()"])) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if ((propValue = obj["var"]))
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj["c"];
                if (external) {
                    if ((propValue = obj["exArgs"]))
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if ((propValue = obj["*"])) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if ((propValue = obj["flg"]))
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if ((propValue = obj["VAR?"])) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if ((propValue = obj["CNT?"])) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if ((propValue = obj["VAR="])) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if ((propValue = obj["temp="])) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj["re"];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj["#"] !== undefined) {
                propValue = obj["#"];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if ((propValue = obj["list"])) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if ((propValue = obj["origins"])) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj["originalChoicePath"] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error("Failed to convert token to runtime object: " + JSON.stringify(token));
    }
    static WriteRuntimeContainer(writer, container, withoutName = false) {
        writer.WriteArrayStart();
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        for (let c of container.content)
            this.WriteRuntimeObject(writer, c);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        let hasNameProperty = container.name != null && !withoutName;
        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;
        if (hasTerminator) {
            writer.WriteObjectStart();
        }
        if (namedOnlyContent != null) {
            for (let [key, value] of namedOnlyContent) {
                let name = key;
                let namedContainer = TypeAssertion_1.asOrNull(value, Container_1.Container);
                writer.WritePropertyStart(name);
                this.WriteRuntimeContainer(writer, namedContainer, true);
                writer.WritePropertyEnd();
            }
        }
        if (hasNameProperty)
            writer.WriteProperty("#n", container.name);
        if (hasTerminator)
            writer.WriteObjectEnd();
        else
            writer.WriteNull();
        writer.WriteArrayEnd();
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == "#f") {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == "#n") {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj["text"].toString();
        choice.index = parseInt(jObj["index"]);
        choice.sourcePath = jObj["originalChoicePath"].toString();
        choice.originalThreadIndex = parseInt(jObj["originalThreadIndex"]);
        choice.pathStringOnChoice = jObj["targetPath"].toString();
        return choice;
    }
    static WriteChoice(writer, choice) {
        writer.WriteObjectStart();
        writer.WriteProperty("text", choice.text);
        writer.WriteIntProperty("index", choice.index);
        writer.WriteProperty("originalChoicePath", choice.sourcePath);
        writer.WriteIntProperty("originalThreadIndex", choice.originalThreadIndex);
        writer.WriteProperty("targetPath", choice.pathStringOnChoice);
        writer.WriteObjectEnd();
    }
    static WriteInkList(writer, listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException("rawList");
        }
        writer.WriteObjectStart();
        writer.WritePropertyStart("list");
        writer.WriteObjectStart();
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            let itemVal = val;
            if (item.itemName === null) {
                return NullException_1.throwNullException("item.itemName");
            }
            writer.WritePropertyNameStart();
            writer.WritePropertyNameInner(item.originName ? item.originName : "?");
            writer.WritePropertyNameInner(".");
            writer.WritePropertyNameInner(item.itemName);
            writer.WritePropertyNameEnd();
            writer.Write(itemVal);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        writer.WritePropertyEnd();
        if (rawList.Count == 0 &&
            rawList.originNames != null &&
            rawList.originNames.length > 0) {
            writer.WritePropertyStart("origins");
            writer.WriteArrayStart();
            for (let name of rawList.originNames)
                writer.Write(name);
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException("item.itemName");
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
exports.JsonSerialisation = JsonSerialisation;
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = "ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = "out";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = "/ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = "du";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = "pop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = "~ret";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = "->->";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = "str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = "/str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = "nop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = "choiceCnt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = "turn";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = "turns";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = "readc";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = "rnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = "srnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = "visit";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =
        "seq";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = "thread";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = "done";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = "end";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = "listInt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = "range";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = "lrnd";
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error("Control command not accounted for in serialisation");
    }
    return _controlCommandNames;
})();
//# sourceMappingURL=JsonSerialisation.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinition.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinition = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
class ListDefinition {
    constructor(name, items) {
        this._name = name || "";
        this._items = null;
        this._itemNameToValues = items || new Map();
    }
    get name() {
        return this._name;
    }
    get items() {
        if (this._items == null) {
            this._items = new Map();
            for (let [key, value] of this._itemNameToValues) {
                let item = new InkList_1.InkListItem(this.name, key);
                this._items.set(item.serialized(), value);
            }
        }
        return this._items;
    }
    ValueForItem(item) {
        if (!item.itemName)
            return 0;
        let intVal = this._itemNameToValues.get(item.itemName);
        if (typeof intVal !== "undefined")
            return intVal;
        else
            return 0;
    }
    ContainsItem(item) {
        if (!item.itemName)
            return false;
        if (item.originName != this.name)
            return false;
        return this._itemNameToValues.has(item.itemName);
    }
    ContainsItemWithName(itemName) {
        return this._itemNameToValues.has(itemName);
    }
    TryGetItemWithValue(val, 
    /* out */ item) {
        for (let [key, value] of this._itemNameToValues) {
            if (value == val) {
                item = new InkList_1.InkListItem(this.name, key);
                return { result: item, exists: true };
            }
        }
        item = InkList_1.InkListItem.Null;
        return { result: item, exists: false };
    }
    TryGetValueForItem(item, 
    /* out */ intVal) {
        if (!item.itemName)
            return { result: 0, exists: false };
        let value = this._itemNameToValues.get(item.itemName);
        if (!value)
            return { result: 0, exists: false };
        return { result: value, exists: true };
    }
}
exports.ListDefinition = ListDefinition;
//# sourceMappingURL=ListDefinition.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js":
/*!************************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinitionsOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinitionsOrigin = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ListDefinitionsOrigin {
    constructor(lists) {
        this._lists = new Map();
        this._allUnambiguousListValueCache = new Map();
        for (let list of lists) {
            this._lists.set(list.name, list);
            for (let [key, val] of list.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                let listValue = new Value_1.ListValue(item, val);
                if (!item.itemName) {
                    throw new Error("item.itemName is null or undefined.");
                }
                this._allUnambiguousListValueCache.set(item.itemName, listValue);
                this._allUnambiguousListValueCache.set(item.fullName, listValue);
            }
        }
    }
    get lists() {
        let listOfLists = [];
        for (let [, value] of this._lists) {
            listOfLists.push(value);
        }
        return listOfLists;
    }
    TryListGetDefinition(name, 
    /* out */ def) {
        if (name === null) {
            return { result: def, exists: false };
        }
        // initially, this function returns a boolean and the second parameter is an out.
        let definition = this._lists.get(name);
        if (!definition)
            return { result: def, exists: false };
        return { result: definition, exists: true };
    }
    FindSingleItemListWithName(name) {
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let val = this._allUnambiguousListValueCache.get(name);
        if (typeof val !== "undefined") {
            return val;
        }
        return null;
    }
}
exports.ListDefinitionsOrigin = ListDefinitionsOrigin;
//# sourceMappingURL=ListDefinitionsOrigin.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NativeFunctionCall.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/NativeFunctionCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeFunctionCall = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class NativeFunctionCall extends Object_1.InkObject {
    constructor() {
        super();
        this._name = null;
        this._numberOfParameters = 0;
        this._prototype = null;
        this._isPrototype = false;
        this._operationFuncs = null;
        if (arguments.length === 0) {
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
        }
        else if (arguments.length === 1) {
            let name = arguments[0];
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
            this.name = name;
        }
        else if (arguments.length === 2) {
            let name = arguments[0];
            let numberOfParameters = arguments[1];
            this._isPrototype = true;
            this.name = name;
            this.numberOfParameters = numberOfParameters;
        }
    }
    static CallWithName(functionName) {
        return new NativeFunctionCall(functionName);
    }
    static CallExistsWithName(functionName) {
        this.GenerateNativeFunctionsIfNecessary();
        return this._nativeFunctions.get(functionName);
    }
    get name() {
        if (this._name === null)
            return NullException_1.throwNullException("NativeFunctionCall._name");
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._isPrototype) {
            if (NativeFunctionCall._nativeFunctions === null)
                NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
            else
                this._prototype =
                    NativeFunctionCall._nativeFunctions.get(this._name) || null;
        }
    }
    get numberOfParameters() {
        if (this._prototype) {
            return this._prototype.numberOfParameters;
        }
        else {
            return this._numberOfParameters;
        }
    }
    set numberOfParameters(value) {
        this._numberOfParameters = value;
    }
    Call(parameters) {
        if (this._prototype) {
            return this._prototype.Call(parameters);
        }
        if (this.numberOfParameters != parameters.length) {
            throw new Error("Unexpected number of parameters");
        }
        let hasList = false;
        for (let p of parameters) {
            if (p instanceof Void_1.Void)
                throw new StoryException_1.StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');
            if (p instanceof Value_1.ListValue)
                hasList = true;
        }
        if (parameters.length == 2 && hasList) {
            return this.CallBinaryListOperation(parameters);
        }
        let coercedParams = this.CoerceValuesToSingleType(parameters);
        let coercedType = coercedParams[0].valueType;
        if (coercedType == Value_1.ValueType.Int) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.Float) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.String) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.DivertTarget) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.List) {
            return this.CallType(coercedParams);
        }
        return null;
    }
    CallType(parametersOfSingleType) {
        let param1 = TypeAssertion_1.asOrThrows(parametersOfSingleType[0], Value_1.Value);
        let valType = param1.valueType;
        let val1 = param1;
        let paramCount = parametersOfSingleType.length;
        if (paramCount == 2 || paramCount == 1) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let opForTypeObj = this._operationFuncs.get(valType);
            if (!opForTypeObj) {
                const key = Value_1.ValueType[valType];
                throw new StoryException_1.StoryException("Cannot perform operation " + this.name + " on " + key);
            }
            if (paramCount == 2) {
                let param2 = TypeAssertion_1.asOrThrows(parametersOfSingleType[1], Value_1.Value);
                let val2 = param2;
                let opForType = opForTypeObj;
                if (val1.value === null || val2.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call BinaryOp values");
                let resultVal = opForType(val1.value, val2.value);
                return Value_1.Value.Create(resultVal);
            }
            else {
                let opForType = opForTypeObj;
                if (val1.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call UnaryOp value");
                let resultVal = opForType(val1.value);
                // This code is different from upstream. Since JavaScript treats
                // integers and floats as the same numbers, it's impossible
                // to force an number to be either an integer or a float.
                //
                // It can be useful to force a specific number type
                // (especially for divisions), so the result of INT() & FLOAT()
                // is coerced to the the proper value type.
                //
                // Note that we also force all other unary operation to
                // return the same value type, although this is only
                // meaningful for numbers. See `Value.Create`.
                if (this.name === NativeFunctionCall.Int) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);
                }
                else if (this.name === NativeFunctionCall.Float) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);
                }
                else {
                    return Value_1.Value.Create(resultVal, param1.valueType);
                }
            }
        }
        else {
            throw new Error("Unexpected number of parameters to NativeFunctionCall: " +
                parametersOfSingleType.length);
        }
    }
    CallBinaryListOperation(parameters) {
        if ((this.name == "+" || this.name == "-") &&
            parameters[0] instanceof Value_1.ListValue &&
            parameters[1] instanceof Value_1.IntValue)
            return this.CallListIncrementOperation(parameters);
        let v1 = TypeAssertion_1.asOrThrows(parameters[0], Value_1.Value);
        let v2 = TypeAssertion_1.asOrThrows(parameters[1], Value_1.Value);
        if ((this.name == "&&" || this.name == "||") &&
            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let op = this._operationFuncs.get(Value_1.ValueType.Int);
            if (op === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallBinaryListOperation op");
            let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);
            return new Value_1.IntValue(result);
        }
        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)
            return this.CallType([v1, v2]);
        throw new StoryException_1.StoryException("Can not call use " +
            this.name +
            " operation on " +
            Value_1.ValueType[v1.valueType] +
            " and " +
            Value_1.ValueType[v2.valueType]);
    }
    CallListIncrementOperation(listIntParams) {
        let listVal = TypeAssertion_1.asOrThrows(listIntParams[0], Value_1.ListValue);
        let intVal = TypeAssertion_1.asOrThrows(listIntParams[1], Value_1.IntValue);
        let resultInkList = new InkList_1.InkList();
        if (listVal.value === null)
            return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");
        for (let [listItemKey, listItemValue] of listVal.value) {
            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);
            if (intVal.value === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");
            let targetInt = intOp(listItemValue, intVal.value);
            let itemOrigin = null;
            if (listVal.value.origins === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");
            for (let origin of listVal.value.origins) {
                if (origin.name == listItem.originName) {
                    itemOrigin = origin;
                    break;
                }
            }
            if (itemOrigin != null) {
                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);
                if (incrementedItem.exists)
                    resultInkList.Add(incrementedItem.result, targetInt);
            }
        }
        return new Value_1.ListValue(resultInkList);
    }
    CoerceValuesToSingleType(parametersIn) {
        let valType = Value_1.ValueType.Int;
        let specialCaseList = null;
        for (let obj of parametersIn) {
            let val = TypeAssertion_1.asOrThrows(obj, Value_1.Value);
            if (val.valueType > valType) {
                valType = val.valueType;
            }
            if (val.valueType == Value_1.ValueType.List) {
                specialCaseList = TypeAssertion_1.asOrNull(val, Value_1.ListValue);
            }
        }
        let parametersOut = [];
        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                if (val.valueType == Value_1.ValueType.List) {
                    parametersOut.push(val);
                }
                else if (val.valueType == Value_1.ValueType.Int) {
                    let intVal = parseInt(val.valueObject);
                    specialCaseList = TypeAssertion_1.asOrThrows(specialCaseList, Value_1.ListValue);
                    if (specialCaseList.value === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");
                    let list = specialCaseList.value.originOfMaxItem;
                    if (list === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");
                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);
                    if (item.exists) {
                        let castedValue = new Value_1.ListValue(item.result, intVal);
                        parametersOut.push(castedValue);
                    }
                    else
                        throw new StoryException_1.StoryException("Could not find List item with the value " +
                            intVal +
                            " in " +
                            list.name);
                }
                else {
                    const key = Value_1.ValueType[val.valueType];
                    throw new StoryException_1.StoryException("Cannot mix Lists and " + key + " values in this operation");
                }
            }
        }
        else {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                let castedValue = val.Cast(valType);
                parametersOut.push(castedValue);
            }
        }
        return parametersOut;
    }
    static Identity(t) {
        return t;
    }
    static GenerateNativeFunctionsIfNecessary() {
        if (this._nativeFunctions == null) {
            this._nativeFunctions = new Map();
            // Int operations
            this.AddIntBinaryOp(this.Add, (x, y) => x + y);
            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));
            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);
            this.AddIntUnaryOp(this.Negate, (x) => -x);
            this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));
            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));
            this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Float, (x) => x);
            // Float operations
            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);
            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);
            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);
            this.AddFloatUnaryOp(this.Negate, (x) => -x);
            this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);
            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));
            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);
            // String operations
            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat
            this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));
            this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));
            this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));
            this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));
            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));
            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));
            this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));
            this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));
            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));
            this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);
            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);
            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));
            this.AddListUnaryOp(this.Invert, (x) => x.inverse);
            this.AddListUnaryOp(this.All, (x) => x.all);
            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());
            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());
            this.AddListUnaryOp(this.Count, (x) => x.Count);
            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);
            let divertTargetsEqual = (d1, d2) => (d1.Equals(d2) ? 1 : 0);
            let divertTargetsNotEqual = (d1, d2) => d1.Equals(d2) ? 0 : 1;
            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);
            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);
        }
    }
    AddOpFuncForType(valType, op) {
        if (this._operationFuncs == null) {
            this._operationFuncs = new Map();
        }
        this._operationFuncs.set(valType, op);
    }
    static AddOpToNativeFunc(name, args, valType, op) {
        if (this._nativeFunctions === null)
            return NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
        let nativeFunc = this._nativeFunctions.get(name);
        if (!nativeFunc) {
            nativeFunc = new NativeFunctionCall(name, args);
            this._nativeFunctions.set(name, nativeFunc);
        }
        nativeFunc.AddOpFuncForType(valType, op);
    }
    static AddIntBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);
    }
    static AddIntUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);
    }
    static AddFloatBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);
    }
    static AddFloatUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);
    }
    static AddStringBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);
    }
    static AddListBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);
    }
    static AddListUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);
    }
    toString() {
        return 'Native "' + this.name + '"';
    }
}
exports.NativeFunctionCall = NativeFunctionCall;
NativeFunctionCall.Add = "+";
NativeFunctionCall.Subtract = "-";
NativeFunctionCall.Divide = "/";
NativeFunctionCall.Multiply = "*";
NativeFunctionCall.Mod = "%";
NativeFunctionCall.Negate = "_";
NativeFunctionCall.Equal = "==";
NativeFunctionCall.Greater = ">";
NativeFunctionCall.Less = "<";
NativeFunctionCall.GreaterThanOrEquals = ">=";
NativeFunctionCall.LessThanOrEquals = "<=";
NativeFunctionCall.NotEquals = "!=";
NativeFunctionCall.Not = "!";
NativeFunctionCall.And = "&&";
NativeFunctionCall.Or = "||";
NativeFunctionCall.Min = "MIN";
NativeFunctionCall.Max = "MAX";
NativeFunctionCall.Pow = "POW";
NativeFunctionCall.Floor = "FLOOR";
NativeFunctionCall.Ceiling = "CEILING";
NativeFunctionCall.Int = "INT";
NativeFunctionCall.Float = "FLOAT";
NativeFunctionCall.Has = "?";
NativeFunctionCall.Hasnt = "!?";
NativeFunctionCall.Intersect = "^";
NativeFunctionCall.ListMin = "LIST_MIN";
NativeFunctionCall.ListMax = "LIST_MAX";
NativeFunctionCall.All = "LIST_ALL";
NativeFunctionCall.Count = "LIST_COUNT";
NativeFunctionCall.ValueOfList = "LIST_VALUE";
NativeFunctionCall.Invert = "LIST_INVERT";
NativeFunctionCall._nativeFunctions = null;
//# sourceMappingURL=NativeFunctionCall.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NullException.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/NullException.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.throwNullException = exports.NullException = void 0;
/**
 * In the original C# code, a SystemException would be thrown when passing
 * null to methods expected a valid instance. Javascript has no such
 * concept, but TypeScript will not allow `null` to be passed to methods
 * explicitely requiring a valid type.
 *
 * Whenever TypeScript complain about the possibility of a `null` value,
 * check the offending value and it it's null, throw this exception using
 * `throwNullException(name: string)`.
 */
class NullException extends Error {
}
exports.NullException = NullException;
/**
 * Throw a NullException.
 *
 * @param name a short description of the offending value (often its name within the code).
 */
function throwNullException(name) {
    throw new NullException(`${name} is null or undefined`);
}
exports.throwNullException = throwNullException;
//# sourceMappingURL=NullException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Object.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Object.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkObject = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class InkObject {
    constructor() {
        this.parent = null;
        this._debugMetadata = null;
        this._path = null;
    }
    get debugMetadata() {
        if (this._debugMetadata === null) {
            if (this.parent) {
                return this.parent.debugMetadata;
            }
        }
        return this._debugMetadata;
    }
    set debugMetadata(value) {
        this._debugMetadata = value;
    }
    get ownDebugMetadata() {
        return this._debugMetadata;
    }
    DebugLineNumberOfPath(path) {
        if (path === null)
            return null;
        // Try to get a line number from debug metadata
        let root = this.rootContentContainer;
        if (root) {
            let targetContent = root.ContentAtPath(path).obj;
            if (targetContent) {
                let dm = targetContent.debugMetadata;
                if (dm !== null) {
                    return dm.startLineNumber;
                }
            }
        }
        return null;
    }
    get path() {
        if (this._path == null) {
            if (this.parent == null) {
                this._path = new Path_1.Path();
            }
            else {
                let comps = [];
                let child = this;
                let container = TypeAssertion_1.asOrNull(child.parent, Container_1.Container);
                while (container !== null) {
                    let namedChild = TypeAssertion_1.asINamedContentOrNull(child);
                    if (namedChild != null && namedChild.hasValidName) {
                        comps.unshift(new Path_1.Path.Component(namedChild.name));
                    }
                    else {
                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));
                    }
                    child = container;
                    container = TypeAssertion_1.asOrNull(container.parent, Container_1.Container);
                }
                this._path = new Path_1.Path(comps);
            }
        }
        return this._path;
    }
    ResolvePath(path) {
        if (path === null)
            return NullException_1.throwNullException("path");
        if (path.isRelative) {
            let nearestContainer = TypeAssertion_1.asOrNull(this, Container_1.Container);
            if (nearestContainer === null) {
                Debug_1.Debug.Assert(this.parent !== null, "Can't resolve relative path because we don't have a parent");
                nearestContainer = TypeAssertion_1.asOrNull(this.parent, Container_1.Container);
                Debug_1.Debug.Assert(nearestContainer !== null, "Expected parent to be a container");
                Debug_1.Debug.Assert(path.GetComponent(0).isParent);
                path = path.tail;
            }
            if (nearestContainer === null) {
                return NullException_1.throwNullException("nearestContainer");
            }
            return nearestContainer.ContentAtPath(path);
        }
        else {
            let contentContainer = this.rootContentContainer;
            if (contentContainer === null) {
                return NullException_1.throwNullException("contentContainer");
            }
            return contentContainer.ContentAtPath(path);
        }
    }
    ConvertPathToRelative(globalPath) {
        let ownPath = this.path;
        let minPathLength = Math.min(globalPath.length, ownPath.length);
        let lastSharedPathCompIndex = -1;
        for (let i = 0; i < minPathLength; ++i) {
            let ownComp = ownPath.GetComponent(i);
            let otherComp = globalPath.GetComponent(i);
            if (ownComp.Equals(otherComp)) {
                lastSharedPathCompIndex = i;
            }
            else {
                break;
            }
        }
        // No shared path components, so just use global path
        if (lastSharedPathCompIndex == -1)
            return globalPath;
        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;
        let newPathComps = [];
        for (let up = 0; up < numUpwardsMoves; ++up)
            newPathComps.push(Path_1.Path.Component.ToParent());
        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)
            newPathComps.push(globalPath.GetComponent(down));
        let relativePath = new Path_1.Path(newPathComps, true);
        return relativePath;
    }
    CompactPathString(otherPath) {
        let globalPathStr = null;
        let relativePathStr = null;
        if (otherPath.isRelative) {
            relativePathStr = otherPath.componentsString;
            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;
        }
        else {
            let relativePath = this.ConvertPathToRelative(otherPath);
            relativePathStr = relativePath.componentsString;
            globalPathStr = otherPath.componentsString;
        }
        if (relativePathStr.length < globalPathStr.length)
            return relativePathStr;
        else
            return globalPathStr;
    }
    get rootContentContainer() {
        let ancestor = this;
        while (ancestor.parent) {
            ancestor = ancestor.parent;
        }
        return TypeAssertion_1.asOrNull(ancestor, Container_1.Container);
    }
    Copy() {
        throw Error("Not Implemented: Doesn't support copying");
    }
    // SetChild works slightly diferently in the js implementation.
    // Since we can't pass an objets property by reference, we instead pass
    // the object and the property string.
    // TODO: This method can probably be rewritten with type-safety in mind.
    SetChild(obj, prop, value) {
        if (obj[prop])
            obj[prop] = null;
        obj[prop] = value;
        if (obj[prop])
            obj[prop].parent = this;
    }
}
exports.InkObject = InkObject;
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PRNG.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/PRNG.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PRNG = void 0;
// Taken from https://gist.github.com/blixt/f17b47c62508be59987b
// Ink uses a seedable PRNG of which there is none in native javascript.
class PRNG {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0)
            this.seed += 2147483646;
    }
    next() {
        return (this.seed = (this.seed * 16807) % 2147483647);
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}
exports.PRNG = PRNG;
//# sourceMappingURL=PRNG.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Path.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
class Path {
    constructor() {
        this._components = [];
        this._componentsString = null;
        this._isRelative = false;
        if (typeof arguments[0] == "string") {
            let componentsString = arguments[0];
            this.componentsString = componentsString;
        }
        else if (arguments[0] instanceof Path.Component &&
            arguments[1] instanceof Path) {
            let head = arguments[0];
            let tail = arguments[1];
            this._components.push(head);
            this._components = this._components.concat(tail._components);
        }
        else if (arguments[0] instanceof Array) {
            let head = arguments[0];
            let relative = !!arguments[1];
            this._components = this._components.concat(head);
            this._isRelative = relative;
        }
    }
    get isRelative() {
        return this._isRelative;
    }
    get componentCount() {
        return this._components.length;
    }
    get head() {
        if (this._components.length > 0) {
            return this._components[0];
        }
        else {
            return null;
        }
    }
    get tail() {
        if (this._components.length >= 2) {
            // careful, the original code uses length-1 here. This is because the second argument of
            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index
            let tailComps = this._components.slice(1, this._components.length);
            return new Path(tailComps);
        }
        else {
            return Path.self;
        }
    }
    get length() {
        return this._components.length;
    }
    get lastComponent() {
        let lastComponentIdx = this._components.length - 1;
        if (lastComponentIdx >= 0) {
            return this._components[lastComponentIdx];
        }
        else {
            return null;
        }
    }
    get containsNamedComponent() {
        for (let i = 0, l = this._components.length; i < l; i++) {
            if (!this._components[i].isIndex) {
                return true;
            }
        }
        return false;
    }
    static get self() {
        let path = new Path();
        path._isRelative = true;
        return path;
    }
    GetComponent(index) {
        return this._components[index];
    }
    PathByAppendingPath(pathToAppend) {
        let p = new Path();
        let upwardMoves = 0;
        for (let i = 0; i < pathToAppend._components.length; ++i) {
            if (pathToAppend._components[i].isParent) {
                upwardMoves++;
            }
            else {
                break;
            }
        }
        for (let i = 0; i < this._components.length - upwardMoves; ++i) {
            p._components.push(this._components[i]);
        }
        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {
            p._components.push(pathToAppend._components[i]);
        }
        return p;
    }
    get componentsString() {
        if (this._componentsString == null) {
            this._componentsString = this._components.join(".");
            if (this.isRelative)
                this._componentsString = "." + this._componentsString;
        }
        return this._componentsString;
    }
    set componentsString(value) {
        this._components.length = 0;
        this._componentsString = value;
        if (this._componentsString == null || this._componentsString == "")
            return;
        if (this._componentsString[0] == ".") {
            this._isRelative = true;
            this._componentsString = this._componentsString.substring(1);
        }
        let componentStrings = this._componentsString.split(".");
        for (let str of componentStrings) {
            // we need to distinguish between named components that start with a number, eg "42somewhere", and indexed components
            // the normal parseInt won't do for the detection because it's too relaxed.
            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
            if (/^(\-|\+)?([0-9]+|Infinity)$/.test(str)) {
                this._components.push(new Path.Component(parseInt(str)));
            }
            else {
                this._components.push(new Path.Component(str));
            }
        }
    }
    toString() {
        return this.componentsString;
    }
    Equals(otherPath) {
        if (otherPath == null)
            return false;
        if (otherPath._components.length != this._components.length)
            return false;
        if (otherPath.isRelative != this.isRelative)
            return false;
        // the original code uses SequenceEqual here, so we need to iterate over the components manually.
        for (let i = 0, l = otherPath._components.length; i < l; i++) {
            // it's not quite clear whether this test should use Equals or a simple == operator,
            // see https://github.com/y-lohse/inkjs/issues/22
            if (!otherPath._components[i].Equals(this._components[i]))
                return false;
        }
        return true;
    }
    PathByAppendingComponent(c) {
        let p = new Path();
        p._components.push.apply(p._components, this._components);
        p._components.push(c);
        return p;
    }
}
exports.Path = Path;
Path.parentId = "^";
(function (Path) {
    class Component {
        constructor(indexOrName) {
            this.index = -1;
            this.name = null;
            if (typeof indexOrName == "string") {
                this.name = indexOrName;
            }
            else {
                this.index = indexOrName;
            }
        }
        get isIndex() {
            return this.index >= 0;
        }
        get isParent() {
            return this.name == Path.parentId;
        }
        static ToParent() {
            return new Component(Path.parentId);
        }
        toString() {
            if (this.isIndex) {
                return this.index.toString();
            }
            else {
                return this.name;
            }
        }
        Equals(otherComp) {
            if (otherComp != null && otherComp.isIndex == this.isIndex) {
                if (this.isIndex) {
                    return this.index == otherComp.index;
                }
                else {
                    return this.name == otherComp.name;
                }
            }
            return false;
        }
    }
    Path.Component = Component;
})(Path = exports.Path || (exports.Path = {}));
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Pointer.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/Pointer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class Pointer {
    constructor() {
        this.container = null;
        this.index = -1;
        if (arguments.length === 2) {
            this.container = arguments[0];
            this.index = arguments[1];
        }
    }
    Resolve() {
        if (this.index < 0)
            return this.container;
        if (this.container == null)
            return null;
        if (this.container.content.length == 0)
            return this.container;
        if (this.index >= this.container.content.length)
            return null;
        return this.container.content[this.index];
    }
    get isNull() {
        return this.container == null;
    }
    get path() {
        if (this.isNull)
            return null;
        if (this.index >= 0)
            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));
        else
            return this.container.path;
    }
    toString() {
        if (!this.container)
            return "Ink Pointer (null)";
        return ("Ink Pointer -> " +
            this.container.path.toString() +
            " -- index " +
            this.index);
    }
    // This method does not exist in the original C# code, but is here to maintain the
    // value semantics of Pointer.
    copy() {
        return new Pointer(this.container, this.index);
    }
    static StartOf(container) {
        return new Pointer(container, 0);
    }
    static get Null() {
        return new Pointer(null, -1);
    }
}
exports.Pointer = Pointer;
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PushPop.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/PushPop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPopType = void 0;
var PushPopType;
(function (PushPopType) {
    PushPopType[PushPopType["Tunnel"] = 0] = "Tunnel";
    PushPopType[PushPopType["Function"] = 1] = "Function";
    PushPopType[PushPopType["FunctionEvaluationFromGame"] = 2] = "FunctionEvaluationFromGame";
})(PushPopType = exports.PushPopType || (exports.PushPopType = {}));
//# sourceMappingURL=PushPop.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SearchResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/SearchResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
class SearchResult {
    constructor() {
        this.obj = null;
        this.approximate = false;
    }
    get correctObj() {
        return this.approximate ? null : this.obj;
    }
    get container() {
        return this.obj instanceof Container_1.Container ? this.obj : null;
    }
    copy() {
        let searchResult = new SearchResult();
        searchResult.obj = this.obj;
        searchResult.approximate = this.approximate;
        return searchResult;
    }
}
exports.SearchResult = SearchResult;
//# sourceMappingURL=SearchResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SimpleJson.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/SimpleJson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleJson = void 0;
class SimpleJson {
    static TextToDictionary(text) {
        return new SimpleJson.Reader(text).ToDictionary();
    }
    static TextToArray(text) {
        return new SimpleJson.Reader(text).ToArray();
    }
}
exports.SimpleJson = SimpleJson;
(function (SimpleJson) {
    class Reader {
        constructor(text) {
            this._rootObject = JSON.parse(text);
        }
        ToDictionary() {
            return this._rootObject;
        }
        ToArray() {
            return this._rootObject;
        }
    }
    SimpleJson.Reader = Reader;
    // In C#, this class writes json tokens directly to a StringWriter or
    // another stream. Here, a temporary hierarchy is created in the form
    // of a javascript object, which is serialised in the `toString` method.
    // See individual methods and properties for more information.
    class Writer {
        constructor() {
            // In addition to `_stateStack` present in the original code,
            // this implementation of SimpleJson use two other stacks and two
            // temporary variables holding the current context.
            // Used to keep track of the current property name being built
            // with `WritePropertyNameStart`, `WritePropertyNameInner` and
            // `WritePropertyNameEnd`.
            this._currentPropertyName = null;
            // Used to keep track of the current string value being built
            // with `WriteStringStart`, `WriteStringInner` and
            // `WriteStringEnd`.
            this._currentString = null;
            this._stateStack = [];
            // Keep track of the current collection being built (either an array
            // or an object). For instance, at the '?' step during the hiarchy
            // creation, this hierarchy:
            // [3, {a: [b, ?]}] will have this corresponding stack:
            // (bottom) [Array, Object, Array] (top)
            this._collectionStack = [];
            // Keep track of the current property being assigned. For instance, at
            // the '?' step during the hiarchy creation, this hierarchy:
            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:
            // (bottom) [a, c] (top)
            this._propertyNameStack = [];
            // Object containing the entire hiearchy.
            this._jsonObject = null;
        }
        WriteObject(inner) {
            this.WriteObjectStart();
            inner(this);
            this.WriteObjectEnd();
        }
        // Add a new object.
        WriteObjectStart() {
            this.StartNewObject(true);
            let newObject = {};
            if (this.state === SimpleJson.Writer.State.Property) {
                // This object is created as the value of a property,
                // inside an other object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This object is created as the child of an array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This object is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));
        }
        WriteObjectEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Write a property name / value pair to the current object.
        WriteProperty(name, innerOrContent) {
            this.WritePropertyStart(name);
            if (arguments[1] instanceof Function) {
                let inner = arguments[1];
                inner(this);
            }
            else {
                let content = arguments[1];
                this.Write(content);
            }
            this.WritePropertyEnd();
        }
        // Int and Float are separate calls, since there both are
        // numbers in JavaScript, but need to be handled differently.
        WriteIntProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteInt(content);
            this.WritePropertyEnd();
        }
        WriteFloatProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteFloat(content);
            this.WritePropertyEnd();
        }
        // Prepare a new property name, which will be use to add the
        // new object when calling _addToCurrentObject() from a Write
        // method.
        WritePropertyStart(name) {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._propertyNameStack.push(name);
            this.IncrementChildCount();
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
        }
        WritePropertyEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Property);
            this.Assert(this.childCount === 1);
            this._stateStack.pop();
        }
        // Prepare a new property name, except this time, the property name
        // will be created by concatenating all the strings passed to
        // WritePropertyNameInner.
        WritePropertyNameStart() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this.IncrementChildCount();
            this._currentPropertyName = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));
        }
        WritePropertyNameEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._propertyNameStack.push(this._currentPropertyName);
            this._currentPropertyName = null;
            this._stateStack.pop();
        }
        WritePropertyNameInner(str) {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._currentPropertyName += str;
        }
        // Add a new array.
        WriteArrayStart() {
            this.StartNewObject(true);
            let newObject = [];
            if (this.state === SimpleJson.Writer.State.Property) {
                // This array is created as the value of a property,
                // inside an object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This array is created as the child of another array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This array is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));
        }
        WriteArrayEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Array);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Add the value to the appropriate collection (array / object), given the current
        // context.
        Write(value, escape = true) {
            if (value === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this.StartNewObject(false);
            this._addToCurrentObject(value);
        }
        WriteInt(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            // Math.floor is used as a precaution:
            //     1. to ensure that the value is written as an integer
            //        (without a fractional part -> 1 instead of 1.0), even
            //        though it should be the default behaviour of
            //        JSON.serialize;
            //     2. to ensure that if a floating number is passed
            //        accidentally, it's converted to an integer.
            //
            // This guarantees savegame compatibility with the reference
            // implementation.
            this._addToCurrentObject(Math.floor(value));
        }
        // Since JSON doesn't support NaN and Infinity, these values
        // are converted here.
        WriteFloat(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            if (value == Number.POSITIVE_INFINITY) {
                this._addToCurrentObject(3.4e38);
            }
            else if (value == Number.NEGATIVE_INFINITY) {
                this._addToCurrentObject(-3.4e38);
            }
            else if (isNaN(value)) {
                this._addToCurrentObject(0.0);
            }
            else {
                this._addToCurrentObject(value);
            }
        }
        WriteNull() {
            this.StartNewObject(false);
            this._addToCurrentObject(null);
        }
        // Prepare a string before adding it to the current collection in
        // WriteStringEnd(). The string will be a concatenation of all the
        // strings passed to WriteStringInner.
        WriteStringStart() {
            this.StartNewObject(false);
            this._currentString = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));
        }
        WriteStringEnd() {
            this.Assert(this.state == SimpleJson.Writer.State.String);
            this._stateStack.pop();
            this._addToCurrentObject(this._currentString);
            this._currentString = null;
        }
        WriteStringInner(str, escape = true) {
            this.Assert(this.state === SimpleJson.Writer.State.String);
            if (str === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this._currentString += str;
        }
        // Serialise the root object into a JSON string.
        ToString() {
            if (this._jsonObject === null) {
                return "";
            }
            return JSON.stringify(this._jsonObject);
        }
        // Prepare the state stack when adding new objects / values.
        StartNewObject(container) {
            if (container) {
                this.Assert(this.state === SimpleJson.Writer.State.None ||
                    this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            else {
                this.Assert(this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(this.childCount === 0);
            }
            if (this.state === SimpleJson.Writer.State.Array ||
                this.state === SimpleJson.Writer.State.Property) {
                this.IncrementChildCount();
            }
        }
        // These getters peek all the different stacks.
        get state() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].type;
            }
            else {
                return SimpleJson.Writer.State.None;
            }
        }
        get childCount() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].childCount;
            }
            else {
                return 0;
            }
        }
        get currentCollection() {
            if (this._collectionStack.length > 0) {
                return this._collectionStack[this._collectionStack.length - 1];
            }
            else {
                return null;
            }
        }
        get currentPropertyName() {
            if (this._propertyNameStack.length > 0) {
                return this._propertyNameStack[this._propertyNameStack.length - 1];
            }
            else {
                return null;
            }
        }
        IncrementChildCount() {
            this.Assert(this._stateStack.length > 0);
            let currEl = this._stateStack.pop();
            currEl.childCount++;
            this._stateStack.push(currEl);
        }
        Assert(condition) {
            if (!condition)
                throw Error("Assert failed while writing JSON");
        }
        // This method did not exist in the original C# code. It adds
        // the given value to the current collection (used by Write methods).
        _addToCurrentObject(value) {
            this.Assert(this.currentCollection !== null);
            if (this.state === SimpleJson.Writer.State.Array) {
                this.Assert(Array.isArray(this.currentCollection));
                this.currentCollection.push(value);
            }
            else if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(!Array.isArray(this.currentCollection));
                this.Assert(this.currentPropertyName !== null);
                this.currentCollection[this.currentPropertyName] = value;
                this._propertyNameStack.pop();
            }
        }
    }
    SimpleJson.Writer = Writer;
    (function (Writer) {
        let State;
        (function (State) {
            State[State["None"] = 0] = "None";
            State[State["Object"] = 1] = "Object";
            State[State["Array"] = 2] = "Array";
            State[State["Property"] = 3] = "Property";
            State[State["PropertyName"] = 4] = "PropertyName";
            State[State["String"] = 5] = "String";
        })(State = Writer.State || (Writer.State = {}));
        class StateElement {
            constructor(type) {
                this.type = SimpleJson.Writer.State.None;
                this.childCount = 0;
                this.type = type;
            }
        }
        Writer.StateElement = StateElement;
    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));
})(SimpleJson = exports.SimpleJson || (exports.SimpleJson = {}));
//# sourceMappingURL=SimpleJson.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StatePatch.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StatePatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePatch = void 0;
class StatePatch {
    constructor() {
        this._changedVariables = new Set();
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        if (arguments.length === 1 && arguments[0] !== null) {
            let toCopy = arguments[0];
            this._globals = new Map(toCopy._globals);
            this._changedVariables = new Set(toCopy._changedVariables);
            this._visitCounts = new Map(toCopy._visitCounts);
            this._turnIndices = new Map(toCopy._turnIndices);
        }
        else {
            this._globals = new Map();
            this._changedVariables = new Set();
            this._visitCounts = new Map();
            this._turnIndices = new Map();
        }
    }
    get globals() {
        return this._globals;
    }
    get changedVariables() {
        return this._changedVariables;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    TryGetGlobal(name, /* out */ value) {
        if (name !== null && this._globals.has(name)) {
            return { result: this._globals.get(name), exists: true };
        }
        return { result: value, exists: false };
    }
    SetGlobal(name, value) {
        this._globals.set(name, value);
    }
    AddChangedVariable(name) {
        return this._changedVariables.add(name);
    }
    TryGetVisitCount(container, /* out */ count) {
        if (this._visitCounts.has(container)) {
            return { result: this._visitCounts.get(container), exists: true };
        }
        return { result: count, exists: false };
    }
    SetVisitCount(container, count) {
        this._visitCounts.set(container, count);
    }
    SetTurnIndex(container, index) {
        this._turnIndices.set(container, index);
    }
    TryGetTurnIndex(container, /* out */ index) {
        if (this._turnIndices.has(container)) {
            return { result: this._turnIndices.get(container), exists: true };
        }
        return { result: index, exists: false };
    }
}
exports.StatePatch = StatePatch;
//# sourceMappingURL=StatePatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StopWatch.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/StopWatch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopwatch = void 0;
// This is simple replacement of the Stopwatch class from the .NET Framework.
// The original class can count time with much more accuracy than the Javascript version.
// It might be worth considering using `window.performance` in the browser
// or `process.hrtime()` in node.
class Stopwatch {
    constructor() {
        this.startTime = undefined;
    }
    get ElapsedMilliseconds() {
        if (typeof this.startTime === "undefined") {
            return 0;
        }
        return new Date().getTime() - this.startTime;
    }
    Start() {
        this.startTime = new Date().getTime();
    }
    Stop() {
        this.startTime = undefined;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=StopWatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Story.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Story.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Story = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const StoryState_1 = __webpack_require__(/*! ./StoryState */ "./node_modules/inkjs/engine/StoryState.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const StopWatch_1 = __webpack_require__(/*! ./StopWatch */ "./node_modules/inkjs/engine/StopWatch.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
var InkList_2 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
Object.defineProperty(exports, "InkList", { enumerable: true, get: function () { return InkList_2.InkList; } });
if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return (typeof nVal === "number" &&
            isFinite(nVal) &&
            nVal > -9007199254740992 &&
            nVal < 9007199254740992 &&
            Math.floor(nVal) === nVal);
    };
}
class Story extends Object_1.InkObject {
    constructor() {
        super();
        this.inkVersionMinimumCompatible = 18;
        this._prevContainers = [];
        this.allowExternalFunctionFallbacks = false;
        this._listDefinitions = null;
        this._variableObservers = null;
        this._hasValidatedExternals = false;
        this._temporaryEvaluationContainer = null;
        this._asyncContinueActive = false;
        this._stateSnapshotAtLastNewline = null;
        this._recursiveContinueCount = 0;
        this._asyncSaving = false;
        this._profiler = null; // TODO: Profiler
        // Discrimination between constructors
        let contentContainer;
        let lists = null;
        let json = null;
        if (arguments[0] instanceof Container_1.Container) {
            contentContainer = arguments[0];
            if (typeof arguments[1] !== "undefined") {
                lists = arguments[1];
            }
            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
            this._mainContentContainer = contentContainer;
            // ------
        }
        else {
            if (typeof arguments[0] === "string") {
                let jsonString = arguments[0];
                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);
            }
            else {
                json = arguments[0];
            }
        }
        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
        if (lists != null)
            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);
        this._externals = new Map();
        // ------
        // ------ Story(string jsonString) : this((Container)null)
        if (json !== null) {
            let rootObject = json;
            let versionObj = rootObject["inkVersion"];
            if (versionObj == null)
                throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");
            let formatFromFile = parseInt(versionObj);
            if (formatFromFile > Story.inkVersionCurrent) {
                throw new Error("Version of ink used to build story was newer than the current version of the engine");
            }
            else if (formatFromFile < this.inkVersionMinimumCompatible) {
                throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");
            }
            else if (formatFromFile != Story.inkVersionCurrent) {
                console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");
            }
            let rootToken = rootObject["root"];
            if (rootToken == null)
                throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");
            let listDefsObj;
            if ((listDefsObj = rootObject["listDefs"])) {
                this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);
            }
            this._mainContentContainer = TypeAssertion_1.asOrThrows(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);
            this.ResetState();
        }
        // ------
    }
    get currentChoices() {
        let choices = [];
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        for (let c of this._state.currentChoices) {
            if (!c.isInvisibleDefault) {
                c.index = choices.length;
                choices.push(c);
            }
        }
        return choices;
    }
    get currentText() {
        this.IfAsyncWeCant("call currentText since it's a work in progress");
        return this.state.currentText;
    }
    get currentTags() {
        this.IfAsyncWeCant("call currentTags since it's a work in progress");
        return this.state.currentTags;
    }
    get currentErrors() {
        return this.state.currentErrors;
    }
    get currentWarnings() {
        return this.state.currentWarnings;
    }
    get hasError() {
        return this.state.hasError;
    }
    get hasWarning() {
        return this.state.hasWarning;
    }
    get variablesState() {
        return this.state.variablesState;
    }
    get listDefinitions() {
        return this._listDefinitions;
    }
    get state() {
        return this._state;
    }
    // TODO: Implement Profiler
    StartProfiling() {
        /* */
    }
    EndProfiling() {
        /* */
    }
    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.
    // Will only return a value if writer was not provided.
    ToJson(writer) {
        let shouldReturn = false;
        if (!writer) {
            shouldReturn = true;
            writer = new SimpleJson_1.SimpleJson.Writer();
        }
        writer.WriteObjectStart();
        writer.WriteIntProperty("inkVersion", Story.inkVersionCurrent);
        writer.WriteProperty("root", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));
        if (this._listDefinitions != null) {
            writer.WritePropertyStart("listDefs");
            writer.WriteObjectStart();
            for (let def of this._listDefinitions.lists) {
                writer.WritePropertyStart(def.name);
                writer.WriteObjectStart();
                for (let [key, value] of def.items) {
                    let item = InkList_1.InkListItem.fromSerializedKey(key);
                    let val = value;
                    writer.WriteIntProperty(item.itemName, val);
                }
                writer.WriteObjectEnd();
                writer.WritePropertyEnd();
            }
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        if (shouldReturn)
            return writer.ToString();
    }
    ResetState() {
        this.IfAsyncWeCant("ResetState");
        this._state = new StoryState_1.StoryState(this);
        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));
        this.ResetGlobals();
    }
    ResetErrors() {
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ResetErrors();
    }
    ResetCallstack() {
        this.IfAsyncWeCant("ResetCallstack");
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ForceEnd();
    }
    ResetGlobals() {
        if (this._mainContentContainer.namedContent.get("global decl")) {
            let originalPointer = this.state.currentPointer.copy();
            this.ChoosePath(new Path_1.Path("global decl"), false);
            this.ContinueInternal();
            this.state.currentPointer = originalPointer;
        }
        this.state.variablesState.SnapshotDefaultGlobals();
    }
    Continue() {
        this.ContinueAsync(0);
        return this.currentText;
    }
    get canContinue() {
        return this.state.canContinue;
    }
    get asyncContinueComplete() {
        return !this._asyncContinueActive;
    }
    ContinueAsync(millisecsLimitAsync) {
        if (!this._hasValidatedExternals)
            this.ValidateExternalBindings();
        this.ContinueInternal(millisecsLimitAsync);
    }
    ContinueInternal(millisecsLimitAsync = 0) {
        if (this._profiler != null)
            this._profiler.PreContinue();
        let isAsyncTimeLimited = millisecsLimitAsync > 0;
        this._recursiveContinueCount++;
        if (!this._asyncContinueActive) {
            this._asyncContinueActive = isAsyncTimeLimited;
            if (!this.canContinue) {
                throw new StoryException_1.StoryException("Can't continue - should check canContinue before calling Continue");
            }
            this._state.didSafeExit = false;
            this._state.ResetOutput();
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = true;
        }
        let durationStopwatch = new StopWatch_1.Stopwatch();
        durationStopwatch.Start();
        let outputStreamEndsInNewline = false;
        do {
            try {
                outputStreamEndsInNewline = this.ContinueSingleStep();
            }
            catch (e) {
                if (!(e instanceof StoryException_1.StoryException))
                    throw e;
                this.AddError(e.message, undefined, e.useEndLineNumber);
                break;
            }
            if (outputStreamEndsInNewline)
                break;
            if (this._asyncContinueActive &&
                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {
                break;
            }
        } while (this.canContinue);
        durationStopwatch.Stop();
        if (outputStreamEndsInNewline || !this.canContinue) {
            if (this._stateSnapshotAtLastNewline !== null) {
                this.RestoreStateSnapshot();
            }
            if (!this.canContinue) {
                if (this.state.callStack.canPopThread)
                    this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");
                if (this.state.generatedChoices.length == 0 &&
                    !this.state.didSafeExit &&
                    this._temporaryEvaluationContainer == null) {
                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))
                        this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))
                        this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");
                    else if (!this.state.callStack.canPop)
                        this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");
                    else
                        this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!");
                }
            }
            this.state.didSafeExit = false;
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = false;
            this._asyncContinueActive = false;
        }
        this._recursiveContinueCount--;
        if (this._profiler != null)
            this._profiler.PostContinue();
    }
    ContinueSingleStep() {
        if (this._profiler != null)
            this._profiler.PreStep();
        this.Step();
        if (this._profiler != null)
            this._profiler.PostStep();
        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {
            this.TryFollowDefaultInvisibleChoice();
        }
        if (this._profiler != null)
            this._profiler.PreSnapshot();
        if (!this.state.inStringEvaluation) {
            if (this._stateSnapshotAtLastNewline !== null) {
                if (this._stateSnapshotAtLastNewline.currentTags === null) {
                    return NullException_1.throwNullException("this._stateAtLastNewline.currentTags");
                }
                if (this.state.currentTags === null) {
                    return NullException_1.throwNullException("this.state.currentTags");
                }
                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);
                if (change == Story.OutputStateChange.ExtendedBeyondNewline) {
                    this.RestoreStateSnapshot();
                    return true;
                }
                else if (change == Story.OutputStateChange.NewlineRemoved) {
                    this.DiscardSnapshot();
                }
            }
            if (this.state.outputStreamEndsInNewline) {
                if (this.canContinue) {
                    if (this._stateSnapshotAtLastNewline == null)
                        this.StateSnapshot();
                }
                else {
                    this.DiscardSnapshot();
                }
            }
        }
        if (this._profiler != null)
            this._profiler.PostSnapshot();
        return false;
    }
    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {
        if (prevText === null) {
            return NullException_1.throwNullException("prevText");
        }
        if (currText === null) {
            return NullException_1.throwNullException("currText");
        }
        let newlineStillExists = currText.length >= prevText.length &&
            currText.charAt(prevText.length - 1) == "\n";
        if (prevTagCount == currTagCount &&
            prevText.length == currText.length &&
            newlineStillExists)
            return Story.OutputStateChange.NoChange;
        if (!newlineStillExists) {
            return Story.OutputStateChange.NewlineRemoved;
        }
        if (currTagCount > prevTagCount)
            return Story.OutputStateChange.ExtendedBeyondNewline;
        for (let i = prevText.length; i < currText.length; i++) {
            let c = currText.charAt(i);
            if (c != " " && c != "\t") {
                return Story.OutputStateChange.ExtendedBeyondNewline;
            }
        }
        return Story.OutputStateChange.NoChange;
    }
    ContinueMaximally() {
        this.IfAsyncWeCant("ContinueMaximally");
        let sb = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            sb.Append(this.Continue());
        }
        return sb.toString();
    }
    ContentAtPath(path) {
        return this.mainContentContainer.ContentAtPath(path);
    }
    KnotContainerWithName(name) {
        let namedContainer = this.mainContentContainer.namedContent.get(name);
        if (namedContainer instanceof Container_1.Container)
            return namedContainer;
        else
            return null;
    }
    PointerAtPath(path) {
        if (path.length == 0)
            return Pointer_1.Pointer.Null;
        let p = new Pointer_1.Pointer();
        let pathLengthToUse = path.length;
        let result = null;
        if (path.lastComponent === null) {
            return NullException_1.throwNullException("path.lastComponent");
        }
        if (path.lastComponent.isIndex) {
            pathLengthToUse = path.length - 1;
            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);
            p.container = result.container;
            p.index = path.lastComponent.index;
        }
        else {
            result = this.mainContentContainer.ContentAtPath(path);
            p.container = result.container;
            p.index = -1;
        }
        if (result.obj == null ||
            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {
            this.Error("Failed to find content at path '" +
                path +
                "', and no approximation of it was possible.");
        }
        else if (result.approximate)
            this.Warning("Failed to find content at path '" +
                path +
                "', so it was approximated to: '" +
                result.obj.path +
                "'.");
        return p;
    }
    StateSnapshot() {
        this._stateSnapshotAtLastNewline = this._state;
        this._state = this._state.CopyAndStartPatching();
    }
    RestoreStateSnapshot() {
        if (this._stateSnapshotAtLastNewline === null) {
            NullException_1.throwNullException("_stateSnapshotAtLastNewline");
        }
        this._stateSnapshotAtLastNewline.RestoreAfterPatch();
        this._state = this._stateSnapshotAtLastNewline;
        this._stateSnapshotAtLastNewline = null;
        if (!this._asyncSaving) {
            this._state.ApplyAnyPatch();
        }
    }
    DiscardSnapshot() {
        if (!this._asyncSaving)
            this._state.ApplyAnyPatch();
        this._stateSnapshotAtLastNewline = null;
    }
    CopyStateForBackgroundThreadSave() {
        this.IfAsyncWeCant("start saving on a background thread");
        if (this._asyncSaving)
            throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");
        let stateToSave = this._state;
        this._state = this._state.CopyAndStartPatching();
        this._asyncSaving = true;
        return stateToSave;
    }
    BackgroundSaveComplete() {
        if (this._stateSnapshotAtLastNewline === null) {
            this._state.ApplyAnyPatch();
        }
        this._asyncSaving = false;
    }
    Step() {
        let shouldAddToStream = true;
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull) {
            return;
        }
        // Container containerToEnter = pointer.Resolve () as Container;
        let containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        while (containerToEnter) {
            this.VisitContainer(containerToEnter, true);
            // No content? the most we can do is step past it
            if (containerToEnter.content.length == 0) {
                break;
            }
            pointer = Pointer_1.Pointer.StartOf(containerToEnter);
            // containerToEnter = pointer.Resolve() as Container;
            containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        }
        this.state.currentPointer = pointer.copy();
        if (this._profiler != null)
            this._profiler.Step(this.state.callStack);
        // Is the current content object:
        //  - Normal content
        //  - Or a logic/flow statement - if so, do it
        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot
        // that was diverted to rather than called as a function)
        let currentContentObj = pointer.Resolve();
        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);
        // Has flow been forced to end by flow control above?
        if (this.state.currentPointer.isNull) {
            return;
        }
        if (isLogicOrFlowControl) {
            shouldAddToStream = false;
        }
        // Choice with condition?
        // var choicePoint = currentContentObj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(currentContentObj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let choice = this.ProcessChoice(choicePoint);
            if (choice) {
                this.state.generatedChoices.push(choice);
            }
            currentContentObj = null;
            shouldAddToStream = false;
        }
        // If the container has no content, then it will be
        // the "content" itself, but we skip over it.
        if (currentContentObj instanceof Container_1.Container) {
            shouldAddToStream = false;
        }
        // Content to add to evaluation stack or the output stream
        if (shouldAddToStream) {
            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific
            // to our current (possibly temporary) context index. And make a copy of the pointer
            // so that we're not editing the original runtime object.
            // var varPointer = currentContentObj as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(currentContentObj, Value_1.VariablePointerValue);
            if (varPointer && varPointer.contextIndex == -1) {
                // Create new object so we're not overwriting the story's own data
                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);
                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);
            }
            // Expression evaluation content
            if (this.state.inExpressionEvaluation) {
                this.state.PushEvaluationStack(currentContentObj);
            }
            // Output stream content (i.e. not expression evaluation)
            else {
                this.state.PushToOutputStream(currentContentObj);
            }
        }
        // Increment the content pointer, following diverts if necessary
        this.NextContent();
        // Starting a thread should be done after the increment to the content pointer,
        // so that when returning from the thread, it returns to the content after this instruction.
        // var controlCmd = currentContentObj as ;
        let controlCmd = TypeAssertion_1.asOrNull(currentContentObj, ControlCommand_1.ControlCommand);
        if (controlCmd &&
            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {
            this.state.callStack.PushThread();
        }
    }
    VisitContainer(container, atStart) {
        if (!container.countingAtStartOnly || atStart) {
            if (container.visitsShouldBeCounted)
                this.state.IncrementVisitCountForContainer(container);
            if (container.turnIndexShouldBeCounted)
                this.state.RecordTurnIndexVisitToContainer(container);
        }
    }
    VisitChangedContainersDueToDivert() {
        let previousPointer = this.state.previousPointer.copy();
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull || pointer.index == -1)
            return;
        this._prevContainers.length = 0;
        if (!previousPointer.isNull) {
            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;
            let resolvedPreviousAncestor = previousPointer.Resolve();
            let prevAncestor = TypeAssertion_1.asOrNull(resolvedPreviousAncestor, Container_1.Container) ||
                TypeAssertion_1.asOrNull(previousPointer.container, Container_1.Container);
            while (prevAncestor) {
                this._prevContainers.push(prevAncestor);
                // prevAncestor = prevAncestor.parent as Container;
                prevAncestor = TypeAssertion_1.asOrNull(prevAncestor.parent, Container_1.Container);
            }
        }
        let currentChildOfContainer = pointer.Resolve();
        if (currentChildOfContainer == null)
            return;
        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;
        let currentContainerAncestor = TypeAssertion_1.asOrNull(currentChildOfContainer.parent, Container_1.Container);
        while (currentContainerAncestor &&
            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||
                currentContainerAncestor.countingAtStartOnly)) {
            // Check whether this ancestor container is being entered at the start,
            // by checking whether the child object is the first.
            let enteringAtStart = currentContainerAncestor.content.length > 0 &&
                currentChildOfContainer == currentContainerAncestor.content[0];
            // Mark a visit to this container
            this.VisitContainer(currentContainerAncestor, enteringAtStart);
            currentChildOfContainer = currentContainerAncestor;
            // currentContainerAncestor = currentContainerAncestor.parent as Container;
            currentContainerAncestor = TypeAssertion_1.asOrNull(currentContainerAncestor.parent, Container_1.Container);
        }
    }
    ProcessChoice(choicePoint) {
        let showChoice = true;
        // Don't create choice if choice point doesn't pass conditional
        if (choicePoint.hasCondition) {
            let conditionValue = this.state.PopEvaluationStack();
            if (!this.IsTruthy(conditionValue)) {
                showChoice = false;
            }
        }
        let startText = "";
        let choiceOnlyText = "";
        if (choicePoint.hasChoiceOnlyContent) {
            // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;
            let choiceOnlyStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            choiceOnlyText = choiceOnlyStrVal.value || "";
        }
        if (choicePoint.hasStartContent) {
            // var startStrVal = state.PopEvaluationStack () as StringValue;
            let startStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            startText = startStrVal.value || "";
        }
        // Don't create choice if player has already read this content
        if (choicePoint.onceOnly) {
            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);
            if (visitCount > 0) {
                showChoice = false;
            }
        }
        // We go through the full process of creating the choice above so
        // that we consume the content for it, since otherwise it'll
        // be shown on the output stream.
        if (!showChoice) {
            return null;
        }
        let choice = new Choice_1.Choice();
        choice.targetPath = choicePoint.pathOnChoice;
        choice.sourcePath = choicePoint.path.toString();
        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;
        choice.threadAtGeneration = this.state.callStack.ForkThread();
        choice.text = (startText + choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g, "");
        return choice;
    }
    IsTruthy(obj) {
        let truthy = false;
        if (obj instanceof Value_1.Value) {
            let val = obj;
            if (val instanceof Value_1.DivertTargetValue) {
                let divTarget = val;
                this.Error("Shouldn't use a divert target (to " +
                    divTarget.targetPath +
                    ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
                return false;
            }
            return val.isTruthy;
        }
        return truthy;
    }
    PerformLogicAndFlowControl(contentObj) {
        if (contentObj == null) {
            return false;
        }
        // Divert
        if (contentObj instanceof Divert_1.Divert) {
            let currentDivert = contentObj;
            if (currentDivert.isConditional) {
                let conditionValue = this.state.PopEvaluationStack();
                // False conditional? Cancel divert
                if (!this.IsTruthy(conditionValue))
                    return true;
            }
            if (currentDivert.hasVariableTarget) {
                let varName = currentDivert.variableDivertName;
                let varContents = this.state.variablesState.GetVariableWithName(varName);
                if (varContents == null) {
                    this.Error("Tried to divert using a target from a variable that could not be found (" +
                        varName +
                        ")");
                }
                else if (!(varContents instanceof Value_1.DivertTargetValue)) {
                    // var intContent = varContents as IntValue;
                    let intContent = TypeAssertion_1.asOrNull(varContents, Value_1.IntValue);
                    let errorMessage = "Tried to divert to a target from a variable, but the variable (" +
                        varName +
                        ") didn't contain a divert target, it ";
                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {
                        errorMessage += "was empty/null (the value 0).";
                    }
                    else {
                        errorMessage += "contained '" + varContents + "'.";
                    }
                    this.Error(errorMessage);
                }
                let target = TypeAssertion_1.asOrThrows(varContents, Value_1.DivertTargetValue);
                this.state.divertedPointer = this.PointerAtPath(target.targetPath);
            }
            else if (currentDivert.isExternal) {
                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);
                return true;
            }
            else {
                this.state.divertedPointer = currentDivert.targetPointer.copy();
            }
            if (currentDivert.pushesToStack) {
                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);
            }
            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {
                if (currentDivert &&
                    currentDivert.debugMetadata &&
                    currentDivert.debugMetadata.sourceName != null) {
                    this.Error("Divert target doesn't exist: " +
                        currentDivert.debugMetadata.sourceName);
                }
                else {
                    this.Error("Divert resolution failed: " + currentDivert);
                }
            }
            return true;
        }
        // Start/end an expression evaluation? Or print out the result?
        else if (contentObj instanceof ControlCommand_1.ControlCommand) {
            let evalCommand = contentObj;
            switch (evalCommand.commandType) {
                case ControlCommand_1.ControlCommand.CommandType.EvalStart:
                    this.Assert(this.state.inExpressionEvaluation === false, "Already in expression evaluation?");
                    this.state.inExpressionEvaluation = true;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:
                    this.Assert(this.state.inExpressionEvaluation === true, "Not in expression evaluation mode");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:
                    // If the expression turned out to be empty, there may not be anything on the stack
                    if (this.state.evaluationStack.length > 0) {
                        let output = this.state.PopEvaluationStack();
                        // Functions may evaluate to Void, in which case we skip output
                        if (!(output instanceof Void_1.Void)) {
                            // TODO: Should we really always blanket convert to string?
                            // It would be okay to have numbers in the output stream the
                            // only problem is when exporting text for viewing, it skips over numbers etc.
                            let text = new Value_1.StringValue(output.toString());
                            this.state.PushToOutputStream(text);
                        }
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.NoOp:
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Duplicate:
                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:
                    this.state.PopEvaluationStack();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopFunction:
                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:
                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction
                        ? PushPop_1.PushPopType.Function
                        : PushPop_1.PushPopType.Tunnel;
                    let overrideTunnelReturnTarget = null;
                    if (popType == PushPop_1.PushPopType.Tunnel) {
                        let popped = this.state.PopEvaluationStack();
                        // overrideTunnelReturnTarget = popped as DivertTargetValue;
                        overrideTunnelReturnTarget = TypeAssertion_1.asOrNull(popped, Value_1.DivertTargetValue);
                        if (overrideTunnelReturnTarget === null) {
                            this.Assert(popped instanceof Void_1.Void, "Expected void if ->-> doesn't override target");
                        }
                    }
                    if (this.state.TryExitFunctionEvaluationFromGame()) {
                        break;
                    }
                    else if (this.state.callStack.currentElement.type != popType ||
                        !this.state.callStack.canPop) {
                        let names = new Map();
                        names.set(PushPop_1.PushPopType.Function, "function return statement (~ return)");
                        names.set(PushPop_1.PushPopType.Tunnel, "tunnel onwards statement (->->)");
                        let expected = names.get(this.state.callStack.currentElement.type);
                        if (!this.state.callStack.canPop) {
                            expected = "end of flow (-> END or choice)";
                        }
                        let errorMsg = "Found " + names.get(popType) + ", when expected " + expected;
                        this.Error(errorMsg);
                    }
                    else {
                        this.state.PopCallStack();
                        if (overrideTunnelReturnTarget)
                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.BeginString:
                    this.state.PushToOutputStream(evalCommand);
                    this.Assert(this.state.inExpressionEvaluation === true, "Expected to be in an expression when evaluating a string");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EndString:
                    let contentStackForString = [];
                    let outputCountConsumed = 0;
                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
                        let obj = this.state.outputStream[i];
                        outputCountConsumed++;
                        // var command = obj as ControlCommand;
                        let command = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
                        if (command &&
                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                            break;
                        }
                        if (obj instanceof Value_1.StringValue) {
                            contentStackForString.push(obj);
                        }
                    }
                    // Consume the content that was produced for this string
                    this.state.PopFromOutputStream(outputCountConsumed);
                    // The C# version uses a Stack for contentStackForString, but we're
                    // using a simple array, so we need to reverse it before using it
                    contentStackForString = contentStackForString.reverse();
                    // Build string out of the content we collected
                    let sb = new StringBuilder_1.StringBuilder();
                    for (let c of contentStackForString) {
                        sb.Append(c.toString());
                    }
                    // Return to expression evaluation (from content mode)
                    this.state.inExpressionEvaluation = true;
                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:
                    let choiceCount = this.state.generatedChoices.length;
                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Turns:
                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:
                case ControlCommand_1.ControlCommand.CommandType.ReadCount:
                    let target = this.state.PopEvaluationStack();
                    if (!(target instanceof Value_1.DivertTargetValue)) {
                        let extraNote = "";
                        if (target instanceof Value_1.IntValue)
                            extraNote =
                                ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
                        this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw " +
                            target +
                            extraNote);
                        break;
                    }
                    // var divertTarget = target as DivertTargetValue;
                    let divertTarget = TypeAssertion_1.asOrThrows(target, Value_1.DivertTargetValue);
                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;
                    let container = TypeAssertion_1.asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);
                    let eitherCount;
                    if (container != null) {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = this.state.TurnsSinceForContainer(container);
                        else
                            eitherCount = this.state.VisitCountForContainer(container);
                    }
                    else {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = -1;
                        else
                            eitherCount = 0;
                        this.Warning("Failed to find container for " +
                            evalCommand.toString() +
                            " lookup at " +
                            divertTarget.targetPath.toString());
                    }
                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Random: {
                    let maxInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    let minInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (minInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");
                    if (maxInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (maxInt.value === null) {
                        return NullException_1.throwNullException("maxInt.value");
                    }
                    if (minInt.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    let randomRange = maxInt.value - minInt.value + 1;
                    if (randomRange <= 0)
                        this.Error("RANDOM was called with minimum as " +
                            minInt.value +
                            " and maximum as " +
                            maxInt.value +
                            ". The maximum must be larger");
                    let resultSeed = this.state.storySeed + this.state.previousRandom;
                    let random = new PRNG_1.PRNG(resultSeed);
                    let nextRandom = random.next();
                    let chosenValue = (nextRandom % randomRange) + minInt.value;
                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));
                    // Next random number (rather than keeping the Random object around)
                    this.state.previousRandom = nextRandom;
                    break;
                }
                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:
                    let seed = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (seed == null || seed instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value passed to SEED_RANDOM");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (seed.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    this.state.storySeed = seed.value;
                    this.state.previousRandom = 0;
                    this.state.PushEvaluationStack(new Void_1.Void());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:
                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count
                    this.state.PushEvaluationStack(new Value_1.IntValue(count));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:
                    let shuffleIndex = this.NextSequenceShuffleIndex();
                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.StartThread:
                    // Handled in main step function
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Done:
                    // We may exist in the context of the initial
                    // act of creating the thread, or in the context of
                    // evaluating the content.
                    if (this.state.callStack.canPopThread) {
                        this.state.callStack.PopThread();
                    }
                    // In normal flow - allow safe exit without warning
                    else {
                        this.state.didSafeExit = true;
                        // Stop flow in current thread
                        this.state.currentPointer = Pointer_1.Pointer.Null;
                    }
                    break;
                // Force flow to end completely
                case ControlCommand_1.ControlCommand.CommandType.End:
                    this.state.ForceEnd();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:
                    // var intVal = state.PopEvaluationStack () as IntValue;
                    let intVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    // var listNameVal = state.PopEvaluationStack () as StringValue;
                    let listNameVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
                    if (intVal === null) {
                        throw new StoryException_1.StoryException("Passed non-integer when creating a list element from a numerical value.");
                    }
                    let generatedListValue = null;
                    if (this.listDefinitions === null) {
                        return NullException_1.throwNullException("this.listDefinitions");
                    }
                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);
                    if (foundListDef.exists) {
                        // Originally a primitive type, but here, can be null.
                        // TODO: Replace by default value?
                        if (intVal.value === null) {
                            return NullException_1.throwNullException("minInt.value");
                        }
                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);
                        if (foundItem.exists) {
                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);
                        }
                    }
                    else {
                        throw new StoryException_1.StoryException("Failed to find LIST called " + listNameVal.value);
                    }
                    if (generatedListValue == null)
                        generatedListValue = new Value_1.ListValue();
                    this.state.PushEvaluationStack(generatedListValue);
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRange:
                    let max = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    let min = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    // var targetList = state.PopEvaluationStack () as ListValue;
                    let targetList = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.ListValue);
                    if (targetList === null || min === null || max === null)
                        throw new StoryException_1.StoryException("Expected list, minimum and maximum for LIST_RANGE");
                    if (targetList.value === null) {
                        return NullException_1.throwNullException("targetList.value");
                    }
                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);
                    this.state.PushEvaluationStack(new Value_1.ListValue(result));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {
                    let listVal = this.state.PopEvaluationStack();
                    if (listVal === null)
                        throw new StoryException_1.StoryException("Expected list for LIST_RANDOM");
                    let list = listVal.value;
                    let newList = null;
                    if (list === null) {
                        throw NullException_1.throwNullException("list");
                    }
                    if (list.Count == 0) {
                        newList = new InkList_1.InkList();
                    }
                    else {
                        // Generate a random index for the element to take
                        let resultSeed = this.state.storySeed + this.state.previousRandom;
                        let random = new PRNG_1.PRNG(resultSeed);
                        let nextRandom = random.next();
                        let listItemIndex = nextRandom % list.Count;
                        // This bit is a little different from the original
                        // C# code, since iterators do not work in the same way.
                        // First, we iterate listItemIndex - 1 times, calling next().
                        // The listItemIndex-th time is made outside of the loop,
                        // in order to retrieve the value.
                        let listEnumerator = list.entries();
                        for (let i = 0; i <= listItemIndex - 1; i++) {
                            listEnumerator.next();
                        }
                        let value = listEnumerator.next().value;
                        let randomItem = {
                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),
                            Value: value[1],
                        };
                        // Origin list is simply the origin of the one element
                        if (randomItem.Key.originName === null) {
                            return NullException_1.throwNullException("randomItem.Key.originName");
                        }
                        newList = new InkList_1.InkList(randomItem.Key.originName, this);
                        newList.Add(randomItem.Key, randomItem.Value);
                        this.state.previousRandom = nextRandom;
                    }
                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));
                    break;
                }
                default:
                    this.Error("unhandled ControlCommand: " + evalCommand);
                    break;
            }
            return true;
        }
        // Variable assignment
        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {
            let varAss = contentObj;
            let assignedVal = this.state.PopEvaluationStack();
            this.state.variablesState.Assign(varAss, assignedVal);
            return true;
        }
        // Variable reference
        else if (contentObj instanceof VariableReference_1.VariableReference) {
            let varRef = contentObj;
            let foundValue = null;
            // Explicit read count value
            if (varRef.pathForCount != null) {
                let container = varRef.containerForCount;
                let count = this.state.VisitCountForContainer(container);
                foundValue = new Value_1.IntValue(count);
            }
            // Normal variable reference
            else {
                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);
                if (foundValue == null) {
                    this.Warning("Variable not found: '" +
                        varRef.name +
                        "'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.");
                    foundValue = new Value_1.IntValue(0);
                }
            }
            this.state.PushEvaluationStack(foundValue);
            return true;
        }
        // Native function call
        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {
            let func = contentObj;
            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);
            let result = func.Call(funcParams);
            this.state.PushEvaluationStack(result);
            return true;
        }
        // No control content, must be ordinary content
        return false;
    }
    ChoosePathString(path, resetCallstack = true, args = []) {
        this.IfAsyncWeCant("call ChoosePathString right now");
        if (resetCallstack) {
            this.ResetCallstack();
        }
        else {
            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {
                let funcDetail = "";
                let container = this.state.callStack.currentElement.currentPointer
                    .container;
                if (container != null) {
                    funcDetail = "(" + container.path.toString() + ") ";
                }
                throw new Error("Story was running a function " +
                    funcDetail +
                    "when you called ChoosePathString(" +
                    path +
                    ") - this is almost certainly not not what you want! Full stack trace: \n" +
                    this.state.callStack.callStackTrace);
            }
        }
        this.state.PassArgumentsToEvaluationStack(args);
        this.ChoosePath(new Path_1.Path(path));
    }
    IfAsyncWeCant(activityStr) {
        if (this._asyncContinueActive)
            throw new Error("Can't " +
                activityStr +
                ". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.");
    }
    ChoosePath(p, incrementingTurnIndex = true) {
        this.state.SetChosenPath(p, incrementingTurnIndex);
        // Take a note of newly visited containers for read counts etc
        this.VisitChangedContainersDueToDivert();
    }
    ChooseChoiceIndex(choiceIdx) {
        choiceIdx = choiceIdx;
        let choices = this.currentChoices;
        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, "choice out of range");
        let choiceToChoose = choices[choiceIdx];
        if (choiceToChoose.threadAtGeneration === null) {
            return NullException_1.throwNullException("choiceToChoose.threadAtGeneration");
        }
        if (choiceToChoose.targetPath === null) {
            return NullException_1.throwNullException("choiceToChoose.targetPath");
        }
        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;
        this.ChoosePath(choiceToChoose.targetPath);
    }
    HasFunction(functionName) {
        try {
            return this.KnotContainerWithName(functionName) != null;
        }
        catch (e) {
            return false;
        }
    }
    EvaluateFunction(functionName, args = [], returnTextOutput = false) {
        // EvaluateFunction behaves slightly differently than the C# version.
        // In C#, you can pass a (second) parameter `out textOutput` to get the
        // text outputted by the function. This is not possible in js. Instead,
        // we maintain the regular signature (functionName, args), plus an
        // optional third parameter returnTextOutput. If set to true, we will
        // return both the textOutput and the returned value, as an object.
        this.IfAsyncWeCant("evaluate a function");
        if (functionName == null) {
            throw new Error("Function is null");
        }
        else if (functionName == "" || functionName.trim() == "") {
            throw new Error("Function is empty or white space.");
        }
        let funcContainer = this.KnotContainerWithName(functionName);
        if (funcContainer == null) {
            throw new Error("Function doesn't exist: '" + functionName + "'");
        }
        let outputStreamBefore = [];
        outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);
        this._state.ResetOutput();
        this.state.StartFunctionEvaluationFromGame(funcContainer, args);
        // Evaluate the function, and collect the string output
        let stringOutput = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            stringOutput.Append(this.Continue());
        }
        let textOutput = stringOutput.toString();
        this._state.ResetOutput(outputStreamBefore);
        let result = this.state.CompleteFunctionEvaluationFromGame();
        return returnTextOutput ? { returned: result, output: textOutput } : result;
    }
    EvaluateExpression(exprContainer) {
        let startCallStackHeight = this.state.callStack.elements.length;
        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);
        this._temporaryEvaluationContainer = exprContainer;
        this.state.GoToStart();
        let evalStackHeight = this.state.evaluationStack.length;
        this.Continue();
        this._temporaryEvaluationContainer = null;
        // Should have fallen off the end of the Container, which should
        // have auto-popped, but just in case we didn't for some reason,
        // manually pop to restore the state (including currentPath).
        if (this.state.callStack.elements.length > startCallStackHeight) {
            this.state.PopCallStack();
        }
        let endStackHeight = this.state.evaluationStack.length;
        if (endStackHeight > evalStackHeight) {
            return this.state.PopEvaluationStack();
        }
        else {
            return null;
        }
    }
    CallExternalFunction(funcName, numberOfArguments) {
        if (funcName === null) {
            return NullException_1.throwNullException("funcName");
        }
        let func = this._externals.get(funcName);
        let fallbackFunctionContainer = null;
        let foundExternal = typeof func !== "undefined";
        // Try to use fallback function?
        if (!foundExternal) {
            if (this.allowExternalFunctionFallbacks) {
                fallbackFunctionContainer = this.KnotContainerWithName(funcName);
                this.Assert(fallbackFunctionContainer !== null, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound, and fallback ink function could not be found.");
                // Divert direct into fallback function and we're done
                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);
                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);
                return;
            }
            else {
                this.Assert(false, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound (and ink fallbacks disabled).");
            }
        }
        // Pop arguments
        let args = [];
        for (let i = 0; i < numberOfArguments; ++i) {
            // var poppedObj = state.PopEvaluationStack () as Value;
            let poppedObj = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.Value);
            let valueObj = poppedObj.valueObject;
            args.push(valueObj);
        }
        // Reverse arguments from the order they were popped,
        // so they're the right way round again.
        args.reverse();
        // Run the function!
        let funcResult = func(args);
        // Convert return value (if any) to the a type that the ink engine can use
        let returnObj = null;
        if (funcResult != null) {
            returnObj = Value_1.Value.Create(funcResult);
            this.Assert(returnObj !== null, "Could not create ink value from returned object of type " +
                typeof funcResult);
        }
        else {
            returnObj = new Void_1.Void();
        }
        this.state.PushEvaluationStack(returnObj);
    }
    BindExternalFunctionGeneral(funcName, func) {
        this.IfAsyncWeCant("bind an external function");
        this.Assert(!this._externals.has(funcName), "Function '" + funcName + "' has already been bound.");
        this._externals.set(funcName, func);
    }
    TryCoerce(value) {
        // We're skipping type coercition in this implementation. First of, js
        // is loosely typed, so it's not that important. Secondly, there is no
        // clean way (AFAIK) for the user to describe what type of parameters
        // they expect.
        return value;
    }
    BindExternalFunction(funcName, func) {
        this.Assert(func != null, "Can't bind a null function");
        this.BindExternalFunctionGeneral(funcName, (args) => {
            this.Assert(args.length >= func.length, "External function expected " + func.length + " arguments");
            let coercedArgs = [];
            for (let i = 0, l = args.length; i < l; i++) {
                coercedArgs[i] = this.TryCoerce(args[i]);
            }
            return func.apply(null, coercedArgs);
        });
    }
    UnbindExternalFunction(funcName) {
        this.IfAsyncWeCant("unbind an external a function");
        this.Assert(this._externals.has(funcName), "Function '" + funcName + "' has not been bound.");
        this._externals.delete(funcName);
    }
    ValidateExternalBindings() {
        let c = null;
        let o = null;
        let missingExternals = arguments[1] || new Set();
        if (arguments[0] instanceof Container_1.Container) {
            c = arguments[0];
        }
        if (arguments[0] instanceof Object_1.InkObject) {
            o = arguments[0];
        }
        if (c === null && o === null) {
            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);
            this._hasValidatedExternals = true;
            // No problem! Validation complete
            if (missingExternals.size == 0) {
                this._hasValidatedExternals = true;
            }
            else {
                let message = "Error: Missing function binding for external";
                message += missingExternals.size > 1 ? "s" : "";
                message += ": '";
                message += Array.from(missingExternals).join("', '");
                message += "' ";
                message += this.allowExternalFunctionFallbacks
                    ? ", and no fallback ink function found."
                    : " (ink fallbacks disabled)";
                this.Error(message);
            }
        }
        else if (c != null) {
            for (let innerContent of c.content) {
                let container = innerContent;
                if (container == null || !container.hasValidName)
                    this.ValidateExternalBindings(innerContent, missingExternals);
            }
            for (let [, value] of c.namedContent) {
                this.ValidateExternalBindings(TypeAssertion_1.asOrNull(value, Object_1.InkObject), missingExternals);
            }
        }
        else if (o != null) {
            let divert = TypeAssertion_1.asOrNull(o, Divert_1.Divert);
            if (divert && divert.isExternal) {
                let name = divert.targetPathString;
                if (name === null) {
                    return NullException_1.throwNullException("name");
                }
                if (!this._externals.has(name)) {
                    if (this.allowExternalFunctionFallbacks) {
                        let fallbackFound = this.mainContentContainer.namedContent.has(name);
                        if (!fallbackFound) {
                            missingExternals.add(name);
                        }
                    }
                    else {
                        missingExternals.add(name);
                    }
                }
            }
        }
    }
    ObserveVariable(variableName, observer) {
        this.IfAsyncWeCant("observe a new variable");
        if (this._variableObservers === null)
            this._variableObservers = new Map();
        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))
            throw new StoryException_1.StoryException("Cannot observe variable '" +
                variableName +
                "' because it wasn't declared in the ink story.");
        if (this._variableObservers.has(variableName)) {
            this._variableObservers.get(variableName).push(observer);
        }
        else {
            this._variableObservers.set(variableName, [observer]);
        }
    }
    ObserveVariables(variableNames, observers) {
        for (let i = 0, l = variableNames.length; i < l; i++) {
            this.ObserveVariable(variableNames[i], observers[i]);
        }
    }
    RemoveVariableObserver(observer, specificVariableName) {
        this.IfAsyncWeCant("remove a variable observer");
        if (this._variableObservers === null)
            return;
        if (typeof specificVariableName !== "undefined") {
            if (this._variableObservers.has(specificVariableName)) {
                let observers = this._variableObservers.get(specificVariableName);
                if (observer !== null) {
                    observers.splice(observers.indexOf(observer), 1);
                }
                else {
                    this._variableObservers.delete(specificVariableName);
                }
            }
        }
        else if (observer !== null) {
            let keys = this._variableObservers.keys();
            for (let varName of keys) {
                let observers = this._variableObservers.get(varName);
                observers.splice(observers.indexOf(observer), 1);
            }
        }
    }
    VariableStateDidChangeEvent(variableName, newValueObj) {
        if (this._variableObservers === null)
            return;
        let observers = this._variableObservers.get(variableName);
        if (typeof observers !== "undefined") {
            if (!(newValueObj instanceof Value_1.Value)) {
                throw new Error("Tried to get the value of a variable that isn't a standard type");
            }
            // var val = newValueObj as Value;
            let val = TypeAssertion_1.asOrThrows(newValueObj, Value_1.Value);
            for (let observer of observers) {
                observer(variableName, val.valueObject);
            }
        }
    }
    get globalTags() {
        return this.TagsAtStartOfFlowContainerWithPathString("");
    }
    TagsForContentAtPath(path) {
        return this.TagsAtStartOfFlowContainerWithPathString(path);
    }
    TagsAtStartOfFlowContainerWithPathString(pathString) {
        let path = new Path_1.Path(pathString);
        let flowContainer = this.ContentAtPath(path).container;
        if (flowContainer === null) {
            return NullException_1.throwNullException("flowContainer");
        }
        while (true) {
            let firstContent = flowContainer.content[0];
            if (firstContent instanceof Container_1.Container)
                flowContainer = firstContent;
            else
                break;
        }
        let tags = null;
        for (let c of flowContainer.content) {
            // var tag = c as Runtime.Tag;
            let tag = TypeAssertion_1.asOrNull(c, Tag_1.Tag);
            if (tag) {
                if (tags == null)
                    tags = [];
                tags.push(tag.text);
            }
            else
                break;
        }
        return tags;
    }
    BuildStringOfHierarchy() {
        let sb = new StringBuilder_1.StringBuilder();
        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    BuildStringOfContainer(container) {
        let sb = new StringBuilder_1.StringBuilder();
        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    NextContent() {
        this.state.previousPointer = this.state.currentPointer.copy();
        if (!this.state.divertedPointer.isNull) {
            this.state.currentPointer = this.state.divertedPointer.copy();
            this.state.divertedPointer = Pointer_1.Pointer.Null;
            this.VisitChangedContainersDueToDivert();
            if (!this.state.currentPointer.isNull) {
                return;
            }
        }
        let successfulPointerIncrement = this.IncrementContentPointer();
        if (!successfulPointerIncrement) {
            let didPop = false;
            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {
                this.state.PopCallStack(PushPop_1.PushPopType.Function);
                if (this.state.inExpressionEvaluation) {
                    this.state.PushEvaluationStack(new Void_1.Void());
                }
                didPop = true;
            }
            else if (this.state.callStack.canPopThread) {
                this.state.callStack.PopThread();
                didPop = true;
            }
            else {
                this.state.TryExitFunctionEvaluationFromGame();
            }
            if (didPop && !this.state.currentPointer.isNull) {
                this.NextContent();
            }
        }
    }
    IncrementContentPointer() {
        let successfulIncrement = true;
        let pointer = this.state.callStack.currentElement.currentPointer.copy();
        pointer.index++;
        if (pointer.container === null) {
            return NullException_1.throwNullException("pointer.container");
        }
        while (pointer.index >= pointer.container.content.length) {
            successfulIncrement = false;
            // Container nextAncestor = pointer.container.parent as Container;
            let nextAncestor = TypeAssertion_1.asOrNull(pointer.container.parent, Container_1.Container);
            if (nextAncestor instanceof Container_1.Container === false) {
                break;
            }
            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);
            if (indexInAncestor == -1) {
                break;
            }
            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);
            pointer.index++;
            successfulIncrement = true;
            if (pointer.container === null) {
                return NullException_1.throwNullException("pointer.container");
            }
        }
        if (!successfulIncrement)
            pointer = Pointer_1.Pointer.Null;
        this.state.callStack.currentElement.currentPointer = pointer.copy();
        return successfulIncrement;
    }
    TryFollowDefaultInvisibleChoice() {
        let allChoices = this._state.currentChoices;
        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);
        if (invisibleChoices.length == 0 ||
            allChoices.length > invisibleChoices.length)
            return false;
        let choice = invisibleChoices[0];
        if (choice.targetPath === null) {
            return NullException_1.throwNullException("choice.targetPath");
        }
        if (choice.threadAtGeneration === null) {
            return NullException_1.throwNullException("choice.threadAtGeneration");
        }
        this.state.callStack.currentThread = choice.threadAtGeneration;
        this.ChoosePath(choice.targetPath, false);
        return true;
    }
    NextSequenceShuffleIndex() {
        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;
        let numElementsIntVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
        if (!(numElementsIntVal instanceof Value_1.IntValue)) {
            this.Error("expected number of elements in sequence for shuffle index");
            return 0;
        }
        let seqContainer = this.state.currentPointer.container;
        if (seqContainer === null) {
            return NullException_1.throwNullException("seqContainer");
        }
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (numElementsIntVal.value === null) {
            return NullException_1.throwNullException("numElementsIntVal.value");
        }
        let numElements = numElementsIntVal.value;
        // var seqCountVal = state.PopEvaluationStack () as IntValue;
        let seqCountVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.IntValue);
        let seqCount = seqCountVal.value;
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (seqCount === null) {
            return NullException_1.throwNullException("seqCount");
        }
        let loopIndex = seqCount / numElements;
        let iterationIndex = seqCount % numElements;
        let seqPathStr = seqContainer.path.toString();
        let sequenceHash = 0;
        for (let i = 0, l = seqPathStr.length; i < l; i++) {
            sequenceHash += seqPathStr.charCodeAt(i) || 0;
        }
        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;
        let random = new PRNG_1.PRNG(Math.floor(randomSeed));
        let unpickedIndices = [];
        for (let i = 0; i < numElements; ++i) {
            unpickedIndices.push(i);
        }
        for (let i = 0; i <= iterationIndex; ++i) {
            let chosen = random.next() % unpickedIndices.length;
            let chosenIndex = unpickedIndices[chosen];
            unpickedIndices.splice(chosen, 1);
            if (i == iterationIndex) {
                return chosenIndex;
            }
        }
        throw new Error("Should never reach here");
    }
    Error(message, useEndLineNumber = false) {
        let e = new StoryException_1.StoryException(message);
        e.useEndLineNumber = useEndLineNumber;
        throw e;
    }
    Warning(message) {
        this.AddError(message, true);
    }
    AddError(message, isWarning = false, useEndLineNumber = false) {
        let dm = this.currentDebugMetadata;
        let errorTypeStr = isWarning ? "WARNING" : "ERROR";
        if (dm != null) {
            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": '" +
                    dm.fileName +
                    "' line " +
                    lineNum +
                    ": " +
                    message;
        }
        else if (!this.state.currentPointer.isNull) {
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": (" +
                    this.state.currentPointer +
                    "): " +
                    message;
        }
        else {
            message = "RUNTIME " + errorTypeStr + ": " + message;
        }
        this.state.AddError(message, isWarning);
        // In a broken state don't need to know about any other errors.
        if (!isWarning)
            this.state.ForceEnd();
    }
    Assert(condition, message = null) {
        if (condition == false) {
            if (message == null) {
                message = "Story assert";
            }
            throw new Error(message + " " + this.currentDebugMetadata);
        }
    }
    get currentDebugMetadata() {
        let dm;
        let pointer = this.state.currentPointer;
        if (!pointer.isNull && pointer.Resolve() !== null) {
            dm = pointer.Resolve().debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {
            pointer = this.state.callStack.elements[i].currentPointer;
            if (!pointer.isNull && pointer.Resolve() !== null) {
                dm = pointer.Resolve().debugMetadata;
                if (dm !== null) {
                    return dm;
                }
            }
        }
        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
            let outputObj = this.state.outputStream[i];
            dm = outputObj.debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        return null;
    }
    get mainContentContainer() {
        if (this._temporaryEvaluationContainer) {
            return this._temporaryEvaluationContainer;
        }
        else {
            return this._mainContentContainer;
        }
    }
}
exports.Story = Story;
Story.inkVersionCurrent = 19;
(function (Story) {
    let OutputStateChange;
    (function (OutputStateChange) {
        OutputStateChange[OutputStateChange["NoChange"] = 0] = "NoChange";
        OutputStateChange[OutputStateChange["ExtendedBeyondNewline"] = 1] = "ExtendedBeyondNewline";
        OutputStateChange[OutputStateChange["NewlineRemoved"] = 2] = "NewlineRemoved";
    })(OutputStateChange = Story.OutputStateChange || (Story.OutputStateChange = {}));
})(Story = exports.Story || (exports.Story = {}));
//# sourceMappingURL=Story.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryException.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryException.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryException = void 0;
class StoryException extends Error {
    constructor(message) {
        super(message);
        this.useEndLineNumber = false;
        this.message = message;
        this.name = "StoryException";
    }
}
exports.StoryException = StoryException;
//# sourceMappingURL=StoryException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryState.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryState.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryState = void 0;
const CallStack_1 = __webpack_require__(/*! ./CallStack */ "./node_modules/inkjs/engine/CallStack.js");
const VariablesState_1 = __webpack_require__(/*! ./VariablesState */ "./node_modules/inkjs/engine/VariablesState.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StatePatch_1 = __webpack_require__(/*! ./StatePatch */ "./node_modules/inkjs/engine/StatePatch.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this._patch = null;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this.currentTurnIndex = -1;
        let timeSeed = new Date().getTime();
        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        let writer = new SimpleJson_1.SimpleJson.Writer();
        this.WriteJson(writer);
        return writer.ToString();
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);
        this.LoadJsonObj(jObject);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut;
        if (this._patch !== null) {
            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;
            if (container === null)
                throw new Error("Content at path not found: " + pathString);
            visitCountOut = this._patch.TryGetVisitCount(container, 0);
            if (visitCountOut.exists)
                return visitCountOut.result;
        }
        visitCountOut = TryGetResult_1.tryGetValueFromMap(this._visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    VisitCountForContainer(container) {
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        if (!container.visitsShouldBeCounted) {
            this.story.Error("Read count for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
            return 0;
        }
        if (this._patch !== null) {
            let count = this._patch.TryGetVisitCount(container, 0);
            if (count.exists) {
                return count.result;
            }
        }
        let containerPathStr = container.path.toString();
        let count2 = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count2.exists) {
            return count2.result;
        }
        return 0;
    }
    IncrementVisitCountForContainer(container) {
        if (this._patch !== null) {
            let currCount = this.VisitCountForContainer(container);
            currCount++;
            this._patch.SetVisitCount(container, currCount);
            return;
        }
        let containerPathStr = container.path.toString();
        let count = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count.exists) {
            this._visitCounts.set(containerPathStr, count.result + 1);
        }
        else {
            this._visitCounts.set(containerPathStr, 1);
        }
    }
    RecordTurnIndexVisitToContainer(container) {
        if (this._patch !== null) {
            this._patch.SetTurnIndex(container, this.currentTurnIndex);
            return;
        }
        let containerPathStr = container.path.toString();
        this._turnIndices.set(containerPathStr, this.currentTurnIndex);
    }
    TurnsSinceForContainer(container) {
        if (!container.turnIndexShouldBeCounted) {
            this.story.Error("TURNS_SINCE() for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
        }
        if (this._patch !== null) {
            let index = this._patch.TryGetTurnIndex(container, 0);
            if (index.exists) {
                return this.currentTurnIndex - index.result;
            }
        }
        let containerPathStr = container.path.toString();
        let index2 = TryGetResult_1.tryGetValueFromMap(this._turnIndices, containerPathStr, 0);
        if (index2.exists) {
            return this.currentTurnIndex - index2.result;
        }
        else {
            return -1;
        }
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    set variablesState(value) {
        this._variablesState = value;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    set currentTurnIndex(value) {
        this._currentTurnIndex = value;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException("pointer.path");
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = c == " " || c == "\t";
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != "\n" &&
                    currentWhitespaceStart > 0 &&
                    currentWhitespaceStart != startOfLine) {
                    sb.Append(" ");
                }
                currentWhitespaceStart = -1;
            }
            if (c == "\n")
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    CopyAndStartPatching() {
        let copy = new StoryState(this.story);
        copy._patch = new StatePatch_1.StatePatch(this._patch);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        copy.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy.variablesState = this.variablesState;
        copy.variablesState.callStack = copy.callStack;
        copy.variablesState.patch = copy._patch;
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = this._visitCounts;
        copy._turnIndices = this._turnIndices;
        copy.currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    RestoreAfterPatch() {
        this.variablesState.callStack = this.callStack;
        this.variablesState.patch = this._patch;
    }
    ApplyAnyPatch() {
        if (this._patch === null)
            return;
        this.variablesState.ApplyPatch();
        for (let [key, value] of this._patch.visitCounts)
            this.ApplyCountChanges(key, value, true);
        for (let [key, value] of this._patch.turnIndices)
            this.ApplyCountChanges(key, value, false);
        this._patch = null;
    }
    ApplyCountChanges(container, newCount, isVisit) {
        let counts = isVisit ? this._visitCounts : this._turnIndices;
        counts.set(container.path.toString(), newCount);
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        let hasChoiceThreads = false;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException("c.threadAtGeneration");
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {
                if (!hasChoiceThreads) {
                    hasChoiceThreads = true;
                    writer.WritePropertyStart("choiceThreads");
                    writer.WriteObjectStart();
                }
                writer.WritePropertyStart(c.originalThreadIndex);
                c.threadAtGeneration.WriteJson(writer);
                writer.WritePropertyEnd();
            }
        }
        if (hasChoiceThreads) {
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        // In the following two calls, `WriteJson` is called inside an arrow
        // function to make sure `this` is correctly bound and passed down
        // the call hierarchy.
        writer.WriteProperty("callstackThreads", (w) => this.callStack.WriteJson(w));
        writer.WriteProperty("variablesState", (w) => this.variablesState.WriteJson(w));
        writer.WriteProperty("evalStack", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));
        writer.WriteProperty("outputStream", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream));
        writer.WriteProperty("currentChoices", (w) => {
            w.WriteArrayStart();
            for (let c of this._currentChoices)
                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);
            w.WriteArrayEnd();
        });
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException("divertedPointer");
            }
            writer.WriteProperty("currentDivertTarget", this.divertedPointer.path.componentsString);
        }
        writer.WriteProperty("visitCounts", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));
        writer.WriteProperty("turnIndices", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));
        writer.WriteIntProperty("turnIdx", this.currentTurnIndex);
        writer.WriteIntProperty("storySeed", this.storySeed);
        writer.WriteIntProperty("previousRandom", this.previousRandom);
        writer.WriteIntProperty("inkSaveVersion", this.kInkSaveStateVersion);
        writer.WriteIntProperty("inkFormatVersion", Story_1.Story.inkVersionCurrent);
        writer.WriteObjectEnd();
    }
    LoadJsonObj(value) {
        let jObject = value;
        let jSaveVersion = jObject["inkSaveVersion"];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" +
                jSaveVersion +
                "', but minimum is " +
                this.kMinCompatibleLoadVersion +
                "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject["callstackThreads"], this.story);
        this.variablesState.SetJsonToken(jObject["variablesState"]);
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);
        let currentDivertTargetPath = jObject["currentDivertTarget"];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);
        this.currentTurnIndex = parseInt(jObject["turnIdx"]);
        this.storySeed = parseInt(jObject["storySeed"]);
        this.previousRandom = parseInt(jObject["previousRandom"]);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject["choiceThreads"];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException("single.value");
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue("\n"));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue("\n"));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = str.length - tailLastNewlineIdx - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;
                let g = o instanceof Glue_1.Glue ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null &&
                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException("obj");
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand &&
                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException("rawList");
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException("StoryState.story.listDefinitions");
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException("StoryState def.result");
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException("obj");
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === "undefined") {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error("trying to pop too many objects");
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement
            .functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex) {
            this.currentTurnIndex++;
        }
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === "number" || typeof args[i] === "string")) {
                    throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type ==
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type !=
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException("Expected external function evaluation to be complete. Stack trace: " +
                this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement
            .evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StringBuilder.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/StringBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StringBuilder = void 0;
class StringBuilder {
    constructor(str) {
        str = typeof str !== "undefined" ? str.toString() : "";
        this.string = str;
    }
    get Length() {
        return this.string.length;
    }
    Append(str) {
        if (str !== null) {
            this.string += str;
        }
    }
    AppendLine(str) {
        if (typeof str !== "undefined")
            this.Append(str);
        this.string += "\n";
    }
    AppendFormat(format, ...args) {
        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format
        this.string += format.replace(/{(\d+)}/g, (match, num) => typeof args[num] != "undefined" ? args[num] : match);
    }
    toString() {
        return this.string;
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Tag.js":
/*!******************************************!*\
  !*** ./node_modules/inkjs/engine/Tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Tag extends Object_1.InkObject {
    constructor(tagText) {
        super();
        this.text = tagText.toString() || "";
    }
    toString() {
        return "# " + this.text;
    }
}
exports.Tag = Tag;
//# sourceMappingURL=Tag.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TryGetResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/TryGetResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseFloat = exports.tryParseInt = exports.tryGetValueFromMap = void 0;
function tryGetValueFromMap(map, key, 
/* out */ value) {
    if (map === null) {
        return { result: value, exists: false };
    }
    let val = map.get(key);
    if (typeof val === "undefined") {
        return { result: value, exists: false };
    }
    else {
        return { result: val, exists: true };
    }
}
exports.tryGetValueFromMap = tryGetValueFromMap;
function tryParseInt(value, 
/* out */ defaultValue = 0) {
    let val = parseInt(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseInt = tryParseInt;
function tryParseFloat(value, 
/* out */ defaultValue = 0) {
    let val = parseFloat(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseFloat = tryParseFloat;
//# sourceMappingURL=TryGetResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TypeAssertion.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/TypeAssertion.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isEquatable = exports.nullIfUndefined = exports.asINamedContentOrNull = exports.asNumberOrThrows = exports.asOrThrows = exports.asOrNull = void 0;
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === "number") {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === "undefined") {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function isEquatable(type) {
    return typeof type === "object" && typeof type.Equals === "function";
}
exports.isEquatable = isEquatable;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Value.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Value.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = exports.ListValue = exports.VariablePointerValue = exports.DivertTargetValue = exports.StringValue = exports.FloatValue = exports.IntValue = exports.Value = exports.AbstractValue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class AbstractValue extends Object_1.InkObject {
    static Create(val, preferredNumberType) {
        // This code doesn't exist in upstream and is simply here to enforce
        // the creation of the proper number value.
        // If `preferredNumberType` is not provided or if value doesn't match
        // `preferredNumberType`, this conditional does nothing.
        if (preferredNumberType) {
            if (preferredNumberType === ValueType.Int &&
                Number.isInteger(Number(val))) {
                return new IntValue(Number(val));
            }
            else if (preferredNumberType === ValueType.Float &&
                !isNaN(val)) {
                return new FloatValue(Number(val));
            }
        }
        // Implicitly convert bools into ints
        if (typeof val === "boolean") {
            let b = !!val;
            val = b ? 1 : 0;
        }
        // https://github.com/y-lohse/inkjs/issues/425
        // Changed condition sequence, because Number('') is
        // parsed to 0, which made setting string to empty
        // impossible
        if (typeof val === "string") {
            return new StringValue(String(val));
        }
        else if (Number.isInteger(Number(val))) {
            return new IntValue(Number(val));
        }
        else if (!isNaN(val)) {
            return new FloatValue(Number(val));
        }
        else if (val instanceof Path_1.Path) {
            return new DivertTargetValue(TypeAssertion_1.asOrThrows(val, Path_1.Path));
        }
        else if (val instanceof InkList_1.InkList) {
            return new ListValue(TypeAssertion_1.asOrThrows(val, InkList_1.InkList));
        }
        return null;
    }
    Copy() {
        return TypeAssertion_1.asOrThrows(AbstractValue.Create(this), Object_1.InkObject);
    }
    BadCastException(targetType) {
        return new StoryException_1.StoryException("Can't cast " +
            this.valueObject +
            " from " +
            this.valueType +
            " to " +
            targetType);
    }
}
exports.AbstractValue = AbstractValue;
class Value extends AbstractValue {
    constructor(val) {
        super();
        this.value = val;
    }
    get valueObject() {
        return this.value;
    }
    toString() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.toString();
    }
}
exports.Value = Value;
class IntValue extends Value {
    constructor(val) {
        super(val || 0);
    }
    get isTruthy() {
        return this.value != 0;
    }
    get valueType() {
        return ValueType.Int;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Float) {
            return new FloatValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.IntValue = IntValue;
class FloatValue extends Value {
    constructor(val) {
        super(val || 0.0);
    }
    get isTruthy() {
        return this.value != 0.0;
    }
    get valueType() {
        return ValueType.Float;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            return new IntValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.FloatValue = FloatValue;
class StringValue extends Value {
    constructor(val) {
        super(val || "");
        this._isNewline = this.value == "\n";
        this._isInlineWhitespace = true;
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (this.value.length > 0) {
            this.value.split("").every((c) => {
                if (c != " " && c != "\t") {
                    this._isInlineWhitespace = false;
                    return false;
                }
                return true;
            });
        }
    }
    get valueType() {
        return ValueType.String;
    }
    get isTruthy() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.length > 0;
    }
    get isNewline() {
        return this._isNewline;
    }
    get isInlineWhitespace() {
        return this._isInlineWhitespace;
    }
    get isNonWhitespace() {
        return !this.isNewline && !this.isInlineWhitespace;
    }
    Cast(newType) {
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            let parsedInt = TryGetResult_1.tryParseInt(this.value);
            if (parsedInt.exists) {
                return new IntValue(parsedInt.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        if (newType == ValueType.Float) {
            let parsedFloat = TryGetResult_1.tryParseFloat(this.value);
            if (parsedFloat.exists) {
                return new FloatValue(parsedFloat.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        throw this.BadCastException(newType);
    }
}
exports.StringValue = StringValue;
class DivertTargetValue extends Value {
    constructor(targetPath) {
        super(targetPath);
    }
    get valueType() {
        return ValueType.DivertTarget;
    }
    get targetPath() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set targetPath(value) {
        this.value = value;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a divert target");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "DivertTargetValue(" + this.targetPath + ")";
    }
}
exports.DivertTargetValue = DivertTargetValue;
class VariablePointerValue extends Value {
    constructor(variableName, contextIndex = -1) {
        super(variableName);
        this._contextIndex = contextIndex;
    }
    get contextIndex() {
        return this._contextIndex;
    }
    set contextIndex(value) {
        this._contextIndex = value;
    }
    get variableName() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set variableName(value) {
        this.value = value;
    }
    get valueType() {
        return ValueType.VariablePointer;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a variable pointer");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "VariablePointerValue(" + this.variableName + ")";
    }
    Copy() {
        return new VariablePointerValue(this.variableName, this.contextIndex);
    }
}
exports.VariablePointerValue = VariablePointerValue;
class ListValue extends Value {
    get isTruthy() {
        if (this.value === null) {
            return NullException_1.throwNullException("this.value");
        }
        return this.value.Count > 0;
    }
    get valueType() {
        return ValueType.List;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == ValueType.Int) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new IntValue(0);
            else
                return new IntValue(max.Value);
        }
        else if (newType == ValueType.Float) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new FloatValue(0.0);
            else
                return new FloatValue(max.Value);
        }
        else if (newType == ValueType.String) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new StringValue("");
            else {
                return new StringValue(max.Key.toString());
            }
        }
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    constructor(listOrSingleItem, singleValue) {
        super(null);
        if (!listOrSingleItem && !singleValue) {
            this.value = new InkList_1.InkList();
        }
        else if (listOrSingleItem instanceof InkList_1.InkList) {
            this.value = new InkList_1.InkList(listOrSingleItem);
        }
        else if (listOrSingleItem instanceof InkList_1.InkListItem &&
            typeof singleValue === "number") {
            this.value = new InkList_1.InkList({
                Key: listOrSingleItem,
                Value: singleValue,
            });
        }
    }
    static RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrNull(oldValue, ListValue);
        let newList = TypeAssertion_1.asOrNull(newValue, ListValue);
        if (newList && newList.value === null)
            return NullException_1.throwNullException("newList.value");
        if (oldList && oldList.value === null)
            return NullException_1.throwNullException("oldList.value");
        // When assigning the empty list, try to retain any initial origin names
        if (oldList && newList && newList.value.Count == 0)
            newList.value.SetInitialOriginNames(oldList.value.originNames);
    }
}
exports.ListValue = ListValue;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 0] = "Int";
    ValueType[ValueType["Float"] = 1] = "Float";
    ValueType[ValueType["List"] = 2] = "List";
    ValueType[ValueType["String"] = 3] = "String";
    ValueType[ValueType["DivertTarget"] = 4] = "DivertTarget";
    ValueType[ValueType["VariablePointer"] = 5] = "VariablePointer";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=Value.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableAssignment.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableAssignment.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableAssignment = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class VariableAssignment extends Object_1.InkObject {
    constructor(variableName, isNewDeclaration) {
        super();
        this.variableName = variableName || null;
        this.isNewDeclaration = !!isNewDeclaration;
        this.isGlobal = false;
    }
    toString() {
        return "VarAssign to " + this.variableName;
    }
}
exports.VariableAssignment = VariableAssignment;
//# sourceMappingURL=VariableAssignment.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableReference.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableReference.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReference = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class VariableReference extends Object_1.InkObject {
    constructor(name = null) {
        super();
        this.pathForCount = null;
        this.name = name;
    }
    get containerForCount() {
        if (this.pathForCount === null)
            return null;
        return this.ResolvePath(this.pathForCount).container;
    }
    get pathStringForCount() {
        if (this.pathForCount === null)
            return null;
        return this.CompactPathString(this.pathForCount);
    }
    set pathStringForCount(value) {
        if (value === null)
            this.pathForCount = null;
        else
            this.pathForCount = new Path_1.Path(value);
    }
    toString() {
        if (this.name != null) {
            return "var(" + this.name + ")";
        }
        else {
            let pathStr = this.pathStringForCount;
            return "read_count(" + pathStr + ")";
        }
    }
}
exports.VariableReference = VariableReference;
//# sourceMappingURL=VariableReference.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariablesState.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/VariablesState.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesState = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class VariablesState {
    constructor(callStack, listDefsOrigin) {
        // The way variableChangedEvent is a bit different than the reference implementation.
        // Originally it uses the C# += operator to add delegates, but in js we need to maintain
        // an actual collection of delegates (ie. callbacks) to register a new one, there is a
        // special ObserveVariableChange method below.
        this.variableChangedEventCallbacks = [];
        this.patch = null;
        this._batchObservingVariableChanges = false;
        this._defaultGlobalVariables = new Map();
        this._changedVariablesForBatchObs = new Set();
        this._globalVariables = new Map();
        this._callStack = callStack;
        this._listDefsOrigin = listDefsOrigin;
        // if es6 proxies are available, use them.
        try {
            // the proxy is used to allow direct manipulation of global variables.
            // It first tries to access the objects own property, and if none is
            // found it delegates the call to the $ method, defined below
            let p = new Proxy(this, {
                get(target, name) {
                    return name in target ? target[name] : target.$(name);
                },
                set(target, name, value) {
                    if (name in target)
                        target[name] = value;
                    else
                        target.$(name, value);
                    return true; // returning a falsy value make the trap fail
                },
            });
            return p;
        }
        catch (e) {
            // thr proxy object is not available in this context. we should warn the
            // dev but writting to the console feels a bit intrusive.
            // console.log("ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.");
        }
    }
    variableChangedEvent(variableName, newValue) {
        for (let callback of this.variableChangedEventCallbacks) {
            callback(variableName, newValue);
        }
    }
    get batchObservingVariableChanges() {
        return this._batchObservingVariableChanges;
    }
    set batchObservingVariableChanges(value) {
        this._batchObservingVariableChanges = value;
        if (value) {
            this._changedVariablesForBatchObs = new Set();
        }
        else {
            if (this._changedVariablesForBatchObs != null) {
                for (let variableName of this._changedVariablesForBatchObs) {
                    let currentValue = this._globalVariables.get(variableName);
                    if (!currentValue) {
                        NullException_1.throwNullException("currentValue");
                    }
                    else {
                        this.variableChangedEvent(variableName, currentValue);
                    }
                }
                this._changedVariablesForBatchObs = null;
            }
        }
    }
    get callStack() {
        return this._callStack;
    }
    set callStack(callStack) {
        this._callStack = callStack;
    }
    // the original code uses a magic getter and setter for global variables,
    // allowing things like variableState['varname]. This is not quite possible
    // in js without a Proxy, so it is replaced with this $ function.
    $(variableName, value) {
        if (typeof value === "undefined") {
            let varContents = null;
            if (this.patch !== null) {
                varContents = this.patch.TryGetGlobal(variableName, null);
                if (varContents.exists)
                    return varContents.result.valueObject;
            }
            varContents = this._globalVariables.get(variableName);
            if (typeof varContents === "undefined") {
                varContents = this._defaultGlobalVariables.get(variableName);
            }
            if (typeof varContents !== "undefined")
                return varContents.valueObject;
            else
                return null;
        }
        else {
            if (typeof this._defaultGlobalVariables.get(variableName) === "undefined")
                throw new StoryException_1.StoryException("Cannot assign to a variable (" +
                    variableName +
                    ") that hasn't been declared in the story");
            let val = Value_1.Value.Create(value);
            if (val == null) {
                if (value == null) {
                    throw new StoryException_1.StoryException("Cannot pass null to VariableState");
                }
                else {
                    throw new StoryException_1.StoryException("Invalid value passed to VariableState: " + value.toString());
                }
            }
            this.SetGlobal(variableName, val);
        }
    }
    ApplyPatch() {
        if (this.patch === null) {
            return NullException_1.throwNullException("this.patch");
        }
        for (let [namedVarKey, namedVarValue] of this.patch.globals) {
            this._globalVariables.set(namedVarKey, namedVarValue);
        }
        if (this._changedVariablesForBatchObs !== null) {
            for (let name of this.patch.changedVariables) {
                this._changedVariablesForBatchObs.add(name);
            }
        }
        this.patch = null;
    }
    SetJsonToken(jToken) {
        this._globalVariables.clear();
        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {
            let loadedToken = jToken[varValKey];
            if (typeof loadedToken !== "undefined") {
                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);
                if (tokenInkObject === null) {
                    return NullException_1.throwNullException("tokenInkObject");
                }
                this._globalVariables.set(varValKey, tokenInkObject);
            }
            else {
                this._globalVariables.set(varValKey, varValValue);
            }
        }
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        for (let [keyValKey, keyValValue] of this._globalVariables) {
            let name = keyValKey;
            let val = keyValValue;
            if (VariablesState.dontSaveDefaultValues) {
                if (this._defaultGlobalVariables.has(name)) {
                    let defaultVal = this._defaultGlobalVariables.get(name);
                    if (this.RuntimeObjectsEqual(val, defaultVal))
                        continue;
                }
            }
            writer.WritePropertyStart(name);
            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    RuntimeObjectsEqual(obj1, obj2) {
        if (obj1 === null) {
            return NullException_1.throwNullException("obj1");
        }
        if (obj2 === null) {
            return NullException_1.throwNullException("obj2");
        }
        if (obj1.constructor !== obj2.constructor)
            return false;
        let intVal = TypeAssertion_1.asOrNull(obj1, Value_1.IntValue);
        if (intVal !== null) {
            return intVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.IntValue).value;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj1, Value_1.FloatValue);
        if (floatVal !== null) {
            return floatVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.FloatValue).value;
        }
        let val1 = TypeAssertion_1.asOrNull(obj1, Value_1.Value);
        let val2 = TypeAssertion_1.asOrNull(obj2, Value_1.Value);
        if (val1 !== null && val2 !== null) {
            if (TypeAssertion_1.isEquatable(val1.valueObject) && TypeAssertion_1.isEquatable(val2.valueObject)) {
                return val1.valueObject.Equals(val2.valueObject);
            }
            else {
                return val1.valueObject === val2.valueObject;
            }
        }
        throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: " +
            obj1.constructor.name);
    }
    GetVariableWithName(name, contextIndex = -1) {
        let varValue = this.GetRawVariableWithName(name, contextIndex);
        // var varPointer = varValue as VariablePointerValue;
        let varPointer = TypeAssertion_1.asOrNull(varValue, Value_1.VariablePointerValue);
        if (varPointer !== null) {
            varValue = this.ValueAtVariablePointer(varPointer);
        }
        return varValue;
    }
    TryGetDefaultVariableValue(name) {
        let val = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
        return val.exists ? val.result : null;
    }
    GlobalVariableExistsWithName(name) {
        return (this._globalVariables.has(name) ||
            (this._defaultGlobalVariables !== null &&
                this._defaultGlobalVariables.has(name)));
    }
    GetRawVariableWithName(name, contextIndex) {
        let varValue = null;
        if (contextIndex == 0 || contextIndex == -1) {
            let variableValue = null;
            if (this.patch !== null) {
                variableValue = this.patch.TryGetGlobal(name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            // this is a conditional assignment
            variableValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, name, null);
            if (variableValue.exists)
                return variableValue.result;
            if (this._defaultGlobalVariables !== null) {
                variableValue = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            if (this._listDefsOrigin === null)
                return NullException_1.throwNullException("VariablesState._listDefsOrigin");
            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);
            if (listItemValue)
                return listItemValue;
        }
        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);
        return varValue;
    }
    ValueAtVariablePointer(pointer) {
        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);
    }
    Assign(varAss, value) {
        let name = varAss.variableName;
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let contextIndex = -1;
        let setGlobal = false;
        if (varAss.isNewDeclaration) {
            setGlobal = varAss.isGlobal;
        }
        else {
            setGlobal = this.GlobalVariableExistsWithName(name);
        }
        if (varAss.isNewDeclaration) {
            // var varPointer = value as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(value, Value_1.VariablePointerValue);
            if (varPointer !== null) {
                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);
                value = fullyResolvedVariablePointer;
            }
        }
        else {
            let existingPointer = null;
            do {
                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;
                existingPointer = TypeAssertion_1.asOrNull(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);
                if (existingPointer != null) {
                    name = existingPointer.variableName;
                    contextIndex = existingPointer.contextIndex;
                    setGlobal = contextIndex == 0;
                }
            } while (existingPointer != null);
        }
        if (setGlobal) {
            this.SetGlobal(name, value);
        }
        else {
            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);
        }
    }
    SnapshotDefaultGlobals() {
        this._defaultGlobalVariables = new Map(this._globalVariables);
    }
    RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrThrows(oldValue, Value_1.ListValue);
        let newList = TypeAssertion_1.asOrThrows(newValue, Value_1.ListValue);
        if (oldList.value && newList.value && newList.value.Count == 0) {
            newList.value.SetInitialOriginNames(oldList.value.originNames);
        }
    }
    SetGlobal(variableName, value) {
        let oldValue = null;
        if (this.patch === null) {
            oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
        }
        if (this.patch !== null) {
            oldValue = this.patch.TryGetGlobal(variableName, null);
            if (!oldValue.exists) {
                oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
            }
        }
        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        if (variableName === null) {
            return NullException_1.throwNullException("variableName");
        }
        if (this.patch !== null) {
            this.patch.SetGlobal(variableName, value);
        }
        else {
            this._globalVariables.set(variableName, value);
        }
        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)
        if (this.variableChangedEvent !== null &&
            oldValue !== null &&
            value !== oldValue.result) {
            if (this.batchObservingVariableChanges) {
                if (this._changedVariablesForBatchObs === null) {
                    return NullException_1.throwNullException("this._changedVariablesForBatchObs");
                }
                if (this.patch !== null) {
                    this.patch.AddChangedVariable(variableName);
                }
                else if (this._changedVariablesForBatchObs !== null) {
                    this._changedVariablesForBatchObs.add(variableName);
                }
            }
            else {
                this.variableChangedEvent(variableName, value);
            }
        }
    }
    ResolveVariablePointer(varPointer) {
        let contextIndex = varPointer.contextIndex;
        if (contextIndex == -1)
            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);
        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);
        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;
        let doubleRedirectionPointer = TypeAssertion_1.asOrNull(valueOfVariablePointedTo, Value_1.VariablePointerValue);
        if (doubleRedirectionPointer != null) {
            return doubleRedirectionPointer;
        }
        else {
            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);
        }
    }
    GetContextIndexOfVariableNamed(varName) {
        if (this.GlobalVariableExistsWithName(varName))
            return 0;
        return this._callStack.currentElementIndex;
    }
    /**
     * This function is specific to the js version of ink. It allows to register a
     * callback that will be called when a variable changes. The original code uses
     * `state.variableChangedEvent += callback` instead.
     *
     * @param {function} callback
     */
    ObserveVariableChange(callback) {
        this.variableChangedEventCallbacks.push(callback);
    }
}
exports.VariablesState = VariablesState;
VariablesState.dontSaveDefaultValues = true;
//# sourceMappingURL=VariablesState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Void.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Void.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Void extends Object_1.InkObject {
}
exports.Void = Void;
//# sourceMappingURL=Void.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/GameMain.ts":
/*!*************************!*\
  !*** ./src/GameMain.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/ui/common */ "./src/data/ui/common.ts");





class GameMain {
    constructor() {
        csharp__WEBPACK_IMPORTED_MODULE_0__["JsManager"].Instance.JsOnApplicationQuit = () => this.onApplicationQuit();
        csharp__WEBPACK_IMPORTED_MODULE_0__["JsManager"].Instance.JsOnDispose = () => this.onDispose();
    }
    async start() {
        try {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game start in JS....");
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].StoryManager.initialize();
            //excel
            //ExcelManager.Instance(ExcelManager);
            //FairyGUI
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].ResManager.loadFairyGUIPackage(_data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].PackageName);
            //do Unit Test
            //UnitTest.doTest();
            //
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_1__["SceneDef"].LoginScene);
            //JSC#
            csharp__WEBPACK_IMPORTED_MODULE_0__["GameLaunch"].Instance.JsLuanchFinish();
        }
        catch (ex) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(ex);
        }
    }
    onApplicationQuit() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].GameObjectPool.cleanup(true);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game onApplicationQuit in JS....");
    }
    onDispose() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game onDispose in JS....");
    }
}
new GameMain().start();


/***/ }),

/***/ "./src/data/pb/Opcode.ts":
/*!*******************************!*\
  !*** ./src/data/pb/Opcode.ts ***!
  \*******************************/
/*! exports provided: DecodeMsg, Opcode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecodeMsg", function() { return DecodeMsg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Opcode", function() { return Opcode; });
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_gen_pb__WEBPACK_IMPORTED_MODULE_0__);

class DecodeMsg {
}
class Opcode {
    static decode(opcode, msg) {
        let msgObj = this.map[opcode]["decode"](msg);
        let decodeMsg = new DecodeMsg();
        decodeMsg.rpcId = msgObj.RpcId;
        decodeMsg.msgObj = msgObj;
        return decodeMsg;
    }
    static encode(opcode, msg) {
        let buf = this.map[opcode]["encode"](msg).finish();
        return buf;
    }
}
Opcode.MSG_C2R_Login = 1000;
Opcode.MSG_R2C_Login = 1001;
Opcode.MSG_C2G_LoginGate = 1002;
Opcode.MSG_G2C_LoginGate = 1003;
Opcode.MSG_C2GS_Test = 2001;
Opcode.MSG_GS2C_Test = 2002;
Opcode.map = {
    1000: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.encode },
    1001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.encode },
    1002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.encode },
    1003: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.encode },
    2001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.encode },
    2002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.encode }
};


/***/ }),

/***/ "./src/data/pb/gen/pb.js":
/*!*******************************!*\
  !*** ./src/data/pb/gen/pb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
$protobuf.util.Long = Long;
$protobuf.configure();


// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.nice_ts = (function() {

    /**
     * Namespace nice_ts.
     * @exports nice_ts
     * @namespace
     */
    var nice_ts = {};

    nice_ts.C2R_Login = (function() {

        /**
         * Properties of a C2R_Login.
         * @memberof nice_ts
         * @interface IC2R_Login
         * @property {string|null} [Account] C2R_Login Account
         * @property {string|null} [Password] C2R_Login Password
         */

        /**
         * Constructs a new C2R_Login.
         * @memberof nice_ts
         * @classdesc Represents a C2R_Login.
         * @implements IC2R_Login
         * @constructor
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         */
        function C2R_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2R_Login Account.
         * @member {string} Account
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Account = "";

        /**
         * C2R_Login Password.
         * @member {string} Password
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Password = "";

        /**
         * Creates a new C2R_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         * @returns {nice_ts.C2R_Login} C2R_Login instance
         */
        C2R_Login.create = function create(properties) {
            return new C2R_Login(properties);
        };

        /**
         * Encodes the specified C2R_Login message. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && Object.hasOwnProperty.call(message, "Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && Object.hasOwnProperty.call(message, "Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified C2R_Login message, length delimited. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2R_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2R_Login message.
         * @function verify
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2R_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        /**
         * Creates a C2R_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2R_Login} C2R_Login
         */
        C2R_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2R_Login)
                return object;
            var message = new $root.nice_ts.C2R_Login();
            if (object.Account != null)
                message.Account = String(object.Account);
            if (object.Password != null)
                message.Password = String(object.Password);
            return message;
        };

        /**
         * Creates a plain object from a C2R_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.C2R_Login} message C2R_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2R_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Account = "";
                object.Password = "";
            }
            if (message.Account != null && message.hasOwnProperty("Account"))
                object.Account = message.Account;
            if (message.Password != null && message.hasOwnProperty("Password"))
                object.Password = message.Password;
            return object;
        };

        /**
         * Converts this C2R_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.C2R_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2R_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2R_Login;
    })();

    nice_ts.R2C_Login = (function() {

        /**
         * Properties of a R2C_Login.
         * @memberof nice_ts
         * @interface IR2C_Login
         * @property {number|null} [Error] R2C_Login Error
         * @property {string|null} [Message] R2C_Login Message
         * @property {string|null} [Address] R2C_Login Address
         * @property {number|Long|null} [Key] R2C_Login Key
         * @property {number|Long|null} [GateId] R2C_Login GateId
         */

        /**
         * Constructs a new R2C_Login.
         * @memberof nice_ts
         * @classdesc Represents a R2C_Login.
         * @implements IR2C_Login
         * @constructor
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         */
        function R2C_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * R2C_Login Error.
         * @member {number} Error
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Error = 0;

        /**
         * R2C_Login Message.
         * @member {string} Message
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Message = "";

        /**
         * R2C_Login Address.
         * @member {string} Address
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Address = "";

        /**
         * R2C_Login Key.
         * @member {number|Long} Key
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * R2C_Login GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new R2C_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         * @returns {nice_ts.R2C_Login} R2C_Login instance
         */
        R2C_Login.create = function create(properties) {
            return new R2C_Login(properties);
        };

        /**
         * Encodes the specified R2C_Login message. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Address != null && Object.hasOwnProperty.call(message, "Address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Address);
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GateId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified R2C_Login message, length delimited. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.R2C_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.Address = reader.string();
                    break;
                case 2:
                    message.Key = reader.int64();
                    break;
                case 3:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a R2C_Login message.
         * @function verify
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        R2C_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.Address != null && message.hasOwnProperty("Address"))
                if (!$util.isString(message.Address))
                    return "Address: string expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a R2C_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.R2C_Login} R2C_Login
         */
        R2C_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.R2C_Login)
                return object;
            var message = new $root.nice_ts.R2C_Login();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.Address != null)
                message.Address = String(object.Address);
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a R2C_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.R2C_Login} message R2C_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        R2C_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.Address != null && message.hasOwnProperty("Address"))
                object.Address = message.Address;
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this R2C_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.R2C_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        R2C_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return R2C_Login;
    })();

    nice_ts.C2G_LoginGate = (function() {

        /**
         * Properties of a C2G_LoginGate.
         * @memberof nice_ts
         * @interface IC2G_LoginGate
         * @property {number|Long|null} [Key] C2G_LoginGate Key
         * @property {number|Long|null} [GateId] C2G_LoginGate GateId
         */

        /**
         * Constructs a new C2G_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a C2G_LoginGate.
         * @implements IC2G_LoginGate
         * @constructor
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         */
        function C2G_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2G_LoginGate Key.
         * @member {number|Long} Key
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2G_LoginGate GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2G_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate instance
         */
        C2G_LoginGate.create = function create(properties) {
            return new C2G_LoginGate(properties);
        };

        /**
         * Encodes the specified C2G_LoginGate message. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.GateId);
            return writer;
        };

        /**
         * Encodes the specified C2G_LoginGate message, length delimited. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2G_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Key = reader.int64();
                    break;
                case 2:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2G_LoginGate message.
         * @function verify
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2G_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2G_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         */
        C2G_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2G_LoginGate)
                return object;
            var message = new $root.nice_ts.C2G_LoginGate();
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2G_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.C2G_LoginGate} message C2G_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2G_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
            }
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            return object;
        };

        /**
         * Converts this C2G_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2G_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2G_LoginGate;
    })();

    nice_ts.G2C_LoginGate = (function() {

        /**
         * Properties of a G2C_LoginGate.
         * @memberof nice_ts
         * @interface IG2C_LoginGate
         * @property {number|null} [Error] G2C_LoginGate Error
         * @property {string|null} [Message] G2C_LoginGate Message
         * @property {number|Long|null} [PlayerId] G2C_LoginGate PlayerId
         */

        /**
         * Constructs a new G2C_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a G2C_LoginGate.
         * @implements IG2C_LoginGate
         * @constructor
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         */
        function G2C_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2C_LoginGate Error.
         * @member {number} Error
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Error = 0;

        /**
         * G2C_LoginGate Message.
         * @member {string} Message
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Message = "";

        /**
         * G2C_LoginGate PlayerId.
         * @member {number|Long} PlayerId
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.PlayerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new G2C_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate instance
         */
        G2C_LoginGate.create = function create(properties) {
            return new G2C_LoginGate(properties);
        };

        /**
         * Encodes the specified G2C_LoginGate message. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerId != null && Object.hasOwnProperty.call(message, "PlayerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PlayerId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified G2C_LoginGate message, length delimited. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.G2C_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.PlayerId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2C_LoginGate message.
         * @function verify
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2C_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (!$util.isInteger(message.PlayerId) && !(message.PlayerId && $util.isInteger(message.PlayerId.low) && $util.isInteger(message.PlayerId.high)))
                    return "PlayerId: integer|Long expected";
            return null;
        };

        /**
         * Creates a G2C_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         */
        G2C_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.G2C_LoginGate)
                return object;
            var message = new $root.nice_ts.G2C_LoginGate();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.PlayerId != null)
                if ($util.Long)
                    (message.PlayerId = $util.Long.fromValue(object.PlayerId)).unsigned = false;
                else if (typeof object.PlayerId === "string")
                    message.PlayerId = parseInt(object.PlayerId, 10);
                else if (typeof object.PlayerId === "number")
                    message.PlayerId = object.PlayerId;
                else if (typeof object.PlayerId === "object")
                    message.PlayerId = new $util.LongBits(object.PlayerId.low >>> 0, object.PlayerId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a G2C_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.G2C_LoginGate} message G2C_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        G2C_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.PlayerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PlayerId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (typeof message.PlayerId === "number")
                    object.PlayerId = options.longs === String ? String(message.PlayerId) : message.PlayerId;
                else
                    object.PlayerId = options.longs === String ? $util.Long.prototype.toString.call(message.PlayerId) : options.longs === Number ? new $util.LongBits(message.PlayerId.low >>> 0, message.PlayerId.high >>> 0).toNumber() : message.PlayerId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this G2C_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        G2C_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return G2C_LoginGate;
    })();

    nice_ts.C2GS_Test = (function() {

        /**
         * Properties of a C2GS_Test.
         * @memberof nice_ts
         * @interface IC2GS_Test
         * @property {number|null} [testID] C2GS_Test testID
         * @property {string|null} [testName] C2GS_Test testName
         */

        /**
         * Constructs a new C2GS_Test.
         * @memberof nice_ts
         * @classdesc Represents a C2GS_Test.
         * @implements IC2GS_Test
         * @constructor
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         */
        function C2GS_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2GS_Test testID.
         * @member {number} testID
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testID = 0;

        /**
         * C2GS_Test testName.
         * @member {string} testName
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testName = "";

        /**
         * Creates a new C2GS_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         * @returns {nice_ts.C2GS_Test} C2GS_Test instance
         */
        C2GS_Test.create = function create(properties) {
            return new C2GS_Test(properties);
        };

        /**
         * Encodes the specified C2GS_Test message. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testID != null && Object.hasOwnProperty.call(message, "testID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.testID);
            if (message.testName != null && Object.hasOwnProperty.call(message, "testName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testName);
            return writer;
        };

        /**
         * Encodes the specified C2GS_Test message, length delimited. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2GS_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.testID = reader.int32();
                    break;
                case 2:
                    message.testName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2GS_Test message.
         * @function verify
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2GS_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.testID != null && message.hasOwnProperty("testID"))
                if (!$util.isInteger(message.testID))
                    return "testID: integer expected";
            if (message.testName != null && message.hasOwnProperty("testName"))
                if (!$util.isString(message.testName))
                    return "testName: string expected";
            return null;
        };

        /**
         * Creates a C2GS_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         */
        C2GS_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2GS_Test)
                return object;
            var message = new $root.nice_ts.C2GS_Test();
            if (object.testID != null)
                message.testID = object.testID | 0;
            if (object.testName != null)
                message.testName = String(object.testName);
            return message;
        };

        /**
         * Creates a plain object from a C2GS_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.C2GS_Test} message C2GS_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2GS_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testID = 0;
                object.testName = "";
            }
            if (message.testID != null && message.hasOwnProperty("testID"))
                object.testID = message.testID;
            if (message.testName != null && message.hasOwnProperty("testName"))
                object.testName = message.testName;
            return object;
        };

        /**
         * Converts this C2GS_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.C2GS_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2GS_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2GS_Test;
    })();

    nice_ts.GS2C_Test = (function() {

        /**
         * Properties of a GS2C_Test.
         * @memberof nice_ts
         * @interface IGS2C_Test
         * @property {number|null} [Error] GS2C_Test Error
         * @property {string|null} [Message] GS2C_Test Message
         * @property {string|null} [testResponse] GS2C_Test testResponse
         */

        /**
         * Constructs a new GS2C_Test.
         * @memberof nice_ts
         * @classdesc Represents a GS2C_Test.
         * @implements IGS2C_Test
         * @constructor
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         */
        function GS2C_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GS2C_Test Error.
         * @member {number} Error
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Error = 0;

        /**
         * GS2C_Test Message.
         * @member {string} Message
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Message = "";

        /**
         * GS2C_Test testResponse.
         * @member {string} testResponse
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.testResponse = "";

        /**
         * Creates a new GS2C_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         * @returns {nice_ts.GS2C_Test} GS2C_Test instance
         */
        GS2C_Test.create = function create(properties) {
            return new GS2C_Test(properties);
        };

        /**
         * Encodes the specified GS2C_Test message. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testResponse != null && Object.hasOwnProperty.call(message, "testResponse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.testResponse);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified GS2C_Test message, length delimited. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.GS2C_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.testResponse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GS2C_Test message.
         * @function verify
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GS2C_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                if (!$util.isString(message.testResponse))
                    return "testResponse: string expected";
            return null;
        };

        /**
         * Creates a GS2C_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         */
        GS2C_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.GS2C_Test)
                return object;
            var message = new $root.nice_ts.GS2C_Test();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.testResponse != null)
                message.testResponse = String(object.testResponse);
            return message;
        };

        /**
         * Creates a plain object from a GS2C_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.GS2C_Test} message GS2C_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GS2C_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testResponse = "";
                object.Error = 0;
                object.Message = "";
            }
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                object.testResponse = message.testResponse;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this GS2C_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.GS2C_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GS2C_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GS2C_Test;
    })();

    return nice_ts;
})();

module.exports = $root;


/***/ }),

/***/ "./src/data/ui/combat.ts":
/*!*******************************!*\
  !*** ./src/data/ui/combat.ts ***!
  \*******************************/
/*! exports provided: combatUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combatUI", function() { return combatUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class combatUI {
}
combatUI.PackageName = "combat";
combatUI.PackageBytes = "combat_fui.bytes";
combatUI.UItest = "test";
combatUI.UICard = "Card";
combatUI.UICombatPage = "CombatPage";
combatUI.UIRoom = "Room";


/***/ }),

/***/ "./src/data/ui/common.ts":
/*!*******************************!*\
  !*** ./src/data/ui/common.ts ***!
  \*******************************/
/*! exports provided: commonUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonUI", function() { return commonUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class commonUI {
}
commonUI.PackageName = "common";
commonUI.PackageBytes = "common_fui.bytes";
commonUI.UILoadingPage = "LoadingPage";
commonUI.UIUIGuideWin = "UIGuideWin";
commonUI.UIUINoticeWin = "UINoticeWin";


/***/ }),

/***/ "./src/data/ui/home.ts":
/*!*****************************!*\
  !*** ./src/data/ui/home.ts ***!
  \*****************************/
/*! exports provided: homeUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homeUI", function() { return homeUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class homeUI {
}
homeUI.PackageName = "home";
homeUI.PackageBytes = "home_fui.bytes";
homeUI.UIHomePage = "HomePage";
homeUI.UILevelPage = "LevelPage";
homeUI.UIShopPage = "ShopPage";


/***/ }),

/***/ "./src/data/ui/login.ts":
/*!******************************!*\
  !*** ./src/data/ui/login.ts ***!
  \******************************/
/*! exports provided: loginUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loginUI", function() { return loginUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class loginUI {
}
loginUI.PackageName = "login";
loginUI.PackageBytes = "login_fui.bytes";
loginUI.UILoginPage = "LoginPage";
loginUI.UISelServerWin = "SelServerWin";
loginUI.UIAreaItem = "AreaItem";


/***/ }),

/***/ "./src/data/ui/story.ts":
/*!******************************!*\
  !*** ./src/data/ui/story.ts ***!
  \******************************/
/*! exports provided: storyUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storyUI", function() { return storyUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class storyUI {
}
storyUI.PackageName = "story";
storyUI.PackageBytes = "story_fui.bytes";
storyUI.UIStoryWin = "StoryWin";


/***/ }),

/***/ "./src/framework/common/GameObjectPool.ts":
/*!************************************************!*\
  !*** ./src/framework/common/GameObjectPool.ts ***!
  \************************************************/
/*! exports provided: GameObjectPool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameObjectPool", function() { return GameObjectPool; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



// -- GameObject
// -- 
// -- 1ResourcesManager
// -- 2GameObject(Asset)GameObjectInst
class GameObjectPool extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.__cacheTransRoot = null;
        this.__goPool = new Map();
        this.__instCache = new Map();
        let go = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Find("GameObjectCacheRoot");
        if (go == undefined) {
            go = new csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject("GameObjectCacheRoot");
            csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].Object.DontDestroyOnLoad(go);
        }
        this.__cacheTransRoot = go.transform;
    }
    //-- 
    checkHasCached(path) {
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            return true;
        }
        let pooledGo = this.__goPool.get(path);
        return pooledGo != undefined;
    }
    //-- GameObject
    cacheAndInstGameObject(path, go, inst_count = 1) {
        this.__goPool.set(path, go);
        if (inst_count > 0) {
            let cachedInst = this.__instCache.get(path);
            for (let i = 0; i < inst_count; i++) {
                let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(go);
                inst.transform.SetParent(this.__cacheTransRoot);
                inst.SetActive(false);
                cachedInst.push(inst);
            }
        }
    }
    //-- 
    tryGetFromCache(path) {
        if (!this.checkHasCached(path)) {
            return null;
        }
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            let inst = cachedInst.pop();
            return inst;
        }
        let pooledGo = this.__goPool.get(path);
        if (pooledGo != undefined) {
            let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(pooledGo);
            return inst;
        }
        return null;
    }
    //
    async preLoadGameObjectAsync(path, inst_count, callback, ...params) {
        if (this.checkHasCached(path)) {
            if (callback != null) {
                callback(params);
            }
            return;
        }
        let go = await _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).loadPrefab(path);
        if (go != undefined) {
            this.cacheAndInstGameObject(path, go, inst_count);
        }
        if (callback != null) {
            callback(params);
        }
    }
    //-- 
    async getGameObjectAsync(path, callback, ...params) {
        let inst = this.tryGetFromCache(path);
        if (inst == null) {
            await this.preLoadGameObjectAsync(path, 1, callback, params);
        }
        inst = this.tryGetFromCache(path);
        inst.SetActive(true);
    }
    //-- 
    recycleGameObject(path, inst) {
        inst.transform.SetParent(this.__cacheTransRoot);
        inst.SetActive(false);
        let cachedInst = this.__instCache.get(path) || new Array();
        cachedInst.push(inst);
        this.__instCache.set(path, cachedInst);
    }
    //-- 
    cleanup(includePooledGo = false) {
        this.__instCache.forEach((values, key) => {
            for (let inst of values) {
                if (inst != null) {
                    csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Destroy(inst);
                }
            }
        });
        this.__instCache.clear();
        if (includePooledGo) {
            this.__goPool.forEach((go, key) => {
                if (go != null) {
                    _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).releaseAddressGO(go);
                }
            });
            this.__goPool.clear();
        }
    }
}


/***/ }),

/***/ "./src/framework/common/Messenger.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Messenger.ts ***!
  \*******************************************/
/*! exports provided: MesObj, Messenger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MesObj", function() { return MesObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Messenger", function() { return Messenger; });
class MesObj {
}
class Messenger {
    constructor() {
        this.listenerMap = new Map();
    }
    addListener(e_type, e_obj, e_listner) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) == "undefined") {
            msgObj = new MesObj();
            msgObj.obj = e_obj;
            msgObj.listeners = new Array();
        }
        msgObj.listeners.push(e_listner);
        this.listenerMap.set(e_type, msgObj);
    }
    getListener(e_type) {
        return this.listenerMap.get(e_type);
    }
    broadcast(e_type, ...params) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let l of msgObj.listeners) {
                l.apply(msgObj.obj, params);
            }
        }
    }
    removeListenerByType(e_type) {
        this.listenerMap.delete(e_type);
    }
    removeListener(e_type, e_listener) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let i = 0; i < msgObj.listeners.length; i++) {
                if (msgObj.listeners[i] == e_listener) {
                    msgObj.listeners.splice(i, 1);
                }
            }
        }
    }
    clearup() {
        this.listenerMap.clear();
    }
}


/***/ }),

/***/ "./src/framework/common/NiceDecorator.ts":
/*!***********************************************!*\
  !*** ./src/framework/common/NiceDecorator.ts ***!
  \***********************************************/
/*! exports provided: binder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binder", function() { return binder; });
// FairyGUI  
function binder(name) {
    return function (target, key) {
        target["binders"] = target["binders"] || {};
        target["binders"][key] = name;
    };
}


/***/ }),

/***/ "./src/framework/common/ResManager.ts":
/*!********************************************!*\
  !*** ./src/framework/common/ResManager.ts ***!
  \********************************************/
/*! exports provided: ResManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResManager", function() { return ResManager; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class ResManager extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this._pkgMap = new Map();
    }
    async loadFairyGUIPackage(packageName) {
        try {
            let count = this._pkgMap.get(packageName);
            if (count == null || count < 1) {
                //
                let address = packageName + "_fui.bytes";
                let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadFairyGUIPackage(address, packageName);
                await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
                this._pkgMap.set(packageName, 1);
            }
            else {
                this._pkgMap.set(packageName, count + 1);
            }
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load fairyGUI :${packageName} : ${ex}`);
        }
    }
    releaseFairyGUIPackage(packageName) {
        let count = this._pkgMap.get(packageName);
        if (count != null && count > 1) {
            this._pkgMap.set(packageName, count - 1);
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log(`release fagui package:${packageName}`);
            this._pkgMap.delete(packageName);
            csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseFGUIPackage(packageName);
        }
    }
    async loadScene(sceneName, mode = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].SceneManagement.LoadSceneMode.Single) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadScene(sceneName, mode, (progress) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("load scene: " + progress);
            });
            let scenInstance = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return scenInstance;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load Scene :${sceneName} : ${ex}`);
            return null;
        }
    }
    async unloadScene(sceneInstance) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadScene(sceneInstance);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Unload scene  : ${ex}`);
            return null;
        }
    }
    unloadSceneByName(sceneName) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadSceneByName(sceneName);
    }
    async loadPrefab(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadPrefab(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load prefab :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextAsset(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextAsset(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load textasset :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextBytes(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextBytes(address);
            let bytes = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return bytes;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`LoadTextBytes :${address} : ${ex}`);
        }
    }
    async loadSprite(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadSprite(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load sprite :${address} : ${ex}`);
            return null;
        }
    }
    releaseAddressGO(go) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseAddressGO(go);
    }
}


/***/ }),

/***/ "./src/framework/common/Singleton.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Singleton.ts ***!
  \*******************************************/
/*! exports provided: Singleton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Singleton", function() { return Singleton; });
class Singleton {
    static Instance(c) {
        if (this.instance == null) {
            this.instance = new c();
        }
        return this.instance;
    }
}
Singleton.instance = null;


/***/ }),

/***/ "./src/framework/ink/InkStateInspector.ts":
/*!************************************************!*\
  !*** ./src/framework/ink/InkStateInspector.ts ***!
  \************************************************/
/*! exports provided: InkStateInspector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkStateInspector", function() { return InkStateInspector; });
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");

class InkStateInspector {
    BindInkMethods(inkStory) {
        //3
        this.bindInkMethodOnce(inkStory, "GetCharacterName", this.getCharacterName);
        //3 
        this.bindInkMethodOnceGeneral(inkStory, "GetCharacterNameByMutiParams", this.getCharacterNameMutiParams);
    }
    getCharacterName() {
        return "Justin Test Puerts";
    }
    getCharacterNameMutiParams(p1, p2, p3) {
        return "Justin Muti Params";
    }
    bindInkMethodOnce(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunction(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    bindInkMethodOnceGeneral(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunctionGeneral(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    unbindInkMethod(inkStory, funcName) {
        try {
            inkStory.UnbindExternalFunction(funcName);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
}


/***/ }),

/***/ "./src/framework/ink/InkWriter.ts":
/*!****************************************!*\
  !*** ./src/framework/ink/InkWriter.ts ***!
  \****************************************/
/*! exports provided: InkWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkWriter", function() { return InkWriter; });
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inkjs/engine/Story */ "./node_modules/inkjs/engine/Story.js");
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkStateInspector */ "./src/framework/ink/InkStateInspector.ts");
/* harmony import */ var _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");




class InkWriter {
    constructor(storyJson) {
        this._allInkCommands = new Map();
        this.setupInkCommands();
        this.createStroy(storyJson);
        this.load();
    }
    load() {
        let storyState = "";
        if (storyState != null && storyState != "") {
            this._currentStory.state.LoadJson(storyState);
        }
    }
    createStroy(json) {
        this._currentStory = new inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__["Story"](json);
    }
    beginStory(knotName) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
            return;
        }
        this._currentStory.ChoosePathString(knotName, true);
        let inkState = new _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__["InkStateInspector"]();
        inkState.BindInkMethods(this._currentStory);
        this.advanceStory();
    }
    giveReward() {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("give reward...");
        return true;
    }
    setupInkCommands() {
        this._allInkCommands.set("GIVE_REWARD", this.giveReward);
    }
    handleCommand(command, args) {
        if (this._allInkCommands.has(command)) {
            return this._allInkCommands.get(command)(args);
        }
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].error("Could not find InkCommand with name:" + command);
        return true;
    }
    parseCommandName(text) {
        let num = text.indexOf(InkWriter.COMMAND_PREFIX);
        let num2 = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num2 == -1) {
            num2 = text.length;
        }
        let length = num2 - (num + InkWriter.COMMAND_PREFIX.length);
        return text.substr(num + InkWriter.COMMAND_PREFIX.length, length).trim();
    }
    parseCommandArgs(text) {
        let num = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num == -1) {
            return [];
        }
        let length = text.length - (num + 1);
        let list = text.substr(num + 1, length).
            trim().
            split(InkWriter.COMMAND_ARG_DELIMITER);
        for (let i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
        }
        return list;
    }
    extractSpeaker(line) {
        if (line.startsWith(InkWriter.COMMAND_PREFIX)) {
            return ["0", line.trim()];
        }
        let array = line.split(':', 2);
        if (array.length > 1) {
            let speakID = array[0].trim();
            let speakContent = array[1].trim();
            return [speakID, speakContent];
        }
        return ["0", line.trim()];
    }
    saveCurrentStory() {
        let currState = this._currentStory.state.toJson();
        //TODO
    }
    canContinue() {
        return this._currentStory.canContinue;
    }
    advanceStory() {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
        }
        else if (this._currentStory.canContinue) {
            let text = this._currentStory.Continue().trim();
            if (text == "") {
                this.advanceStory();
                return;
            }
            let speakID;
            let speakContent;
            [speakID, speakContent] = this.extractSpeaker(text);
            let commandName = null;
            let args = null;
            if (speakContent.startsWith(InkWriter.COMMAND_PREFIX)) {
                commandName = this.parseCommandName(speakContent);
                args = this.parseCommandArgs(speakContent);
                if (commandName != null && commandName != "") {
                    if (this.handleCommand(commandName, args)) {
                        this.advanceStory();
                    }
                }
            }
            else {
                //OnContentReady
                _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastContentReady(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCONTENTREADY, speakContent, speakID, this._currentStory.currentTags, this._currentStory.currentChoices);
            }
        }
        else if (this._currentStory.currentChoices.length > 0) {
            //OnChoicesPresented
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastChoicesPresented(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCHOICESPRESENTED, this._currentStory.currentChoices);
        }
        else {
            //OnStoryFinished
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastStoryFinished(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONSTORYFINISHED);
        }
    }
    selectChoice(choiceIndex) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to ChooseChoice in InkWriter when no story has begun");
            return;
        }
        this._currentStory.ChooseChoiceIndex(choiceIndex);
        this.advanceStory();
    }
    getVariable(variableName) {
        return this._currentStory.variablesState.GetVariableWithName(variableName);
    }
    setVariable(variableName, value) {
        this._currentStory.variablesState.$(variableName, value);
    }
}
InkWriter.DEBUG_STORY_ID = "DEBUG_STORY";
InkWriter.COMMAND_PREFIX = ">>>";
InkWriter.COMMAND_DELIMITER = ":";
InkWriter.COMMAND_ARG_DELIMITER = ',';


/***/ }),

/***/ "./src/framework/ink/StoryManager.ts":
/*!*******************************************!*\
  !*** ./src/framework/ink/StoryManager.ts ***!
  \*******************************************/
/*! exports provided: StoryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryManager", function() { return StoryManager; });
/* harmony import */ var _common_ResManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _InkWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkWriter */ "./src/framework/ink/InkWriter.ts");



class StoryManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super();
        this.storyAddress = "Story/TestStory.json";
    }
    get inkWriter() {
        return this._inkWriter;
    }
    async initialize() {
        if (this._inkWriter == null) {
            var json = (await _common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"].Instance(_common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"]).loadTextAsset(this.storyAddress)).text;
            this._inkWriter = new _InkWriter__WEBPACK_IMPORTED_MODULE_2__["InkWriter"](json);
        }
    }
    beginStory(knotName) {
        this._inkWriter.beginStory(knotName);
    }
    canContinue() {
        return this._inkWriter.canContinue;
    }
    advanceStory() {
        this._inkWriter.advanceStory();
    }
    selectChoice(choice) {
        this._inkWriter.selectChoice(choice.index);
    }
    loadCurrent() {
        if (this._inkWriter != null)
            this._inkWriter.load();
    }
    getVariable(variableName) {
        return this._inkWriter.getVariable(variableName);
    }
    setVariable(variableName, value) {
        this.inkWriter.setVariable(variableName, value);
    }
}


/***/ }),

/***/ "./src/framework/ink/StoryMessageManager.ts":
/*!**************************************************!*\
  !*** ./src/framework/ink/StoryMessageManager.ts ***!
  \**************************************************/
/*! exports provided: StoryMessageManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryMessageManager", function() { return StoryMessageManager; });
/* harmony import */ var _common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");


class StoryMessageManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.storyMessage = new _common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.storyMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.storyMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.storyMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.storyMessage.clearup();
    }
    broadcastContentReady(msgCode, speakerContent, speakerId, currentTags, currentChoices) {
        this.storyMessage.broadcast(msgCode, speakerContent, speakerId, currentTags, currentChoices);
    }
    broadcastChoicesPresented(mesgCode, currentChoices) {
        this.storyMessage.broadcast(mesgCode, currentChoices);
    }
    broadcastStoryFinished(mesgCode) {
        this.storyMessage.broadcast(mesgCode);
    }
}
StoryMessageManager.ONCONTENTREADY = 1001;
StoryMessageManager.ONCHOICESPRESENTED = 1002;
StoryMessageManager.ONSTORYFINISHED = 1003;


/***/ }),

/***/ "./src/framework/logger/Logger.ts":
/*!****************************************!*\
  !*** ./src/framework/logger/Logger.ts ***!
  \****************************************/
/*! exports provided: Logger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");


var LogType;
(function (LogType) {
    LogType[LogType["Error"] = 0] = "Error";
    LogType[LogType["Assert"] = 1] = "Assert";
    LogType[LogType["Warning"] = 2] = "Warning";
    LogType[LogType["Log"] = 3] = "Log";
    LogType[LogType["Exception"] = 4] = "Exception";
})(LogType || (LogType = {}));
class Logger {
    static getPrintStack(type, showStack, ...args) {
        let message = '';
        for (let i = 0; i < args.length; i++) {
            const element = args[i];
            if (typeof element === 'object' && Logger.LOG_OBJECT_TO_JSON) {
                message += JSON.stringify(element);
            }
            else {
                message += element;
            }
            if (i < args.length - 1) {
                message += ' ';
            }
        }
        if (showStack || csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Application.isEditor) {
            var stacks = new Error().stack.split('\n');
            for (let i = 3; i < stacks.length; i++) {
                const line = stacks[i];
                message += '\n';
                message += line;
            }
        }
        if (!Logger.unity_log_target) {
            Logger.unity_log_target = new csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Object();
        }
        return message;
    }
    static log(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /**
     * Outputs a warning message to the Logger.
     * @param message  list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static warn(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Warning, true, args);
        console.warn(msg);
    }
    /**
     * Outputs an error message to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static error(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Error, true, args);
        console.error(msg);
    }
    /** Outputs a stack trace to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
    */
    static trace(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /** Log JavaScript Objects as JSON format */
    static LOG_OBJECT_TO_JSON(...args) {
        return false;
    }
}
Logger.unity_log_target = null;


/***/ }),

/***/ "./src/framework/net/GameSession.ts":
/*!******************************************!*\
  !*** ./src/framework/net/GameSession.ts ***!
  \******************************************/
/*! exports provided: MsgPack, GameSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MsgPack", function() { return MsgPack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSession", function() { return GameSession; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MessageParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MessageParser */ "./src/framework/net/MessageParser.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");






class MsgPack {
    constructor() {
        this.retryTimes = 0;
    }
}
class GameSession extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.id = 0; //session ID
        this.reSendInterval = 10000; //10
        this.timeoutInterval = 5000; //5
        this.maxReSendTimes = 5; //
        this._rpcId = 1;
        this.requestCallback = new Map();
        this.listeners = new Map();
        //ID, 
        this._serverId = -1;
        this._serverType = 1;
    }
    get rpcId() {
        return ++this._rpcId;
    }
    //address-> ip:port
    connectChannel(address, connCaback) {
        this.channel = csharp__WEBPACK_IMPORTED_MODULE_3__["NiceTS"].TService.Instance.GetChannel();
        this.channel.errorCallback = (channel, code) => {
            if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__["NetErrorCode"].ERR_SocketConnSucc) {
                this.timeoutIimer = setInterval(() => {
                    this.checkTimeoutMsg();
                }, this.timeoutInterval);
            }
            connCaback(channel, code);
        };
        this.channel.readCallback = (buffer) => {
            this.onReceive(buffer);
        };
        this.channel.Connect(address);
        return this;
    }
    //
    listen(opcode, callback) {
        this.listeners.set(opcode, callback);
    }
    //protoubf
    // rpc_id[4] - opcode[2] - server_id[2] - server_type[1] - 
    send(opcode, rpcid, message, callBack) {
        //
        let rpcBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeInt(rpcid); //4
        let opcodeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(opcode); //2
        let serveridBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(this._serverId); //2
        let servertypeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeByte(this._serverType); //1
        let sendArray = new Uint8Array(4 + 2 + 2 + 1 + message.length);
        sendArray.set(rpcBuf);
        sendArray.set(opcodeBuf, 4);
        sendArray.set(serveridBuf, 4 + 2);
        sendArray.set(servertypeBuf, 4 + 2 + 2);
        sendArray.set(message, 4 + 2 + 2 + 1);
        if (callBack != null) {
            let msgPack = new MsgPack();
            msgPack.sendTime = new Date().getTime();
            msgPack.callback = callBack;
            msgPack.bytes = sendArray;
            this.requestCallback.set(rpcid, msgPack);
        }
        // for(let i in sendArray){
        //     Logger.log("TS -- send array: "+i);
        // }
        //Logger.log("send array: "+sendArray);
        this.channel.Send(sendArray);
    }
    reSend(bytes) {
        this.channel.Send(bytes);
    }
    onReceive(buffer) {
        let msgBuf = new Uint8Array(buffer);
        let rpcid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeInt(msgBuf.subarray(0, 4));
        let opcode = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(4, 6));
        let serverid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(6, 8));
        let servertype = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeByte(msgBuf.subarray(8, 9));
        this._serverId = serverid;
        this._serverType = servertype;
        let msgBytes = msgBuf.subarray(9);
        try {
            let decodeMsg = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].decode(opcode, msgBytes);
            if (rpcid == undefined || !this.requestCallback.has(rpcid)) {
                //
                if (this.listeners.has(opcode)) {
                    let listen = this.listeners.get(opcode);
                    listen(decodeMsg.msgObj);
                }
            }
            else {
                let msgPack = this.requestCallback.get(rpcid);
                msgPack.callback(decodeMsg.msgObj);
                this.requestCallback.delete(rpcid);
            }
        }
        catch (e) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].error("parse msg error, opcode:" + opcode);
        }
    }
    checkTimeoutMsg() {
        let currTime = new Date().getTime();
        this.requestCallback.forEach((value, key) => {
            if (value.retryTimes >= this.maxReSendTimes) {
                //
                _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`Message resend too more, opcode:${key}, lastsend:${value.sendTime}`);
                this.requestCallback.delete(key);
            }
            else {
                if ((currTime - value.sendTime) >= this.reSendInterval) {
                    value.retryTimes++;
                    value.sendTime = currTime;
                    //
                    this.reSend(value.bytes);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`resend message:, opcode:${key}, retry times:${value.retryTimes}`);
                }
            }
        });
    }
    disconnect() {
        clearInterval(this.timeoutIimer);
        this.channel.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/net/HttpManager.ts":
/*!******************************************!*\
  !*** ./src/framework/net/HttpManager.ts ***!
  \******************************************/
/*! exports provided: HttpManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpManager", function() { return HttpManager; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class HttpManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    constructor() {
        super();
    }
    async get(url) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Get(url);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Get error :${url} : ${ex}`);
            return null;
        }
    }
    async post(url, form) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Post(url, form);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Post error :${url} : ${ex}`);
            return null;
        }
    }
}


/***/ }),

/***/ "./src/framework/net/MessageParser.ts":
/*!********************************************!*\
  !*** ./src/framework/net/MessageParser.ts ***!
  \********************************************/
/*! exports provided: MessageParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageParser", function() { return MessageParser; });
class MessageParser {
    static encodeInt(n) {
        let buffer = new Uint8Array(4);
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        return buffer;
    }
    static decodeInt(buffer) {
        let n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        return n;
    }
    static encodeShort(n) {
        let buffer = new Uint8Array(2);
        buffer[0] = n >>> 8;
        buffer[1] = n & 0xff;
        return buffer;
    }
    static decodeShort(buffer) {
        let n = buffer[0] << 8 | buffer[1];
        return n;
    }
    static encodeByte(n) {
        let buffer = new Uint8Array(1);
        buffer[0] = n & 0xff;
        return buffer;
    }
    static decodeByte(buffer) {
        let n = buffer[0];
        return n;
    }
}


/***/ }),

/***/ "./src/framework/net/NetErrorCode.ts":
/*!*******************************************!*\
  !*** ./src/framework/net/NetErrorCode.ts ***!
  \*******************************************/
/*! exports provided: NetErrorCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetErrorCode", function() { return NetErrorCode; });
class NetErrorCode {
}
NetErrorCode.ERR_SocketConnSucc = 100000;
NetErrorCode.ERR_ConnectGateKeyError = 100006;
NetErrorCode.ERR_PeerDisconnect = 102008;
NetErrorCode.ERR_SocketCantSend = 102009;
NetErrorCode.ERR_SocketError = 102010;
NetErrorCode.ERR_SocketConnError = 102011;


/***/ }),

/***/ "./src/framework/net/SessionManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/net/SessionManager.ts ***!
  \*********************************************/
/*! exports provided: SessionManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionManager", function() { return SessionManager; });
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");






class SessionManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    get realmRpcID() {
        return this.sessionReam.rpcId;
    }
    get gateRpcID() {
        return this.sessionGate.rpcId;
    }
    async connectRealmServer() {
        let promise = new Promise(resove => {
            this.sessionReam = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerIP + ":" + _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerPort, (channel, code) => {
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionReam.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("login reamserver err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectRealmServer() {
        this.sessionReam.disconnect();
        this.sessionReam = null;
    }
    async sendRealmMsg(opcode, msg) {
        let rpcID = this.sessionReam.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionReam.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
    async connectGateServer(address) {
        let promise = new Promise(resove => {
            this.sessionGate = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(address, (channel, code) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("login Gate Server: " + code);
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionGate.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("gate server err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectGateServer() {
        this.sessionGate.disconnect();
        this.sessionGate = null;
    }
    async sendGateMsg(opcode, msg) {
        let rpcID = this.sessionGate.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionGate.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/framework/scene/BaseScene.ts":
/*!******************************************!*\
  !*** ./src/framework/scene/BaseScene.ts ***!
  \******************************************/
/*! exports provided: BaseScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseScene", function() { return BaseScene; });
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");

class BaseScene {
    constructor() {
        this.finishCount = 0;
        this.totalCount = 0;
        this.preloadPrefab = new Map();
        this.finishCount = 0;
    }
    addPreloadPrefab(address, instCount) {
        if (!this.preloadPrefab.has(address)) {
            this.preloadPrefab.set(address, instCount);
            return;
        }
        this.preloadPrefab.set(address, this.preloadPrefab.get(address) + instCount);
    }
    setSceneInstance(sceneInstance) {
        this.sceneInstance = sceneInstance;
    }
    async loadAssetsAsync() {
        this.totalCount = this.preloadPrefab.size;
        let premises = [];
        this.preloadPrefab.forEach((value, key) => {
            let premise = _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.preLoadGameObjectAsync(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        await Promise.all(premises);
    }
    onDestroy() {
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.cleanup(true);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].ResManager.unloadScene(this.sceneInstance);
        this.preloadPrefab.clear();
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneDef.ts":
/*!*****************************************!*\
  !*** ./src/framework/scene/SceneDef.ts ***!
  \*****************************************/
/*! exports provided: SceneDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneDef", function() { return SceneDef; });
class SceneDef {
}
SceneDef.LoadingScene = "LoadingScene";
SceneDef.LaunchScene = "LaunchScene";
SceneDef.HomeScene = "HomeScene";
SceneDef.LoginScene = "LoginScene";
SceneDef.PveScene = "PveScene";


/***/ }),

/***/ "./src/framework/scene/SceneFactory.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneFactory.ts ***!
  \*********************************************/
/*! exports provided: SceneFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneFactory", function() { return SceneFactory; });
/* harmony import */ var _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/pve/scene/PveScene */ "./src/game/module/pve/scene/PveScene.ts");
/* harmony import */ var _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/scene/HomeScene */ "./src/game/module/home/scene/HomeScene.ts");
/* harmony import */ var _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../game/module/login/scene/LoginScene */ "./src/game/module/login/scene/LoginScene.ts");
/* harmony import */ var _SceneDef__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SceneDef */ "./src/framework/scene/SceneDef.ts");




class SceneFactory {
    static createScene(sceneName) {
        let scene = null;
        switch (sceneName) {
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].LoginScene:
                scene = new _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__["LoginScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].HomeScene:
                scene = new _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__["HomeScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].PveScene:
                scene = new _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__["PveScene"]();
                break;
        }
        return scene;
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneManager.ts ***!
  \*********************************************/
/*! exports provided: SceneManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneManager", function() { return SceneManager; });
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _SceneFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SceneFactory */ "./src/framework/scene/SceneFactory.ts");






class SceneManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_3__["Singleton"] {
    constructor() {
        super();
        this.currentScene = null;
    }
    async loadScene(scene) {
        try {
            //Loading
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
            //
            if (this.currentScene) {
                this.currentScene.onLeave();
                this.currentScene.onDestroy();
            }
            //
            let sceneInstance = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].ResManager.loadScene(scene);
            //
            this.currentScene = _SceneFactory__WEBPACK_IMPORTED_MODULE_5__["SceneFactory"].createScene(scene);
            this.currentScene.setSceneInstance(sceneInstance);
            this.currentScene.onEnter();
            //Timer
            let progressInterval = setInterval(() => {
                let progress = this.currentScene.finishCount / this.currentScene.totalCount;
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("progress:" + progress + " = " + this.currentScene.finishCount + " = " + this.currentScene.totalCount);
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIMessageManger.broadcast(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__["UIMessage"].MSG_SCENE_PROGRESS, progress * 100);
            }, 100);
            //
            await this.currentScene.loadAssetsAsync();
            //
            clearInterval(progressInterval);
            this.currentScene.onComplete();
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.closeLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("load scene excep:" + ex);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIDefine.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIDefine.ts ***!
  \**************************************/
/*! exports provided: UITypeDef, UILayerDef, UIComDefs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UITypeDef", function() { return UITypeDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILayerDef", function() { return UILayerDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIComDefs", function() { return UIComDefs; });
var UITypeDef;
(function (UITypeDef) {
    UITypeDef[UITypeDef["Unkown"] = 0] = "Unkown";
    UITypeDef[UITypeDef["Page"] = 1] = "Page";
    UITypeDef[UITypeDef["Window"] = 2] = "Window";
    UITypeDef[UITypeDef["Widget"] = 3] = "Widget";
    UITypeDef[UITypeDef["Loading"] = 4] = "Loading";
})(UITypeDef || (UITypeDef = {}));
class UILayerDef {
    static getDefaultLayer(type) {
        switch (type) {
            case UITypeDef.Loading: return this.Loading;
            case UITypeDef.Widget: return this.Widget;
            case UITypeDef.Window: return this.NormalWindow;
            case UITypeDef.Page: return this.Page;
            case UITypeDef.Unkown: return this.Unkown;
            default: return this.Unkown;
        }
    }
}
UILayerDef.Background = 0;
UILayerDef.Page = 1000;
UILayerDef.NormalWindow = 2000;
UILayerDef.TopWindow = 3000;
UILayerDef.Widget = 4000;
UILayerDef.Loading = 5000;
UILayerDef.Unkown = 9999;
class UIComDefs {
}
UIComDefs.BackBtn = "back_btn";
UIComDefs.WindowCloseBtn = "win_close_btn";


/***/ }),

/***/ "./src/framework/ui/UIFactory.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIFactory.ts ***!
  \***************************************/
/*! exports provided: UIFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIFactory", function() { return UIFactory; });
/* harmony import */ var _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/login/ui/UILoginPage */ "./src/game/module/login/ui/UILoginPage.ts");
/* harmony import */ var _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/ui/UIHomePage */ "./src/game/module/home/ui/UIHomePage.ts");
/* harmony import */ var _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UILib/UILoading */ "./src/framework/ui/UILib/UILoading.ts");
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UILib/UIMsgBox */ "./src/framework/ui/UILib/UIMsgBox.ts");
/* harmony import */ var _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../game/module/login/ui/UISelServerWin */ "./src/game/module/login/ui/UISelServerWin.ts");
/* harmony import */ var _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../game/module/home/ui/UIShopPage */ "./src/game/module/home/ui/UIShopPage.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../game/module/story/UIStoryWin */ "./src/game/module/story/UIStoryWin.ts");
/* harmony import */ var _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../data/ui/combat */ "./src/data/ui/combat.ts");
/* harmony import */ var _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../game/module/guide/UIGuideWin */ "./src/game/module/guide/UIGuideWin.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");














const CS = __webpack_require__(/*! csharp */ "csharp");
class UIFactory {
    static createUI(pkg, name) {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].log(`create UI: ${pkg}:${name}`);
        let comp = CS.FairyGUI.UIPackage.CreateObject(pkg, name).asCom;
        let ui = this.uiCache.get(name);
        if (!ui) {
            switch (pkg) {
                case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].PackageName:
                    switch (name) {
                        //common
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUINoticeWin:
                            ui = new _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__["UIMsgBox"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UILoadingPage:
                            ui = new _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__["UILoading"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUIGuideWin:
                            ui = new _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__["UIGuideWin"]();
                    }
                    break;
                case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName:
                    switch (name) {
                        //login
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UILoginPage:
                            ui = new _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__["UILoginPage"]();
                            break;
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin:
                            ui = new _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__["UISelServerWin"]();
                            break;
                    }
                    break;
                case _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__["combatUI"].PackageName:
                    break;
                case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].PackageName:
                    switch (name) {
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIHomePage:
                            ui = new _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__["UIHomePage"]();
                            break;
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIShopPage:
                            ui = new _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__["UIShopPage"]();
                            break;
                    }
                    break;
                case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].PackageName:
                    switch (name) {
                        case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].UIStoryWin:
                            ui = new _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__["UIStoryWin"]();
                            break;
                    }
                    break;
            }
            this.uiCache.set(name, ui);
        }
        if (ui != null) {
            ui.fui = comp;
            ui.name = name;
            ui.pkgName = pkg;
            //FairyGUI
            ui.bindAll(ui);
            ui.awake();
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].error(`not create ui: ${pkg}-${name}`);
        }
        return ui;
    }
}
UIFactory.uiCache = new Map();


/***/ }),

/***/ "./src/framework/ui/UILib/UILoading.ts":
/*!*********************************************!*\
  !*** ./src/framework/ui/UILib/UILoading.ts ***!
  \*********************************************/
/*! exports provided: UILoading */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoading", function() { return UILoading; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class UILoading extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    onAwake() {
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Loading;
    }
    onShow(arg) {
        this.progressLoading.value = 0;
        this.progressLoading.visible = true;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.addListener(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS, this, (progress) => {
            this.progressLoading.TweenValue(progress, 0.1);
        });
    }
    onClose(arg) {
        this.progressLoading.visible = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.removeListenerByCode(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS);
    }
}
__decorate([
    Object(_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__["binder"])("loading_pregress")
], UILoading.prototype, "progressLoading", void 0);


/***/ }),

/***/ "./src/framework/ui/UILib/UIMsgBox.ts":
/*!********************************************!*\
  !*** ./src/framework/ui/UILib/UIMsgBox.ts ***!
  \********************************************/
/*! exports provided: UIMsgBoxArg, UIMsgBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBoxArg", function() { return UIMsgBoxArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBox", function() { return UIMsgBox; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


// 
class UIMsgBoxArg {
    constructor() {
        this.title = "";
        this.content = "";
        this.btnText = ""; //"||"
    }
}
class UIMsgBox extends _UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.bindAll(this);
    }
    onShow(arg) {
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("msgTxt")
], UIMsgBox.prototype, "m_txt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("okBtn")
], UIMsgBox.prototype, "m_okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("cancelBtn")
], UIMsgBox.prototype, "m_cancelBtn", void 0);


/***/ }),

/***/ "./src/framework/ui/UIManager.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIManager.ts ***!
  \***************************************/
/*! exports provided: UIPageTrack, UIManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPageTrack", function() { return UIPageTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIManager", function() { return UIManager; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _UIFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIFactory */ "./src/framework/ui/UIFactory.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");





class UIPageTrack {
}
class UIManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.m_pageTrackStack = new Array();
        this.m_listLoadedPanel = new Array();
    }
    distroyAllLoadedPanel() {
        for (let i = this.m_listLoadedPanel.length - 1; i >= 0; i--) {
            let panel = this.m_listLoadedPanel[i];
            if (panel.isOpen) {
                panel.close();
            }
            //
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.releaseFairyGUIPackage(panel.pkgName);
            panel.dispose();
        }
        this.m_listLoadedPanel.length = 0;
    }
    clean() {
        this.distroyAllLoadedPanel();
        this.m_pageTrackStack.length = 0;
        this.m_listLoadedPanel.length = 0;
    }
    async open(pkg, name, arg) {
        let ui = this.getUI(name);
        if (ui == null) {
            // package
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.loadFairyGUIPackage(pkg);
            ui = _UIFactory__WEBPACK_IMPORTED_MODULE_1__["UIFactory"].createUI(pkg, name);
            this.m_listLoadedPanel.push(ui);
        }
        if (ui != null) {
            // ###  ui as any 
            ui._internalOpen(arg);
        }
        return ui;
    }
    getUI(name) {
        for (const panel of this.m_listLoadedPanel) {
            if (panel.name == name) {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("find panel in cache: " + name);
                return panel;
            }
        }
        return null;
    }
    //,,
    openPageInScene(pkg, page, arg) {
        this.openPageWorker(pkg, page, arg);
    }
    //==========================================================UILoading
    //Loading
    openLoading(pkg, name, arg) {
        this.openPageInScene(pkg, name, arg);
    }
    //Loading
    closeLoading(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================Page
    openPageWorker(pkg, page, arg) {
        this.m_currentPage = new UIPageTrack();
        this.m_currentPage.pkg = pkg;
        this.m_currentPage.name = page;
        this.m_currentPage.arg = arg;
        this.distroyAllLoadedPanel();
        this.open(pkg, page, arg);
    }
    //, ,Widiget
    openPage(pkg, name, arg) {
        if (this.m_currentPage != undefined && this.m_currentPage.name != name) {
            this.m_pageTrackStack.push(this.m_currentPage);
        }
        this.openPageWorker(pkg, name, arg);
    }
    //
    goBackPage() {
        if (this.m_pageTrackStack.length > 0) {
            let track = this.m_pageTrackStack.pop();
            this.openPageWorker(track.pkg, track.name, track.arg);
        }
        else {
            this.enterMainPage();
        }
    }
    //
    enterMainPage() {
        this.m_pageTrackStack.length = 0;
        this.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].UIHomePage, null);
    }
    //==========================================================UIWindow
    //
    async openWindow(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //
    closeWindow(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================UIWidget
    //Widiget
    async openWidget(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //uWidiget
    closeWidget(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPage.ts":
/*!************************************!*\
  !*** ./src/framework/ui/UIPage.ts ***!
  \************************************/
/*! exports provided: UIPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPage", function() { return UIPage; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");



class UIPage extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Page;
    }
    onAwake() {
        this.m_btnGoBack = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].BackBtn);
        if (this.m_btnGoBack != undefined) {
            this.m_btnGoBack.onClick.Add(() => {
                this.onBtnGoBack();
            });
        }
    }
    onShow(vo) {
    }
    onClose(arg) {
    }
    onBtnGoBack() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.goBackPage();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPanel.ts":
/*!*************************************!*\
  !*** ./src/framework/ui/UIPanel.ts ***!
  \*************************************/
/*! exports provided: UIPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPanel", function() { return UIPanel; });
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_1__);


class UIPanel {
    constructor() {
        this.m_layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].Unkown;
    }
    set name(v) {
        this._name = v;
    }
    get name() {
        return this._name;
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UITypeDef"].Unkown;
    }
    get layer() {
        return this.m_layer;
    }
    set layer(v) {
        this.m_layer = v;
    }
    get isOpen() {
        return this.fui.visible;
    }
    onUpdate() { }
    awake() {
        this.onAwake();
    }
    //FairyGUI
    bindAll(target) {
        for (let k in target["binders"]) {
            let fguiName = this["binders"][k];
            this[k] = this.fui.GetChild(fguiName);
        }
    }
    update() {
        this.onUpdate();
    }
    /**
     * UI Manager 
     * @param arg
     */
    _internalOpen(arg) {
        this.layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].getDefaultLayer(this.uiType);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.AddChild(this.fui);
        this.onShow(arg);
    }
    close(arg = null) {
        this.onClose(arg);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.RemoveChild(this.fui);
    }
    dispose() {
        this.fui.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIWindow.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIWindow.ts ***!
  \**************************************/
/*! exports provided: UIWindow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIWindow", function() { return UIWindow; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



class UIWindow extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Window;
    }
    onAwake() {
        this.m_btnClose = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].WindowCloseBtn);
    }
    onShow(arg) {
        this.fui.x = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.width / 2 - this.fui.width / 2;
        this.fui.y = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.height / 2 - this.fui.height / 2;
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Add(this.onBtnClose);
        }
    }
    onClose(arg) {
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Remove(this.onBtnClose);
        }
    }
    onBtnClose() {
        this.close(0);
    }
}


/***/ }),

/***/ "./src/game/api/LoginAPI.ts":
/*!**********************************!*\
  !*** ./src/game/api/LoginAPI.ts ***!
  \**********************************/
/*! exports provided: LoginAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginAPI", function() { return LoginAPI; });
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");




class LoginAPI {
    static async benchmarkTest() {
        for (let i = 1; i < 2; i++) {
            let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.create();
            msg.testID = i;
            msg.testName = "benchmark test";
            let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2GS_Test, msg);
            let test = response;
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].log("code: " + test.Error + ",msg:" + test.Message + ",res:" + test.testResponse);
        }
    }
    static async loginRealmServer(account, password) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.create();
        msg.Account = account;
        msg.Password = password;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendRealmMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2R_Login, msg);
        return response;
    }
    static async loginGateServer(gateId, gateKey) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.create();
        msg.GateId = gateId;
        msg.Key = gateKey;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2G_LoginGate, msg);
        return response;
    }
}


/***/ }),

/***/ "./src/game/event/UIMessage.ts":
/*!*************************************!*\
  !*** ./src/game/event/UIMessage.ts ***!
  \*************************************/
/*! exports provided: UIMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessage", function() { return UIMessage; });
class UIMessage {
}
UIMessage.MSG_SELECT_SERVER = 1000;
UIMessage.MSG_SCENE_PROGRESS = 1001;


/***/ }),

/***/ "./src/game/event/UIMessageManager.ts":
/*!********************************************!*\
  !*** ./src/game/event/UIMessageManager.ts ***!
  \********************************************/
/*! exports provided: UIMessageManger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessageManger", function() { return UIMessageManger; });
/* harmony import */ var _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");


class UIMessageManger extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.uiMessage = new _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.uiMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.uiMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.uiMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.uiMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.uiMessage.broadcast(msgCode, params);
    }
}


/***/ }),

/***/ "./src/game/module/guide/UIGuideWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/guide/UIGuideWin.ts ***!
  \*********************************************/
/*! exports provided: UIGuideWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIGuideWin", function() { return UIGuideWin; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class UIGuideWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.m_focus.alpha = 0.2;
        this.m_focus.SetXY(520, 550);
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("focus")
], UIGuideWin.prototype, "m_focus", void 0);


/***/ }),

/***/ "./src/game/module/home/scene/HomeScene.ts":
/*!*************************************************!*\
  !*** ./src/game/module/home/scene/HomeScene.ts ***!
  \*************************************************/
/*! exports provided: HomeScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HomeScene", function() { return HomeScene; });
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vo/VoHome */ "./src/game/module/home/vo/VoHome.ts");




class HomeScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
        let vo = new _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__["VoHome"]();
        vo.name = "Justin";
        vo.hp = 1200;
        vo.mp = 3300;
        vo.money = 666;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].UIHomePage, vo);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/home/ui/UIHomePage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIHomePage.ts ***!
  \***********************************************/
/*! exports provided: UIHomePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIHomePage", function() { return UIHomePage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








class UIHomePage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
        this.m_chatBtn.onClick.Add(() => {
            this.onchatBtn();
        });
        this.m_bagBtn.onClick.Add(() => {
            this.onbagBtn();
        });
        this.m_shopBtn.onClick.Add(() => {
            this.onshopBtn();
        });
        this.m_levelBtn.onClick.Add(() => {
            this.onlevelBtn();
        });
    }
    onShow(vo) {
        super.onShow(vo);
        this.m_nameLbl.text = vo.name;
        this.m_mpLbl.text = vo.mp.toString();
        this.m_hpLbl.text = vo.hp.toString();
        this.m_moneyLbl.text = vo.money.toString();
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].GameSession.listen(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__["Opcode"].MSG_GS2C_Test, function (msg) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("" + msg.testResponse);
        });
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onchatBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].UIUINoticeWin, null);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on chat...");
    }
    onbagBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on bag ..");
        //benchmark test
        _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__["LoginAPI"].benchmarkTest();
    }
    onshopBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openPage(_data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].UIShopPage);
    }
    onlevelBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on level...");
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("chatBtn")
], UIHomePage.prototype, "m_chatBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("bagBtn")
], UIHomePage.prototype, "m_bagBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("shopBtn")
], UIHomePage.prototype, "m_shopBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("levelBtn")
], UIHomePage.prototype, "m_levelBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("nameTxt")
], UIHomePage.prototype, "m_nameLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hpTxt")
], UIHomePage.prototype, "m_hpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("mpTxt")
], UIHomePage.prototype, "m_mpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("moneyTxt")
], UIHomePage.prototype, "m_moneyLbl", void 0);


/***/ }),

/***/ "./src/game/module/home/ui/UIShopPage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIShopPage.ts ***!
  \***********************************************/
/*! exports provided: UIShopPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIShopPage", function() { return UIShopPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");

class UIShopPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}


/***/ }),

/***/ "./src/game/module/home/vo/VoHome.ts":
/*!*******************************************!*\
  !*** ./src/game/module/home/vo/VoHome.ts ***!
  \*******************************************/
/*! exports provided: VoHome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoHome", function() { return VoHome; });
class VoHome {
}


/***/ }),

/***/ "./src/game/module/login/scene/LoginScene.ts":
/*!***************************************************!*\
  !*** ./src/game/module/login/scene/LoginScene.ts ***!
  \***************************************************/
/*! exports provided: LoginScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginScene", function() { return LoginScene; });
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");



class LoginScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    onEnter() {
    }
    onComplete() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].UILoginPage, null);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/login/ui/UILoginPage.ts":
/*!*************************************************!*\
  !*** ./src/game/module/login/ui/UILoginPage.ts ***!
  \*************************************************/
/*! exports provided: UILoginPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoginPage", function() { return UILoginPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vo/VoServer */ "./src/game/module/login/vo/VoServer.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











class UILoginPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    constructor() {
        super(...arguments);
        this._effectGo = null;
    }
    async onAwake() {
        super.onAwake();
        this.m_loginBtn.onClick.Add(() => {
            this.onLoginClick();
        });
        this.m_storyBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].PackageName, _data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].UIStoryWin, null);
        });
        this.m_newGuideBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].UIUIGuideWin, null);
        });
        this.m_selserverBtn.onClick.Add(() => {
            this.openSelServerWin();
        });
        // let connected = await S.SessionManager.connectRealmServer();
        // this.m_loginBtn.enabled = connected;
        // Logger.log("connect ream server: "+connected)
    }
    onSelectServer(serverItem) {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(" server selected: " + serverItem.serverName);
        this.m_selserverBtn.text = serverItem.serverName;
    }
    async onShow(vo) {
        super.onShow(vo);
        //
        this._effectGo = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.loadPrefab("Effect/Prefab/UI/ef_ui_pet_rank_yellow_test.prefab");
        let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(this._effectGo);
        let wrapper = new csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GoWrapper(inst);
        this.m_holder.SetNativeObject(wrapper);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.addListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this, this.onSelectServer);
    }
    onClose(arg) {
        super.onClose(arg);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.releaseAddressGO(this._effectGo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.removeListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this.onSelectServer);
    }
    openSelServerWin() {
        // 
        let voServer = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServer"]();
        for (let i = 1; i < 10; i++) {
            voServer.areaMap.set(i, "" + i);
            voServer.serverMap.set(i, new Array());
            for (let j = 1; j < 20; j++) {
                let voServerItem = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServerItem"]();
                voServerItem.areaId = i;
                voServerItem.serverId = j;
                voServerItem.serverName = "" + i + ":" + j;
                voServerItem.serverStatus = Math.floor(Math.random() * 3 + 1);
                voServer.serverMap.get(i).push(voServerItem);
            }
        }
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin, voServer);
    }
    async onLoginClick() {
        let account = this.m_account.text;
        let password = this.m_password.text;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`account:${account} - password: ${password}`);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__["SceneDef"].HomeScene);
        // if(account != "" && password != ""){
        //     let msg = await LoginAPI.loginRealmServer(account, password)
        //     this.gateId = msg.GateId;
        //     this.gateKey = msg.Key;
        //     Logger.log("login ream succ, gate addr:"+msg.Address + ",key:"+msg.Key);
        //     S.SessionManager.disconnectRealmServer();
        //     //
        //     let connected = await S.SessionManager.connectGateServer(msg.Address);
        //     if(connected){
        //         Logger.log("connect gate succ")
        //         let msg = await LoginAPI.loginGateServer( this.gateId, this.gateKey)
        //         let playerID = msg.PlayerId;
        //         Logger.log("login gate response.." +playerID);
        //         S.SceneManager.loadScene(SceneDef.HomeScene);
        //     }else{
        //     Logger.log("connect gate err ")
        //     }
        //  }
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("account")
], UILoginPage.prototype, "m_account", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("password")
], UILoginPage.prototype, "m_password", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("selserverBtn")
], UILoginPage.prototype, "m_selserverBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("loginBtn")
], UILoginPage.prototype, "m_loginBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("storyBtn")
], UILoginPage.prototype, "m_storyBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("newGuideBtn")
], UILoginPage.prototype, "m_newGuideBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hold")
], UILoginPage.prototype, "m_holder", void 0);


/***/ }),

/***/ "./src/game/module/login/ui/UISelServerWin.ts":
/*!****************************************************!*\
  !*** ./src/game/module/login/ui/UISelServerWin.ts ***!
  \****************************************************/
/*! exports provided: UISelServerWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UISelServerWin", function() { return UISelServerWin; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _UIServerListItem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UIServerListItem */ "./src/game/module/login/ui/UIServerListItem.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class UISelServerWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_2__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.clickAreaIndex = 0;
        this.clickServerIndex = 0;
    }
    onAwake() {
        super.onAwake();
        this.backBtn.onClick.Add(() => {
            this.close();
        });
        this.okBtn.onClick.Add(() => {
            this.onSelectServer();
        });
        this.areaList.onClickItem.Add((event) => {
            this.clickAreaIndex = this.areaList.GetChildIndex(event.data);
            this.serverList.numItems = this.voServer.serverMap.get(this.clickAreaIndex + 1).length;
            this.serverList.RefreshVirtualList();
        });
        this.serverList.onClickItem.Add((event) => {
            this.clickServerIndex = this.serverList.GetChildIndex(event.data);
            this.title.text = "" + this.clickServerIndex;
        });
        let pool = [];
        csharp__WEBPACK_IMPORTED_MODULE_0__["FairyGUI"].UIObjectFactory.SetPackageItemExtension("ui://l64dumk9feeg54", () => {
            let item = new _UIServerListItem__WEBPACK_IMPORTED_MODULE_5__["UIServerListItem"]();
            pool.push(item);
            return item;
        });
    }
    onSelectServer() {
        let selItem = this.voServer.serverMap.get(this.clickAreaIndex + 1)[this.clickServerIndex];
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].UIMessageManger.broadcast(_event_UIMessage__WEBPACK_IMPORTED_MODULE_4__["UIMessage"].MSG_SELECT_SERVER, selItem);
        this.close();
    }
    onShow(vo) {
        super.onShow(vo);
        this.voServer = vo;
        this.areaList.SetVirtual();
        this.areaList.itemRenderer = (index, obj) => {
            this.renderAreaListItem(index, obj);
        };
        this.areaList.numItems = vo.areaMap.size;
        this.serverList.SetVirtual();
        this.serverList.itemRenderer = (index, obj) => {
            this.renderServerListItem(index, obj);
        };
        this.serverList.numItems = vo.serverMap.get(this.clickAreaIndex + 1).length;
    }
    renderAreaListItem(index, obj) {
        let areaBtn = obj.asButton;
        areaBtn.text = this.voServer.areaMap.get(index + 1);
    }
    renderServerListItem(index, item) {
        if (item instanceof _UIServerListItem__WEBPACK_IMPORTED_MODULE_5__["UIServerListItem"]) {
            console.log("1111111111111111111111");
        }
        else {
            console.log("333333333333333333");
        }
        item.itemLabel = this.voServer.serverMap.get(this.clickAreaIndex + 1)[index].serverName;
        //serverBtn.icon = FairyGUI.UIPackage.
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("areaList")
], UISelServerWin.prototype, "areaList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("serverList")
], UISelServerWin.prototype, "serverList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("backBtn")
], UISelServerWin.prototype, "backBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("okBtn")
], UISelServerWin.prototype, "okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("title")
], UISelServerWin.prototype, "title", void 0);


/***/ }),

/***/ "./src/game/module/login/ui/UIServerListItem.ts":
/*!******************************************************!*\
  !*** ./src/game/module/login/ui/UIServerListItem.ts ***!
  \******************************************************/
/*! exports provided: UIServerListItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIServerListItem", function() { return UIServerListItem; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);

class UIServerListItem extends csharp__WEBPACK_IMPORTED_MODULE_0__["FairyGUI"].GButton {
    set itemLabel(txt) {
        this.text = txt;
    }
}


/***/ }),

/***/ "./src/game/module/login/vo/VoServer.ts":
/*!**********************************************!*\
  !*** ./src/game/module/login/vo/VoServer.ts ***!
  \**********************************************/
/*! exports provided: VoServerItem, VoServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServerItem", function() { return VoServerItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServer", function() { return VoServer; });
class VoServerItem {
}
class VoServer {
    constructor() {
        this.serverMap = new Map();
        this.areaMap = new Map();
    }
}


/***/ }),

/***/ "./src/game/module/pve/scene/PveScene.ts":
/*!***********************************************!*\
  !*** ./src/game/module/pve/scene/PveScene.ts ***!
  \***********************************************/
/*! exports provided: PveScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PveScene", function() { return PveScene; });
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");

class PveScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/story/UIStoryWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/story/UIStoryWin.ts ***!
  \*********************************************/
/*! exports provided: UIStoryWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIStoryWin", function() { return UIStoryWin; });
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class UIStoryWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.shouldContineStory = false;
        this.optionsMap = new Map();
    }
    onAwake() {
        super.onAwake();
        this.m_btnList.itemRenderer = (index, obj) => {
            this.renderBtnList(index, obj);
        };
        this.m_btnList.onClickItem.Add((event) => {
            let clickId = this.m_btnList.GetChildIndex(event.data);
            if (this.shouldContineStory) {
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.advanceStory();
            }
            else {
                this.optionsMap.clear();
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.selectChoice(this.allChoices[clickId]);
            }
        });
    }
    onShow(vo) {
        super.onShow(vo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this, this.OnStoryFinished);
        this.optionsMap.clear();
        this.shouldContineStory = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.beginStory("story2");
    }
    OnContentReady(speakerContent, speakerId, currentTags, currentChoices) {
        this.m_speakerTxt.text = speakerContent;
        if (_global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.canContinue) {
            this.shouldContineStory = true;
            this.m_btnList.numItems = 1;
        }
        if (currentChoices.length > 0) {
            this.allChoices = currentChoices;
            this.shouldContineStory = false;
            let len = currentChoices.length;
            for (let i = 0; i < len; i++) {
                this.optionsMap.set(i, currentChoices[i].text);
            }
            this.m_btnList.numItems = len;
        }
    }
    renderBtnList(index, obj) {
        let continueBtn = obj.asButton;
        if (this.optionsMap.size > 0) {
            continueBtn.text = this.optionsMap.get(index);
        }
        else {
            continueBtn.text = "";
        }
    }
    OnChoicesPresented(currentChoices) {
        this.shouldContineStory = false;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("....OnChoicesPresented......");
    }
    OnStoryFinished() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Story Finished");
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].UIManager.closeWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_0__["storyUI"].UIStoryWin, null);
    }
    onClose(arg) {
        super.onClose(arg);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this.OnStoryFinished);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("speakerTxt")
], UIStoryWin.prototype, "m_speakerTxt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("btnList")
], UIStoryWin.prototype, "m_btnList", void 0);


/***/ }),

/***/ "./src/global/GameConfig.ts":
/*!**********************************!*\
  !*** ./src/global/GameConfig.ts ***!
  \**********************************/
/*! exports provided: GameConfig, S */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameConfig", function() { return GameConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return S; });
/* harmony import */ var _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
/* harmony import */ var _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../framework/net/GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../framework/net/HttpManager */ "./src/framework/net/HttpManager.ts");
/* harmony import */ var _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
/* harmony import */ var _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
/* harmony import */ var _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
/* harmony import */ var _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");










class GameConfig {
}
GameConfig.debug = true;
GameConfig.realmServerIP = "127.0.0.1";
GameConfig.realmServerPort = 9001;
class S {
}
S.UIManager = _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"].Instance(_framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"]);
S.UIMessageManger = _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"].Instance(_game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"]);
S.SceneManager = _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"].Instance(_framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"]);
S.GameObjectPool = _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"].Instance(_framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"]);
S.ResManager = _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]);
S.StoryManager = _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"].Instance(_framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"]);
S.SessionManager = _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"].Instance(_framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"]);
S.GameSession = _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]);
S.StoryMessageManager = _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]);
S.HttpManager = _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"].Instance(_framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"]);


/***/ }),

/***/ "csharp":
/*!*************************!*\
  !*** external "csharp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("csharp");

/***/ }),

/***/ "puerts":
/*!*************************!*\
  !*** external "puerts" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("puerts");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2FsbFN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2hvaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2hvaWNlUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Db250cm9sQ29tbWFuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvRGl2ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvR2x1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0lua0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Kc29uU2VyaWFsaXNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0xpc3REZWZpbml0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTGlzdERlZmluaXRpb25zT3JpZ2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTmF0aXZlRnVuY3Rpb25DYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTnVsbEV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1BSTkcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1B1c2hQb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TZWFyY2hSZXN1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TaW1wbGVKc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RhdGVQYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3BXYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcnlFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdG9yeVN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RyaW5nQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1RyeUdldFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1R5cGVBc3NlcnRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhcmlhYmxlQXNzaWdubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhcmlhYmxlUmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVzU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Wb2lkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0dhbWVNYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3BiL09wY29kZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9wYi9nZW4vcGIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvY29tYmF0LnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3VpL2NvbW1vbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9ob21lLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3VpL2xvZ2luLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3VpL3N0b3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL0dhbWVPYmplY3RQb29sLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL01lc3Nlbmdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL1Jlc01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vU2luZ2xldG9uLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL0lua1N0YXRlSW5zcGVjdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL0lua1dyaXRlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9TdG9yeU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvU3RvcnlNZXNzYWdlTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvR2FtZVNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvSHR0cE1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvTWVzc2FnZVBhcnNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9OZXRFcnJvckNvZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvU2Vzc2lvbk1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZURlZi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3NjZW5lL1NjZW5lRmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJRGVmaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlMaWIvVUlMb2FkaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlMaWIvVUlNc2dCb3gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSVBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSVBhbmVsLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlXaW5kb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvYXBpL0xvZ2luQVBJLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2V2ZW50L1VJTWVzc2FnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9ldmVudC9VSU1lc3NhZ2VNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ndWlkZS9VSUd1aWRlV2luLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3NjZW5lL0hvbWVTY2VuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS91aS9VSUhvbWVQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3VpL1VJU2hvcFBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvdm8vVm9Ib21lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi9zY2VuZS9Mb2dpblNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi91aS9VSUxvZ2luUGFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlTZWxTZXJ2ZXJXaW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJU2VydmVyTGlzdEl0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3ZvL1ZvU2VydmVyLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9wdmUvc2NlbmUvUHZlU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL3N0b3J5L1VJU3RvcnlXaW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dsb2JhbC9HYW1lQ29uZmlnLnRzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNzaGFycFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInB1ZXJ0c1wiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRmE7QUFDYjs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxFQUFFO0FBQ2IsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNB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QUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ25ELDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHlCQUF5QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsSUFBSTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DOzs7Ozs7Ozs7Ozs7QUMvY2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQix5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsaUVBQWU7QUFDN0MsNEJBQTRCLG1CQUFPLENBQUMsNkVBQXFCO0FBQ3pELDZCQUE2QixtQkFBTyxDQUFDLCtFQUFzQjtBQUMzRCw2QkFBNkIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDM0QsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyxpREFBTztBQUM3QixlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELGdDQUFnQyxtQkFBTyxDQUFDLHFGQUF5QjtBQUNqRSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1EQUFtRDtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZDOzs7Ozs7Ozs7Ozs7QUM3a0JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsMEM7Ozs7Ozs7Ozs7OztBQ2hFYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRDs7Ozs7Ozs7Ozs7O0FDckRhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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LG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsS0FBSyxFQUFFO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNENBQTRDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHVEQUF1RDtBQUM1RCxDQUFDLDZEQUE2RDtBQUM5RCxzQzs7Ozs7Ozs7Ozs7O0FDOVdhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxzQzs7Ozs7Ozs7Ozs7O0FDbEVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDOzs7Ozs7Ozs7Ozs7QUN6QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DLDRCQUE0QixtQkFBTyxDQUFDLDZFQUFxQjtBQUN6RCxxQkFBcUIsbUJBQU8sQ0FBQywrREFBYztBQUMzQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsaUVBQWU7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQixjQUFjLG1CQUFPLENBQUMsaURBQU87QUFDN0IsNkJBQTZCLG1CQUFPLENBQUMsK0VBQXNCO0FBQzNELDRCQUE0QixtQkFBTyxDQUFDLDZFQUFxQjtBQUN6RCw2QkFBNkIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDM0QseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQix3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMscUZBQXlCO0FBQ2pFLG9CQUFvQixtQkFBTyxDQUFDLDZEQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsK0RBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMseURBQVc7QUFDbkMsMkNBQTJDLHFDQUFxQywwQkFBMEIsRUFBRSxFQUFFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxxQkFBcUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxRQUFRO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdCQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVDQUF1QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUJBQXlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0QsaUM7Ozs7Ozs7Ozs7OztBQy9VYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7Ozs7Ozs7OztBQ2hCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUN0Q2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCw0QkFBNEIsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pELHVCQUF1QixtQkFBTyxDQUFDLG1FQUFnQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0FBQyxzRkFBbUIsQ0FBQyxDQUFDO0FBQ3hFLGFBQVcsR0FBRyxzRUFBVyxDQUFDLFFBQVEsQ0FBQyxzRUFBVyxDQUFDLENBQUM7Ozs7Ozs7Ozs7OztBQzlCbEUsbUM7Ozs7Ozs7Ozs7O0FDQUEsbUMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvR2FtZU1haW4udHNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBhc1Byb21pc2U7XHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5hc1Byb21pc2V9LlxyXG4gKiBAdHlwZWRlZiBhc1Byb21pc2VDYWxsYmFja1xyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBBZGRpdGlvbmFsIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmcm9tIGEgbm9kZS1zdHlsZSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHthc1Byb21pc2VDYWxsYmFja30gZm4gRnVuY3Rpb24gdG8gY2FsbFxyXG4gKiBAcGFyYW0geyp9IGN0eCBGdW5jdGlvbiBjb250ZXh0XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTwqPn0gUHJvbWlzaWZpZWQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGFzUHJvbWlzZShmbiwgY3R4LyosIHZhcmFyZ3MgKi8pIHtcclxuICAgIHZhciBwYXJhbXMgID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICBvZmZzZXQgID0gMCxcclxuICAgICAgICBpbmRleCAgID0gMixcclxuICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcclxuICAgIHdoaWxlIChpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGgpXHJcbiAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0XSA9IGZ1bmN0aW9uIGNhbGxiYWNrKGVyci8qLCB2YXJhcmdzICovKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IHBhcmFtcy5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbb2Zmc2V0XTtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlLmFwcGx5KG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZuLmFwcGx5KGN0eCB8fCBudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgYmFzZTY0IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgYmFzZTY0ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBieXRlIGxlbmd0aCBvZiBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbmJhc2U2NC5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgcCA9IHN0cmluZy5sZW5ndGg7XHJcbiAgICBpZiAoIXApXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgbiA9IDA7XHJcbiAgICB3aGlsZSAoLS1wICUgNCA+IDEgJiYgc3RyaW5nLmNoYXJBdChwKSA9PT0gXCI9XCIpXHJcbiAgICAgICAgKytuO1xyXG4gICAgcmV0dXJuIE1hdGguY2VpbChzdHJpbmcubGVuZ3RoICogMykgLyA0IC0gbjtcclxufTtcclxuXHJcbi8vIEJhc2U2NCBlbmNvZGluZyB0YWJsZVxyXG52YXIgYjY0ID0gbmV3IEFycmF5KDY0KTtcclxuXHJcbi8vIEJhc2U2NCBkZWNvZGluZyB0YWJsZVxyXG52YXIgczY0ID0gbmV3IEFycmF5KDEyMyk7XHJcblxyXG4vLyA2NS4uOTAsIDk3Li4xMjIsIDQ4Li41NywgNDMsIDQ3XHJcbmZvciAodmFyIGkgPSAwOyBpIDwgNjQ7KVxyXG4gICAgczY0W2I2NFtpXSA9IGkgPCAyNiA/IGkgKyA2NSA6IGkgPCA1MiA/IGkgKyA3MSA6IGkgPCA2MiA/IGkgLSA0IDogaSAtIDU5IHwgNDNdID0gaSsrO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZXMgYSBidWZmZXIgdG8gYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqL1xyXG5iYXNlNjQuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCAvLyBvdXRwdXQgaW5kZXhcclxuICAgICAgICBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHZhciBiID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgPj4gMl07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAzKSA8PCA0O1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA0XTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDE1KSA8PCAyO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0IHwgYiA+PiA2XTtcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiAmIDYzXTtcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaikge1xyXG4gICAgICAgIGNodW5rW2krK10gPSBiNjRbdF07XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxudmFyIGludmFsaWRFbmNvZGluZyA9IFwiaW52YWxpZCBlbmNvZGluZ1wiO1xyXG5cclxuLyoqXHJcbiAqIERlY29kZXMgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gYSBidWZmZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gTnVtYmVyIG9mIGJ5dGVzIHdyaXR0ZW5cclxuICogQHRocm93cyB7RXJyb3J9IElmIGVuY29kaW5nIGlzIGludmFsaWRcclxuICovXHJcbmJhc2U2NC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xyXG4gICAgdmFyIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOykge1xyXG4gICAgICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBpZiAoYyA9PT0gNjEgJiYgaiA+IDEpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGlmICgoYyA9IHM2NFtjXSkgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gdCA8PCAyIHwgKGMgJiA0OCkgPj4gNDtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMTUpIDw8IDQgfCAoYyAmIDYwKSA+PiAyO1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAzKSA8PCA2IHwgYztcclxuICAgICAgICAgICAgICAgIGogPSAwO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEVuY29kaW5nKTtcclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHN0cmluZyBhcHBlYXJzIHRvIGJlIGJhc2U2NCBlbmNvZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZyB0byB0ZXN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcHJvYmFibHkgYmFzZTY0IGVuY29kZWQsIG90aGVyd2lzZSBmYWxzZVxyXG4gKi9cclxuYmFzZTY0LnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHN0cmluZykge1xyXG4gICAgcmV0dXJuIC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kLy50ZXN0KHN0cmluZyk7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGV2ZW50IGVtaXR0ZXIgaW5zdGFuY2UuXHJcbiAqIEBjbGFzc2Rlc2MgQSBtaW5pbWFsIGV2ZW50IGVtaXR0ZXIuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj59XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lci5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIExpc3RlbmVyXHJcbiAqIEBwYXJhbSB7Kn0gW2N0eF0gTGlzdGVuZXIgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2dCwgZm4sIGN0eCkge1xyXG4gICAgKHRoaXMuX2xpc3RlbmVyc1tldnRdIHx8ICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdKSkucHVzaCh7XHJcbiAgICAgICAgZm4gIDogZm4sXHJcbiAgICAgICAgY3R4IDogY3R4IHx8IHRoaXNcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhbiBldmVudCBsaXN0ZW5lciBvciBhbnkgbWF0Y2hpbmcgbGlzdGVuZXJzIGlmIGFyZ3VtZW50cyBhcmUgb21pdHRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtldnRdIEV2ZW50IG5hbWUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBpZiBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZm5dIExpc3RlbmVyIHRvIHJlbW92ZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIG9mIGBldnRgIGlmIG9taXR0ZWQuXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIG9mZihldnQsIGZuKSB7XHJcbiAgICBpZiAoZXZ0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoZm4gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tpXS5mbiA9PT0gZm4pXHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdHMgYW4gZXZlbnQgYnkgY2FsbGluZyBpdHMgbGlzdGVuZXJzIHdpdGggdGhlIHNwZWNpZmllZCBhcmd1bWVudHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2dCkge1xyXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldnRdO1xyXG4gICAgaWYgKGxpc3RlbmVycykge1xyXG4gICAgICAgIHZhciBhcmdzID0gW10sXHJcbiAgICAgICAgICAgIGkgPSAxO1xyXG4gICAgICAgIGZvciAoOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2krK10uY3R4LCBhcmdzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShmYWN0b3J5KTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyAvIHdyaXRlcyBmbG9hdHMgLyBkb3VibGVzIGZyb20gLyB0byBidWZmZXJzLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0XHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDY0IGJpdCBkb3VibGUgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlTEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgNjQgYml0IGRvdWJsZSBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRG91YmxlQkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLy8gRmFjdG9yeSBmdW5jdGlvbiBmb3IgdGhlIHB1cnBvc2Ugb2Ygbm9kZS1iYXNlZCB0ZXN0aW5nIGluIG1vZGlmaWVkIGdsb2JhbCBlbnZpcm9ubWVudHNcclxuZnVuY3Rpb24gZmFjdG9yeShleHBvcnRzKSB7XHJcblxyXG4gICAgLy8gZmxvYXQ6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShbIC0wIF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmMzIuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzNdID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9jcHkgOiB3cml0ZUZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfcmV2IDogd3JpdGVGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfZjMyX3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIHJldHVybiBmMzJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfY3B5IDogcmVhZEZsb2F0X2YzMl9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gbGUgPyByZWFkRmxvYXRfZjMyX3JldiA6IHJlYWRGbG9hdF9mMzJfY3B5O1xyXG5cclxuICAgIC8vIGZsb2F0OiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9pZWVlNzU0KHdyaXRlVWludCwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWwpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDMyODkzNDQsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID4gMy40MDI4MjM0NjYzODUyODg2ZSszOCkgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjEzOTA5NTA0MCkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsIDwgMS4xNzU0OTQzNTA4MjIyODc1ZS0zOCkgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IE1hdGgucm91bmQodmFsIC8gMS40MDEyOTg0NjQzMjQ4MTdlLTQ1KSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSBNYXRoLnJvdW5kKHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCkgKiA4Mzg4NjA4KSAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEyNyA8PCAyMyB8IG1hbnRpc3NhKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFKTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRCRSA9IHdyaXRlRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2llZWU3NTQocmVhZFVpbnQsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciB1aW50ID0gcmVhZFVpbnQoYnVmLCBwb3MpLFxyXG4gICAgICAgICAgICAgICAgc2lnbiA9ICh1aW50ID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSB1aW50ID4+PiAyMyAmIDI1NSxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdWludCAmIDgzODg2MDc7XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjU1XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDE1MCkgKiAobWFudGlzc2EgKyA4Mzg4NjA4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0TEUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSByZWFkRmxvYXRfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUpO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy8gZG91YmxlOiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDY0QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoWy0wXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGY2NC5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbN10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X2NweSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzBdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbN107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfcmV2KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbN107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbNF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfY3B5IDogd3JpdGVEb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X3JldiA6IHdyaXRlRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X2NweShidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfZjY0X3JldihidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICAgIF07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyAxXTtcclxuICAgICAgICAgICAgZjhiWzVdID0gYnVmW3BvcyArIDJdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgM107XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyA0XTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDVdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgNl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyA3XTtcclxuICAgICAgICAgICAgcmV0dXJuIGY2NFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSBsZSA/IHJlYWREb3VibGVfZjY0X2NweSA6IHJlYWREb3VibGVfZjY0X3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9yZXYgOiByZWFkRG91YmxlX2Y2NF9jcHk7XHJcblxyXG4gICAgLy8gZG91YmxlOiBpZWVlNzU0XHJcbiAgICB9KSgpOyBlbHNlIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfaWVlZTc1NCh3cml0ZVVpbnQsIG9mZjAsIG9mZjEsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDIxNDY5NTkzNjAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsID4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpIHsgLy8gKy1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTQ2NDM1MDcyKSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYW50aXNzYTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWwgPCAyLjIyNTA3Mzg1ODUwNzIwMTRlLTMwOCkgeyAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsIC8gNWUtMzI0O1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBtYW50aXNzYSAvIDQyOTQ5NjcyOTYpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXhwb25lbnQgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbCkgLyBNYXRoLkxOMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09PSAxMDI0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IDEwMjM7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludChtYW50aXNzYSAqIDQ1MDM1OTk2MjczNzA0OTYgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMDIzIDw8IDIwIHwgbWFudGlzc2EgKiAxMDQ4NTc2ICYgMTA0ODU3NSkgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9pZWVlNzU0KHJlYWRVaW50LCBvZmYwLCBvZmYxLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgbG8gPSByZWFkVWludChidWYsIHBvcyArIG9mZjApLFxyXG4gICAgICAgICAgICAgICAgaGkgPSByZWFkVWludChidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IChoaSA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gaGkgPj4+IDIwICYgMjA0NyxcclxuICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gNDI5NDk2NzI5NiAqIChoaSAmIDEwNDg1NzUpICsgbG87XHJcbiAgICAgICAgICAgIHJldHVybiBleHBvbmVudCA9PT0gMjA0N1xyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiA1ZS0zMjQgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxMDc1KSAqIChtYW50aXNzYSArIDQ1MDM1OTk2MjczNzA0OTYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlTEUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50QkUsIDQsIDApO1xyXG5cclxuICAgIH0pKCk7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbn1cclxuXHJcbi8vIHVpbnQgaGVscGVyc1xyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50TEUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludEJFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgPj4+IDI0O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiA4ICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludExFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXVxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdIDw8IDI0KSA+Pj4gMDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRCRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF0gPDwgMjRcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSkgPj4+IDA7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gaW5xdWlyZTtcclxuXHJcbi8qKlxyXG4gKiBSZXF1aXJlcyBhIG1vZHVsZSBvbmx5IGlmIGF2YWlsYWJsZS5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWUgTW9kdWxlIHRvIHJlcXVpcmVcclxuICogQHJldHVybnMgez9PYmplY3R9IFJlcXVpcmVkIG1vZHVsZSBpZiBhdmFpbGFibGUgYW5kIG5vdCBlbXB0eSwgb3RoZXJ3aXNlIGBudWxsYFxyXG4gKi9cclxuZnVuY3Rpb24gaW5xdWlyZShtb2R1bGVOYW1lKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhciBtb2QgPSBldmFsKFwicXVpcmVcIi5yZXBsYWNlKC9eLyxcInJlXCIpKShtb2R1bGVOYW1lKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXHJcbiAgICAgICAgaWYgKG1vZCAmJiAobW9kLmxlbmd0aCB8fCBPYmplY3Qua2V5cyhtb2QpLmxlbmd0aCkpXHJcbiAgICAgICAgICAgIHJldHVybiBtb2Q7XHJcbiAgICB9IGNhdGNoIChlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBwb29sO1xyXG5cclxuLyoqXHJcbiAqIEFuIGFsbG9jYXRvciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sQWxsb2NhdG9yXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIHNsaWNlciBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLnBvb2x9LlxyXG4gKiBAdHlwZWRlZiBQb29sU2xpY2VyXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIEVuZCBvZmZzZXRcclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlciBzbGljZVxyXG4gKiBAdGhpcyB7VWludDhBcnJheX1cclxuICovXHJcblxyXG4vKipcclxuICogQSBnZW5lcmFsIHB1cnBvc2UgYnVmZmVyIHBvb2wuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1Bvb2xBbGxvY2F0b3J9IGFsbG9jIEFsbG9jYXRvclxyXG4gKiBAcGFyYW0ge1Bvb2xTbGljZXJ9IHNsaWNlIFNsaWNlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9ODE5Ml0gU2xhYiBzaXplXHJcbiAqIEByZXR1cm5zIHtQb29sQWxsb2NhdG9yfSBQb29sZWQgYWxsb2NhdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBwb29sKGFsbG9jLCBzbGljZSwgc2l6ZSkge1xyXG4gICAgdmFyIFNJWkUgICA9IHNpemUgfHwgODE5MjtcclxuICAgIHZhciBNQVggICAgPSBTSVpFID4+PiAxO1xyXG4gICAgdmFyIHNsYWIgICA9IG51bGw7XHJcbiAgICB2YXIgb2Zmc2V0ID0gU0laRTtcclxuICAgIHJldHVybiBmdW5jdGlvbiBwb29sX2FsbG9jKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IE1BWClcclxuICAgICAgICAgICAgcmV0dXJuIGFsbG9jKHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgKyBzaXplID4gU0laRSkge1xyXG4gICAgICAgICAgICBzbGFiID0gYWxsb2MoU0laRSk7XHJcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBzbGljZS5jYWxsKHNsYWIsIG9mZnNldCwgb2Zmc2V0ICs9IHNpemUpO1xyXG4gICAgICAgIGlmIChvZmZzZXQgJiA3KSAvLyBhbGlnbiB0byAzMiBiaXRcclxuICAgICAgICAgICAgb2Zmc2V0ID0gKG9mZnNldCB8IDcpICsgMTtcclxuICAgICAgICByZXR1cm4gYnVmO1xyXG4gICAgfTtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBBIG1pbmltYWwgVVRGOCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIHV0ZjggPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFVURjggYnl0ZSBsZW5ndGggb2YgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG51dGY4Lmxlbmd0aCA9IGZ1bmN0aW9uIHV0ZjhfbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIGxlbiA9IDAsXHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDEyOClcclxuICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgZWxzZSBpZiAoYyA8IDIwNDgpXHJcbiAgICAgICAgICAgIGxlbiArPSAyO1xyXG4gICAgICAgIGVsc2UgaWYgKChjICYgMHhGQzAwKSA9PT0gMHhEODAwICYmIChzdHJpbmcuY2hhckNvZGVBdChpICsgMSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBsZW4gKz0gNDtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgbGVuICs9IDM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGVuO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIFVURjggYnl0ZXMgYXMgYSBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFNvdXJjZSBzdGFydFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIFNvdXJjZSBlbmRcclxuICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcclxuICovXHJcbnV0ZjgucmVhZCA9IGZ1bmN0aW9uIHV0ZjhfcmVhZChidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChsZW4gPCAxKVxyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgdmFyIHBhcnRzID0gbnVsbCxcclxuICAgICAgICBjaHVuayA9IFtdLFxyXG4gICAgICAgIGkgPSAwLCAvLyBjaGFyIG9mZnNldFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xyXG4gICAgICAgIHQgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgaWYgKHQgPCAxMjgpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSB0O1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAxOTEgJiYgdCA8IDIyNClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMzEpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBlbHNlIGlmICh0ID4gMjM5ICYmIHQgPCAzNjUpIHtcclxuICAgICAgICAgICAgdCA9ICgodCAmIDcpIDw8IDE4IHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzKSAtIDB4MTAwMDA7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweEQ4MDAgKyAodCA+PiAxMCk7XHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAweERDMDAgKyAodCAmIDEwMjMpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAxNSkgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MztcclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSBzdHJpbmcgYXMgVVRGOCBieXRlcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlcyB3cml0dGVuXHJcbiAqL1xyXG51dGY4LndyaXRlID0gZnVuY3Rpb24gdXRmOF93cml0ZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQsXHJcbiAgICAgICAgYzEsIC8vIGNoYXJhY3RlciAxXHJcbiAgICAgICAgYzI7IC8vIGNoYXJhY3RlciAyXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgIGMxID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMTtcclxuICAgICAgICB9IGVsc2UgaWYgKGMxIDwgMjA0OCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgICAgICB8IDE5MjtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKChjMiA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSkgJiAweEZDMDApID09PSAweERDMDApIHtcclxuICAgICAgICAgICAgYzEgPSAweDEwMDAwICsgKChjMSAmIDB4MDNGRikgPDwgMTApICsgKGMyICYgMHgwM0ZGKTtcclxuICAgICAgICAgICAgKytpO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTggICAgICB8IDI0MDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgICAgICB8IDIyNDtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbGxTdGFjayA9IHZvaWQgMDtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgU3RvcnlfMSA9IHJlcXVpcmUoXCIuL1N0b3J5XCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBDYWxsU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgU3RvcnlfMS5TdG9yeSkge1xuICAgICAgICAgICAgbGV0IHN0b3J5Q29udGV4dCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihzdG9yeUNvbnRleHQucm9vdENvbnRlbnRDb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5SZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHRvQ29weSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuX3RocmVhZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IG90aGVyVGhyZWFkIG9mIHRvQ29weS5fdGhyZWFkcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RocmVhZHMucHVzaChvdGhlclRocmVhZC5Db3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IHRvQ29weS5fdGhyZWFkQ291bnRlcjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gdG9Db3B5Ll9zdGFydE9mUm9vdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjaztcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RWxlbWVudCgpIHtcbiAgICAgICAgbGV0IHRocmVhZCA9IHRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgbGV0IGNzID0gdGhyZWFkLmNhbGxzdGFjaztcbiAgICAgICAgcmV0dXJuIGNzW2NzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVsZW1lbnRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGhyZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyZWFkc1t0aGlzLl90aHJlYWRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFRocmVhZCh2YWx1ZSkge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydCh0aGlzLl90aHJlYWRzLmxlbmd0aCA9PSAxLCBcIlNob3VsZG4ndCBiZSBkaXJlY3RseSBzZXR0aW5nIHRoZSBjdXJyZW50IHRocmVhZCB3aGVuIHdlIGhhdmUgYSBzdGFjayBvZiB0aGVtXCIpO1xuICAgICAgICB0aGlzLl90aHJlYWRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3RocmVhZHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBjYW5Qb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGggPiAxO1xuICAgIH1cbiAgICBSZXNldCgpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkcyA9IFtdO1xuICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2gobmV3IENhbGxTdGFjay5UaHJlYWQoKSk7XG4gICAgICAgIHRoaXMuX3RocmVhZHNbMF0uY2FsbHN0YWNrLnB1c2gobmV3IENhbGxTdGFjay5FbGVtZW50KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwsIHRoaXMuX3N0YXJ0T2ZSb290KSk7XG4gICAgfVxuICAgIFNldEpzb25Ub2tlbihqT2JqZWN0LCBzdG9yeUNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5sZW5ndGggPSAwO1xuICAgICAgICAvLyBUT0RPOiAoTGlzdDxvYmplY3Q+KSBqT2JqZWN0IFtcInRocmVhZHNcIl07XG4gICAgICAgIGxldCBqVGhyZWFkcyA9IGpPYmplY3RbXCJ0aHJlYWRzXCJdO1xuICAgICAgICBmb3IgKGxldCBqVGhyZWFkVG9rIG9mIGpUaHJlYWRzKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB2YXIgalRocmVhZE9iaiA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0PilqVGhyZWFkVG9rO1xuICAgICAgICAgICAgbGV0IGpUaHJlYWRPYmogPSBqVGhyZWFkVG9rO1xuICAgICAgICAgICAgbGV0IHRocmVhZCA9IG5ldyBDYWxsU3RhY2suVGhyZWFkKGpUaHJlYWRPYmosIHN0b3J5Q29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2godGhyZWFkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiAoaW50KWpPYmplY3QgW1widGhyZWFkQ291bnRlclwiXTtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IHBhcnNlSW50KGpPYmplY3RbXCJ0aHJlYWRDb3VudGVyXCJdKTtcbiAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHN0b3J5Q29udGV4dC5yb290Q29udGVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIFdyaXRlSnNvbih3KSB7XG4gICAgICAgIHcuV3JpdGVPYmplY3QoKHdyaXRlcikgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZHNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0aHJlYWQgb2YgdGhpcy5fdGhyZWFkcykge1xuICAgICAgICAgICAgICAgIHRocmVhZC5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZENvdW50ZXJcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnQodGhpcy5fdGhyZWFkQ291bnRlcik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgUHVzaFRocmVhZCgpIHtcbiAgICAgICAgbGV0IG5ld1RocmVhZCA9IHRoaXMuY3VycmVudFRocmVhZC5Db3B5KCk7XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIrKztcbiAgICAgICAgbmV3VGhyZWFkLnRocmVhZEluZGV4ID0gdGhpcy5fdGhyZWFkQ291bnRlcjtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKG5ld1RocmVhZCk7XG4gICAgfVxuICAgIEZvcmtUaHJlYWQoKSB7XG4gICAgICAgIGxldCBmb3JrZWRUaHJlYWQgPSB0aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyKys7XG4gICAgICAgIGZvcmtlZFRocmVhZC50aHJlYWRJbmRleCA9IHRoaXMuX3RocmVhZENvdW50ZXI7XG4gICAgICAgIHJldHVybiBmb3JrZWRUaHJlYWQ7XG4gICAgfVxuICAgIFBvcFRocmVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUG9wVGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzLnNwbGljZSh0aGlzLl90aHJlYWRzLmluZGV4T2YodGhpcy5jdXJyZW50VGhyZWFkKSwgMSk7IC8vIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIGEgcG9wKClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBvcCB0aHJlYWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhblBvcFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVhZHMubGVuZ3RoID4gMSAmJiAhdGhpcy5lbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWU7XG4gICAgfVxuICAgIFB1c2godHlwZSwgZXh0ZXJuYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQgPSAwLCBvdXRwdXRTdHJlYW1MZW5ndGhXaXRoUHVzaGVkID0gMCkge1xuICAgICAgICBsZXQgZWxlbWVudCA9IG5ldyBDYWxsU3RhY2suRWxlbWVudCh0eXBlLCB0aGlzLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLCBmYWxzZSk7XG4gICAgICAgIGVsZW1lbnQuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IGV4dGVybmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0O1xuICAgICAgICBlbGVtZW50LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IG91dHB1dFN0cmVhbUxlbmd0aFdpdGhQdXNoZWQ7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIENhblBvcCh0eXBlID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuY2FuUG9wKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gdHlwZTtcbiAgICB9XG4gICAgUG9wKHR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLkNhblBvcCh0eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIHB1c2gvcG9wIGluIENhbGxzdGFja1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHZXRUZW1wb3JhcnlWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICBsZXQgY29udGV4dEVsZW1lbnQgPSB0aGlzLmNhbGxTdGFja1tjb250ZXh0SW5kZXggLSAxXTtcbiAgICAgICAgbGV0IHZhclZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgIGlmICh2YXJWYWx1ZS5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB2YXJWYWx1ZS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTZXRUZW1wb3JhcnlWYXJpYWJsZShuYW1lLCB2YWx1ZSwgZGVjbGFyZU5ldywgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IHRoaXMuY3VycmVudEVsZW1lbnRJbmRleCArIDE7XG4gICAgICAgIGxldCBjb250ZXh0RWxlbWVudCA9IHRoaXMuY2FsbFN0YWNrW2NvbnRleHRJbmRleCAtIDFdO1xuICAgICAgICBpZiAoIWRlY2xhcmVOZXcgJiYgIWNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ291bGQgbm90IGZpbmQgdGVtcG9yYXJ5IHZhcmlhYmxlIHRvIHNldDogXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2xkVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAoY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgIFZhbHVlXzEuTGlzdFZhbHVlLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZS5yZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIENvbnRleHRGb3JWYXJpYWJsZU5hbWVkKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLmdldChuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUaHJlYWRXaXRoSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZpbHRlcmVkID0gdGhpcy5fdGhyZWFkcy5maWx0ZXIoKHQpID0+IHtcbiAgICAgICAgICAgIGlmICh0LnRocmVhZEluZGV4ID09IGluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbHRlcmVkLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFswXSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBjYWxsU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUaHJlYWQuY2FsbHN0YWNrO1xuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrVHJhY2UoKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuX3RocmVhZHMubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIGxldCB0aHJlYWQgPSB0aGlzLl90aHJlYWRzW3RdO1xuICAgICAgICAgICAgbGV0IGlzQ3VycmVudCA9IHQgPT0gdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgc2IuQXBwZW5kRm9ybWF0KFwiPT09IFRIUkVBRCB7MH0vezF9IHsyfT09PVxcblwiLCB0ICsgMSwgdGhpcy5fdGhyZWFkcy5sZW5ndGgsIGlzQ3VycmVudCA/IFwiKGN1cnJlbnQpIFwiIDogXCJcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRocmVhZC5jYWxsc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhyZWFkLmNhbGxzdGFja1tpXS50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbilcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiICBbRlVOQ1RJT05dIFwiKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgW1RVTk5FTF0gXCIpO1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gdGhyZWFkLmNhbGxzdGFja1tpXS5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIjxTT01FV0hFUkUgSU4gXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKHBvaW50ZXIuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoXCI+XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxTdGFjayA9IENhbGxTdGFjaztcbihmdW5jdGlvbiAoQ2FsbFN0YWNrKSB7XG4gICAgY2xhc3MgRWxlbWVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHR5cGUsIHBvaW50ZXIsIGluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkID0gMDtcbiAgICAgICAgICAgIHRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gMDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBwb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGluRXhwcmVzc2lvbkV2YWx1YXRpb247XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgQ29weSgpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IEVsZW1lbnQodGhpcy50eXBlLCB0aGlzLmN1cnJlbnRQb2ludGVyLCB0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pO1xuICAgICAgICAgICAgY29weS50ZW1wb3JhcnlWYXJpYWJsZXMgPSBuZXcgTWFwKHRoaXMudGVtcG9yYXJ5VmFyaWFibGVzKTtcbiAgICAgICAgICAgIGNvcHkuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IHRoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZDtcbiAgICAgICAgICAgIGNvcHkuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gdGhpcy5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsU3RhY2suRWxlbWVudCA9IEVsZW1lbnQ7XG4gICAgY2xhc3MgVGhyZWFkIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLnRocmVhZEluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2FsbHN0YWNrID0gW107XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdICYmIGFyZ3VtZW50c1sxXSkge1xuICAgICAgICAgICAgICAgIGxldCBqVGhyZWFkT2JqID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGxldCBzdG9yeUNvbnRleHQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogKGludCkgalRocmVhZE9ialsndGhyZWFkSW5kZXgnXSBjYW4gcmFpc2U7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJlYWRJbmRleCA9IHBhcnNlSW50KGpUaHJlYWRPYmpbXCJ0aHJlYWRJbmRleFwiXSk7XG4gICAgICAgICAgICAgICAgbGV0IGpUaHJlYWRDYWxsc3RhY2sgPSBqVGhyZWFkT2JqW1wiY2FsbHN0YWNrXCJdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGpFbFRvayBvZiBqVGhyZWFkQ2FsbHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBqRWxlbWVudE9iaiA9IGpFbFRvaztcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogKGludCkgakVsZW1lbnRPYmpbJ3R5cGUnXSBjYW4gcmFpc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwdXNoUG9wVHlwZSA9IHBhcnNlSW50KGpFbGVtZW50T2JqW1widHlwZVwiXSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXJQYXRoU3RyO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBqRWxlbWVudE9iai5UcnlHZXRWYWx1ZSAoXCJjUGF0aFwiLCBvdXQgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuID0gakVsZW1lbnRPYmpbXCJjUGF0aFwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyUGF0aFN0ciA9IGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aHJlYWRQb2ludGVyUmVzdWx0ID0gc3RvcnlDb250ZXh0LkNvbnRlbnRBdFBhdGgobmV3IFBhdGhfMS5QYXRoKGN1cnJlbnRDb250YWluZXJQYXRoU3RyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmNvbnRhaW5lciA9IHRocmVhZFBvaW50ZXJSZXN1bHQuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5pbmRleCA9IHBhcnNlSW50KGpFbGVtZW50T2JqW1wiaWR4XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJlYWRQb2ludGVyUmVzdWx0Lm9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldoZW4gbG9hZGluZyBzdGF0ZSwgaW50ZXJuYWwgc3RvcnkgbG9jYXRpb24gY291bGRuJ3QgYmUgZm91bmQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRocmVhZFBvaW50ZXJSZXN1bHQuYXBwcm94aW1hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcnlDb250ZXh0Lldhcm5pbmcoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGV4YWN0IGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyUGF0aFN0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0byAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicgdG8gcmVjb3Zlci4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9ICEhakVsZW1lbnRPYmpbXCJleHBcIl07XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IG5ldyBFbGVtZW50KHB1c2hQb3BUeXBlLCBwb2ludGVyLCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBzID0gakVsZW1lbnRPYmpbXCJ0ZW1wXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRlbXBzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50ZW1wb3JhcnlWYXJpYWJsZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2Jqcyh0ZW1wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC50ZW1wb3JhcnlWYXJpYWJsZXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxzdGFjay5wdXNoKGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHByZXZDb250ZW50T2JqUGF0aCA9IGpUaHJlYWRPYmpbXCJwcmV2aW91c0NvbnRlbnRPYmplY3RcIl07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2Q29udGVudE9ialBhdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHByZXZDb250ZW50T2JqUGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1BvaW50ZXIgPSBzdG9yeUNvbnRleHQuUG9pbnRlckF0UGF0aChwcmV2UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIENvcHkoKSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBUaHJlYWQoKTtcbiAgICAgICAgICAgIGNvcHkudGhyZWFkSW5kZXggPSB0aGlzLnRocmVhZEluZGV4O1xuICAgICAgICAgICAgZm9yIChsZXQgZSBvZiB0aGlzLmNhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgIGNvcHkuY2FsbHN0YWNrLnB1c2goZS5Db3B5KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICByZXR1cm4gY29weTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImNhbGxzdGFja1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuY2FsbHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWVsLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwuY3VycmVudFBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImNQYXRoXCIsIGVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlkeFwiLCBlbC5jdXJyZW50UG9pbnRlci5pbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiZXhwXCIsIGVsLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidHlwZVwiLCBlbC50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZWwudGVtcG9yYXJ5VmFyaWFibGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0ZW1wXCIpO1xuICAgICAgICAgICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHdyaXRlciwgZWwudGVtcG9yYXJ5VmFyaWFibGVzKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidGhyZWFkSW5kZXhcIiwgdGhpcy50aHJlYWRJbmRleCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJldmlvdXNQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCByZXNvbHZlZFBvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkUG9pbnRlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMucHJldmlvdXNQb2ludGVyLlJlc29sdmUoKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJwcmV2aW91c0NvbnRlbnRPYmplY3RcIiwgcmVzb2x2ZWRQb2ludGVyLnBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsU3RhY2suVGhyZWFkID0gVGhyZWFkO1xufSkoQ2FsbFN0YWNrID0gZXhwb3J0cy5DYWxsU3RhY2sgfHwgKGV4cG9ydHMuQ2FsbFN0YWNrID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGxTdGFjay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hvaWNlID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIENob2ljZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudGV4dCA9IFwiXCI7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnRocmVhZEF0R2VuZXJhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlUGF0aCA9IFwiXCI7XG4gICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3JpZ2luYWxUaHJlYWRJbmRleCA9IDA7XG4gICAgfVxuICAgIGdldCBwYXRoU3RyaW5nT25DaG9pY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldFBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHNldCBwYXRoU3RyaW5nT25DaG9pY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkNob2ljZSA9IENob2ljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNob2ljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hvaWNlUG9pbnQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgQ2hvaWNlUG9pbnQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKG9uY2VPbmx5ID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9wYXRoT25DaG9pY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1N0YXJ0Q29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25jZU9ubHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gb25jZU9ubHk7XG4gICAgfVxuICAgIGdldCBwYXRoT25DaG9pY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoT25DaG9pY2UgIT0gbnVsbCAmJiB0aGlzLl9wYXRoT25DaG9pY2UuaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IGNob2ljZVRhcmdldE9iaiA9IHRoaXMuY2hvaWNlVGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGNob2ljZVRhcmdldE9iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGhPbkNob2ljZSA9IGNob2ljZVRhcmdldE9iai5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoT25DaG9pY2U7XG4gICAgfVxuICAgIHNldCBwYXRoT25DaG9pY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcGF0aE9uQ2hvaWNlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjaG9pY2VUYXJnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoT25DaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZVBvaW50Ll9wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzLlJlc29sdmVQYXRoKHRoaXMuX3BhdGhPbkNob2ljZSkuY29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoT25DaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZVBvaW50LnBhdGhPbkNob2ljZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoT25DaG9pY2UpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGF0aE9uQ2hvaWNlID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGZsYWdzKCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAwO1xuICAgICAgICBpZiAodGhpcy5oYXNDb25kaXRpb24pXG4gICAgICAgICAgICBmbGFncyB8PSAxO1xuICAgICAgICBpZiAodGhpcy5oYXNTdGFydENvbnRlbnQpXG4gICAgICAgICAgICBmbGFncyB8PSAyO1xuICAgICAgICBpZiAodGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudClcbiAgICAgICAgICAgIGZsYWdzIHw9IDQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW52aXNpYmxlRGVmYXVsdClcbiAgICAgICAgICAgIGZsYWdzIHw9IDg7XG4gICAgICAgIGlmICh0aGlzLm9uY2VPbmx5KVxuICAgICAgICAgICAgZmxhZ3MgfD0gMTY7XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG4gICAgc2V0IGZsYWdzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGFzQ29uZGl0aW9uID0gKHZhbHVlICYgMSkgPiAwO1xuICAgICAgICB0aGlzLmhhc1N0YXJ0Q29udGVudCA9ICh2YWx1ZSAmIDIpID4gMDtcbiAgICAgICAgdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudCA9ICh2YWx1ZSAmIDQpID4gMDtcbiAgICAgICAgdGhpcy5pc0ludmlzaWJsZURlZmF1bHQgPSAodmFsdWUgJiA4KSA+IDA7XG4gICAgICAgIHRoaXMub25jZU9ubHkgPSAodmFsdWUgJiAxNikgPiAwO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIC8vIGludD8gdGFyZ2V0TGluZU51bSA9IERlYnVnTGluZU51bWJlck9mUGF0aCAocGF0aE9uQ2hvaWNlKTtcbiAgICAgICAgbGV0IHRhcmdldExpbmVOdW0gPSBudWxsO1xuICAgICAgICBsZXQgdGFyZ2V0U3RyaW5nID0gdGhpcy5wYXRoT25DaG9pY2UudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRhcmdldExpbmVOdW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGFyZ2V0U3RyaW5nID0gXCIgbGluZSBcIiArIHRhcmdldExpbmVOdW0gKyBcIihcIiArIHRhcmdldFN0cmluZyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkNob2ljZTogLT4gXCIgKyB0YXJnZXRTdHJpbmc7XG4gICAgfVxufVxuZXhwb3J0cy5DaG9pY2VQb2ludCA9IENob2ljZVBvaW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hvaWNlUG9pbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRhaW5lciA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBTZWFyY2hSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1NlYXJjaFJlc3VsdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMubmFtZWRDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBoYXNWYWxpZE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgIT0gbnVsbCAmJiB0aGlzLm5hbWUubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50O1xuICAgIH1cbiAgICBzZXQgY29udGVudCh2YWx1ZSkge1xuICAgICAgICB0aGlzLkFkZENvbnRlbnQodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbmFtZWRPbmx5Q29udGVudCgpIHtcbiAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnREaWN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBpbmtPYmplY3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnREaWN0LnNldChrZXksIGlua09iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBuYW1lZCA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwoYyk7XG4gICAgICAgICAgICBpZiAobmFtZWQgIT0gbnVsbCAmJiBuYW1lZC5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdC5kZWxldGUobmFtZWQubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVkT25seUNvbnRlbnREaWN0LnNpemUgPT0gMClcbiAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnREaWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5hbWVkT25seUNvbnRlbnREaWN0O1xuICAgIH1cbiAgICBzZXQgbmFtZWRPbmx5Q29udGVudCh2YWx1ZSkge1xuICAgICAgICBsZXQgZXhpc3RpbmdOYW1lZE9ubHkgPSB0aGlzLm5hbWVkT25seUNvbnRlbnQ7XG4gICAgICAgIGlmIChleGlzdGluZ05hbWVkT25seSAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5XSBvZiBleGlzdGluZ05hbWVkT25seSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZWRDb250ZW50LmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCBbLCB2YWxdIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbmFtZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKHZhbCk7XG4gICAgICAgICAgICBpZiAobmFtZWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvdW50RmxhZ3MoKSB7XG4gICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgIGlmICh0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgIGZsYWdzIHw9IENvbnRhaW5lci5Db3VudEZsYWdzLlZpc2l0cztcbiAgICAgICAgaWYgKHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgZmxhZ3MgfD0gQ29udGFpbmVyLkNvdW50RmxhZ3MuVHVybnM7XG4gICAgICAgIGlmICh0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkpXG4gICAgICAgICAgICBmbGFncyB8PSBDb250YWluZXIuQ291bnRGbGFncy5Db3VudFN0YXJ0T25seTtcbiAgICAgICAgaWYgKGZsYWdzID09IENvbnRhaW5lci5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KSB7XG4gICAgICAgICAgICBmbGFncyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cbiAgICBzZXQgY291bnRGbGFncyh2YWx1ZSkge1xuICAgICAgICBsZXQgZmxhZyA9IHZhbHVlO1xuICAgICAgICBpZiAoKGZsYWcgJiBDb250YWluZXIuQ291bnRGbGFncy5WaXNpdHMpID4gMClcbiAgICAgICAgICAgIHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuVHVybnMpID4gMClcbiAgICAgICAgICAgIHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkpID4gMClcbiAgICAgICAgICAgIHRoaXMuY291bnRpbmdBdFN0YXJ0T25seSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBwYXRoVG9GaXJzdExlYWZDb250ZW50KCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCA9IHRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKHRoaXMuaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBpbnRlcm5hbFBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQoKSB7XG4gICAgICAgIGxldCBjb21wb25lbnRzID0gW107XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoY29udGFpbmVyIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KDApKTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBjb250YWluZXIuY29udGVudFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGhfMS5QYXRoKGNvbXBvbmVudHMpO1xuICAgIH1cbiAgICBBZGRDb250ZW50KGNvbnRlbnRPYmpPckxpc3QpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmpPckxpc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRMaXN0ID0gY29udGVudE9iak9yTGlzdDtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29udGVudExpc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZENvbnRlbnQoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudE9iaiA9IGNvbnRlbnRPYmpPckxpc3Q7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnB1c2goY29udGVudE9iaik7XG4gICAgICAgICAgICBpZiAoY29udGVudE9iai5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIgKyBjb250ZW50T2JqLnBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250ZW50T2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChjb250ZW50T2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaikge1xuICAgICAgICBsZXQgbmFtZWRDb250ZW50T2JqID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbChjb250ZW50T2JqKTtcbiAgICAgICAgaWYgKG5hbWVkQ29udGVudE9iaiAhPSBudWxsICYmIG5hbWVkQ29udGVudE9iai5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuQWRkVG9OYW1lZENvbnRlbnRPbmx5KG5hbWVkQ29udGVudE9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkVG9OYW1lZENvbnRlbnRPbmx5KG5hbWVkQ29udGVudE9iaikge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydFR5cGUobmFtZWRDb250ZW50T2JqLCBPYmplY3RfMS5JbmtPYmplY3QsIFwiQ2FuIG9ubHkgYWRkIFJ1bnRpbWUuT2JqZWN0cyB0byBhIFJ1bnRpbWUuQ29udGFpbmVyXCIpO1xuICAgICAgICBsZXQgcnVudGltZU9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG5hbWVkQ29udGVudE9iaiwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICAgICAgcnVudGltZU9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLm5hbWVkQ29udGVudC5zZXQobmFtZWRDb250ZW50T2JqLm5hbWUsIG5hbWVkQ29udGVudE9iaik7XG4gICAgfVxuICAgIENvbnRlbnRBdFBhdGgocGF0aCwgcGFydGlhbFBhdGhTdGFydCA9IDAsIHBhcnRpYWxQYXRoTGVuZ3RoID0gLTEpIHtcbiAgICAgICAgaWYgKHBhcnRpYWxQYXRoTGVuZ3RoID09IC0xKVxuICAgICAgICAgICAgcGFydGlhbFBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBTZWFyY2hSZXN1bHRfMS5TZWFyY2hSZXN1bHQoKTtcbiAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyID0gdGhpcztcbiAgICAgICAgbGV0IGN1cnJlbnRPYmogPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gcGFydGlhbFBhdGhTdGFydDsgaSA8IHBhcnRpYWxQYXRoTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjb21wID0gcGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZE9iaiA9IGN1cnJlbnRDb250YWluZXIuQ29udGVudFdpdGhQYXRoQ29tcG9uZW50KGNvbXApO1xuICAgICAgICAgICAgaWYgKGZvdW5kT2JqID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwcm94aW1hdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE9iaiA9IGZvdW5kT2JqO1xuICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChmb3VuZE9iaiwgQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQub2JqID0gY3VycmVudE9iajtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgSW5zZXJ0Q29udGVudChjb250ZW50T2JqLCBpbmRleCkge1xuICAgICAgICB0aGlzLmNvbnRlbnRbaW5kZXhdID0gY29udGVudE9iajtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmoucGFyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIgKyBjb250ZW50T2JqLnBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudE9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChjb250ZW50T2JqKTtcbiAgICB9XG4gICAgQWRkQ29udGVudHNPZkNvbnRhaW5lcihvdGhlckNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuY29uY2F0KG90aGVyQ29udGFpbmVyLmNvbnRlbnQpO1xuICAgICAgICBmb3IgKGxldCBvYmogb2Ygb3RoZXJDb250YWluZXIuY29udGVudCkge1xuICAgICAgICAgICAgb2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLlRyeUFkZE5hbWVkQ29udGVudChvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnRlbnRXaXRoUGF0aENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50LmluZGV4ID49IDAgJiYgY29tcG9uZW50LmluZGV4IDwgdGhpcy5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbY29tcG9uZW50LmluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBvbmVudC5pc1BhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5uYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb21wb25lbnQubmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3VuZENvbnRlbnQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5uYW1lZENvbnRlbnQsIGNvbXBvbmVudC5uYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChmb3VuZENvbnRlbnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGZvdW5kQ29udGVudC5yZXN1bHQsIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBCdWlsZFN0cmluZ09mSGllcmFyY2h5KCkge1xuICAgICAgICBsZXQgc2I7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICB0aGlzLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIDAsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2IgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGxldCBpbmRlbnRhdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgbGV0IHBvaW50ZWRPYmogPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZEluZGVudGF0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc3BhY2VzUGVySW5kZW50ID0gNDsgLy8gVHJ1bHkgY29uc3QgaW4gdGhlIG9yaWdpbmFsIGNvZGVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BhY2VzUGVySW5kZW50ICogaW5kZW50YXRpb247ICsraSkge1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgc2IuQXBwZW5kKFwiW1wiKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmRGb3JtYXQoXCIgKHswfSlcIiwgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBwb2ludGVkT2JqKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgIDwtLS1cIik7XG4gICAgICAgIH1cbiAgICAgICAgc2IuQXBwZW5kTGluZSgpO1xuICAgICAgICBpbmRlbnRhdGlvbisrO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gb2JqO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCBpbmRlbnRhdGlvbiwgcG9pbnRlZE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCgnXCInKTtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKG9iai50b1N0cmluZygpLnJlcGxhY2UoXCJcXG5cIiwgXCJcXFxcblwiKSk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCgnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChvYmoudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgIT0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgQ29udGFpbmVyKSAmJiBvYmogPT0gcG9pbnRlZE9iaikge1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgPC0tLVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25seU5hbWVkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaW5kZXhPZihUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25seU5hbWVkLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob25seU5hbWVkLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICAgICAgc2IuQXBwZW5kTGluZShcIi0tIG5hbWVkOiAtLVwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiBvbmx5TmFtZWQpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydFR5cGUodmFsdWUsIENvbnRhaW5lciwgXCJDYW4gb25seSBwcmludCBvdXQgbmFtZWQgQ29udGFpbmVyc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIGluZGVudGF0aW9uLCBwb2ludGVkT2JqKTtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmRMaW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kZW50YXRpb24tLTtcbiAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgc2IuQXBwZW5kKFwiXVwiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcbihmdW5jdGlvbiAoQ29udGFpbmVyKSB7XG4gICAgbGV0IENvdW50RmxhZ3M7XG4gICAgKGZ1bmN0aW9uIChDb3VudEZsYWdzKSB7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIlZpc2l0c1wiXSA9IDFdID0gXCJWaXNpdHNcIjtcbiAgICAgICAgQ291bnRGbGFnc1tDb3VudEZsYWdzW1wiVHVybnNcIl0gPSAyXSA9IFwiVHVybnNcIjtcbiAgICAgICAgQ291bnRGbGFnc1tDb3VudEZsYWdzW1wiQ291bnRTdGFydE9ubHlcIl0gPSA0XSA9IFwiQ291bnRTdGFydE9ubHlcIjtcbiAgICB9KShDb3VudEZsYWdzID0gQ29udGFpbmVyLkNvdW50RmxhZ3MgfHwgKENvbnRhaW5lci5Db3VudEZsYWdzID0ge30pKTtcbn0pKENvbnRhaW5lciA9IGV4cG9ydHMuQ29udGFpbmVyIHx8IChleHBvcnRzLkNvbnRhaW5lciA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250YWluZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnRyb2xDb21tYW5kID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBDb250cm9sQ29tbWFuZCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoY29tbWFuZFR5cGUgPSBDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob3RTZXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fY29tbWFuZFR5cGUgPSBjb21tYW5kVHlwZTtcbiAgICB9XG4gICAgZ2V0IGNvbW1hbmRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZFR5cGU7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQodGhpcy5jb21tYW5kVHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0KTtcbiAgICB9XG4gICAgc3RhdGljIEV2YWxPdXRwdXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbE91dHB1dCk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsRW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmQpO1xuICAgIH1cbiAgICBzdGF0aWMgRHVwbGljYXRlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BFdmFsdWF0ZWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BGdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBQb3BUdW5uZWwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsKTtcbiAgICB9XG4gICAgc3RhdGljIEJlZ2luU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIEVuZFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRTdHJpbmcpO1xuICAgIH1cbiAgICBzdGF0aWMgTm9PcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob09wKTtcbiAgICB9XG4gICAgc3RhdGljIENob2ljZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50KTtcbiAgICB9XG4gICAgc3RhdGljIFR1cm5zKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zKTtcbiAgICB9XG4gICAgc3RhdGljIFR1cm5zU2luY2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSk7XG4gICAgfVxuICAgIHN0YXRpYyBSZWFkQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50KTtcbiAgICB9XG4gICAgc3RhdGljIFJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SYW5kb20pO1xuICAgIH1cbiAgICBzdGF0aWMgU2VlZFJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZWVkUmFuZG9tKTtcbiAgICB9XG4gICAgc3RhdGljIFZpc2l0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTZXF1ZW5jZVNodWZmbGVJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTdGFydFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZCk7XG4gICAgfVxuICAgIHN0YXRpYyBEb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmUpO1xuICAgIH1cbiAgICBzdGF0aWMgRW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0RnJvbUludCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlKTtcbiAgICB9XG4gICAgc3RhdGljIExpc3RSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kVHlwZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJvbENvbW1hbmQgPSBDb250cm9sQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29udHJvbENvbW1hbmQpIHtcbiAgICBsZXQgQ29tbWFuZFR5cGU7XG4gICAgKGZ1bmN0aW9uIChDb21tYW5kVHlwZSkge1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIk5vdFNldFwiXSA9IC0xXSA9IFwiTm90U2V0XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRXZhbFN0YXJ0XCJdID0gMF0gPSBcIkV2YWxTdGFydFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxPdXRwdXRcIl0gPSAxXSA9IFwiRXZhbE91dHB1dFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxFbmRcIl0gPSAyXSA9IFwiRXZhbEVuZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkR1cGxpY2F0ZVwiXSA9IDNdID0gXCJEdXBsaWNhdGVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJQb3BFdmFsdWF0ZWRWYWx1ZVwiXSA9IDRdID0gXCJQb3BFdmFsdWF0ZWRWYWx1ZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlBvcEZ1bmN0aW9uXCJdID0gNV0gPSBcIlBvcEZ1bmN0aW9uXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUG9wVHVubmVsXCJdID0gNl0gPSBcIlBvcFR1bm5lbFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkJlZ2luU3RyaW5nXCJdID0gN10gPSBcIkJlZ2luU3RyaW5nXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRW5kU3RyaW5nXCJdID0gOF0gPSBcIkVuZFN0cmluZ1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIk5vT3BcIl0gPSA5XSA9IFwiTm9PcFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkNob2ljZUNvdW50XCJdID0gMTBdID0gXCJDaG9pY2VDb3VudFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlR1cm5zXCJdID0gMTFdID0gXCJUdXJuc1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlR1cm5zU2luY2VcIl0gPSAxMl0gPSBcIlR1cm5zU2luY2VcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJSYW5kb21cIl0gPSAxM10gPSBcIlJhbmRvbVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlNlZWRSYW5kb21cIl0gPSAxNF0gPSBcIlNlZWRSYW5kb21cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJWaXNpdEluZGV4XCJdID0gMTVdID0gXCJWaXNpdEluZGV4XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiU2VxdWVuY2VTaHVmZmxlSW5kZXhcIl0gPSAxNl0gPSBcIlNlcXVlbmNlU2h1ZmZsZUluZGV4XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiU3RhcnRUaHJlYWRcIl0gPSAxN10gPSBcIlN0YXJ0VGhyZWFkXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRG9uZVwiXSA9IDE4XSA9IFwiRG9uZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkVuZFwiXSA9IDE5XSA9IFwiRW5kXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdEZyb21JbnRcIl0gPSAyMF0gPSBcIkxpc3RGcm9tSW50XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdFJhbmdlXCJdID0gMjFdID0gXCJMaXN0UmFuZ2VcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJMaXN0UmFuZG9tXCJdID0gMjJdID0gXCJMaXN0UmFuZG9tXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUmVhZENvdW50XCJdID0gMjNdID0gXCJSZWFkQ291bnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUT1RBTF9WQUxVRVNcIl0gPSAyNF0gPSBcIlRPVEFMX1ZBTFVFU1wiO1xuICAgIH0pKENvbW1hbmRUeXBlID0gQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUgfHwgKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlID0ge30pKTtcbn0pKENvbnRyb2xDb21tYW5kID0gZXhwb3J0cy5Db250cm9sQ29tbWFuZCB8fCAoZXhwb3J0cy5Db250cm9sQ29tbWFuZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sQ29tbWFuZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVidWcgPSB2b2lkIDA7XG52YXIgRGVidWc7XG4oZnVuY3Rpb24gKERlYnVnKSB7XG4gICAgZnVuY3Rpb24gQXNzZXJ0VHlwZSh2YXJpYWJsZSwgdHlwZSwgbWVzc2FnZSkge1xuICAgICAgICBBc3NlcnQodmFyaWFibGUgaW5zdGFuY2VvZiB0eXBlLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgRGVidWcuQXNzZXJ0VHlwZSA9IEFzc2VydFR5cGU7XG4gICAgZnVuY3Rpb24gQXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGVidWcuQXNzZXJ0ID0gQXNzZXJ0O1xufSkoRGVidWcgPSBleHBvcnRzLkRlYnVnIHx8IChleHBvcnRzLkRlYnVnID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlYnVnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaXZlcnQgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBEaXZlcnQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHN0YWNrUHVzaFR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YWNrUHVzaFR5cGUgPSAwO1xuICAgICAgICB0aGlzLmlzRXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEFyZ3MgPSAwO1xuICAgICAgICB0aGlzLmlzQ29uZGl0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wdXNoZXNUb1N0YWNrID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tQdXNoVHlwZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy5wdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tQdXNoVHlwZSA9IHN0YWNrUHVzaFR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoICE9IG51bGwgJiYgdGhpcy5fdGFyZ2V0UGF0aC5pc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0T2JqID0gdGhpcy50YXJnZXRQb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRPYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQYXRoID0gdGFyZ2V0T2JqLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBhdGg7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldFBhdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgfVxuICAgIGdldCB0YXJnZXRQb2ludGVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPYmogPSB0aGlzLlJlc29sdmVQYXRoKHRoaXMuX3RhcmdldFBhdGgpLm9iajtcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fdGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0T2JqID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRhcmdldE9ialwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyLmNvbnRhaW5lciA9XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE9iai5wYXJlbnQgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIgPyB0YXJnZXRPYmoucGFyZW50IDogbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyLmluZGV4ID0gdGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50LmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YodGFyZ2V0T2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGFyZ2V0T2JqIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UGF0aFN0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMudGFyZ2V0UGF0aCk7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaGFzVmFyaWFibGVUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSAhPSBudWxsO1xuICAgIH1cbiAgICBFcXVhbHMob2JqKSB7XG4gICAgICAgIGxldCBvdGhlckRpdmVydCA9IG9iajtcbiAgICAgICAgaWYgKG90aGVyRGl2ZXJ0IGluc3RhbmNlb2YgRGl2ZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCA9PSBvdGhlckRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSA9PSBvdGhlckRpdmVydC52YXJpYWJsZURpdmVydE5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnRhcmdldFBhdGhcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldFBhdGguRXF1YWxzKG90aGVyRGl2ZXJ0LnRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRGl2ZXJ0KHZhcmlhYmxlOiBcIiArIHRoaXMudmFyaWFibGVEaXZlcnROYW1lICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXRQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkRpdmVydChudWxsKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0U3RyID0gdGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBpbnQ/IHRhcmdldExpbmVOdW0gPSBEZWJ1Z0xpbmVOdW1iZXJPZlBhdGggKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgbGV0IHRhcmdldExpbmVOdW0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRhcmdldExpbmVOdW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFN0ciA9IFwibGluZSBcIiArIHRhcmdldExpbmVOdW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCJEaXZlcnRcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0NvbmRpdGlvbmFsKVxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIj9cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wdXNoZXNUb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIGZ1bmN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIHR1bm5lbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgLT4gXCIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKHRoaXMudGFyZ2V0UGF0aFN0cmluZyk7XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIgKFwiKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0YXJnZXRTdHIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiKVwiKTtcbiAgICAgICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EaXZlcnQgPSBEaXZlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkdsdWUgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIEdsdWUgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJHbHVlXCI7XG4gICAgfVxufVxuZXhwb3J0cy5HbHVlID0gR2x1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklua0xpc3QgPSBleHBvcnRzLklua0xpc3RJdGVtID0gdm9pZCAwO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jbGFzcyBJbmtMaXN0SXRlbSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIElua0xpc3RJdGVtIGlzIGEgc3RydWN0XG4gICAgICAgIHRoaXMub3JpZ2luTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXRlbU5hbWUgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9yaWdpbk5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLm9yaWdpbk5hbWUgPSBvcmlnaW5OYW1lO1xuICAgICAgICAgICAgdGhpcy5pdGVtTmFtZSA9IGl0ZW1OYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgbGV0IGZ1bGxOYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IG5hbWVQYXJ0cyA9IGZ1bGxOYW1lLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5OYW1lID0gbmFtZVBhcnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5pdGVtTmFtZSA9IG5hbWVQYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE51bGwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5rTGlzdEl0ZW0obnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGdldCBpc051bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbk5hbWUgPT0gbnVsbCAmJiB0aGlzLml0ZW1OYW1lID09IG51bGw7XG4gICAgfVxuICAgIGdldCBmdWxsTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy5vcmlnaW5OYW1lICE9PSBudWxsID8gdGhpcy5vcmlnaW5OYW1lIDogXCI/XCIpICsgXCIuXCIgKyB0aGlzLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ1bGxOYW1lO1xuICAgIH1cbiAgICBFcXVhbHMob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBJbmtMaXN0SXRlbSkge1xuICAgICAgICAgICAgbGV0IG90aGVySXRlbSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiAob3RoZXJJdGVtLml0ZW1OYW1lID09IHRoaXMuaXRlbU5hbWUgJiZcbiAgICAgICAgICAgICAgICBvdGhlckl0ZW0ub3JpZ2luTmFtZSA9PSB0aGlzLm9yaWdpbk5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVGhlc2UgbWV0aG9kcyBkaWQgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLiBUaGVpciBwdXJwb3NlIGlzIHRvXG4gICAgLy8gbWFrZSBgSW5rTGlzdEl0ZW1gIG1pbWljcyB0aGUgdmFsdWUtdHlwZSBzZW1hbnRpY3Mgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gc3RydWN0LiBQbGVhc2UgcmVmZXIgdG8gdGhlIGVuZCBvZiB0aGlzIGZpbGUsIGZvciBhIG1vcmUgaW4tZGVwdGhcbiAgICAvLyBleHBsYW5hdGlvbi5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc2hhbGxvdyBjbG9uZSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKHRoaXMub3JpZ2luTmFtZSwgdGhpcy5pdGVtTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgU2VyaWFsaXplZElua0xpc3RJdGVtYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnRcbiAgICAgKiBpbnN0YW5jZS4gVGhlIHJlc3VsdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGFzIGEga2V5IGluc2lkZSBhIE1hcC5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVkKCkge1xuICAgICAgICAvLyBXZSBhcmUgc2ltcGx5IHVzaW5nIGEgSlNPTiByZXByZXNlbnRhdGlvbiBhcyBhIHZhbHVlLXR5cGVkIGtleS5cbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIG9yaWdpbk5hbWU6IHRoaXMub3JpZ2luTmFtZSxcbiAgICAgICAgICAgIGl0ZW1OYW1lOiB0aGlzLml0ZW1OYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb25zdHJ1Y3RzIGEgYElua0xpc3RJdGVtYCBmcm9tIHRoZSBnaXZlbiBTZXJpYWxpemVkSW5rTGlzdEl0ZW0uXG4gICAgICovXG4gICAgc3RhdGljIGZyb21TZXJpYWxpemVkS2V5KGtleSkge1xuICAgICAgICBsZXQgb2JqID0gSlNPTi5wYXJzZShrZXkpO1xuICAgICAgICBpZiAoIUlua0xpc3RJdGVtLmlzTGlrZUlua0xpc3RJdGVtKG9iaikpXG4gICAgICAgICAgICByZXR1cm4gSW5rTGlzdEl0ZW0uTnVsbDtcbiAgICAgICAgbGV0IGlua0xpc3RJdGVtID0gb2JqO1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKGlua0xpc3RJdGVtLm9yaWdpbk5hbWUsIGlua0xpc3RJdGVtLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBpdGVtIGlzIHN1ZmZpY2llbnRseSBgSW5rTGlzdEl0ZW1gLWxpa2VcbiAgICAgKiB0byBiZSB1c2VkIGFzIGEgdGVtcGxhdGUgd2hlbiByZWNvbnN0cnVjdGluZyB0aGUgSW5rTGlzdEl0ZW0uXG4gICAgICovXG4gICAgc3RhdGljIGlzTGlrZUlua0xpc3RJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWl0ZW0uaGFzT3duUHJvcGVydHkoXCJvcmlnaW5OYW1lXCIpIHx8ICFpdGVtLmhhc093blByb3BlcnR5KFwiaXRlbU5hbWVcIikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5vcmlnaW5OYW1lICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtLm9yaWdpbk5hbWUgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbS5pdGVtTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbS5pdGVtTmFtZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5JbmtMaXN0SXRlbSA9IElua0xpc3RJdGVtO1xuY2xhc3MgSW5rTGlzdCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIFRyeWluZyB0byBiZSBzbWFydCBoZXJlLCB0aGlzIGVtdWxhdGVzIHRoZSBjb25zdHJ1Y3RvciBpbmhlcml0YW5jZSBmb3VuZFxuICAgICAgICAvLyBpbiB0aGUgb3JpZ2luYWwgY29kZSwgYnV0IG9ubHkgaWYgb3RoZXJMaXN0IGlzIGFuIElua0xpc3QuIElJRkUgRlRXLlxuICAgICAgICBzdXBlcigoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIElua0xpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKTtcbiAgICAgICAgdGhpcy5vcmlnaW5zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIElua0xpc3QpIHtcbiAgICAgICAgICAgIGxldCBvdGhlckxpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpZiAob3RoZXJMaXN0Ll9vcmlnaW5OYW1lcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gb3RoZXJMaXN0Ll9vcmlnaW5OYW1lcy5zbGljZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBzaW5nbGVPcmlnaW5MaXN0TmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBvcmlnaW5TdG9yeSA9IGFyZ3VtZW50c1sxXTsgLyogYXMgU3RvcnkgKi9cbiAgICAgICAgICAgIHRoaXMuU2V0SW5pdGlhbE9yaWdpbk5hbWUoc2luZ2xlT3JpZ2luTGlzdE5hbWUpO1xuICAgICAgICAgICAgbGV0IGRlZiA9IG9yaWdpblN0b3J5Lmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihzaW5nbGVPcmlnaW5MaXN0TmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoZGVmLmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2lucyA9IFtkZWYucmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklua0xpc3Qgb3JpZ2luIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBzdG9yeSB3aGVuIGNvbnN0cnVjdGluZyBuZXcgbGlzdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICBzaW5nbGVPcmlnaW5MaXN0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiS2V5XCIpICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoXCJWYWx1ZVwiKSkge1xuICAgICAgICAgICAgbGV0IHNpbmdsZUVsZW1lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLkFkZChzaW5nbGVFbGVtZW50LktleSwgc2luZ2xlRWxlbWVudC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkSXRlbShpdGVtT3JJdGVtTmFtZSkge1xuICAgICAgICBpZiAoaXRlbU9ySXRlbU5hbWUgaW5zdGFuY2VvZiBJbmtMaXN0SXRlbSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBpdGVtT3JJdGVtTmFtZTtcbiAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkSXRlbShpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBpdGVtLm9yaWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IG9yaWdpbi5UcnlHZXRWYWx1ZUZvckl0ZW0oaXRlbSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZChpdGVtLCBpbnRWYWwucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGxpc3QgZGVmaW5pdGlvbiBpbiBpbmsuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGFkZCBpdGVtIHRvIGxpc3QgYmVjYXVzZSB0aGUgaXRlbSB3YXMgZnJvbSBhIG5ldyBsaXN0IGRlZmluaXRpb24gdGhhdCB3YXNuJ3QgcHJldmlvdXNseSBrbm93biB0byB0aGlzIGxpc3QuIE9ubHkgaXRlbXMgZnJvbSBwcmV2aW91c2x5IGtub3duIGxpc3RzIGNhbiBiZSB1c2VkLCBzbyB0aGF0IHRoZSBpbnQgdmFsdWUgY2FuIGJlIGZvdW5kLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpdGVtTmFtZSA9IGl0ZW1Pckl0ZW1OYW1lO1xuICAgICAgICAgICAgbGV0IGZvdW5kTGlzdERlZiA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtTmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtTmFtZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLkNvbnRhaW5zSXRlbVdpdGhOYW1lKGl0ZW1OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1OYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBjb3VsZCBjb21lIGZyb20gZWl0aGVyIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4ubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGlzdERlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTGlzdERlZiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3VuZExpc3REZWYgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgaXRlbU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBpc24ndCBrbm93biB0byBhbnkgbGlzdCBkZWZpbml0aW9ucyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxpc3QuXCIpO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSW5rTGlzdEl0ZW0oZm91bmRMaXN0RGVmLm5hbWUsIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgIGxldCBpdGVtVmFsID0gZm91bmRMaXN0RGVmLlZhbHVlRm9ySXRlbShpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuQWRkKGl0ZW0sIGl0ZW1WYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbU5hbWVkKGl0ZW1OYW1lKSB7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09IGl0ZW1OYW1lKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ29udGFpbnNLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkuc2VyaWFsaXplZCgpKTtcbiAgICB9XG4gICAgQWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWRLZXkgPSBrZXkuc2VyaWFsaXplZCgpO1xuICAgICAgICBpZiAodGhpcy5oYXMoc2VyaWFsaXplZEtleSkpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGFuIGV4Y2VwdGlvbiB0byBtYXRjaCB0aGUgQyMgYmVoYXZpb3IuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBNYXAgYWxyZWFkeSBjb250YWlucyBhbiBlbnRyeSBmb3IgJHtrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQoc2VyaWFsaXplZEtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBSZW1vdmUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkuc2VyaWFsaXplZCgpKTtcbiAgICB9XG4gICAgZ2V0IENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luT2ZNYXhJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1heE9yaWdpbk5hbWUgPSB0aGlzLm1heEl0ZW0uS2V5Lm9yaWdpbk5hbWU7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbnMuZXZlcnkoKG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgaWYgKG9yaWdpbi5uYW1lID09IG1heE9yaWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0IG9yaWdpbk5hbWVzKCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW5OYW1lcyA9PSBudWxsICYmIHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW107XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX29yaWdpbk5hbWVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5XSBvZiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzLnB1c2goaXRlbS5vcmlnaW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luTmFtZXM7XG4gICAgfVxuICAgIFNldEluaXRpYWxPcmlnaW5OYW1lKGluaXRpYWxPcmlnaW5OYW1lKSB7XG4gICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW2luaXRpYWxPcmlnaW5OYW1lXTtcbiAgICB9XG4gICAgU2V0SW5pdGlhbE9yaWdpbk5hbWVzKGluaXRpYWxPcmlnaW5OYW1lcykge1xuICAgICAgICBpZiAoaW5pdGlhbE9yaWdpbk5hbWVzID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gaW5pdGlhbE9yaWdpbk5hbWVzLnNsaWNlKCk7IC8vIHN0b3JlIGEgY29weVxuICAgIH1cbiAgICBnZXQgbWF4SXRlbSgpIHtcbiAgICAgICAgbGV0IG1heCA9IHtcbiAgICAgICAgICAgIEtleTogSW5rTGlzdEl0ZW0uTnVsbCxcbiAgICAgICAgICAgIFZhbHVlOiAwLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsIHx8IHZhbHVlID4gbWF4LlZhbHVlKVxuICAgICAgICAgICAgICAgIG1heCA9IHsgS2V5OiBpdGVtLCBWYWx1ZTogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgbWluSXRlbSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IHtcbiAgICAgICAgICAgIEtleTogSW5rTGlzdEl0ZW0uTnVsbCxcbiAgICAgICAgICAgIFZhbHVlOiAwLFxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKG1pbi5LZXkuaXNOdWxsIHx8IHZhbHVlIDwgbWluLlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbWluID0geyBLZXk6IGl0ZW0sIFZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBpbnZlcnNlKCkge1xuICAgICAgICBsZXQgbGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvcmlnaW4uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuQ29udGFpbnNLZXkoaXRlbSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0LkFkZChpdGVtLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBnZXQgYWxsKCkge1xuICAgICAgICBsZXQgbGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIHRoaXMub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvcmlnaW4uaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnNldChpdGVtLnNlcmlhbGl6ZWQoKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgVW5pb24ob3RoZXJMaXN0KSB7XG4gICAgICAgIGxldCB1bmlvbiA9IG5ldyBJbmtMaXN0KHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3RoZXJMaXN0KSB7XG4gICAgICAgICAgICB1bmlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuaW9uO1xuICAgIH1cbiAgICBJbnRlcnNlY3Qob3RoZXJMaXN0KSB7XG4gICAgICAgIGxldCBpbnRlcnNlY3Rpb24gPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKG90aGVyTGlzdC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuICAgIFdpdGhvdXQobGlzdFRvUmVtb3ZlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgSW5rTGlzdCh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgbGlzdFRvUmVtb3ZlKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29udGFpbnMob3RoZXJMaXN0KSB7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIG90aGVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgR3JlYXRlclRoYW4ob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5taW5JdGVtLlZhbHVlID4gb3RoZXJMaXN0Lm1heEl0ZW0uVmFsdWU7XG4gICAgfVxuICAgIEdyZWF0ZXJUaGFuT3JFcXVhbHMob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRoaXMubWluSXRlbS5WYWx1ZSA+PSBvdGhlckxpc3QubWluSXRlbS5WYWx1ZSAmJlxuICAgICAgICAgICAgdGhpcy5tYXhJdGVtLlZhbHVlID49IG90aGVyTGlzdC5tYXhJdGVtLlZhbHVlKTtcbiAgICB9XG4gICAgTGVzc1RoYW4ob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhJdGVtLlZhbHVlIDwgb3RoZXJMaXN0Lm1pbkl0ZW0uVmFsdWU7XG4gICAgfVxuICAgIExlc3NUaGFuT3JFcXVhbHMob3RoZXJMaXN0KSB7XG4gICAgICAgIGlmIChvdGhlckxpc3QuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gKHRoaXMubWF4SXRlbS5WYWx1ZSA8PSBvdGhlckxpc3QubWF4SXRlbS5WYWx1ZSAmJlxuICAgICAgICAgICAgdGhpcy5taW5JdGVtLlZhbHVlIDw9IG90aGVyTGlzdC5taW5JdGVtLlZhbHVlKTtcbiAgICB9XG4gICAgTWF4QXNMaXN0KCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QodGhpcy5tYXhJdGVtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KCk7XG4gICAgfVxuICAgIE1pbkFzTGlzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KHRoaXMubWluSXRlbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgIH1cbiAgICBMaXN0V2l0aFN1YlJhbmdlKG1pbkJvdW5kLCBtYXhCb3VuZCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGxldCBvcmRlcmVkID0gdGhpcy5vcmRlcmVkSXRlbXM7XG4gICAgICAgIGxldCBtaW5WYWx1ZSA9IDA7XG4gICAgICAgIGxldCBtYXhWYWx1ZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtaW5Cb3VuZCkpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gbWluQm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWluQm91bmQgaW5zdGFuY2VvZiBJbmtMaXN0ICYmIG1pbkJvdW5kLkNvdW50ID4gMClcbiAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IG1pbkJvdW5kLm1pbkl0ZW0uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWF4Qm91bmQpKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IG1heEJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pbkJvdW5kIGluc3RhbmNlb2YgSW5rTGlzdCAmJiBtaW5Cb3VuZC5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBtYXhCb3VuZC5tYXhJdGVtLlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJMaXN0ID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgc3ViTGlzdC5TZXRJbml0aWFsT3JpZ2luTmFtZXModGhpcy5vcmlnaW5OYW1lcyk7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygb3JkZXJlZCkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uVmFsdWUgPj0gbWluVmFsdWUgJiYgaXRlbS5WYWx1ZSA8PSBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHN1Ykxpc3QuQWRkKGl0ZW0uS2V5LCBpdGVtLlZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViTGlzdDtcbiAgICB9XG4gICAgRXF1YWxzKG90aGVySW5rTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJJbmtMaXN0IGluc3RhbmNlb2YgSW5rTGlzdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlcklua0xpc3QuQ291bnQgIT0gdGhpcy5Db3VudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAgaWYgKCFvdGhlcklua0xpc3QuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBHZXRIYXNoQ29kZSBub3QgaW1wbGVtZW50ZWRcbiAgICBnZXQgb3JkZXJlZEl0ZW1zKCkge1xuICAgICAgICAvLyBMaXN0PEtleVZhbHVlUGFpcjxJbmtMaXN0SXRlbSwgaW50Pj5cbiAgICAgICAgbGV0IG9yZGVyZWQgPSBuZXcgQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIG9yZGVyZWQucHVzaCh7IEtleTogaXRlbSwgVmFsdWU6IHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIG9yZGVyZWQuc29ydCgoeCwgeSkgPT4ge1xuICAgICAgICAgICAgaWYgKHguS2V5Lm9yaWdpbk5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInguS2V5Lm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeS5LZXkub3JpZ2luTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwieS5LZXkub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4LlZhbHVlID09IHkuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5LZXkub3JpZ2luTmFtZS5sb2NhbGVDb21wYXJlKHkuS2V5Lm9yaWdpbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgdGhpcyBiaXQgaW50byBhIG51bWJlckNvbXBhcmVUbyBtZXRob2Q/XG4gICAgICAgICAgICAgICAgaWYgKHguVmFsdWUgPCB5LlZhbHVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguVmFsdWUgPiB5LlZhbHVlID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gb3JkZXJlZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBvcmRlcmVkID0gdGhpcy5vcmRlcmVkSXRlbXM7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9yZGVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIsIFwiKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gb3JkZXJlZFtpXS5LZXk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0uaXRlbU5hbWVcIik7XG4gICAgICAgICAgICBzYi5BcHBlbmQoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8vIGNhc3RpbmcgYSBJbmtMaXN0IHRvIGEgTnVtYmVyLCBmb3Igc29tZXJlYXNvbiwgYWN0dWFsbHkgZ2l2ZXMgYSBudW1iZXIuXG4gICAgLy8gVGhpcyBtZXNzZXMgdXAgdGhlIHR5cGUgZGV0ZWN0aW9uIHdoZW4gY3JlYXRpbmcgYSBWYWx1ZSBmcm9tIGEgSW5rTGlzdC5cbiAgICAvLyBSZXR1cm5pbmcgTmFOIGhlcmUgcHJldmVudHMgdGhhdC5cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5rTGlzdCA9IElua0xpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmtMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Kc29uU2VyaWFsaXNhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgR2x1ZV8xID0gcmVxdWlyZShcIi4vR2x1ZVwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBEaXZlcnRfMSA9IHJlcXVpcmUoXCIuL0RpdmVydFwiKTtcbmNvbnN0IENob2ljZVBvaW50XzEgPSByZXF1aXJlKFwiLi9DaG9pY2VQb2ludFwiKTtcbmNvbnN0IFZhcmlhYmxlUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZVJlZmVyZW5jZVwiKTtcbmNvbnN0IFZhcmlhYmxlQXNzaWdubWVudF8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVBc3NpZ25tZW50XCIpO1xuY29uc3QgTmF0aXZlRnVuY3Rpb25DYWxsXzEgPSByZXF1aXJlKFwiLi9OYXRpdmVGdW5jdGlvbkNhbGxcIik7XG5jb25zdCBWb2lkXzEgPSByZXF1aXJlKFwiLi9Wb2lkXCIpO1xuY29uc3QgVGFnXzEgPSByZXF1aXJlKFwiLi9UYWdcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgQ2hvaWNlXzEgPSByZXF1aXJlKFwiLi9DaG9pY2VcIik7XG5jb25zdCBMaXN0RGVmaW5pdGlvbl8xID0gcmVxdWlyZShcIi4vTGlzdERlZmluaXRpb25cIik7XG5jb25zdCBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMSA9IHJlcXVpcmUoXCIuL0xpc3REZWZpbml0aW9uc09yaWdpblwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIEpzb25TZXJpYWxpc2F0aW9uIHtcbiAgICBzdGF0aWMgSkFycmF5VG9SdW50aW1lT2JqTGlzdChqQXJyYXksIHNraXBMYXN0ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gakFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKHNraXBMYXN0KVxuICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgalRvayA9IGpBcnJheVtpXTtcbiAgICAgICAgICAgIGxldCBydW50aW1lT2JqID0gdGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3QoalRvayk7XG4gICAgICAgICAgICBpZiAocnVudGltZU9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicnVudGltZU9ialwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChydW50aW1lT2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHdyaXRlciwgZGljdGlvbmFyeSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZGljdGlvbmFyeSkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChrZXkpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVMaXN0UnVudGltZU9ianMod3JpdGVyLCBsaXN0KSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgbGlzdCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlSW50RGljdGlvbmFyeSh3cml0ZXIsIGRpY3QpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRpY3QpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgb2JqKSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpdmVydCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIERpdmVydF8xLkRpdmVydCk7XG4gICAgICAgIGlmIChkaXZlcnQpIHtcbiAgICAgICAgICAgIGxldCBkaXZUeXBlS2V5ID0gXCItPlwiO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwieCgpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXZlcnQucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIGlmIChkaXZlcnQuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwiZigpXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmVydC5zdGFja1B1c2hUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2VHlwZUtleSA9IFwiLT50LT5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdGFyZ2V0U3RyO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldFN0ciA9IGRpdmVydC52YXJpYWJsZURpdmVydE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShkaXZUeXBlS2V5LCB0YXJnZXRTdHIpO1xuICAgICAgICAgICAgaWYgKGRpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidmFyXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpdmVydC5pc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjXCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpdmVydC5leHRlcm5hbEFyZ3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJleEFyZ3NcIiwgZGl2ZXJ0LmV4dGVybmFsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hvaWNlUG9pbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KTtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50KSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIqXCIsIGNob2ljZVBvaW50LnBhdGhTdHJpbmdPbkNob2ljZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImZsZ1wiLCBjaG9pY2VQb2ludC5mbGFncyk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGlmIChpbnRWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludChpbnRWYWwudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbG9hdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuRmxvYXRWYWx1ZSk7XG4gICAgICAgIGlmIChmbG9hdFZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlRmxvYXQoZmxvYXRWYWwudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgaWYgKHN0clZhbCkge1xuICAgICAgICAgICAgaWYgKHN0clZhbC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCJcXG5cIiwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nU3RhcnQoKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdJbm5lcihcIl5cIik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nSW5uZXIoc3RyVmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGlzdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKGxpc3RWYWwpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVJbmtMaXN0KHdyaXRlciwgbGlzdFZhbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpdlRhcmdldFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoZGl2VGFyZ2V0VmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgaWYgKGRpdlRhcmdldFZhbC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZGl2VGFyZ2V0VmFsLnZhbHVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJeLT5cIiwgZGl2VGFyZ2V0VmFsLnZhbHVlLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhclB0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICBpZiAodmFyUHRyVmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJedmFyXCIsIHZhclB0clZhbC52YWx1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImNpXCIsIHZhclB0clZhbC5jb250ZXh0SW5kZXgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGdsdWUgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBHbHVlXzEuR2x1ZSk7XG4gICAgICAgIGlmIChnbHVlKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCI8PlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udHJvbENtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICBpZiAoY29udHJvbENtZCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKEpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzW2NvbnRyb2xDbWQuY29tbWFuZFR5cGVdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmF0aXZlRnVuYyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbCk7XG4gICAgICAgIGlmIChuYXRpdmVGdW5jKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IG5hdGl2ZUZ1bmMubmFtZTtcbiAgICAgICAgICAgIGlmIChuYW1lID09IFwiXlwiKVxuICAgICAgICAgICAgICAgIG5hbWUgPSBcIkxeXCI7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUobmFtZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhclJlZiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UpO1xuICAgICAgICBpZiAodmFyUmVmKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgbGV0IHJlYWRDb3VudFBhdGggPSB2YXJSZWYucGF0aFN0cmluZ0ZvckNvdW50O1xuICAgICAgICAgICAgaWYgKHJlYWRDb3VudFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiQ05UP1wiLCByZWFkQ291bnRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiVkFSP1wiLCB2YXJSZWYubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFyQXNzID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KTtcbiAgICAgICAgaWYgKHZhckFzcykge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGxldCBrZXkgPSB2YXJBc3MuaXNHbG9iYWwgPyBcIlZBUj1cIiA6IFwidGVtcD1cIjtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KGtleSwgdmFyQXNzLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAvLyBSZWFzc2lnbm1lbnQ/XG4gICAgICAgICAgICBpZiAoIXZhckFzcy5pc05ld0RlY2xhcmF0aW9uKVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicmVcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdm9pZE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZvaWRfMS5Wb2lkKTtcbiAgICAgICAgaWYgKHZvaWRPYmopIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShcInZvaWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhZyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFRhZ18xLlRhZyk7XG4gICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIiNcIiwgdGFnLnRleHQpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENob2ljZV8xLkNob2ljZSk7XG4gICAgICAgIGlmIChjaG9pY2UpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVDaG9pY2Uod3JpdGVyLCBjaG9pY2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHJ1bnRpbWUgb2JqZWN0IHRvIEpzb24gdG9rZW46IFwiICsgb2JqKTtcbiAgICB9XG4gICAgc3RhdGljIEpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2JqcyhqT2JqZWN0KSB7XG4gICAgICAgIGxldCBkaWN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gak9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGpPYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxldCBpbmtPYmplY3QgPSB0aGlzLkpUb2tlblRvUnVudGltZU9iamVjdChqT2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmtPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpbmtPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpY3Quc2V0KGtleSwgaW5rT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gICAgc3RhdGljIEpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdCkge1xuICAgICAgICBsZXQgZGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGpPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChqT2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkaWN0LnNldChrZXksIHBhcnNlSW50KGpPYmplY3Rba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH1cbiAgICBzdGF0aWMgSlRva2VuVG9SdW50aW1lT2JqZWN0KHRva2VuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwibnVtYmVyXCIgJiYgIWlzTmFOKHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gdG9rZW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIFN0cmluZyB2YWx1ZVxuICAgICAgICAgICAgbGV0IGZpcnN0Q2hhciA9IHN0clswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT0gXCJeXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcoMSkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3RDaGFyID09IFwiXFxuXCIgJiYgc3RyLmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShcIlxcblwiKTtcbiAgICAgICAgICAgIC8vIEdsdWVcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCI8PlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgR2x1ZV8xLkdsdWUoKTtcbiAgICAgICAgICAgIC8vIENvbnRyb2wgY29tbWFuZHMgKHdvdWxkIGxvb2tpbmcgdXAgaW4gYSBoYXNoIHNldCBiZSBmYXN0ZXI/KVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBKc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGxldCBjbWROYW1lID0gSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0ciA9PSBjbWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOYXRpdmUgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoc3RyID09IFwiTF5cIilcbiAgICAgICAgICAgICAgICBzdHIgPSBcIl5cIjtcbiAgICAgICAgICAgIGlmIChOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbEV4aXN0c1dpdGhOYW1lKHN0cikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsV2l0aE5hbWUoc3RyKTtcbiAgICAgICAgICAgIC8vIFBvcFxuICAgICAgICAgICAgaWYgKHN0ciA9PSBcIi0+LT5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Qb3BUdW5uZWwoKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0ciA9PSBcIn5yZXRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Qb3BGdW5jdGlvbigpO1xuICAgICAgICAgICAgLy8gVm9pZFxuICAgICAgICAgICAgaWYgKHN0ciA9PSBcInZvaWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZvaWRfMS5Wb2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0b2tlbjtcbiAgICAgICAgICAgIGxldCBwcm9wVmFsdWU7XG4gICAgICAgICAgICAvLyBEaXZlcnQgdGFyZ2V0IHZhbHVlIHRvIHBhdGhcbiAgICAgICAgICAgIGlmIChvYmpbXCJeLT5cIl0pIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCJeLT5cIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKG5ldyBQYXRoXzEuUGF0aChwcm9wVmFsdWUudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGVQb2ludGVyVmFsdWVcbiAgICAgICAgICAgIGlmIChvYmpbXCJedmFyXCJdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiXnZhclwiXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyUHRyID0gbmV3IFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChcImNpXCIgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcImNpXCJdO1xuICAgICAgICAgICAgICAgICAgICB2YXJQdHIuY29udGV4dEluZGV4ID0gcGFyc2VJbnQocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhclB0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERpdmVydFxuICAgICAgICAgICAgbGV0IGlzRGl2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgcHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgbGV0IGV4dGVybmFsID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIi0+XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJmKClcIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNEaXZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2hlc1RvU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIi0+dC0+XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wieCgpXCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleHRlcm5hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGl2ZXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpdmVydCA9IG5ldyBEaXZlcnRfMS5EaXZlcnQoKTtcbiAgICAgICAgICAgICAgICBkaXZlcnQucHVzaGVzVG9TdGFjayA9IHB1c2hlc1RvU3RhY2s7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LnN0YWNrUHVzaFR5cGUgPSBkaXZQdXNoVHlwZTtcbiAgICAgICAgICAgICAgICBkaXZlcnQuaXNFeHRlcm5hbCA9IGV4dGVybmFsO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcInZhclwiXSkpXG4gICAgICAgICAgICAgICAgICAgIGRpdmVydC52YXJpYWJsZURpdmVydE5hbWUgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZyA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXZlcnQuaXNDb25kaXRpb25hbCA9ICEhb2JqW1wiY1wiXTtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJleEFyZ3NcIl0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0LmV4dGVybmFsQXJncyA9IHBhcnNlSW50KHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkaXZlcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaG9pY2VcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiKlwiXSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZVBvaW50XzEuQ2hvaWNlUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBjaG9pY2UucGF0aFN0cmluZ09uQ2hvaWNlID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJmbGdcIl0pKVxuICAgICAgICAgICAgICAgICAgICBjaG9pY2UuZmxhZ3MgPSBwYXJzZUludChwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiVkFSP1wiXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIkNOVD9cIl0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlYWRDb3VudFZhclJlZiA9IG5ldyBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgcmVhZENvdW50VmFyUmVmLnBhdGhTdHJpbmdGb3JDb3VudCA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ291bnRWYXJSZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSBhc3NpZ25tZW50XG4gICAgICAgICAgICBsZXQgaXNWYXJBc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpc0dsb2JhbFZhciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJWQVI9XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzVmFyQXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc0dsb2JhbFZhciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1widGVtcD1cIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNWYXJBc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzR2xvYmFsVmFyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNWYXJBc3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFyTmFtZSA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBpc05ld0RlY2wgPSAhb2JqW1wicmVcIl07XG4gICAgICAgICAgICAgICAgbGV0IHZhckFzcyA9IG5ldyBWYXJpYWJsZUFzc2lnbm1lbnRfMS5WYXJpYWJsZUFzc2lnbm1lbnQodmFyTmFtZSwgaXNOZXdEZWNsKTtcbiAgICAgICAgICAgICAgICB2YXJBc3MuaXNHbG9iYWwgPSBpc0dsb2JhbFZhcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ialtcIiNcIl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcIiNcIl07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUYWdfMS5UYWcocHJvcFZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJsaXN0XCJdKSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0Q29udGVudCA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0Pilwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RDb250ZW50ID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCByYXdMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJvcmlnaW5zXCJdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbmFtZXNBc09ianMgPSAoTGlzdDxvYmplY3Q+KXByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVzQXNPYmpzID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvLyByYXdMaXN0LlNldEluaXRpYWxPcmlnaW5OYW1lcyhuYW1lc0FzT2Jqcy5DYXN0PHN0cmluZz4oKS5Ub0xpc3QoKSk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0xpc3QuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG5hbWVzQXNPYmpzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGxpc3RDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0Q29udGVudC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZVRvVmFsID0gbGlzdENvbnRlbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RfMS5JbmtMaXN0SXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHBhcnNlSW50KG5hbWVUb1ZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByYXdMaXN0LkFkZChpdGVtLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5MaXN0VmFsdWUocmF3TGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqW1wib3JpZ2luYWxDaG9pY2VQYXRoXCJdICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuSk9iamVjdFRvQ2hvaWNlKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJyYXkgaXMgYWx3YXlzIGEgUnVudGltZS5Db250YWluZXJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5KQXJyYXlUb0NvbnRhaW5lcih0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgdG9rZW4gdG8gcnVudGltZSBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIGNvbnRhaW5lciwgd2l0aG91dE5hbWUgPSBmYWxzZSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgb2YgY29udGFpbmVyLmNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIGMpO1xuICAgICAgICBsZXQgbmFtZWRPbmx5Q29udGVudCA9IGNvbnRhaW5lci5uYW1lZE9ubHlDb250ZW50O1xuICAgICAgICBsZXQgY291bnRGbGFncyA9IGNvbnRhaW5lci5jb3VudEZsYWdzO1xuICAgICAgICBsZXQgaGFzTmFtZVByb3BlcnR5ID0gY29udGFpbmVyLm5hbWUgIT0gbnVsbCAmJiAhd2l0aG91dE5hbWU7XG4gICAgICAgIGxldCBoYXNUZXJtaW5hdG9yID0gbmFtZWRPbmx5Q29udGVudCAhPSBudWxsIHx8IGNvdW50RmxhZ3MgPiAwIHx8IGhhc05hbWVQcm9wZXJ0eTtcbiAgICAgICAgaWYgKGhhc1Rlcm1pbmF0b3IpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVkT25seUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG5hbWVkT25seUNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZWRDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih3cml0ZXIsIG5hbWVkQ29udGFpbmVyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNOYW1lUHJvcGVydHkpXG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIiNuXCIsIGNvbnRhaW5lci5uYW1lKTtcbiAgICAgICAgaWYgKGhhc1Rlcm1pbmF0b3IpXG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlTnVsbCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgSkFycmF5VG9Db250YWluZXIoakFycmF5KSB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIGNvbnRhaW5lci5jb250ZW50ID0gdGhpcy5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpBcnJheSwgdHJ1ZSk7XG4gICAgICAgIGxldCB0ZXJtaW5hdGluZ09iaiA9IGpBcnJheVtqQXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0ZXJtaW5hdGluZ09iaiAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbmFtZWRPbmx5Q29udGVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiB0ZXJtaW5hdGluZ09iaikge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIjZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5jb3VudEZsYWdzID0gcGFyc2VJbnQodGVybWluYXRpbmdPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PSBcIiNuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgPSB0ZXJtaW5hdGluZ09ialtrZXldLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZWRDb250ZW50SXRlbSA9IHRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KHRlcm1pbmF0aW5nT2JqW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbmFtZWRTdWJDb250YWluZXIgPSBuYW1lZENvbnRlbnRJdGVtIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkU3ViQ29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG5hbWVkQ29udGVudEl0ZW0sIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lZFN1YkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVkU3ViQ29udGFpbmVyLm5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnQuc2V0KGtleSwgbmFtZWRDb250ZW50SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyLm5hbWVkT25seUNvbnRlbnQgPSBuYW1lZE9ubHlDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9DaG9pY2Uoak9iaikge1xuICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZV8xLkNob2ljZSgpO1xuICAgICAgICBjaG9pY2UudGV4dCA9IGpPYmpbXCJ0ZXh0XCJdLnRvU3RyaW5nKCk7XG4gICAgICAgIGNob2ljZS5pbmRleCA9IHBhcnNlSW50KGpPYmpbXCJpbmRleFwiXSk7XG4gICAgICAgIGNob2ljZS5zb3VyY2VQYXRoID0gak9ialtcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiXS50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2Uub3JpZ2luYWxUaHJlYWRJbmRleCA9IHBhcnNlSW50KGpPYmpbXCJvcmlnaW5hbFRocmVhZEluZGV4XCJdKTtcbiAgICAgICAgY2hvaWNlLnBhdGhTdHJpbmdPbkNob2ljZSA9IGpPYmpbXCJ0YXJnZXRQYXRoXCJdLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUNob2ljZSh3cml0ZXIsIGNob2ljZSkge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInRleHRcIiwgY2hvaWNlLnRleHQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImluZGV4XCIsIGNob2ljZS5pbmRleCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwib3JpZ2luYWxDaG9pY2VQYXRoXCIsIGNob2ljZS5zb3VyY2VQYXRoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJvcmlnaW5hbFRocmVhZEluZGV4XCIsIGNob2ljZS5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ0YXJnZXRQYXRoXCIsIGNob2ljZS5wYXRoU3RyaW5nT25DaG9pY2UpO1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlSW5rTGlzdCh3cml0ZXIsIGxpc3RWYWwpIHtcbiAgICAgICAgbGV0IHJhd0xpc3QgPSBsaXN0VmFsLnZhbHVlO1xuICAgICAgICBpZiAocmF3TGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYXdMaXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJsaXN0XCIpO1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIHJhd0xpc3QpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBsZXQgaXRlbVZhbCA9IHZhbDtcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lU3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKGl0ZW0ub3JpZ2luTmFtZSA/IGl0ZW0ub3JpZ2luTmFtZSA6IFwiP1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKFwiLlwiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lRW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoaXRlbVZhbCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICBpZiAocmF3TGlzdC5Db3VudCA9PSAwICYmXG4gICAgICAgICAgICByYXdMaXN0Lm9yaWdpbk5hbWVzICE9IG51bGwgJiZcbiAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2luTmFtZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcIm9yaWdpbnNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHJhd0xpc3Qub3JpZ2luTmFtZXMpXG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlKG5hbWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0RGVmaW5pdGlvbnNUb0pUb2tlbihvcmlnaW4pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBkZWYgb2Ygb3JpZ2luLmxpc3RzKSB7XG4gICAgICAgICAgICBsZXQgbGlzdERlZkpzb24gPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgZGVmLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0uaXRlbU5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3REZWZKc29uW2l0ZW0uaXRlbU5hbWVdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W2RlZi5uYW1lXSA9IGxpc3REZWZKc29uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBKVG9rZW5Ub0xpc3REZWZpbml0aW9ucyhvYmopIHtcbiAgICAgICAgLy8gdmFyIGRlZnNPYmogPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pb2JqO1xuICAgICAgICBsZXQgZGVmc09iaiA9IG9iajtcbiAgICAgICAgbGV0IGFsbERlZnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGRlZnNPYmopIHtcbiAgICAgICAgICAgIGlmIChkZWZzT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0RGVmSnNvbiA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0Pilrdi5WYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdERlZkpzb24gPSBkZWZzT2JqW2tleV07XG4gICAgICAgICAgICAgICAgLy8gQ2FzdCAoc3RyaW5nLCBvYmplY3QpIHRvIChzdHJpbmcsIGludCkgZm9yIGl0ZW1zXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG5hbWVWYWx1ZUtleSBpbiBsaXN0RGVmSnNvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmc09iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZVZhbHVlID0gbGlzdERlZkpzb25bbmFtZVZhbHVlS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldChuYW1lVmFsdWVLZXksIHBhcnNlSW50KG5hbWVWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkZWYgPSBuZXcgTGlzdERlZmluaXRpb25fMS5MaXN0RGVmaW5pdGlvbihuYW1lLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgYWxsRGVmcy5wdXNoKGRlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMS5MaXN0RGVmaW5pdGlvbnNPcmlnaW4oYWxsRGVmcyk7XG4gICAgfVxufVxuZXhwb3J0cy5Kc29uU2VyaWFsaXNhdGlvbiA9IEpzb25TZXJpYWxpc2F0aW9uO1xuSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXMgPSAoKCkgPT4ge1xuICAgIGxldCBfY29udHJvbENvbW1hbmROYW1lcyA9IFtdO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0XSA9IFwiZXZcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXRdID0gXCJvdXRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmRdID0gXCIvZXZcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZV0gPSBcImR1XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZV0gPSBcInBvcFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb25dID0gXCJ+cmV0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BUdW5uZWxdID0gXCItPi0+XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZ10gPSBcInN0clwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kU3RyaW5nXSA9IFwiL3N0clwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm9PcF0gPSBcIm5vcFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnRdID0gXCJjaG9pY2VDbnRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zXSA9IFwidHVyblwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZV0gPSBcInR1cm5zXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SZWFkQ291bnRdID0gXCJyZWFkY1wiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tXSA9IFwicm5kXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZWVkUmFuZG9tXSA9IFwic3JuZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleF0gPSBcInZpc2l0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleF0gPVxuICAgICAgICBcInNlcVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWRdID0gXCJ0aHJlYWRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmVdID0gXCJkb25lXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRdID0gXCJlbmRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50XSA9IFwibGlzdEludFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlXSA9IFwicmFuZ2VcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb21dID0gXCJscm5kXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlRPVEFMX1ZBTFVFUzsgKytpKSB7XG4gICAgICAgIGlmIChfY29udHJvbENvbW1hbmROYW1lc1tpXSA9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbCBjb21tYW5kIG5vdCBhY2NvdW50ZWQgZm9yIGluIHNlcmlhbGlzYXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBfY29udHJvbENvbW1hbmROYW1lcztcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Kc29uU2VyaWFsaXNhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdERlZmluaXRpb24gPSB2b2lkIDA7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY2xhc3MgTGlzdERlZmluaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcyA9IGl0ZW1zIHx8IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSW5rTGlzdF8xLklua0xpc3RJdGVtKHRoaXMubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcy5zZXQoaXRlbS5zZXJpYWxpemVkKCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuICAgIFZhbHVlRm9ySXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgaW50VmFsID0gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5nZXQoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgaW50VmFsICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuIGludFZhbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbShpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0ub3JpZ2luTmFtZSAhPSB0aGlzLm5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyhpdGVtLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgQ29udGFpbnNJdGVtV2l0aE5hbWUoaXRlbU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuaGFzKGl0ZW1OYW1lKTtcbiAgICB9XG4gICAgVHJ5R2V0SXRlbVdpdGhWYWx1ZSh2YWwsIFxuICAgIC8qIG91dCAqLyBpdGVtKSB7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0odGhpcy5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogaXRlbSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsO1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGl0ZW0sIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgVHJ5R2V0VmFsdWVGb3JJdGVtKGl0ZW0sIFxuICAgIC8qIG91dCAqLyBpbnRWYWwpIHtcbiAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiAwLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiAwLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdERlZmluaXRpb24gPSBMaXN0RGVmaW5pdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3REZWZpbml0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbnNPcmlnaW4gPSB2b2lkIDA7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIExpc3REZWZpbml0aW9uc09yaWdpbiB7XG4gICAgY29uc3RydWN0b3IobGlzdHMpIHtcbiAgICAgICAgdGhpcy5fbGlzdHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGxpc3Qgb2YgbGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RzLnNldChsaXN0Lm5hbWUsIGxpc3QpO1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBsaXN0Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIml0ZW0uaXRlbU5hbWUgaXMgbnVsbCBvciB1bmRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChpdGVtLml0ZW1OYW1lLCBsaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuc2V0KGl0ZW0uZnVsbE5hbWUsIGxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxpc3RzKCkge1xuICAgICAgICBsZXQgbGlzdE9mTGlzdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgWywgdmFsdWVdIG9mIHRoaXMuX2xpc3RzKSB7XG4gICAgICAgICAgICBsaXN0T2ZMaXN0cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdE9mTGlzdHM7XG4gICAgfVxuICAgIFRyeUxpc3RHZXREZWZpbml0aW9uKG5hbWUsIFxuICAgIC8qIG91dCAqLyBkZWYpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW5pdGlhbGx5LCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib29sZWFuIGFuZCB0aGUgc2Vjb25kIHBhcmFtZXRlciBpcyBhbiBvdXQuXG4gICAgICAgIGxldCBkZWZpbml0aW9uID0gdGhpcy5fbGlzdHMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIWRlZmluaXRpb24pXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZiwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZmluaXRpb24sIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBGaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbCA9IHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkxpc3REZWZpbml0aW9uc09yaWdpbiA9IExpc3REZWZpbml0aW9uc09yaWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxpc3REZWZpbml0aW9uc09yaWdpbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmF0aXZlRnVuY3Rpb25DYWxsID0gdm9pZCAwO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgTmF0aXZlRnVuY3Rpb25DYWxsIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX251bWJlck9mUGFyYW1ldGVycyA9IDA7XG4gICAgICAgIHRoaXMuX3Byb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUHJvdG90eXBlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBudW1iZXJPZlBhcmFtZXRlcnMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9pc1Byb3RvdHlwZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5udW1iZXJPZlBhcmFtZXRlcnMgPSBudW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIENhbGxXaXRoTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYXRpdmVGdW5jdGlvbkNhbGwoZnVuY3Rpb25OYW1lKTtcbiAgICB9XG4gICAgc3RhdGljIENhbGxFeGlzdHNXaXRoTmFtZShmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdGhpcy5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5fbmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYW1lXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICBpZiAoIXRoaXMuX2lzUHJvdG90eXBlKSB7XG4gICAgICAgICAgICBpZiAoTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3RvdHlwZSA9XG4gICAgICAgICAgICAgICAgICAgIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zLmdldCh0aGlzLl9uYW1lKSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBudW1iZXJPZlBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b3R5cGUubnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlck9mUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX251bWJlck9mUGFyYW1ldGVycyA9IHZhbHVlO1xuICAgIH1cbiAgICBDYWxsKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvdHlwZS5DYWxsKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm51bWJlck9mUGFyYW1ldGVycyAhPSBwYXJhbWV0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFzTGlzdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBwIG9mIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oJ0F0dGVtcHRpbmcgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24gYSB2b2lkIHZhbHVlLiBEaWQgeW91IGZvcmdldCB0byBcInJldHVyblwiIGEgdmFsdWUgZnJvbSBhIGZ1bmN0aW9uIHlvdSBjYWxsZWQgaGVyZT8nKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgVmFsdWVfMS5MaXN0VmFsdWUpXG4gICAgICAgICAgICAgICAgaGFzTGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtZXRlcnMubGVuZ3RoID09IDIgJiYgaGFzTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24ocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZXJjZWRQYXJhbXMgPSB0aGlzLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZShwYXJhbWV0ZXJzKTtcbiAgICAgICAgbGV0IGNvZXJjZWRUeXBlID0gY29lcmNlZFBhcmFtc1swXS52YWx1ZVR5cGU7XG4gICAgICAgIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIENhbGxUeXBlKHBhcmFtZXRlcnNPZlNpbmdsZVR5cGUpIHtcbiAgICAgICAgbGV0IHBhcmFtMSA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNPZlNpbmdsZVR5cGVbMF0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdmFsVHlwZSA9IHBhcmFtMS52YWx1ZVR5cGU7XG4gICAgICAgIGxldCB2YWwxID0gcGFyYW0xO1xuICAgICAgICBsZXQgcGFyYW1Db3VudCA9IHBhcmFtZXRlcnNPZlNpbmdsZVR5cGUubGVuZ3RoO1xuICAgICAgICBpZiAocGFyYW1Db3VudCA9PSAyIHx8IHBhcmFtQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBvcEZvclR5cGVPYmogPSB0aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQodmFsVHlwZSk7XG4gICAgICAgICAgICBpZiAoIW9wRm9yVHlwZU9iaikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFZhbHVlXzEuVmFsdWVUeXBlW3ZhbFR5cGVdO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIFwiICsgdGhpcy5uYW1lICsgXCIgb24gXCIgKyBrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtQ291bnQgPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBwYXJhbTIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlWzFdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsMiA9IHBhcmFtMjtcbiAgICAgICAgICAgICAgICBsZXQgb3BGb3JUeXBlID0gb3BGb3JUeXBlT2JqO1xuICAgICAgICAgICAgICAgIGlmICh2YWwxLnZhbHVlID09PSBudWxsIHx8IHZhbDIudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGwgQmluYXJ5T3AgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRWYWwgPSBvcEZvclR5cGUodmFsMS52YWx1ZSwgdmFsMi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb3BGb3JUeXBlID0gb3BGb3JUeXBlT2JqO1xuICAgICAgICAgICAgICAgIGlmICh2YWwxLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIFVuYXJ5T3AgdmFsdWVcIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFZhbCA9IG9wRm9yVHlwZSh2YWwxLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgaXMgZGlmZmVyZW50IGZyb20gdXBzdHJlYW0uIFNpbmNlIEphdmFTY3JpcHQgdHJlYXRzXG4gICAgICAgICAgICAgICAgLy8gaW50ZWdlcnMgYW5kIGZsb2F0cyBhcyB0aGUgc2FtZSBudW1iZXJzLCBpdCdzIGltcG9zc2libGVcbiAgICAgICAgICAgICAgICAvLyB0byBmb3JjZSBhbiBudW1iZXIgdG8gYmUgZWl0aGVyIGFuIGludGVnZXIgb3IgYSBmbG9hdC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEl0IGNhbiBiZSB1c2VmdWwgdG8gZm9yY2UgYSBzcGVjaWZpYyBudW1iZXIgdHlwZVxuICAgICAgICAgICAgICAgIC8vIChlc3BlY2lhbGx5IGZvciBkaXZpc2lvbnMpLCBzbyB0aGUgcmVzdWx0IG9mIElOVCgpICYgRkxPQVQoKVxuICAgICAgICAgICAgICAgIC8vIGlzIGNvZXJjZWQgdG8gdGhlIHRoZSBwcm9wZXIgdmFsdWUgdHlwZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBhbHNvIGZvcmNlIGFsbCBvdGhlciB1bmFyeSBvcGVyYXRpb24gdG9cbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhlIHNhbWUgdmFsdWUgdHlwZSwgYWx0aG91Z2ggdGhpcyBpcyBvbmx5XG4gICAgICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBmb3IgbnVtYmVycy4gU2VlIGBWYWx1ZS5DcmVhdGVgLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT09IE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgVmFsdWVfMS5WYWx1ZVR5cGUuSW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5uYW1lID09PSBOYXRpdmVGdW5jdGlvbkNhbGwuRmxvYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHJlc3VsdFZhbCwgcGFyYW0xLnZhbHVlVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVycyB0byBOYXRpdmVGdW5jdGlvbkNhbGw6IFwiICtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24ocGFyYW1ldGVycykge1xuICAgICAgICBpZiAoKHRoaXMubmFtZSA9PSBcIitcIiB8fCB0aGlzLm5hbWUgPT0gXCItXCIpICYmXG4gICAgICAgICAgICBwYXJhbWV0ZXJzWzBdIGluc3RhbmNlb2YgVmFsdWVfMS5MaXN0VmFsdWUgJiZcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbMV0gaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24ocGFyYW1ldGVycyk7XG4gICAgICAgIGxldCB2MSA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNbMF0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdjIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzWzFdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgaWYgKCh0aGlzLm5hbWUgPT0gXCImJlwiIHx8IHRoaXMubmFtZSA9PSBcInx8XCIpICYmXG4gICAgICAgICAgICAodjEudmFsdWVUeXBlICE9IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QgfHwgdjIudmFsdWVUeXBlICE9IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO1xuICAgICAgICAgICAgbGV0IG9wID0gdGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KFZhbHVlXzEuVmFsdWVUeXBlLkludCk7XG4gICAgICAgICAgICBpZiAob3AgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24gb3BcIik7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gb3AodjEuaXNUcnV0aHkgPyAxIDogMCwgdjIuaXNUcnV0aHkgPyAxIDogMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuSW50VmFsdWUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodjEudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QgJiYgdjIudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShbdjEsIHYyXSk7XG4gICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuIG5vdCBjYWxsIHVzZSBcIiArXG4gICAgICAgICAgICB0aGlzLm5hbWUgK1xuICAgICAgICAgICAgXCIgb3BlcmF0aW9uIG9uIFwiICtcbiAgICAgICAgICAgIFZhbHVlXzEuVmFsdWVUeXBlW3YxLnZhbHVlVHlwZV0gK1xuICAgICAgICAgICAgXCIgYW5kIFwiICtcbiAgICAgICAgICAgIFZhbHVlXzEuVmFsdWVUeXBlW3YyLnZhbHVlVHlwZV0pO1xuICAgIH1cbiAgICBDYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbihsaXN0SW50UGFyYW1zKSB7XG4gICAgICAgIGxldCBsaXN0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobGlzdEludFBhcmFtc1swXSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobGlzdEludFBhcmFtc1sxXSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGxldCByZXN1bHRJbmtMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgIGlmIChsaXN0VmFsLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZVwiKTtcbiAgICAgICAgZm9yIChsZXQgW2xpc3RJdGVtS2V5LCBsaXN0SXRlbVZhbHVlXSBvZiBsaXN0VmFsLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbGlzdEl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkobGlzdEl0ZW1LZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBpbnRPcCA9IHRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpO1xuICAgICAgICAgICAgaWYgKGludFZhbC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBpbnRWYWwudmFsdWVcIik7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0SW50ID0gaW50T3AobGlzdEl0ZW1WYWx1ZSwgaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIGxldCBpdGVtT3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChsaXN0VmFsLnZhbHVlLm9yaWdpbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZS5vcmlnaW5zXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3JpZ2luIG9mIGxpc3RWYWwudmFsdWUub3JpZ2lucykge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBsaXN0SXRlbS5vcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtT3JpZ2luICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5jcmVtZW50ZWRJdGVtID0gaXRlbU9yaWdpbi5UcnlHZXRJdGVtV2l0aFZhbHVlKHRhcmdldEludCwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmNyZW1lbnRlZEl0ZW0uZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRJbmtMaXN0LkFkZChpbmNyZW1lbnRlZEl0ZW0ucmVzdWx0LCB0YXJnZXRJbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5MaXN0VmFsdWUocmVzdWx0SW5rTGlzdCk7XG4gICAgfVxuICAgIENvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZShwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgbGV0IHZhbFR5cGUgPSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQ7XG4gICAgICAgIGxldCBzcGVjaWFsQ2FzZUxpc3QgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBvYmogb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWwudmFsdWVUeXBlID4gdmFsVHlwZSkge1xuICAgICAgICAgICAgICAgIHZhbFR5cGUgPSB2YWwudmFsdWVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxDYXNlTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWwsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyYW1ldGVyc091dCA9IFtdO1xuICAgICAgICBpZiAoVmFsdWVfMS5WYWx1ZVR5cGVbdmFsVHlwZV0gPT0gVmFsdWVfMS5WYWx1ZVR5cGVbVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdF0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlua09iamVjdFZhbCBvZiBwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoaW5rT2JqZWN0VmFsLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50VmFsID0gcGFyc2VJbnQodmFsLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbENhc2VMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Moc3BlY2lhbENhc2VMaXN0LCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsQ2FzZUxpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUgc3BlY2lhbENhc2VMaXN0LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IHNwZWNpYWxDYXNlTGlzdC52YWx1ZS5vcmlnaW5PZk1heEl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIGxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbGlzdC5UcnlHZXRJdGVtV2l0aFZhbHVlKGludFZhbCwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYXN0ZWRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShpdGVtLnJlc3VsdCwgaW50VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaChjYXN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDb3VsZCBub3QgZmluZCBMaXN0IGl0ZW0gd2l0aCB0aGUgdmFsdWUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFZhbCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgaW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBWYWx1ZV8xLlZhbHVlVHlwZVt2YWwudmFsdWVUeXBlXTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgbWl4IExpc3RzIGFuZCBcIiArIGtleSArIFwiIHZhbHVlcyBpbiB0aGlzIG9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmtPYmplY3RWYWwgb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGlua09iamVjdFZhbCwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNhc3RlZFZhbHVlID0gdmFsLkNhc3QodmFsVHlwZSk7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc091dC5wdXNoKGNhc3RlZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1ldGVyc091dDtcbiAgICB9XG4gICAgc3RhdGljIElkZW50aXR5KHQpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICAgIHN0YXRpYyBHZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCkge1xuICAgICAgICBpZiAodGhpcy5fbmF0aXZlRnVuY3Rpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZ1bmN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8vIEludCBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geCArIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geCAtIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCAoeCwgeSkgPT4geCAqIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkRpdmlkZSwgKHgsIHkpID0+IE1hdGguZmxvb3IoeCAvIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Nb2QsICh4LCB5KSA9PiB4ICUgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5OZWdhdGUsICh4KSA9PiAteCk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeCA9PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyLCAoeCwgeSkgPT4gKHggPiB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5MZXNzLCAoeCwgeSkgPT4gKHggPCB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4gKHggPj0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywgKHgsIHkpID0+ICh4IDw9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICh4ICE9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTm90LCAoeCkgPT4gKHggPT0gMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQW5kLCAoeCwgeSkgPT4gKHggIT0gMCAmJiB5ICE9IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk9yLCAoeCwgeSkgPT4gKHggIT0gMCB8fCB5ICE9IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1heCwgKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NaW4sICh4LCB5KSA9PiBNYXRoLm1pbih4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuUG93LCAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvb3IsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5DZWlsaW5nLCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuSW50LCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvYXQsICh4KSA9PiB4KTtcbiAgICAgICAgICAgIC8vIEZsb2F0IG9wZXJhdGlvbnNcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geCAtIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTXVsdGlwbHksICh4LCB5KSA9PiB4ICogeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5EaXZpZGUsICh4LCB5KSA9PiB4IC8geSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Nb2QsICh4LCB5KSA9PiB4ICUgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLk5lZ2F0ZSwgKHgpID0+IC14KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHggPT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5HcmVhdGVyLCAoeCwgeSkgPT4gKHggPiB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3MsICh4LCB5KSA9PiAoeCA8IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+IHggPj0geSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiAoeCA8PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICh4ICE9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5Ob3QsICh4KSA9PiAoeCA9PSAwLjAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuQW5kLCAoeCwgeSkgPT4gKHggIT0gMC4wICYmIHkgIT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk9yLCAoeCwgeSkgPT4gKHggIT0gMC4wIHx8IHkgIT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1heCwgKHgsIHkpID0+IE1hdGgubWF4KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1pbiwgKHgsIHkpID0+IE1hdGgubWluKHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlBvdywgKHgsIHkpID0+IE1hdGgucG93KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvb3IsICh4KSA9PiBNYXRoLmZsb29yKHgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuQ2VpbGluZywgKHgpID0+IE1hdGguY2VpbCh4KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkludCwgKHgpID0+IE1hdGguZmxvb3IoeCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5GbG9hdCwgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIC8vIFN0cmluZyBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geCArIHkpOyAvLyBjb25jYXRcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4ID09PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoISh4ID09PSB5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuSGFzLCAoeCwgeSkgPT4gKHguaW5jbHVkZXMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhc250LCAoeCwgeSkgPT4gKHguaW5jbHVkZXMoeSkgPyAwIDogMSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4LlVuaW9uKHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsICh4LCB5KSA9PiB4LldpdGhvdXQoeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXMsICh4LCB5KSA9PiAoeC5Db250YWlucyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkhhc250LCAoeCwgeSkgPT4gKHguQ29udGFpbnMoeSkgPyAwIDogMSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5JbnRlcnNlY3QsICh4LCB5KSA9PiB4LkludGVyc2VjdCh5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHguRXF1YWxzKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4LkdyZWF0ZXJUaGFuKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzcywgKHgsIHkpID0+ICh4Lkxlc3NUaGFuKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+IHguR3JlYXRlclRoYW5PckVxdWFscyh5KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywgKHgsIHkpID0+IHguTGVzc1RoYW5PckVxdWFscyh5KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKCF4LkVxdWFscyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+IHguQ291bnQgPiAwICYmIHkuQ291bnQgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+IHguQ291bnQgPiAwIHx8IHkuQ291bnQgPiAwID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLk5vdCwgKHgpID0+ICh4LkNvdW50ID09IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkludmVydCwgKHgpID0+IHguaW52ZXJzZSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQWxsLCAoeCkgPT4geC5hbGwpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkxpc3RNaW4sICh4KSA9PiB4Lk1pbkFzTGlzdCgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWF4LCAoeCkgPT4geC5NYXhBc0xpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQ291bnQsICh4KSA9PiB4LkNvdW50KTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5WYWx1ZU9mTGlzdCwgKHgpID0+IHgubWF4SXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0c0VxdWFsID0gKGQxLCBkMikgPT4gKGQxLkVxdWFscyhkMikgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0c05vdEVxdWFsID0gKGQxLCBkMikgPT4gZDEuRXF1YWxzKGQyKSA/IDAgOiAxO1xuICAgICAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLkVxdWFsLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQsIGRpdmVydFRhcmdldHNFcXVhbCk7XG4gICAgICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHRoaXMuTm90RXF1YWxzLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQsIGRpdmVydFRhcmdldHNOb3RFcXVhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQWRkT3BGdW5jRm9yVHlwZSh2YWxUeXBlLCBvcCkge1xuICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fb3BlcmF0aW9uRnVuY3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uRnVuY3Muc2V0KHZhbFR5cGUsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIGFyZ3MsIHZhbFR5cGUsIG9wKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYXRpdmVGdW5jdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpO1xuICAgICAgICBsZXQgbmF0aXZlRnVuYyA9IHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbmF0aXZlRnVuYykge1xuICAgICAgICAgICAgbmF0aXZlRnVuYyA9IG5ldyBOYXRpdmVGdW5jdGlvbkNhbGwobmFtZSwgYXJncyk7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuc2V0KG5hbWUsIG5hdGl2ZUZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIG5hdGl2ZUZ1bmMuQWRkT3BGdW5jRm9yVHlwZSh2YWxUeXBlLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRJbnRCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkludCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkSW50VW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDEsIFZhbHVlXzEuVmFsdWVUeXBlLkludCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkRmxvYXRCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRGbG9hdFVuYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAxLCBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkU3RyaW5nQmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5TdHJpbmcsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZExpc3RCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZExpc3RVbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMSwgVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCwgb3ApO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICdOYXRpdmUgXCInICsgdGhpcy5uYW1lICsgJ1wiJztcbiAgICB9XG59XG5leHBvcnRzLk5hdGl2ZUZ1bmN0aW9uQ2FsbCA9IE5hdGl2ZUZ1bmN0aW9uQ2FsbDtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5BZGQgPSBcIitcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5TdWJ0cmFjdCA9IFwiLVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkRpdmlkZSA9IFwiL1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk11bHRpcGx5ID0gXCIqXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTW9kID0gXCIlXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTmVnYXRlID0gXCJfXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRXF1YWwgPSBcIj09XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuR3JlYXRlciA9IFwiPlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxlc3MgPSBcIjxcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5HcmVhdGVyVGhhbk9yRXF1YWxzID0gXCI+PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxlc3NUaGFuT3JFcXVhbHMgPSBcIjw9XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTm90RXF1YWxzID0gXCIhPVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5vdCA9IFwiIVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkFuZCA9IFwiJiZcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5PciA9IFwifHxcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NaW4gPSBcIk1JTlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk1heCA9IFwiTUFYXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuUG93ID0gXCJQT1dcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5GbG9vciA9IFwiRkxPT1JcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DZWlsaW5nID0gXCJDRUlMSU5HXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW50ID0gXCJJTlRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5GbG9hdCA9IFwiRkxPQVRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5IYXMgPSBcIj9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5IYXNudCA9IFwiIT9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnRlcnNlY3QgPSBcIl5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MaXN0TWluID0gXCJMSVNUX01JTlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxpc3RNYXggPSBcIkxJU1RfTUFYXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQWxsID0gXCJMSVNUX0FMTFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkNvdW50ID0gXCJMSVNUX0NPVU5UXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuVmFsdWVPZkxpc3QgPSBcIkxJU1RfVkFMVUVcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnZlcnQgPSBcIkxJU1RfSU5WRVJUXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9ucyA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OYXRpdmVGdW5jdGlvbkNhbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRocm93TnVsbEV4Y2VwdGlvbiA9IGV4cG9ydHMuTnVsbEV4Y2VwdGlvbiA9IHZvaWQgMDtcbi8qKlxuICogSW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUsIGEgU3lzdGVtRXhjZXB0aW9uIHdvdWxkIGJlIHRocm93biB3aGVuIHBhc3NpbmdcbiAqIG51bGwgdG8gbWV0aG9kcyBleHBlY3RlZCBhIHZhbGlkIGluc3RhbmNlLiBKYXZhc2NyaXB0IGhhcyBubyBzdWNoXG4gKiBjb25jZXB0LCBidXQgVHlwZVNjcmlwdCB3aWxsIG5vdCBhbGxvdyBgbnVsbGAgdG8gYmUgcGFzc2VkIHRvIG1ldGhvZHNcbiAqIGV4cGxpY2l0ZWx5IHJlcXVpcmluZyBhIHZhbGlkIHR5cGUuXG4gKlxuICogV2hlbmV2ZXIgVHlwZVNjcmlwdCBjb21wbGFpbiBhYm91dCB0aGUgcG9zc2liaWxpdHkgb2YgYSBgbnVsbGAgdmFsdWUsXG4gKiBjaGVjayB0aGUgb2ZmZW5kaW5nIHZhbHVlIGFuZCBpdCBpdCdzIG51bGwsIHRocm93IHRoaXMgZXhjZXB0aW9uIHVzaW5nXG4gKiBgdGhyb3dOdWxsRXhjZXB0aW9uKG5hbWU6IHN0cmluZylgLlxuICovXG5jbGFzcyBOdWxsRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xufVxuZXhwb3J0cy5OdWxsRXhjZXB0aW9uID0gTnVsbEV4Y2VwdGlvbjtcbi8qKlxuICogVGhyb3cgYSBOdWxsRXhjZXB0aW9uLlxuICpcbiAqIEBwYXJhbSBuYW1lIGEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIG9mZmVuZGluZyB2YWx1ZSAob2Z0ZW4gaXRzIG5hbWUgd2l0aGluIHRoZSBjb2RlKS5cbiAqL1xuZnVuY3Rpb24gdGhyb3dOdWxsRXhjZXB0aW9uKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgTnVsbEV4Y2VwdGlvbihgJHtuYW1lfSBpcyBudWxsIG9yIHVuZGVmaW5lZGApO1xufVxuZXhwb3J0cy50aHJvd051bGxFeGNlcHRpb24gPSB0aHJvd051bGxFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdWxsRXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmtPYmplY3QgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIElua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVidWdNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhdGggPSBudWxsO1xuICAgIH1cbiAgICBnZXQgZGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlYnVnTWV0YWRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z01ldGFkYXRhO1xuICAgIH1cbiAgICBzZXQgZGVidWdNZXRhZGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWJ1Z01ldGFkYXRhID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBvd25EZWJ1Z01ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdNZXRhZGF0YTtcbiAgICB9XG4gICAgRGVidWdMaW5lTnVtYmVyT2ZQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBhIGxpbmUgbnVtYmVyIGZyb20gZGVidWcgbWV0YWRhdGFcbiAgICAgICAgbGV0IHJvb3QgPSB0aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldENvbnRlbnQgPSByb290LkNvbnRlbnRBdFBhdGgocGF0aCkub2JqO1xuICAgICAgICAgICAgaWYgKHRhcmdldENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZG0gPSB0YXJnZXRDb250ZW50LmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkbS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoID0gbmV3IFBhdGhfMS5QYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29tcHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY2hpbGQucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjb250YWluZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkQ2hpbGQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVkQ2hpbGQgIT0gbnVsbCAmJiBuYW1lZENoaWxkLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHMudW5zaGlmdChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KG5hbWVkQ2hpbGQubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHMudW5zaGlmdChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KGNvbnRhaW5lci5jb250ZW50LmluZGV4T2YoY2hpbGQpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjb250YWluZXIucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoID0gbmV3IFBhdGhfMS5QYXRoKGNvbXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aDtcbiAgICB9XG4gICAgUmVzb2x2ZVBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicGF0aFwiKTtcbiAgICAgICAgaWYgKHBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IG5lYXJlc3RDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcywgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChuZWFyZXN0Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5wYXJlbnQgIT09IG51bGwsIFwiQ2FuJ3QgcmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudFwiKTtcbiAgICAgICAgICAgICAgICBuZWFyZXN0Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KG5lYXJlc3RDb250YWluZXIgIT09IG51bGwsIFwiRXhwZWN0ZWQgcGFyZW50IHRvIGJlIGEgY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHBhdGguR2V0Q29tcG9uZW50KDApLmlzUGFyZW50KTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC50YWlsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lYXJlc3RDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5lYXJlc3RDb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmVhcmVzdENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRDb250YWluZXIgPSB0aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRlbnRDb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENvbnZlcnRQYXRoVG9SZWxhdGl2ZShnbG9iYWxQYXRoKSB7XG4gICAgICAgIGxldCBvd25QYXRoID0gdGhpcy5wYXRoO1xuICAgICAgICBsZXQgbWluUGF0aExlbmd0aCA9IE1hdGgubWluKGdsb2JhbFBhdGgubGVuZ3RoLCBvd25QYXRoLmxlbmd0aCk7XG4gICAgICAgIGxldCBsYXN0U2hhcmVkUGF0aENvbXBJbmRleCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pblBhdGhMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IG93bkNvbXAgPSBvd25QYXRoLkdldENvbXBvbmVudChpKTtcbiAgICAgICAgICAgIGxldCBvdGhlckNvbXAgPSBnbG9iYWxQYXRoLkdldENvbXBvbmVudChpKTtcbiAgICAgICAgICAgIGlmIChvd25Db21wLkVxdWFscyhvdGhlckNvbXApKSB7XG4gICAgICAgICAgICAgICAgbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc2hhcmVkIHBhdGggY29tcG9uZW50cywgc28ganVzdCB1c2UgZ2xvYmFsIHBhdGhcbiAgICAgICAgaWYgKGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFBhdGg7XG4gICAgICAgIGxldCBudW1VcHdhcmRzTW92ZXMgPSBvd25QYXRoLmNvbXBvbmVudENvdW50IC0gMSAtIGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4O1xuICAgICAgICBsZXQgbmV3UGF0aENvbXBzID0gW107XG4gICAgICAgIGZvciAobGV0IHVwID0gMDsgdXAgPCBudW1VcHdhcmRzTW92ZXM7ICsrdXApXG4gICAgICAgICAgICBuZXdQYXRoQ29tcHMucHVzaChQYXRoXzEuUGF0aC5Db21wb25lbnQuVG9QYXJlbnQoKSk7XG4gICAgICAgIGZvciAobGV0IGRvd24gPSBsYXN0U2hhcmVkUGF0aENvbXBJbmRleCArIDE7IGRvd24gPCBnbG9iYWxQYXRoLmNvbXBvbmVudENvdW50OyArK2Rvd24pXG4gICAgICAgICAgICBuZXdQYXRoQ29tcHMucHVzaChnbG9iYWxQYXRoLkdldENvbXBvbmVudChkb3duKSk7XG4gICAgICAgIGxldCByZWxhdGl2ZVBhdGggPSBuZXcgUGF0aF8xLlBhdGgobmV3UGF0aENvbXBzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aDtcbiAgICB9XG4gICAgQ29tcGFjdFBhdGhTdHJpbmcob3RoZXJQYXRoKSB7XG4gICAgICAgIGxldCBnbG9iYWxQYXRoU3RyID0gbnVsbDtcbiAgICAgICAgbGV0IHJlbGF0aXZlUGF0aFN0ciA9IG51bGw7XG4gICAgICAgIGlmIChvdGhlclBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoU3RyID0gb3RoZXJQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgICAgICBnbG9iYWxQYXRoU3RyID0gdGhpcy5wYXRoLlBhdGhCeUFwcGVuZGluZ1BhdGgob3RoZXJQYXRoKS5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlUGF0aCA9IHRoaXMuQ29udmVydFBhdGhUb1JlbGF0aXZlKG90aGVyUGF0aCk7XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGhTdHIgPSByZWxhdGl2ZVBhdGguY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgICAgIGdsb2JhbFBhdGhTdHIgPSBvdGhlclBhdGguY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVsYXRpdmVQYXRoU3RyLmxlbmd0aCA8IGdsb2JhbFBhdGhTdHIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlUGF0aFN0cjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFBhdGhTdHI7XG4gICAgfVxuICAgIGdldCByb290Q29udGVudENvbnRhaW5lcigpIHtcbiAgICAgICAgbGV0IGFuY2VzdG9yID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yLnBhcmVudCkge1xuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChhbmNlc3RvciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWQ6IERvZXNuJ3Qgc3VwcG9ydCBjb3B5aW5nXCIpO1xuICAgIH1cbiAgICAvLyBTZXRDaGlsZCB3b3JrcyBzbGlnaHRseSBkaWZlcmVudGx5IGluIHRoZSBqcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAvLyBTaW5jZSB3ZSBjYW4ndCBwYXNzIGFuIG9iamV0cyBwcm9wZXJ0eSBieSByZWZlcmVuY2UsIHdlIGluc3RlYWQgcGFzc1xuICAgIC8vIHRoZSBvYmplY3QgYW5kIHRoZSBwcm9wZXJ0eSBzdHJpbmcuXG4gICAgLy8gVE9ETzogVGhpcyBtZXRob2QgY2FuIHByb2JhYmx5IGJlIHJld3JpdHRlbiB3aXRoIHR5cGUtc2FmZXR5IGluIG1pbmQuXG4gICAgU2V0Q2hpbGQob2JqLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2JqW3Byb3BdKVxuICAgICAgICAgICAgb2JqW3Byb3BdID0gbnVsbDtcbiAgICAgICAgb2JqW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGlmIChvYmpbcHJvcF0pXG4gICAgICAgICAgICBvYmpbcHJvcF0ucGFyZW50ID0gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLklua09iamVjdCA9IElua09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUFJORyA9IHZvaWQgMDtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmxpeHQvZjE3YjQ3YzYyNTA4YmU1OTk4N2Jcbi8vIEluayB1c2VzIGEgc2VlZGFibGUgUFJORyBvZiB3aGljaCB0aGVyZSBpcyBub25lIGluIG5hdGl2ZSBqYXZhc2NyaXB0LlxuY2xhc3MgUFJORyB7XG4gICAgY29uc3RydWN0b3Ioc2VlZCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkICUgMjE0NzQ4MzY0NztcbiAgICAgICAgaWYgKHRoaXMuc2VlZCA8PSAwKVxuICAgICAgICAgICAgdGhpcy5zZWVkICs9IDIxNDc0ODM2NDY7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5zZWVkID0gKHRoaXMuc2VlZCAqIDE2ODA3KSAlIDIxNDc0ODM2NDcpO1xuICAgIH1cbiAgICBuZXh0RmxvYXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5uZXh0KCkgLSAxKSAvIDIxNDc0ODM2NDY7XG4gICAgfVxufVxuZXhwb3J0cy5QUk5HID0gUFJORztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBSTkcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGggPSB2b2lkIDA7XG5jbGFzcyBQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNSZWxhdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50c1N0cmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1N0cmluZyA9IGNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUGF0aC5Db21wb25lbnQgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBhdGgpIHtcbiAgICAgICAgICAgIGxldCBoZWFkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHRhaWwgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLnB1c2goaGVhZCk7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5jb25jYXQodGFpbC5fY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBoZWFkID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IHJlbGF0aXZlID0gISFhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5jb25jYXQoaGVhZCk7XG4gICAgICAgICAgICB0aGlzLl9pc1JlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzUmVsYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1JlbGF0aXZlO1xuICAgIH1cbiAgICBnZXQgY29tcG9uZW50Q291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGhlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHRhaWwoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAvLyBjYXJlZnVsLCB0aGUgb3JpZ2luYWwgY29kZSB1c2VzIGxlbmd0aC0xIGhlcmUuIFRoaXMgaXMgYmVjYXVzZSB0aGUgc2Vjb25kIGFyZ3VtZW50IG9mXG4gICAgICAgICAgICAvLyBMaXN0LkdldFJhbmdlIGlzIGEgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4dHJhY3QsIHdoZXJlYXNlIEFycmF5LnNsaWNlIHVzZXMgYW4gaW5kZXhcbiAgICAgICAgICAgIGxldCB0YWlsQ29tcHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKDEsIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGF0aCh0YWlsQ29tcHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGguc2VsZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBsYXN0Q29tcG9uZW50KCkge1xuICAgICAgICBsZXQgbGFzdENvbXBvbmVudElkeCA9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGxhc3RDb21wb25lbnRJZHggPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbbGFzdENvbXBvbmVudElkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY29udGFpbnNOYW1lZENvbXBvbmVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzW2ldLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc2VsZigpIHtcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aCgpO1xuICAgICAgICBwYXRoLl9pc1JlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIEdldENvbXBvbmVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG4gICAgfVxuICAgIFBhdGhCeUFwcGVuZGluZ1BhdGgocGF0aFRvQXBwZW5kKSB7XG4gICAgICAgIGxldCBwID0gbmV3IFBhdGgoKTtcbiAgICAgICAgbGV0IHVwd2FyZE1vdmVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHNbaV0uaXNQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB1cHdhcmRNb3ZlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCAtIHVwd2FyZE1vdmVzOyArK2kpIHtcbiAgICAgICAgICAgIHAuX2NvbXBvbmVudHMucHVzaCh0aGlzLl9jb21wb25lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdXB3YXJkTW92ZXM7IGkgPCBwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHAuX2NvbXBvbmVudHMucHVzaChwYXRoVG9BcHBlbmQuX2NvbXBvbmVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBnZXQgY29tcG9uZW50c1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHRoaXMuX2NvbXBvbmVudHMuam9pbihcIi5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKVxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSBcIi5cIiArIHRoaXMuX2NvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNTdHJpbmc7XG4gICAgfVxuICAgIHNldCBjb21wb25lbnRzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1N0cmluZyA9PSBudWxsIHx8IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gXCJcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmdbMF0gPT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVsYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb21wb25lbnRTdHJpbmdzID0gdGhpcy5fY29tcG9uZW50c1N0cmluZy5zcGxpdChcIi5cIik7XG4gICAgICAgIGZvciAobGV0IHN0ciBvZiBjb21wb25lbnRTdHJpbmdzKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gbmFtZWQgY29tcG9uZW50cyB0aGF0IHN0YXJ0IHdpdGggYSBudW1iZXIsIGVnIFwiNDJzb21ld2hlcmVcIiwgYW5kIGluZGV4ZWQgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gdGhlIG5vcm1hbCBwYXJzZUludCB3b24ndCBkbyBmb3IgdGhlIGRldGVjdGlvbiBiZWNhdXNlIGl0J3MgdG9vIHJlbGF4ZWQuXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvcGFyc2VJbnRcbiAgICAgICAgICAgIGlmICgvXihcXC18XFwrKT8oWzAtOV0rfEluZmluaXR5KSQvLnRlc3Qoc3RyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgUGF0aC5Db21wb25lbnQocGFyc2VJbnQoc3RyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKG5ldyBQYXRoLkNvbXBvbmVudChzdHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50c1N0cmluZztcbiAgICB9XG4gICAgRXF1YWxzKG90aGVyUGF0aCkge1xuICAgICAgICBpZiAob3RoZXJQYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlclBhdGguX2NvbXBvbmVudHMubGVuZ3RoICE9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJQYXRoLmlzUmVsYXRpdmUgIT0gdGhpcy5pc1JlbGF0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgY29kZSB1c2VzIFNlcXVlbmNlRXF1YWwgaGVyZSwgc28gd2UgbmVlZCB0byBpdGVyYXRlIG92ZXIgdGhlIGNvbXBvbmVudHMgbWFudWFsbHkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3RoZXJQYXRoLl9jb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgLy8gaXQncyBub3QgcXVpdGUgY2xlYXIgd2hldGhlciB0aGlzIHRlc3Qgc2hvdWxkIHVzZSBFcXVhbHMgb3IgYSBzaW1wbGUgPT0gb3BlcmF0b3IsXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3ktbG9oc2UvaW5ranMvaXNzdWVzLzIyXG4gICAgICAgICAgICBpZiAoIW90aGVyUGF0aC5fY29tcG9uZW50c1tpXS5FcXVhbHModGhpcy5fY29tcG9uZW50c1tpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBQYXRoQnlBcHBlbmRpbmdDb21wb25lbnQoYykge1xuICAgICAgICBsZXQgcCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIHAuX2NvbXBvbmVudHMucHVzaC5hcHBseShwLl9jb21wb25lbnRzLCB0aGlzLl9jb21wb25lbnRzKTtcbiAgICAgICAgcC5fY29tcG9uZW50cy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG59XG5leHBvcnRzLlBhdGggPSBQYXRoO1xuUGF0aC5wYXJlbnRJZCA9IFwiXlwiO1xuKGZ1bmN0aW9uIChQYXRoKSB7XG4gICAgY2xhc3MgQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IoaW5kZXhPck5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4T3JOYW1lID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBpbmRleE9yTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXggPSBpbmRleE9yTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNJbmRleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID49IDA7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzUGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PSBQYXRoLnBhcmVudElkO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBUb1BhcmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50KFBhdGgucGFyZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEVxdWFscyhvdGhlckNvbXApIHtcbiAgICAgICAgICAgIGlmIChvdGhlckNvbXAgIT0gbnVsbCAmJiBvdGhlckNvbXAuaXNJbmRleCA9PSB0aGlzLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09IG90aGVyQ29tcC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT0gb3RoZXJDb21wLm5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhdGguQ29tcG9uZW50ID0gQ29tcG9uZW50O1xufSkoUGF0aCA9IGV4cG9ydHMuUGF0aCB8fCAoZXhwb3J0cy5QYXRoID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBhdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvaW50ZXIgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY2xhc3MgUG9pbnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IHRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5jb250ZW50W3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBnZXQgaXNOdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIgPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnBhdGguUGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KG5ldyBQYXRoXzEuUGF0aC5Db21wb25lbnQodGhpcy5pbmRleCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIucGF0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250YWluZXIpXG4gICAgICAgICAgICByZXR1cm4gXCJJbmsgUG9pbnRlciAobnVsbClcIjtcbiAgICAgICAgcmV0dXJuIChcIkluayBQb2ludGVyIC0+IFwiICtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSArXG4gICAgICAgICAgICBcIiAtLSBpbmRleCBcIiArXG4gICAgICAgICAgICB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgLy8gVGhpcyBtZXRob2QgZG9lcyBub3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUsIGJ1dCBpcyBoZXJlIHRvIG1haW50YWluIHRoZVxuICAgIC8vIHZhbHVlIHNlbWFudGljcyBvZiBQb2ludGVyLlxuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnRlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIHN0YXRpYyBTdGFydE9mKGNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIoY29udGFpbmVyLCAwKTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOdWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIobnVsbCwgLTEpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9pbnRlciA9IFBvaW50ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qb2ludGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QdXNoUG9wVHlwZSA9IHZvaWQgMDtcbnZhciBQdXNoUG9wVHlwZTtcbihmdW5jdGlvbiAoUHVzaFBvcFR5cGUpIHtcbiAgICBQdXNoUG9wVHlwZVtQdXNoUG9wVHlwZVtcIlR1bm5lbFwiXSA9IDBdID0gXCJUdW5uZWxcIjtcbiAgICBQdXNoUG9wVHlwZVtQdXNoUG9wVHlwZVtcIkZ1bmN0aW9uXCJdID0gMV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZVwiXSA9IDJdID0gXCJGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZVwiO1xufSkoUHVzaFBvcFR5cGUgPSBleHBvcnRzLlB1c2hQb3BUeXBlIHx8IChleHBvcnRzLlB1c2hQb3BUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVB1c2hQb3AuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlYXJjaFJlc3VsdCA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY2xhc3MgU2VhcmNoUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vYmogPSBudWxsO1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjb3JyZWN0T2JqKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHByb3hpbWF0ZSA/IG51bGwgOiB0aGlzLm9iajtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGhpcy5vYmogOiBudWxsO1xuICAgIH1cbiAgICBjb3B5KCkge1xuICAgICAgICBsZXQgc2VhcmNoUmVzdWx0ID0gbmV3IFNlYXJjaFJlc3VsdCgpO1xuICAgICAgICBzZWFyY2hSZXN1bHQub2JqID0gdGhpcy5vYmo7XG4gICAgICAgIHNlYXJjaFJlc3VsdC5hcHByb3hpbWF0ZSA9IHRoaXMuYXBwcm94aW1hdGU7XG4gICAgICAgIHJldHVybiBzZWFyY2hSZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TZWFyY2hSZXN1bHQgPSBTZWFyY2hSZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWFyY2hSZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZUpzb24gPSB2b2lkIDA7XG5jbGFzcyBTaW1wbGVKc29uIHtcbiAgICBzdGF0aWMgVGV4dFRvRGljdGlvbmFyeSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlSnNvbi5SZWFkZXIodGV4dCkuVG9EaWN0aW9uYXJ5KCk7XG4gICAgfVxuICAgIHN0YXRpYyBUZXh0VG9BcnJheSh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2ltcGxlSnNvbi5SZWFkZXIodGV4dCkuVG9BcnJheSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxlSnNvbiA9IFNpbXBsZUpzb247XG4oZnVuY3Rpb24gKFNpbXBsZUpzb24pIHtcbiAgICBjbGFzcyBSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9yb290T2JqZWN0ID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBUb0RpY3Rpb25hcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBUb0FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RPYmplY3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2ltcGxlSnNvbi5SZWFkZXIgPSBSZWFkZXI7XG4gICAgLy8gSW4gQyMsIHRoaXMgY2xhc3Mgd3JpdGVzIGpzb24gdG9rZW5zIGRpcmVjdGx5IHRvIGEgU3RyaW5nV3JpdGVyIG9yXG4gICAgLy8gYW5vdGhlciBzdHJlYW0uIEhlcmUsIGEgdGVtcG9yYXJ5IGhpZXJhcmNoeSBpcyBjcmVhdGVkIGluIHRoZSBmb3JtXG4gICAgLy8gb2YgYSBqYXZhc2NyaXB0IG9iamVjdCwgd2hpY2ggaXMgc2VyaWFsaXNlZCBpbiB0aGUgYHRvU3RyaW5nYCBtZXRob2QuXG4gICAgLy8gU2VlIGluZGl2aWR1YWwgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICBjbGFzcyBXcml0ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIC8vIEluIGFkZGl0aW9uIHRvIGBfc3RhdGVTdGFja2AgcHJlc2VudCBpbiB0aGUgb3JpZ2luYWwgY29kZSxcbiAgICAgICAgICAgIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gb2YgU2ltcGxlSnNvbiB1c2UgdHdvIG90aGVyIHN0YWNrcyBhbmQgdHdvXG4gICAgICAgICAgICAvLyB0ZW1wb3JhcnkgdmFyaWFibGVzIGhvbGRpbmcgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgICAgIC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBuYW1lIGJlaW5nIGJ1aWx0XG4gICAgICAgICAgICAvLyB3aXRoIGBXcml0ZVByb3BlcnR5TmFtZVN0YXJ0YCwgYFdyaXRlUHJvcGVydHlOYW1lSW5uZXJgIGFuZFxuICAgICAgICAgICAgLy8gYFdyaXRlUHJvcGVydHlOYW1lRW5kYC5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHN0cmluZyB2YWx1ZSBiZWluZyBidWlsdFxuICAgICAgICAgICAgLy8gd2l0aCBgV3JpdGVTdHJpbmdTdGFydGAsIGBXcml0ZVN0cmluZ0lubmVyYCBhbmRcbiAgICAgICAgICAgIC8vIGBXcml0ZVN0cmluZ0VuZGAuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgY29sbGVjdGlvbiBiZWluZyBidWlsdCAoZWl0aGVyIGFuIGFycmF5XG4gICAgICAgICAgICAvLyBvciBhbiBvYmplY3QpLiBGb3IgaW5zdGFuY2UsIGF0IHRoZSAnPycgc3RlcCBkdXJpbmcgdGhlIGhpYXJjaHlcbiAgICAgICAgICAgIC8vIGNyZWF0aW9uLCB0aGlzIGhpZXJhcmNoeTpcbiAgICAgICAgICAgIC8vIFszLCB7YTogW2IsID9dfV0gd2lsbCBoYXZlIHRoaXMgY29ycmVzcG9uZGluZyBzdGFjazpcbiAgICAgICAgICAgIC8vIChib3R0b20pIFtBcnJheSwgT2JqZWN0LCBBcnJheV0gKHRvcClcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBwcm9wZXJ0eSBiZWluZyBhc3NpZ25lZC4gRm9yIGluc3RhbmNlLCBhdFxuICAgICAgICAgICAgLy8gdGhlICc/JyBzdGVwIGR1cmluZyB0aGUgaGlhcmNoeSBjcmVhdGlvbiwgdGhpcyBoaWVyYXJjaHk6XG4gICAgICAgICAgICAvLyBbMywge2E6IFtiLCB7YzogP31dfV0gd2lsbCBoYXZlIHRoaXMgY29ycmVzcG9uZGluZyBzdGFjazpcbiAgICAgICAgICAgIC8vIChib3R0b20pIFthLCBjXSAodG9wKVxuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIE9iamVjdCBjb250YWluaW5nIHRoZSBlbnRpcmUgaGllYXJjaHkuXG4gICAgICAgICAgICB0aGlzLl9qc29uT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZU9iamVjdChpbm5lcikge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBpbm5lcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBuZXcgb2JqZWN0LlxuICAgICAgICBXcml0ZU9iamVjdFN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdCh0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgYXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIG90aGVyIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eU5hbWUgPSB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3Byb3BlcnR5TmFtZV0gPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgY3JlYXRlZCBhcyB0aGUgY2hpbGQgb2YgYW4gYXJyYXkuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIHRoZSByb290IG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc29uT2JqZWN0ID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZU9iamVjdEVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIGEgcHJvcGVydHkgbmFtZSAvIHZhbHVlIHBhaXIgdG8gdGhlIGN1cnJlbnQgb2JqZWN0LlxuICAgICAgICBXcml0ZVByb3BlcnR5KG5hbWUsIGlubmVyT3JDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICBpbm5lcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIHRoaXMuV3JpdGUoY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbnQgYW5kIEZsb2F0IGFyZSBzZXBhcmF0ZSBjYWxscywgc2luY2UgdGhlcmUgYm90aCBhcmVcbiAgICAgICAgLy8gbnVtYmVycyBpbiBKYXZhU2NyaXB0LCBidXQgbmVlZCB0byBiZSBoYW5kbGVkIGRpZmZlcmVudGx5LlxuICAgICAgICBXcml0ZUludFByb3BlcnR5KG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZUludChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlRmxvYXRQcm9wZXJ0eShuYW1lLCBjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVGbG9hdChjb250ZW50KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgYSBuZXcgcHJvcGVydHkgbmFtZSwgd2hpY2ggd2lsbCBiZSB1c2UgdG8gYWRkIHRoZVxuICAgICAgICAvLyBuZXcgb2JqZWN0IHdoZW4gY2FsbGluZyBfYWRkVG9DdXJyZW50T2JqZWN0KCkgZnJvbSBhIFdyaXRlXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlUHJvcGVydHlFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmNoaWxkQ291bnQgPT09IDEpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIGEgbmV3IHByb3BlcnR5IG5hbWUsIGV4Y2VwdCB0aGlzIHRpbWUsIHRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIC8vIHdpbGwgYmUgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIGFsbCB0aGUgc3RyaW5ncyBwYXNzZWQgdG9cbiAgICAgICAgLy8gV3JpdGVQcm9wZXJ0eU5hbWVJbm5lci5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eU5hbWVTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlUHJvcGVydHlOYW1lRW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5TmFtZUlubmVyKHN0cikge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSArPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgbmV3IGFycmF5LlxuICAgICAgICBXcml0ZUFycmF5U3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgbGV0IG5ld09iamVjdCA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyBjcmVhdGVkIGFzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlOYW1lID0gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbltwcm9wZXJ0eU5hbWVdID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgY3JlYXRlZCBhcyB0aGUgY2hpbGQgb2YgYW5vdGhlciBhcnJheS5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB0aGUgcm9vdCBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUFycmF5RW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIHRvIHRoZSBhcHByb3ByaWF0ZSBjb2xsZWN0aW9uIChhcnJheSAvIG9iamVjdCksIGdpdmVuIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIGNvbnRleHQuXG4gICAgICAgIFdyaXRlKHZhbHVlLCBlc2NhcGUgPSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogdHJ5aW5nIHRvIHdyaXRlIGEgbnVsbCBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlSW50KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgaXMgdXNlZCBhcyBhIHByZWNhdXRpb246XG4gICAgICAgICAgICAvLyAgICAgMS4gdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIHdyaXR0ZW4gYXMgYW4gaW50ZWdlclxuICAgICAgICAgICAgLy8gICAgICAgICh3aXRob3V0IGEgZnJhY3Rpb25hbCBwYXJ0IC0+IDEgaW5zdGVhZCBvZiAxLjApLCBldmVuXG4gICAgICAgICAgICAvLyAgICAgICAgdGhvdWdoIGl0IHNob3VsZCBiZSB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2ZcbiAgICAgICAgICAgIC8vICAgICAgICBKU09OLnNlcmlhbGl6ZTtcbiAgICAgICAgICAgIC8vICAgICAyLiB0byBlbnN1cmUgdGhhdCBpZiBhIGZsb2F0aW5nIG51bWJlciBpcyBwYXNzZWRcbiAgICAgICAgICAgIC8vICAgICAgICBhY2NpZGVudGFsbHksIGl0J3MgY29udmVydGVkIHRvIGFuIGludGVnZXIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHNhdmVnYW1lIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdChNYXRoLmZsb29yKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgSlNPTiBkb2Vzbid0IHN1cHBvcnQgTmFOIGFuZCBJbmZpbml0eSwgdGhlc2UgdmFsdWVzXG4gICAgICAgIC8vIGFyZSBjb252ZXJ0ZWQgaGVyZS5cbiAgICAgICAgV3JpdGVGbG9hdCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDMuNGUzOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoLTMuNGUzOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoMC4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVOdWxsKCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBhIHN0cmluZyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gaW5cbiAgICAgICAgLy8gV3JpdGVTdHJpbmdFbmQoKS4gVGhlIHN0cmluZyB3aWxsIGJlIGEgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGhlXG4gICAgICAgIC8vIHN0cmluZ3MgcGFzc2VkIHRvIFdyaXRlU3RyaW5nSW5uZXIuXG4gICAgICAgIFdyaXRlU3RyaW5nU3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVTdHJpbmdFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHRoaXMuX2N1cnJlbnRTdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVTdHJpbmdJbm5lcihzdHIsIGVzY2FwZSA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZyk7XG4gICAgICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlcmlhbGlzZSB0aGUgcm9vdCBvYmplY3QgaW50byBhIEpTT04gc3RyaW5nLlxuICAgICAgICBUb1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9qc29uT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbk9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgc3RhdGUgc3RhY2sgd2hlbiBhZGRpbmcgbmV3IG9iamVjdHMgLyB2YWx1ZXMuXG4gICAgICAgIFN0YXJ0TmV3T2JqZWN0KGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmUgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jaGlsZENvdW50ID09PSAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlc2UgZ2V0dGVycyBwZWVrIGFsbCB0aGUgZGlmZmVyZW50IHN0YWNrcy5cbiAgICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoIC0gMV0udHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjaGlsZENvdW50KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoIC0gMV0uY2hpbGRDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjdXJyZW50Q29sbGVjdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uU3RhY2tbdGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGN1cnJlbnRQcm9wZXJ0eU5hbWUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFja1t0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEluY3JlbWVudENoaWxkQ291bnQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApO1xuICAgICAgICAgICAgbGV0IGN1cnJFbCA9IHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjdXJyRWwuY2hpbGRDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKGN1cnJFbCk7XG4gICAgICAgIH1cbiAgICAgICAgQXNzZXJ0KGNvbmRpdGlvbikge1xuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJBc3NlcnQgZmFpbGVkIHdoaWxlIHdyaXRpbmcgSlNPTlwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGlzIG1ldGhvZCBkaWQgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLiBJdCBhZGRzXG4gICAgICAgIC8vIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgY3VycmVudCBjb2xsZWN0aW9uICh1c2VkIGJ5IFdyaXRlIG1ldGhvZHMpLlxuICAgICAgICBfYWRkVG9DdXJyZW50T2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KEFycmF5LmlzQXJyYXkodGhpcy5jdXJyZW50Q29sbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KCFBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb25bdGhpcy5jdXJyZW50UHJvcGVydHlOYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFNpbXBsZUpzb24uV3JpdGVyID0gV3JpdGVyO1xuICAgIChmdW5jdGlvbiAoV3JpdGVyKSB7XG4gICAgICAgIGxldCBTdGF0ZTtcbiAgICAgICAgKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiT2JqZWN0XCJdID0gMV0gPSBcIk9iamVjdFwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJBcnJheVwiXSA9IDJdID0gXCJBcnJheVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJQcm9wZXJ0eVwiXSA9IDNdID0gXCJQcm9wZXJ0eVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJQcm9wZXJ0eU5hbWVcIl0gPSA0XSA9IFwiUHJvcGVydHlOYW1lXCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlN0cmluZ1wiXSA9IDVdID0gXCJTdHJpbmdcIjtcbiAgICAgICAgfSkoU3RhdGUgPSBXcml0ZXIuU3RhdGUgfHwgKFdyaXRlci5TdGF0ZSA9IHt9KSk7XG4gICAgICAgIGNsYXNzIFN0YXRlRWxlbWVudCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVyLlN0YXRlRWxlbWVudCA9IFN0YXRlRWxlbWVudDtcbiAgICB9KShXcml0ZXIgPSBTaW1wbGVKc29uLldyaXRlciB8fCAoU2ltcGxlSnNvbi5Xcml0ZXIgPSB7fSkpO1xufSkoU2ltcGxlSnNvbiA9IGV4cG9ydHMuU2ltcGxlSnNvbiB8fCAoZXhwb3J0cy5TaW1wbGVKc29uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNpbXBsZUpzb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXRlUGF0Y2ggPSB2b2lkIDA7XG5jbGFzcyBTdGF0ZVBhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBhcmd1bWVudHNbMF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB0b0NvcHkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxzID0gbmV3IE1hcCh0b0NvcHkuX2dsb2JhbHMpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQodG9Db3B5Ll9jaGFuZ2VkVmFyaWFibGVzKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCh0b0NvcHkuX3Zpc2l0Q291bnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCh0b0NvcHkuX3R1cm5JbmRpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2xvYmFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbHM7XG4gICAgfVxuICAgIGdldCBjaGFuZ2VkVmFyaWFibGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlcztcbiAgICB9XG4gICAgZ2V0IHZpc2l0Q291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgfVxuICAgIGdldCB0dXJuSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgIH1cbiAgICBUcnlHZXRHbG9iYWwobmFtZSwgLyogb3V0ICovIHZhbHVlKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsICYmIHRoaXMuX2dsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX2dsb2JhbHMuZ2V0KG5hbWUpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFNldEdsb2JhbChuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9nbG9iYWxzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIEFkZENoYW5nZWRWYXJpYWJsZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzLmFkZChuYW1lKTtcbiAgICB9XG4gICAgVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIC8qIG91dCAqLyBjb3VudCkge1xuICAgICAgICBpZiAodGhpcy5fdmlzaXRDb3VudHMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fdmlzaXRDb3VudHMuZ2V0KGNvbnRhaW5lciksIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogY291bnQsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgU2V0VmlzaXRDb3VudChjb250YWluZXIsIGNvdW50KSB7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXIsIGNvdW50KTtcbiAgICB9XG4gICAgU2V0VHVybkluZGV4KGNvbnRhaW5lciwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMuc2V0KGNvbnRhaW5lciwgaW5kZXgpO1xuICAgIH1cbiAgICBUcnlHZXRUdXJuSW5kZXgoY29udGFpbmVyLCAvKiBvdXQgKi8gaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R1cm5JbmRpY2VzLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX3R1cm5JbmRpY2VzLmdldChjb250YWluZXIpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGluZGV4LCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0ZVBhdGNoID0gU3RhdGVQYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YXRlUGF0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3B3YXRjaCA9IHZvaWQgMDtcbi8vIFRoaXMgaXMgc2ltcGxlIHJlcGxhY2VtZW50IG9mIHRoZSBTdG9wd2F0Y2ggY2xhc3MgZnJvbSB0aGUgLk5FVCBGcmFtZXdvcmsuXG4vLyBUaGUgb3JpZ2luYWwgY2xhc3MgY2FuIGNvdW50IHRpbWUgd2l0aCBtdWNoIG1vcmUgYWNjdXJhY3kgdGhhbiB0aGUgSmF2YXNjcmlwdCB2ZXJzaW9uLlxuLy8gSXQgbWlnaHQgYmUgd29ydGggY29uc2lkZXJpbmcgdXNpbmcgYHdpbmRvdy5wZXJmb3JtYW5jZWAgaW4gdGhlIGJyb3dzZXJcbi8vIG9yIGBwcm9jZXNzLmhydGltZSgpYCBpbiBub2RlLlxuY2xhc3MgU3RvcHdhdGNoIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBFbGFwc2VkTWlsbGlzZWNvbmRzKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3RhcnRUaW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuICAgIFN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcHdhdGNoID0gU3RvcHdhdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcFdhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yeSA9IHZvaWQgMDtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBTdG9yeVN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdG9yeVN0YXRlXCIpO1xuY29uc3QgQ29udHJvbENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xDb21tYW5kXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IENob2ljZVBvaW50XzEgPSByZXF1aXJlKFwiLi9DaG9pY2VQb2ludFwiKTtcbmNvbnN0IENob2ljZV8xID0gcmVxdWlyZShcIi4vQ2hvaWNlXCIpO1xuY29uc3QgRGl2ZXJ0XzEgPSByZXF1aXJlKFwiLi9EaXZlcnRcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgVmFyaWFibGVBc3NpZ25tZW50XzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZUFzc2lnbm1lbnRcIik7XG5jb25zdCBWYXJpYWJsZVJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVSZWZlcmVuY2VcIik7XG5jb25zdCBOYXRpdmVGdW5jdGlvbkNhbGxfMSA9IHJlcXVpcmUoXCIuL05hdGl2ZUZ1bmN0aW9uQ2FsbFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFBSTkdfMSA9IHJlcXVpcmUoXCIuL1BSTkdcIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25zT3JpZ2luXzEgPSByZXF1aXJlKFwiLi9MaXN0RGVmaW5pdGlvbnNPcmlnaW5cIik7XG5jb25zdCBTdG9wV2F0Y2hfMSA9IHJlcXVpcmUoXCIuL1N0b3BXYXRjaFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTaW1wbGVKc29uXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVKc29uXCIpO1xudmFyIElua0xpc3RfMiA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbmtMaXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbmtMaXN0XzIuSW5rTGlzdDsgfSB9KTtcbmlmICghTnVtYmVyLmlzSW50ZWdlcikge1xuICAgIE51bWJlci5pc0ludGVnZXIgPSBmdW5jdGlvbiBpc0ludGVnZXIoblZhbCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBuVmFsID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBpc0Zpbml0ZShuVmFsKSAmJlxuICAgICAgICAgICAgblZhbCA+IC05MDA3MTk5MjU0NzQwOTkyICYmXG4gICAgICAgICAgICBuVmFsIDwgOTAwNzE5OTI1NDc0MDk5MiAmJlxuICAgICAgICAgICAgTWF0aC5mbG9vcihuVmFsKSA9PT0gblZhbCk7XG4gICAgfTtcbn1cbmNsYXNzIFN0b3J5IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbmtWZXJzaW9uTWluaW11bUNvbXBhdGlibGUgPSAxODtcbiAgICAgICAgdGhpcy5fcHJldkNvbnRhaW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fYXN5bmNTYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvZmlsZXIgPSBudWxsOyAvLyBUT0RPOiBQcm9maWxlclxuICAgICAgICAvLyBEaXNjcmltaW5hdGlvbiBiZXR3ZWVuIGNvbnN0cnVjdG9yc1xuICAgICAgICBsZXQgY29udGVudENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGxpc3RzID0gbnVsbDtcbiAgICAgICAgbGV0IGpzb24gPSBudWxsO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250ZW50Q29udGFpbmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBsaXN0cyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLS0tLSBTdG9yeSAoQ29udGFpbmVyIGNvbnRlbnRDb250YWluZXIsIExpc3Q8UnVudGltZS5MaXN0RGVmaW5pdGlvbj4gbGlzdHMgPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIgPSBjb250ZW50Q29udGFpbmVyO1xuICAgICAgICAgICAgLy8gLS0tLS0tXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGxldCBqc29uU3RyaW5nID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGpzb24gPSBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5UZXh0VG9EaWN0aW9uYXJ5KGpzb25TdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAganNvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0gU3RvcnkgKENvbnRhaW5lciBjb250ZW50Q29udGFpbmVyLCBMaXN0PFJ1bnRpbWUuTGlzdERlZmluaXRpb24+IGxpc3RzID0gbnVsbClcbiAgICAgICAgaWYgKGxpc3RzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9saXN0RGVmaW5pdGlvbnMgPSBuZXcgTGlzdERlZmluaXRpb25zT3JpZ2luXzEuTGlzdERlZmluaXRpb25zT3JpZ2luKGxpc3RzKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyAtLS0tLS1cbiAgICAgICAgLy8gLS0tLS0tIFN0b3J5KHN0cmluZyBqc29uU3RyaW5nKSA6IHRoaXMoKENvbnRhaW5lciludWxsKVxuICAgICAgICBpZiAoanNvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHJvb3RPYmplY3QgPSBqc29uO1xuICAgICAgICAgICAgbGV0IHZlcnNpb25PYmogPSByb290T2JqZWN0W1wiaW5rVmVyc2lvblwiXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uT2JqID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5rIHZlcnNpb24gbnVtYmVyIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIGl0J3MgYSB2YWxpZCAuaW5rLmpzb24gZmlsZT9cIik7XG4gICAgICAgICAgICBsZXQgZm9ybWF0RnJvbUZpbGUgPSBwYXJzZUludCh2ZXJzaW9uT2JqKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXRGcm9tRmlsZSA+IFN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSB3YXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXRGcm9tRmlsZSA8IHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBpcyB0b28gb2xkIHRvIGJlIGxvYWRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGVuZ2luZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdEZyb21GaWxlICE9IFN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiV0FSTklORzogVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBkb2Vzbid0IG1hdGNoIGN1cnJlbnQgdmVyc2lvbiBvZiBlbmdpbmUuIE5vbi1jcml0aWNhbCwgYnV0IHJlY29tbWVuZCBzeW5jaHJvbmlzaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByb290VG9rZW4gPSByb290T2JqZWN0W1wicm9vdFwiXTtcbiAgICAgICAgICAgIGlmIChyb290VG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb290IG5vZGUgZm9yIGluayBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpO1xuICAgICAgICAgICAgbGV0IGxpc3REZWZzT2JqO1xuICAgICAgICAgICAgaWYgKChsaXN0RGVmc09iaiA9IHJvb3RPYmplY3RbXCJsaXN0RGVmc1wiXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0RGVmaW5pdGlvbnMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpUb2tlblRvTGlzdERlZmluaXRpb25zKGxpc3REZWZzT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub1J1bnRpbWVPYmplY3Qocm9vdFRva2VuKSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuUmVzZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLVxuICAgIH1cbiAgICBnZXQgY3VycmVudENob2ljZXMoKSB7XG4gICAgICAgIGxldCBjaG9pY2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBpZiAoIWMuaXNJbnZpc2libGVEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgYy5pbmRleCA9IGNob2ljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNob2ljZXMucHVzaChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUZXh0KCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUZXh0IHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50VGV4dDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUYWdzKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUYWdzIHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50VGFncztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRFcnJvcnM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50V2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRXYXJuaW5ncztcbiAgICB9XG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXNFcnJvcjtcbiAgICB9XG4gICAgZ2V0IGhhc1dhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhc1dhcm5pbmc7XG4gICAgfVxuICAgIGdldCB2YXJpYWJsZXNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGU7XG4gICAgfVxuICAgIGdldCBsaXN0RGVmaW5pdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0RGVmaW5pdGlvbnM7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvLyBUT0RPOiBJbXBsZW1lbnQgUHJvZmlsZXJcbiAgICBTdGFydFByb2ZpbGluZygpIHtcbiAgICAgICAgLyogKi9cbiAgICB9XG4gICAgRW5kUHJvZmlsaW5nKCkge1xuICAgICAgICAvKiAqL1xuICAgIH1cbiAgICAvLyBNZXJnZSB0b2dldGhlciBgcHVibGljIHN0cmluZyBUb0pzb24oKWAgYW5kIGB2b2lkIFRvSnNvbihTaW1wbGVKc29uLldyaXRlciB3cml0ZXIpYC5cbiAgICAvLyBXaWxsIG9ubHkgcmV0dXJuIGEgdmFsdWUgaWYgd3JpdGVyIHdhcyBub3QgcHJvdmlkZWQuXG4gICAgVG9Kc29uKHdyaXRlcikge1xuICAgICAgICBsZXQgc2hvdWxkUmV0dXJuID0gZmFsc2U7XG4gICAgICAgIGlmICghd3JpdGVyKSB7XG4gICAgICAgICAgICBzaG91bGRSZXR1cm4gPSB0cnVlO1xuICAgICAgICAgICAgd3JpdGVyID0gbmV3IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLldyaXRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rVmVyc2lvblwiLCBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicm9vdFwiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZVJ1bnRpbWVDb250YWluZXIodywgdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIpKTtcbiAgICAgICAgaWYgKHRoaXMuX2xpc3REZWZpbml0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdERlZnNcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVmIG9mIHRoaXMuX2xpc3REZWZpbml0aW9ucy5saXN0cykge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoZGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRlZi5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KGl0ZW0uaXRlbU5hbWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIGlmIChzaG91bGRSZXR1cm4pXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyLlRvU3RyaW5nKCk7XG4gICAgfVxuICAgIFJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0U3RhdGVcIik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IFN0b3J5U3RhdGVfMS5TdG9yeVN0YXRlKHRoaXMpO1xuICAgICAgICB0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5PYnNlcnZlVmFyaWFibGVDaGFuZ2UodGhpcy5WYXJpYWJsZVN0YXRlRGlkQ2hhbmdlRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuUmVzZXRHbG9iYWxzKCk7XG4gICAgfVxuICAgIFJlc2V0RXJyb3JzKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRFcnJvcnMoKTtcbiAgICB9XG4gICAgUmVzZXRDYWxsc3RhY2soKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0Q2FsbHN0YWNrXCIpO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGUuRm9yY2VFbmQoKTtcbiAgICB9XG4gICAgUmVzZXRHbG9iYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldChcImdsb2JhbCBkZWNsXCIpKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxQb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLkNob29zZVBhdGgobmV3IFBhdGhfMS5QYXRoKFwiZ2xvYmFsIGRlY2xcIiksIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuQ29udGludWVJbnRlcm5hbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IG9yaWdpbmFsUG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLlNuYXBzaG90RGVmYXVsdEdsb2JhbHMoKTtcbiAgICB9XG4gICAgQ29udGludWUoKSB7XG4gICAgICAgIHRoaXMuQ29udGludWVBc3luYygwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRleHQ7XG4gICAgfVxuICAgIGdldCBjYW5Db250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY2FuQ29udGludWU7XG4gICAgfVxuICAgIGdldCBhc3luY0NvbnRpbnVlQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZTtcbiAgICB9XG4gICAgQ29udGludWVBc3luYyhtaWxsaXNlY3NMaW1pdEFzeW5jKSB7XG4gICAgICAgIGlmICghdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzKVxuICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKTtcbiAgICAgICAgdGhpcy5Db250aW51ZUludGVybmFsKG1pbGxpc2Vjc0xpbWl0QXN5bmMpO1xuICAgIH1cbiAgICBDb250aW51ZUludGVybmFsKG1pbGxpc2Vjc0xpbWl0QXN5bmMgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlQ29udGludWUoKTtcbiAgICAgICAgbGV0IGlzQXN5bmNUaW1lTGltaXRlZCA9IG1pbGxpc2Vjc0xpbWl0QXN5bmMgPiAwO1xuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50Kys7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSA9IGlzQXN5bmNUaW1lTGltaXRlZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuJ3QgY29udGludWUgLSBzaG91bGQgY2hlY2sgY2FuQ29udGludWUgYmVmb3JlIGNhbGxpbmcgQ29udGludWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5kaWRTYWZlRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID09IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkdXJhdGlvblN0b3B3YXRjaCA9IG5ldyBTdG9wV2F0Y2hfMS5TdG9wd2F0Y2goKTtcbiAgICAgICAgZHVyYXRpb25TdG9wd2F0Y2guU3RhcnQoKTtcbiAgICAgICAgbGV0IG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lID0gdGhpcy5Db250aW51ZVNpbmdsZVN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24pKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoZS5tZXNzYWdlLCB1bmRlZmluZWQsIGUudXNlRW5kTGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlICYmXG4gICAgICAgICAgICAgICAgZHVyYXRpb25TdG9wd2F0Y2guRWxhcHNlZE1pbGxpc2Vjb25kcyA+IG1pbGxpc2Vjc0xpbWl0QXN5bmMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5Db250aW51ZSk7XG4gICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLlN0b3AoKTtcbiAgICAgICAgaWYgKG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgfHwgIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuUmVzdG9yZVN0YXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJUaHJlYWQgYXZhaWxhYmxlIHRvIHBvcCwgdGhyZWFkcyBzaG91bGQgYWx3YXlzIGJlIGZsYXQgYnkgdGhlIGVuZCBvZiBldmFsdWF0aW9uP1wiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aCA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLmRpZFNhZmVFeGl0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICctPi0+JyB0byByZXR1cm4gZnJvbSBhIHR1bm5lbD9cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICd+IHJldHVybic/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInJhbiBvdXQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4gRE9ORScgb3IgJy0+IEVORCc/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQgZm9yIHVua25vd24gcmVhc29uLiBQbGVhc2UgZGVidWcgY29tcGlsZXIhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50ID09IDEpXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50LS07XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUG9zdENvbnRpbnVlKCk7XG4gICAgfVxuICAgIENvbnRpbnVlU2luZ2xlU3RlcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5QcmVTdGVwKCk7XG4gICAgICAgIHRoaXMuU3RlcCgpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RTdGVwKCk7XG4gICAgICAgIGlmICghdGhpcy5jYW5Db250aW51ZSAmJiAhdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhpcy5UcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5QcmVTbmFwc2hvdCgpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuaW5TdHJpbmdFdmFsdWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZUF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRUYWdzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5zdGF0ZS5jdXJyZW50VGFnc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNoYW5nZSA9IHRoaXMuQ2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUZXh0LCB0aGlzLnN0YXRlLmN1cnJlbnRUZXh0LCB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGFncy5sZW5ndGgsIHRoaXMuc3RhdGUuY3VycmVudFRhZ3MubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlID09IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2UgPT0gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5EaXNjYXJkU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlN0YXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRGlzY2FyZFNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUG9zdFNuYXBzaG90KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHByZXZUZXh0LCBjdXJyVGV4dCwgcHJldlRhZ0NvdW50LCBjdXJyVGFnQ291bnQpIHtcbiAgICAgICAgaWYgKHByZXZUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInByZXZUZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyVGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjdXJyVGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3bGluZVN0aWxsRXhpc3RzID0gY3VyclRleHQubGVuZ3RoID49IHByZXZUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgY3VyclRleHQuY2hhckF0KHByZXZUZXh0Lmxlbmd0aCAtIDEpID09IFwiXFxuXCI7XG4gICAgICAgIGlmIChwcmV2VGFnQ291bnQgPT0gY3VyclRhZ0NvdW50ICYmXG4gICAgICAgICAgICBwcmV2VGV4dC5sZW5ndGggPT0gY3VyclRleHQubGVuZ3RoICYmXG4gICAgICAgICAgICBuZXdsaW5lU3RpbGxFeGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2U7XG4gICAgICAgIGlmICghbmV3bGluZVN0aWxsRXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJUYWdDb3VudCA+IHByZXZUYWdDb3VudClcbiAgICAgICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmU7XG4gICAgICAgIGZvciAobGV0IGkgPSBwcmV2VGV4dC5sZW5ndGg7IGkgPCBjdXJyVGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMgPSBjdXJyVGV4dC5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyAhPSBcIiBcIiAmJiBjICE9IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5Ob0NoYW5nZTtcbiAgICB9XG4gICAgQ29udGludWVNYXhpbWFsbHkoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIkNvbnRpbnVlTWF4aW1hbGx5XCIpO1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0aGlzLkNvbnRpbnVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBDb250ZW50QXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICB9XG4gICAgS25vdENvbnRhaW5lcldpdGhOYW1lKG5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWVkQ29udGFpbmVyID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAobmFtZWRDb250YWluZXIgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpXG4gICAgICAgICAgICByZXR1cm4gbmFtZWRDb250YWluZXI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBQb2ludGVyQXRQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09IDApXG4gICAgICAgICAgICByZXR1cm4gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgbGV0IHAgPSBuZXcgUG9pbnRlcl8xLlBvaW50ZXIoKTtcbiAgICAgICAgbGV0IHBhdGhMZW5ndGhUb1VzZSA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKHBhdGgubGFzdENvbXBvbmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwYXRoLmxhc3RDb21wb25lbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGFzdENvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICBwYXRoTGVuZ3RoVG9Vc2UgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCwgdW5kZWZpbmVkLCBwYXRoTGVuZ3RoVG9Vc2UpO1xuICAgICAgICAgICAgcC5jb250YWluZXIgPSByZXN1bHQuY29udGFpbmVyO1xuICAgICAgICAgICAgcC5pbmRleCA9IHBhdGgubGFzdENvbXBvbmVudC5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgICAgIHAuY29udGFpbmVyID0gcmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHAuaW5kZXggPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lm9iaiA9PSBudWxsIHx8XG4gICAgICAgICAgICAocmVzdWx0Lm9iaiA9PSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyICYmIHBhdGhMZW5ndGhUb1VzZSA+IDApKSB7XG4gICAgICAgICAgICB0aGlzLkVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY29udGVudCBhdCBwYXRoICdcIiArXG4gICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgXCInLCBhbmQgbm8gYXBwcm94aW1hdGlvbiBvZiBpdCB3YXMgcG9zc2libGUuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5hcHByb3hpbWF0ZSlcbiAgICAgICAgICAgIHRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIgK1xuICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgIFwiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0bzogJ1wiICtcbiAgICAgICAgICAgICAgICByZXN1bHQub2JqLnBhdGggK1xuICAgICAgICAgICAgICAgIFwiJy5cIik7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBTdGF0ZVNuYXBzaG90KCkge1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCk7XG4gICAgfVxuICAgIFJlc3RvcmVTdGF0ZVNuYXBzaG90KCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJfc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuUmVzdG9yZUFmdGVyUGF0Y2goKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jU2F2aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRGlzY2FyZFNuYXBzaG90KCkge1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jU2F2aW5nKVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IG51bGw7XG4gICAgfVxuICAgIENvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJzdGFydCBzYXZpbmcgb24gYSBiYWNrZ3JvdW5kIHRocmVhZFwiKTtcbiAgICAgICAgaWYgKHRoaXMuX2FzeW5jU2F2aW5nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RvcnkgaXMgYWxyZWFkeSBpbiBiYWNrZ3JvdW5kIHNhdmluZyBtb2RlLCBjYW4ndCBjYWxsIENvcHlTdGF0ZUZvckJhY2tncm91bmRUaHJlYWRTYXZlIGFnYWluIVwiKTtcbiAgICAgICAgbGV0IHN0YXRlVG9TYXZlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fc3RhdGUuQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKTtcbiAgICAgICAgdGhpcy5fYXN5bmNTYXZpbmcgPSB0cnVlO1xuICAgICAgICByZXR1cm4gc3RhdGVUb1NhdmU7XG4gICAgfVxuICAgIEJhY2tncm91bmRTYXZlQ29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFN0ZXAoKSB7XG4gICAgICAgIGxldCBzaG91bGRBZGRUb1N0cmVhbSA9IHRydWU7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRhaW5lciBjb250YWluZXJUb0VudGVyID0gcG9pbnRlci5SZXNvbHZlICgpIGFzIENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGNvbnRhaW5lclRvRW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5SZXNvbHZlKCksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIHdoaWxlIChjb250YWluZXJUb0VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLlZpc2l0Q29udGFpbmVyKGNvbnRhaW5lclRvRW50ZXIsIHRydWUpO1xuICAgICAgICAgICAgLy8gTm8gY29udGVudD8gdGhlIG1vc3Qgd2UgY2FuIGRvIGlzIHN0ZXAgcGFzdCBpdFxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lclRvRW50ZXIuY29udGVudC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoY29udGFpbmVyVG9FbnRlcik7XG4gICAgICAgICAgICAvLyBjb250YWluZXJUb0VudGVyID0gcG9pbnRlci5SZXNvbHZlKCkgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgY29udGFpbmVyVG9FbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb2ludGVyLlJlc29sdmUoKSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuU3RlcCh0aGlzLnN0YXRlLmNhbGxTdGFjayk7XG4gICAgICAgIC8vIElzIHRoZSBjdXJyZW50IGNvbnRlbnQgb2JqZWN0OlxuICAgICAgICAvLyAgLSBOb3JtYWwgY29udGVudFxuICAgICAgICAvLyAgLSBPciBhIGxvZ2ljL2Zsb3cgc3RhdGVtZW50IC0gaWYgc28sIGRvIGl0XG4gICAgICAgIC8vIFN0b3AgZmxvdyBpZiB3ZSBoaXQgYSBzdGFjayBwb3Agd2hlbiB3ZSdyZSB1bmFibGUgdG8gcG9wIChlLmcuIHJldHVybi9kb25lIHN0YXRlbWVudCBpbiBrbm90XG4gICAgICAgIC8vIHRoYXQgd2FzIGRpdmVydGVkIHRvIHJhdGhlciB0aGFuIGNhbGxlZCBhcyBhIGZ1bmN0aW9uKVxuICAgICAgICBsZXQgY3VycmVudENvbnRlbnRPYmogPSBwb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgbGV0IGlzTG9naWNPckZsb3dDb250cm9sID0gdGhpcy5QZXJmb3JtTG9naWNBbmRGbG93Q29udHJvbChjdXJyZW50Q29udGVudE9iaik7XG4gICAgICAgIC8vIEhhcyBmbG93IGJlZW4gZm9yY2VkIHRvIGVuZCBieSBmbG93IGNvbnRyb2wgYWJvdmU/XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xvZ2ljT3JGbG93Q29udHJvbCkge1xuICAgICAgICAgICAgc2hvdWxkQWRkVG9TdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaG9pY2Ugd2l0aCBjb25kaXRpb24/XG4gICAgICAgIC8vIHZhciBjaG9pY2VQb2ludCA9IGN1cnJlbnRDb250ZW50T2JqIGFzIENob2ljZVBvaW50O1xuICAgICAgICBsZXQgY2hvaWNlUG9pbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIENob2ljZVBvaW50XzEuQ2hvaWNlUG9pbnQpO1xuICAgICAgICBpZiAoY2hvaWNlUG9pbnQpIHtcbiAgICAgICAgICAgIGxldCBjaG9pY2UgPSB0aGlzLlByb2Nlc3NDaG9pY2UoY2hvaWNlUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGNob2ljZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5wdXNoKGNob2ljZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Q29udGVudE9iaiA9IG51bGw7XG4gICAgICAgICAgICBzaG91bGRBZGRUb1N0cmVhbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjb250YWluZXIgaGFzIG5vIGNvbnRlbnQsIHRoZW4gaXQgd2lsbCBiZVxuICAgICAgICAvLyB0aGUgXCJjb250ZW50XCIgaXRzZWxmLCBidXQgd2Ugc2tpcCBvdmVyIGl0LlxuICAgICAgICBpZiAoY3VycmVudENvbnRlbnRPYmogaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIHNob3VsZEFkZFRvU3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udGVudCB0byBhZGQgdG8gZXZhbHVhdGlvbiBzdGFjayBvciB0aGUgb3V0cHV0IHN0cmVhbVxuICAgICAgICBpZiAoc2hvdWxkQWRkVG9TdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHB1c2hpbmcgYSB2YXJpYWJsZSBwb2ludGVyIG9udG8gdGhlIGV2YWx1YXRpb24gc3RhY2ssIGVuc3VyZSB0aGF0IGl0J3Mgc3BlY2lmaWNcbiAgICAgICAgICAgIC8vIHRvIG91ciBjdXJyZW50IChwb3NzaWJseSB0ZW1wb3JhcnkpIGNvbnRleHQgaW5kZXguIEFuZCBtYWtlIGEgY29weSBvZiB0aGUgcG9pbnRlclxuICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSdyZSBub3QgZWRpdGluZyB0aGUgb3JpZ2luYWwgcnVudGltZSBvYmplY3QuXG4gICAgICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IGN1cnJlbnRDb250ZW50T2JqIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhclBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhclBvaW50ZXIgJiYgdmFyUG9pbnRlci5jb250ZXh0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgbmV3IG9iamVjdCBzbyB3ZSdyZSBub3Qgb3ZlcndyaXRpbmcgdGhlIHN0b3J5J3Mgb3duIGRhdGFcbiAgICAgICAgICAgICAgICBsZXQgY29udGV4dElkeCA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNvbnRleHRGb3JWYXJpYWJsZU5hbWVkKHZhclBvaW50ZXIudmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGVudE9iaiA9IG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHZhclBvaW50ZXIudmFyaWFibGVOYW1lLCBjb250ZXh0SWR4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cHJlc3Npb24gZXZhbHVhdGlvbiBjb250ZW50XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGN1cnJlbnRDb250ZW50T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE91dHB1dCBzdHJlYW0gY29udGVudCAoaS5lLiBub3QgZXhwcmVzc2lvbiBldmFsdWF0aW9uKVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oY3VycmVudENvbnRlbnRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUgY29udGVudCBwb2ludGVyLCBmb2xsb3dpbmcgZGl2ZXJ0cyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGhpcy5OZXh0Q29udGVudCgpO1xuICAgICAgICAvLyBTdGFydGluZyBhIHRocmVhZCBzaG91bGQgYmUgZG9uZSBhZnRlciB0aGUgaW5jcmVtZW50IHRvIHRoZSBjb250ZW50IHBvaW50ZXIsXG4gICAgICAgIC8vIHNvIHRoYXQgd2hlbiByZXR1cm5pbmcgZnJvbSB0aGUgdGhyZWFkLCBpdCByZXR1cm5zIHRvIHRoZSBjb250ZW50IGFmdGVyIHRoaXMgaW5zdHJ1Y3Rpb24uXG4gICAgICAgIC8vIHZhciBjb250cm9sQ21kID0gY3VycmVudENvbnRlbnRPYmogYXMgO1xuICAgICAgICBsZXQgY29udHJvbENtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGVudE9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgIGlmIChjb250cm9sQ21kICYmXG4gICAgICAgICAgICBjb250cm9sQ21kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2hUaHJlYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaXNpdENvbnRhaW5lcihjb250YWluZXIsIGF0U3RhcnQpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIuY291bnRpbmdBdFN0YXJ0T25seSB8fCBhdFN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnZpc2l0c1Nob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLkluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpIHtcbiAgICAgICAgbGV0IHByZXZpb3VzUG9pbnRlciA9IHRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNOdWxsIHx8IHBvaW50ZXIuaW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmICghcHJldmlvdXNQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgLy8gQ29udGFpbmVyIHByZXZBbmNlc3RvciA9IHByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCkgYXMgQ29udGFpbmVyID8/IHByZXZpb3VzUG9pbnRlci5jb250YWluZXIgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkUHJldmlvdXNBbmNlc3RvciA9IHByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICBsZXQgcHJldkFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHJlc29sdmVkUHJldmlvdXNBbmNlc3RvciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB8fFxuICAgICAgICAgICAgICAgIFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwcmV2aW91c1BvaW50ZXIuY29udGFpbmVyLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgd2hpbGUgKHByZXZBbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzLnB1c2gocHJldkFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBwcmV2QW5jZXN0b3IgPSBwcmV2QW5jZXN0b3IucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBwcmV2QW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocHJldkFuY2VzdG9yLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudENoaWxkT2ZDb250YWluZXIgPSBwb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIENvbnRhaW5lciBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRDb250YWluZXJBbmNlc3RvciAmJlxuICAgICAgICAgICAgKHRoaXMuX3ByZXZDb250YWluZXJzLmluZGV4T2YoY3VycmVudENvbnRhaW5lckFuY2VzdG9yKSA8IDAgfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY291bnRpbmdBdFN0YXJ0T25seSkpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhpcyBhbmNlc3RvciBjb250YWluZXIgaXMgYmVpbmcgZW50ZXJlZCBhdCB0aGUgc3RhcnQsXG4gICAgICAgICAgICAvLyBieSBjaGVja2luZyB3aGV0aGVyIHRoZSBjaGlsZCBvYmplY3QgaXMgdGhlIGZpcnN0LlxuICAgICAgICAgICAgbGV0IGVudGVyaW5nQXRTdGFydCA9IGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5jb250ZW50Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9PSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY29udGVudFswXTtcbiAgICAgICAgICAgIC8vIE1hcmsgYSB2aXNpdCB0byB0aGlzIGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5WaXNpdENvbnRhaW5lcihjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IsIGVudGVyaW5nQXRTdGFydCk7XG4gICAgICAgICAgICBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9IGN1cnJlbnRDb250YWluZXJBbmNlc3RvcjtcbiAgICAgICAgICAgIC8vIGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUHJvY2Vzc0Nob2ljZShjaG9pY2VQb2ludCkge1xuICAgICAgICBsZXQgc2hvd0Nob2ljZSA9IHRydWU7XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBjaG9pY2UgaWYgY2hvaWNlIHBvaW50IGRvZXNuJ3QgcGFzcyBjb25kaXRpb25hbFxuICAgICAgICBpZiAoY2hvaWNlUG9pbnQuaGFzQ29uZGl0aW9uKSB7XG4gICAgICAgICAgICBsZXQgY29uZGl0aW9uVmFsdWUgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLklzVHJ1dGh5KGNvbmRpdGlvblZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHNob3dDaG9pY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRUZXh0ID0gXCJcIjtcbiAgICAgICAgbGV0IGNob2ljZU9ubHlUZXh0ID0gXCJcIjtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc0Nob2ljZU9ubHlDb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgY2hvaWNlT25seVN0clZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGxldCBjaG9pY2VPbmx5U3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBjaG9pY2VPbmx5VGV4dCA9IGNob2ljZU9ubHlTdHJWYWwudmFsdWUgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlUG9pbnQuaGFzU3RhcnRDb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgc3RhcnRTdHJWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBsZXQgc3RhcnRTdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIHN0YXJ0VGV4dCA9IHN0YXJ0U3RyVmFsLnZhbHVlIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGNob2ljZSBpZiBwbGF5ZXIgaGFzIGFscmVhZHkgcmVhZCB0aGlzIGNvbnRlbnRcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lm9uY2VPbmx5KSB7XG4gICAgICAgICAgICBsZXQgdmlzaXRDb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjaG9pY2VQb2ludC5jaG9pY2VUYXJnZXQpO1xuICAgICAgICAgICAgaWYgKHZpc2l0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Nob2ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGdvIHRocm91Z2ggdGhlIGZ1bGwgcHJvY2VzcyBvZiBjcmVhdGluZyB0aGUgY2hvaWNlIGFib3ZlIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgY29uc3VtZSB0aGUgY29udGVudCBmb3IgaXQsIHNpbmNlIG90aGVyd2lzZSBpdCdsbFxuICAgICAgICAvLyBiZSBzaG93biBvbiB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgaWYgKCFzaG93Q2hvaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hvaWNlID0gbmV3IENob2ljZV8xLkNob2ljZSgpO1xuICAgICAgICBjaG9pY2UudGFyZ2V0UGF0aCA9IGNob2ljZVBvaW50LnBhdGhPbkNob2ljZTtcbiAgICAgICAgY2hvaWNlLnNvdXJjZVBhdGggPSBjaG9pY2VQb2ludC5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGNob2ljZS5pc0ludmlzaWJsZURlZmF1bHQgPSBjaG9pY2VQb2ludC5pc0ludmlzaWJsZURlZmF1bHQ7XG4gICAgICAgIGNob2ljZS50aHJlYWRBdEdlbmVyYXRpb24gPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5Gb3JrVGhyZWFkKCk7XG4gICAgICAgIGNob2ljZS50ZXh0ID0gKHN0YXJ0VGV4dCArIGNob2ljZU9ubHlUZXh0KS5yZXBsYWNlKC9eWyBcXHRdK3xbIFxcdF0rJC9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICB9XG4gICAgSXNUcnV0aHkob2JqKSB7XG4gICAgICAgIGxldCB0cnV0aHkgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuVmFsdWUpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBvYmo7XG4gICAgICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXZUYXJnZXQgPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlNob3VsZG4ndCB1c2UgYSBkaXZlcnQgdGFyZ2V0ICh0byBcIiArXG4gICAgICAgICAgICAgICAgICAgIGRpdlRhcmdldC50YXJnZXRQYXRoICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIGFzIGEgY29uZGl0aW9uYWwgdmFsdWUuIERpZCB5b3UgaW50ZW5kIGEgZnVuY3Rpb24gY2FsbCAnbGlrZVRoaXMoKScgb3IgYSByZWFkIGNvdW50IGNoZWNrICdsaWtlVGhpcyc/IChubyBhcnJvd3MpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWwuaXNUcnV0aHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydXRoeTtcbiAgICB9XG4gICAgUGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2woY29udGVudE9iaikge1xuICAgICAgICBpZiAoY29udGVudE9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGl2ZXJ0XG4gICAgICAgIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgRGl2ZXJ0XzEuRGl2ZXJ0KSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudERpdmVydCA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBpZiAoY3VycmVudERpdmVydC5pc0NvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmRpdGlvblZhbHVlID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAvLyBGYWxzZSBjb25kaXRpb25hbD8gQ2FuY2VsIGRpdmVydFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5Jc1RydXRoeShjb25kaXRpb25WYWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFyTmFtZSA9IGN1cnJlbnREaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgICAgIGxldCB2YXJDb250ZW50cyA9IHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyQ29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiVHJpZWQgdG8gZGl2ZXJ0IHVzaW5nIGEgdGFyZ2V0IGZyb20gYSB2YXJpYWJsZSB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZCAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCEodmFyQ29udGVudHMgaW5zdGFuY2VvZiBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgaW50Q29udGVudCA9IHZhckNvbnRlbnRzIGFzIEludFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50Q29udGVudCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YXJDb250ZW50cywgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlRyaWVkIHRvIGRpdmVydCB0byBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUsIGJ1dCB0aGUgdmFyaWFibGUgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpIGRpZG4ndCBjb250YWluIGEgZGl2ZXJ0IHRhcmdldCwgaXQgXCI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRDb250ZW50IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSAmJiBpbnRDb250ZW50LnZhbHVlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBcIndhcyBlbXB0eS9udWxsICh0aGUgdmFsdWUgMCkuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gXCJjb250YWluZWQgJ1wiICsgdmFyQ29udGVudHMgKyBcIicuXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFyQ29udGVudHMsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5Qb2ludGVyQXRQYXRoKHRhcmdldC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnREaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuQ2FsbEV4dGVybmFsRnVuY3Rpb24oY3VycmVudERpdmVydC50YXJnZXRQYXRoU3RyaW5nLCBjdXJyZW50RGl2ZXJ0LmV4dGVybmFsQXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IGN1cnJlbnREaXZlcnQudGFyZ2V0UG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudERpdmVydC5wdXNoZXNUb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChjdXJyZW50RGl2ZXJ0LnN0YWNrUHVzaFR5cGUsIHVuZGVmaW5lZCwgdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwgJiYgIWN1cnJlbnREaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0ICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXZlcnQuZGVidWdNZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJEaXZlcnQgdGFyZ2V0IGRvZXNuJ3QgZXhpc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXZlcnQuZGVidWdNZXRhZGF0YS5zb3VyY2VOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJEaXZlcnQgcmVzb2x1dGlvbiBmYWlsZWQ6IFwiICsgY3VycmVudERpdmVydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RhcnQvZW5kIGFuIGV4cHJlc3Npb24gZXZhbHVhdGlvbj8gT3IgcHJpbnQgb3V0IHRoZSByZXN1bHQ/XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKSB7XG4gICAgICAgICAgICBsZXQgZXZhbENvbW1hbmQgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgc3dpdGNoIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsU3RhcnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gZmFsc2UsIFwiQWxyZWFkeSBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24/XCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbEVuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID09PSB0cnVlLCBcIk5vdCBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24gbW9kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsT3V0cHV0OlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXhwcmVzc2lvbiB0dXJuZWQgb3V0IHRvIGJlIGVtcHR5LCB0aGVyZSBtYXkgbm90IGJlIGFueXRoaW5nIG9uIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbnMgbWF5IGV2YWx1YXRlIHRvIFZvaWQsIGluIHdoaWNoIGNhc2Ugd2Ugc2tpcCBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG91dHB1dCBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSByZWFsbHkgYWx3YXlzIGJsYW5rZXQgY29udmVydCB0byBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQgd291bGQgYmUgb2theSB0byBoYXZlIG51bWJlcnMgaW4gdGhlIG91dHB1dCBzdHJlYW0gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBwcm9ibGVtIGlzIHdoZW4gZXhwb3J0aW5nIHRleHQgZm9yIHZpZXdpbmcsIGl0IHNraXBzIG92ZXIgbnVtYmVycyBldGMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRleHQgPSBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShvdXRwdXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vT3A6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayh0aGlzLnN0YXRlLlBlZWtFdmFsdWF0aW9uU3RhY2soKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BUdW5uZWw6XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3BUeXBlID0gZXZhbENvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIDogUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcHBlZCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IHBvcHBlZCBhcyBEaXZlcnRUYXJnZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvcHBlZCwgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChwb3BwZWQgaW5zdGFuY2VvZiBWb2lkXzEuVm9pZCwgXCJFeHBlY3RlZCB2b2lkIGlmIC0+LT4gZG9lc24ndCBvdmVycmlkZSB0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgIT0gcG9wVHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuc2V0KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbiwgXCJmdW5jdGlvbiByZXR1cm4gc3RhdGVtZW50ICh+IHJldHVybilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5zZXQoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCwgXCJ0dW5uZWwgb253YXJkcyBzdGF0ZW1lbnQgKC0+LT4pXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV4cGVjdGVkID0gbmFtZXMuZ2V0KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZCA9IFwiZW5kIG9mIGZsb3cgKC0+IEVORCBvciBjaG9pY2UpXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNc2cgPSBcIkZvdW5kIFwiICsgbmFtZXMuZ2V0KHBvcFR5cGUpICsgXCIsIHdoZW4gZXhwZWN0ZWQgXCIgKyBleHBlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IHRoaXMuUG9pbnRlckF0UGF0aChvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGV2YWxDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID09PSB0cnVlLCBcIkV4cGVjdGVkIHRvIGJlIGluIGFuIGV4cHJlc3Npb24gd2hlbiBldmFsdWF0aW5nIGEgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZFN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnRTdGFja0ZvclN0cmluZyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0Q291bnRDb25zdW1lZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0Q291bnRDb25zdW1lZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGNvbW1hbmQgPSBvYmogYXMgQ29udHJvbENvbW1hbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFN0YWNrRm9yU3RyaW5nLnB1c2gob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdW1lIHRoZSBjb250ZW50IHRoYXQgd2FzIHByb2R1Y2VkIGZvciB0aGlzIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcEZyb21PdXRwdXRTdHJlYW0ob3V0cHV0Q291bnRDb25zdW1lZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBDIyB2ZXJzaW9uIHVzZXMgYSBTdGFjayBmb3IgY29udGVudFN0YWNrRm9yU3RyaW5nLCBidXQgd2UncmVcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYSBzaW1wbGUgYXJyYXksIHNvIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdCBiZWZvcmUgdXNpbmcgaXRcbiAgICAgICAgICAgICAgICAgICAgY29udGVudFN0YWNrRm9yU3RyaW5nID0gY29udGVudFN0YWNrRm9yU3RyaW5nLnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVpbGQgc3RyaW5nIG91dCBvZiB0aGUgY29udGVudCB3ZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGMgb2YgY29udGVudFN0YWNrRm9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoYy50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdG8gZXhwcmVzc2lvbiBldmFsdWF0aW9uIChmcm9tIGNvbnRlbnQgbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHNiLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50OlxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hvaWNlQ291bnQgPSB0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY2hvaWNlQ291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUodGhpcy5zdGF0ZS5jdXJyZW50VHVybkluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZTpcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50OlxuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHRyYU5vdGUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFOb3RlID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSByZWFkIGNvdW50ICgna25vdF9uYW1lJykgaW5zdGVhZCBvZiBhIHRhcmdldCAoJy0+IGtub3RfbmFtZScpP1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlRVUk5TX1NJTkNFIC8gUkVBRF9DT1VOVCBleHBlY3RlZCBhIGRpdmVydCB0YXJnZXQgKGtub3QsIHN0aXRjaCwgbGFiZWwgbmFtZSksIGJ1dCBzYXcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFOb3RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBkaXZlcnRUYXJnZXQgPSB0YXJnZXQgYXMgRGl2ZXJ0VGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXZlcnRUYXJnZXQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0YXJnZXQsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgY29udGFpbmVyID0gQ29udGVudEF0UGF0aCAoZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgpLmNvcnJlY3RPYmogYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuQ29udGVudEF0UGF0aChkaXZlcnRUYXJnZXQudGFyZ2V0UGF0aCkuY29ycmVjdE9iaiwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVpdGhlckNvdW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSB0aGlzLnN0YXRlLlR1cm5zU2luY2VGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuV2FybmluZyhcIkZhaWxlZCB0byBmaW5kIGNvbnRhaW5lciBmb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2YWxDb21tYW5kLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGxvb2t1cCBhdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGVpdGhlckNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SYW5kb206IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heEludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkludCA9PSBudWxsIHx8IG1pbkludCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtaW5pbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SW50ID09IG51bGwgfHwgbWluSW50IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG1heGltdW0gcGFyYW1ldGVyIG9mIFJBTkRPTShtaW4sIG1heClcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhJbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWF4SW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5JbnQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWluSW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21SYW5nZSA9IG1heEludC52YWx1ZSAtIG1pbkludC52YWx1ZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5kb21SYW5nZSA8PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlJBTkRPTSB3YXMgY2FsbGVkIHdpdGggbWluaW11bSBhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluSW50LnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBhbmQgbWF4aW11bSBhcyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4SW50LnZhbHVlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4gVGhlIG1heGltdW0gbXVzdCBiZSBsYXJnZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRTZWVkID0gdGhpcy5zdGF0ZS5zdG9yeVNlZWQgKyB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tID0gbmV3IFBSTkdfMS5QUk5HKHJlc3VsdFNlZWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFJhbmRvbSA9IHJhbmRvbS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaG9zZW5WYWx1ZSA9IChuZXh0UmFuZG9tICUgcmFuZG9tUmFuZ2UpICsgbWluSW50LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY2hvc2VuVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV4dCByYW5kb20gbnVtYmVyIChyYXRoZXIgdGhhbiBrZWVwaW5nIHRoZSBSYW5kb20gb2JqZWN0IGFyb3VuZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSA9IG5leHRSYW5kb207XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVkID09IG51bGwgfHwgc2VlZCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBTRUVEX1JBTkRPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWluSW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RvcnlTZWVkID0gc2VlZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVm9pZF8xLlZvaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5WaXNpdEluZGV4OlxuICAgICAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXIpIC0gMTsgLy8gaW5kZXggbm90IGNvdW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShjb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXg6XG4gICAgICAgICAgICAgICAgICAgIGxldCBzaHVmZmxlSW5kZXggPSB0aGlzLk5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoc2h1ZmZsZUluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlZCBpbiBtYWluIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkRvbmU6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIG1heSBleGlzdCBpbiB0aGUgY29udGV4dCBvZiB0aGUgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAvLyBhY3Qgb2YgY3JlYXRpbmcgdGhlIHRocmVhZCwgb3IgaW4gdGhlIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZhbHVhdGluZyB0aGUgY29udGVudC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gbm9ybWFsIGZsb3cgLSBhbGxvdyBzYWZlIGV4aXQgd2l0aG91dCB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIGZsb3cgaW4gY3VycmVudCB0aHJlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIC8vIEZvcmNlIGZsb3cgdG8gZW5kIGNvbXBsZXRlbHlcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLkZvcmNlRW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludDpcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGludFZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBJbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGxpc3ROYW1lVmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdE5hbWVWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludFZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJQYXNzZWQgbm9uLWludGVnZXIgd2hlbiBjcmVhdGluZyBhIGxpc3QgZWxlbWVudCBmcm9tIGEgbnVtZXJpY2FsIHZhbHVlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZ2VuZXJhdGVkTGlzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGlzdERlZmluaXRpb25zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMubGlzdERlZmluaXRpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZExpc3REZWYgPSB0aGlzLmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihsaXN0TmFtZVZhbC52YWx1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZExpc3REZWYuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEl0ZW0gPSBmb3VuZExpc3REZWYucmVzdWx0LlRyeUdldEl0ZW1XaXRoVmFsdWUoaW50VmFsLnZhbHVlLCBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRJdGVtLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZExpc3RWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShmb3VuZEl0ZW0ucmVzdWx0LCBpbnRWYWwudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJGYWlsZWQgdG8gZmluZCBMSVNUIGNhbGxlZCBcIiArIGxpc3ROYW1lVmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTGlzdFZhbHVlID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRMaXN0VmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGdlbmVyYXRlZExpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZ2U6XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXggPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW4gPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciB0YXJnZXRMaXN0ID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIExpc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldExpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGlzdCA9PT0gbnVsbCB8fCBtaW4gPT09IG51bGwgfHwgbWF4ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBsaXN0LCBtaW5pbXVtIGFuZCBtYXhpbXVtIGZvciBMSVNUX1JBTkdFXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0TGlzdC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0YXJnZXRMaXN0LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0YXJnZXRMaXN0LnZhbHVlLkxpc3RXaXRoU3ViUmFuZ2UobWluLnZhbHVlT2JqZWN0LCBtYXgudmFsdWVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbToge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdFZhbCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0VmFsID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBsaXN0IGZvciBMSVNUX1JBTkRPTVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBsaXN0VmFsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3TGlzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdC5Db3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBpbmRleCBmb3IgdGhlIGVsZW1lbnQgdG8gdGFrZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFNlZWQgPSB0aGlzLnN0YXRlLnN0b3J5U2VlZCArIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb207XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tID0gbmV3IFBSTkdfMS5QUk5HKHJlc3VsdFNlZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRSYW5kb20gPSByYW5kb20ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RJdGVtSW5kZXggPSBuZXh0UmFuZG9tICUgbGlzdC5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYml0IGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQyMgY29kZSwgc2luY2UgaXRlcmF0b3JzIGRvIG5vdCB3b3JrIGluIHRoZSBzYW1lIHdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0LCB3ZSBpdGVyYXRlIGxpc3RJdGVtSW5kZXggLSAxIHRpbWVzLCBjYWxsaW5nIG5leHQoKS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsaXN0SXRlbUluZGV4LXRoIHRpbWUgaXMgbWFkZSBvdXRzaWRlIG9mIHRoZSBsb29wLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgdG8gcmV0cmlldmUgdGhlIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RFbnVtZXJhdG9yID0gbGlzdC5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsaXN0SXRlbUluZGV4IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEVudW1lcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbGlzdEVudW1lcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgS2V5OiBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkodmFsdWVbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZhbHVlOiB2YWx1ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW4gbGlzdCBpcyBzaW1wbHkgdGhlIG9yaWdpbiBvZiB0aGUgb25lIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdChyYW5kb21JdGVtLktleS5vcmlnaW5OYW1lLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QuQWRkKHJhbmRvbUl0ZW0uS2V5LCByYW5kb21JdGVtLlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSBuZXh0UmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5MaXN0VmFsdWUobmV3TGlzdCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcInVuaGFuZGxlZCBDb250cm9sQ29tbWFuZDogXCIgKyBldmFsQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFyaWFibGUgYXNzaWdubWVudFxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBsZXQgdmFyQXNzID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGxldCBhc3NpZ25lZFZhbCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkFzc2lnbih2YXJBc3MsIGFzc2lnbmVkVmFsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgbGV0IHZhclJlZiA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgZm91bmRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdCByZWFkIGNvdW50IHZhbHVlXG4gICAgICAgICAgICBpZiAodmFyUmVmLnBhdGhGb3JDb3VudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHZhclJlZi5jb250YWluZXJGb3JDb3VudDtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBmb3VuZFZhbHVlID0gbmV3IFZhbHVlXzEuSW50VmFsdWUoY291bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsIHZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJSZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJWYXJpYWJsZSBub3QgZm91bmQ6ICdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJSZWYubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIicuIFVzaW5nIGRlZmF1bHQgdmFsdWUgb2YgMCAoZmFsc2UpLiBUaGlzIGNhbiBoYXBwZW4gd2l0aCB0ZW1wb3JhcnkgdmFyaWFibGVzIGlmIHRoZSBkZWNsYXJhdGlvbiBoYXNuJ3QgeWV0IGJlZW4gaGl0LiBHbG9iYWxzIGFyZSBhbHdheXMgZ2l2ZW4gYSBkZWZhdWx0IHZhbHVlIG9uIGxvYWQgaWYgYSB2YWx1ZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzYXZlIHN0YXRlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkludFZhbHVlKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhmb3VuZFZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5hdGl2ZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGxldCBmdW5jID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGxldCBmdW5jUGFyYW1zID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soZnVuYy5udW1iZXJPZlBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGZ1bmMuQ2FsbChmdW5jUGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhyZXN1bHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gY29udHJvbCBjb250ZW50LCBtdXN0IGJlIG9yZGluYXJ5IGNvbnRlbnRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDaG9vc2VQYXRoU3RyaW5nKHBhdGgsIHJlc2V0Q2FsbHN0YWNrID0gdHJ1ZSwgYXJncyA9IFtdKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgQ2hvb3NlUGF0aFN0cmluZyByaWdodCBub3dcIik7XG4gICAgICAgIGlmIChyZXNldENhbGxzdGFjaykge1xuICAgICAgICAgICAgdGhpcy5SZXNldENhbGxzdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bmNEZXRhaWwgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAuY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jRGV0YWlsID0gXCIoXCIgKyBjb250YWluZXIucGF0aC50b1N0cmluZygpICsgXCIpIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9yeSB3YXMgcnVubmluZyBhIGZ1bmN0aW9uIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY0RldGFpbCArXG4gICAgICAgICAgICAgICAgICAgIFwid2hlbiB5b3UgY2FsbGVkIENob29zZVBhdGhTdHJpbmcoXCIgK1xuICAgICAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIC0gdGhpcyBpcyBhbG1vc3QgY2VydGFpbmx5IG5vdCBub3Qgd2hhdCB5b3Ugd2FudCEgRnVsbCBzdGFjayB0cmFjZTogXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soYXJncyk7XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChuZXcgUGF0aF8xLlBhdGgocGF0aCkpO1xuICAgIH1cbiAgICBJZkFzeW5jV2VDYW50KGFjdGl2aXR5U3RyKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgXCIgK1xuICAgICAgICAgICAgICAgIGFjdGl2aXR5U3RyICtcbiAgICAgICAgICAgICAgICBcIi4gU3RvcnkgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIENvbnRpbnVlQXN5bmMoKS4gTWFrZSBtb3JlIENvbnRpbnVlQXN5bmMoKSBjYWxscyBvciBhIHNpbmdsZSBDb250aW51ZSgpIGNhbGwgYmVmb3JlaGFuZC5cIik7XG4gICAgfVxuICAgIENob29zZVBhdGgocCwgaW5jcmVtZW50aW5nVHVybkluZGV4ID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0YXRlLlNldENob3NlblBhdGgocCwgaW5jcmVtZW50aW5nVHVybkluZGV4KTtcbiAgICAgICAgLy8gVGFrZSBhIG5vdGUgb2YgbmV3bHkgdmlzaXRlZCBjb250YWluZXJzIGZvciByZWFkIGNvdW50cyBldGNcbiAgICAgICAgdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKTtcbiAgICB9XG4gICAgQ2hvb3NlQ2hvaWNlSW5kZXgoY2hvaWNlSWR4KSB7XG4gICAgICAgIGNob2ljZUlkeCA9IGNob2ljZUlkeDtcbiAgICAgICAgbGV0IGNob2ljZXMgPSB0aGlzLmN1cnJlbnRDaG9pY2VzO1xuICAgICAgICB0aGlzLkFzc2VydChjaG9pY2VJZHggPj0gMCAmJiBjaG9pY2VJZHggPCBjaG9pY2VzLmxlbmd0aCwgXCJjaG9pY2Ugb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgY2hvaWNlVG9DaG9vc2UgPSBjaG9pY2VzW2Nob2ljZUlkeF07XG4gICAgICAgIGlmIChjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZCA9IGNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvbjtcbiAgICAgICAgdGhpcy5DaG9vc2VQYXRoKGNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBIYXNGdW5jdGlvbihmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jdGlvbk5hbWUpICE9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFdmFsdWF0ZUZ1bmN0aW9uKGZ1bmN0aW9uTmFtZSwgYXJncyA9IFtdLCByZXR1cm5UZXh0T3V0cHV0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gRXZhbHVhdGVGdW5jdGlvbiBiZWhhdmVzIHNsaWdodGx5IGRpZmZlcmVudGx5IHRoYW4gdGhlIEMjIHZlcnNpb24uXG4gICAgICAgIC8vIEluIEMjLCB5b3UgY2FuIHBhc3MgYSAoc2Vjb25kKSBwYXJhbWV0ZXIgYG91dCB0ZXh0T3V0cHV0YCB0byBnZXQgdGhlXG4gICAgICAgIC8vIHRleHQgb3V0cHV0dGVkIGJ5IHRoZSBmdW5jdGlvbi4gVGhpcyBpcyBub3QgcG9zc2libGUgaW4ganMuIEluc3RlYWQsXG4gICAgICAgIC8vIHdlIG1haW50YWluIHRoZSByZWd1bGFyIHNpZ25hdHVyZSAoZnVuY3Rpb25OYW1lLCBhcmdzKSwgcGx1cyBhblxuICAgICAgICAvLyBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIgcmV0dXJuVGV4dE91dHB1dC4gSWYgc2V0IHRvIHRydWUsIHdlIHdpbGxcbiAgICAgICAgLy8gcmV0dXJuIGJvdGggdGhlIHRleHRPdXRwdXQgYW5kIHRoZSByZXR1cm5lZCB2YWx1ZSwgYXMgYW4gb2JqZWN0LlxuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJldmFsdWF0ZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlzIG51bGxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZnVuY3Rpb25OYW1lID09IFwiXCIgfHwgZnVuY3Rpb25OYW1lLnRyaW0oKSA9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBlbXB0eSBvciB3aGl0ZSBzcGFjZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmNDb250YWluZXIgPSB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jdGlvbk5hbWUpO1xuICAgICAgICBpZiAoZnVuY0NvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBkb2Vzbid0IGV4aXN0OiAnXCIgKyBmdW5jdGlvbk5hbWUgKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dHB1dFN0cmVhbUJlZm9yZSA9IFtdO1xuICAgICAgICBvdXRwdXRTdHJlYW1CZWZvcmUucHVzaC5hcHBseShvdXRwdXRTdHJlYW1CZWZvcmUsIHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5TdGFydEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKGZ1bmNDb250YWluZXIsIGFyZ3MpO1xuICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgZnVuY3Rpb24sIGFuZCBjb2xsZWN0IHRoZSBzdHJpbmcgb3V0cHV0XG4gICAgICAgIGxldCBzdHJpbmdPdXRwdXQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgIHN0cmluZ091dHB1dC5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dE91dHB1dCA9IHN0cmluZ091dHB1dC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5SZXNldE91dHB1dChvdXRwdXRTdHJlYW1CZWZvcmUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zdGF0ZS5Db21wbGV0ZUZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCk7XG4gICAgICAgIHJldHVybiByZXR1cm5UZXh0T3V0cHV0ID8geyByZXR1cm5lZDogcmVzdWx0LCBvdXRwdXQ6IHRleHRPdXRwdXQgfSA6IHJlc3VsdDtcbiAgICB9XG4gICAgRXZhbHVhdGVFeHByZXNzaW9uKGV4cHJDb250YWluZXIpIHtcbiAgICAgICAgbGV0IHN0YXJ0Q2FsbFN0YWNrSGVpZ2h0ID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID0gZXhwckNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5zdGF0ZS5Hb1RvU3RhcnQoKTtcbiAgICAgICAgbGV0IGV2YWxTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgICAgdGhpcy5Db250aW51ZSgpO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgLy8gU2hvdWxkIGhhdmUgZmFsbGVuIG9mZiB0aGUgZW5kIG9mIHRoZSBDb250YWluZXIsIHdoaWNoIHNob3VsZFxuICAgICAgICAvLyBoYXZlIGF1dG8tcG9wcGVkLCBidXQganVzdCBpbiBjYXNlIHdlIGRpZG4ndCBmb3Igc29tZSByZWFzb24sXG4gICAgICAgIC8vIG1hbnVhbGx5IHBvcCB0byByZXN0b3JlIHRoZSBzdGF0ZSAoaW5jbHVkaW5nIGN1cnJlbnRQYXRoKS5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aCA+IHN0YXJ0Q2FsbFN0YWNrSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlBvcENhbGxTdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmRTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aDtcbiAgICAgICAgaWYgKGVuZFN0YWNrSGVpZ2h0ID4gZXZhbFN0YWNrSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lLCBudW1iZXJPZkFyZ3VtZW50cykge1xuICAgICAgICBpZiAoZnVuY05hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZnVuY05hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bmMgPSB0aGlzLl9leHRlcm5hbHMuZ2V0KGZ1bmNOYW1lKTtcbiAgICAgICAgbGV0IGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgPSBudWxsO1xuICAgICAgICBsZXQgZm91bmRFeHRlcm5hbCA9IHR5cGVvZiBmdW5jICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICAvLyBUcnkgdG8gdXNlIGZhbGxiYWNrIGZ1bmN0aW9uP1xuICAgICAgICBpZiAoIWZvdW5kRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgPSB0aGlzLktub3RDb250YWluZXJXaXRoTmFtZShmdW5jTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lciAhPT0gbnVsbCwgXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQsIGFuZCBmYWxsYmFjayBpbmsgZnVuY3Rpb24gY291bGQgbm90IGJlIGZvdW5kLlwiKTtcbiAgICAgICAgICAgICAgICAvLyBEaXZlcnQgZGlyZWN0IGludG8gZmFsbGJhY2sgZnVuY3Rpb24gYW5kIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbiwgdW5kZWZpbmVkLCB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChmYWxzZSwgXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQgKGFuZCBpbmsgZmFsbGJhY2tzIGRpc2FibGVkKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUG9wIGFyZ3VtZW50c1xuICAgICAgICBsZXQgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQXJndW1lbnRzOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHZhciBwb3BwZWRPYmogPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgVmFsdWU7XG4gICAgICAgICAgICBsZXQgcG9wcGVkT2JqID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBsZXQgdmFsdWVPYmogPSBwb3BwZWRPYmoudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICBhcmdzLnB1c2godmFsdWVPYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldmVyc2UgYXJndW1lbnRzIGZyb20gdGhlIG9yZGVyIHRoZXkgd2VyZSBwb3BwZWQsXG4gICAgICAgIC8vIHNvIHRoZXkncmUgdGhlIHJpZ2h0IHdheSByb3VuZCBhZ2Fpbi5cbiAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIC8vIFJ1biB0aGUgZnVuY3Rpb24hXG4gICAgICAgIGxldCBmdW5jUmVzdWx0ID0gZnVuYyhhcmdzKTtcbiAgICAgICAgLy8gQ29udmVydCByZXR1cm4gdmFsdWUgKGlmIGFueSkgdG8gdGhlIGEgdHlwZSB0aGF0IHRoZSBpbmsgZW5naW5lIGNhbiB1c2VcbiAgICAgICAgbGV0IHJldHVybk9iaiA9IG51bGw7XG4gICAgICAgIGlmIChmdW5jUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybk9iaiA9IFZhbHVlXzEuVmFsdWUuQ3JlYXRlKGZ1bmNSZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQocmV0dXJuT2JqICE9PSBudWxsLCBcIkNvdWxkIG5vdCBjcmVhdGUgaW5rIHZhbHVlIGZyb20gcmV0dXJuZWQgb2JqZWN0IG9mIHR5cGUgXCIgK1xuICAgICAgICAgICAgICAgIHR5cGVvZiBmdW5jUmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybk9iaiA9IG5ldyBWb2lkXzEuVm9pZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhyZXR1cm5PYmopO1xuICAgIH1cbiAgICBCaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiYmluZCBhbiBleHRlcm5hbCBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5Bc3NlcnQoIXRoaXMuX2V4dGVybmFscy5oYXMoZnVuY05hbWUpLCBcIkZ1bmN0aW9uICdcIiArIGZ1bmNOYW1lICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXCIpO1xuICAgICAgICB0aGlzLl9leHRlcm5hbHMuc2V0KGZ1bmNOYW1lLCBmdW5jKTtcbiAgICB9XG4gICAgVHJ5Q29lcmNlKHZhbHVlKSB7XG4gICAgICAgIC8vIFdlJ3JlIHNraXBwaW5nIHR5cGUgY29lcmNpdGlvbiBpbiB0aGlzIGltcGxlbWVudGF0aW9uLiBGaXJzdCBvZiwganNcbiAgICAgICAgLy8gaXMgbG9vc2VseSB0eXBlZCwgc28gaXQncyBub3QgdGhhdCBpbXBvcnRhbnQuIFNlY29uZGx5LCB0aGVyZSBpcyBub1xuICAgICAgICAvLyBjbGVhbiB3YXkgKEFGQUlLKSBmb3IgdGhlIHVzZXIgdG8gZGVzY3JpYmUgd2hhdCB0eXBlIG9mIHBhcmFtZXRlcnNcbiAgICAgICAgLy8gdGhleSBleHBlY3QuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgQmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUsIGZ1bmMpIHtcbiAgICAgICAgdGhpcy5Bc3NlcnQoZnVuYyAhPSBudWxsLCBcIkNhbid0IGJpbmQgYSBudWxsIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChmdW5jTmFtZSwgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KGFyZ3MubGVuZ3RoID49IGZ1bmMubGVuZ3RoLCBcIkV4dGVybmFsIGZ1bmN0aW9uIGV4cGVjdGVkIFwiICsgZnVuYy5sZW5ndGggKyBcIiBhcmd1bWVudHNcIik7XG4gICAgICAgICAgICBsZXQgY29lcmNlZEFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gYXJncy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2VyY2VkQXJnc1tpXSA9IHRoaXMuVHJ5Q29lcmNlKGFyZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgY29lcmNlZEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgVW5iaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJ1bmJpbmQgYW4gZXh0ZXJuYWwgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fZXh0ZXJuYWxzLmhhcyhmdW5jTmFtZSksIFwiRnVuY3Rpb24gJ1wiICsgZnVuY05hbWUgKyBcIicgaGFzIG5vdCBiZWVuIGJvdW5kLlwiKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzLmRlbGV0ZShmdW5jTmFtZSk7XG4gICAgfVxuICAgIFZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncygpIHtcbiAgICAgICAgbGV0IGMgPSBudWxsO1xuICAgICAgICBsZXQgbyA9IG51bGw7XG4gICAgICAgIGxldCBtaXNzaW5nRXh0ZXJuYWxzID0gYXJndW1lbnRzWzFdIHx8IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgYyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0XzEuSW5rT2JqZWN0KSB7XG4gICAgICAgICAgICBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSBudWxsICYmIG8gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLCBtaXNzaW5nRXh0ZXJuYWxzKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICAvLyBObyBwcm9ibGVtISBWYWxpZGF0aW9uIGNvbXBsZXRlXG4gICAgICAgICAgICBpZiAobWlzc2luZ0V4dGVybmFscy5zaXplID09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkVycm9yOiBNaXNzaW5nIGZ1bmN0aW9uIGJpbmRpbmcgZm9yIGV4dGVybmFsXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBtaXNzaW5nRXh0ZXJuYWxzLnNpemUgPiAxID8gXCJzXCIgOiBcIlwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCI6ICdcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IEFycmF5LmZyb20obWlzc2luZ0V4dGVybmFscykuam9pbihcIicsICdcIik7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIicgXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSB0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICA/IFwiLCBhbmQgbm8gZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGZvdW5kLlwiXG4gICAgICAgICAgICAgICAgICAgIDogXCIgKGluayBmYWxsYmFja3MgZGlzYWJsZWQpXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5FcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlubmVyQ29udGVudCBvZiBjLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgPT0gbnVsbCB8fCAhY29udGFpbmVyLmhhc1ZhbGlkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoaW5uZXJDb250ZW50LCBtaXNzaW5nRXh0ZXJuYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiBjLm5hbWVkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZSwgT2JqZWN0XzEuSW5rT2JqZWN0KSwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobyAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG8sIERpdmVydF8xLkRpdmVydCk7XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0ICYmIGRpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBkaXZlcnQudGFyZ2V0UGF0aFN0cmluZztcbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZXh0ZXJuYWxzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmYWxsYmFja0ZvdW5kID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuaGFzKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmYWxsYmFja0ZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0V4dGVybmFscy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nRXh0ZXJuYWxzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZlVmFyaWFibGUodmFyaWFibGVOYW1lLCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJvYnNlcnZlIGEgbmV3IHZhcmlhYmxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodmFyaWFibGVOYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IG9ic2VydmUgdmFyaWFibGUgJ1wiICtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWUgK1xuICAgICAgICAgICAgICAgIFwiJyBiZWNhdXNlIGl0IHdhc24ndCBkZWNsYXJlZCBpbiB0aGUgaW5rIHN0b3J5LlwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyh2YXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodmFyaWFibGVOYW1lKS5wdXNoKG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLnNldCh2YXJpYWJsZU5hbWUsIFtvYnNlcnZlcl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9ic2VydmVWYXJpYWJsZXModmFyaWFibGVOYW1lcywgb2JzZXJ2ZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdmFyaWFibGVOYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuT2JzZXJ2ZVZhcmlhYmxlKHZhcmlhYmxlTmFtZXNbaV0sIG9ic2VydmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVtb3ZlVmFyaWFibGVPYnNlcnZlcihvYnNlcnZlciwgc3BlY2lmaWNWYXJpYWJsZU5hbWUpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwicmVtb3ZlIGEgdmFyaWFibGUgb2JzZXJ2ZXJcIik7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHR5cGVvZiBzcGVjaWZpY1ZhcmlhYmxlTmFtZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmhhcyhzcGVjaWZpY1ZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHNwZWNpZmljVmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZGVsZXRlKHNwZWNpZmljVmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBrZXlzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMua2V5cygpO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFyTmFtZSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh2YXJOYW1lKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50KHZhcmlhYmxlTmFtZSwgbmV3VmFsdWVPYmopIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAoIShuZXdWYWx1ZU9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIHZhcmlhYmxlIHRoYXQgaXNuJ3QgYSBzdGFuZGFyZCB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFyIHZhbCA9IG5ld1ZhbHVlT2JqIGFzIFZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG5ld1ZhbHVlT2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyKHZhcmlhYmxlTmFtZSwgdmFsLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZ2xvYmFsVGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhcIlwiKTtcbiAgICB9XG4gICAgVGFnc0ZvckNvbnRlbnRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHBhdGgpO1xuICAgIH1cbiAgICBUYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgbGV0IHBhdGggPSBuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZyk7XG4gICAgICAgIGxldCBmbG93Q29udGFpbmVyID0gdGhpcy5Db250ZW50QXRQYXRoKHBhdGgpLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGZsb3dDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZmxvd0NvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgbGV0IGZpcnN0Q29udGVudCA9IGZsb3dDb250YWluZXIuY29udGVudFswXTtcbiAgICAgICAgICAgIGlmIChmaXJzdENvbnRlbnQgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpXG4gICAgICAgICAgICAgICAgZmxvd0NvbnRhaW5lciA9IGZpcnN0Q29udGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFncyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGMgb2YgZmxvd0NvbnRhaW5lci5jb250ZW50KSB7XG4gICAgICAgICAgICAvLyB2YXIgdGFnID0gYyBhcyBSdW50aW1lLlRhZztcbiAgICAgICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoYywgVGFnXzEuVGFnKTtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFncyA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0YWdzID0gW107XG4gICAgICAgICAgICAgICAgdGFncy5wdXNoKHRhZy50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFncztcbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgMCwgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCAwLCB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLlJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBOZXh0Q29udGVudCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLlZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VjY2Vzc2Z1bFBvaW50ZXJJbmNyZW1lbnQgPSB0aGlzLkluY3JlbWVudENvbnRlbnRQb2ludGVyKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc2Z1bFBvaW50ZXJJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBkaWRQb3AgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3AoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZvaWRfMS5Wb2lkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWRQb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCk7XG4gICAgICAgICAgICAgICAgZGlkUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkUG9wICYmICF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuTmV4dENvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJbmNyZW1lbnRDb250ZW50UG9pbnRlcigpIHtcbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxJbmNyZW1lbnQgPSB0cnVlO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgcG9pbnRlci5pbmRleCsrO1xuICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBvaW50ZXIuaW5kZXggPj0gcG9pbnRlci5jb250YWluZXIuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxJbmNyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIENvbnRhaW5lciBuZXh0QW5jZXN0b3IgPSBwb2ludGVyLmNvbnRhaW5lci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgbGV0IG5leHRBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb2ludGVyLmNvbnRhaW5lci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobmV4dEFuY2VzdG9yIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGluZGV4SW5BbmNlc3RvciA9IG5leHRBbmNlc3Rvci5jb250ZW50LmluZGV4T2YocG9pbnRlci5jb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGluZGV4SW5BbmNlc3RvciA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlciA9IG5ldyBQb2ludGVyXzEuUG9pbnRlcihuZXh0QW5jZXN0b3IsIGluZGV4SW5BbmNlc3Rvcik7XG4gICAgICAgICAgICBwb2ludGVyLmluZGV4Kys7XG4gICAgICAgICAgICBzdWNjZXNzZnVsSW5jcmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdWNjZXNzZnVsSW5jcmVtZW50KVxuICAgICAgICAgICAgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgIHJldHVybiBzdWNjZXNzZnVsSW5jcmVtZW50O1xuICAgIH1cbiAgICBUcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCkge1xuICAgICAgICBsZXQgYWxsQ2hvaWNlcyA9IHRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzO1xuICAgICAgICBsZXQgaW52aXNpYmxlQ2hvaWNlcyA9IGFsbENob2ljZXMuZmlsdGVyKChjKSA9PiBjLmlzSW52aXNpYmxlRGVmYXVsdCk7XG4gICAgICAgIGlmIChpbnZpc2libGVDaG9pY2VzLmxlbmd0aCA9PSAwIHx8XG4gICAgICAgICAgICBhbGxDaG9pY2VzLmxlbmd0aCA+IGludmlzaWJsZUNob2ljZXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hvaWNlID0gaW52aXNpYmxlQ2hvaWNlc1swXTtcbiAgICAgICAgaWYgKGNob2ljZS50YXJnZXRQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZS50aHJlYWRBdEdlbmVyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZCA9IGNob2ljZS50aHJlYWRBdEdlbmVyYXRpb247XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChjaG9pY2UudGFyZ2V0UGF0aCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgTmV4dFNlcXVlbmNlU2h1ZmZsZUluZGV4KCkge1xuICAgICAgICAvLyB2YXIgbnVtRWxlbWVudHNJbnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgIGxldCBudW1FbGVtZW50c0ludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgaWYgKCEobnVtRWxlbWVudHNJbnRWYWwgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5FcnJvcihcImV4cGVjdGVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBzZXF1ZW5jZSBmb3Igc2h1ZmZsZSBpbmRleFwiKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXFDb250YWluZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHNlcUNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzZXFDb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgaWYgKG51bUVsZW1lbnRzSW50VmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm51bUVsZW1lbnRzSW50VmFsLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1FbGVtZW50cyA9IG51bUVsZW1lbnRzSW50VmFsLnZhbHVlO1xuICAgICAgICAvLyB2YXIgc2VxQ291bnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgIGxldCBzZXFDb3VudFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBsZXQgc2VxQ291bnQgPSBzZXFDb3VudFZhbC52YWx1ZTtcbiAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgaWYgKHNlcUNvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInNlcUNvdW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsb29wSW5kZXggPSBzZXFDb3VudCAvIG51bUVsZW1lbnRzO1xuICAgICAgICBsZXQgaXRlcmF0aW9uSW5kZXggPSBzZXFDb3VudCAlIG51bUVsZW1lbnRzO1xuICAgICAgICBsZXQgc2VxUGF0aFN0ciA9IHNlcUNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBzZXF1ZW5jZUhhc2ggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHNlcVBhdGhTdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBzZXF1ZW5jZUhhc2ggKz0gc2VxUGF0aFN0ci5jaGFyQ29kZUF0KGkpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJhbmRvbVNlZWQgPSBzZXF1ZW5jZUhhc2ggKyBsb29wSW5kZXggKyB0aGlzLnN0YXRlLnN0b3J5U2VlZDtcbiAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhNYXRoLmZsb29yKHJhbmRvbVNlZWQpKTtcbiAgICAgICAgbGV0IHVucGlja2VkSW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVsZW1lbnRzOyArK2kpIHtcbiAgICAgICAgICAgIHVucGlja2VkSW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGl0ZXJhdGlvbkluZGV4OyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjaG9zZW4gPSByYW5kb20ubmV4dCgpICUgdW5waWNrZWRJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBjaG9zZW5JbmRleCA9IHVucGlja2VkSW5kaWNlc1tjaG9zZW5dO1xuICAgICAgICAgICAgdW5waWNrZWRJbmRpY2VzLnNwbGljZShjaG9zZW4sIDEpO1xuICAgICAgICAgICAgaWYgKGkgPT0gaXRlcmF0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvc2VuSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIik7XG4gICAgfVxuICAgIEVycm9yKG1lc3NhZ2UsIHVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZSA9IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKG1lc3NhZ2UpO1xuICAgICAgICBlLnVzZUVuZExpbmVOdW1iZXIgPSB1c2VFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBXYXJuaW5nKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5BZGRFcnJvcihtZXNzYWdlLCB0cnVlKTtcbiAgICB9XG4gICAgQWRkRXJyb3IobWVzc2FnZSwgaXNXYXJuaW5nID0gZmFsc2UsIHVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZG0gPSB0aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhO1xuICAgICAgICBsZXQgZXJyb3JUeXBlU3RyID0gaXNXYXJuaW5nID8gXCJXQVJOSU5HXCIgOiBcIkVSUk9SXCI7XG4gICAgICAgIGlmIChkbSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbGluZU51bSA9IHVzZUVuZExpbmVOdW1iZXIgPyBkbS5lbmRMaW5lTnVtYmVyIDogZG0uc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgXCJSVU5USU1FIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeXBlU3RyICtcbiAgICAgICAgICAgICAgICAgICAgXCI6ICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGRtLmZpbGVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCInIGxpbmUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBsaW5lTnVtICtcbiAgICAgICAgICAgICAgICAgICAgXCI6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIFwiUlVOVElNRSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZVN0ciArXG4gICAgICAgICAgICAgICAgICAgIFwiOiAoXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyICtcbiAgICAgICAgICAgICAgICAgICAgXCIpOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJSVU5USU1FIFwiICsgZXJyb3JUeXBlU3RyICsgXCI6IFwiICsgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLkFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZyk7XG4gICAgICAgIC8vIEluIGEgYnJva2VuIHN0YXRlIGRvbid0IG5lZWQgdG8ga25vdyBhYm91dCBhbnkgb3RoZXIgZXJyb3JzLlxuICAgICAgICBpZiAoIWlzV2FybmluZylcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuRm9yY2VFbmQoKTtcbiAgICB9XG4gICAgQXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbmRpdGlvbiA9PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlN0b3J5IGFzc2VydFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgKyBcIiBcIiArIHRoaXMuY3VycmVudERlYnVnTWV0YWRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50RGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgbGV0IGRtO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI7XG4gICAgICAgIGlmICghcG9pbnRlci5pc051bGwgJiYgcG9pbnRlci5SZXNvbHZlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRtID0gcG9pbnRlci5SZXNvbHZlKCkuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50c1tpXS5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgICAgIGlmICghcG9pbnRlci5pc051bGwgJiYgcG9pbnRlci5SZXNvbHZlKCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkbSA9IHBvaW50ZXIuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgb3V0cHV0T2JqID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBkbSA9IG91dHB1dE9iai5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWFpbkNvbnRlbnRDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3RvcnkgPSBTdG9yeTtcblN0b3J5Lmlua1ZlcnNpb25DdXJyZW50ID0gMTk7XG4oZnVuY3Rpb24gKFN0b3J5KSB7XG4gICAgbGV0IE91dHB1dFN0YXRlQ2hhbmdlO1xuICAgIChmdW5jdGlvbiAoT3V0cHV0U3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJOb0NoYW5nZVwiXSA9IDBdID0gXCJOb0NoYW5nZVwiO1xuICAgICAgICBPdXRwdXRTdGF0ZUNoYW5nZVtPdXRwdXRTdGF0ZUNoYW5nZVtcIkV4dGVuZGVkQmV5b25kTmV3bGluZVwiXSA9IDFdID0gXCJFeHRlbmRlZEJleW9uZE5ld2xpbmVcIjtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJOZXdsaW5lUmVtb3ZlZFwiXSA9IDJdID0gXCJOZXdsaW5lUmVtb3ZlZFwiO1xuICAgIH0pKE91dHB1dFN0YXRlQ2hhbmdlID0gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UgfHwgKFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlID0ge30pKTtcbn0pKFN0b3J5ID0gZXhwb3J0cy5TdG9yeSB8fCAoZXhwb3J0cy5TdG9yeSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnlFeGNlcHRpb24gPSB2b2lkIDA7XG5jbGFzcyBTdG9yeUV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnVzZUVuZExpbmVOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJTdG9yeUV4Y2VwdGlvblwiO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcnlFeGNlcHRpb24gPSBTdG9yeUV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3J5RXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yeVN0YXRlID0gdm9pZCAwO1xuY29uc3QgQ2FsbFN0YWNrXzEgPSByZXF1aXJlKFwiLi9DYWxsU3RhY2tcIik7XG5jb25zdCBWYXJpYWJsZXNTdGF0ZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVzU3RhdGVcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgVGFnXzEgPSByZXF1aXJlKFwiLi9UYWdcIik7XG5jb25zdCBHbHVlXzEgPSByZXF1aXJlKFwiLi9HbHVlXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBQUk5HXzEgPSByZXF1aXJlKFwiLi9QUk5HXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFBvaW50ZXJfMSA9IHJlcXVpcmUoXCIuL1BvaW50ZXJcIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBEZWJ1Z18xID0gcmVxdWlyZShcIi4vRGVidWdcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU3RvcnlfMSA9IHJlcXVpcmUoXCIuL1N0b3J5XCIpO1xuY29uc3QgU3RhdGVQYXRjaF8xID0gcmVxdWlyZShcIi4vU3RhdGVQYXRjaFwiKTtcbmNvbnN0IFNpbXBsZUpzb25fMSA9IHJlcXVpcmUoXCIuL1NpbXBsZUpzb25cIik7XG5jbGFzcyBTdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yeSkge1xuICAgICAgICB0aGlzLmtJbmtTYXZlU3RhdGVWZXJzaW9uID0gODtcbiAgICAgICAgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uID0gODtcbiAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuZGl2ZXJ0ZWRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFR1cm5JbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3RvcnlTZWVkID0gMDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1JhbmRvbSA9IDA7XG4gICAgICAgIHRoaXMuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFncyA9IG51bGw7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9yeSA9IHN0b3J5O1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSBbXTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICB0aGlzLl9ldmFsdWF0aW9uU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2sgPSBuZXcgQ2FsbFN0YWNrXzEuQ2FsbFN0YWNrKHN0b3J5KTtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzU3RhdGUgPSBuZXcgVmFyaWFibGVzU3RhdGVfMS5WYXJpYWJsZXNTdGF0ZSh0aGlzLmNhbGxTdGFjaywgc3RvcnkubGlzdERlZmluaXRpb25zKTtcbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUdXJuSW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHRpbWVTZWVkID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIHRoaXMuc3RvcnlTZWVkID0gbmV3IFBSTkdfMS5QUk5HKHRpbWVTZWVkKS5uZXh0KCkgJSAxMDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcyA9IFtdO1xuICAgICAgICB0aGlzLkdvVG9TdGFydCgpO1xuICAgIH1cbiAgICBUb0pzb24oaW5kZW50ZWQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgd3JpdGVyID0gbmV3IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLldyaXRlcigpO1xuICAgICAgICB0aGlzLldyaXRlSnNvbih3cml0ZXIpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLlRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSnNvbihpbmRlbnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRvSnNvbihpbmRlbnRlZCk7XG4gICAgfVxuICAgIExvYWRKc29uKGpzb24pIHtcbiAgICAgICAgbGV0IGpPYmplY3QgPSBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5UZXh0VG9EaWN0aW9uYXJ5KGpzb24pO1xuICAgICAgICB0aGlzLkxvYWRKc29uT2JqKGpPYmplY3QpO1xuICAgIH1cbiAgICBWaXNpdENvdW50QXRQYXRoU3RyaW5nKHBhdGhTdHJpbmcpIHtcbiAgICAgICAgbGV0IHZpc2l0Q291bnRPdXQ7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuc3RvcnkuQ29udGVudEF0UGF0aChuZXcgUGF0aF8xLlBhdGgocGF0aFN0cmluZykpLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGVudCBhdCBwYXRoIG5vdCBmb3VuZDogXCIgKyBwYXRoU3RyaW5nKTtcbiAgICAgICAgICAgIHZpc2l0Q291bnRPdXQgPSB0aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBpZiAodmlzaXRDb3VudE91dC5leGlzdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0Q291bnRPdXQucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0Q291bnRPdXQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIHBhdGhTdHJpbmcsIG51bGwpO1xuICAgICAgICBpZiAodmlzaXRDb3VudE91dC5leGlzdHMpXG4gICAgICAgICAgICByZXR1cm4gdmlzaXRDb3VudE91dC5yZXN1bHQ7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRhaW5lci52aXNpdHNTaG91bGRCZUNvdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcnkuRXJyb3IoXCJSZWFkIGNvdW50IGZvciB0YXJnZXQgKFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSArXG4gICAgICAgICAgICAgICAgXCIgLSBvbiBcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmRlYnVnTWV0YWRhdGEgK1xuICAgICAgICAgICAgICAgIFwiKSB1bmtub3duLiBUaGUgc3RvcnkgbWF5IG5lZWQgdG8gYmUgY29tcGlsZWQgd2l0aCBjb3VudEFsbFZpc2l0cyBmbGFnICgtYykuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY291bnQgPSB0aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBpZiAoY291bnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvdW50LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjb3VudDIgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIGNvbnRhaW5lclBhdGhTdHIsIG51bGwpO1xuICAgICAgICBpZiAoY291bnQyLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50Mi5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIEluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGN1cnJDb3VudCA9IHRoaXMuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgY3VyckNvdW50Kys7XG4gICAgICAgICAgICB0aGlzLl9wYXRjaC5TZXRWaXNpdENvdW50KGNvbnRhaW5lciwgY3VyckNvdW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBjb3VudCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl92aXNpdENvdW50cywgY29udGFpbmVyUGF0aFN0ciwgbnVsbCk7XG4gICAgICAgIGlmIChjb3VudC5leGlzdHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXJQYXRoU3RyLCBjb3VudC5yZXN1bHQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzLnNldChjb250YWluZXJQYXRoU3RyLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZWNvcmRUdXJuSW5kZXhWaXNpdFRvQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhdGNoLlNldFR1cm5JbmRleChjb250YWluZXIsIHRoaXMuY3VycmVudFR1cm5JbmRleCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcy5zZXQoY29udGFpbmVyUGF0aFN0ciwgdGhpcy5jdXJyZW50VHVybkluZGV4KTtcbiAgICB9XG4gICAgVHVybnNTaW5jZUZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIudHVybkluZGV4U2hvdWxkQmVDb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3J5LkVycm9yKFwiVFVSTlNfU0lOQ0UoKSBmb3IgdGFyZ2V0IChcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiIC0gb24gXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kZWJ1Z01ldGFkYXRhICtcbiAgICAgICAgICAgICAgICBcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3BhdGNoLlRyeUdldFR1cm5JbmRleChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKGluZGV4LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUdXJuSW5kZXggLSBpbmRleC5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgaW5kZXgyID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3R1cm5JbmRpY2VzLCBjb250YWluZXJQYXRoU3RyLCAwKTtcbiAgICAgICAgaWYgKGluZGV4Mi5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUdXJuSW5kZXggLSBpbmRleDIucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYWxsc3RhY2tEZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmRlcHRoO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0U3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3V0cHV0U3RyZWFtO1xuICAgIH1cbiAgICBnZXQgY3VycmVudENob2ljZXMoKSB7XG4gICAgICAgIC8vIElmIHdlIGNhbiBjb250aW51ZSBnZW5lcmF0aW5nIHRleHQgY29udGVudCByYXRoZXIgdGhhbiBjaG9pY2VzLFxuICAgICAgICAvLyB0aGVuIHdlIHJlZmxlY3QgdGhlIGNob2ljZSBsaXN0IGFzIGJlaW5nIGVtcHR5LCBzaW5jZSBjaG9pY2VzXG4gICAgICAgIC8vIHNob3VsZCBhbHdheXMgY29tZSBhdCB0aGUgZW5kLlxuICAgICAgICBpZiAodGhpcy5jYW5Db250aW51ZSlcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaG9pY2VzO1xuICAgIH1cbiAgICBnZXQgZ2VuZXJhdGVkQ2hvaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRDaG9pY2VzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRFcnJvcnM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50V2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50V2FybmluZ3M7XG4gICAgfVxuICAgIGdldCB2YXJpYWJsZXNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhcmlhYmxlc1N0YXRlO1xuICAgIH1cbiAgICBzZXQgdmFyaWFibGVzU3RhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFyaWFibGVzU3RhdGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGV2YWx1YXRpb25TdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRpb25TdGFjaztcbiAgICB9XG4gICAgZ2V0IHZpc2l0Q291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgfVxuICAgIGdldCB0dXJuSW5kaWNlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFR1cm5JbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXg7XG4gICAgfVxuICAgIHNldCBjdXJyZW50VHVybkluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQYXRoU3RyaW5nKCkge1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuY3VycmVudFBvaW50ZXI7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocG9pbnRlci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLnBhdGhcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb2ludGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFBvaW50ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSB2YWx1ZS5jb3B5KCk7XG4gICAgfVxuICAgIGdldCBwcmV2aW91c1BvaW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgfVxuICAgIHNldCBwcmV2aW91c1BvaW50ZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXIgPSB2YWx1ZS5jb3B5KCk7XG4gICAgfVxuICAgIGdldCBjYW5Db250aW51ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmN1cnJlbnRQb2ludGVyLmlzTnVsbCAmJiAhdGhpcy5oYXNFcnJvcjtcbiAgICB9XG4gICAgZ2V0IGhhc0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RXJyb3JzICE9IG51bGwgJiYgdGhpcy5jdXJyZW50RXJyb3JzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBoYXNXYXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50V2FybmluZ3MgIT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRXYXJuaW5ncy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRleHQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkpIHtcbiAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgZm9yIChsZXQgb3V0cHV0T2JqIG9mIHRoaXMuX291dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciB0ZXh0Q29udGVudCA9IG91dHB1dE9iaiBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dENvbnRlbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob3V0cHV0T2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKHRleHRDb250ZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGV4dCA9IHRoaXMuQ2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHNiLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUZXh0O1xuICAgIH1cbiAgICBDbGVhbk91dHB1dFdoaXRlc3BhY2Uoc3RyKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBsZXQgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9IC0xO1xuICAgICAgICBsZXQgc3RhcnRPZkxpbmUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgbGV0IGlzSW5saW5lV2hpdGVzcGFjZSA9IGMgPT0gXCIgXCIgfHwgYyA9PSBcIlxcdFwiO1xuICAgICAgICAgICAgaWYgKGlzSW5saW5lV2hpdGVzcGFjZSAmJiBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID09IC0xKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKCFpc0lubGluZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPSBcIlxcblwiICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgIT0gc3RhcnRPZkxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICBzdGFydE9mTGluZSA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKCFpc0lubGluZVdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRhZ3MoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYWdzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBvdXRwdXRPYmogb2YgdGhpcy5fb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHRhZyA9IG91dHB1dE9iaiBhcyBUYWc7XG4gICAgICAgICAgICAgICAgbGV0IHRhZyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvdXRwdXRPYmosIFRhZ18xLlRhZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRhZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFncy5wdXNoKHRhZy50ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRhZ3M7XG4gICAgfVxuICAgIGdldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbjtcbiAgICB9XG4gICAgc2V0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBHb1RvU3RhcnQoKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZih0aGlzLnN0b3J5Lm1haW5Db250ZW50Q29udGFpbmVyKTtcbiAgICB9XG4gICAgQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKSB7XG4gICAgICAgIGxldCBjb3B5ID0gbmV3IFN0b3J5U3RhdGUodGhpcy5zdG9yeSk7XG4gICAgICAgIGNvcHkuX3BhdGNoID0gbmV3IFN0YXRlUGF0Y2hfMS5TdGF0ZVBhdGNoKHRoaXMuX3BhdGNoKTtcbiAgICAgICAgY29weS5vdXRwdXRTdHJlYW0ucHVzaC5hcHBseShjb3B5Lm91dHB1dFN0cmVhbSwgdGhpcy5fb3V0cHV0U3RyZWFtKTtcbiAgICAgICAgY29weS5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICBjb3B5Ll9jdXJyZW50Q2hvaWNlcy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRDaG9pY2VzLCB0aGlzLl9jdXJyZW50Q2hvaWNlcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50RXJyb3JzID0gW107XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50RXJyb3JzLnB1c2guYXBwbHkoY29weS5fY3VycmVudEVycm9ycywgdGhpcy5jdXJyZW50RXJyb3JzIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNXYXJuaW5nKSB7XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50V2FybmluZ3MgPSBbXTtcbiAgICAgICAgICAgIGNvcHkuX2N1cnJlbnRXYXJuaW5ncy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRXYXJuaW5ncywgdGhpcy5jdXJyZW50V2FybmluZ3MgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGNvcHkuY2FsbFN0YWNrID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjayh0aGlzLmNhbGxTdGFjayk7XG4gICAgICAgIGNvcHkudmFyaWFibGVzU3RhdGUgPSB0aGlzLnZhcmlhYmxlc1N0YXRlO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjayA9IGNvcHkuY2FsbFN0YWNrO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlLnBhdGNoID0gY29weS5fcGF0Y2g7XG4gICAgICAgIGNvcHkuZXZhbHVhdGlvblN0YWNrLnB1c2guYXBwbHkoY29weS5ldmFsdWF0aW9uU3RhY2ssIHRoaXMuZXZhbHVhdGlvblN0YWNrKTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGwpXG4gICAgICAgICAgICBjb3B5LmRpdmVydGVkUG9pbnRlciA9IHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgY29weS5wcmV2aW91c1BvaW50ZXIgPSB0aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGNvcHkuX3Zpc2l0Q291bnRzID0gdGhpcy5fdmlzaXRDb3VudHM7XG4gICAgICAgIGNvcHkuX3R1cm5JbmRpY2VzID0gdGhpcy5fdHVybkluZGljZXM7XG4gICAgICAgIGNvcHkuY3VycmVudFR1cm5JbmRleCA9IHRoaXMuY3VycmVudFR1cm5JbmRleDtcbiAgICAgICAgY29weS5zdG9yeVNlZWQgPSB0aGlzLnN0b3J5U2VlZDtcbiAgICAgICAgY29weS5wcmV2aW91c1JhbmRvbSA9IHRoaXMucHJldmlvdXNSYW5kb207XG4gICAgICAgIGNvcHkuZGlkU2FmZUV4aXQgPSB0aGlzLmRpZFNhZmVFeGl0O1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgUmVzdG9yZUFmdGVyUGF0Y2goKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUuY2FsbFN0YWNrID0gdGhpcy5jYWxsU3RhY2s7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUucGF0Y2ggPSB0aGlzLl9wYXRjaDtcbiAgICB9XG4gICAgQXBwbHlBbnlQYXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLkFwcGx5UGF0Y2goKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX3BhdGNoLnZpc2l0Q291bnRzKVxuICAgICAgICAgICAgdGhpcy5BcHBseUNvdW50Q2hhbmdlcyhrZXksIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX3BhdGNoLnR1cm5JbmRpY2VzKVxuICAgICAgICAgICAgdGhpcy5BcHBseUNvdW50Q2hhbmdlcyhrZXksIHZhbHVlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3BhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgQXBwbHlDb3VudENoYW5nZXMoY29udGFpbmVyLCBuZXdDb3VudCwgaXNWaXNpdCkge1xuICAgICAgICBsZXQgY291bnRzID0gaXNWaXNpdCA/IHRoaXMuX3Zpc2l0Q291bnRzIDogdGhpcy5fdHVybkluZGljZXM7XG4gICAgICAgIGNvdW50cy5zZXQoY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSwgbmV3Q291bnQpO1xuICAgIH1cbiAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGxldCBoYXNDaG9pY2VUaHJlYWRzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpIHtcbiAgICAgICAgICAgIGlmIChjLnRocmVhZEF0R2VuZXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiYy50aHJlYWRBdEdlbmVyYXRpb25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjLm9yaWdpbmFsVGhyZWFkSW5kZXggPSBjLnRocmVhZEF0R2VuZXJhdGlvbi50aHJlYWRJbmRleDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgoYy5vcmlnaW5hbFRocmVhZEluZGV4KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghaGFzQ2hvaWNlVGhyZWFkcykge1xuICAgICAgICAgICAgICAgICAgICBoYXNDaG9pY2VUaHJlYWRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImNob2ljZVRocmVhZHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoYy5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjLnRocmVhZEF0R2VuZXJhdGlvbi5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNDaG9pY2VUaHJlYWRzKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIGZvbGxvd2luZyB0d28gY2FsbHMsIGBXcml0ZUpzb25gIGlzIGNhbGxlZCBpbnNpZGUgYW4gYXJyb3dcbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gbWFrZSBzdXJlIGB0aGlzYCBpcyBjb3JyZWN0bHkgYm91bmQgYW5kIHBhc3NlZCBkb3duXG4gICAgICAgIC8vIHRoZSBjYWxsIGhpZXJhcmNoeS5cbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjYWxsc3RhY2tUaHJlYWRzXCIsICh3KSA9PiB0aGlzLmNhbGxTdGFjay5Xcml0ZUpzb24odykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZhcmlhYmxlc1N0YXRlXCIsICh3KSA9PiB0aGlzLnZhcmlhYmxlc1N0YXRlLldyaXRlSnNvbih3KSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiZXZhbFN0YWNrXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHcsIHRoaXMuZXZhbHVhdGlvblN0YWNrKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwib3V0cHV0U3RyZWFtXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHcsIHRoaXMuX291dHB1dFN0cmVhbSkpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnRDaG9pY2VzXCIsICh3KSA9PiB7XG4gICAgICAgICAgICB3LldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcylcbiAgICAgICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlQ2hvaWNlKHcsIGMpO1xuICAgICAgICAgICAgdy5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImRpdmVydGVkUG9pbnRlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY3VycmVudERpdmVydFRhcmdldFwiLCB0aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidmlzaXRDb3VudHNcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVJbnREaWN0aW9uYXJ5KHcsIHRoaXMuX3Zpc2l0Q291bnRzKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidHVybkluZGljZXNcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVJbnREaWN0aW9uYXJ5KHcsIHRoaXMuX3R1cm5JbmRpY2VzKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwidHVybklkeFwiLCB0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInN0b3J5U2VlZFwiLCB0aGlzLnN0b3J5U2VlZCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwicHJldmlvdXNSYW5kb21cIiwgdGhpcy5wcmV2aW91c1JhbmRvbSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rU2F2ZVZlcnNpb25cIiwgdGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbik7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5rRm9ybWF0VmVyc2lvblwiLCBTdG9yeV8xLlN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIExvYWRKc29uT2JqKHZhbHVlKSB7XG4gICAgICAgIGxldCBqT2JqZWN0ID0gdmFsdWU7XG4gICAgICAgIGxldCBqU2F2ZVZlcnNpb24gPSBqT2JqZWN0W1wiaW5rU2F2ZVZlcnNpb25cIl07XG4gICAgICAgIGlmIChqU2F2ZVZlcnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJpbmsgc2F2ZSBmb3JtYXQgaW5jb3JyZWN0LCBjYW4ndCBsb2FkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZUludChqU2F2ZVZlcnNpb24pIDwgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkluayBzYXZlIGZvcm1hdCBpc24ndCBjb21wYXRpYmxlIHdpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiAoc2F3ICdcIiArXG4gICAgICAgICAgICAgICAgalNhdmVWZXJzaW9uICtcbiAgICAgICAgICAgICAgICBcIicsIGJ1dCBtaW5pbXVtIGlzIFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24gK1xuICAgICAgICAgICAgICAgIFwiKSwgc28gY2FuJ3QgbG9hZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsU3RhY2suU2V0SnNvblRva2VuKGpPYmplY3RbXCJjYWxsc3RhY2tUaHJlYWRzXCJdLCB0aGlzLnN0b3J5KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5TZXRKc29uVG9rZW4oak9iamVjdFtcInZhcmlhYmxlc1N0YXRlXCJdKTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGlvblN0YWNrID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpPYmplY3RbXCJldmFsU3RhY2tcIl0pO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpBcnJheVRvUnVudGltZU9iakxpc3Qoak9iamVjdFtcIm91dHB1dFN0cmVhbVwiXSk7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgLy8gY3VycmVudENob2ljZXMgPSBKc29uLkpBcnJheVRvUnVudGltZU9iakxpc3Q8Q2hvaWNlPigoSkFycmF5KWpPYmplY3QgW1wiY3VycmVudENob2ljZXNcIl0pO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdChqT2JqZWN0W1wiY3VycmVudENob2ljZXNcIl0pO1xuICAgICAgICBsZXQgY3VycmVudERpdmVydFRhcmdldFBhdGggPSBqT2JqZWN0W1wiY3VycmVudERpdmVydFRhcmdldFwiXTtcbiAgICAgICAgaWYgKGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkaXZlcnRQYXRoID0gbmV3IFBhdGhfMS5QYXRoKGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgoZGl2ZXJ0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdFtcInZpc2l0Q291bnRzXCJdKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpPYmplY3RUb0ludERpY3Rpb25hcnkoak9iamVjdFtcInR1cm5JbmRpY2VzXCJdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4ID0gcGFyc2VJbnQoak9iamVjdFtcInR1cm5JZHhcIl0pO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IHBhcnNlSW50KGpPYmplY3RbXCJzdG9yeVNlZWRcIl0pO1xuICAgICAgICB0aGlzLnByZXZpb3VzUmFuZG9tID0gcGFyc2VJbnQoak9iamVjdFtcInByZXZpb3VzUmFuZG9tXCJdKTtcbiAgICAgICAgLy8gdmFyIGpDaG9pY2VUaHJlYWRzID0gak9iamVjdFtcImNob2ljZVRocmVhZHNcIl0gYXMgSk9iamVjdDtcbiAgICAgICAgbGV0IGpDaG9pY2VUaHJlYWRzID0gak9iamVjdFtcImNob2ljZVRocmVhZHNcIl07XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEFjdGl2ZVRocmVhZCA9IHRoaXMuY2FsbFN0YWNrLlRocmVhZFdpdGhJbmRleChjLm9yaWdpbmFsVGhyZWFkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZvdW5kQWN0aXZlVGhyZWFkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjLnRocmVhZEF0R2VuZXJhdGlvbiA9IGZvdW5kQWN0aXZlVGhyZWFkLkNvcHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBqU2F2ZWRDaG9pY2VUaHJlYWQgPSBqQ2hvaWNlVGhyZWFkc1tjLm9yaWdpbmFsVGhyZWFkSW5kZXgudG9TdHJpbmcoKV07XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24gPSBuZXcgQ2FsbFN0YWNrXzEuQ2FsbFN0YWNrLlRocmVhZChqU2F2ZWRDaG9pY2VUaHJlYWQsIHRoaXMuc3RvcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJlc2V0RXJyb3JzKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzID0gbnVsbDtcbiAgICB9XG4gICAgUmVzZXRPdXRwdXQob2JqcyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCA9IDA7XG4gICAgICAgIGlmIChvYmpzICE9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnB1c2guYXBwbHkodGhpcy5fb3V0cHV0U3RyZWFtLCBvYmpzKTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBQdXNoVG9PdXRwdXRTdHJlYW0ob2JqKSB7XG4gICAgICAgIC8vIHZhciB0ZXh0ID0gb2JqIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGxpc3RUZXh0ID0gdGhpcy5UcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2UodGV4dCk7XG4gICAgICAgICAgICBpZiAobGlzdFRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB0ZXh0T2JqIG9mIGxpc3RUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbCh0ZXh0T2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwob2JqKTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBQb3BGcm9tT3V0cHV0U3RyZWFtKGNvdW50KSB7XG4gICAgICAgIHRoaXMub3V0cHV0U3RyZWFtLnNwbGljZSh0aGlzLm91dHB1dFN0cmVhbS5sZW5ndGggLSBjb3VudCwgY291bnQpO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIFRyeVNwbGl0dGluZ0hlYWRUYWlsV2hpdGVzcGFjZShzaW5nbGUpIHtcbiAgICAgICAgbGV0IHN0ciA9IHNpbmdsZS52YWx1ZTtcbiAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzaW5nbGUudmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhlYWRGaXJzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgbGV0IGhlYWRMYXN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGhlYWRGaXJzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgICAgIGhlYWRMYXN0TmV3bGluZUlkeCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09IFwiIFwiIHx8IGMgPT0gXCJcXHRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFpbExhc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGxldCB0YWlsRmlyc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHN0cltpXTtcbiAgICAgICAgICAgIGlmIChjID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0YWlsTGFzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgICAgIHRhaWxGaXJzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSBcIiBcIiB8fCBjID09IFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc3BsaXR0aW5nIHRvIGJlIGRvbmU/XG4gICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID09IC0xICYmIHRhaWxMYXN0TmV3bGluZUlkeCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbGlzdFRleHRzID0gW107XG4gICAgICAgIGxldCBpbm5lclN0clN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGlubmVyU3RyRW5kID0gc3RyLmxlbmd0aDtcbiAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggIT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsZWFkaW5nU3BhY2VzID0gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoc3RyLnN1YnN0cmluZygwLCBoZWFkRmlyc3ROZXdsaW5lSWR4KSk7XG4gICAgICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobGVhZGluZ1NwYWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0VGV4dHMucHVzaChuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShcIlxcblwiKSk7XG4gICAgICAgICAgICBpbm5lclN0clN0YXJ0ID0gaGVhZExhc3ROZXdsaW5lSWR4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ICE9IC0xKSB7XG4gICAgICAgICAgICBpbm5lclN0ckVuZCA9IHRhaWxGaXJzdE5ld2xpbmVJZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlubmVyU3RyRW5kID4gaW5uZXJTdHJTdGFydCkge1xuICAgICAgICAgICAgbGV0IGlubmVyU3RyVGV4dCA9IHN0ci5zdWJzdHJpbmcoaW5uZXJTdHJTdGFydCwgaW5uZXJTdHJFbmQgLSBpbm5lclN0clN0YXJ0KTtcbiAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKGlubmVyU3RyVGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggIT0gLTEgJiYgdGFpbEZpcnN0TmV3bGluZUlkeCA+IGhlYWRMYXN0TmV3bGluZUlkeCkge1xuICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIikpO1xuICAgICAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCA8IHN0ci5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbGV0IG51bVNwYWNlcyA9IHN0ci5sZW5ndGggLSB0YWlsTGFzdE5ld2xpbmVJZHggLSAxO1xuICAgICAgICAgICAgICAgIGxldCB0cmFpbGluZ1NwYWNlcyA9IG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcodGFpbExhc3ROZXdsaW5lSWR4ICsgMSwgbnVtU3BhY2VzKSk7XG4gICAgICAgICAgICAgICAgbGlzdFRleHRzLnB1c2godHJhaWxpbmdTcGFjZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0VGV4dHM7XG4gICAgfVxuICAgIFB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwob2JqKSB7XG4gICAgICAgIGxldCBnbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgR2x1ZV8xLkdsdWUpO1xuICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICBsZXQgaW5jbHVkZUluT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuVHJpbU5ld2xpbmVzRnJvbU91dHB1dFN0cmVhbSgpO1xuICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICBsZXQgZnVuY3Rpb25UcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxldCBjdXJyRWwgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChjdXJyRWwudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvblRyaW1JbmRleCA9IGN1cnJFbC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZ2x1ZVRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBvID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGxldCBjID0gbyBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQgPyBvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgZyA9IG8gaW5zdGFuY2VvZiBHbHVlXzEuR2x1ZSA/IG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChnICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x1ZVRyaW1JbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgYy5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID49IGZ1bmN0aW9uVHJpbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmIChnbHVlVHJpbUluZGV4ICE9IC0xICYmIGZ1bmN0aW9uVHJpbUluZGV4ICE9IC0xKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRleCA9IE1hdGgubWluKGZ1bmN0aW9uVHJpbUluZGV4LCBnbHVlVHJpbUluZGV4KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGdsdWVUcmltSW5kZXggIT0gLTEpXG4gICAgICAgICAgICAgICAgdHJpbUluZGV4ID0gZ2x1ZVRyaW1JbmRleDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0cmltSW5kZXggPSBmdW5jdGlvblRyaW1JbmRleDtcbiAgICAgICAgICAgIGlmICh0cmltSW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQuaXNOb25XaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbHVlVHJpbUluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlJlbW92ZUV4aXN0aW5nR2x1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25UcmltSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhbGxTdGFja0VsZW1lbnRzID0gdGhpcy5jYWxsU3RhY2suZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2FsbFN0YWNrRWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBjYWxsU3RhY2tFbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0ZXh0LmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgfHwgIXRoaXMub3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlSW5PdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZUluT3V0cHV0KSB7XG4gICAgICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0ucHVzaChvYmopO1xuICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKSB7XG4gICAgICAgIGxldCByZW1vdmVXaGl0ZXNwYWNlRnJvbSA9IC0xO1xuICAgICAgICBsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgbGV0IHR4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNtZCAhPSBudWxsIHx8ICh0eHQgIT0gbnVsbCAmJiB0eHQuaXNOb25XaGl0ZXNwYWNlKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHh0ICE9IG51bGwgJiYgdHh0LmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZVdoaXRlc3BhY2VGcm9tID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHdoaXRlc3BhY2VcbiAgICAgICAgaWYgKHJlbW92ZVdoaXRlc3BhY2VGcm9tID49IDApIHtcbiAgICAgICAgICAgIGkgPSByZW1vdmVXaGl0ZXNwYWNlRnJvbTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuX291dHB1dFN0cmVhbVtpXSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBSZW1vdmVFeGlzdGluZ0dsdWUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgaWYgKGMgaW5zdGFuY2VvZiBHbHVlXzEuR2x1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0IGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dC5pc05ld2xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dC5pc05vbldoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0U3RyZWFtQ29udGFpbnNDb250ZW50KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX291dHB1dFN0cmVhbVtpXSBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaW5TdHJpbmdFdmFsdWF0aW9uKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyB2YXIgY21kID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldIGFzIENvbnRyb2xDb21tYW5kO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLl9vdXRwdXRTdHJlYW1baV0sIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKGNtZCBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQgJiZcbiAgICAgICAgICAgICAgICBjbWQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgUHVzaEV2YWx1YXRpb25TdGFjayhvYmopIHtcbiAgICAgICAgLy8gdmFyIGxpc3RWYWx1ZSA9IG9iaiBhcyBMaXN0VmFsdWU7XG4gICAgICAgIGxldCBsaXN0VmFsdWUgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChsaXN0VmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvcmlnaW4gd2hlbiBsaXN0IGlzIGhhcyBzb21ldGhpbmcgdG8gaW5kaWNhdGUgdGhlIGxpc3Qgb3JpZ2luXG4gICAgICAgICAgICBsZXQgcmF3TGlzdCA9IGxpc3RWYWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyYXdMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJyYXdMaXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJhd0xpc3Qub3JpZ2luTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICghcmF3TGlzdC5vcmlnaW5zKVxuICAgICAgICAgICAgICAgICAgICByYXdMaXN0Lm9yaWdpbnMgPSBbXTtcbiAgICAgICAgICAgICAgICByYXdMaXN0Lm9yaWdpbnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuIG9mIHJhd0xpc3Qub3JpZ2luTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJTdG9yeVN0YXRlLnN0b3J5Lmxpc3REZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZiA9IHRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKG4sIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLnJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiU3RvcnlTdGF0ZSBkZWYucmVzdWx0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmF3TGlzdC5vcmlnaW5zLmluZGV4T2YoZGVmLnJlc3VsdCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zLnB1c2goZGVmLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXZhbHVhdGlvblN0YWNrLnB1c2gob2JqKTtcbiAgICB9XG4gICAgUG9wRXZhbHVhdGlvblN0YWNrKG51bWJlck9mT2JqZWN0cykge1xuICAgICAgICBpZiAodHlwZW9mIG51bWJlck9mT2JqZWN0cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuZXZhbHVhdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5udWxsSWZVbmRlZmluZWQob2JqKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChudW1iZXJPZk9iamVjdHMgPiB0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnlpbmcgdG8gcG9wIHRvbyBtYW55IG9iamVjdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcG9wcGVkID0gdGhpcy5ldmFsdWF0aW9uU3RhY2suc3BsaWNlKHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCAtIG51bWJlck9mT2JqZWN0cywgbnVtYmVyT2ZPYmplY3RzKTtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEubnVsbElmVW5kZWZpbmVkKHBvcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGVla0V2YWx1YXRpb25TdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbHVhdGlvblN0YWNrW3RoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBGb3JjZUVuZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suUmVzZXQoKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgfVxuICAgIFRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCkge1xuICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydCh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbik7XG4gICAgICAgIGxldCBmdW5jdGlvblN0YXJ0UG9pbnQgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudFxuICAgICAgICAgICAgLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uU3RhcnRQb2ludCA9PSAtMSkge1xuICAgICAgICAgICAgZnVuY3Rpb25TdGFydFBvaW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gZnVuY3Rpb25TdGFydFBvaW50OyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBsZXQgdHh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBsZXQgY21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgICAgICBpZiAodHh0ID09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY21kKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHR4dC5pc05ld2xpbmUgfHwgdHh0LmlzSW5saW5lV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9wQ2FsbFN0YWNrKHBvcFR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbilcbiAgICAgICAgICAgIHRoaXMuVHJpbVdoaXRlc3BhY2VGcm9tRnVuY3Rpb25FbmQoKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suUG9wKHBvcFR5cGUpO1xuICAgIH1cbiAgICBTZXRDaG9zZW5QYXRoKHBhdGgsIGluY3JlbWVudGluZ1R1cm5JbmRleCkge1xuICAgICAgICAvLyBDaGFuZ2luZyBkaXJlY3Rpb24sIGFzc3VtZSB3ZSBuZWVkIHRvIGNsZWFyIGN1cnJlbnQgc2V0IG9mIGNob2ljZXNcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IG5ld1BvaW50ZXIgPSB0aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgocGF0aCk7XG4gICAgICAgIGlmICghbmV3UG9pbnRlci5pc051bGwgJiYgbmV3UG9pbnRlci5pbmRleCA9PSAtMSlcbiAgICAgICAgICAgIG5ld1BvaW50ZXIuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gbmV3UG9pbnRlcjtcbiAgICAgICAgaWYgKGluY3JlbWVudGluZ1R1cm5JbmRleCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZShmdW5jQ29udGFpbmVyLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlB1c2goUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lLCB0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoZnVuY0NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpO1xuICAgIH1cbiAgICBQYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soYXJncykge1xuICAgICAgICAvLyBQYXNzIGFyZ3VtZW50cyBvbnRvIHRoZSBldmFsdWF0aW9uIHN0YWNrXG4gICAgICAgIGlmIChhcmdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBhcmdzW2ldID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcmdzW2ldID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmsgYXJndW1lbnRzIHdoZW4gY2FsbGluZyBFdmFsdWF0ZUZ1bmN0aW9uIC8gQ2hvb3NlUGF0aFN0cmluZ1dpdGhQYXJhbWV0ZXJzICBtdXN0IGJlIGludCwgZmxvYXQgb3Igc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLlB1c2hFdmFsdWF0aW9uU3RhY2soVmFsdWVfMS5WYWx1ZS5DcmVhdGUoYXJnc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT1cbiAgICAgICAgICAgIFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLmRpZFNhZmVFeGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgIT1cbiAgICAgICAgICAgIFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJFeHBlY3RlZCBleHRlcm5hbCBmdW5jdGlvbiBldmFsdWF0aW9uIHRvIGJlIGNvbXBsZXRlLiBTdGFjayB0cmFjZTogXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0YWNrLmNhbGxTdGFja1RyYWNlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpZ2luYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQgPSB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudFxuICAgICAgICAgICAgLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ7XG4gICAgICAgIGxldCByZXR1cm5lZE9iaiA9IG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggPiBvcmlnaW5hbEV2YWx1YXRpb25TdGFja0hlaWdodCkge1xuICAgICAgICAgICAgbGV0IHBvcHBlZE9iaiA9IHRoaXMuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWRPYmogPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuZWRPYmogPSBwb3BwZWRPYmo7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5Qb3BDYWxsU3RhY2soUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKTtcbiAgICAgICAgaWYgKHJldHVybmVkT2JqKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWRPYmogaW5zdGFuY2VvZiBWb2lkXzEuVm9pZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIC8vIFNvbWUga2luZCBvZiB2YWx1ZSwgaWYgbm90IHZvaWRcbiAgICAgICAgICAgIC8vIHZhciByZXR1cm5WYWwgPSByZXR1cm5lZE9iaiBhcyBSdW50aW1lLlZhbHVlO1xuICAgICAgICAgICAgbGV0IHJldHVyblZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHJldHVybmVkT2JqLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIC8vIERpdmVydFRhcmdldHMgZ2V0IHJldHVybmVkIGFzIHRoZSBzdHJpbmcgb2YgY29tcG9uZW50c1xuICAgICAgICAgICAgLy8gKHJhdGhlciB0aGFuIGEgUGF0aCwgd2hpY2ggaXNuJ3QgcHVibGljKVxuICAgICAgICAgICAgaWYgKHJldHVyblZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbC52YWx1ZU9iamVjdC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3RoZXIgdHlwZXMgY2FuIGp1c3QgaGF2ZSB0aGVpciBleGFjdCBvYmplY3QgdHlwZTpcbiAgICAgICAgICAgIC8vIGludCwgZmxvYXQsIHN0cmluZy4gVmFyaWFibGVQb2ludGVycyBnZXQgcmV0dXJuZWQgYXMgc3RyaW5ncy5cbiAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWwudmFsdWVPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIEFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZykge1xuICAgICAgICBpZiAoIWlzV2FybmluZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFcnJvcnMgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFdhcm5pbmdzID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPdXRwdXRTdHJlYW1EaXJ0eSgpIHtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLlN0b3J5U3RhdGUgPSBTdG9yeVN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcnlTdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IHZvaWQgMDtcbmNsYXNzIFN0cmluZ0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cikge1xuICAgICAgICBzdHIgPSB0eXBlb2Ygc3RyICE9PSBcInVuZGVmaW5lZFwiID8gc3RyLnRvU3RyaW5nKCkgOiBcIlwiO1xuICAgICAgICB0aGlzLnN0cmluZyA9IHN0cjtcbiAgICB9XG4gICAgZ2V0IExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgQXBwZW5kKHN0cikge1xuICAgICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmluZyArPSBzdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXBwZW5kTGluZShzdHIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHIgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICB0aGlzLkFwcGVuZChzdHIpO1xuICAgICAgICB0aGlzLnN0cmluZyArPSBcIlxcblwiO1xuICAgIH1cbiAgICBBcHBlbmRGb3JtYXQoZm9ybWF0LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHRha2VuIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MTA0MDYvamF2YXNjcmlwdC1lcXVpdmFsZW50LXRvLXByaW50Zi1zdHJpbmctZm9ybWF0XG4gICAgICAgIHRoaXMuc3RyaW5nICs9IGZvcm1hdC5yZXBsYWNlKC97KFxcZCspfS9nLCAobWF0Y2gsIG51bSkgPT4gdHlwZW9mIGFyZ3NbbnVtXSAhPSBcInVuZGVmaW5lZFwiID8gYXJnc1tudW1dIDogbWF0Y2gpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nQnVpbGRlciA9IFN0cmluZ0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdCdWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWcgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFRhZyBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IodGFnVGV4dCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRleHQgPSB0YWdUZXh0LnRvU3RyaW5nKCkgfHwgXCJcIjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIiMgXCIgKyB0aGlzLnRleHQ7XG4gICAgfVxufVxuZXhwb3J0cy5UYWcgPSBUYWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UYWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyeVBhcnNlRmxvYXQgPSBleHBvcnRzLnRyeVBhcnNlSW50ID0gZXhwb3J0cy50cnlHZXRWYWx1ZUZyb21NYXAgPSB2b2lkIDA7XG5mdW5jdGlvbiB0cnlHZXRWYWx1ZUZyb21NYXAobWFwLCBrZXksIFxuLyogb3V0ICovIHZhbHVlKSB7XG4gICAgaWYgKG1hcCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIGxldCB2YWwgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJ5R2V0VmFsdWVGcm9tTWFwID0gdHJ5R2V0VmFsdWVGcm9tTWFwO1xuZnVuY3Rpb24gdHJ5UGFyc2VJbnQodmFsdWUsIFxuLyogb3V0ICovIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgICBsZXQgdmFsID0gcGFyc2VJbnQodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZhdWx0VmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeVBhcnNlSW50ID0gdHJ5UGFyc2VJbnQ7XG5mdW5jdGlvbiB0cnlQYXJzZUZsb2F0KHZhbHVlLCBcbi8qIG91dCAqLyBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gICAgbGV0IHZhbCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWwsIGV4aXN0czogdHJ1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZhdWx0VmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeVBhcnNlRmxvYXQgPSB0cnlQYXJzZUZsb2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJ5R2V0UmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0VxdWF0YWJsZSA9IGV4cG9ydHMubnVsbElmVW5kZWZpbmVkID0gZXhwb3J0cy5hc0lOYW1lZENvbnRlbnRPck51bGwgPSBleHBvcnRzLmFzTnVtYmVyT3JUaHJvd3MgPSBleHBvcnRzLmFzT3JUaHJvd3MgPSBleHBvcnRzLmFzT3JOdWxsID0gdm9pZCAwO1xuZnVuY3Rpb24gYXNPck51bGwob2JqLCB0eXBlKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNPck51bGwgPSBhc09yTnVsbDtcbmZ1bmN0aW9uIGFzT3JUaHJvd3Mob2JqLCB0eXBlKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmp9IGlzIG5vdCBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzT3JUaHJvd3MgPSBhc09yVGhyb3dzO1xuZnVuY3Rpb24gYXNOdW1iZXJPclRocm93cyhvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29ian0gaXMgbm90IGEgbnVtYmVyYCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc051bWJlck9yVGhyb3dzID0gYXNOdW1iZXJPclRocm93cztcbi8vIFNvIGhlcmUsIGluIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24sIGNvbnRlbnRPYmogaXMgY2FzdGVkIHRvIGFuIElOYW1lZENvbnRlbnRcbi8vIGJ1dCBoZXJlIHdlIHVzZSBqcy1zdHlsZSBkdWNrIHR5cGluZzogaWYgaXQgaW1wbGVtZW50cyB0aGUgc2FtZSBwcm9wcyBhcyB0aGUgaW50ZXJmYWNlLFxuLy8gd2UgdHJlYXQgaXQgYXMgdmFsaWQuXG5mdW5jdGlvbiBhc0lOYW1lZENvbnRlbnRPck51bGwob2JqKSB7XG4gICAgaWYgKG9iai5oYXNWYWxpZE5hbWUgJiYgb2JqLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmFzSU5hbWVkQ29udGVudE9yTnVsbCA9IGFzSU5hbWVkQ29udGVudE9yTnVsbDtcbmZ1bmN0aW9uIG51bGxJZlVuZGVmaW5lZChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmV4cG9ydHMubnVsbElmVW5kZWZpbmVkID0gbnVsbElmVW5kZWZpbmVkO1xuZnVuY3Rpb24gaXNFcXVhdGFibGUodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdHlwZS5FcXVhbHMgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmV4cG9ydHMuaXNFcXVhdGFibGUgPSBpc0VxdWF0YWJsZTtcbmZ1bmN0aW9uIHVuc2FmZVR5cGVBc3NlcnRpb24ob2JqLCB0eXBlKSB7XG4gICAgcmV0dXJuIG9iajtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVBc3NlcnRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhbHVlVHlwZSA9IGV4cG9ydHMuTGlzdFZhbHVlID0gZXhwb3J0cy5WYXJpYWJsZVBvaW50ZXJWYWx1ZSA9IGV4cG9ydHMuRGl2ZXJ0VGFyZ2V0VmFsdWUgPSBleHBvcnRzLlN0cmluZ1ZhbHVlID0gZXhwb3J0cy5GbG9hdFZhbHVlID0gZXhwb3J0cy5JbnRWYWx1ZSA9IGV4cG9ydHMuVmFsdWUgPSBleHBvcnRzLkFic3RyYWN0VmFsdWUgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIEFic3RyYWN0VmFsdWUgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIHN0YXRpYyBDcmVhdGUodmFsLCBwcmVmZXJyZWROdW1iZXJUeXBlKSB7XG4gICAgICAgIC8vIFRoaXMgY29kZSBkb2Vzbid0IGV4aXN0IGluIHVwc3RyZWFtIGFuZCBpcyBzaW1wbHkgaGVyZSB0byBlbmZvcmNlXG4gICAgICAgIC8vIHRoZSBjcmVhdGlvbiBvZiB0aGUgcHJvcGVyIG51bWJlciB2YWx1ZS5cbiAgICAgICAgLy8gSWYgYHByZWZlcnJlZE51bWJlclR5cGVgIGlzIG5vdCBwcm92aWRlZCBvciBpZiB2YWx1ZSBkb2Vzbid0IG1hdGNoXG4gICAgICAgIC8vIGBwcmVmZXJyZWROdW1iZXJUeXBlYCwgdGhpcyBjb25kaXRpb25hbCBkb2VzIG5vdGhpbmcuXG4gICAgICAgIGlmIChwcmVmZXJyZWROdW1iZXJUeXBlKSB7XG4gICAgICAgICAgICBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSA9PT0gVmFsdWVUeXBlLkludCAmJlxuICAgICAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcmVmZXJyZWROdW1iZXJUeXBlID09PSBWYWx1ZVR5cGUuRmxvYXQgJiZcbiAgICAgICAgICAgICAgICAhaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW1wbGljaXRseSBjb252ZXJ0IGJvb2xzIGludG8gaW50c1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGxldCBiID0gISF2YWw7XG4gICAgICAgICAgICB2YWwgPSBiID8gMSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ktbG9oc2UvaW5ranMvaXNzdWVzLzQyNVxuICAgICAgICAvLyBDaGFuZ2VkIGNvbmRpdGlvbiBzZXF1ZW5jZSwgYmVjYXVzZSBOdW1iZXIoJycpIGlzXG4gICAgICAgIC8vIHBhcnNlZCB0byAwLCB3aGljaCBtYWRlIHNldHRpbmcgc3RyaW5nIHRvIGVtcHR5XG4gICAgICAgIC8vIGltcG9zc2libGVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoU3RyaW5nKHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBQYXRoXzEuUGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEaXZlcnRUYXJnZXRWYWx1ZShUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWwsIFBhdGhfMS5QYXRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlzdFZhbHVlKFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhbCwgSW5rTGlzdF8xLklua0xpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKEFic3RyYWN0VmFsdWUuQ3JlYXRlKHRoaXMpLCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgIH1cbiAgICBCYWRDYXN0RXhjZXB0aW9uKHRhcmdldFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2FuJ3QgY2FzdCBcIiArXG4gICAgICAgICAgICB0aGlzLnZhbHVlT2JqZWN0ICtcbiAgICAgICAgICAgIFwiIGZyb20gXCIgK1xuICAgICAgICAgICAgdGhpcy52YWx1ZVR5cGUgK1xuICAgICAgICAgICAgXCIgdG8gXCIgK1xuICAgICAgICAgICAgdGFyZ2V0VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5BYnN0cmFjdFZhbHVlID0gQWJzdHJhY3RWYWx1ZTtcbmNsYXNzIFZhbHVlIGV4dGVuZHMgQWJzdHJhY3RWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgfVxuICAgIGdldCB2YWx1ZU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5WYWx1ZSA9IFZhbHVlO1xuY2xhc3MgSW50VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKHZhbCB8fCAwKTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSAwO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkludDtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIiArIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkludFZhbHVlID0gSW50VmFsdWU7XG5jbGFzcyBGbG9hdFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgMC4wKTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSAhPSAwLjA7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuRmxvYXQ7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIiArIHRoaXMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0VmFsdWUgPSBGbG9hdFZhbHVlO1xuY2xhc3MgU3RyaW5nVmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKHZhbCB8fCBcIlwiKTtcbiAgICAgICAgdGhpcy5faXNOZXdsaW5lID0gdGhpcy52YWx1ZSA9PSBcIlxcblwiO1xuICAgICAgICB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuc3BsaXQoXCJcIikuZXZlcnkoKGMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYyAhPSBcIiBcIiAmJiBjICE9IFwiXFx0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLlN0cmluZztcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBpc05ld2xpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc05ld2xpbmU7XG4gICAgfVxuICAgIGdldCBpc0lubGluZVdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2U7XG4gICAgfVxuICAgIGdldCBpc05vbldoaXRlc3BhY2UoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pc05ld2xpbmUgJiYgIXRoaXMuaXNJbmxpbmVXaGl0ZXNwYWNlO1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRJbnQgPSBUcnlHZXRSZXN1bHRfMS50cnlQYXJzZUludCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShwYXJzZWRJbnQucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRGbG9hdCA9IFRyeUdldFJlc3VsdF8xLnRyeVBhcnNlRmxvYXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRmxvYXQuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKHBhcnNlZEZsb2F0LnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nVmFsdWUgPSBTdHJpbmdWYWx1ZTtcbmNsYXNzIERpdmVydFRhcmdldFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldFBhdGgpIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0UGF0aCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0O1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgc2V0IHRhcmdldFBhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIGRpdmVydCB0YXJnZXRcIik7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJEaXZlcnRUYXJnZXRWYWx1ZShcIiArIHRoaXMudGFyZ2V0UGF0aCArIFwiKVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRGl2ZXJ0VGFyZ2V0VmFsdWUgPSBEaXZlcnRUYXJnZXRWYWx1ZTtcbmNsYXNzIFZhcmlhYmxlUG9pbnRlclZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhcmlhYmxlTmFtZSwgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgc3VwZXIodmFyaWFibGVOYW1lKTtcbiAgICAgICAgdGhpcy5fY29udGV4dEluZGV4ID0gY29udGV4dEluZGV4O1xuICAgIH1cbiAgICBnZXQgY29udGV4dEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dEluZGV4O1xuICAgIH1cbiAgICBzZXQgY29udGV4dEluZGV4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVOYW1lKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFyaWFibGVOYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5WYXJpYWJsZVBvaW50ZXI7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkbid0IGJlIGNoZWNraW5nIHRoZSB0cnV0aGluZXNzIG9mIGEgdmFyaWFibGUgcG9pbnRlclwiKTtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlZhcmlhYmxlUG9pbnRlclZhbHVlKFwiICsgdGhpcy52YXJpYWJsZU5hbWUgKyBcIilcIjtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZVBvaW50ZXJWYWx1ZSh0aGlzLnZhcmlhYmxlTmFtZSwgdGhpcy5jb250ZXh0SW5kZXgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVQb2ludGVyVmFsdWUgPSBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbmNsYXNzIExpc3RWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMudmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuQ291bnQgPiAwO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkxpc3Q7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heEl0ZW07XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZSgwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKG1heC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heEl0ZW07XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKDAuMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKG1heC5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUoXCJcIik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKG1heC5LZXkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihsaXN0T3JTaW5nbGVJdGVtLCBzaW5nbGVWYWx1ZSkge1xuICAgICAgICBzdXBlcihudWxsKTtcbiAgICAgICAgaWYgKCFsaXN0T3JTaW5nbGVJdGVtICYmICFzaW5nbGVWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RPclNpbmdsZUl0ZW0gaW5zdGFuY2VvZiBJbmtMaXN0XzEuSW5rTGlzdCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdChsaXN0T3JTaW5nbGVJdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0T3JTaW5nbGVJdGVtIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3RJdGVtICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2luZ2xlVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3Qoe1xuICAgICAgICAgICAgICAgIEtleTogbGlzdE9yU2luZ2xlSXRlbSxcbiAgICAgICAgICAgICAgICBWYWx1ZTogc2luZ2xlVmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvbGRWYWx1ZSwgTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IG5ld0xpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwobmV3VmFsdWUsIExpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChuZXdMaXN0ICYmIG5ld0xpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5ld0xpc3QudmFsdWVcIik7XG4gICAgICAgIGlmIChvbGRMaXN0ICYmIG9sZExpc3QudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9sZExpc3QudmFsdWVcIik7XG4gICAgICAgIC8vIFdoZW4gYXNzaWduaW5nIHRoZSBlbXB0eSBsaXN0LCB0cnkgdG8gcmV0YWluIGFueSBpbml0aWFsIG9yaWdpbiBuYW1lc1xuICAgICAgICBpZiAob2xkTGlzdCAmJiBuZXdMaXN0ICYmIG5ld0xpc3QudmFsdWUuQ291bnQgPT0gMClcbiAgICAgICAgICAgIG5ld0xpc3QudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG9sZExpc3QudmFsdWUub3JpZ2luTmFtZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdFZhbHVlID0gTGlzdFZhbHVlO1xudmFyIFZhbHVlVHlwZTtcbihmdW5jdGlvbiAoVmFsdWVUeXBlKSB7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkludFwiXSA9IDBdID0gXCJJbnRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiRmxvYXRcIl0gPSAxXSA9IFwiRmxvYXRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiTGlzdFwiXSA9IDJdID0gXCJMaXN0XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIlN0cmluZ1wiXSA9IDNdID0gXCJTdHJpbmdcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiRGl2ZXJ0VGFyZ2V0XCJdID0gNF0gPSBcIkRpdmVydFRhcmdldFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJWYXJpYWJsZVBvaW50ZXJcIl0gPSA1XSA9IFwiVmFyaWFibGVQb2ludGVyXCI7XG59KShWYWx1ZVR5cGUgPSBleHBvcnRzLlZhbHVlVHlwZSB8fCAoZXhwb3J0cy5WYWx1ZVR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlQXNzaWdubWVudCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgVmFyaWFibGVBc3NpZ25tZW50IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZU5hbWUsIGlzTmV3RGVjbGFyYXRpb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWUgPSB2YXJpYWJsZU5hbWUgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pc05ld0RlY2xhcmF0aW9uID0gISFpc05ld0RlY2xhcmF0aW9uO1xuICAgICAgICB0aGlzLmlzR2xvYmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJWYXJBc3NpZ24gdG8gXCIgKyB0aGlzLnZhcmlhYmxlTmFtZTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlQXNzaWdubWVudCA9IFZhcmlhYmxlQXNzaWdubWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlQXNzaWdubWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVSZWZlcmVuY2UgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jbGFzcyBWYXJpYWJsZVJlZmVyZW5jZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IobmFtZSA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXRoRm9yQ291bnQgPSBudWxsO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQgY29udGFpbmVyRm9yQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhGb3JDb3VudCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLnBhdGhGb3JDb3VudCkuY29udGFpbmVyO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ0ZvckNvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoRm9yQ291bnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoRm9yQ291bnQpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ0ZvckNvdW50KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5wYXRoRm9yQ291bnQgPSBuZXcgUGF0aF8xLlBhdGgodmFsdWUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ2YXIoXCIgKyB0aGlzLm5hbWUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwYXRoU3RyID0gdGhpcy5wYXRoU3RyaW5nRm9yQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gXCJyZWFkX2NvdW50KFwiICsgcGF0aFN0ciArIFwiKVwiO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZVJlZmVyZW5jZSA9IFZhcmlhYmxlUmVmZXJlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVSZWZlcmVuY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlc1N0YXRlID0gdm9pZCAwO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIFZhcmlhYmxlc1N0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsU3RhY2ssIGxpc3REZWZzT3JpZ2luKSB7XG4gICAgICAgIC8vIFRoZSB3YXkgdmFyaWFibGVDaGFuZ2VkRXZlbnQgaXMgYSBiaXQgZGlmZmVyZW50IHRoYW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gT3JpZ2luYWxseSBpdCB1c2VzIHRoZSBDIyArPSBvcGVyYXRvciB0byBhZGQgZGVsZWdhdGVzLCBidXQgaW4ganMgd2UgbmVlZCB0byBtYWludGFpblxuICAgICAgICAvLyBhbiBhY3R1YWwgY29sbGVjdGlvbiBvZiBkZWxlZ2F0ZXMgKGllLiBjYWxsYmFja3MpIHRvIHJlZ2lzdGVyIGEgbmV3IG9uZSwgdGhlcmUgaXMgYVxuICAgICAgICAvLyBzcGVjaWFsIE9ic2VydmVWYXJpYWJsZUNoYW5nZSBtZXRob2QgYmVsb3cuXG4gICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5wYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jYWxsU3RhY2sgPSBjYWxsU3RhY2s7XG4gICAgICAgIHRoaXMuX2xpc3REZWZzT3JpZ2luID0gbGlzdERlZnNPcmlnaW47XG4gICAgICAgIC8vIGlmIGVzNiBwcm94aWVzIGFyZSBhdmFpbGFibGUsIHVzZSB0aGVtLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGhlIHByb3h5IGlzIHVzZWQgdG8gYWxsb3cgZGlyZWN0IG1hbmlwdWxhdGlvbiBvZiBnbG9iYWwgdmFyaWFibGVzLlxuICAgICAgICAgICAgLy8gSXQgZmlyc3QgdHJpZXMgdG8gYWNjZXNzIHRoZSBvYmplY3RzIG93biBwcm9wZXJ0eSwgYW5kIGlmIG5vbmUgaXNcbiAgICAgICAgICAgIC8vIGZvdW5kIGl0IGRlbGVnYXRlcyB0aGUgY2FsbCB0byB0aGUgJCBtZXRob2QsIGRlZmluZWQgYmVsb3dcbiAgICAgICAgICAgIGxldCBwID0gbmV3IFByb3h5KHRoaXMsIHtcbiAgICAgICAgICAgICAgICBnZXQodGFyZ2V0LCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lIGluIHRhcmdldCA/IHRhcmdldFtuYW1lXSA6IHRhcmdldC4kKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0KHRhcmdldCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgaW4gdGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC4kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHJldHVybmluZyBhIGZhbHN5IHZhbHVlIG1ha2UgdGhlIHRyYXAgZmFpbFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyB0aHIgcHJveHkgb2JqZWN0IGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBjb250ZXh0LiB3ZSBzaG91bGQgd2FybiB0aGVcbiAgICAgICAgICAgIC8vIGRldiBidXQgd3JpdHRpbmcgdG8gdGhlIGNvbnNvbGUgZmVlbHMgYSBiaXQgaW50cnVzaXZlLlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJFUzYgUHJveHkgbm90IGF2YWlsYWJsZSAtIGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgZ2xvYmFsIHZhcmlhYmxlcyBjYW4ndCB3b3JrLCB1c2UgJCgpIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgY2FsbGJhY2sgb2YgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2sodmFyaWFibGVOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM7XG4gICAgfVxuICAgIHNldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHZhcmlhYmxlTmFtZSBvZiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjdXJyZW50VmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYWxsU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhY2s7XG4gICAgfVxuICAgIHNldCBjYWxsU3RhY2soY2FsbFN0YWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxTdGFjayA9IGNhbGxTdGFjaztcbiAgICB9XG4gICAgLy8gdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBhIG1hZ2ljIGdldHRlciBhbmQgc2V0dGVyIGZvciBnbG9iYWwgdmFyaWFibGVzLFxuICAgIC8vIGFsbG93aW5nIHRoaW5ncyBsaWtlIHZhcmlhYmxlU3RhdGVbJ3Zhcm5hbWVdLiBUaGlzIGlzIG5vdCBxdWl0ZSBwb3NzaWJsZVxuICAgIC8vIGluIGpzIHdpdGhvdXQgYSBQcm94eSwgc28gaXQgaXMgcmVwbGFjZWQgd2l0aCB0aGlzICQgZnVuY3Rpb24uXG4gICAgJCh2YXJpYWJsZU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCB2YXJDb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyQ29udGVudHMuZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29udGVudHMucmVzdWx0LnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyQ29udGVudHMgPSB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhckNvbnRlbnRzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyQ29udGVudHMgPSB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJDb250ZW50cyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyQ29udGVudHMudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSkgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgYXNzaWduIHRvIGEgdmFyaWFibGUgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCIpIHRoYXQgaGFzbid0IGJlZW4gZGVjbGFyZWQgaW4gdGhlIHN0b3J5XCIpO1xuICAgICAgICAgICAgbGV0IHZhbCA9IFZhbHVlXzEuVmFsdWUuQ3JlYXRlKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IHBhc3MgbnVsbCB0byBWYXJpYWJsZVN0YXRlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBWYXJpYWJsZVN0YXRlOiBcIiArIHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcHBseVBhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnBhdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IFtuYW1lZFZhcktleSwgbmFtZWRWYXJWYWx1ZV0gb2YgdGhpcy5wYXRjaC5nbG9iYWxzKSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KG5hbWVkVmFyS2V5LCBuYW1lZFZhclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHRoaXMucGF0Y2guY2hhbmdlZFZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRjaCA9IG51bGw7XG4gICAgfVxuICAgIFNldEpzb25Ub2tlbihqVG9rZW4pIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmNsZWFyKCk7XG4gICAgICAgIGZvciAobGV0IFt2YXJWYWxLZXksIHZhclZhbFZhbHVlXSBvZiB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzKSB7XG4gICAgICAgICAgICBsZXQgbG9hZGVkVG9rZW4gPSBqVG9rZW5bdmFyVmFsS2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9hZGVkVG9rZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5JbmtPYmplY3QgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpUb2tlblRvUnVudGltZU9iamVjdChsb2FkZWRUb2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuSW5rT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidG9rZW5JbmtPYmplY3RcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodmFyVmFsS2V5LCB0b2tlbklua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhclZhbEtleSwgdmFyVmFsVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFdyaXRlSnNvbih3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleVZhbEtleSwga2V5VmFsVmFsdWVdIG9mIHRoaXMuX2dsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXlWYWxLZXk7XG4gICAgICAgICAgICBsZXQgdmFsID0ga2V5VmFsVmFsdWU7XG4gICAgICAgICAgICBpZiAoVmFyaWFibGVzU3RhdGUuZG9udFNhdmVEZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0VmFsID0gdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLlJ1bnRpbWVPYmplY3RzRXF1YWwodmFsLCBkZWZhdWx0VmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIHZhbCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBSdW50aW1lT2JqZWN0c0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKG9iajEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqMVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmoyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBpZiAoaW50VmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50VmFsLnZhbHVlID09PSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvYmoyLCBWYWx1ZV8xLkludFZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxvYXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMSwgVmFsdWVfMS5GbG9hdFZhbHVlKTtcbiAgICAgICAgaWYgKGZsb2F0VmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxvYXRWYWwudmFsdWUgPT09IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9iajIsIFZhbHVlXzEuRmxvYXRWYWx1ZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbDEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGxldCB2YWwyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajIsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBpZiAodmFsMSAhPT0gbnVsbCAmJiB2YWwyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoVHlwZUFzc2VydGlvbl8xLmlzRXF1YXRhYmxlKHZhbDEudmFsdWVPYmplY3QpICYmIFR5cGVBc3NlcnRpb25fMS5pc0VxdWF0YWJsZSh2YWwyLnZhbHVlT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwxLnZhbHVlT2JqZWN0LkVxdWFscyh2YWwyLnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwxLnZhbHVlT2JqZWN0ID09PSB2YWwyLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhc3RSb3VnaERlZmluaXRlbHlFcXVhbHM6IFVuc3VwcG9ydGVkIHJ1bnRpbWUgb2JqZWN0IHR5cGU6IFwiICtcbiAgICAgICAgICAgIG9iajEuY29uc3RydWN0b3IubmFtZSk7XG4gICAgfVxuICAgIEdldFZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgbGV0IHZhclZhbHVlID0gdGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIC8vIHZhciB2YXJQb2ludGVyID0gdmFyVmFsdWUgYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhclZhbHVlLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKHZhclBvaW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhclZhbHVlID0gdGhpcy5WYWx1ZUF0VmFyaWFibGVQb2ludGVyKHZhclBvaW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJWYWx1ZTtcbiAgICB9XG4gICAgVHJ5R2V0RGVmYXVsdFZhcmlhYmxlVmFsdWUobmFtZSkge1xuICAgICAgICBsZXQgdmFsID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICByZXR1cm4gdmFsLmV4aXN0cyA/IHZhbC5yZXN1bHQgOiBudWxsO1xuICAgIH1cbiAgICBHbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuaGFzKG5hbWUpKSk7XG4gICAgfVxuICAgIEdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KSB7XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gMCB8fCBjb250ZXh0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCB2YXJpYWJsZVZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IHRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGNvbmRpdGlvbmFsIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUuZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdERlZnNPcmlnaW4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYXJpYWJsZXNTdGF0ZS5fbGlzdERlZnNPcmlnaW5cIik7XG4gICAgICAgICAgICBsZXQgbGlzdEl0ZW1WYWx1ZSA9IHRoaXMuX2xpc3REZWZzT3JpZ2luLkZpbmRTaW5nbGVJdGVtTGlzdFdpdGhOYW1lKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGxpc3RJdGVtVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RJdGVtVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyVmFsdWUgPSB0aGlzLl9jYWxsU3RhY2suR2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdmFyVmFsdWU7XG4gICAgfVxuICAgIFZhbHVlQXRWYXJpYWJsZVBvaW50ZXIocG9pbnRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5HZXRWYXJpYWJsZVdpdGhOYW1lKHBvaW50ZXIudmFyaWFibGVOYW1lLCBwb2ludGVyLmNvbnRleHRJbmRleCk7XG4gICAgfVxuICAgIEFzc2lnbih2YXJBc3MsIHZhbHVlKSB7XG4gICAgICAgIGxldCBuYW1lID0gdmFyQXNzLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGV4dEluZGV4ID0gLTE7XG4gICAgICAgIGxldCBzZXRHbG9iYWwgPSBmYWxzZTtcbiAgICAgICAgaWYgKHZhckFzcy5pc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBzZXRHbG9iYWwgPSB2YXJBc3MuaXNHbG9iYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRHbG9iYWwgPSB0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhckFzcy5pc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IHZhbHVlIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgbGV0IHZhclBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhclBvaW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVsbHlSZXNvbHZlZFZhcmlhYmxlUG9pbnRlciA9IHRoaXMuUmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZ1bGx5UmVzb2x2ZWRWYXJpYWJsZVBvaW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZ1BvaW50ZXIgPSBHZXRSYXdWYXJpYWJsZVdpdGhOYW1lIChuYW1lLCBjb250ZXh0SW5kZXgpIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KSwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nUG9pbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBleGlzdGluZ1BvaW50ZXIudmFyaWFibGVOYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0SW5kZXggPSBleGlzdGluZ1BvaW50ZXIuY29udGV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBzZXRHbG9iYWwgPSBjb250ZXh0SW5kZXggPT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChleGlzdGluZ1BvaW50ZXIgIT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldEdsb2JhbCkge1xuICAgICAgICAgICAgdGhpcy5TZXRHbG9iYWwobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY2FsbFN0YWNrLlNldFRlbXBvcmFyeVZhcmlhYmxlKG5hbWUsIHZhbHVlLCB2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbiwgY29udGV4dEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTbmFwc2hvdERlZmF1bHRHbG9iYWxzKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMpO1xuICAgIH1cbiAgICBSZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCBvbGRMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2xkVmFsdWUsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IG5ld0xpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuZXdWYWx1ZSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBpZiAob2xkTGlzdC52YWx1ZSAmJiBuZXdMaXN0LnZhbHVlICYmIG5ld0xpc3QudmFsdWUuQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgbmV3TGlzdC52YWx1ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXMob2xkTGlzdC52YWx1ZS5vcmlnaW5OYW1lcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcywgdmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSB0aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKCFvbGRWYWx1ZS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsIHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVmFsdWVfMS5MaXN0VmFsdWUuUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLnJlc3VsdCwgdmFsdWUpO1xuICAgICAgICBpZiAodmFyaWFibGVOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInZhcmlhYmxlTmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5wYXRjaC5TZXRHbG9iYWwodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IE5vdCBzdXJlICE9PSBpcyBlcXVpdmFsZW50IHRvICF2YWx1ZS5FcXVhbHMob2xkVmFsdWUpXG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50ICE9PSBudWxsICYmXG4gICAgICAgICAgICBvbGRWYWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG9sZFZhbHVlLnJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGNoLkFkZENoYW5nZWRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzLmFkZCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKSB7XG4gICAgICAgIGxldCBjb250ZXh0SW5kZXggPSB2YXJQb2ludGVyLmNvbnRleHRJbmRleDtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IHRoaXMuR2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHZhclBvaW50ZXIudmFyaWFibGVOYW1lKTtcbiAgICAgICAgbGV0IHZhbHVlT2ZWYXJpYWJsZVBvaW50ZWRUbyA9IHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZSh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgLy8gdmFyIGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciA9IHZhbHVlT2ZWYXJpYWJsZVBvaW50ZWRUbyBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgbGV0IGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8sIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICBpZiAoZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUodmFyUG9pbnRlci52YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHZhck5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh2YXJOYW1lKSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50SW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgc3BlY2lmaWMgdG8gdGhlIGpzIHZlcnNpb24gb2YgaW5rLiBJdCBhbGxvd3MgdG8gcmVnaXN0ZXIgYVxuICAgICAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiBhIHZhcmlhYmxlIGNoYW5nZXMuIFRoZSBvcmlnaW5hbCBjb2RlIHVzZXNcbiAgICAgKiBgc3RhdGUudmFyaWFibGVDaGFuZ2VkRXZlbnQgKz0gY2FsbGJhY2tgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIE9ic2VydmVWYXJpYWJsZUNoYW5nZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVzU3RhdGUgPSBWYXJpYWJsZXNTdGF0ZTtcblZhcmlhYmxlc1N0YXRlLmRvbnRTYXZlRGVmYXVsdFZhbHVlcyA9IHRydWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZXNTdGF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVm9pZCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgVm9pZCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG59XG5leHBvcnRzLlZvaWQgPSBWb2lkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vm9pZC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IExvbmc7XHJcblxyXG4vKipcclxuICogd2FzbSBvcHRpbWl6YXRpb25zLCB0byBkbyBuYXRpdmUgaTY0IG11bHRpcGxpY2F0aW9uIGFuZCBkaXZpZGVcclxuICovXHJcbnZhciB3YXNtID0gbnVsbDtcclxuXHJcbnRyeSB7XHJcbiAgd2FzbSA9IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKG5ldyBVaW50OEFycmF5KFtcclxuICAgIDAsIDk3LCAxMTUsIDEwOSwgMSwgMCwgMCwgMCwgMSwgMTMsIDIsIDk2LCAwLCAxLCAxMjcsIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNywgMywgNywgNiwgMCwgMSwgMSwgMSwgMSwgMSwgNiwgNiwgMSwgMTI3LCAxLCA2NSwgMCwgMTEsIDcsIDUwLCA2LCAzLCAxMDksIDExNywgMTA4LCAwLCAxLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLCA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LCA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LCA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLCAxMCwgMTkxLCAxLCA2LCA0LCAwLCAzNSwgMCwgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI3LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjgsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTMwLCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExXHJcbiAgXSkpLCB7fSkuZXhwb3J0cztcclxufSBjYXRjaCAoZSkge1xyXG4gIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxyXG59XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIsIGdpdmVuIGl0cyBsb3cgYW5kIGhpZ2ggMzIgYml0IHZhbHVlcyBhcyAqc2lnbmVkKiBpbnRlZ2Vycy5cclxuICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXHJcbiAqIEBleHBvcnRzIExvbmdcclxuICogQGNsYXNzIEEgTG9uZyBjbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciB2YWx1ZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdC5cclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICB0aGlzLnVuc2lnbmVkID0gISF1bnNpZ25lZDtcclxufVxyXG5cclxuLy8gVGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgbG9uZyBpcyB0aGUgdHdvIGdpdmVuIHNpZ25lZCwgMzItYml0IHZhbHVlcy5cclxuLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcclxuLy8gSmF2YXNjcmlwdCBwZXJmb3JtcyBiaXQtb3BlcmF0aW9ucy4gIEZvciBvcGVyYXRpb25zIGxpa2UgYWRkaXRpb24gYW5kXHJcbi8vIG11bHRpcGxpY2F0aW9uLCB3ZSBzcGxpdCBlYWNoIG51bWJlciBpbnRvIDE2IGJpdCBwaWVjZXMsIHdoaWNoIGNhbiBlYXNpbHkgYmVcclxuLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcclxuLy8gb3IgY2hhbmdlIGluIHNpZ24uXHJcbi8vXHJcbi8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcclxuLy8gcG9zaXRpdmUgY2FzZSBieSBuZWdhdGluZyB0aGUgaW5wdXQocykgYW5kIHRoZW4gcG9zdC1wcm9jZXNzaW5nIHRoZSByZXN1bHQuXHJcbi8vIE5vdGUgdGhhdCB3ZSBtdXN0IEFMV0FZUyBjaGVjayBzcGVjaWFsbHkgd2hldGhlciB0aG9zZSB2YWx1ZXMgYXJlIE1JTl9WQUxVRVxyXG4vLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXHJcbi8vIGEgcG9zaXRpdmUgbnVtYmVyLCBpdCBvdmVyZmxvd3MgYmFjayBpbnRvIGEgbmVnYXRpdmUpLiAgTm90IGhhbmRsaW5nIHRoaXNcclxuLy8gY2FzZSB3b3VsZCBvZnRlbiByZXN1bHQgaW4gaW5maW5pdGUgcmVjdXJzaW9uLlxyXG4vL1xyXG4vLyBDb21tb24gY29uc3RhbnQgdmFsdWVzIFpFUk8sIE9ORSwgTkVHX09ORSwgZXRjLiBhcmUgZGVmaW5lZCBiZWxvdyB0aGUgZnJvbSpcclxuLy8gbWV0aG9kcyBvbiB3aGljaCB0aGV5IGRlcGVuZC5cclxuXHJcbi8qKlxyXG4gKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXHJcbiAqIEB0eXBlIHtib29sZWFufVxyXG4gKiBAY29uc3RcclxuICogQHByaXZhdGVcclxuICovXHJcbkxvbmcucHJvdG90eXBlLl9faXNMb25nX187XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9uZy5wcm90b3R5cGUsIFwiX19pc0xvbmdfX1wiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gaXNMb25nKG9iaikge1xyXG4gICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nLmlzTG9uZyA9IGlzTG9uZztcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIElOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVUlOVF9DQUNIRSA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICB2YWx1ZSA+Pj49IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YWx1ZSB8PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBJTlRfQ0FDSEVbdmFsdWVdO1xyXG4gICAgICAgICAgICBpZiAoY2FjaGVkT2JqKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2JqID0gZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUludCA9IGZyb21JbnQ7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKGlzTmFOKHZhbHVlKSlcclxuICAgICAgICByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICBpZiAodW5zaWduZWQpIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPCAwKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKC12YWx1ZSwgdW5zaWduZWQpLm5lZygpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKCh2YWx1ZSAlIFRXT19QV1JfMzJfREJMKSB8IDAsICh2YWx1ZSAvIFRXT19QV1JfMzJfREJMKSB8IDAsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tTnVtYmVyID0gZnJvbU51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIDY0IGJpdCBpbnRlZ2VyIHRoYXQgY29tZXMgYnkgY29uY2F0ZW5hdGluZyB0aGUgZ2l2ZW4gbG93IGFuZCBoaWdoIGJpdHMuIEVhY2ggaXNcclxuICogIGFzc3VtZWQgdG8gdXNlIDMyIGJpdHMuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93Qml0cyBUaGUgbG93IDMyIGJpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzIFRoZSBoaWdoIDMyIGJpdHNcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIHBvd19kYmwgPSBNYXRoLnBvdzsgLy8gVXNlZCA0IHRpbWVzICg0KjggdG8gMTUrNClcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXhcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcclxuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdlbXB0eSBzdHJpbmcnKTtcclxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIilcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgLy8gRm9yIGdvb2cubWF0aC5sb25nIGNvbXBhdGliaWxpdHlcclxuICAgICAgICByYWRpeCA9IHVuc2lnbmVkLFxyXG4gICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHVuc2lnbmVkID0gISEgdW5zaWduZWQ7XHJcbiAgICB9XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcblxyXG4gICAgdmFyIHA7XHJcbiAgICBpZiAoKHAgPSBzdHIuaW5kZXhPZignLScpKSA+IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO1xyXG4gICAgZWxzZSBpZiAocCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoOCkgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA4KSk7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IFpFUk87XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gOCkge1xyXG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxyXG4gICAgICAgICAgICB2YWx1ZSA9IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSwgaSArIHNpemUpLCByYWRpeCk7XHJcbiAgICAgICAgaWYgKHNpemUgPCA4KSB7XHJcbiAgICAgICAgICAgIHZhciBwb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgc2l6ZSkpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tVmFsdWUodmFsLCB1bnNpZ25lZCkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKVxyXG4gICAgICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpO1xyXG4gICAgLy8gVGhyb3dzIGZvciBub24tb2JqZWN0cywgY29udmVydHMgbm9uLWluc3RhbmNlb2YgTG9uZzpcclxuICAgIHJldHVybiBmcm9tQml0cyh2YWwubG93LCB2YWwuaGlnaCwgdHlwZW9mIHVuc2lnbmVkID09PSAnYm9vbGVhbicgPyB1bnNpZ25lZCA6IHZhbC51bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLmZyb21WYWx1ZSA9IGZyb21WYWx1ZTtcclxuXHJcbi8vIE5PVEU6IHRoZSBjb21waWxlciBzaG91bGQgaW5saW5lIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiZWxvdyBhbmQgdGhlbiByZW1vdmUgdGhlc2UgdmFyaWFibGVzLCBzbyB0aGVyZSBzaG91bGQgYmVcclxuLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0X0RCTCA9IDEgPDwgMjQ7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzYzX0RCTCA9IFRXT19QV1JfNjRfREJMIC8gMjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBaRVJPID0gZnJvbUludCgwKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5aRVJPID0gWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVaRVJPID0gVVpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBPTkUgPSBmcm9tSW50KDEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuT05FID0gT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVU9ORSA9IGZyb21JbnQoMSwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlVPTkUgPSBVT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCBuZWdhdGl2ZSBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTkVHX09ORSA9IE5FR19PTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4N0ZGRkZGRkZ8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHhGRkZGRkZGRnwwLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1JTl9WQUxVRSA9IGZyb21CaXRzKDAsIDB4ODAwMDAwMDB8MCwgZmFsc2UpO1xyXG5cclxuLyoqXHJcbiAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcclxuXHJcbi8qKlxyXG4gKiBAYWxpYXMgTG9uZy5wcm90b3R5cGVcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgMzIgYml0IGludGVnZXIsIGFzc3VtaW5nIGl0IGlzIGEgMzIgYml0IGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gdG9JbnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gKCh0aGlzLmhpZ2ggPj4+IDApICogVFdPX1BXUl8zMl9EQkwpICsgKHRoaXMubG93ID4+PiAwKTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFJhZGl4ICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQG92ZXJyaWRlXHJcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IElmIGByYWRpeGAgaXMgb3V0IG9mIHJhbmdlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcocmFkaXgpIHtcclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiAnMCc7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGNoYW5nZSB0aGUgTG9uZyB2YWx1ZSBiZWZvcmUgaXQgY2FuIGJlIG5lZ2F0ZWQsIHNvIHdlIHJlbW92ZVxyXG4gICAgICAgICAgICAvLyB0aGUgYm90dG9tLW1vc3QgZGlnaXQgaW4gdGhpcyBiYXNlIGFuZCB0aGVuIHJlY3Vyc2UgdG8gZG8gdGhlIHJlc3QuXHJcbiAgICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcclxuICAgICAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXHJcbiAgICAgICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gJy0nICsgdGhpcy5uZWcoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xyXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXHJcbiAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXHJcbiAgICAgICAgcmVtID0gdGhpcztcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKSxcclxuICAgICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgcmVtID0gcmVtRGl2O1xyXG4gICAgICAgIGlmIChyZW0uaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcclxuICAgICAgICAgICAgICAgIGRpZ2l0cyA9ICcwJyArIGRpZ2l0cztcclxuICAgICAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzID0gZnVuY3Rpb24gZ2V0TG93Qml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBVbnNpZ25lZCBsb3cgYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXROdW1CaXRzQWJzID0gZnVuY3Rpb24gZ2V0TnVtQml0c0FicygpIHtcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcclxuICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSlcclxuICAgICAgICBpZiAoKHZhbCAmICgxIDw8IGJpdCkpICE9IDApXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAhPSAwID8gYml0ICsgMzMgOiBiaXQgKyAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNpc1plcm99LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF6ID0gTG9uZ1Byb3RvdHlwZS5pc1plcm87XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcclxuICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc09kZCA9IGZ1bmN0aW9uIGlzT2RkKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGV2ZW4uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmICh0aGlzLmhpZ2ggPj4+IDMxKSA9PT0gMSAmJiAob3RoZXIuaGlnaCA+Pj4gMzEpID09PSAxKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xyXG4gICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubmUgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbiA9IGZ1bmN0aW9uIGxlc3NUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPCAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHQgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGxlc3NUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDw9IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubHRlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbiA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3QgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbCA9IGZ1bmN0aW9uIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3RlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy5lcShvdGhlcikpXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxyXG4gICAgICAgIG90aGVyTmVnID0gb3RoZXIuaXNOZWdhdGl2ZSgpO1xyXG4gICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gMTtcclxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHNpZ24gYml0cyBhcmUgdGhlIHNhbWVcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWIob3RoZXIpLmlzTmVnYXRpdmUoKSA/IC0xIDogMTtcclxuICAgIC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxyXG4gICAgcmV0dXJuIChvdGhlci5oaWdoID4+PiAwKSA+ICh0aGlzLmhpZ2ggPj4+IDApIHx8IChvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgKG90aGVyLmxvdyA+Pj4gMCkgPiAodGhpcy5sb3cgPj4+IDApKSA/IC0xIDogMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXAgPSBMb25nUHJvdG90eXBlLmNvbXBhcmU7XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS5cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmIHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gTUlOX1ZBTFVFO1xyXG4gICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XHJcbn07XHJcblxyXG4vKipcclxuICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc3VtIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU3VtXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcclxuICAgIGlmICghaXNMb25nKGFkZGVuZCkpXHJcbiAgICAgICAgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbnVtYmVyIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gc3VtIHRoZSBjaHVua3MuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gYWRkZW5kLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IGFkZGVuZC5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiArIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKyBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSlcclxuICAgICAgICBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xyXG4gICAgcmV0dXJuIHRoaXMuYWRkKHN1YnRyYWhlbmQubmVnKCkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWIgPSBMb25nUHJvdG90eXBlLnN1YnRyYWN0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseShtdWx0aXBsaWVyKSB7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICghaXNMb25nKG11bHRpcGxpZXIpKVxyXG4gICAgICAgIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSB3YXNtLm11bCh0aGlzLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmxvdyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5oaWdoKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuICAgIGlmIChtdWx0aXBsaWVyLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcblxyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllci5uZWcoKSk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XHJcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLm11bChtdWx0aXBsaWVyLm5lZygpKS5uZWcoKTtcclxuXHJcbiAgICAvLyBJZiBib3RoIGxvbmdzIGFyZSBzbWFsbCwgdXNlIGZsb2F0IG11bHRpcGxpY2F0aW9uXHJcbiAgICBpZiAodGhpcy5sdChUV09fUFdSXzI0KSAmJiBtdWx0aXBsaWVyLmx0KFRXT19QV1JfMjQpKVxyXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7XHJcblxyXG4gICAgLy8gRGl2aWRlIGVhY2ggbG9uZyBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIGFkZCB1cCA0eDQgcHJvZHVjdHMuXHJcbiAgICAvLyBXZSBjYW4gc2tpcCBwcm9kdWN0cyB0aGF0IHdvdWxkIG92ZXJmbG93LlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gbXVsdGlwbGllci5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGIxNiA9IG11bHRpcGxpZXIubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKiBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICogYjAwO1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGEwMCAqIGIxNjtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMzIgKiBiMDA7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTE2ICogYjE2O1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEwMCAqIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbXVsdGlwbHl9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXHJcbiAqICB1bnNpZ25lZCBpZiB0aGlzIExvbmcgaXMgdW5zaWduZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcbiAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcclxuICAgICAgICB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBuZWdhdGl2ZSBudW1iZXIgLyAtMSB3b3VsZCBiZSAxIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cclxuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5oaWdoID09PSAtMHg4MDAwMDAwMCAmJlxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiYgZGl2aXNvci5oaWdoID09PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLmRpdl91IDogd2FzbS5kaXZfcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xyXG4gICAgICAgIC8vIFRoaXMgc2VjdGlvbiBpcyBvbmx5IHJlbGV2YW50IGZvciBzaWduZWQgbG9uZ3MgYW5kIGlzIGRlcml2ZWQgZnJvbSB0aGVcclxuICAgICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmVxKE9ORSkgfHwgZGl2aXNvci5lcShORUdfT05FKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7ICAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gT05FO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgfG90aGVyfCA+PSAyLCBzbyB8dGhpcy9vdGhlcnwgPCB8TUlOX1ZBTFVFfC5cclxuICAgICAgICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xyXG4gICAgICAgICAgICAgICAgYXBwcm94ID0gaGFsZlRoaXMuZGl2KGRpdmlzb3IpLnNobCgxKTtcclxuICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGl2aXNvci5pc05lZ2F0aXZlKCkgPyBPTkUgOiBORUdfT05FO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBhcHByb3guYWRkKHJlbS5kaXYoZGl2aXNvcikpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yLm5lZygpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpdihkaXZpc29yLm5lZygpKS5uZWcoKTtcclxuICAgICAgICByZXMgPSBaRVJPO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcclxuICAgICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXHJcbiAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxyXG4gICAgICAgICAgICBkaXZpc29yID0gZGl2aXNvci50b1Vuc2lnbmVkKCk7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxyXG4gICAgICAgICAgICByZXR1cm4gVU9ORTtcclxuICAgICAgICByZXMgPSBVWkVSTztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXBlYXQgdGhlIGZvbGxvd2luZyB1bnRpbCB0aGUgcmVtYWluZGVyIGlzIGxlc3MgdGhhbiBvdGhlcjogIGZpbmQgYVxyXG4gICAgLy8gZmxvYXRpbmctcG9pbnQgdGhhdCBhcHByb3hpbWF0ZXMgcmVtYWluZGVyIC8gb3RoZXIgKmZyb20gYmVsb3cqLCBhZGQgdGhpc1xyXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxyXG4gICAgLy8gdGhlIGFwcHJveGltYXRlIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgcmVhbCB2YWx1ZSBzbyB0aGF0IHRoZVxyXG4gICAgLy8gcmVtYWluZGVyIG5ldmVyIGJlY29tZXMgbmVnYXRpdmUuXHJcbiAgICByZW0gPSB0aGlzO1xyXG4gICAgd2hpbGUgKHJlbS5ndGUoZGl2aXNvcikpIHtcclxuICAgICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXHJcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXHJcbiAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xyXG5cclxuICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXHJcbiAgICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxyXG4gICAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXHJcbiAgICAgICAgICAgIGRlbHRhID0gKGxvZzIgPD0gNDgpID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcclxuXHJcbiAgICAgICAgLy8gRGVjcmVhc2UgdGhlIGFwcHJveGltYXRpb24gdW50aWwgaXQgaXMgc21hbGxlciB0aGFuIHRoZSByZW1haW5kZXIuICBOb3RlXHJcbiAgICAgICAgLy8gdGhhdCBpZiBpdCBpcyB0b28gbGFyZ2UsIHRoZSBwcm9kdWN0IG92ZXJmbG93cyBhbmQgaXMgbmVnYXRpdmUuXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xyXG4gICAgICAgICAgICBhcHByb3ggLT0gZGVsdGE7XHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94LCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxyXG4gICAgICAgIC8vIGluZmluaXRlIHJlY3Vyc2lvbiBzaW5jZSB3ZSB3b3VsZCBtYWtlIG5vIHByb2dyZXNzLlxyXG4gICAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpXHJcbiAgICAgICAgICAgIGFwcHJveFJlcyA9IE9ORTtcclxuXHJcbiAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xyXG4gICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2RpdmlkZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5yZW1fdSA6IHdhc20ucmVtX3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLnN1Yih0aGlzLmRpdihkaXZpc29yKS5tdWwoZGl2aXNvcikpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tb2QgPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUucmVtID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBOT1Qgb2YgdGhpcyBMb25nLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcclxuICAgIHJldHVybiBmcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgQU5EIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBYT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgZ2l2ZW4gb25lLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0TGVmdCA9IGZ1bmN0aW9uIHNoaWZ0TGVmdChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzLCAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiAoMzIgLSBudW1CaXRzKSksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdExlZnR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBudW1CaXRzICY9IDYzO1xyXG4gICAgaWYgKG51bUJpdHMgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMuaGlnaDtcclxuICAgICAgICBpZiAobnVtQml0cyA8IDMyKSB7XHJcbiAgICAgICAgICAgIHZhciBsb3cgPSB0aGlzLmxvdztcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICB9IGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoaGlnaCA+Pj4gKG51bUJpdHMgLSAzMiksIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvU2lnbmVkID0gZnVuY3Rpb24gdG9TaWduZWQoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byB1bnNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvVW5zaWduZWQgPSBmdW5jdGlvbiB0b1Vuc2lnbmVkKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uIHRvQnl0ZXMobGUpIHtcclxuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDI0XHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xyXG4gICAgdmFyIGhpID0gdGhpcy5oaWdoLFxyXG4gICAgICAgIGxvID0gdGhpcy5sb3c7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIGhpID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBsbyA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZlxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcclxuICAgIHJldHVybiBsZSA/IExvbmcuZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSA6IExvbmcuZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzBdICAgICAgIHxcclxuICAgICAgICBieXRlc1sxXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzNdIDw8IDI0LFxyXG4gICAgICAgIGJ5dGVzWzRdICAgICAgIHxcclxuICAgICAgICBieXRlc1s1XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzddIDw8IDI0LFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0JFID0gZnVuY3Rpb24gZnJvbUJ5dGVzQkUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbNF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbN10sXHJcbiAgICAgICAgYnl0ZXNbMF0gPDwgMjQgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1syXSA8PCAgOCB8XHJcbiAgICAgICAgYnl0ZXNbM10sXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcbiIsIi8vIG1pbmltYWwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleC1taW5pbWFsXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBleHBvcnRzO1xuXG4vKipcbiAqIEJ1aWxkIHR5cGUsIG9uZSBvZiBgXCJmdWxsXCJgLCBgXCJsaWdodFwiYCBvciBgXCJtaW5pbWFsXCJgLlxuICogQG5hbWUgYnVpbGRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xucHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyX2J1ZmZlclwiKTtcbnByb3RvYnVmLlJlYWRlciAgICAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcbnByb3RvYnVmLnJwYyAgICAgICAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcbnByb3RvYnVmLnJvb3RzICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBSZWNvbmZpZ3VyZXMgdGhlIGxpYnJhcnkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcbiAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xuICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG59XG5cbi8vIFNldCB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50XG5jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHN0YXJ0ID09PSBlbmQgLy8gZml4IGZvciBJRSAxMC9XaW44IGFuZCBvdGhlcnMnIHN1YmFycmF5IHJldHVybmluZyBhcnJheSBvZiBzaXplIDFcbiAgICAgICAgPyBuZXcgdGhpcy5idWYuY29uc3RydWN0b3IoMClcbiAgICAgICAgOiB0aGlzLl9zbGljZS5jYWxsKHRoaXMuYnVmLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzdHJpbmcgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZygpIHtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzKCk7XG4gICAgcmV0dXJuIHV0ZjgucmVhZChieXRlcywgMCwgYnl0ZXMubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgYnl0ZXMgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2tpcHMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIGlmIGtub3duLCBvdGhlcndpc2UgYSB2YXJpbnQgaXMgYXNzdW1lZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIHNraXAobGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLnBvcyArIGxlbmd0aCA+IHRoaXMubGVuKVxuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG4gICAgICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBuZXh0IGVsZW1lbnQgb2YgdGhlIHNwZWNpZmllZCB3aXJlIHR5cGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lyZVR5cGUgV2lyZSB0eXBlIHJlY2VpdmVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwVHlwZSA9IGZ1bmN0aW9uKHdpcmVUeXBlKSB7XG4gICAgc3dpdGNoICh3aXJlVHlwZSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLnNraXAoOCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5za2lwKHRoaXMudWludDMyKCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHdoaWxlICgod2lyZVR5cGUgPSB0aGlzLnVpbnQzMigpICYgNykgIT09IDQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNraXBUeXBlKHdpcmVUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLnNraXAoNCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlICsgXCIgYXQgb2Zmc2V0IFwiICsgdGhpcy5wb3MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyUmVhZGVyXykge1xuICAgIEJ1ZmZlclJlYWRlciA9IEJ1ZmZlclJlYWRlcl87XG4gICAgUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG5cbiAgICB2YXIgZm4gPSB1dGlsLkxvbmcgPyBcInRvTG9uZ1wiIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gXCJ0b051bWJlclwiO1xuICAgIHV0aWwubWVyZ2UoUmVhZGVyLnByb3RvdHlwZSwge1xuXG4gICAgICAgIGludDY0OiBmdW5jdGlvbiByZWFkX2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1aW50NjQ6IGZ1bmN0aW9uIHJlYWRfdWludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNpbnQ2NDogZnVuY3Rpb24gcmVhZF9zaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKS56ekRlY29kZSgpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9maXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKHRydWUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNmaXhlZDY0OiBmdW5jdGlvbiByZWFkX3NmaXhlZDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRGaXhlZDY0LmNhbGwodGhpcylbZm5dKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlclJlYWRlcjtcblxuLy8gZXh0ZW5kcyBSZWFkZXJcbnZhciBSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG4oQnVmZmVyUmVhZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVhZGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyUmVhZGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciByZWFkZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBSZWFkZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlclJlYWRlcihidWZmZXIpIHtcbiAgICBSZWFkZXIuY2FsbCh0aGlzLCBidWZmZXIpO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQG5hbWUgQnVmZmVyUmVhZGVyI2J1ZlxuICAgICAqIEB0eXBlIHtCdWZmZXJ9XG4gICAgICovXG59XG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHV0aWwuQnVmZmVyKVxuICAgICAgICBCdWZmZXJSZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zbGljZTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiByZWFkX3N0cmluZ19idWZmZXIoKSB7XG4gICAgdmFyIGxlbiA9IHRoaXMudWludDMyKCk7IC8vIG1vZGlmaWVzIHBvc1xuICAgIHJldHVybiB0aGlzLmJ1Zi51dGY4U2xpY2VcbiAgICAgICAgPyB0aGlzLmJ1Zi51dGY4U2xpY2UodGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSlcbiAgICAgICAgOiB0aGlzLmJ1Zi50b1N0cmluZyhcInV0Zi04XCIsIHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgQnVmZmVyUmVhZGVyI2J5dGVzXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFZhbHVlIHJlYWRcbiAqL1xuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vKipcbiAqIE5hbWVkIHJvb3RzLlxuICogVGhpcyBpcyB3aGVyZSBwYmpzIHN0b3JlcyBnZW5lcmF0ZWQgc3RydWN0dXJlcyAodGhlIG9wdGlvbiBgLXIsIC0tcm9vdGAgc3BlY2lmaWVzIGEgbmFtZSkuXG4gKiBDYW4gYWxzbyBiZSB1c2VkIG1hbnVhbGx5IHRvIG1ha2Ugcm9vdHMgYXZhaWxhYmxlIGFjY3Jvc3MgbW9kdWxlcy5cbiAqIEBuYW1lIHJvb3RzXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUm9vdD59XG4gKiBAZXhhbXBsZVxuICogLy8gcGJqcyAtciBteXJvb3QgLW8gY29tcGlsZWQuanMgLi4uXG4gKlxuICogLy8gaW4gYW5vdGhlciBtb2R1bGU6XG4gKiByZXF1aXJlKFwiLi9jb21waWxlZC5qc1wiKTtcbiAqXG4gKiAvLyBpbiBhbnkgc3Vic2VxdWVudCBtb2R1bGU6XG4gKiB2YXIgcm9vdCA9IHByb3RvYnVmLnJvb3RzW1wibXlyb290XCJdO1xuICovXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vLyBFeHRlbmRzIEV2ZW50RW1pdHRlclxuKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh1dGlsLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IFNlcnZpY2U7XG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBycGMuU2VydmljZU1ldGhvZHxTZXJ2aWNlTWV0aG9kfS5cbiAqXG4gKiBEaWZmZXJzIGZyb20ge0BsaW5rIFJQQ0ltcGxDYWxsYmFja30gaW4gdGhhdCBpdCBpcyBhbiBhY3R1YWwgY2FsbGJhY2sgb2YgYSBzZXJ2aWNlIG1ldGhvZCB3aGljaCBtYXkgbm90IHJldHVybiBgcmVzcG9uc2UgPSBudWxsYC5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2tcbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XG4gKiBAcGFyYW0ge1RSZXN9IFtyZXNwb25zZV0gUmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgcGFydCBvZiBhIHtAbGluayBycGMuU2VydmljZX0gYXMgY3JlYXRlZCBieSB7QGxpbmsgU2VydmljZS5jcmVhdGV9LlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RcbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IFtjYWxsYmFja10gTm9kZS1zdHlsZSBjYWxsYmFjayBjYWxsZWQgd2l0aCB0aGUgZXJyb3IsIGlmIGFueSwgYW5kIHRoZSByZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXNzYWdlPFRSZXM+Pn0gUHJvbWlzZSBpZiBgY2FsbGJhY2tgIGhhcyBiZWVuIG9taXR0ZWQsIG90aGVyd2lzZSBgdW5kZWZpbmVkYFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBSUEMgc2VydmljZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQW4gUlBDIHNlcnZpY2UgYXMgcmV0dXJuZWQgYnkge0BsaW5rIFNlcnZpY2UjY3JlYXRlfS5cbiAqIEBleHBvcnRzIHJwYy5TZXJ2aWNlXG4gKiBAZXh0ZW5kcyB1dGlsLkV2ZW50RW1pdHRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JQQ0ltcGx9IHJwY0ltcGwgUlBDIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXF1ZXN0RGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNwb25zZURlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqL1xuZnVuY3Rpb24gU2VydmljZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuXG4gICAgaWYgKHR5cGVvZiBycGNJbXBsICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJwY0ltcGwgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuXG4gICAgdXRpbC5FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFJQQyBpbXBsZW1lbnRhdGlvbi4gQmVjb21lcyBgbnVsbGAgb25jZSB0aGUgc2VydmljZSBpcyBlbmRlZC5cbiAgICAgKiBAdHlwZSB7UlBDSW1wbHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucnBjSW1wbCA9IHJwY0ltcGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlcXVlc3RzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVxdWVzdERlbGltaXRlZCA9IEJvb2xlYW4ocmVxdWVzdERlbGltaXRlZCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3BvbnNlRGVsaW1pdGVkID0gQm9vbGVhbihyZXNwb25zZURlbGltaXRlZCk7XG59XG5cbi8qKlxuICogQ2FsbHMgYSBzZXJ2aWNlIG1ldGhvZCB0aHJvdWdoIHtAbGluayBycGMuU2VydmljZSNycGNJbXBsfHJwY0ltcGx9LlxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8VFJlcSxUUmVzPn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXE+fSByZXF1ZXN0Q3RvciBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NvbnN0cnVjdG9yPFRSZXM+fSByZXNwb25zZUN0b3IgUmVzcG9uc2UgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gY2FsbGJhY2sgU2VydmljZSBjYWxsYmFja1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUUmVxIGV4dGVuZHMgTWVzc2FnZTxUUmVxPlxuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJwY0NhbGwgPSBmdW5jdGlvbiBycGNDYWxsKG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCwgY2FsbGJhY2spIHtcblxuICAgIGlmICghcmVxdWVzdClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicmVxdWVzdCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gdXRpbC5hc1Byb21pc2UocnBjQ2FsbCwgc2VsZiwgbWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0KTtcblxuICAgIGlmICghc2VsZi5ycGNJbXBsKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKEVycm9yKFwiYWxyZWFkeSBlbmRlZFwiKSk7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzZWxmLnJwY0ltcGwoXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0Q3RvcltzZWxmLnJlcXVlc3REZWxpbWl0ZWQgPyBcImVuY29kZURlbGltaXRlZFwiIDogXCJlbmNvZGVcIl0ocmVxdWVzdCkuZmluaXNoKCksXG4gICAgICAgICAgICBmdW5jdGlvbiBycGNDYWxsYmFjayhlcnIsIHJlc3BvbnNlKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZW5kKC8qIGVuZGVkQnlSUEMgKi8gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiByZXNwb25zZUN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3BvbnNlQ3RvcltzZWxmLnJlc3BvbnNlRGVsaW1pdGVkID8gXCJkZWNvZGVEZWxpbWl0ZWRcIiA6IFwiZGVjb2RlXCJdKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImRhdGFcIiwgcmVzcG9uc2UsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhlcnIpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKipcbiAqIEVuZHMgdGhpcyBzZXJ2aWNlIGFuZCBlbWl0cyB0aGUgYGVuZGAgZXZlbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtlbmRlZEJ5UlBDPWZhbHNlXSBXaGV0aGVyIHRoZSBzZXJ2aWNlIGhhcyBiZWVuIGVuZGVkIGJ5IHRoZSBSUEMgaW1wbGVtZW50YXRpb24uXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IGB0aGlzYFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiBlbmQoZW5kZWRCeVJQQykge1xuICAgIGlmICh0aGlzLnJwY0ltcGwpIHtcbiAgICAgICAgaWYgKCFlbmRlZEJ5UlBDKSAvLyBzaWduYWwgZW5kIHRvIHJwY0ltcGxcbiAgICAgICAgICAgIHRoaXMucnBjSW1wbChudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdGhpcy5ycGNJbXBsID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpLm9mZigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTG9uZ0JpdHM7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMuXG4gKiBAY2xhc3NkZXNjIEhlbHBlciBjbGFzcyBmb3Igd29ya2luZyB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsbyBMb3cgMzIgYml0cywgdW5zaWduZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaSBIaWdoIDMyIGJpdHMsIHVuc2lnbmVkXG4gKi9cbmZ1bmN0aW9uIExvbmdCaXRzKGxvLCBoaSkge1xuXG4gICAgLy8gbm90ZSB0aGF0IHRoZSBjYXN0cyBiZWxvdyBhcmUgdGhlb3JldGljYWxseSB1bm5lY2Vzc2FyeSBhcyBvZiB0b2RheSwgYnV0IG9sZGVyIHN0YXRpY2FsbHlcbiAgICAvLyBnZW5lcmF0ZWQgY29udmVydGVyIGNvZGUgbWlnaHQgc3RpbGwgY2FsbCB0aGUgY3RvciB3aXRoIHNpZ25lZCAzMmJpdHMuIGtlcHQgZm9yIGNvbXBhdC5cblxuICAgIC8qKlxuICAgICAqIExvdyBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sbyA9IGxvID4+PiAwO1xuXG4gICAgLyoqXG4gICAgICogSGlnaCBiaXRzLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5oaSA9IGhpID4+PiAwO1xufVxuXG4vKipcbiAqIFplcm8gYml0cy5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7dXRpbC5Mb25nQml0c31cbiAqL1xudmFyIHplcm8gPSBMb25nQml0cy56ZXJvID0gbmV3IExvbmdCaXRzKDAsIDApO1xuXG56ZXJvLnRvTnVtYmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuemVyby56ekVuY29kZSA9IHplcm8uenpEZWNvZGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH07XG56ZXJvLmxlbmd0aCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMTsgfTtcblxuLyoqXG4gKiBaZXJvIGhhc2guXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3N0cmluZ31cbiAqL1xudmFyIHplcm9IYXNoID0gTG9uZ0JpdHMuemVyb0hhc2ggPSBcIlxcMFxcMFxcMFxcMFxcMFxcMFxcMFxcMFwiO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgbnVtYmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbU51bWJlciA9IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IDApXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHZhciBzaWduID0gdmFsdWUgPCAwO1xuICAgIGlmIChzaWduKVxuICAgICAgICB2YWx1ZSA9IC12YWx1ZTtcbiAgICB2YXIgbG8gPSB2YWx1ZSA+Pj4gMCxcbiAgICAgICAgaGkgPSAodmFsdWUgLSBsbykgLyA0Mjk0OTY3Mjk2ID4+PiAwO1xuICAgIGlmIChzaWduKSB7XG4gICAgICAgIGhpID0gfmhpID4+PiAwO1xuICAgICAgICBsbyA9IH5sbyA+Pj4gMDtcbiAgICAgICAgaWYgKCsrbG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICBsbyA9IDA7XG4gICAgICAgICAgICBpZiAoKytoaSA+IDQyOTQ5NjcyOTUpXG4gICAgICAgICAgICAgICAgaGkgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMobG8sIGhpKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gYSBudW1iZXIsIGxvbmcgb3Igc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gSW5zdGFuY2VcbiAqL1xuTG9uZ0JpdHMuZnJvbSA9IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgICAgICB2YWx1ZSA9IHV0aWwuTG9uZy5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIocGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5sb3cgfHwgdmFsdWUuaGlnaCA/IG5ldyBMb25nQml0cyh2YWx1ZS5sb3cgPj4+IDAsIHZhbHVlLmhpZ2ggPj4+IDApIDogemVybztcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBwb3NzaWJseSB1bnNhZmUgSmF2YVNjcmlwdCBudW1iZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc3NpYmx5IHVuc2FmZSBudW1iZXJcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIodW5zaWduZWQpIHtcbiAgICBpZiAoIXVuc2lnbmVkICYmIHRoaXMuaGkgPj4+IDMxKSB7XG4gICAgICAgIHZhciBsbyA9IH50aGlzLmxvICsgMSA+Pj4gMCxcbiAgICAgICAgICAgIGhpID0gfnRoaXMuaGkgICAgID4+PiAwO1xuICAgICAgICBpZiAoIWxvKVxuICAgICAgICAgICAgaGkgPSBoaSArIDEgPj4+IDA7XG4gICAgICAgIHJldHVybiAtKGxvICsgaGkgKiA0Mjk0OTY3Mjk2KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG8gKyB0aGlzLmhpICogNDI5NDk2NzI5Njtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSBsb25nLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ30gTG9uZ1xuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9Mb25nID0gZnVuY3Rpb24gdG9Mb25nKHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIHV0aWwuTG9uZ1xuICAgICAgICA/IG5ldyB1dGlsLkxvbmcodGhpcy5sbyB8IDAsIHRoaXMuaGkgfCAwLCBCb29sZWFuKHVuc2lnbmVkKSlcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiB7IGxvdzogdGhpcy5sbyB8IDAsIGhpZ2g6IHRoaXMuaGkgfCAwLCB1bnNpZ25lZDogQm9vbGVhbih1bnNpZ25lZCkgfTtcbn07XG5cbnZhciBjaGFyQ29kZUF0ID0gU3RyaW5nLnByb3RvdHlwZS5jaGFyQ29kZUF0O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIHRoZSBzcGVjaWZpZWQgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBCaXRzXG4gKi9cbkxvbmdCaXRzLmZyb21IYXNoID0gZnVuY3Rpb24gZnJvbUhhc2goaGFzaCkge1xuICAgIGlmIChoYXNoID09PSB6ZXJvSGFzaClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAyKSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAzKSA8PCAyNCkgPj4+IDBcbiAgICAsXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDQpXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDUpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNykgPDwgMjQpID4+PiAwXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBsb25nIGJpdHMgdG8gYSA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9IYXNoID0gZnVuY3Rpb24gdG9IYXNoKCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICB0aGlzLmxvICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAyNCAgICAgICxcbiAgICAgICAgdGhpcy5oaSAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMjRcbiAgICApO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGVuY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekVuY29kZSA9IGZ1bmN0aW9uIHp6RW5jb2RlKCkge1xuICAgIHZhciBtYXNrID0gICB0aGlzLmhpID4+IDMxO1xuICAgIHRoaXMuaGkgID0gKCh0aGlzLmhpIDw8IDEgfCB0aGlzLmxvID4+PiAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmxvICA9ICggdGhpcy5sbyA8PCAxICAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZGVjb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RGVjb2RlID0gZnVuY3Rpb24genpEZWNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAtKHRoaXMubG8gJiAxKTtcbiAgICB0aGlzLmxvICA9ICgodGhpcy5sbyA+Pj4gMSB8IHRoaXMuaGkgPDwgMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5oaSAgPSAoIHRoaXMuaGkgPj4+IDEgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBsb25nYml0cyB3aGVuIGVuY29kZWQgYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBMZW5ndGhcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICB2YXIgcGFydDAgPSAgdGhpcy5sbyxcbiAgICAgICAgcGFydDEgPSAodGhpcy5sbyA+Pj4gMjggfCB0aGlzLmhpIDw8IDQpID4+PiAwLFxuICAgICAgICBwYXJ0MiA9ICB0aGlzLmhpID4+PiAyNDtcbiAgICByZXR1cm4gcGFydDIgPT09IDBcbiAgICAgICAgID8gcGFydDEgPT09IDBcbiAgICAgICAgICAgPyBwYXJ0MCA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MCA8IDEyOCA/IDEgOiAyXG4gICAgICAgICAgICAgOiBwYXJ0MCA8IDIwOTcxNTIgPyAzIDogNFxuICAgICAgICAgICA6IHBhcnQxIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQxIDwgMTI4ID8gNSA6IDZcbiAgICAgICAgICAgICA6IHBhcnQxIDwgMjA5NzE1MiA/IDcgOiA4XG4gICAgICAgICA6IHBhcnQyIDwgMTI4ID8gOSA6IDEwO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHV0aWwgPSBleHBvcnRzO1xuXG4vLyB1c2VkIHRvIHJldHVybiBhIFByb21pc2Ugd2hlcmUgY2FsbGJhY2sgaXMgb21pdHRlZFxudXRpbC5hc1Byb21pc2UgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYXNwcm9taXNlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xudXRpbC5iYXNlNjQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvYmFzZTY0XCIpO1xuXG4vLyBiYXNlIGNsYXNzIG9mIHJwYy5TZXJ2aWNlXG51dGlsLkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9ldmVudGVtaXR0ZXJcIik7XG5cbi8vIGZsb2F0IGhhbmRsaW5nIGFjY3Jvc3MgYnJvd3NlcnNcbnV0aWwuZmxvYXQgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZmxvYXRcIik7XG5cbi8vIHJlcXVpcmVzIG1vZHVsZXMgb3B0aW9uYWxseSBhbmQgaGlkZXMgdGhlIGNhbGwgZnJvbSBidW5kbGVyc1xudXRpbC5pbnF1aXJlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2lucXVpcmVcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSB1dGY4IGVuY29kZWQgc3RyaW5nc1xudXRpbC51dGY4ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3V0ZjhcIik7XG5cbi8vIHByb3ZpZGVzIGEgbm9kZS1saWtlIGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyXG51dGlsLnBvb2wgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvcG9vbFwiKTtcblxuLy8gdXRpbGl0eSB0byB3b3JrIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlXG51dGlsLkxvbmdCaXRzID0gcmVxdWlyZShcIi4vbG9uZ2JpdHNcIik7XG5cbi8qKlxuICogV2hldGhlciBydW5uaW5nIHdpdGhpbiBub2RlIG9yIG5vdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqL1xudXRpbC5pc05vZGUgPSBCb29sZWFuKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWxcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnMubm9kZSk7XG5cbi8qKlxuICogR2xvYmFsIG9iamVjdCByZWZlcmVuY2UuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge09iamVjdH1cbiAqL1xudXRpbC5nbG9iYWwgPSB1dGlsLmlzTm9kZSAmJiBnbG9iYWxcbiAgICAgICAgICAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcbiAgICAgICAgICAgfHwgdHlwZW9mIHNlbGYgICAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmXG4gICAgICAgICAgIHx8IHRoaXM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8taW52YWxpZC10aGlzXG5cbi8qKlxuICogQW4gaW1tdWFibGUgZW1wdHkgYXJyYXkuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge0FycmF5LjwqPn1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5QXJyYXkgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZShbXSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBbXTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogQW4gaW1tdXRhYmxlIGVtcHR5IG9iamVjdC5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eU9iamVjdCA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKHt9KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9OyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlclxuICovXG51dGlsLmlzSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gaXNJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWx1ZSkgJiYgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgc3RyaW5nLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICovXG51dGlsLmlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdFxuICovXG51dGlsLmlzT2JqZWN0ID0gZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgdXRpbC5pc1NldH0uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzc2V0ID1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBwcm9wZXJ0eSBvbiBhIG1lc3NhZ2UgaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNTZXQgPSBmdW5jdGlvbiBpc1NldChvYmosIHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBvYmpbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgb2JqLmhhc093blByb3BlcnR5KHByb3ApKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcSwgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubGVuZ3RoIDogT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkgPiAwO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgQnVmZmVyIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIEJ1ZmZlciBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbm9kZSdzIHR5cGluZ3MuXG4gKiBAaW50ZXJmYWNlIEJ1ZmZlclxuICogQGV4dGVuZHMgVWludDhBcnJheVxuICovXG5cbi8qKlxuICogTm9kZSdzIEJ1ZmZlciBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8QnVmZmVyPn1cbiAqL1xudXRpbC5CdWZmZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIEJ1ZmZlciA9IHV0aWwuaW5xdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG4gICAgICAgIC8vIHJlZnVzZSB0byB1c2Ugbm9uLW5vZGUgYnVmZmVycyBpZiBub3QgZXhwbGljaXRseSBhc3NpZ25lZCAocGVyZiByZWFzb25zKTpcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID8gQnVmZmVyIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gbnVsbDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn0pKCk7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmdWxsIGZvciBCdWZmZXIuZnJvbS5cbnV0aWwuX0J1ZmZlcl9mcm9tID0gbnVsbDtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZpbGwgZm9yIEJ1ZmZlci5hbGxvY1Vuc2FmZS5cbnV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBidWZmZXIgb2Ygd2hhdGV2ZXIgdHlwZSBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50LlxuICogQHBhcmFtIHtudW1iZXJ8bnVtYmVyW119IFtzaXplT3JBcnJheT0wXSBCdWZmZXIgc2l6ZSBvciBudW1iZXIgYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fEJ1ZmZlcn0gQnVmZmVyXG4gKi9cbnV0aWwubmV3QnVmZmVyID0gZnVuY3Rpb24gbmV3QnVmZmVyKHNpemVPckFycmF5KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gdHlwZW9mIHNpemVPckFycmF5ID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiBuZXcgdXRpbC5BcnJheShzaXplT3JBcnJheSlcbiAgICAgICAgOiB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfZnJvbShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogdHlwZW9mIFVpbnQ4QXJyYXkgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgICAgICA/IHNpemVPckFycmF5XG4gICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShzaXplT3JBcnJheSk7XG59O1xuXG4vKipcbiAqIEFycmF5IGltcGxlbWVudGF0aW9uIHVzZWQgaW4gdGhlIGJyb3dzZXIuIGBVaW50OEFycmF5YCBpZiBzdXBwb3J0ZWQsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPFVpbnQ4QXJyYXk+fVxuICovXG51dGlsLkFycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIgPyBVaW50OEFycmF5IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogQXJyYXk7XG5cbi8qKlxuICogQW55IGNvbXBhdGlibGUgTG9uZyBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBMb25nIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBsb25nLmpzLlxuICogQGludGVyZmFjZSBMb25nXG4gKiBAcHJvcGVydHkge251bWJlcn0gbG93IExvdyBiaXRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gaGlnaCBIaWdoIGJpdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqL1xuXG4vKipcbiAqIExvbmcuanMncyBMb25nIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxMb25nPn1cbiAqL1xudXRpbC5Mb25nID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTyAmJiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPLkxvbmdcbiAgICAgICAgIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLkxvbmdcbiAgICAgICAgIHx8IHV0aWwuaW5xdWlyZShcImxvbmdcIik7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDIgYml0IChgYm9vbGApIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTJSZSA9IC9edHJ1ZXxmYWxzZXwwfDEkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMzIgYml0IChgaW50MzJgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTMyUmUgPSAvXi0/KD86MHxbMS05XVswLTldKikkLztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgNjQgYml0IChgaW50NjRgIGV0Yy4pIG1hcCBrZXlzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqIEBjb25zdFxuICovXG51dGlsLmtleTY0UmUgPSAvXig/OltcXFxceDAwLVxcXFx4ZmZdezh9fC0/KD86MHxbMS05XVswLTldKikpJC87XG5cbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgb3IgbG9uZyB0byBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xudXRpbC5sb25nVG9IYXNoID0gZnVuY3Rpb24gbG9uZ1RvSGFzaCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICA/IHV0aWwuTG9uZ0JpdHMuZnJvbSh2YWx1ZSkudG9IYXNoKClcbiAgICAgICAgOiB1dGlsLkxvbmdCaXRzLnplcm9IYXNoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhbiA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoIHN0cmluZyB0byBhIGxvbmcgb3IgbnVtYmVyLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7TG9uZ3xudW1iZXJ9IE9yaWdpbmFsIHZhbHVlXG4gKi9cbnV0aWwubG9uZ0Zyb21IYXNoID0gZnVuY3Rpb24gbG9uZ0Zyb21IYXNoKGhhc2gsIHVuc2lnbmVkKSB7XG4gICAgdmFyIGJpdHMgPSB1dGlsLkxvbmdCaXRzLmZyb21IYXNoKGhhc2gpO1xuICAgIGlmICh1dGlsLkxvbmcpXG4gICAgICAgIHJldHVybiB1dGlsLkxvbmcuZnJvbUJpdHMoYml0cy5sbywgYml0cy5oaSwgdW5zaWduZWQpO1xuICAgIHJldHVybiBiaXRzLnRvTnVtYmVyKEJvb2xlYW4odW5zaWduZWQpKTtcbn07XG5cbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBkc3QgRGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBzcmMgU291cmNlIG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBbaWZOb3RTZXQ9ZmFsc2VdIE1lcmdlcyBvbmx5IGlmIHRoZSBrZXkgaXMgbm90IGFscmVhZHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG5mdW5jdGlvbiBtZXJnZShkc3QsIHNyYywgaWZOb3RTZXQpIHsgLy8gdXNlZCBieSBjb252ZXJ0ZXJzXG4gICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGRzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkIHx8ICFpZk5vdFNldClcbiAgICAgICAgICAgIGRzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICByZXR1cm4gZHN0O1xufVxuXG51dGlsLm1lcmdlID0gbWVyZ2U7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gQ29udmVydGVkIHN0cmluZ1xuICovXG51dGlsLmxjRmlyc3QgPSBmdW5jdGlvbiBsY0ZpcnN0KHN0cikge1xuICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVycm9yIG5hbWVcbiAqIEByZXR1cm5zIHtDb25zdHJ1Y3RvcjxFcnJvcj59IEN1c3RvbSBlcnJvciBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBuZXdFcnJvcihuYW1lKSB7XG5cbiAgICBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN1c3RvbUVycm9yKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgLy8gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgLy8gXiBqdXN0IHJldHVybnMgYSBuZXcgZXJyb3IgaW5zdGFuY2UgYmVjYXVzZSB0aGUgY3RvciBjYW4gYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb25cblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1lc3NhZ2U7IH0gfSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSAvLyBub2RlXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBDdXN0b21FcnJvcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YWNrXCIsIHsgdmFsdWU6IG5ldyBFcnJvcigpLnN0YWNrIHx8IFwiXCIgfSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICBtZXJnZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAoQ3VzdG9tRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEN1c3RvbUVycm9yO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEN1c3RvbUVycm9yLnByb3RvdHlwZSwgXCJuYW1lXCIsIHsgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG5hbWU7IH0gfSk7XG5cbiAgICBDdXN0b21FcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEN1c3RvbUVycm9yO1xufVxuXG51dGlsLm5ld0Vycm9yID0gbmV3RXJyb3I7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBwcm90b2NvbCBlcnJvci5cbiAqIEBjbGFzc2Rlc2MgRXJyb3Igc3ViY2xhc3MgaW5kaWNhdGluZyBhIHByb3RvY29sIHNwZWNpZmMgZXJyb3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGV4dGVuZHMgRXJyb3JcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBFcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbcHJvcGVydGllc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAZXhhbXBsZVxuICogdHJ5IHtcbiAqICAgICBNeU1lc3NhZ2UuZGVjb2RlKHNvbWVCdWZmZXIpOyAvLyB0aHJvd3MgaWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKiB9IGNhdGNoIChlKSB7XG4gKiAgICAgaWYgKGUgaW5zdGFuY2VvZiBQcm90b2NvbEVycm9yICYmIGUuaW5zdGFuY2UpXG4gKiAgICAgICAgIGNvbnNvbGUubG9nKFwiZGVjb2RlZCBzbyBmYXI6IFwiICsgSlNPTi5zdHJpbmdpZnkoZS5pbnN0YW5jZSkpO1xuICogfVxuICovXG51dGlsLlByb3RvY29sRXJyb3IgPSBuZXdFcnJvcihcIlByb3RvY29sRXJyb3JcIik7XG5cbi8qKlxuICogU28gZmFyIGRlY29kZWQgbWVzc2FnZSBpbnN0YW5jZS5cbiAqIEBuYW1lIHV0aWwuUHJvdG9jb2xFcnJvciNpbnN0YW5jZVxuICogQHR5cGUge01lc3NhZ2U8VD59XG4gKi9cblxuLyoqXG4gKiBBIE9uZU9mIGdldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZkdldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZkdldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIGdldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZkdldHRlcn0gVW5ib3VuZCBnZXR0ZXJcbiAqL1xudXRpbC5vbmVPZkdldHRlciA9IGZ1bmN0aW9uIGdldE9uZU9mKGZpZWxkTmFtZXMpIHtcbiAgICB2YXIgZmllbGRNYXAgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGZpZWxkTWFwW2ZpZWxkTmFtZXNbaV1dID0gMTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyksIGkgPSBrZXlzLmxlbmd0aCAtIDE7IGkgPiAtMTsgLS1pKVxuICAgICAgICAgICAgaWYgKGZpZWxkTWFwW2tleXNbaV1dID09PSAxICYmIHRoaXNba2V5c1tpXV0gIT09IHVuZGVmaW5lZCAmJiB0aGlzW2tleXNbaV1dICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzW2ldO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEEgT25lT2Ygc2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mU2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mU2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHZhbHVlIEZpZWxkIG5hbWVcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBzZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZTZXR0ZXJ9IFVuYm91bmQgc2V0dGVyXG4gKi9cbnV0aWwub25lT2ZTZXR0ZXIgPSBmdW5jdGlvbiBzZXRPbmVPZihmaWVsZE5hbWVzKSB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZXNbaV0gIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXNbZmllbGROYW1lc1tpXV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogRGVmYXVsdCBjb252ZXJzaW9uIG9wdGlvbnMgdXNlZCBmb3Ige0BsaW5rIE1lc3NhZ2UjdG9KU09OfSBpbXBsZW1lbnRhdGlvbnMuXG4gKlxuICogVGhlc2Ugb3B0aW9ucyBhcmUgY2xvc2UgdG8gcHJvdG8zJ3MgSlNPTiBtYXBwaW5nIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGludGVybmFsIHR5cGVzIGxpa2UgQW55IGFyZSBoYW5kbGVkIGp1c3QgbGlrZSBtZXNzYWdlcy4gTW9yZSBwcmVjaXNlbHk6XG4gKlxuICogLSBMb25ncyBiZWNvbWUgc3RyaW5nc1xuICogLSBFbnVtcyBiZWNvbWUgc3RyaW5nIGtleXNcbiAqIC0gQnl0ZXMgYmVjb21lIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqIC0gKFN1Yi0pTWVzc2FnZXMgYmVjb21lIHBsYWluIG9iamVjdHNcbiAqIC0gTWFwcyBiZWNvbWUgcGxhaW4gb2JqZWN0cyB3aXRoIGFsbCBzdHJpbmcga2V5c1xuICogLSBSZXBlYXRlZCBmaWVsZHMgYmVjb21lIGFycmF5c1xuICogLSBOYU4gYW5kIEluZmluaXR5IGZvciBmbG9hdCBhbmQgZG91YmxlIGZpZWxkcyBiZWNvbWUgc3RyaW5nc1xuICpcbiAqIEB0eXBlIHtJQ29udmVyc2lvbk9wdGlvbnN9XG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9wcm90bzM/aGw9ZW4janNvblxuICovXG51dGlsLnRvSlNPTk9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAganNvbjogdHJ1ZVxufTtcblxuLy8gU2V0cyB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50IChjYWxsZWQgaW4gaW5kZXgtbWluaW1hbClcbnV0aWwuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBCdWZmZXIgPSB1dGlsLkJ1ZmZlcjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUJ1ZmZlcikge1xuICAgICAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmVjYXVzZSBub2RlIDQueCBidWZmZXJzIGFyZSBpbmNvbXBhdGlibGUgJiBpbW11dGFibGVcbiAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY29kZUlPL3Byb3RvYnVmLmpzL3B1bGwvNjY1XG4gICAgdXRpbC5fQnVmZmVyX2Zyb20gPSBCdWZmZXIuZnJvbSAhPT0gVWludDhBcnJheS5mcm9tICYmIEJ1ZmZlci5mcm9tIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9mcm9tKHZhbHVlLCBlbmNvZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIodmFsdWUsIGVuY29kaW5nKTtcbiAgICAgICAgfTtcbiAgICB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBCdWZmZXIuYWxsb2NVbnNhZmUgfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2FsbG9jVW5zYWZlKHNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICB9O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBXcml0ZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJXcml0ZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICBiYXNlNjQgICAgPSB1dGlsLmJhc2U2NCxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBVaW50OEFycmF5LCBudW1iZXIpfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBPcChmbiwgbGVuLCB2YWwpIHtcblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwuXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9XG4gICAgICovXG4gICAgdGhpcy5mbiA9IGZuO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgYnl0ZSBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIHdyaXRlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudmFsID0gdmFsOyAvLyB0eXBlIHZhcmllc1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHktZnVuY3Rpb25cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBzdGF0ZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgQ29waWVkIHdyaXRlciBzdGF0ZS5cbiAqIEBtZW1iZXJvZiBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXcml0ZXJ9IHdyaXRlciBXcml0ZXIgdG8gY29weSBzdGF0ZSBmcm9tXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFN0YXRlKHdyaXRlcikge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBoZWFkLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gd3JpdGVyLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRhaWwuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB3cml0ZXIudGFpbDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gd3JpdGVyLmxlbjtcblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RhdGUuXG4gICAgICogQHR5cGUge1N0YXRlfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gd3JpdGVyLnN0YXRlcztcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFdyaXRlcigpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyBoZWFkLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5oZWFkID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0aW9ucyB0YWlsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLnRhaWwgPSB0aGlzLmhlYWQ7XG5cbiAgICAvKipcbiAgICAgKiBMaW5rZWQgZm9ya2VkIHN0YXRlcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBudWxsO1xuXG4gICAgLy8gV2hlbiBhIHZhbHVlIGlzIHdyaXR0ZW4sIHRoZSB3cml0ZXIgY2FsY3VsYXRlcyBpdHMgYnl0ZSBsZW5ndGggYW5kIHB1dHMgaXQgaW50byBhIGxpbmtlZFxuICAgIC8vIGxpc3Qgb2Ygb3BlcmF0aW9ucyB0byBwZXJmb3JtIHdoZW4gZmluaXNoKCkgaXMgY2FsbGVkLiBUaGlzIGJvdGggYWxsb3dzIHVzIHRvIGFsbG9jYXRlXG4gICAgLy8gYnVmZmVycyBvZiB0aGUgZXhhY3QgcmVxdWlyZWQgc2l6ZSBhbmQgcmVkdWNlcyB0aGUgYW1vdW50IG9mIHdvcmsgd2UgaGF2ZSB0byBkbyBjb21wYXJlZFxuICAgIC8vIHRvIGZpcnN0IGNhbGN1bGF0aW5nIG92ZXIgb2JqZWN0cyBhbmQgdGhlbiBlbmNvZGluZyBvdmVyIG9iamVjdHMuIEluIG91ciBjYXNlLCB0aGUgZW5jb2RpbmdcbiAgICAvLyBwYXJ0IGlzIGp1c3QgYSBsaW5rZWQgbGlzdCB3YWxrIGNhbGxpbmcgb3BlcmF0aW9ucyB3aXRoIGFscmVhZHkgcHJlcGFyZWQgdmFsdWVzLlxufVxuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFdyaXRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyV3JpdGVyKCk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIoKTtcbiAgICAgICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB3cml0ZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJXcml0ZXJ8V3JpdGVyfSBBIHtAbGluayBCdWZmZXJXcml0ZXJ9IHdoZW4gQnVmZmVycyBhcmUgc3VwcG9ydGVkLCBvdGhlcndpc2UgYSB7QGxpbmsgV3JpdGVyfVxuICovXG5Xcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cbi8qKlxuICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXG4gKi9cbldyaXRlci5hbGxvYyA9IGZ1bmN0aW9uIGFsbG9jKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IHV0aWwuQXJyYXkoc2l6ZSk7XG59O1xuXG4vLyBVc2UgVWludDhBcnJheSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlciwganVzdCBsaWtlIG5vZGUgZG9lcyB3aXRoIGJ1ZmZlcnNcbi8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5pZiAodXRpbC5BcnJheSAhPT0gQXJyYXkpXG4gICAgV3JpdGVyLmFsbG9jID0gdXRpbC5wb29sKFdyaXRlci5hbGxvYywgdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkpO1xuXG4vKipcbiAqIFB1c2hlcyBhIG5ldyBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICogQHBhcmFtIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfSBmbiBGdW5jdGlvbiB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEBwcml2YXRlXG4gKi9cbldyaXRlci5wcm90b3R5cGUuX3B1c2ggPSBmdW5jdGlvbiBwdXNoKGZuLCBsZW4sIHZhbCkge1xuICAgIHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IE9wKGZuLCBsZW4sIHZhbCk7XG4gICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVCeXRlKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zXSA9IHZhbCAmIDI1NTtcbn1cblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbCA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwgPj4+PSA3O1xuICAgIH1cbiAgICBidWZbcG9zXSA9IHZhbDtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHZhcmludCB3cml0ZXIgb3BlcmF0aW9uIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBTY2hlZHVsZWQgdmFyaW50IHdyaXRlciBvcGVyYXRpb24uXG4gKiBAZXh0ZW5kcyBPcFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIFZhbHVlIGJ5dGUgbGVuZ3RoXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIFZhcmludE9wKGxlbiwgdmFsKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudmFsID0gdmFsO1xufVxuXG5WYXJpbnRPcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKE9wLnByb3RvdHlwZSk7XG5WYXJpbnRPcC5wcm90b3R5cGUuZm4gPSB3cml0ZVZhcmludDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQzMih2YWx1ZSkge1xuICAgIC8vIGhlcmUsIHRoZSBjYWxsIHRvIHRoaXMucHVzaCBoYXMgYmVlbiBpbmxpbmVkIGFuZCBhIHZhcmludCBzcGVjaWZpYyBPcCBzdWJjbGFzcyBpcyB1c2VkLlxuICAgIC8vIHVpbnQzMiBpcyBieSBmYXIgdGhlIG1vc3QgZnJlcXVlbnRseSB1c2VkIG9wZXJhdGlvbiBhbmQgYmVuZWZpdHMgc2lnbmlmaWNhbnRseSBmcm9tIHRoaXMuXG4gICAgdGhpcy5sZW4gKz0gKHRoaXMudGFpbCA9IHRoaXMudGFpbC5uZXh0ID0gbmV3IFZhcmludE9wKFxuICAgICAgICAodmFsdWUgPSB2YWx1ZSA+Pj4gMClcbiAgICAgICAgICAgICAgICA8IDEyOCAgICAgICA/IDFcbiAgICAgICAgOiB2YWx1ZSA8IDE2Mzg0ICAgICA/IDJcbiAgICAgICAgOiB2YWx1ZSA8IDIwOTcxNTIgICA/IDNcbiAgICAgICAgOiB2YWx1ZSA8IDI2ODQzNTQ1NiA/IDRcbiAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgdmFsdWUpKS5sZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9pbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA8IDBcbiAgICAgICAgPyB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIDEwLCBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKSkgLy8gMTAgYnl0ZXMgcGVyIHNwZWNcbiAgICAgICAgOiB0aGlzLnVpbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiB3cml0ZV9zaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKHZhbHVlIDw8IDEgXiB2YWx1ZSA+PiAzMSkgPj4+IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVWYXJpbnQ2NCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgd2hpbGUgKHZhbC5oaSkge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSAodmFsLmxvID4+PiA3IHwgdmFsLmhpIDw8IDI1KSA+Pj4gMDtcbiAgICAgICAgdmFsLmhpID4+Pj0gNztcbiAgICB9XG4gICAgd2hpbGUgKHZhbC5sbyA+IDEyNykge1xuICAgICAgICBidWZbcG9zKytdID0gdmFsLmxvICYgMTI3IHwgMTI4O1xuICAgICAgICB2YWwubG8gPSB2YWwubG8gPj4+IDc7XG4gICAgfVxuICAgIGJ1Zltwb3MrK10gPSB2YWwubG87XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnVpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3VpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDY0ID0gV3JpdGVyLnByb3RvdHlwZS51aW50NjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludCwgemlnLXphZyBlbmNvZGVkLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDY0ID0gZnVuY3Rpb24gd3JpdGVfc2ludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKS56ekVuY29kZSgpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBib29saXNoIHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHdyaXRlX2Jvb2wodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIHZhbHVlID8gMSA6IDApO1xufTtcblxuZnVuY3Rpb24gd3JpdGVGaXhlZDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDE2ICAmIDI1NTtcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCB2YWx1ZSA+Pj4gMCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0ID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmxvKS5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMuaGkpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGZpeGVkIDY0IGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDY0ID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIGZsb2F0ICgzMiBiaXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gd3JpdGVfZmxvYXQodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRmxvYXRMRSwgNCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gd3JpdGVfZG91YmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZURvdWJsZUxFLCA4LCB2YWx1ZSk7XG59O1xuXG52YXIgd3JpdGVCeXRlcyA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnNldFxuICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc19zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzX2Zvcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgYnVmW3BvcyArIGldID0gdmFsW2ldO1xuICAgIH07XG5cbi8qKlxuICogV3JpdGVzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSB2YWx1ZSBCdWZmZXIgb3IgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IFdyaXRlci5hbGxvYyhsZW4gPSBiYXNlNjQubGVuZ3RoKHZhbHVlKSk7XG4gICAgICAgIGJhc2U2NC5kZWNvZGUodmFsdWUsIGJ1ZiwgMCk7XG4gICAgICAgIHZhbHVlID0gYnVmO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51aW50MzIobGVuKS5fcHVzaCh3cml0ZUJ5dGVzLCBsZW4sIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmcodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRmOC5sZW5ndGgodmFsdWUpO1xuICAgIHJldHVybiBsZW5cbiAgICAgICAgPyB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHV0Zjgud3JpdGUsIGxlbiwgdmFsdWUpXG4gICAgICAgIDogdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xufTtcblxuLyoqXG4gKiBGb3JrcyB0aGlzIHdyaXRlcidzIHN0YXRlIGJ5IHB1c2hpbmcgaXQgdG8gYSBzdGFjay5cbiAqIENhbGxpbmcge0BsaW5rIFdyaXRlciNyZXNldHxyZXNldH0gb3Ige0BsaW5rIFdyaXRlciNsZGVsaW18bGRlbGltfSByZXNldHMgdGhlIHdyaXRlciB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mb3JrID0gZnVuY3Rpb24gZm9yaygpIHtcbiAgICB0aGlzLnN0YXRlcyA9IG5ldyBTdGF0ZSh0aGlzKTtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgdGhpcy5sZW4gPSAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdGhpcyBpbnN0YW5jZSB0byB0aGUgbGFzdCBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuaGVhZCAgID0gdGhpcy5zdGF0ZXMuaGVhZDtcbiAgICAgICAgdGhpcy50YWlsICAgPSB0aGlzLnN0YXRlcy50YWlsO1xuICAgICAgICB0aGlzLmxlbiAgICA9IHRoaXMuc3RhdGVzLmxlbjtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSB0aGlzLnN0YXRlcy5uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICAgICAgdGhpcy5sZW4gID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0byB0aGUgbGFzdCBzdGF0ZSBhbmQgYXBwZW5kcyB0aGUgZm9yayBzdGF0ZSdzIGN1cnJlbnQgd3JpdGUgbGVuZ3RoIGFzIGEgdmFyaW50IGZvbGxvd2VkIGJ5IGl0cyBvcGVyYXRpb25zLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUubGRlbGltID0gZnVuY3Rpb24gbGRlbGltKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLFxuICAgICAgICB0YWlsID0gdGhpcy50YWlsLFxuICAgICAgICBsZW4gID0gdGhpcy5sZW47XG4gICAgdGhpcy5yZXNldCgpLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy50YWlsLm5leHQgPSBoZWFkLm5leHQ7IC8vIHNraXAgbm9vcFxuICAgICAgICB0aGlzLnRhaWwgPSB0YWlsO1xuICAgICAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZC5uZXh0LCAvLyBza2lwIG5vb3BcbiAgICAgICAgYnVmICA9IHRoaXMuY29uc3RydWN0b3IuYWxsb2ModGhpcy5sZW4pLFxuICAgICAgICBwb3MgID0gMDtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgICBoZWFkLmZuKGhlYWQudmFsLCBidWYsIHBvcyk7XG4gICAgICAgIHBvcyArPSBoZWFkLmxlbjtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICB9XG4gICAgLy8gdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICByZXR1cm4gYnVmO1xufTtcblxuV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJXcml0ZXJfKSB7XG4gICAgQnVmZmVyV3JpdGVyID0gQnVmZmVyV3JpdGVyXztcbiAgICBXcml0ZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyV3JpdGVyO1xuXG4vLyBleHRlbmRzIFdyaXRlclxudmFyIFdyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbihCdWZmZXJXcml0ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShXcml0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJXcml0ZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHdyaXRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgd3JpdGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlcldyaXRlcigpIHtcbiAgICBXcml0ZXIuY2FsbCh0aGlzKTtcbn1cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQWxsb2NhdGVzIGEgYnVmZmVyIG9mIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IEJ1ZmZlclxuICAgICAqL1xuICAgIEJ1ZmZlcldyaXRlci5hbGxvYyA9IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZTtcblxuICAgIEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyID0gdXRpbC5CdWZmZXIgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2V0Lm5hbWUgPT09IFwic2V0XCJcbiAgICAgICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGZhc3RlciB0aGFuIGNvcHkgKHJlcXVpcmVzIG5vZGUgPj0gNCB3aGVyZSBCdWZmZXJzIGV4dGVuZCBVaW50OEFycmF5IGFuZCBzZXQgaXMgcHJvcGVybHkgaW5oZXJpdGVkKVxuICAgICAgICAgIC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9jb3B5KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBpZiAodmFsLmNvcHkpIC8vIEJ1ZmZlciB2YWx1ZXNcbiAgICAgICAgICAgIHZhbC5jb3B5KGJ1ZiwgcG9zLCAwLCB2YWwubGVuZ3RoKTtcbiAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDspIC8vIHBsYWluIGFycmF5IHZhbHVlc1xuICAgICAgICAgICAgYnVmW3BvcysrXSA9IHZhbFtpKytdO1xuICAgICAgICB9O1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXNfYnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHV0aWwuX0J1ZmZlcl9mcm9tKHZhbHVlLCBcImJhc2U2NFwiKTtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaChCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVN0cmluZ0J1ZmZlcih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0MCkgLy8gcGxhaW4ganMgaXMgZmFzdGVyIGZvciBzaG9ydCBzdHJpbmdzIChwcm9iYWJseSBkdWUgdG8gcmVkdW5kYW50IGFzc2VydGlvbnMpXG4gICAgICAgIHV0aWwudXRmOC53cml0ZSh2YWwsIGJ1ZiwgcG9zKTtcbiAgICBlbHNlIGlmIChidWYudXRmOFdyaXRlKVxuICAgICAgICBidWYudXRmOFdyaXRlKHZhbCwgcG9zKTtcbiAgICBlbHNlXG4gICAgICAgIGJ1Zi53cml0ZSh2YWwsIHBvcyk7XG59XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nX2J1ZmZlcih2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGlsLkJ1ZmZlci5ieXRlTGVuZ3RoKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2god3JpdGVTdHJpbmdCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAbmFtZSBCdWZmZXJXcml0ZXIjZmluaXNoXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IEZpbmlzaGVkIGJ1ZmZlclxuICovXG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJcclxuaW1wb3J0IHtVbml0VGVzdH0gZnJvbSAnLi91bml0dGVzdC9Vbml0VGVzdCc7XHJcbmltcG9ydCB7IEpzTWFuYWdlciAsR2FtZUxhdW5jaCB9IGZyb20gJ2NzaGFycCc7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSAnLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWYnO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSAnLi9nbG9iYWwvR2FtZUNvbmZpZyc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXInO1xyXG5pbXBvcnQgeyBjb21tb25VSSB9IGZyb20gJy4vZGF0YS91aS9jb21tb24nO1xyXG5cclxuXHJcblxyXG5jbGFzcyBHYW1lTWFpbntcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkFwcGxpY2F0aW9uUXVpdCA9ICgpID0+IHRoaXMub25BcHBsaWNhdGlvblF1aXQoKTtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkRpc3Bvc2UgPSAoKSA9PiB0aGlzLm9uRGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICBcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJHYW1lIHN0YXJ0IGluIEpTLi4uLlwiKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBTLlN0b3J5TWFuYWdlci5pbml0aWFsaXplKCk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy/pooTliqDovb1leGNlbOaVsOaNrlxyXG4gICAgICAgICAgICAvL0V4Y2VsTWFuYWdlci5JbnN0YW5jZShFeGNlbE1hbmFnZXIpO1xyXG4gICAgICBcclxuICAgICAgICAgICAgLy/liqDovb3pgJrnlKhGYWlyeUdVSei1hOa6kFxyXG4gICAgICAgICAgICBhd2FpdCBTLlJlc01hbmFnZXIubG9hZEZhaXJ5R1VJUGFja2FnZShjb21tb25VSS5QYWNrYWdlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvL2RvIFVuaXQgVGVzdFxyXG4gICAgICAgICAgICAvL1VuaXRUZXN0LmRvVGVzdCgpO1xyXG5cclxuICAgICAgICAgICAgLy/ov5vlhaXnmbvlvZXmqKHlnZdcclxuICAgICAgICAgICAgYXdhaXQgUy5TY2VuZU1hbmFnZXIubG9hZFNjZW5lKFNjZW5lRGVmLkxvZ2luU2NlbmUpO1xyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vSlPlkK/liqjlrozmiJDvvIzpgJrnn6VDI+WxglxyXG4gICAgICAgICAgICBHYW1lTGF1bmNoLkluc3RhbmNlLkpzTHVhbmNoRmluaXNoKCk7XHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihleCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25BcHBsaWNhdGlvblF1aXQoKTp2b2lkIHtcclxuXHJcbiAgICAgICAgUy5HYW1lT2JqZWN0UG9vbC5jbGVhbnVwKHRydWUpO1xyXG4gICAgICAgIExvZ2dlci5sb2coXCJHYW1lIG9uQXBwbGljYXRpb25RdWl0IGluIEpTLi4uLlwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25EaXNwb3NlKCk6dm9pZCB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIkdhbWUgb25EaXNwb3NlIGluIEpTLi4uLlwiKTtcclxuICAgIH1cclxuICAgIFxyXG59XHJcblxyXG5uZXcgR2FtZU1haW4oKS5zdGFydCgpO1xyXG5cclxuIiwiaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuL2dlbi9wYlwiO1xyXG5leHBvcnQgY2xhc3MgRGVjb2RlTXNne1xyXG5cdHB1YmxpYyBycGNJZDpudW1iZXI7XHJcblx0cHVibGljIG1zZ09iajphbnk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIE9wY29kZXtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMlJfTG9naW46bnVtYmVyID0gMTAwMDtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19SMkNfTG9naW46bnVtYmVyID0gMTAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdfTG9naW5HYXRlOm51bWJlciA9IDEwMDI7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfRzJDX0xvZ2luR2F0ZTpudW1iZXIgPSAxMDAzO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdTX1Rlc3Q6bnVtYmVyID0gMjAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19HUzJDX1Rlc3Q6bnVtYmVyID0gMjAwMjtcclxuXHJcblx0cHVibGljIHN0YXRpYyBtYXAgPSB7XHJcblx0XHQxMDAwIDoge1wiZGVjb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZW5jb2RlfSxcclxuXHRcdDEwMDEgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5lbmNvZGV9LFxyXG5cdFx0MTAwMiA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHX0xvZ2luR2F0ZS5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLkMyR19Mb2dpbkdhdGUuZW5jb2RlfSxcclxuXHRcdDEwMDMgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLkcyQ19Mb2dpbkdhdGUuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HMkNfTG9naW5HYXRlLmVuY29kZX0sXHJcblxyXG5cdFx0MjAwMSA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmVuY29kZX0sXHJcblx0XHQyMDAyIDoge1wiZGVjb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZW5jb2RlfVxyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGRlY29kZShvcGNvZGU6bnVtYmVyLCBtc2c6VWludDhBcnJheSk6RGVjb2RlTXNnIHtcclxuXHRcdGxldCBtc2dPYmogPSB0aGlzLm1hcFtvcGNvZGVdW1wiZGVjb2RlXCJdKG1zZyk7XHJcblx0XHRsZXQgZGVjb2RlTXNnID0gbmV3IERlY29kZU1zZygpO1xyXG5cdFx0ZGVjb2RlTXNnLnJwY0lkID0gbXNnT2JqLlJwY0lkO1xyXG5cdFx0ZGVjb2RlTXNnLm1zZ09iaiA9IG1zZ09iajtcclxuXHRcdHJldHVybiBkZWNvZGVNc2c7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZW5jb2RlKG9wY29kZTpudW1iZXIsIG1zZzpVaW50OEFycmF5KXtcclxuXHRcdGxldCBidWYgPSB0aGlzLm1hcFtvcGNvZGVdW1wiZW5jb2RlXCJdKG1zZykuZmluaXNoKCk7XHJcblx0XHRyZXR1cm4gYnVmXHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcbiIsIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XHJcblxyXG4vLyBDb21tb24gYWxpYXNlc1xyXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xyXG5cclxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcclxuJHByb3RvYnVmLnV0aWwuTG9uZyA9IExvbmc7XHJcbiRwcm90b2J1Zi5jb25maWd1cmUoKTtcclxuXHJcblxyXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxyXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xyXG5cclxuJHJvb3QubmljZV90cyA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5hbWVzcGFjZSBuaWNlX3RzLlxyXG4gICAgICogQGV4cG9ydHMgbmljZV90c1xyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICovXHJcbiAgICB2YXIgbmljZV90cyA9IHt9O1xyXG5cclxuICAgIG5pY2VfdHMuQzJSX0xvZ2luID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJSX0xvZ2luLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW0FjY291bnRdIEMyUl9Mb2dpbiBBY2NvdW50XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW1Bhc3N3b3JkXSBDMlJfTG9naW4gUGFzc3dvcmRcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDMlJfTG9naW4uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMlJfTG9naW4uXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQzJSX0xvZ2luKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyUl9Mb2dpbiBBY2NvdW50LlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gQWNjb3VudFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUuQWNjb3VudCA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyUl9Mb2dpbiBQYXNzd29yZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhc3N3b3JkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLnByb3RvdHlwZS5QYXNzd29yZCA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQzJSX0xvZ2luIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW4gaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMlJfTG9naW4ocHJvcGVydGllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyUl9Mb2dpbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJBY2NvdW50XCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5BY2NvdW50KTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBhc3N3b3JkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5QYXNzd29yZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyUl9Mb2dpbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJSX0xvZ2luKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFjY291bnQgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QYXNzd29yZCA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMlJfTG9naW4gbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFjY291bnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWNjb3VudFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BY2NvdW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBY2NvdW50OiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGFzc3dvcmRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuUGFzc3dvcmQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlBhc3N3b3JkOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5DMlJfTG9naW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbigpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkFjY291bnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWNjb3VudCA9IFN0cmluZyhvYmplY3QuQWNjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuUGFzc3dvcmQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGFzc3dvcmQgPSBTdHJpbmcob2JqZWN0LlBhc3N3b3JkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJSX0xvZ2luIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyUl9Mb2dpbn0gbWVzc2FnZSBDMlJfTG9naW5cclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQWNjb3VudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuUGFzc3dvcmQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFjY291bnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWNjb3VudFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BY2NvdW50ID0gbWVzc2FnZS5BY2NvdW50O1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QYXNzd29yZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQYXNzd29yZFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5QYXNzd29yZCA9IG1lc3NhZ2UuUGFzc3dvcmQ7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDMlJfTG9naW4gdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gQzJSX0xvZ2luO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLlIyQ19Mb2dpbiA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFIyQ19Mb2dpbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtFcnJvcl0gUjJDX0xvZ2luIEVycm9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIFIyQ19Mb2dpbiBNZXNzYWdlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW0FkZHJlc3NdIFIyQ19Mb2dpbiBBZGRyZXNzXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbS2V5XSBSMkNfTG9naW4gS2V5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbR2F0ZUlkXSBSMkNfTG9naW4gR2F0ZUlkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUjJDX0xvZ2luLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUjJDX0xvZ2luLlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElSMkNfTG9naW5cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFIyQ19Mb2dpbihwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gRXJyb3IuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuRXJyb3IgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gTWVzc2FnZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gQWRkcmVzcy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEFkZHJlc3NcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkFkZHJlc3MgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gS2V5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBLZXlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLktleSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gR2F0ZUlkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBHYXRlSWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkdhdGVJZCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFIyQ19Mb2dpbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luIGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUjJDX0xvZ2luKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBSMkNfTG9naW4gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5SMkNfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbn0gbWVzc2FnZSBSMkNfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWRkcmVzcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLktleSk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiR2F0ZUlkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQ2NChtZXNzYWdlLkdhdGVJZCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTEsIHdpcmVUeXBlIDAgPSovNzI4KS5pbnQzMihtZXNzYWdlLkVycm9yKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUjJDX0xvZ2luIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuUjJDX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW59IG1lc3NhZ2UgUjJDX0xvZ2luIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgUjJDX0xvZ2luIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5SMkNfTG9naW4oKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuUjJDX0xvZ2lufSBSMkNfTG9naW5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIFIyQ19Mb2dpbiBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BZGRyZXNzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBZGRyZXNzOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5KSAmJiAhKG1lc3NhZ2UuS2V5ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiS2V5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkKSAmJiAhKG1lc3NhZ2UuR2F0ZUlkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2F0ZUlkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5SMkNfTG9naW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLlIyQ19Mb2dpbigpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkFkZHJlc3MgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWRkcmVzcyA9IFN0cmluZyhvYmplY3QuQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuS2V5ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5LZXkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuS2V5KSkudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcGFyc2VJbnQob2JqZWN0LktleSwgMTApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBvYmplY3QuS2V5O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LktleS5sb3cgPj4+IDAsIG9iamVjdC5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5HYXRlSWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLkdhdGVJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5HYXRlSWQpKS51bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBwYXJzZUludChvYmplY3QuR2F0ZUlkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG9iamVjdC5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuR2F0ZUlkLmxvdyA+Pj4gMCwgb2JqZWN0LkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBSMkNfTG9naW4gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gbWVzc2FnZS5BZGRyZXNzO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLktleSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuS2V5KSA6IG1lc3NhZ2UuS2V5O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuS2V5KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLktleS5sb3cgPj4+IDAsIG1lc3NhZ2UuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLktleTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5HYXRlSWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLkdhdGVJZCkgOiBtZXNzYWdlLkdhdGVJZDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLkdhdGVJZCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5HYXRlSWQubG93ID4+PiAwLCBtZXNzYWdlLkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5HYXRlSWQ7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gbWVzc2FnZS5FcnJvcjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBtZXNzYWdlLk1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBSMkNfTG9naW4gdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gUjJDX0xvZ2luO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLkMyR19Mb2dpbkdhdGUgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBDMkdfTG9naW5HYXRlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0tleV0gQzJHX0xvZ2luR2F0ZSBLZXlcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtHYXRlSWRdIEMyR19Mb2dpbkdhdGUgR2F0ZUlkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJHX0xvZ2luR2F0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyR19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDMkdfTG9naW5HYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyR19Mb2dpbkdhdGUgS2V5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBLZXlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuS2V5ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyR19Mb2dpbkdhdGUgR2F0ZUlkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBHYXRlSWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuR2F0ZUlkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQzJHX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZSBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMkdfTG9naW5HYXRlKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJLZXlcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5LZXkpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50NjQobWVzc2FnZS5HYXRlSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkpICYmICEobWVzc2FnZS5LZXkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmhpZ2gpKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJLZXk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiR2F0ZUlkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQpICYmICEobWVzc2FnZS5HYXRlSWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmhpZ2gpKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHYXRlSWQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LktleSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuS2V5ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LktleSkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IHBhcnNlSW50KG9iamVjdC5LZXksIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gb2JqZWN0LktleTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5LZXkubG93ID4+PiAwLCBvYmplY3QuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuR2F0ZUlkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5HYXRlSWQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuR2F0ZUlkKSkudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gcGFyc2VJbnQob2JqZWN0LkdhdGVJZCwgMTApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBvYmplY3QuR2F0ZUlkO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LkdhdGVJZC5sb3cgPj4+IDAsIG9iamVjdC5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gbWVzc2FnZSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5LZXkgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLktleSkgOiBtZXNzYWdlLktleTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLktleSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5LZXkubG93ID4+PiAwLCBtZXNzYWdlLktleS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5LZXk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuR2F0ZUlkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5HYXRlSWQpIDogbWVzc2FnZS5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5HYXRlSWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuR2F0ZUlkLmxvdyA+Pj4gMCwgbWVzc2FnZS5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuR2F0ZUlkO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHX0xvZ2luR2F0ZSB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEMyR19Mb2dpbkdhdGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZSA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEcyQ19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAaW50ZXJmYWNlIElHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBHMkNfTG9naW5HYXRlIEVycm9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIEcyQ19Mb2dpbkdhdGUgTWVzc2FnZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW1BsYXllcklkXSBHMkNfTG9naW5HYXRlIFBsYXllcklkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRzJDX0xvZ2luR2F0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEcyQ19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBHMkNfTG9naW5HYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgRXJyb3IuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5FcnJvciA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgTWVzc2FnZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5wcm90b3R5cGUuTWVzc2FnZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgUGxheWVySWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IFBsYXllcklkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLlBsYXllcklkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHMkNfTG9naW5HYXRlKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHMkNfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGV9IG1lc3NhZ2UgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBsYXllcklkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuUGxheWVySWQpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkyLCB3aXJlVHlwZSAyID0qLzczOCkuc3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HMkNfTG9naW5HYXRlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IEcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HMkNfTG9naW5HYXRlKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IHJlYWRlci5pbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MjpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuRXJyb3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5NZXNzYWdlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGxheWVySWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLlBsYXllcklkKSAmJiAhKG1lc3NhZ2UuUGxheWVySWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuUGxheWVySWQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5QbGF5ZXJJZC5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUGxheWVySWQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LlBsYXllcklkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5QbGF5ZXJJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5QbGF5ZXJJZCkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSBwYXJzZUludChvYmplY3QuUGxheWVySWQsIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG9iamVjdC5QbGF5ZXJJZDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuUGxheWVySWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuUGxheWVySWQubG93ID4+PiAwLCBvYmplY3QuUGxheWVySWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGxheWVySWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuUGxheWVySWQpIDogbWVzc2FnZS5QbGF5ZXJJZDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuUGxheWVySWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuUGxheWVySWQubG93ID4+PiAwLCBtZXNzYWdlLlBsYXllcklkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLlBsYXllcklkO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IG1lc3NhZ2UuRXJyb3I7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gbWVzc2FnZS5NZXNzYWdlO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgRzJDX0xvZ2luR2F0ZSB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEcyQ19Mb2dpbkdhdGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG5pY2VfdHMuQzJHU19UZXN0ID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJHU19UZXN0XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3Rlc3RJRF0gQzJHU19UZXN0IHRlc3RJRFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt0ZXN0TmFtZV0gQzJHU19UZXN0IHRlc3ROYW1lXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMkdTX1Rlc3RcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEMyR1NfVGVzdChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdTX1Rlc3QgdGVzdElELlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdGVzdElEXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LnByb3RvdHlwZS50ZXN0SUQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdTX1Rlc3QgdGVzdE5hbWUuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0TmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudGVzdE5hbWUgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyR1NfVGVzdCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0IGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJHU19UZXN0KHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdTX1Rlc3QgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMkdTX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZXN0SURcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS50ZXN0SUQpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0TmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVzdE5hbWVcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLnRlc3ROYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHU19UZXN0IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHU19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdElEID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0TmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0SURcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRlc3RJRCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdElEOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3ROYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3ROYW1lXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRlc3ROYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0TmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC50ZXN0SUQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdElEID0gb2JqZWN0LnRlc3RJRCB8IDA7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdE5hbWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdE5hbWUgPSBTdHJpbmcob2JqZWN0LnRlc3ROYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHU19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3RcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdElEID0gMDtcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0TmFtZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RJRFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0SUQgPSBtZXNzYWdlLnRlc3RJRDtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdE5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdE5hbWVcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdE5hbWUgPSBtZXNzYWdlLnRlc3ROYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHU19UZXN0IHRvIEpTT04uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEMyR1NfVGVzdDtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgbmljZV90cy5HUzJDX1Rlc3QgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAaW50ZXJmYWNlIElHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbRXJyb3JdIEdTMkNfVGVzdCBFcnJvclxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNZXNzYWdlXSBHUzJDX1Rlc3QgTWVzc2FnZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt0ZXN0UmVzcG9uc2VdIEdTMkNfVGVzdCB0ZXN0UmVzcG9uc2VcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gR1MyQ19UZXN0KHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCBFcnJvci5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEVycm9yXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS5FcnJvciA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCBNZXNzYWdlLlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gTWVzc2FnZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5wcm90b3R5cGUuTWVzc2FnZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCB0ZXN0UmVzcG9uc2UuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0UmVzcG9uc2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLnRlc3RSZXNwb25zZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgR1MyQ19UZXN0IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3QgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHUzJDX1Rlc3QocHJvcGVydGllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEdTMkNfVGVzdCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkdTMkNfVGVzdC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0fSBtZXNzYWdlIEdTMkNfVGVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0UmVzcG9uc2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3RSZXNwb25zZVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5MSwgd2lyZVR5cGUgMCA9Ki83MjgpLmludDMyKG1lc3NhZ2UuRXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5Miwgd2lyZVR5cGUgMiA9Ki83MzgpLnN0cmluZyhtZXNzYWdlLk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHUzJDX1Rlc3QgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HUzJDX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSByZWFkZXIuaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgOTI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdFJlc3BvbnNlID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIEdTMkNfVGVzdCBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RSZXNwb25zZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0UmVzcG9uc2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0UmVzcG9uc2U6IHN0cmluZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuR1MyQ19UZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuRXJyb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSBvYmplY3QuRXJyb3IgfCAwO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0Lk1lc3NhZ2UgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IFN0cmluZyhvYmplY3QuTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdFJlc3BvbnNlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RSZXNwb25zZSA9IFN0cmluZyhvYmplY3QudGVzdFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR1MyQ19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdFJlc3BvbnNlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdFJlc3BvbnNlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RSZXNwb25zZVwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0UmVzcG9uc2UgPSBtZXNzYWdlLnRlc3RSZXNwb25zZTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSBtZXNzYWdlLkVycm9yO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IG1lc3NhZ2UuTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEdTMkNfVGVzdCB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBHUzJDX1Rlc3Q7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBuaWNlX3RzO1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAkcm9vdDtcclxuIiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIGNvbWJhdFVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImNvbWJhdFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiY29tYmF0X2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUl0ZXN0OnN0cmluZyA9IFwidGVzdFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlDYXJkOnN0cmluZyA9IFwiQ2FyZFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlDb21iYXRQYWdlOnN0cmluZyA9IFwiQ29tYmF0UGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlSb29tOnN0cmluZyA9IFwiUm9vbVwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBjb21tb25VSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJjb21tb25cIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImNvbW1vbl9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJTG9hZGluZ1BhZ2U6c3RyaW5nID0gXCJMb2FkaW5nUGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlVSUd1aWRlV2luOnN0cmluZyA9IFwiVUlHdWlkZVdpblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlVSU5vdGljZVdpbjpzdHJpbmcgPSBcIlVJTm90aWNlV2luXCI7XG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBob21lVUlcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImhvbWVcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiaG9tZV9mdWkuYnl0ZXNcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgVUlIb21lUGFnZTpzdHJpbmcgPSBcIkhvbWVQYWdlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJTGV2ZWxQYWdlOnN0cmluZyA9IFwiTGV2ZWxQYWdlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJU2hvcFBhZ2U6c3RyaW5nID0gXCJTaG9wUGFnZVwiO1xyXG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIGxvZ2luVUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwibG9naW5cIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImxvZ2luX2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlMb2dpblBhZ2U6c3RyaW5nID0gXCJMb2dpblBhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJU2VsU2VydmVyV2luOnN0cmluZyA9IFwiU2VsU2VydmVyV2luXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUFyZWFJdGVtOnN0cmluZyA9IFwiQXJlYUl0ZW1cIjtcbn0iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3Mgc3RvcnlVSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJzdG9yeVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwic3RvcnlfZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVN0b3J5V2luOnN0cmluZyA9IFwiU3RvcnlXaW5cIjtcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSAnLi9SZXNNYW5hZ2VyJztcclxuaW1wb3J0IHsgVW5pdHlFbmdpbmUgfSBmcm9tICdjc2hhcnAnO1xyXG5cclxuXHJcblxyXG4vLyAtLSBHYW1lT2JqZWN057yT5a2Y5rGgXHJcbi8vIC0tIOazqOaEj++8mlxyXG4vLyAtLSAx44CB5omA5pyJ6ZyA6KaB6aKE6K6+6YO95LuO6L+Z6YeM5Yqg6L2977yM5LiN6KaB55u05o6l5YiwUmVzb3VyY2VzTWFuYWdlcuWOu+WKoOi9ve+8jOeUsei/memHjOe7n+S4gOWBmue8k+WtmOeuoeeQhlxyXG4vLyAtLSAy44CB57yT5a2Y5YiG5Li65Lik6YOo5YiG77ya5LuO6LWE5rqQ5bGC5Yqg6L2955qE5Y6f5aeLR2FtZU9iamVjdChBc3NldCnvvIzku45HYW1lT2JqZWN05a6e5L6L5YyW5Ye65p2l55qE5aSa5LiqSW5zdFxyXG5leHBvcnQgY2xhc3MgR2FtZU9iamVjdFBvb2wgZXh0ZW5kcyBTaW5nbGV0b248R2FtZU9iamVjdFBvb2w+e1xyXG5cclxuICAgIHByaXZhdGUgX19jYWNoZVRyYW5zUm9vdCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9fZ29Qb29sID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBfX2luc3RDYWNoZTpNYXA8c3RyaW5nLEFycmF5PGFueT4+ID0gbmV3IE1hcDxzdHJpbmcsQXJyYXk8YW55Pj4oKTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBsZXQgZ28gPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0LkZpbmQoXCJHYW1lT2JqZWN0Q2FjaGVSb290XCIpO1xyXG5cclxuICAgICAgICBpZihnbyA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBnbyA9IG5ldyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0KFwiR2FtZU9iamVjdENhY2hlUm9vdFwiKTtcclxuICAgICAgICAgICAgVW5pdHlFbmdpbmUuT2JqZWN0LkRvbnREZXN0cm95T25Mb2FkKGdvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX19jYWNoZVRyYW5zUm9vdCA9IGdvLnRyYW5zZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICAvLy0tIOajgOa1i+aYr+WQpuW3sue7j+iiq+e8k+WtmFxyXG4gICAgcHVibGljIGNoZWNrSGFzQ2FjaGVkKHBhdGg6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8YW55PiA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKGNhY2hlZEluc3QgIT0gdW5kZWZpbmVkICYmIGNhY2hlZEluc3QubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBvb2xlZEdvID0gdGhpcy5fX2dvUG9vbC5nZXQocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBvb2xlZEdvICE9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDnvJPlrZjlubblrp7kvovljJZHYW1lT2JqZWN0XHJcbiAgICBwdWJsaWMgY2FjaGVBbmRJbnN0R2FtZU9iamVjdChwYXRoOnN0cmluZywgZ286YW55LCBpbnN0X2NvdW50Om51bWJlciA9IDEpe1xyXG5cclxuICAgICAgICB0aGlzLl9fZ29Qb29sLnNldChwYXRoLCBnbyk7XHJcbiAgICAgICAgaWYoaW5zdF9jb3VudCA+IDApe1xyXG5cclxuICAgICAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8YW55PiA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk6bnVtYmVyID0wOyBpIDwgaW5zdF9jb3VudDsgaSsrKXtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdCA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuSW5zdGFudGlhdGUoZ28pIGFzIFVuaXR5RW5naW5lLkdhbWVPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICBpbnN0LnRyYW5zZm9ybS5TZXRQYXJlbnQodGhpcy5fX2NhY2hlVHJhbnNSb290KTtcclxuICAgICAgICAgICAgICAgIGluc3QuU2V0QWN0aXZlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRJbnN0LnB1c2goaW5zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLSDlsJ3or5Xku47nvJPlrZjkuK3ojrflj5ZcclxuICAgIHB1YmxpYyB0cnlHZXRGcm9tQ2FjaGUocGF0aDpzdHJpbmcpOmFueXtcclxuXHJcbiAgICAgICAgaWYoIXRoaXMuY2hlY2tIYXNDYWNoZWQocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY2FjaGVkSW5zdDpBcnJheTxvYmplY3Q+ICA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKGNhY2hlZEluc3QgIT0gdW5kZWZpbmVkICYmIGNhY2hlZEluc3QubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGluc3QgPSBjYWNoZWRJbnN0LnBvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb29sZWRHbyA9IHRoaXMuX19nb1Bvb2wuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKHBvb2xlZEdvICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGxldCBpbnN0ID0gVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5JbnN0YW50aWF0ZShwb29sZWRHbyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy/pooTliqDovb3vvJrlj6/mj5DkvpvliJ3lp4vlrp7kvovljJbkuKrmlbBcclxuICAgIHB1YmxpYyBhc3luYyBwcmVMb2FkR2FtZU9iamVjdEFzeW5jKHBhdGg6c3RyaW5nLCBpbnN0X2NvdW50Om51bWJlciwgY2FsbGJhY2s6RnVuY3Rpb24sLi4ucGFyYW1zKXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5jaGVja0hhc0NhY2hlZChwYXRoKSl7XHJcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGdvID0gYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkUHJlZmFiKHBhdGgpO1xyXG4gICAgICAgIGlmKGdvIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlQW5kSW5zdEdhbWVPYmplY3QocGF0aCwgZ28saW5zdF9jb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjYWxsYmFjayE9bnVsbCl7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOW8guatpeiOt+WPlu+8muW/heimgeaXtuWKoOi9vVxyXG4gICAgcHVibGljIGFzeW5jIGdldEdhbWVPYmplY3RBc3luYyhwYXRoOnN0cmluZywgY2FsbGJhY2s6RnVuY3Rpb24sLi4ucGFyYW1zKXtcclxuXHJcbiAgICAgICAgbGV0IGluc3Q6YW55ID0gdGhpcy50cnlHZXRGcm9tQ2FjaGUocGF0aCk7XHJcbiAgICAgICAgaWYoaW5zdCA9PW51bGwpe1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZUxvYWRHYW1lT2JqZWN0QXN5bmMocGF0aCwgMSwgY2FsbGJhY2ssIHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnN0ID0gdGhpcy50cnlHZXRGcm9tQ2FjaGUocGF0aCk7XHJcbiAgICAgICAgaW5zdC5TZXRBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOWbnuaUtlxyXG4gICAgcHVibGljIHJlY3ljbGVHYW1lT2JqZWN0KHBhdGg6c3RyaW5nLCBpbnN0OmFueSl7XHJcblxyXG4gICAgICAgIGluc3QudHJhbnNmb3JtLlNldFBhcmVudCh0aGlzLl9fY2FjaGVUcmFuc1Jvb3QpO1xyXG4gICAgICAgIGluc3QuU2V0QWN0aXZlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3QgPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKSB8fCBuZXcgQXJyYXkoKTtcclxuICAgICAgICBjYWNoZWRJbnN0LnB1c2goaW5zdCk7XHJcblxyXG4gICAgICAgIHRoaXMuX19pbnN0Q2FjaGUuc2V0KHBhdGgsIGNhY2hlZEluc3QpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDmuIXnkIbnvJPlrZhcclxuICAgIHB1YmxpYyBjbGVhbnVwKGluY2x1ZGVQb29sZWRHbzpib29sZWFuID0gZmFsc2Upe1xyXG5cclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLmZvckVhY2goKHZhbHVlcywga2V5KT0+e1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBpbnN0IG9mIHZhbHVlcyl7XHJcbiAgICAgICAgICAgICAgICBpZihpbnN0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIFVuaXR5RW5naW5lLkdhbWVPYmplY3QuRGVzdHJveShpbnN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19pbnN0Q2FjaGUuY2xlYXIoKTsgXHJcblxyXG4gICAgICAgIGlmKGluY2x1ZGVQb29sZWRHbyl7XHJcbiAgICAgICAgICAgIHRoaXMuX19nb1Bvb2wuZm9yRWFjaCgoZ28sIGtleSk9PntcclxuXHJcbiAgICAgICAgICAgICAgICBpZihnbyAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLnJlbGVhc2VBZGRyZXNzR08oZ28pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19nb1Bvb2wuY2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJcclxuXHJcbmV4cG9ydCBjbGFzcyBNZXNPYmp7XHJcbiAgICBwdWJsaWMgbGlzdGVuZXJzOkFycmF5PEZ1bmN0aW9uPjtcclxuICAgIHB1YmxpYyBvYmo6YW55O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE1lc3NlbmdlcntcclxuXHJcbiAgICBwcml2YXRlIGxpc3RlbmVyTWFwID0gbmV3IE1hcDxudW1iZXIsTWVzT2JqPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihlX3R5cGU6bnVtYmVyLCBlX29iajphbnksIGVfbGlzdG5lcjpGdW5jdGlvbik6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZihtc2dPYmopID09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgICBtc2dPYmogPSBuZXcgTWVzT2JqKCk7XHJcbiAgICAgICAgICAgIG1zZ09iai5vYmogPSBlX29iajtcclxuICAgICAgICAgICAgbXNnT2JqLmxpc3RlbmVycyA9IG5ldyBBcnJheTxGdW5jdGlvbj4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXNnT2JqLmxpc3RlbmVycy5wdXNoKGVfbGlzdG5lcik7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuc2V0KGVfdHlwZSwgbXNnT2JqKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TGlzdGVuZXIoZV90eXBlOm51bWJlcik6TWVzT2Jqe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBicm9hZGNhc3QoZV90eXBlOm51bWJlciwgLi4ucGFyYW1zOmFueVtdKSA6IHZvaWQge1xyXG5cclxuICAgICAgICBsZXQgbXNnT2JqID0gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0eXBlb2YobXNnT2JqKSAhPSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgZm9yKGxldCBsIG9mIG1zZ09iai5saXN0ZW5lcnMpe1xyXG4gICAgICAgICAgICAgICBsLmFwcGx5KG1zZ09iai5vYmosIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlUeXBlKGVfdHlwZTpudW1iZXIpIDp2b2lkIHtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lck1hcC5kZWxldGUoZV90eXBlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKGVfdHlwZTpudW1iZXIsIGVfbGlzdGVuZXI6RnVuY3Rpb24gKTp2b2lke1xyXG5cclxuICAgICAgICBsZXQgbXNnT2JqID0gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mKG1zZ09iaikgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IGk6bnVtYmVyID0wOyBpPCBtc2dPYmoubGlzdGVuZXJzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKG1zZ09iai5saXN0ZW5lcnNbaV0gPT0gZV9saXN0ZW5lcil7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnT2JqLmxpc3RlbmVycy5zcGxpY2UoaSwxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXJ1cCgpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbn0iLCJcclxuXHJcblxyXG4vLyBGYWlyeUdVSSDlhYPku7Yg57uR5a6a5ZmoXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kZXIobmFtZTpzdHJpbmcpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDphbnksIGtleTpzdHJpbmcgfCBzeW1ib2wpe1xyXG4gICAgICAgIHRhcmdldFtcImJpbmRlcnNcIl0gPSB0YXJnZXRbXCJiaW5kZXJzXCJdIHx8IHt9O1xyXG4gICAgICAgIHRhcmdldFtcImJpbmRlcnNcIl1ba2V5XSA9IG5hbWU7XHJcbiAgICB9XHJcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyAkcHJvbWlzZSB9IGZyb20gJ3B1ZXJ0cyc7XHJcbmltcG9ydCB7TmljZVRTLCBVbml0eUVuZ2luZX0gZnJvbSAnY3NoYXJwJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyL0xvZ2dlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVzTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZXNNYW5hZ2VyPntcclxuXHJcbiAgICBwcml2YXRlIF9wa2dNYXA6TWFwPHN0cmluZyxudW1iZXI+ID0gbmV3IE1hcDxzdHJpbmcsbnVtYmVyPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkRmFpcnlHVUlQYWNrYWdlKHBhY2thZ2VOYW1lOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGtnTWFwLmdldChwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKXtcclxuICAgICAgICAgICAgICAgIC8v5rKh5pyJ57yT5a2Y77yM5Yqg6L29XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHBhY2thZ2VOYW1lK1wiX2Z1aS5ieXRlc1wiO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRGYWlyeUdVSVBhY2thZ2UoYWRkcmVzcyxwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGtnTWFwLnNldChwYWNrYWdlTmFtZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5zZXQocGFja2FnZU5hbWUsIGNvdW50KzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBMb2FkIGZhaXJ5R1VJIDoke3BhY2thZ2VOYW1lfSA6ICR7ZXh9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyByZWxlYXNlRmFpcnlHVUlQYWNrYWdlKHBhY2thZ2VOYW1lKXtcclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGtnTWFwLmdldChwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgaWYoY291bnQhPW51bGwgJiYgY291bnQ+MSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5zZXQocGFja2FnZU5hbWUsIGNvdW50LTEpO1xyXG4gICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhgcmVsZWFzZSBmYWd1aSBwYWNrYWdlOiR7cGFja2FnZU5hbWV9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5kZWxldGUocGFja2FnZU5hbWUpO1xyXG4gICAgICAgICAgICBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlJlbGVhc2VGR1VJUGFja2FnZShwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTY2VuZShzY2VuZU5hbWU6c3RyaW5nLCBtb2RlID0gVW5pdHlFbmdpbmUuU2NlbmVNYW5hZ2VtZW50LkxvYWRTY2VuZU1vZGUuU2luZ2xlKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRTY2VuZShzY2VuZU5hbWUsIG1vZGUsKHByb2dyZXNzOk51bWJlcik9PntcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJsb2FkIHNjZW5lOiBcIitwcm9ncmVzcylcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2Nlbkluc3RhbmNlID0gYXdhaXQgJHByb21pc2UodGFzaylcclxuICAgICAgICAgICAgcmV0dXJuIHNjZW5JbnN0YW5jZVxyXG5cclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBMb2FkIFNjZW5lIDoke3NjZW5lTmFtZX0gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIHVubG9hZFNjZW5lKHNjZW5lSW5zdGFuY2U6VW5pdHlFbmdpbmUuUmVzb3VyY2VNYW5hZ2VtZW50LlJlc291cmNlUHJvdmlkZXJzLlNjZW5lSW5zdGFuY2Upe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2s9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuVW5sb2FkU2NlbmUoc2NlbmVJbnN0YW5jZSlcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBVbmxvYWQgc2NlbmUgIDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bmxvYWRTY2VuZUJ5TmFtZShzY2VuZU5hbWU6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgTmljZVRTLlJlc291cmNlTWFuYWdlci5VbmxvYWRTY2VuZUJ5TmFtZShzY2VuZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRQcmVmYWIoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRQcmVmYWIoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBwcmVmYWIgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRUZXh0QXNzZXQoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkVGV4dEFzc2V0KGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCB0ZXh0YXNzZXQgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIGxvYWRUZXh0Qnl0ZXMoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkVGV4dEJ5dGVzKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgYnl0ZXMgPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZFRleHRCeXRlcyA6JHthZGRyZXNzfSA6ICR7ZXh9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFNwcml0ZShhZGRyZXNzOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRTcHJpdGUoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBzcHJpdGUgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZWxlYXNlQWRkcmVzc0dPKGdvOmFueSl7XHJcblxyXG4gICAgICAgIE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuUmVsZWFzZUFkZHJlc3NHTyhnbyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIFxyXG59IiwiXHJcblxyXG5leHBvcnQgY2xhc3MgU2luZ2xldG9uPFQ+e1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOmFueSA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBJbnN0YW5jZTxUPiggYzogeyBuZXcoKTogVCB9ICkgOiBUe1xyXG5cclxuICAgICAgICBpZih0aGlzLmluc3RhbmNlID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IGMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IFN0b3J5IH0gZnJvbSBcImlua2pzL2VuZ2luZS9TdG9yeVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcblxuZXhwb3J0IGNsYXNzIElua1N0YXRlSW5zcGVjdG9ye1xuXG4gICAgcHVibGljIEJpbmRJbmtNZXRob2RzKGlua1N0b3J5OlN0b3J5KTp2b2lke1xuICAgICAgICBcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiL6YeH55So5q2k5pa55byPXG4gICAgICAgIHRoaXMuYmluZElua01ldGhvZE9uY2UoaW5rU3RvcnksXCJHZXRDaGFyYWN0ZXJOYW1lXCIsdGhpcy5nZXRDaGFyYWN0ZXJOYW1lKTtcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiK6YeH55So5q2k5pa55byPIFxuICAgICAgICB0aGlzLmJpbmRJbmtNZXRob2RPbmNlR2VuZXJhbChpbmtTdG9yeSxcIkdldENoYXJhY3Rlck5hbWVCeU11dGlQYXJhbXNcIix0aGlzLmdldENoYXJhY3Rlck5hbWVNdXRpUGFyYW1zKTtcbiAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENoYXJhY3Rlck5hbWUoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIkp1c3RpbiBUZXN0IFB1ZXJ0c1wiO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2hhcmFjdGVyTmFtZU11dGlQYXJhbXMocDE6bnVtYmVyLHAyOm51bWJlcixwMzpudW1iZXIpOnN0cmluZ3tcbiAgICAgICAgcmV0dXJuIFwiSnVzdGluIE11dGkgUGFyYW1zXCI7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGJpbmRJbmtNZXRob2RPbmNlKGlua1N0b3J5OlN0b3J5LGZ1bmNOYW1lOnN0cmluZyxmdW5jOlN0b3J5LkV4dGVybmFsRnVuY3Rpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgZnVuYyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGJpbmRJbmtNZXRob2RPbmNlR2VuZXJhbChpbmtTdG9yeTpTdG9yeSwgZnVuY05hbWU6c3RyaW5nLGZ1bmM6U3RvcnkuRXh0ZXJuYWxGdW5jdGlvbil7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlua1N0b3J5LkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChmdW5jTmFtZSwgZnVuYyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIHVuYmluZElua01ldGhvZChpbmtTdG9yeTpTdG9yeSxmdW5jTmFtZTpzdHJpbmcpe1xuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuVW5iaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxufSIsImltcG9ydCB7IFN0b3J5IH0gZnJvbSBcImlua2pzL2VuZ2luZS9TdG9yeVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IElua1N0YXRlSW5zcGVjdG9yIH0gZnJvbSBcIi4vSW5rU3RhdGVJbnNwZWN0b3JcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBJbmtXcml0ZXJ7XG5cbiAgICBwdWJsaWMgc3RhdGljIERFQlVHX1NUT1JZX0lEOnN0cmluZyA9IFwiREVCVUdfU1RPUllcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfUFJFRklYOnN0cmluZyA9IFwiPj4+XCI7XG4gICAgcHVibGljIHN0YXRpYyBDT01NQU5EX0RFTElNSVRFUjpzdHJpbmcgPSBcIjpcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfQVJHX0RFTElNSVRFUjpzdHJpbmcgPSAnLCc7XG5cbiAgICBwcml2YXRlIF9jdXJyZW50U3Rvcnk6U3Rvcnk7XG4gICAgcHJpdmF0ZSBfYWxsSW5rQ29tbWFuZHM6TWFwPHN0cmluZyxGdW5jdGlvbj4gPSBuZXcgTWFwPHN0cmluZyxGdW5jdGlvbj4oKTtcblxuXG4gICAgY29uc3RydWN0b3Ioc3RvcnlKc29uOnN0cmluZyl7XG4gICAgICAgIHRoaXMuc2V0dXBJbmtDb21tYW5kcygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0cm95KHN0b3J5SnNvbik7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkKCk6dm9pZHtcbiAgICAgICAgbGV0IHN0b3J5U3RhdGU6c3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYoc3RvcnlTdGF0ZSE9bnVsbCAmJiBzdG9yeVN0YXRlIT1cIlwiKXtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS5Mb2FkSnNvbihzdG9yeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU3Ryb3koanNvbjpzdHJpbmcpe1xuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkgPSBuZXcgU3RvcnkoanNvbik7XG5cbiAgICAgICBcbiAgICB9XG5cbiAgICBwdWJsaWMgYmVnaW5TdG9yeShrbm90TmFtZTpzdHJpbmcpe1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBMb2dnZXIud2FybihcIlRyeWluZyB0byBBZHZhbmNlU3RvcnkgaW4gSW5rV3JpdGVyIHdoZW4gbm8gc3RvcnkgaGFzIGJlZW4gY3JlYXRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5DaG9vc2VQYXRoU3RyaW5nKGtub3ROYW1lLCB0cnVlKTtcblxuICAgICAgICAgbGV0IGlua1N0YXRlOklua1N0YXRlSW5zcGVjdG9yID0gbmV3IElua1N0YXRlSW5zcGVjdG9yKCk7XG4gICAgICAgICBpbmtTdGF0ZS5CaW5kSW5rTWV0aG9kcyh0aGlzLl9jdXJyZW50U3RvcnkpO1xuXG4gICAgICAgIHRoaXMuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdpdmVSZXdhcmQoKTpib29sZWFue1xuICAgICAgICBMb2dnZXIubG9nKFwiZ2l2ZSByZXdhcmQuLi5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cElua0NvbW1hbmRzKCk6dm9pZHtcbiAgICAgICAgdGhpcy5fYWxsSW5rQ29tbWFuZHMuc2V0KFwiR0lWRV9SRVdBUkRcIix0aGlzLmdpdmVSZXdhcmQpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDb21tYW5kKGNvbW1hbmQ6c3RyaW5nLCBhcmdzOnN0cmluZ1tdKTpib29sZWFue1xuICAgICAgICBpZih0aGlzLl9hbGxJbmtDb21tYW5kcy5oYXMoY29tbWFuZCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbElua0NvbW1hbmRzLmdldChjb21tYW5kKShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZXJyb3IoXCJDb3VsZCBub3QgZmluZCBJbmtDb21tYW5kIHdpdGggbmFtZTpcIitjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUNvbW1hbmROYW1lKHRleHQ6c3RyaW5nKTpzdHJpbmd7XG4gICAgICAgIGxldCBudW06bnVtYmVyID0gdGV4dC5pbmRleE9mKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCk7XG4gICAgICAgIGxldCBudW0yOm51bWJlciA9IHRleHQuaW5kZXhPZihJbmtXcml0ZXIuQ09NTUFORF9ERUxJTUlURVIpO1xuICAgICAgICBpZihudW0yID09IC0xKXtcbiAgICAgICAgICAgIG51bTIgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW5ndGg6bnVtYmVyID0gbnVtMiAtIChudW0gKyBJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyKG51bSArIElua1dyaXRlci5DT01NQU5EX1BSRUZJWC5sZW5ndGgsIGxlbmd0aCkudHJpbSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBwYXJzZUNvbW1hbmRBcmdzKHRleHQ6c3RyaW5nKTpzdHJpbmdbXXtcbiAgICAgICAgbGV0IG51bTpudW1iZXIgPSB0ZXh0LmluZGV4T2YoSW5rV3JpdGVyLkNPTU1BTkRfREVMSU1JVEVSKTtcbiAgICAgICAgaWYobnVtID09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlciA9IHRleHQubGVuZ3RoIC0gKG51bSArIDEpO1xuICAgICAgICBsZXQgbGlzdDpzdHJpbmdbXSA9IHRleHQuc3Vic3RyKG51bSsxLCBsZW5ndGgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0oKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdChJbmtXcml0ZXIuQ09NTUFORF9BUkdfREVMSU1JVEVSKTtcbiAgICAgICAgZm9yIChsZXQgaTpudW1iZXI9MDsgaTxsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gbGlzdFtpXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGV4dHJhY3RTcGVha2VyKGxpbmU6c3RyaW5nKTpbc3RyaW5nLHN0cmluZ117XG4gICAgICAgIGlmKGxpbmUuc3RhcnRzV2l0aChJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpKXtcbiAgICAgICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFycmF5OnN0cmluZ1tdID0gbGluZS5zcGxpdCgnOicsMik7XG4gICAgICAgIGlmKGFycmF5Lmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgbGV0IHNwZWFrSUQ6c3RyaW5nID0gYXJyYXlbMF0udHJpbSgpO1xuICAgICAgICAgICAgbGV0IHNwZWFrQ29udGVudDpzdHJpbmcgPSBhcnJheVsxXS50cmltKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbc3BlYWtJRCwgc3BlYWtDb250ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgIH1cblxuICAgIHB1YmxpYyBzYXZlQ3VycmVudFN0b3J5KCk6dm9pZHtcbiAgICAgICAgbGV0IGN1cnJTdGF0ZSA9IHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS50b0pzb24oKTtcbiAgICAgICAgLy9UT0RP772T772B772W772FXG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNvbnRpbnVlKCk6Ym9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdG9yeS5jYW5Db250aW51ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWR2YW5jZVN0b3J5KCk6dm9pZHtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJUcnlpbmcgdG8gQWR2YW5jZVN0b3J5IGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWVuIGNyZWF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9jdXJyZW50U3RvcnkuY2FuQ29udGludWUpe1xuICAgICAgICAgICAgbGV0IHRleHQ6c3RyaW5nID0gdGhpcy5fY3VycmVudFN0b3J5LkNvbnRpbnVlKCkudHJpbSgpO1xuICAgICAgICAgICAgaWYodGV4dCA9PSBcIlwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3BlYWtJRDpzdHJpbmc7XG4gICAgICAgICAgICBsZXQgc3BlYWtDb250ZW50OnN0cmluZztcblxuICAgICAgICAgICAgW3NwZWFrSUQsIHNwZWFrQ29udGVudF0gPSB0aGlzLmV4dHJhY3RTcGVha2VyKHRleHQpO1xuXG4gICAgICAgICAgICBsZXQgY29tbWFuZE5hbWU6c3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzOnN0cmluZ1tdID0gbnVsbDtcbiAgICAgICAgICAgIGlmKHNwZWFrQ29udGVudC5zdGFydHNXaXRoKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCkpe1xuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lID0gdGhpcy5wYXJzZUNvbW1hbmROYW1lKHNwZWFrQ29udGVudCk7XG4gICAgICAgICAgICAgICAgYXJncyA9IHRoaXMucGFyc2VDb21tYW5kQXJncyhzcGVha0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmKGNvbW1hbmROYW1lICE9IG51bGwgJiYgY29tbWFuZE5hbWUgIT1cIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5oYW5kbGVDb21tYW5kKGNvbW1hbmROYW1lLCBhcmdzKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy9PbkNvbnRlbnRSZWFkeVxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikuYnJvYWRjYXN0Q29udGVudFJlYWR5KFxuICAgICAgICAgICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgICAgICAgICBzcGVha0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWFrSUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50VGFncyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIC8vT25DaG9pY2VzUHJlc2VudGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdENob2ljZXNQcmVzZW50ZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdFN0b3J5RmluaXNoZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRURcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3RDaG9pY2UoY2hvaWNlSW5kZXg6bnVtYmVyKTp2b2lke1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBMb2dnZXIud2FybihcIlRyeWluZyB0byBDaG9vc2VDaG9pY2UgaW4gSW5rV3JpdGVyIHdoZW4gbm8gc3RvcnkgaGFzIGJlZ3VuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5DaG9vc2VDaG9pY2VJbmRleChjaG9pY2VJbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcpOmFueXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdG9yeS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKHZhcmlhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcsIHZhbHVlOmFueSl7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS52YXJpYWJsZXNTdGF0ZS4kKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDaG9pY2UgfSBmcm9tIFwiaW5ranMvZW5naW5lL0Nob2ljZVwiO1xuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gXCIuLi9jb21tb24vUmVzTWFuYWdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IElua1dyaXRlciB9IGZyb20gXCIuL0lua1dyaXRlclwiO1xuXG5leHBvcnQgY2xhc3MgU3RvcnlNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFN0b3J5TWFuYWdlcj57XG5cbiAgICBwcml2YXRlIF9pbmtXcml0ZXI6SW5rV3JpdGVyO1xuICAgIHByaXZhdGUgc3RvcnlBZGRyZXNzOnN0cmluZyA9IFwiU3RvcnkvVGVzdFN0b3J5Lmpzb25cIjtcblxuICAgIHB1YmxpYyBnZXQgaW5rV3JpdGVyKCk6SW5rV3JpdGVye1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoKXtcblxuICAgICAgICBpZih0aGlzLl9pbmtXcml0ZXIgPT0gbnVsbCl7XG5cbiAgICAgICAgICAgIHZhciBqc29uID0gIChhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRUZXh0QXNzZXQodGhpcy5zdG9yeUFkZHJlc3MpKS50ZXh0O1xuICAgICAgICAgICAgdGhpcy5faW5rV3JpdGVyID0gbmV3IElua1dyaXRlcihqc29uKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIGJlZ2luU3Rvcnkoa25vdE5hbWU6c3RyaW5nKTp2b2lke1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuYmVnaW5TdG9yeShrbm90TmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNvbnRpbnVlKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmtXcml0ZXIuY2FuQ29udGludWU7XG4gICAgfVxuXG4gICAgcHVibGljIGFkdmFuY2VTdG9yeSgpe1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHNlbGVjdENob2ljZShjaG9pY2U6Q2hvaWNlKTp2b2lke1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuc2VsZWN0Q2hvaWNlKGNob2ljZS5pbmRleCk7XG4gICAgfVxuXG4gICAgcHVibGljIGxvYWRDdXJyZW50KCk6dm9pZHtcbiAgICAgICAgaWYodGhpcy5faW5rV3JpdGVyIT1udWxsKSB0aGlzLl9pbmtXcml0ZXIubG9hZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nKTphbnl7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmtXcml0ZXIuZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZywgdmFsdWU6YW55KXtcbiAgICAgICAgdGhpcy5pbmtXcml0ZXIuc2V0VmFyaWFibGUodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IE1lc3NlbmdlciB9IGZyb20gXCIuLi9jb21tb24vTWVzc2VuZ2VyXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuXG5leHBvcnQgY2xhc3MgU3RvcnlNZXNzYWdlTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxTdG9yeU1lc3NhZ2VNYW5hZ2VyPntcblxuICAgIHB1YmxpYyBzdGF0aWMgT05DT05URU5UUkVBRFk6bnVtYmVyID0gMTAwMTtcbiAgICBwdWJsaWMgc3RhdGljIE9OQ0hPSUNFU1BSRVNFTlRFRDpudW1iZXIgPSAxMDAyO1xuICAgIHB1YmxpYyBzdGF0aWMgT05TVE9SWUZJTklTSEVEOm51bWJlciA9IDEwMDM7XG5cbiAgICBwcml2YXRlIHN0b3J5TWVzc2FnZTpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XG5cblxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihtc2dDb2RlOm51bWJlcixvYmo6YW55LCBsaXN0ZW5lcjpGdW5jdGlvbil7XG5cbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYWRkTGlzdGVuZXIobXNnQ29kZSwgb2JqLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLCBsaXN0ZW5lcjpGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG1zZ0NvZGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXJCeUNvZGUobXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5yZW1vdmVMaXN0ZW5lckJ5VHlwZShtc2dDb2RlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXJ1cCgpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5jbGVhcnVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdENvbnRlbnRSZWFkeShcbiAgICAgICAgbXNnQ29kZTpudW1iZXIsXG4gICAgICAgIHNwZWFrZXJDb250ZW50OnN0cmluZyxcbiAgICAgICAgc3BlYWtlcklkOnN0cmluZyxcbiAgICAgICAgY3VycmVudFRhZ3M6c3RyaW5nW10sXG4gICAgICAgIGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdXG4gICAgICAgIClcbiAgICB7XG5cbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYnJvYWRjYXN0KG1zZ0NvZGUsIHNwZWFrZXJDb250ZW50LHNwZWFrZXJJZCxjdXJyZW50VGFncyxjdXJyZW50Q2hvaWNlcyk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdENob2ljZXNQcmVzZW50ZWQoXG4gICAgICAgIG1lc2dDb2RlOm51bWJlcixcbiAgICAgICAgY3VycmVudENob2ljZXM6Q2hvaWNlW11cbiAgICApe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5icm9hZGNhc3QobWVzZ0NvZGUsY3VycmVudENob2ljZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RTdG9yeUZpbmlzaGVkKG1lc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmJyb2FkY2FzdChtZXNnQ29kZSk7ICAgXG4gICAgfVxufSIsImltcG9ydCB7IFVuaXR5RW5naW5lIH0gZnJvbSAnY3NoYXJwJztcbmltcG9ydCB7IEdhbWVDb25maWcgfSBmcm9tICcuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZyc7XG5lbnVtIExvZ1R5cGUge1xuXHRFcnJvciA9IDAsXG5cdEFzc2VydCA9IDEsXG5cdFdhcm5pbmcgPSAyLFxuXHRMb2cgPSAzLFxuXHRFeGNlcHRpb24gPSA0XG59XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXJ7XG4gICAgcHJpdmF0ZSAgc3RhdGljICB1bml0eV9sb2dfdGFyZ2V0ID0gbnVsbDtcblxuICAgIHN0YXRpYyBnZXRQcmludFN0YWNrKHR5cGU6IExvZ1R5cGUsIHNob3dTdGFjayA6IGJvb2xlYW4sIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgTG9nZ2VyLkxPR19PQkpFQ1RfVE9fSlNPTikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgYXJncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKHNob3dTdGFjayB8fCBVbml0eUVuZ2luZS5BcHBsaWNhdGlvbi5pc0VkaXRvcikge1xuICAgICAgICAgICAgdmFyIHN0YWNrcyA9IG5ldyBFcnJvcigpLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoIUxvZ2dlci51bml0eV9sb2dfdGFyZ2V0KSB7XG4gICAgICAgICAgICBMb2dnZXIudW5pdHlfbG9nX3RhcmdldCA9IG5ldyBVbml0eUVuZ2luZS5PYmplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIFxuXG5cdHN0YXRpYyBsb2coLi4uYXJncyk6IHZvaWR7XG4gICAgICAgIGlmKCFHYW1lQ29uZmlnLmRlYnVnKSByZXR1cm47XG5cbiAgICAgICAgbGV0IG1zZyA9IExvZ2dlci5nZXRQcmludFN0YWNrKExvZ1R5cGUuTG9nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIE91dHB1dHMgYSB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIExvZ2dlci5cblx0ICogQHBhcmFtIG1lc3NhZ2UgIGxpc3Qgb2YgSmF2YVNjcmlwdCBvYmplY3RzIHRvIG91dHB1dC4gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgZWFjaCBvZiB0aGVzZSBvYmplY3RzIGFyZSBhcHBlbmRlZCB0b2dldGhlciBpbiB0aGUgb3JkZXIgbGlzdGVkIGFuZCBvdXRwdXQuXG5cdCAqL1xuXHRzdGF0aWMgd2FybiguLi5hcmdzKTogdm9pZHtcbiAgICAgICAgaWYoIUdhbWVDb25maWcuZGVidWcpIHJldHVybjtcblxuICAgICAgICBsZXQgbXNnID0gTG9nZ2VyLmdldFByaW50U3RhY2soTG9nVHlwZS5XYXJuaW5nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBPdXRwdXRzIGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIExvZ2dlci5cblx0ICogQHBhcmFtIG1lc3NhZ2UgQSBsaXN0IG9mIEphdmFTY3JpcHQgb2JqZWN0cyB0byBvdXRwdXQuIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIGVhY2ggb2YgdGhlc2Ugb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG9nZXRoZXIgaW4gdGhlIG9yZGVyIGxpc3RlZCBhbmQgb3V0cHV0LlxuXHQgKi9cblx0c3RhdGljIGVycm9yKC4uLmFyZ3MpOiB2b2lke1xuICAgICAgICBpZighR2FtZUNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtc2cgPSBMb2dnZXIuZ2V0UHJpbnRTdGFjayhMb2dUeXBlLkVycm9yLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH1cblxuXHQvKiogT3V0cHV0cyBhIHN0YWNrIHRyYWNlIHRvIHRoZSBMb2dnZXIuXG5cdCAqIEBwYXJhbSBtZXNzYWdlIEEgbGlzdCBvZiBKYXZhU2NyaXB0IG9iamVjdHMgdG8gb3V0cHV0LiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiBlYWNoIG9mIHRoZXNlIG9iamVjdHMgYXJlIGFwcGVuZGVkIHRvZ2V0aGVyIGluIHRoZSBvcmRlciBsaXN0ZWQgYW5kIG91dHB1dC5cblx0Ki9cblx0c3RhdGljIHRyYWNlKC4uLmFyZ3MpOiB2b2lke1xuICAgICAgICBpZighR2FtZUNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgbGV0IG1zZyA9IExvZ2dlci5nZXRQcmludFN0YWNrKExvZ1R5cGUuTG9nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG5cblx0LyoqIExvZyBKYXZhU2NyaXB0IE9iamVjdHMgYXMgSlNPTiBmb3JtYXQgKi9cblx0c3RhdGljIExPR19PQkpFQ1RfVE9fSlNPTiguLi5hcmdzKTogYm9vbGVhbntcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IE5ldEVycm9yQ29kZSB9IGZyb20gXCIuL05ldEVycm9yQ29kZVwiO1xyXG5pbXBvcnQgeyBOaWNlVFMgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VQYXJzZXIgfSBmcm9tIFwiLi9NZXNzYWdlUGFyc2VyXCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE1zZ1BhY2t7XHJcbiAgICBwdWJsaWMgc2VuZFRpbWU6bnVtYmVyO1xyXG4gICAgcHVibGljIGNhbGxiYWNrOkZ1bmN0aW9uO1xyXG4gICAgcHVibGljIHJldHJ5VGltZXM6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBieXRlczpVaW50OEFycmF5O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR2FtZVNlc3Npb24gZXh0ZW5kcyBTaW5nbGV0b248R2FtZVNlc3Npb24+e1xyXG5cclxuICAgIHB1YmxpYyBpZDpudW1iZXIgPSAwOyAgLy9zZXNzaW9uIElEXHJcbiAgICBwcml2YXRlIHJlU2VuZEludGVydmFsOm51bWJlciA9IDEwMDAwOyAvLzEw56eS6YeN5Y+R5LiA5qyhXHJcbiAgICBwcml2YXRlIHRpbWVvdXRJbnRlcnZhbDpudW1iZXIgPSA1MDAwOyAvLzXnp5Lmo4Dmn6XkuIDmrKHmmK/lkKbotoXml7ZcclxuICAgIHByaXZhdGUgbWF4UmVTZW5kVGltZXM6bnVtYmVyID0gNTsgLy/mnIDlpKfph43lj5HmrKHmlbBcclxuICAgIHByaXZhdGUgdGltZW91dElpbWVyOmFueTtcclxuXHJcbiAgICBwcml2YXRlIF9ycGNJZDpudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSBjaGFubmVsOmFueTtcclxuICAgIHByaXZhdGUgcmVxdWVzdENhbGxiYWNrOk1hcDxudW1iZXIsTXNnUGFjaz4gPSBuZXcgTWFwPG51bWJlcixNc2dQYWNrPigpO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6TWFwPG51bWJlcixGdW5jdGlvbj4gPSBuZXcgTWFwPG51bWJlcixGdW5jdGlvbj4oKTtcclxuXHJcbiAgICAvL+i/lOWbnueahOacjeWKoeWZqElELCDnsbvlnotcclxuICAgIHByaXZhdGUgX3NlcnZlcklkOm51bWJlciA9IC0xO1xyXG4gICAgcHJpdmF0ZSBfc2VydmVyVHlwZTpudW1iZXIgPSAxO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHJwY0lkKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiArK3RoaXMuX3JwY0lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vYWRkcmVzcy0+IGlwOnBvcnRcclxuICAgIHB1YmxpYyBjb25uZWN0Q2hhbm5lbChhZGRyZXNzOnN0cmluZywgY29ubkNhYmFjazphbnkpe1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSBOaWNlVFMuVFNlcnZpY2UuSW5zdGFuY2UuR2V0Q2hhbm5lbCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5lcnJvckNhbGxiYWNrID0gKGNoYW5uZWw6YW55LCBjb2RlOm51bWJlcik9PntcclxuICAgICAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dE1zZygpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy50aW1lb3V0SW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25uQ2FiYWNrKGNoYW5uZWwsIGNvZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLnJlYWRDYWxsYmFjayA9IChidWZmZXI6VWludDhBcnJheSk9PntcclxuICAgICAgICAgICAgdGhpcy5vblJlY2VpdmUoYnVmZmVyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwuQ29ubmVjdChhZGRyZXNzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy/mjqXmlLbmnI3liqHlmajpgJrnn6VcclxuICAgIHB1YmxpYyBsaXN0ZW4ob3Bjb2RlOm51bWJlcixjYWxsYmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KG9wY29kZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5Y+R6YCBcHJvdG91Ymbmtojmga9cclxuICAgIC8v5raI5oGv77yaIHJwY19pZFs0XSAtIG9wY29kZVsyXSAtIHNlcnZlcl9pZFsyXSAtIHNlcnZlcl90eXBlWzFdIC0gXHJcbiAgICBwdWJsaWMgc2VuZChvcGNvZGU6bnVtYmVyLHJwY2lkOm51bWJlciwgbWVzc2FnZTpVaW50OEFycmF5LCBjYWxsQmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/lsIHoo4Xmtojmga/vvJpcclxuICAgICAgICBsZXQgcnBjQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZUludChycGNpZCk7IC8vNFxyXG4gICAgICAgIGxldCBvcGNvZGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlU2hvcnQob3Bjb2RlKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcmlkQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZVNob3J0KHRoaXMuX3NlcnZlcklkKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcnR5cGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlQnl0ZSh0aGlzLl9zZXJ2ZXJUeXBlKTsgLy8xXHJcblxyXG5cclxuICAgICAgICBsZXQgc2VuZEFycmF5OlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0ICsgMiArIDIgKyAxICttZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChycGNCdWYpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQob3Bjb2RlQnVmLCAgICA0KTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KHNlcnZlcmlkQnVmLCAgNCArIDIpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQoc2VydmVydHlwZUJ1ZiwgNCArIDIgKyAyKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KG1lc3NhZ2UsICAgICAgIDQgKyAyICsgMiArIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNhbGxCYWNrICE9IG51bGwpe1xyXG4gICAgICAgICAgICBsZXQgbXNnUGFjazpNc2dQYWNrID0gbmV3IE1zZ1BhY2soKTtcclxuICAgICAgICAgICAgbXNnUGFjay5zZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBtc2dQYWNrLmNhbGxiYWNrID0gY2FsbEJhY2s7XHJcbiAgICAgICAgICAgIG1zZ1BhY2suYnl0ZXMgPSBzZW5kQXJyYXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5zZXQocnBjaWQsIG1zZ1BhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IobGV0IGkgaW4gc2VuZEFycmF5KXtcclxuICAgICAgICAvLyAgICAgTG9nZ2VyLmxvZyhcIlRTIC0tIHNlbmQgYXJyYXk6IFwiK2kpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvL0xvZ2dlci5sb2coXCJzZW5kIGFycmF5OiBcIitzZW5kQXJyYXkpO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5TZW5kKHNlbmRBcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZVNlbmQoYnl0ZXM6VWludDhBcnJheSl7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsLlNlbmQoYnl0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblJlY2VpdmUoYnVmZmVyOlVpbnQ4QXJyYXkpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBtc2dCdWYgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG5cclxuICAgICAgICBsZXQgcnBjaWQgPSBNZXNzYWdlUGFyc2VyLmRlY29kZUludChtc2dCdWYuc3ViYXJyYXkoMCw0KSk7XHJcbiAgICAgICAgbGV0IG9wY29kZSA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlU2hvcnQobXNnQnVmLnN1YmFycmF5KDQsNikpO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJpZCA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlU2hvcnQobXNnQnVmLnN1YmFycmF5KDYsOCkpO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJ0eXBlID0gTWVzc2FnZVBhcnNlci5kZWNvZGVCeXRlKG1zZ0J1Zi5zdWJhcnJheSg4LDkpKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VydmVySWQgPSBzZXJ2ZXJpZDtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXJUeXBlID0gc2VydmVydHlwZTtcclxuXHJcbiAgICAgICAgbGV0IG1zZ0J5dGVzOlVpbnQ4QXJyYXkgPSBtc2dCdWYuc3ViYXJyYXkoOSk7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IGRlY29kZU1zZyA9ICBPcGNvZGUuZGVjb2RlKG9wY29kZSwgbXNnQnl0ZXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHJwY2lkPT11bmRlZmluZWQgfHwgIXRoaXMucmVxdWVzdENhbGxiYWNrLmhhcyhycGNpZCkpe1xyXG4gICAgICAgICAgICAgICAgLy/mo4Dmn6XmmK/lkKbmmK/mnI3liqHlmajkuIvlj5HnmoTmtojmga9cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGlzdGVuZXJzLmhhcyhvcGNvZGUpKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdGVuID0gdGhpcy5saXN0ZW5lcnMuZ2V0KG9wY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuKGRlY29kZU1zZy5tc2dPYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbGV0IG1zZ1BhY2s6TXNnUGFjayA9IHRoaXMucmVxdWVzdENhbGxiYWNrLmdldChycGNpZCk7XHJcbiAgICAgICAgICAgICAgICBtc2dQYWNrLmNhbGxiYWNrKGRlY29kZU1zZy5tc2dPYmopOyAgXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLmRlbGV0ZShycGNpZCk7XHJcbiAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKFwicGFyc2UgbXNnIGVycm9yLCBvcGNvZGU6XCIrb3Bjb2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGVja1RpbWVvdXRNc2coKXtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLmZvckVhY2goKHZhbHVlLCBrZXkpID0+e1xyXG5cclxuICAgICAgICAgICAgaWYodmFsdWUucmV0cnlUaW1lcyA+PSB0aGlzLm1heFJlU2VuZFRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvL+i2hei/h+acgOWkp+mHjeWPkeasoeaVsO+8jOS4ouW8g1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhgTWVzc2FnZSByZXNlbmQgdG9vIG1vcmUsIG9wY29kZToke2tleX0sIGxhc3RzZW5kOiR7dmFsdWUuc2VuZFRpbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5kZWxldGUoa2V5KTsgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKChjdXJyVGltZSAtIHZhbHVlLnNlbmRUaW1lKSA+PSB0aGlzLnJlU2VuZEludGVydmFsKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXRyeVRpbWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2VuZFRpbWUgPSBjdXJyVGltZTtcclxuICAgICAgICAgICAgICAgICAgICAvL+mHjeWPkea2iOaBr1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVTZW5kKHZhbHVlLmJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKGByZXNlbmQgbWVzc2FnZTosIG9wY29kZToke2tleX0sIHJldHJ5IHRpbWVzOiR7dmFsdWUucmV0cnlUaW1lc31gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdCgpOnZvaWR7XHJcblxyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lb3V0SWltZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwuRGlzcG9zZSgpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgTmljZVRTIH0gZnJvbSBcImNzaGFycFwiO1xuaW1wb3J0IHsgJHByb21pc2UgfSBmcm9tIFwicHVlcnRzXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcblxuZXhwb3J0IGNsYXNzIEh0dHBNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPEh0dHBNYW5hZ2VyPntcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgZ2V0KHVybDpzdHJpbmcpe1xuXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuSHR0cE1hbmFnZXIuR2V0KHVybClcbiAgICAgICAgICAgIGxldCB0eHQgPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcbiAgICAgICAgICAgIHJldHVybiB0eHQ7XG4gICAgICAgIH1jYXRjaChleCl7XG5cbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgR2V0IGVycm9yIDoke3VybH0gOiAke2V4fWApXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBwb3N0KHVybDpzdHJpbmcsIGZvcm06c3RyaW5nKXtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgdGFzaz0gTmljZVRTLkh0dHBNYW5hZ2VyLlBvc3QodXJsLCBmb3JtKVxuICAgICAgICAgICAgbGV0IHR4dCA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHR4dDtcblxuICAgICAgICB9Y2F0Y2goZXgpe1xuXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYFBvc3QgZXJyb3IgOiR7dXJsfSA6ICR7ZXh9YClcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIlxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VQYXJzZXJ7XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlSW50KG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXI6VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBidWZmZXJbMF0gPSBuID4+PiAyNDtcbiAgICAgICAgYnVmZmVyWzFdID0gbiA+Pj4gMTY7XG4gICAgICAgIGJ1ZmZlclsyXSA9IG4gPj4+IDg7XG4gICAgICAgIGJ1ZmZlclszXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUludChidWZmZXI6VWludDhBcnJheSk6bnVtYmVye1xuICAgICAgICBcbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF0gPDwgMjQgfCBidWZmZXJbMV0gPDwgMTYgfCBidWZmZXJbMl0gPDwgOCB8IGJ1ZmZlclszXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlU2hvcnQobjpudW1iZXIpOlVpbnQ4QXJyYXl7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gODtcbiAgICAgICAgYnVmZmVyWzFdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb2RlU2hvcnQoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXSA8PCA4IHwgYnVmZmVyWzFdO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuXG4gICAgcHVibGljIHN0YXRpYyBlbmNvZGVCeXRlKG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXIgOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICAgICAgYnVmZmVyWzBdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUJ5dGUoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuXG59IiwiXG5cbiBleHBvcnQgY2xhc3MgTmV0RXJyb3JDb2RlXG4ge1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ublN1Y2M6bnVtYmVyID0gMTAwMDAwO1xuXG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Db25uZWN0R2F0ZUtleUVycm9yOm51bWJlciA9IDEwMDAwNjtcblxuICAgICBwdWJsaWMgc3RhdGljICBFUlJfUGVlckRpc2Nvbm5lY3Q6bnVtYmVyICAgPSAxMDIwMDg7XG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Tb2NrZXRDYW50U2VuZDpudW1iZXIgICA9IDEwMjAwOTtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldEVycm9yOm51bWJlciAgICAgID0gMTAyMDEwO1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ubkVycm9yOm51bWJlciAgPSAxMDIwMTE7XG5cblxuICAgICBcblxuIH0iLCJcbmltcG9ydCB7IE9wY29kZSB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL09wY29kZVwiO1xuaW1wb3J0IHsgR2FtZUNvbmZpZyB9IGZyb20gXCIuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuL0dhbWVTZXNzaW9uXCI7XG5pbXBvcnQgeyBOZXRFcnJvckNvZGUgfSBmcm9tIFwiLi9OZXRFcnJvckNvZGVcIjtcblxuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbk1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2Vzc2lvbk1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBzZXNzaW9uUmVhbTpHYW1lU2Vzc2lvbjtcbiAgICBwcml2YXRlIHNlc3Npb25HYXRlOkdhbWVTZXNzaW9uO1xuXG5cbiAgICBwdWJsaWMgZ2V0IHJlYWxtUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblJlYW0ucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnYXRlUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkdhdGUucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNvbm5lY3RSZWFsbVNlcnZlcigpOlByb21pc2U8Ym9vbGVhbj4ge1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8Ym9vbGVhbj4ocmVzb3ZlID0+e1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbSA9IEdhbWVTZXNzaW9uLkluc3RhbmNlKEdhbWVTZXNzaW9uKS5jb25uZWN0Q2hhbm5lbChcbiAgICAgICAgICAgICAgICBHYW1lQ29uZmlnLnJlYWxtU2VydmVySVArXCI6XCIrR2FtZUNvbmZpZy5yZWFsbVNlcnZlclBvcnQsXG4gICAgICAgICAgICAgICAgKGNoYW5uZWw6YW55LGNvZGU6bnVtYmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZihjb2RlID09IE5ldEVycm9yQ29kZS5FUlJfU29ja2V0Q29ublN1Y2Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5pZCA9IGNoYW5uZWwuSWQ7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZShmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihcImxvZ2luIHJlYW1zZXJ2ZXIgZXJyLCBjb2RlOiBcIitjb2RlICsgXCIsaWQ6XCIrY2hhbm5lbC5JZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG4gICAgXG4gICAgcHVibGljIGRpc2Nvbm5lY3RSZWFsbVNlcnZlcigpe1xuICAgICAgICB0aGlzLnNlc3Npb25SZWFtLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbSA9IG51bGw7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgYXN5bmMgc2VuZFJlYWxtTXNnKG9wY29kZTpudW1iZXIsbXNnOmFueSk6UHJvbWlzZTxhbnk+e1xuICAgICAgICBcbiAgICAgICAgbGV0IHJwY0lEID0gdGhpcy5zZXNzaW9uUmVhbS5ycGNJZFxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGFueT4oKHJlc292ZSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgYnVmID0gT3Bjb2RlLmVuY29kZShvcGNvZGUsIG1zZylcblxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5zZW5kKG9wY29kZSwgcnBjSUQsIGJ1ZiwgKHJlc3BvbnNlOmFueSk9PntcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc292ZShyZXNwb25zZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cblxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0R2F0ZVNlcnZlcihhZGRyZXNzOnN0cmluZyk6UHJvbWlzZTxib29sZWFuPntcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGJvb2xlYW4+KHJlc292ZSA9PntcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUgPSBHYW1lU2Vzc2lvbi5JbnN0YW5jZShHYW1lU2Vzc2lvbikuY29ubmVjdENoYW5uZWwoXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbDphbnksY29kZTpudW1iZXIpPT57XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJsb2dpbiBHYXRlIFNlcnZlcjogXCIrY29kZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvZGUgPT0gTmV0RXJyb3JDb2RlLkVSUl9Tb2NrZXRDb25uU3VjYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlLmlkID0gY2hhbm5lbC5JZDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUoZmFsc2UpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihcImdhdGUgc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cblxuICAgIHB1YmxpYyBkaXNjb25uZWN0R2F0ZVNlcnZlcigpe1xuICAgICAgICB0aGlzLnNlc3Npb25HYXRlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRHYXRlTXNnKG9wY29kZTpudW1iZXIsIG1zZzphbnkpOlByb21pc2U8YW55PntcblxuICAgICAgICBsZXQgcnBjSUQgPSB0aGlzLnNlc3Npb25HYXRlLnJwY0lkXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8YW55PigocmVzb3ZlKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBidWYgPSBPcGNvZGUuZW5jb2RlKG9wY29kZSwgbXNnKVxuXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlLnNlbmQob3Bjb2RlLCBycGNJRCwgYnVmLCAocmVzcG9uc2U6YW55KT0+e1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb3ZlKHJlc3BvbnNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuXG4gICAgfVxufSAgIFxuIiwiaW1wb3J0IHsgVW5pdHlFbmdpbmUgfSBmcm9tIFwiY3NoYXJwXCI7XG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlU2NlbmV7XG5cbiAgICBwcml2YXRlIHByZWxvYWRQcmVmYWI6TWFwPHN0cmluZyxudW1iZXI+O1xuICAgIHByaXZhdGUgc2NlbmVJbnN0YW5jZTpVbml0eUVuZ2luZS5SZXNvdXJjZU1hbmFnZW1lbnQuUmVzb3VyY2VQcm92aWRlcnMuU2NlbmVJbnN0YW5jZVxuXG4gICAgcHVibGljIGZpbmlzaENvdW50ID0gMDtcbiAgICBwdWJsaWMgdG90YWxDb3VudCA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIgPSBuZXcgTWFwPHN0cmluZyxudW1iZXI+KCk7XG4gICAgICAgIHRoaXMuZmluaXNoQ291bnQgPSAwO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRQcmVsb2FkUHJlZmFiKGFkZHJlc3M6c3RyaW5nLCBpbnN0Q291bnQpe1xuICAgICAgICBpZighdGhpcy5wcmVsb2FkUHJlZmFiLmhhcyhhZGRyZXNzKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLnNldChhZGRyZXNzLCBpbnN0Q291bnQpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLnNldChhZGRyZXNzLCB0aGlzLnByZWxvYWRQcmVmYWIuZ2V0KGFkZHJlc3MpICsgaW5zdENvdW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0U2NlbmVJbnN0YW5jZShzY2VuZUluc3RhbmNlOlVuaXR5RW5naW5lLlJlc291cmNlTWFuYWdlbWVudC5SZXNvdXJjZVByb3ZpZGVycy5TY2VuZUluc3RhbmNlKXtcbiAgICAgICAgdGhpcy5zY2VuZUluc3RhbmNlID0gc2NlbmVJbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25FbnRlcigpO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkNvbXBsZXRlKCk7XG4gICAgcHVibGljIGFic3RyYWN0IG9uTGVhdmUoKTtcblxuICAgIHB1YmxpYyBhc3luYyBsb2FkQXNzZXRzQXN5bmMoKXtcblxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSB0aGlzLnByZWxvYWRQcmVmYWIuc2l6ZTtcblxuICAgICAgICBsZXQgcHJlbWlzZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIGxldCBwcmVtaXNlID0gUy5HYW1lT2JqZWN0UG9vbC5wcmVMb2FkR2FtZU9iamVjdEFzeW5jKGtleSwgdmFsdWUsKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaENvdW50Kys7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcHJlbWlzZXMucHVzaChwcmVtaXNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJlbWlzZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkRlc3Ryb3koKXtcbiBcbiAgICAgICAgLy/muIXnkIbotYTmupDnvJPlrZhcbiAgICAgICAgUy5HYW1lT2JqZWN0UG9vbC5jbGVhbnVwKHRydWUpO1xuXG4gICAgICAgIC8v5Y246L295Zy65pmvXG4gICAgICAgIFMuUmVzTWFuYWdlci51bmxvYWRTY2VuZSh0aGlzLnNjZW5lSW5zdGFuY2UpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLmNsZWFyKCk7XG4gICAgfVxufSIsImV4cG9ydCAgY2xhc3MgU2NlbmVEZWZ7XG5cbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmdTY2VuZTpzdHJpbmcgPSBcIkxvYWRpbmdTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgTGF1bmNoU2NlbmU6c3RyaW5nID0gXCJMYXVuY2hTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgSG9tZVNjZW5lOnN0cmluZyA9IFwiSG9tZVNjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBMb2dpblNjZW5lOnN0cmluZyA9IFwiTG9naW5TY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUHZlU2NlbmU6c3RyaW5nID0gXCJQdmVTY2VuZVwiO1xufVxuIiwiaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4vQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFB2ZVNjZW5lIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL3B2ZS9zY2VuZS9QdmVTY2VuZVwiO1xyXG5pbXBvcnQgeyBIb21lU2NlbmUgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvaG9tZS9zY2VuZS9Ib21lU2NlbmVcIjtcclxuaW1wb3J0IHsgTG9naW5TY2VuZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi9zY2VuZS9Mb2dpblNjZW5lXCI7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSBcIi4vU2NlbmVEZWZcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lRmFjdG9yeXtcclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVTY2VuZShzY2VuZU5hbWU6c3RyaW5nKTpCYXNlU2NlbmV7XHJcblxyXG4gICAgICAgIGxldCBzY2VuZTpCYXNlU2NlbmUgPSBudWxsO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHNjZW5lTmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuTG9naW5TY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IExvZ2luU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjZW5lRGVmLkhvbWVTY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IEhvbWVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuUHZlU2NlbmU6XHJcbiAgICAgICAgICAgICAgICBzY2VuZSA9IG5ldyBQdmVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvZXZlbnQvVUlNZXNzYWdlXCI7XG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuL0Jhc2VTY2VuZVwiO1xuaW1wb3J0IHsgU2NlbmVGYWN0b3J5IH0gZnJvbSBcIi4vU2NlbmVGYWN0b3J5XCI7XG5cblxuXG5cbmV4cG9ydCBjbGFzcyBTY2VuZU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2NlbmVNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgY3VycmVudFNjZW5lOkJhc2VTY2VuZSA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2NlbmUoc2NlbmU6c3RyaW5nKXtcbiAgICAgICAgXG4gICAgICAgIHRyeXtcblxuICAgICAgICAgICAgLy/miZPlvIBMb2FkaW5n55WM6Z2iXG4gICAgICAgICAgICBTLlVJTWFuYWdlci5vcGVuTG9hZGluZyhjb21tb25VSS5QYWNrYWdlTmFtZSwgY29tbW9uVUkuVUlMb2FkaW5nUGFnZSk7XG5cbiAgICAgICAgICAgIC8v5riF55CG5pen5Zy65pmvXG4gICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL+W8gOWni+WKoOi9veWcuuaZr1xuICAgICAgICAgICAgbGV0IHNjZW5lSW5zdGFuY2UgPSBhd2FpdCBTLlJlc01hbmFnZXIubG9hZFNjZW5lKHNjZW5lKTtcblxuICAgICAgICAgICAgLy/lvIDlp4vliqDovb3ov5vlhaXlnLrmma/nmoTotYTmupBcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gIFNjZW5lRmFjdG9yeS5jcmVhdGVTY2VuZShzY2VuZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5zZXRTY2VuZUluc3RhbmNlKHNjZW5lSW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25FbnRlcigpO1xuXG4gICAgICAgICAgICAvL+iuvue9ruW9k+WJjeWcuuaZr+WKoOi9vei/m+W6plRpbWVyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3NJbnRlcnZhbCA9IHNldEludGVydmFsKCgpPT57XG5cbiAgICAgICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSB0aGlzLmN1cnJlbnRTY2VuZS5maW5pc2hDb3VudC90aGlzLmN1cnJlbnRTY2VuZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJwcm9ncmVzczpcIitwcm9ncmVzcyArIFwiID0gXCIrdGhpcy5jdXJyZW50U2NlbmUuZmluaXNoQ291bnQgKyBcIiA9IFwiK3RoaXMuY3VycmVudFNjZW5lLnRvdGFsQ291bnQpO1xuXG4gICAgICAgICAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIuYnJvYWRjYXN0KFxuICAgICAgICAgICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyoxMDApO1xuXG4gICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgICAvL+WKoOi9vei1hOa6kFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2NlbmUubG9hZEFzc2V0c0FzeW5jKCk7XG5cbiAgICAgICAgICAgIC8v5Yqg6L295a6M5oiQXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHByb2dyZXNzSW50ZXJ2YWwpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkNvbXBsZXRlKClcbiAgICAgICAgICAgIFMuVUlNYW5hZ2VyLmNsb3NlTG9hZGluZyhjb21tb25VSS5VSUxvYWRpbmdQYWdlKTtcblxuICAgICAgICB9Y2F0Y2goZXgpe1xuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcImxvYWQgc2NlbmUgZXhjZXA6XCIrZXgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuXG5cbiAgICBcbn0iLCJcclxuXHJcblxyXG5leHBvcnQgZW51bSBVSVR5cGVEZWZ7XHJcbiAgICBVbmtvd24gPSAwLFxyXG4gICAgUGFnZSA9IDEsXHJcbiAgICBXaW5kb3c9MixcclxuICAgIFdpZGdldCA9IDMsXHJcbiAgICBMb2FkaW5nID00XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxheWVyRGVme1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQmFja2dyb3VuZDpudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBQYWdlOm51bWJlciA9IDEwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIE5vcm1hbFdpbmRvdzpudW1iZXIgPSAyMDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBUb3BXaW5kb3c6bnVtYmVyID0gMzAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgV2lkZ2V0Om51bWJlciA9IDQwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmc6bnVtYmVyID0gNTAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgVW5rb3duOm51bWJlciA9IDk5OTk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyAgZ2V0RGVmYXVsdExheWVyKHR5cGU6VUlUeXBlRGVmKTpudW1iZXJ7XHJcblxyXG4gICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuTG9hZGluZzogcmV0dXJuIHRoaXMuTG9hZGluZztcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuV2lkZ2V0OiByZXR1cm4gdGhpcy5XaWRnZXQ7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLldpbmRvdzogcmV0dXJuIHRoaXMuTm9ybWFsV2luZG93O1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5QYWdlOiByZXR1cm4gdGhpcy5QYWdlO1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5Vbmtvd246IHJldHVybiB0aGlzLlVua293bjtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuVW5rb3duOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlDb21EZWZze1xyXG4gICAgcHVibGljIHN0YXRpYyBCYWNrQnRuID0gXCJiYWNrX2J0blwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBXaW5kb3dDbG9zZUJ0biA9IFwid2luX2Nsb3NlX2J0blwiO1xyXG59XHJcblxyXG5cclxuXHJcbiIsIlxyXG5pbXBvcnQgeyBVSUxvZ2luUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSUxvZ2luUGFnZVwiO1xyXG5pbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSUhvbWVQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlIb21lUGFnZVwiO1xyXG5pbXBvcnQgeyBVSUxvYWRpbmcgfSBmcm9tIFwiLi9VSUxpYi9VSUxvYWRpbmdcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IGhvbWVVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2hvbWVcIjtcclxuaW1wb3J0IHsgVUlNc2dCb3ggfSBmcm9tIFwiLi9VSUxpYi9VSU1zZ0JveFwiO1xyXG5pbXBvcnQgeyBVSVNlbFNlcnZlcldpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlbFNlcnZlcldpblwiO1xyXG5pbXBvcnQgeyBVSVNob3BQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlTaG9wUGFnZVwiO1xyXG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcclxuaW1wb3J0IHsgVUlTdG9yeVdpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9zdG9yeS9VSVN0b3J5V2luXCI7XHJcbmltcG9ydCB7IGNvbWJhdFVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tYmF0XCI7XHJcbmltcG9ydCB7IFVJR3VpZGVXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvZ3VpZGUvVUlHdWlkZVdpblwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuXHJcblxyXG5jb25zdCBDUyA9IHJlcXVpcmUoJ2NzaGFycCcpO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUZhY3Rvcnl7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB1aUNhY2hlOk1hcDxzdHJpbmcsVUlQYW5lbD4gPSBuZXcgTWFwPHN0cmluZyxVSVBhbmVsPigpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlVUkocGtnOnN0cmluZywgbmFtZTpzdHJpbmcpe1xyXG4gICAgICAgIExvZ2dlci5sb2coYGNyZWF0ZSBVSTogJHtwa2d9OiR7bmFtZX1gKVxyXG4gICAgICAgIGxldCBjb21wID0gQ1MuRmFpcnlHVUkuVUlQYWNrYWdlLkNyZWF0ZU9iamVjdChwa2csIG5hbWUpLmFzQ29tXHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHVpOlVJUGFuZWwgPSB0aGlzLnVpQ2FjaGUuZ2V0KG5hbWUpO1xyXG5cclxuICAgICAgICBpZighdWkpe1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoKHBrZyl7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBjb21tb25VSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbW1vblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vblVJLlVJVUlOb3RpY2VXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSU1zZ0JveCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlMb2FkaW5nUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlVSUd1aWRlV2luOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlHdWlkZVdpbigpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuUGFja2FnZU5hbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2dpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuVUlMb2dpblBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSUxvZ2luUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbG9naW5VSS5VSVNlbFNlcnZlcldpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU2VsU2VydmVyV2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2UgY29tYmF0VUkuUGFja2FnZU5hbWU6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5VSUhvbWVQYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlIb21lUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaG9tZVVJLlVJU2hvcFBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVNob3BQYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2Ugc3RvcnlVSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHN0b3J5VUkuVUlTdG9yeVdpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU3RvcnlXaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51aUNhY2hlLnNldChuYW1lLCB1aSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHVpIT1udWxsKXtcclxuICAgICAgICAgICAgdWkuZnVpID0gY29tcDtcclxuICAgICAgICAgICAgdWkubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIHVpLnBrZ05hbWUgPSBwa2c7XHJcblxyXG4gICAgICAgICAgICAvL+e7keWumkZhaXJ5R1VJ5o6n5Lu2XHJcbiAgICAgICAgICAgIHVpLmJpbmRBbGwodWkpO1xyXG4gICAgICAgICAgICB1aS5hd2FrZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYG5vdCBjcmVhdGUgdWk6ICR7cGtnfS0ke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4uL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlUeXBlRGVmIH0gZnJvbSBcIi4uL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2dhbWUvZXZlbnQvVUlNZXNzYWdlXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzICBVSUxvYWRpbmcgZXh0ZW5kcyBVSVBhbmVse1xyXG5cclxuXHJcbiAgICBAYmluZGVyKFwibG9hZGluZ19wcmVncmVzc1wiKVxyXG4gICAgcHVibGljIHByb2dyZXNzTG9hZGluZzogRmFpcnlHVUkuR1Byb2dyZXNzQmFyO1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTogdm9pZCB7XHJcbiAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5Mb2FkaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblNob3coYXJnOmFueSk6dm9pZHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52YWx1ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAocHJvZ3Jlc3M6bnVtYmVyKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcuVHdlZW5WYWx1ZShwcm9ncmVzcywgMC4xKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIucmVtb3ZlTGlzdGVuZXJCeUNvZGUoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0NFTkVfUFJPR1JFU1NcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi9VSVdpbmRvd1wiO1xyXG5cclxuLy8g6YCa55So5by556qXXHJcbmV4cG9ydCBjbGFzcyBVSU1zZ0JveEFyZ3tcclxuICAgIHB1YmxpYyB0aXRsZTpzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGNvbnRlbnQ6c3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBidG5UZXh0OnN0cmluZyA9IFwiXCI7Ly9cIuehruWumnzlj5bmtoh85YWz6ZetXCJcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSU1zZ0JveCBleHRlbmRzIFVJV2luZG93e1xyXG5cclxuICAgIHByaXZhdGUgbV9hcmc6VUlNc2dCb3hBcmc7XHJcblxyXG4gICAgQGJpbmRlcihcIm1zZ1R4dFwiKVxyXG4gICAgcHJpdmF0ZSBtX3R4dDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwib2tCdG5cIilcclxuICAgIHByaXZhdGUgbV9va0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImNhbmNlbEJ0blwiKVxyXG4gICAgcHJpdmF0ZSBtX2NhbmNlbEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kQWxsKHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uU2hvdyhhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgIFxyXG4gICAgfVxyXG5cclxufSIsIlxyXG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tICcuLi9jb21tb24vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgVUlMb2FkaW5nIH0gZnJvbSAnLi9VSUxpYi9VSUxvYWRpbmcnO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gJy4vVUlXaW5kb3cnO1xyXG5pbXBvcnQgeyBVSVdpZGdlIH0gZnJvbSAnLi9VSVdpZGdlJztcclxuaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gJy4vVUlQYW5lbCc7XHJcbmltcG9ydCB7IFVJRmFjdG9yeSB9IGZyb20gJy4vVUlGYWN0b3J5JztcclxuaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSAnLi4vLi4vZGF0YS91aS9ob21lJztcclxuaW1wb3J0IHsgUyB9IGZyb20gJy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyL0xvZ2dlcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJUGFnZVRyYWNre1xyXG4gICAgcHVibGljIHBrZzpzdHJpbmc7XHJcbiAgICBwdWJsaWMgbmFtZTpzdHJpbmc7XHJcbiAgICBwdWJsaWMgYXJnOmFueTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248VUlNYW5hZ2VyPntcclxuXHJcbiAgICBwcml2YXRlICBtX3BhZ2VUcmFja1N0YWNrOkFycmF5PFVJUGFnZVRyYWNrPjtcclxuICAgIHByaXZhdGUgbV9jdXJyZW50UGFnZTpVSVBhZ2VUcmFjaztcclxuXHJcbiAgICBwcml2YXRlIG1fbGlzdExvYWRlZFBhbmVsOkFycmF5PFVJUGFuZWw+O1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjayA9IG5ldyBBcnJheTxVSVBhZ2VUcmFjaz4oKTtcclxuICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsID0gbmV3IEFycmF5PFVJUGFuZWw+KCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGlzdHJveUFsbExvYWRlZFBhbmVsKCk6dm9pZHtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xyXG4gICAgICAgICAgICBsZXQgcGFuZWwgPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYocGFuZWwuaXNPcGVuKXtcclxuICAgICAgICAgICAgICAgIHBhbmVsLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/ljbjovb3otYTmupBcclxuICAgICAgICAgICAgUy5SZXNNYW5hZ2VyLnJlbGVhc2VGYWlyeUdVSVBhY2thZ2UocGFuZWwucGtnTmFtZSk7XHJcbiAgICAgICAgICAgIHBhbmVsLmRpc3Bvc2UoKTsgIFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFuKCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXN0cm95QWxsTG9hZGVkUGFuZWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBvcGVuKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcbiAgIFxyXG4gICAgICAgIGxldCB1aTphbnkgPSB0aGlzLmdldFVJKG5hbWUpO1xyXG5cclxuICAgICAgICBpZih1aSA9PSBudWxsKXtcclxuICAgICAgICAgICAgLy/liqDovb0gcGFja2FnZVxyXG4gICAgICAgICAgICBhd2FpdCBTLlJlc01hbmFnZXIubG9hZEZhaXJ5R1VJUGFja2FnZShwa2cpO1xyXG4gICAgICAgICAgICB1aSA9IFVJRmFjdG9yeS5jcmVhdGVVSShwa2csIG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLnB1c2godWkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodWkgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vICMjIyAgdWkgYXMgYW55IOiwg+eUqOengeacieaWueazlVxyXG4gICAgICAgICAgICAodWkgYXMgYW55KS5faW50ZXJuYWxPcGVuKGFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXRVSShuYW1lOnN0cmluZyk6VUlQYW5lbHtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBwYW5lbCBvZiB0aGlzLm1fbGlzdExvYWRlZFBhbmVsKSB7XHJcbiAgICAgICAgICAgIGlmKHBhbmVsLm5hbWUgPT0gbmFtZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhcImZpbmQgcGFuZWwgaW4gY2FjaGU6IFwiK25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYW5lbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvL+aJk+W8gOWcuuaZr+mhtemdoizmraTpobXpnaLkuI3orqHlhaXpobXpnaLmoIgs5peg6L+U5Zue5LiK5LiA6Z2i5oyJ6ZKuXHJcbiAgICBwdWJsaWMgb3BlblBhZ2VJblNjZW5lKHBrZzpzdHJpbmcsIHBhZ2U6c3RyaW5nLCBhcmc6YW55KXtcclxuICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHBrZywgcGFnZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSUxvYWRpbmdcclxuICAgIC8v5omT5byATG9hZGluZ+eVjOmdolxyXG4gICAgcHVibGljIG9wZW5Mb2FkaW5nKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcblxyXG4gICAgICAgIHRoaXMub3BlblBhZ2VJblNjZW5lKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICB9XHJcbiAgICAvL+WFs+mXrUxvYWRpbmfnlYzpnaJcclxuICAgIHB1YmxpYyBjbG9zZUxvYWRpbmcobmFtZTpzdHJpbmcsIGFyZz86YW55KTp2b2lke1xyXG4gICAgICAgIGxldCB1aTpVSUxvYWRpbmcgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJTG9hZGluZztcclxuICAgICAgICBpZih1aSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdWkuY2xvc2UoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVBhZ2VcclxuICAgIHByaXZhdGUgb3BlblBhZ2VXb3JrZXIocGtnOnN0cmluZywgcGFnZTpzdHJpbmcsIGFyZzphbnkpe1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZSA9IG5ldyBVSVBhZ2VUcmFjaygpO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5wa2cgPSBwa2c7XHJcbiAgICAgICAgdGhpcy5tX2N1cnJlbnRQYWdlLm5hbWUgPSBwYWdlO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5hcmcgPSBhcmc7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzdHJveUFsbExvYWRlZFBhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMub3Blbihwa2csIHBhZ2UsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/miZPlvIDpobXpnaIsIOS8muWFs+mXreS4iuS4gOS4qumhtemdouS4iueahOaJgOacieeql+WPoyxXaWRpZ2V0562JXHJcbiAgICBwdWJsaWMgb3BlblBhZ2UocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZz86YW55KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2N1cnJlbnRQYWdlICE9IHVuZGVmaW5lZCAmJiB0aGlzLm1fY3VycmVudFBhZ2UubmFtZSE9bmFtZSl7XHJcbiAgICAgICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5wdXNoKHRoaXMubV9jdXJyZW50UGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHBrZywgbmFtZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+i/lOWbnuS4iuS4gOS4qumhtemdolxyXG4gICAgcHVibGljIGdvQmFja1BhZ2UoKTp2b2lke1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fcGFnZVRyYWNrU3RhY2subGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMubV9wYWdlVHJhY2tTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcih0cmFjay5wa2cgLHRyYWNrLm5hbWUsIHRyYWNrLmFyZyk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJNYWluUGFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8v5Zue5Yiw5Li75Z+OXHJcbiAgICBwdWJsaWMgZW50ZXJNYWluUGFnZSgpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMub3BlblBhZ2VJblNjZW5lKGhvbWVVSS5QYWNrYWdlTmFtZSAsaG9tZVVJLlVJSG9tZVBhZ2UsbnVsbClcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpbmRvd1xyXG4gICAgLy/miZPlvIDnqpflj6NcclxuICAgIHB1YmxpYyBhc3luYyBvcGVuV2luZG93KHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc6YW55KXtcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2luZG93ID0gYXdhaXQgdGhpcy5vcGVuKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5YWz6Zet56qX5Y+jXHJcbiAgICBwdWJsaWMgY2xvc2VXaW5kb3cobmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaW5kb3cgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJV2luZG93O1xyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICB1aS5jbG9zZShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpZGdldFxyXG4gICAgLy/miZPlvIBXaWRpZ2V0XHJcbiAgICBwdWJsaWMgYXN5bmMgb3BlbldpZGdldChwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpZGdlID0gYXdhaXQgdGhpcy5vcGVuKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdeWFs+mXrVdpZGlnZXRcclxuICAgIHB1YmxpYyBjbG9zZVdpZGdldChuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpZGdlID0gdGhpcy5nZXRVSShuYW1lKSBhcyBVSVdpZGdlO1xyXG4gICAgICAgIGlmKHVpIT1udWxsKXtcclxuICAgICAgICAgICAgdWkuY2xvc2UoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFuZWwgfSBmcm9tIFwiLi9VSVBhbmVsXCI7XHJcbmltcG9ydCB7IFVJVHlwZURlZiwgVUlDb21EZWZzIH0gZnJvbSBcIi4vVUlEZWZpbmVcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUGFnZSBleHRlbmRzIFVJUGFuZWx7XHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLlBhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtX2J0bkdvQmFjazpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2J0bkdvQmFjayA9IHRoaXMuZnVpLkdldENoaWxkKFVJQ29tRGVmcy5CYWNrQnRuKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2J0bkdvQmFjayE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5tX2J0bkdvQmFjay5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkJ0bkdvQmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xyXG5cclxuICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgIFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25CdG5Hb0JhY2soKXtcclxuICAgICAgICBTLlVJTWFuYWdlci5nb0JhY2tQYWdlKCk7XHJcbiAgICB9XHJcblxyXG59ICIsImltcG9ydCB7IFVJVHlwZURlZiwgVUlMYXllckRlZiB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUGFuZWwge1xyXG5cclxuICAgIHB1YmxpYyBmdWk6YW55OyAgLy9GYWlyeUdVSSDlr7nosaFcclxuXHJcbiAgICBwdWJsaWMgcGtnTmFtZTpzdHJpbmc7XHJcblxyXG5cclxuICAgIHByaXZhdGUgX25hbWU6c3RyaW5nO1xyXG4gICAgcHVibGljIHNldCBuYW1lKHY6c3RyaW5nKXtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgbmFtZSgpOnN0cmluZ3tcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLlVua293bjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBtX2xheWVyOlVJTGF5ZXJEZWYgPSBVSUxheWVyRGVmLlVua293bjtcclxuICAgIHB1YmxpYyBnZXQgbGF5ZXIoKSA6IFVJTGF5ZXJEZWYge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fbGF5ZXI7IFxyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBsYXllcih2IDogVUlMYXllckRlZikge1xyXG4gICAgICAgIHRoaXMubV9sYXllciA9IHY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyAgZ2V0IGlzT3BlbigpIDogYm9vbGVhbntcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVpLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQXdha2UoKTp2b2lkO1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uU2hvdyh2bzphbnkpOnZvaWQ7XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25DbG9zZShhcmc6YW55KTp2b2lkO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgb25VcGRhdGUoKTp2b2lke31cclxuXHJcbiAgICBwdWJsaWMgYXdha2UoKTp2b2lke1xyXG4gICAgICAgIHRoaXMub25Bd2FrZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL+e7keWumkZhaXJ5R1VJ5YWD5Lu2XHJcbiAgICBwdWJsaWMgYmluZEFsbCh0YXJnZXQ6YW55KTp2b2lke1xyXG4gICAgICAgIGZvcihsZXQgayBpbiB0YXJnZXRbXCJiaW5kZXJzXCJdKXtcclxuICAgICAgICAgICAgbGV0IGZndWlOYW1lID0gdGhpc1tcImJpbmRlcnNcIl1ba107XHJcbiAgICAgICAgICAgIHRoaXNba10gPSB0aGlzLmZ1aS5HZXRDaGlsZChmZ3VpTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoKTp2b2lke1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOatpOengeacieaWueazleWcqFVJIE1hbmFnZXLkuK3osIPnlKgg77yM54m55q6K6LCD55So44CCXHJcbiAgICAgKiBAcGFyYW0gYXJnIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbE9wZW4oYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmxheWVyID0gVUlMYXllckRlZi5nZXREZWZhdWx0TGF5ZXIodGhpcy51aVR5cGUpO1xyXG4gICAgICAgIEZhaXJ5R1VJLkdSb290Lmluc3QuQWRkQ2hpbGQodGhpcy5mdWkpO1xyXG5cclxuICAgICAgICB0aGlzLm9uU2hvdyhhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbG9zZShhcmc6YW55ID0gbnVsbCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNsb3NlKGFyZyk7XHJcbiAgICAgICAgRmFpcnlHVUkuR1Jvb3QuaW5zdC5SZW1vdmVDaGlsZCh0aGlzLmZ1aSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLmZ1aS5EaXNwb3NlKCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYsIFVJQ29tRGVmcyB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyAgVUlXaW5kb3cgZXh0ZW5kcyBVSVBhbmVse1xyXG4gICBcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbV9idG5DbG9zZTpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fYnRuQ2xvc2UgPSB0aGlzLmZ1aS5HZXRDaGlsZChVSUNvbURlZnMuV2luZG93Q2xvc2VCdG4pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KGFyZzphbnkpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMuZnVpLnggPSBGYWlyeUdVSS5HUm9vdC5pbnN0LndpZHRoLzIgLSB0aGlzLmZ1aS53aWR0aC8yO1xyXG4gICAgICAgIHRoaXMuZnVpLnkgPSBGYWlyeUdVSS5HUm9vdC5pbnN0LmhlaWdodC8yIC0gdGhpcy5mdWkuaGVpZ2h0LzI7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9idG5DbG9zZSE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5tX2J0bkNsb3NlLm9uQ2xpY2suQWRkKHRoaXMub25CdG5DbG9zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fYnRuQ2xvc2UhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5DbG9zZS5vbkNsaWNrLlJlbW92ZSh0aGlzLm9uQnRuQ2xvc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQnRuQ2xvc2UoKXtcclxuICAgICAgICB0aGlzLmNsb3NlKDApO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IG5pY2VfdHMgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9nZW4vcGJcIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlclwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIExvZ2luQVBJe1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgYmVuY2htYXJrVGVzdCgpe1xyXG5cclxuICAgICAgICBcclxuICAgICAgICBmb3IobGV0IGk9MTsgaTwyO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyR1NfVGVzdC5jcmVhdGUoKTtcclxuICAgICAgICAgICAgbXNnLnRlc3RJRCA9IGk7XHJcbiAgICAgICAgICAgIG1zZy50ZXN0TmFtZSA9IFwiYmVuY2htYXJrIHRlc3RcIjtcclxuXHJcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgICAgICBPcGNvZGUuTVNHX0MyR1NfVGVzdCxcclxuICAgICAgICAgICAgICAgIG1zZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIGxldCB0ZXN0ICA9ICByZXNwb25zZSBhcyBuaWNlX3RzLkdTMkNfVGVzdDtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcImNvZGU6IFwiK3Rlc3QuRXJyb3IgK1wiLG1zZzpcIit0ZXN0Lk1lc3NhZ2UgK1wiLHJlczpcIit0ZXN0LnRlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvZ2luUmVhbG1TZXJ2ZXIoYWNjb3VudDpzdHJpbmcsIHBhc3N3b3JkOnN0cmluZyk6UHJvbWlzZTxuaWNlX3RzLlIyQ19Mb2dpbj57XHJcblxyXG4gICAgICAgICBsZXQgbXNnID0gbmljZV90cy5DMlJfTG9naW4uY3JlYXRlKCk7XHJcbiAgICAgICAgIG1zZy5BY2NvdW50ID0gYWNjb3VudDtcclxuICAgICAgICAgbXNnLlBhc3N3b3JkID0gcGFzc3dvcmQ7XHJcblxyXG4gICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBTLlNlc3Npb25NYW5hZ2VyLnNlbmRSZWFsbU1zZyhcclxuICAgICAgICAgICAgT3Bjb2RlLk1TR19DMlJfTG9naW4sXHJcbiAgICAgICAgICAgIG1zZ1xyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlIGFzIG5pY2VfdHMuUjJDX0xvZ2luO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2dpbkdhdGVTZXJ2ZXIoZ2F0ZUlkLCBnYXRlS2V5KTpQcm9taXNlPG5pY2VfdHMuRzJDX0xvZ2luR2F0ZT57XHJcblxyXG4gICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyR19Mb2dpbkdhdGUuY3JlYXRlKCk7XHJcbiAgICAgICAgbXNnLkdhdGVJZCA9IGdhdGVJZDtcclxuICAgICAgICBtc2cuS2V5ID0gZ2F0ZUtleTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBTLlNlc3Npb25NYW5hZ2VyLnNlbmRHYXRlTXNnKFxyXG4gICAgICAgICAgICBPcGNvZGUuTVNHX0MyR19Mb2dpbkdhdGUsXHJcbiAgICAgICAgICAgIG1zZ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiByZXNwb25zZSBhcyBuaWNlX3RzLkcyQ19Mb2dpbkdhdGU7XHJcbiAgICB9XHJcbn0iLCJcblxuXG5leHBvcnQgY2xhc3MgVUlNZXNzYWdle1xuXG5cbiAgICBwdWJsaWMgc3RhdGljIE1TR19TRUxFQ1RfU0VSVkVSOm51bWJlciAgPSAxMDAwO1xuICAgIHB1YmxpYyBzdGF0aWMgTVNHX1NDRU5FX1BST0dSRVNTOm51bWJlciA9IDEwMDE7XG4gICAgXG5cblxufSIsImltcG9ydCB7IE1lc3NlbmdlciB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvY29tbW9uL01lc3NlbmdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uLy4uL2ZyYW1ld29yay9jb21tb24vU2luZ2xldG9uXCI7XG5cblxuZXhwb3J0IGNsYXNzIFVJTWVzc2FnZU1hbmdlciBleHRlbmRzIFNpbmdsZXRvbjxVSU1lc3NhZ2VNYW5nZXI+e1xuXG4gICAgcHJpdmF0ZSB1aU1lc3NhZ2U6TWVzc2VuZ2VyID0gbmV3IE1lc3NlbmdlcigpO1xuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsb2JqOmFueSwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMudWlNZXNzYWdlLmFkZExpc3RlbmVyKG1zZ0NvZGUsIG9iaiwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihtc2dDb2RlOm51bWJlciwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLnVpTWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihtc2dDb2RlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlDb2RlKG1zZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXJCeVR5cGUobXNnQ29kZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFydXAoKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UuY2xlYXJ1cCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3QobXNnQ29kZTpudW1iZXIscGFyYW1zOmFueSl7XG5cblxuICAgICAgICB0aGlzLnVpTWVzc2FnZS5icm9hZGNhc3QobXNnQ29kZSwgcGFyYW1zKVxuICAgIH1cbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVdpbmRvd1wiO1xuXG5leHBvcnQgY2xhc3MgVUlHdWlkZVdpbiBleHRlbmRzIFVJV2luZG93e1xuXG4gICAgQGJpbmRlcihcImZvY3VzXCIpXG4gICAgcHJpdmF0ZSBtX2ZvY3VzOkZhaXJ5R1VJLkdHcmFwaDtcblxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xuXG4gICAgICAgIHRoaXMubV9mb2N1cy5hbHBoYSA9IDAuMlxuXG4gICAgICAgIHRoaXMubV9mb2N1cy5TZXRYWSg1MjAsNTUwKVxuXG4gICAgfVxuXG4gICAgcHVibGljIG9uU2hvdyh2bzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XG5cbiAgICAgIFxuICAgIH1cblxuXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuaW1wb3J0IHsgVm9Ib21lIH0gZnJvbSBcIi4uL3ZvL1ZvSG9tZVwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBIb21lU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ29tcGxldGUoKSB7XHJcblxyXG4gICAgICAgIGxldCB2bzpWb0hvbWUgPSBuZXcgVm9Ib21lKCk7XHJcbiAgICAgICAgdm8ubmFtZSA9IFwiSnVzdGluXCI7XHJcbiAgICAgICAgdm8uaHAgPSAxMjAwO1xyXG4gICAgICAgIHZvLm1wID0gMzMwMDtcclxuICAgICAgICB2by5tb25leSA9IDY2NjtcclxuXHJcbiAgICAgICAgUy5VSU1hbmFnZXIub3BlblBhZ2VJblNjZW5lKFxyXG4gICAgICAgICAgICBob21lVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGhvbWVVSS5VSUhvbWVQYWdlLFxyXG4gICAgICAgICAgICB2byk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJUGFnZVwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IFZvSG9tZSB9IGZyb20gXCIuLi92by9Wb0hvbWVcIjtcclxuaW1wb3J0IHsgTG9naW5BUEkgfSBmcm9tIFwiLi4vLi4vLi4vYXBpL0xvZ2luQVBJXCI7XHJcbmltcG9ydCB7IE9wY29kZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3BiL09wY29kZVwiO1xyXG5pbXBvcnQgeyBuaWNlX3RzIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvcGIvZ2VuL3BiXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUhvbWVQYWdlIGV4dGVuZHMgVUlQYWdle1xyXG5cclxuICAgIEBiaW5kZXIoXCJjaGF0QnRuXCIpXHJcbiAgICBwdWJsaWMgbV9jaGF0QnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwiYmFnQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9iYWdCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJzaG9wQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9zaG9wQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwibGV2ZWxCdG5cIilcclxuICAgIHB1YmxpYyBtX2xldmVsQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcIm5hbWVUeHRcIilcclxuICAgIHB1YmxpYyBtX25hbWVMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcImhwVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9ocExibDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwibXBUeHRcIilcclxuICAgIHB1YmxpYyBtX21wTGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJtb25leVR4dFwiKVxyXG4gICAgcHVibGljIG1fbW9uZXlMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xyXG5cclxuICAgICAgICB0aGlzLm1fY2hhdEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uY2hhdEJ0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubV9iYWdCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbmJhZ0J0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubV9zaG9wQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25zaG9wQnRuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5tX2xldmVsQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25sZXZlbEJ0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIFxyXG4gICAgcHVibGljIG9uU2hvdyh2bzpWb0hvbWUpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX25hbWVMYmwudGV4dCA9IHZvLm5hbWU7XHJcbiAgICAgICAgdGhpcy5tX21wTGJsLnRleHQgPSB2by5tcC50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMubV9ocExibC50ZXh0ID0gdm8uaHAudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLm1fbW9uZXlMYmwudGV4dCA9IHZvLm1vbmV5LnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICAgIFMuR2FtZVNlc3Npb24ubGlzdGVuKE9wY29kZS5NU0dfR1MyQ19UZXN0LGZ1bmN0aW9uKG1zZzpuaWNlX3RzLkdTMkNfVGVzdCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCLmlLbliLDmnI3liqHlmajkuIvlj5HnmoTmtojmga/jgILjgILjgILjgIJcIittc2cudGVzdFJlc3BvbnNlKVxyXG4gICAgICAgIH0pXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbmNoYXRCdG4oKXtcclxuXHJcbiAgICAgICAgUy5VSU1hbmFnZXIub3BlbldpbmRvdyhcclxuICAgICAgICAgICAgY29tbW9uVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGNvbW1vblVJLlVJVUlOb3RpY2VXaW4sXHJcbiAgICAgICAgICAgIG51bGwpO1xyXG4gICAgICAgIExvZ2dlci5sb2coXCJvbiBjaGF0Li4uXCIpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uYmFnQnRuKCl7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIm9uIGJhZyAuLlwiKTtcclxuXHJcbiAgICAgICAgLy9iZW5jaG1hcmsgdGVzdFxyXG4gICAgICAgIExvZ2luQVBJLmJlbmNobWFya1Rlc3QoKTtcclxuXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25zaG9wQnRuKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgUy5VSU1hbmFnZXIub3BlblBhZ2UoXHJcbiAgICAgICAgICAgIGhvbWVVSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgaG9tZVVJLlVJU2hvcFBhZ2UpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9ubGV2ZWxCdG4oKXtcclxuICAgICAgICBMb2dnZXIubG9nKFwib24gbGV2ZWwuLi5cIik7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVBhZ2VcIjtcblxuXG5cbmV4cG9ydCBjbGFzcyBVSVNob3BQYWdlIGV4dGVuZHMgVUlQYWdle1xuXG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgIH1cblxuICAgIFxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vblNob3codm8pO1xuXG4gICAgICAgIFxuICAgIH1cbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XG5cbiAgICB9XG5cbn0iLCJcblxuZXhwb3J0IGNsYXNzIFZvSG9tZXtcblxuICAgIHB1YmxpYyBuYW1lOnN0cmluZztcbiAgICBwdWJsaWMgaHA6bnVtYmVyO1xuICAgIHB1YmxpYyBtcDpudW1iZXI7XG4gICAgcHVibGljIG1vbmV5Om51bWJlcjtcblxufSIsIlxyXG5pbXBvcnQgeyBsb2dpblVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvbG9naW5cIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIExvZ2luU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5QYWdlSW5TY2VuZShcclxuICAgICAgICAgICAgbG9naW5VSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgbG9naW5VSS5VSUxvZ2luUGFnZSxcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgXHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVBhZ2VcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSwgVW5pdHlFbmdpbmUgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IExvZ2luQVBJIH0gZnJvbSBcIi4uLy4uLy4uL2FwaS9Mb2dpbkFQSVwiO1xyXG5pbXBvcnQgeyBsb2dpblVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvbG9naW5cIjtcclxuaW1wb3J0IHsgVm9TZXJ2ZXIsIFZvU2VydmVySXRlbSB9IGZyb20gXCIuLi92by9Wb1NlcnZlclwiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vZXZlbnQvVUlNZXNzYWdlXCI7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9TY2VuZURlZlwiO1xyXG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcclxuaW1wb3J0IHsgY29tbW9uVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9jb21tb25cIjtcclxuaW1wb3J0IHsgUyB9IGZyb20gXCIuLi8uLi8uLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXJcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJTG9naW5QYWdlIGV4dGVuZHMgVUlQYWdle1xyXG5cclxuICAgIEBiaW5kZXIoXCJhY2NvdW50XCIpXHJcbiAgICBwdWJsaWMgbV9hY2NvdW50OkZhaXJ5R1VJLkdUZXh0RmllbGQ7XHJcbiAgICBAYmluZGVyKFwicGFzc3dvcmRcIilcclxuICAgIHB1YmxpYyBtX3Bhc3N3b3JkOkZhaXJ5R1VJLkdUZXh0RmllbGQ7XHJcblxyXG4gICAgQGJpbmRlcihcInNlbHNlcnZlckJ0blwiKVxyXG4gICAgcHVibGljIG1fc2Vsc2VydmVyQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcImxvZ2luQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9sb2dpbkJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJzdG9yeUJ0blwiKVxyXG4gICAgcHVibGljIG1fc3RvcnlCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBAYmluZGVyKFwibmV3R3VpZGVCdG5cIilcclxuICAgIHB1YmxpYyBtX25ld0d1aWRlQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcImhvbGRcIilcclxuICAgIHB1YmxpYyBtX2hvbGRlcjpGYWlyeUdVSS5HR3JhcGg7XHJcblxyXG4gICAgcHJpdmF0ZSBnYXRlSWQ6YW55O1xyXG4gICAgcHJpdmF0ZSBnYXRlS2V5Om51bWJlcnxMb25nO1xyXG4gICAgcHJpdmF0ZSBfZWZmZWN0R286YW55ID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgb25Bd2FrZSgpe1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fbG9naW5CdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbkxvZ2luQ2xpY2soKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3N0b3J5QnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgICAgICBzdG9yeVVJLlBhY2thZ2VOYW1lLCBcclxuICAgICAgICAgICAgICAgIHN0b3J5VUkuVUlTdG9yeVdpbixcclxuICAgICAgICAgICAgICAgIG51bGwpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1fbmV3R3VpZGVCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgUy5VSU1hbmFnZXIub3BlbldpbmRvdyhcclxuICAgICAgICAgICAgICAgIGNvbW1vblVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICAgICAgY29tbW9uVUkuVUlVSUd1aWRlV2luLFxyXG4gICAgICAgICAgICAgICAgbnVsbFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm1fc2Vsc2VydmVyQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub3BlblNlbFNlcnZlcldpbigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBsZXQgY29ubmVjdGVkID0gYXdhaXQgUy5TZXNzaW9uTWFuYWdlci5jb25uZWN0UmVhbG1TZXJ2ZXIoKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyB0aGlzLm1fbG9naW5CdG4uZW5hYmxlZCA9IGNvbm5lY3RlZDtcclxuICAgICAgICAvLyBMb2dnZXIubG9nKFwiY29ubmVjdCByZWFtIHNlcnZlcjogXCIrY29ubmVjdGVkKVxyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgcHJpdmF0ZSBvblNlbGVjdFNlcnZlcihzZXJ2ZXJJdGVtOlZvU2VydmVySXRlbSl7XHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coXCIgc2VydmVyIHNlbGVjdGVkOiBcIitzZXJ2ZXJJdGVtLnNlcnZlck5hbWUpXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi50ZXh0ID0gc2VydmVySXRlbS5zZXJ2ZXJOYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgb25TaG93KHZvOmFueSl7XHJcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcclxuXHJcbiAgICAgICAgLy/liqDovb3nibnmlYhcclxuICAgICAgICB0aGlzLl9lZmZlY3RHbyA9IGF3YWl0IFMuUmVzTWFuYWdlci5sb2FkUHJlZmFiKFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9wZXRfcmFua195ZWxsb3dfdGVzdC5wcmVmYWJcIilcclxuICAgICAgICBsZXQgaW5zdCA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuSW5zdGFudGlhdGUodGhpcy5fZWZmZWN0R28pIGFzIFVuaXR5RW5naW5lLkdhbWVPYmplY3Q7XHJcbiAgICAgICAgbGV0IHdyYXBwZXIgPSBuZXcgRmFpcnlHVUkuR29XcmFwcGVyKGluc3QpO1xyXG4gICAgICAgIHRoaXMubV9ob2xkZXIuU2V0TmF0aXZlT2JqZWN0KHdyYXBwZXIpO1xyXG5cclxuXHJcbiAgICAgICAgIC8v55uR5ZCs6YCJ5pyN5raI5oGvXHJcbiAgICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NFTEVDVF9TRVJWRVIsXHJcbiAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RTZXJ2ZXJcclxuICAgICAgICApO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgICAgIC8v5Y246L296ZOB5pWIXHJcbiAgICAgICAgUy5SZXNNYW5hZ2VyLnJlbGVhc2VBZGRyZXNzR08odGhpcy5fZWZmZWN0R28pO1xyXG5cclxuICAgICAgICBTLlVJTWVzc2FnZU1hbmdlci5yZW1vdmVMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9wZW5TZWxTZXJ2ZXJXaW4oKXtcclxuXHJcbiAgICAgICAgLy8g5rWL6K+V5pWw5o2uXHJcbiAgICAgICAgbGV0IHZvU2VydmVyOlZvU2VydmVyID0gbmV3IFZvU2VydmVyKCk7XHJcbiAgICAgICAgZm9yKGxldCBpPTE7IGk8MTA7IGkrKyl7XHJcbiAgICAgICAgICAgIHZvU2VydmVyLmFyZWFNYXAuc2V0KGksXCLliIbljLpcIitpKTtcclxuICAgICAgICAgICAgdm9TZXJ2ZXIuc2VydmVyTWFwLnNldChpLCBuZXcgQXJyYXk8Vm9TZXJ2ZXJJdGVtPigpKTtcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaj0xOyBqPDIwOyBqKyspe1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCB2b1NlcnZlckl0ZW06Vm9TZXJ2ZXJJdGVtID0gbmV3IFZvU2VydmVySXRlbSgpO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLmFyZWFJZCA9IGk7XHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVySWQgPSBqO1xyXG5cclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5zZXJ2ZXJOYW1lID0gXCLmtYvor5XmnI3liqHlmahcIitpK1wiOlwiK2o7XHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVyU3RhdHVzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjMrMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KGkpLnB1c2godm9TZXJ2ZXJJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgUy5VSU1hbmFnZXIub3BlbldpbmRvdyhcclxuICAgICAgICAgICAgbG9naW5VSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgIGxvZ2luVUkuVUlTZWxTZXJ2ZXJXaW4sXHJcbiAgICAgICAgICAgIHZvU2VydmVyKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGFzeW5jIG9uTG9naW5DbGljaygpe1xyXG5cclxuICAgICAgICBsZXQgYWNjb3VudCA9IHRoaXMubV9hY2NvdW50LnRleHQ7XHJcbiAgICAgICAgbGV0IHBhc3N3b3JkID0gdGhpcy5tX3Bhc3N3b3JkLnRleHQ7XHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coYGFjY291bnQ6JHthY2NvdW50fSAtIHBhc3N3b3JkOiAke3Bhc3N3b3JkfWApO1xyXG5cclxuICAgICAgICBTLlNjZW5lTWFuYWdlci5sb2FkU2NlbmUoU2NlbmVEZWYuSG9tZVNjZW5lKTtcclxuXHJcblxyXG4gICAgICAgIC8vIGlmKGFjY291bnQgIT0gXCJcIiAmJiBwYXNzd29yZCAhPSBcIlwiKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gICAgIGxldCBtc2cgPSBhd2FpdCBMb2dpbkFQSS5sb2dpblJlYWxtU2VydmVyKGFjY291bnQsIHBhc3N3b3JkKVxyXG4gICAgICAgIC8vICAgICB0aGlzLmdhdGVJZCA9IG1zZy5HYXRlSWQ7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuZ2F0ZUtleSA9IG1zZy5LZXk7XHJcbiAgICAgICAgLy8gICAgIExvZ2dlci5sb2coXCJsb2dpbiByZWFtIHN1Y2MsIGdhdGUgYWRkcjpcIittc2cuQWRkcmVzcyArIFwiLGtleTpcIittc2cuS2V5KTtcclxuXHJcbiAgICAgICAgLy8gICAgIFMuU2Vzc2lvbk1hbmFnZXIuZGlzY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vICAgICAvL+eZu+W9lee9keWFs+acjVxyXG4gICAgICAgIC8vICAgICBsZXQgY29ubmVjdGVkID0gYXdhaXQgUy5TZXNzaW9uTWFuYWdlci5jb25uZWN0R2F0ZVNlcnZlcihtc2cuQWRkcmVzcyk7XHJcbiAgICAgICAgLy8gICAgIGlmKGNvbm5lY3RlZCl7XHJcbiAgICAgICAgLy8gICAgICAgICBMb2dnZXIubG9nKFwiY29ubmVjdCBnYXRlIHN1Y2NcIilcclxuXHJcbiAgICAgICAgLy8gICAgICAgICBsZXQgbXNnID0gYXdhaXQgTG9naW5BUEkubG9naW5HYXRlU2VydmVyKCB0aGlzLmdhdGVJZCwgdGhpcy5nYXRlS2V5KVxyXG5cclxuICAgICAgICAvLyAgICAgICAgIGxldCBwbGF5ZXJJRCA9IG1zZy5QbGF5ZXJJZDtcclxuICAgICAgICAvLyAgICAgICAgIExvZ2dlci5sb2coXCJsb2dpbiBnYXRlIHJlc3BvbnNlLi5cIiArcGxheWVySUQpO1xyXG5cclxuICAgICAgICAvLyAgICAgICAgIFMuU2NlbmVNYW5hZ2VyLmxvYWRTY2VuZShTY2VuZURlZi5Ib21lU2NlbmUpO1xyXG5cclxuICAgICAgICAvLyAgICAgfWVsc2V7XHJcbiAgICAgICAgLy8gICAgIExvZ2dlci5sb2coXCJjb25uZWN0IGdhdGUgZXJyIFwiKVxyXG4gICAgICAgIC8vICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyAgfVxyXG5cclxuICAgIH1cclxufSIsImltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVdpbmRvd1wiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi8uLi9ldmVudC9VSU1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgVm9TZXJ2ZXIsIFZvU2VydmVySXRlbSB9IGZyb20gXCIuLi92by9Wb1NlcnZlclwiO1xyXG5pbXBvcnQgeyBVSVNlcnZlckxpc3RJdGVtIH0gZnJvbSBcIi4vVUlTZXJ2ZXJMaXN0SXRlbVwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlTZWxTZXJ2ZXJXaW4gZXh0ZW5kcyBVSVdpbmRvd3tcclxuXHJcbiAgICBAYmluZGVyKFwiYXJlYUxpc3RcIilcclxuICAgIHByaXZhdGUgYXJlYUxpc3Q6RmFpcnlHVUkuR0xpc3Q7XHJcbiAgICBAYmluZGVyKFwic2VydmVyTGlzdFwiKVxyXG4gICAgcHJpdmF0ZSBzZXJ2ZXJMaXN0OkZhaXJ5R1VJLkdMaXN0O1xyXG4gICAgQGJpbmRlcihcImJhY2tCdG5cIilcclxuICAgIHByaXZhdGUgYmFja0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcIm9rQnRuXCIpXHJcbiAgICBwcml2YXRlIG9rQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwidGl0bGVcIilcclxuICAgIHByaXZhdGUgdGl0bGU6RmFpcnlHVUkuR0xhYmVsO1xyXG5cclxuICAgIHByaXZhdGUgIGNsaWNrQXJlYUluZGV4Om51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlICBjbGlja1NlcnZlckluZGV4Om51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHZvU2VydmVyOlZvU2VydmVyO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFja0J0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMub2tCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlcigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrQXJlYUluZGV4ID0gdGhpcy5hcmVhTGlzdC5HZXRDaGlsZEluZGV4KGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm51bUl0ZW1zID0gdGhpcy52b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KHRoaXMuY2xpY2tBcmVhSW5kZXgrMSkubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlckxpc3QuUmVmcmVzaFZpcnR1YWxMaXN0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5vbkNsaWNrSXRlbS5BZGQoKGV2ZW50OkZhaXJ5R1VJLkV2ZW50Q29udGV4dCk9PntcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTZXJ2ZXJJbmRleCA9IHRoaXMuc2VydmVyTGlzdC5HZXRDaGlsZEluZGV4KGV2ZW50LmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aXRsZS50ZXh0ID0gXCLlt7LpgInmi6nmnI3liqHlmajvvJpcIit0aGlzLmNsaWNrU2VydmVySW5kZXg7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGxldCBwb29sID0gW107XHJcbiAgICAgICAgRmFpcnlHVUkuVUlPYmplY3RGYWN0b3J5LlNldFBhY2thZ2VJdGVtRXh0ZW5zaW9uKFwidWk6Ly9sNjRkdW1rOWZlZWc1NFwiLFxyXG4gICAgICAgICgpPT57XHJcbiAgICAgICAgICAgIGxldCBpdGVtID0gIG5ldyBVSVNlcnZlckxpc3RJdGVtKCk7XHJcbiAgICAgICAgICAgIHBvb2wucHVzaChpdGVtKVxyXG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIG9uU2VsZWN0U2VydmVyKCl7XHJcblxyXG4gICAgICAgIGxldCBzZWxJdGVtOlZvU2VydmVySXRlbSA9IHRoaXMudm9TZXJ2ZXIuc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpW3RoaXMuY2xpY2tTZXJ2ZXJJbmRleF07XHJcblxyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmJyb2FkY2FzdChcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICBzZWxJdGVtXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KHZvOlZvU2VydmVyKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcbiAgICAgICAgdGhpcy52b1NlcnZlciA9IHZvO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFMaXN0LlNldFZpcnR1YWwoKTtcclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckFyZWFMaXN0SXRlbShpbmRleCwgb2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXJlYUxpc3QubnVtSXRlbXMgPSB2by5hcmVhTWFwLnNpemU7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5TZXRWaXJ0dWFsKCk7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpVSVNlcnZlckxpc3RJdGVtKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4LCBvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm51bUl0ZW1zID0gdm8uc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlckFyZWFMaXN0SXRlbShpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KXtcclxuXHJcbiAgICAgICAgbGV0IGFyZWFCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcclxuICAgICAgICBhcmVhQnRuLnRleHQgPSB0aGlzLnZvU2VydmVyLmFyZWFNYXAuZ2V0KGluZGV4KzEpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4Om51bWJlciwgaXRlbTpVSVNlcnZlckxpc3RJdGVtKXtcclxuXHJcbiAgICAgICAgaWYoaXRlbSBpbnN0YW5jZW9mIFVJU2VydmVyTGlzdEl0ZW0pe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIjExMTExMTExMTExMTExMTExMTExMTFcIilcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIzMzMzMzMzMzMzMzMzMzMzMzNcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlbS5pdGVtTGFiZWwgPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKVtpbmRleF0uc2VydmVyTmFtZTtcclxuICAgICAgICAvL3NlcnZlckJ0bi5pY29uID0gRmFpcnlHVUkuVUlQYWNrYWdlLlxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XG5cblxuXG5leHBvcnQgIGNsYXNzIFVJU2VydmVyTGlzdEl0ZW0gZXh0ZW5kcyBGYWlyeUdVSS5HQnV0dG9ue1xuXG4gICAgcHVibGljIHNldCBpdGVtTGFiZWwodHh0OnN0cmluZyl7XG4gICAgICAgIHRoaXMudGV4dCA9IHR4dDtcbiAgICB9XG5cbn0gIiwiXG5cblxuZXhwb3J0IGNsYXNzIFZvU2VydmVySXRlbXtcblxuICAgIHB1YmxpYyBhcmVhSWQ6bnVtYmVyO1xuICAgIHB1YmxpYyBzZXJ2ZXJJZDpudW1iZXI7XG4gICAgcHVibGljIHNlcnZlck5hbWU6c3RyaW5nO1xuICAgIHB1YmxpYyBzZXJ2ZXJTdGF0dXM6bnVtYmVyO1xufVxuXG5leHBvcnQgIGNsYXNzIFZvU2VydmVye1xuXG4gICAgcHVibGljIHNlcnZlck1hcDogTWFwPG51bWJlciwgQXJyYXk8Vm9TZXJ2ZXJJdGVtPj4gPSBuZXcgTWFwPG51bWJlciwgQXJyYXk8Vm9TZXJ2ZXJJdGVtPj4oKTtcbiAgICBwdWJsaWMgYXJlYU1hcDpNYXA8bnVtYmVyLHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xufSIsImltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFB2ZVNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7IENob2ljZSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvQ2hvaWNlXCI7XG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2luay9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVdpbmRvd1wiO1xuaW1wb3J0IHsgU30gZnJvbSBcIi4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5cbmV4cG9ydCBjbGFzcyBVSVN0b3J5V2luIGV4dGVuZHMgVUlXaW5kb3d7XG5cbiAgICBAYmluZGVyKFwic3BlYWtlclR4dFwiKVxuICAgIHByaXZhdGUgbV9zcGVha2VyVHh0OkZhaXJ5R1VJLkdSaWNoVGV4dEZpZWxkO1xuICAgIEBiaW5kZXIoXCJidG5MaXN0XCIpXG4gICAgcHJpdmF0ZSBtX2J0bkxpc3Q6RmFpcnlHVUkuR0xpc3Q7XG5cbiAgICBwcml2YXRlIHNob3VsZENvbnRpbmVTdG9yeTpib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBvcHRpb25zTWFwOk1hcDxudW1iZXIsc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLHN0cmluZz4oKTtcbiAgICBwcml2YXRlIGFsbENob2ljZXM6Q2hvaWNlW107XG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgICAgICB0aGlzLm1fYnRuTGlzdC5pdGVtUmVuZGVyZXIgPSAoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCk9PntcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQnRuTGlzdChpbmRleCwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubV9idG5MaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xuICAgICAgICAgICAgIGxldCBjbGlja0lkOm51bWJlciA9IHRoaXMubV9idG5MaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLnNob3VsZENvbnRpbmVTdG9yeSl7XG4gICAgICAgICAgICAgICAgUy5TdG9yeU1hbmFnZXIuYWR2YW5jZVN0b3J5KCk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBTLlN0b3J5TWFuYWdlci5zZWxlY3RDaG9pY2UodGhpcy5hbGxDaG9pY2VzW2NsaWNrSWRdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25TaG93KHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcblxuICAgICAgICBTLlN0b3J5TWVzc2FnZU1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMuT25Db250ZW50UmVhZHlcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PbkNob2ljZXNQcmVzZW50ZWRcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PblN0b3J5RmluaXNoZWRcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub3B0aW9uc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IGZhbHNlO1xuXG4gICAgICAgIFMuU3RvcnlNYW5hZ2VyLmJlZ2luU3RvcnkoXCJzdG9yeTJcIik7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIE9uQ29udGVudFJlYWR5KFxuICAgICAgICBzcGVha2VyQ29udGVudDpzdHJpbmcsXG4gICAgICAgIHNwZWFrZXJJZDpzdHJpbmcsXG4gICAgICAgIGN1cnJlbnRUYWdzOnN0cmluZ1tdLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSlcbiAgICB7XG4gICAgICAgIHRoaXMubV9zcGVha2VyVHh0LnRleHQgPSBzcGVha2VyQ29udGVudDtcblxuICAgICAgICBpZihTLlN0b3J5TWFuYWdlci5jYW5Db250aW51ZSl7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnRDaG9pY2VzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hvaWNlcyA9IGN1cnJlbnRDaG9pY2VzO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IGxlbiA9IGN1cnJlbnRDaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hcC5zZXQoaSwgY3VycmVudENob2ljZXNbaV0udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJCdG5MaXN0KGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3Qpe1xuICAgICAgICBsZXQgY29udGludWVCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9uc01hcC5zaXplPjApe1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IHRoaXMub3B0aW9uc01hcC5nZXQoaW5kZXgpO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IFwi54K55Ye757un57utXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIE9uQ2hvaWNlc1ByZXNlbnRlZChjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSl7XG4gICAgICBcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcbiAgICAgICAgTG9nZ2VyLmxvZyhcIi4uLi5PbkNob2ljZXNQcmVzZW50ZWQuLi4uLi5cIilcbiAgICB9XG5cbiAgICBwcml2YXRlIE9uU3RvcnlGaW5pc2hlZCgpOnZvaWR7XG5cbiAgICAgICAgTG9nZ2VyLmxvZyhcIlN0b3J5IEZpbmlzaGVkXCIpXG5cbiAgICAgICAgUy5VSU1hbmFnZXIuY2xvc2VXaW5kb3coc3RvcnlVSS5VSVN0b3J5V2luLG51bGwpO1xuICAgIH1cblxuXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgICAgIFMuU3RvcnlNZXNzYWdlTWFuYWdlci5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DT05URU5UUkVBRFksXG4gICAgICAgICAgICB0aGlzLk9uQ29udGVudFJlYWR5XG4gICAgICAgICk7XG4gICAgICAgIFMuU3RvcnlNZXNzYWdlTWFuYWdlci5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DSE9JQ0VTUFJFU0VOVEVELFxuICAgICAgICAgICAgdGhpcy5PbkNob2ljZXNQcmVzZW50ZWRcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLk9uU3RvcnlGaW5pc2hlZFxuICAgICAgICApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBHYW1lT2JqZWN0UG9vbCB9IGZyb20gXCIuLi9mcmFtZXdvcmsvY29tbW9uL0dhbWVPYmplY3RQb29sXCI7XHJcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFN0b3J5TWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvaW5rL1N0b3J5TWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTdG9yeU1lc3NhZ2VNYW5hZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9pbmsvU3RvcnlNZXNzYWdlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuLi9mcmFtZXdvcmsvbmV0L0dhbWVTZXNzaW9uXCI7XHJcbmltcG9ydCB7IEh0dHBNYW5hZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9uZXQvSHR0cE1hbmFnZXJcIjtcclxuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL25ldC9TZXNzaW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTY2VuZU1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL3VpL1VJTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2VNYW5nZXIgfSBmcm9tIFwiLi4vZ2FtZS9ldmVudC9VSU1lc3NhZ2VNYW5hZ2VyXCI7XHJcblxyXG5leHBvcnQgIGNsYXNzIEdhbWVDb25maWd7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWJ1Zzpib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVySVA6c3RyaW5nID0gXCIxMjcuMC4wLjFcIjsgXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVyUG9ydDpudW1iZXIgPSA5MDAxO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJTWFuYWdlciA9IFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBVSU1lc3NhZ2VNYW5nZXIgPSBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU2NlbmVNYW5hZ2VyID0gU2NlbmVNYW5hZ2VyLkluc3RhbmNlKFNjZW5lTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIEdhbWVPYmplY3RQb29sID0gR2FtZU9iamVjdFBvb2wuSW5zdGFuY2UoR2FtZU9iamVjdFBvb2wpO1xyXG4gICAgcHVibGljIHN0YXRpYyBSZXNNYW5hZ2VyID0gUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU3RvcnlNYW5hZ2VyID0gU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIFNlc3Npb25NYW5hZ2VyID0gU2Vzc2lvbk1hbmFnZXIuSW5zdGFuY2UoU2Vzc2lvbk1hbmFnZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBHYW1lU2Vzc2lvbiA9IEdhbWVTZXNzaW9uLkluc3RhbmNlKEdhbWVTZXNzaW9uKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU3RvcnlNZXNzYWdlTWFuYWdlciA9IFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIEh0dHBNYW5hZ2VyID0gSHR0cE1hbmFnZXIuSW5zdGFuY2UoSHR0cE1hbmFnZXIpO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNzaGFycFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwdWVydHNcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==