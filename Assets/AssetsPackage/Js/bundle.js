/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/GameMain.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/inkjs/dist/ink-es2015.js":
/*!***********************************************!*\
  !*** ./node_modules/inkjs/dist/ink-es2015.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{constructor(){if(this._components=[],this._componentsString=null,this._isRelative=!1,"string"==typeof arguments[0]){let t=arguments[0];this.componentsString=t}else if(arguments[0]instanceof e.Component&&arguments[1]instanceof e){let t=arguments[0],e=arguments[1];this._components.push(t),this._components=this._components.concat(e._components)}else if(arguments[0]instanceof Array){let t=arguments[0],e=!!arguments[1];this._components=this._components.concat(t),this._isRelative=e}}get isRelative(){return this._isRelative}get componentCount(){return this._components.length}get head(){return this._components.length>0?this._components[0]:null}get tail(){if(this._components.length>=2){let t=this._components.slice(1,this._components.length);return new e(t)}return e.self}get length(){return this._components.length}get lastComponent(){let t=this._components.length-1;return t>=0?this._components[t]:null}get containsNamedComponent(){for(let t=0,e=this._components.length;t<e;t++)if(!this._components[t].isIndex)return!0;return!1}static get self(){let t=new e;return t._isRelative=!0,t}GetComponent(t){return this._components[t]}PathByAppendingPath(t){let n=new e,i=0;for(let e=0;e<t._components.length&&t._components[e].isParent;++e)i++;for(let t=0;t<this._components.length-i;++t)n._components.push(this._components[t]);for(let e=i;e<t._components.length;++e)n._components.push(t._components[e]);return n}get componentsString(){return null==this._componentsString&&(this._componentsString=this._components.join("."),this.isRelative&&(this._componentsString="."+this._componentsString)),this._componentsString}set componentsString(t){if(this._components.length=0,this._componentsString=t,null==this._componentsString||""==this._componentsString)return;"."==this._componentsString[0]&&(this._isRelative=!0,this._componentsString=this._componentsString.substring(1));let n=this._componentsString.split(".");for(let t of n)/^(\-|\+)?([0-9]+|Infinity)$/.test(t)?this._components.push(new e.Component(parseInt(t))):this._components.push(new e.Component(t))}toString(){return this.componentsString}Equals(t){if(null==t)return!1;if(t._components.length!=this._components.length)return!1;if(t.isRelative!=this.isRelative)return!1;for(let e=0,n=t._components.length;e<n;e++)if(!t._components[e].Equals(this._components[e]))return!1;return!0}PathByAppendingComponent(t){let n=new e;return n._components.push.apply(n._components,this._components),n._components.push(t),n}}var n,i,r;function a(t,e){return t instanceof e?h(t):null}function s(t,e){if(t instanceof e)return h(t);throw new Error(`${t} is not of type ${e}`)}function l(t){return t.hasValidName&&t.name?t:null}function o(t){return void 0===t?null:t}function u(t){return"object"==typeof t&&"function"==typeof t.Equals}function h(t,e){return t}e.parentId="^",function(t){class e{constructor(t){this.index=-1,this.name=null,"string"==typeof t?this.name=t:this.index=t}get isIndex(){return this.index>=0}get isParent(){return this.name==t.parentId}static ToParent(){return new e(t.parentId)}toString(){return this.isIndex?this.index.toString():this.name}Equals(t){return null!=t&&t.isIndex==this.isIndex&&(this.isIndex?this.index==t.index:this.name==t.name)}}t.Component=e}(e||(e={})),function(t){function e(t,e){if(!t)throw void 0!==e&&console.warn(e),console.trace&&console.trace(),new Error("")}t.AssertType=function(t,n,i){e(t instanceof n,i)},t.Assert=e}(n||(n={}));class c extends Error{}function d(t){throw new c(t+" is null or undefined")}class p{constructor(){this.parent=null,this._debugMetadata=null,this._path=null}get debugMetadata(){return null===this._debugMetadata&&this.parent?this.parent.debugMetadata:this._debugMetadata}set debugMetadata(t){this._debugMetadata=t}get ownDebugMetadata(){return this._debugMetadata}DebugLineNumberOfPath(t){if(null===t)return null;let e=this.rootContentContainer;if(e){let n=e.ContentAtPath(t).obj;if(n){let t=n.debugMetadata;if(null!==t)return t.startLineNumber}}return null}get path(){if(null==this._path)if(null==this.parent)this._path=new e;else{let t=[],n=this,i=a(n.parent,N);for(;null!==i;){let r=l(n);null!=r&&r.hasValidName?t.unshift(new e.Component(r.name)):t.unshift(new e.Component(i.content.indexOf(n))),n=i,i=a(i.parent,N)}this._path=new e(t)}return this._path}ResolvePath(t){if(null===t)return d("path");if(t.isRelative){let e=a(this,N);return null===e&&(n.Assert(null!==this.parent,"Can't resolve relative path because we don't have a parent"),e=a(this.parent,N),n.Assert(null!==e,"Expected parent to be a container"),n.Assert(t.GetComponent(0).isParent),t=t.tail),null===e?d("nearestContainer"):e.ContentAtPath(t)}{let e=this.rootContentContainer;return null===e?d("contentContainer"):e.ContentAtPath(t)}}ConvertPathToRelative(t){let n=this.path,i=Math.min(t.length,n.length),r=-1;for(let e=0;e<i;++e){let i=n.GetComponent(e),a=t.GetComponent(e);if(!i.Equals(a))break;r=e}if(-1==r)return t;let a=n.componentCount-1-r,s=[];for(let t=0;t<a;++t)s.push(e.Component.ToParent());for(let e=r+1;e<t.componentCount;++e)s.push(t.GetComponent(e));return new e(s,!0)}CompactPathString(t){let e=null,n=null;if(t.isRelative)n=t.componentsString,e=this.path.PathByAppendingPath(t).componentsString;else{n=this.ConvertPathToRelative(t).componentsString,e=t.componentsString}return n.length<e.length?n:e}get rootContentContainer(){let t=this;for(;t.parent;)t=t.parent;return a(t,N)}Copy(){throw Error("Not Implemented: Doesn't support copying")}SetChild(t,e,n){t[e]&&(t[e]=null),t[e]=n,t[e]&&(t[e].parent=this)}}class m{constructor(t){t=void 0!==t?t.toString():"",this.string=t}get Length(){return this.string.length}Append(t){null!==t&&(this.string+=t)}AppendLine(t){void 0!==t&&this.Append(t),this.string+="\n"}AppendFormat(t,...e){this.string+=t.replace(/{(\d+)}/g,(t,n)=>void 0!==e[n]?e[n]:t)}toString(){return this.string}}class f{constructor(){if(this.originName=null,this.itemName=null,void 0!==arguments[1]){let t=arguments[0],e=arguments[1];this.originName=t,this.itemName=e}else if(arguments[0]){let t=arguments[0].toString().split(".");this.originName=t[0],this.itemName=t[1]}}static get Null(){return new f(null,null)}get isNull(){return null==this.originName&&null==this.itemName}get fullName(){return(null!==this.originName?this.originName:"?")+"."+this.itemName}toString(){return this.fullName}Equals(t){if(t instanceof f){let e=t;return e.itemName==this.itemName&&e.originName==this.originName}return!1}copy(){return new f(this.originName,this.itemName)}serialized(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}static fromSerializedKey(t){let e=JSON.parse(t);if(!f.isLikeInkListItem(e))return f.Null;let n=e;return new f(n.originName,n.itemName)}static isLikeInkListItem(t){return"object"==typeof t&&(!(!t.hasOwnProperty("originName")||!t.hasOwnProperty("itemName"))&&(("string"==typeof t.originName||null===typeof t.originName)&&("string"==typeof t.itemName||null===typeof t.itemName)))}}class g extends Map{constructor(){if(super(arguments[0]instanceof g?arguments[0]:[]),this.origins=null,this._originNames=[],arguments[0]instanceof g){let t=arguments[0];t._originNames&&(this._originNames=t._originNames.slice())}else if("string"==typeof arguments[0]){let t=arguments[0],e=arguments[1];this.SetInitialOriginName(t);let n=e.listDefinitions.TryListGetDefinition(t,null);if(!n.exists)throw new Error("InkList origin could not be found in story when constructing new list: "+t);this.origins=[n.result]}else if("object"==typeof arguments[0]&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")){let t=arguments[0];this.Add(t.Key,t.Value)}}AddItem(t){if(t instanceof f){let e=t;if(null==e.originName)return void this.AddItem(e.itemName);if(null===this.origins)return d("this.origins");for(let t of this.origins)if(t.name==e.originName){let n=t.TryGetValueForItem(e,0);if(n.exists)return void this.Add(e,n.result);throw new Error("Could not add the item "+e+" to this list because it doesn't exist in the original list definition in ink.")}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}{let e=t,n=null;if(null===this.origins)return d("this.origins");for(let t of this.origins){if(null===e)return d("itemName");if(t.ContainsItemWithName(e)){if(null!=n)throw new Error("Could not add the item "+e+" to this list because it could come from either "+t.name+" or "+n.name);n=t}}if(null==n)throw new Error("Could not add the item "+e+" to this list because it isn't known to any list definitions previously associated with this list.");let i=new f(n.name,e),r=n.ValueForItem(i);this.Add(i,r)}}ContainsItemNamed(t){for(let[e]of this){if(f.fromSerializedKey(e).itemName==t)return!0}return!1}ContainsKey(t){return this.has(t.serialized())}Add(t,e){let n=t.serialized();if(this.has(n))throw new Error("The Map already contains an entry for "+t);this.set(n,e)}Remove(t){return this.delete(t.serialized())}get Count(){return this.size}get originOfMaxItem(){if(null==this.origins)return null;let t=this.maxItem.Key.originName,e=null;return this.origins.every(n=>n.name!=t||(e=n,!1)),e}get originNames(){if(this.Count>0){null==this._originNames&&this.Count>0?this._originNames=[]:(this._originNames||(this._originNames=[]),this._originNames.length=0);for(let[t]of this){let e=f.fromSerializedKey(t);if(null===e.originName)return d("item.originName");this._originNames.push(e.originName)}}return this._originNames}SetInitialOriginName(t){this._originNames=[t]}SetInitialOriginNames(t){this._originNames=null==t?null:t.slice()}get maxItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n>t.Value)&&(t={Key:i,Value:n})}return t}get minItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n<t.Value)&&(t={Key:i,Value:n})}return t}get inverse(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);this.ContainsKey(e)||t.Add(e,i)}return t}get all(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);t.set(e.serialized(),i)}return t}Union(t){let e=new g(this);for(let[n,i]of t)e.set(n,i);return e}Intersect(t){let e=new g;for(let[n,i]of this)t.has(n)&&e.set(n,i);return e}Without(t){let e=new g(this);for(let[n]of t)e.delete(n);return e}Contains(t){for(let[e]of t)if(!this.has(e))return!1;return!0}GreaterThan(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>t.maxItem.Value)}GreaterThanOrEquals(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>=t.minItem.Value&&this.maxItem.Value>=t.maxItem.Value)}LessThan(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<t.minItem.Value)}LessThanOrEquals(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<=t.maxItem.Value&&this.minItem.Value<=t.minItem.Value)}MaxAsList(){return this.Count>0?new g(this.maxItem):new g}MinAsList(){return this.Count>0?new g(this.minItem):new g}ListWithSubRange(t,e){if(0==this.Count)return new g;let n=this.orderedItems,i=0,r=Number.MAX_SAFE_INTEGER;Number.isInteger(t)?i=t:t instanceof g&&t.Count>0&&(i=t.minItem.Value),Number.isInteger(e)?r=e:t instanceof g&&t.Count>0&&(r=e.maxItem.Value);let a=new g;a.SetInitialOriginNames(this.originNames);for(let t of n)t.Value>=i&&t.Value<=r&&a.Add(t.Key,t.Value);return a}Equals(t){if(t instanceof g==!1)return!1;if(t.Count!=this.Count)return!1;for(let[e]of this)if(!t.has(e))return!1;return!0}get orderedItems(){let t=new Array;for(let[e,n]of this){let i=f.fromSerializedKey(e);t.push({Key:i,Value:n})}return t.sort((t,e)=>null===t.Key.originName?d("x.Key.originName"):null===e.Key.originName?d("y.Key.originName"):t.Value==e.Value?t.Key.originName.localeCompare(e.Key.originName):t.Value<e.Value?-1:t.Value>e.Value?1:0),t}toString(){let t=this.orderedItems,e=new m;for(let n=0;n<t.length;n++){n>0&&e.Append(", ");let i=t[n].Key;if(null===i.itemName)return d("item.itemName");e.Append(i.itemName)}return e.toString()}valueOf(){return NaN}}class S extends Error{constructor(t){super(t),this.useEndLineNumber=!1,this.message=t,this.name="StoryException"}}function y(t,e,n){if(null===t)return{result:n,exists:!1};let i=t.get(e);return void 0===i?{result:n,exists:!1}:{result:i,exists:!0}}class C extends p{static Create(t,n){if(n){if(n===i.Int&&Number.isInteger(Number(t)))return new b(Number(t));if(n===i.Float&&!isNaN(t))return new _(Number(t))}if("boolean"==typeof t){t=!!t?1:0}return"string"==typeof t?new T(String(t)):Number.isInteger(Number(t))?new b(Number(t)):isNaN(t)?t instanceof e?new P(s(t,e)):t instanceof g?new O(s(t,g)):null:new _(Number(t))}Copy(){return s(C.Create(this),p)}BadCastException(t){return new S("Can't cast "+this.valueObject+" from "+this.valueType+" to "+t)}}class v extends C{constructor(t){super(),this.value=t}get valueObject(){return this.value}toString(){return null===this.value?d("Value.value"):this.value.toString()}}class b extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Int}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Float)return new _(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class _ extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Float}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Int)return new b(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class T extends v{constructor(t){if(super(t||""),this._isNewline="\n"==this.value,this._isInlineWhitespace=!0,null===this.value)return d("Value.value");this.value.length>0&&this.value.split("").every(t=>" "==t||"\t"==t||(this._isInlineWhitespace=!1,!1))}get valueType(){return i.String}get isTruthy(){return null===this.value?d("Value.value"):this.value.length>0}get isNewline(){return this._isNewline}get isInlineWhitespace(){return this._isInlineWhitespace}get isNonWhitespace(){return!this.isNewline&&!this.isInlineWhitespace}Cast(t){if(t==this.valueType)return this;if(t==i.Int){let e=function(t,e=0){let n=parseInt(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new b(e.result);throw this.BadCastException(t)}if(t==i.Float){let e=function(t,e=0){let n=parseFloat(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new _(e.result);throw this.BadCastException(t)}throw this.BadCastException(t)}}class P extends v{constructor(t){super(t)}get valueType(){return i.DivertTarget}get targetPath(){return null===this.value?d("Value.value"):this.value}set targetPath(t){this.value=t}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a divert target")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"DivertTargetValue("+this.targetPath+")"}}class w extends v{constructor(t,e=-1){super(t),this._contextIndex=e}get contextIndex(){return this._contextIndex}set contextIndex(t){this._contextIndex=t}get variableName(){return null===this.value?d("Value.value"):this.value}set variableName(t){this.value=t}get valueType(){return i.VariablePointer}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"VariablePointerValue("+this.variableName+")"}Copy(){return new w(this.variableName,this.contextIndex)}}class O extends v{get isTruthy(){return null===this.value?d("this.value"):this.value.Count>0}get valueType(){return i.List}Cast(t){if(null===this.value)return d("Value.value");if(t==i.Int){let t=this.value.maxItem;return t.Key.isNull?new b(0):new b(t.Value)}if(t==i.Float){let t=this.value.maxItem;return t.Key.isNull?new _(0):new _(t.Value)}if(t==i.String){let t=this.value.maxItem;return t.Key.isNull?new T(""):new T(t.Key.toString())}if(t==this.valueType)return this;throw this.BadCastException(t)}constructor(t,e){super(null),t||e?t instanceof g?this.value=new g(t):t instanceof f&&"number"==typeof e&&(this.value=new g({Key:t,Value:e})):this.value=new g}static RetainListOriginsForAssignment(t,e){let n=a(t,O),i=a(e,O);return i&&null===i.value?d("newList.value"):n&&null===n.value?d("oldList.value"):void(n&&i&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames))}}!function(t){t[t.Int=0]="Int",t[t.Float=1]="Float",t[t.List=2]="List",t[t.String=3]="String",t[t.DivertTarget=4]="DivertTarget",t[t.VariablePointer=5]="VariablePointer"}(i||(i={}));class E{constructor(){this.obj=null,this.approximate=!1}get correctObj(){return this.approximate?null:this.obj}get container(){return this.obj instanceof N?this.obj:null}copy(){let t=new E;return t.obj=this.obj,t.approximate=this.approximate,t}}class N extends p{constructor(){super(...arguments),this.name="",this._content=[],this.namedContent=new Map,this.visitsShouldBeCounted=!1,this.turnIndexShouldBeCounted=!1,this.countingAtStartOnly=!1,this._pathToFirstLeafContent=null}get hasValidName(){return null!=this.name&&this.name.length>0}get content(){return this._content}set content(t){this.AddContent(t)}get namedOnlyContent(){let t=new Map;for(let[e,n]of this.namedContent){let i=s(n,p);t.set(e,i)}for(let e of this.content){let n=l(e);null!=n&&n.hasValidName&&t.delete(n.name)}return 0==t.size&&(t=null),t}set namedOnlyContent(t){let e=this.namedOnlyContent;if(null!=e)for(let[t]of e)this.namedContent.delete(t);if(null!=t)for(let[,e]of t){let t=l(e);null!=t&&this.AddToNamedContentOnly(t)}}get countFlags(){let t=0;return this.visitsShouldBeCounted&&(t|=N.CountFlags.Visits),this.turnIndexShouldBeCounted&&(t|=N.CountFlags.Turns),this.countingAtStartOnly&&(t|=N.CountFlags.CountStartOnly),t==N.CountFlags.CountStartOnly&&(t=0),t}set countFlags(t){let e=t;(e&N.CountFlags.Visits)>0&&(this.visitsShouldBeCounted=!0),(e&N.CountFlags.Turns)>0&&(this.turnIndexShouldBeCounted=!0),(e&N.CountFlags.CountStartOnly)>0&&(this.countingAtStartOnly=!0)}get pathToFirstLeafContent(){return null==this._pathToFirstLeafContent&&(this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent)),this._pathToFirstLeafContent}get internalPathToFirstLeafContent(){let t=[],n=this;for(;n instanceof N;)n.content.length>0&&(t.push(new e.Component(0)),n=n.content[0]);return new e(t)}AddContent(t){if(t instanceof Array){let e=t;for(let t of e)this.AddContent(t)}else{let e=t;if(this._content.push(e),e.parent)throw new Error("content is already in "+e.parent);e.parent=this,this.TryAddNamedContent(e)}}TryAddNamedContent(t){let e=l(t);null!=e&&e.hasValidName&&this.AddToNamedContentOnly(e)}AddToNamedContentOnly(t){n.AssertType(t,p,"Can only add Runtime.Objects to a Runtime.Container"),s(t,p).parent=this,this.namedContent.set(t.name,t)}ContentAtPath(t,e=0,n=-1){-1==n&&(n=t.length);let i=new E;i.approximate=!1;let r=this,s=this;for(let l=e;l<n;++l){let e=t.GetComponent(l);if(null==r){i.approximate=!0;break}let n=r.ContentWithPathComponent(e);if(null==n){i.approximate=!0;break}s=n,r=a(n,N)}return i.obj=s,i}InsertContent(t,e){if(this.content[e]=t,t.parent)throw new Error("content is already in "+t.parent);t.parent=this,this.TryAddNamedContent(t)}AddContentsOfContainer(t){this.content=this.content.concat(t.content);for(let e of t.content)e.parent=this,this.TryAddNamedContent(e)}ContentWithPathComponent(t){if(t.isIndex)return t.index>=0&&t.index<this.content.length?this.content[t.index]:null;if(t.isParent)return this.parent;{if(null===t.name)return d("component.name");let e=y(this.namedContent,t.name,null);return e.exists?s(e.result,p):null}}BuildStringOfHierarchy(){let t;if(0==arguments.length)return t=new m,this.BuildStringOfHierarchy(t,0,null),t.toString();t=arguments[0];let e=arguments[1],i=arguments[2];function r(){for(let n=0;n<4*e;++n)t.Append(" ")}r(),t.Append("["),this.hasValidName&&t.AppendFormat(" ({0})",this.name),this==i&&t.Append("  <---"),t.AppendLine(),e++;for(let n=0;n<this.content.length;++n){let a=this.content[n];if(a instanceof N){a.BuildStringOfHierarchy(t,e,i)}else r(),a instanceof T?(t.Append('"'),t.Append(a.toString().replace("\n","\\n")),t.Append('"')):t.Append(a.toString());n!=this.content.length-1&&t.Append(","),a instanceof N||a!=i||t.Append("  <---"),t.AppendLine()}let a=new Map;for(let[t,e]of this.namedContent)this.content.indexOf(s(e,p))>=0||a.set(t,e);if(a.size>0){r(),t.AppendLine("-- named: --");for(let[,r]of a){n.AssertType(r,N,"Can only print out named Containers"),r.BuildStringOfHierarchy(t,e,i),t.AppendLine()}}e--,r(),t.Append("]")}}!function(t){let e;!function(t){t[t.Visits=1]="Visits",t[t.Turns=2]="Turns",t[t.CountStartOnly=4]="CountStartOnly"}(e=t.CountFlags||(t.CountFlags={}))}(N||(N={}));class x extends p{toString(){return"Glue"}}class A extends p{constructor(t=A.CommandType.NotSet){super(),this._commandType=t}get commandType(){return this._commandType}Copy(){return new A(this.commandType)}static EvalStart(){return new A(A.CommandType.EvalStart)}static EvalOutput(){return new A(A.CommandType.EvalOutput)}static EvalEnd(){return new A(A.CommandType.EvalEnd)}static Duplicate(){return new A(A.CommandType.Duplicate)}static PopEvaluatedValue(){return new A(A.CommandType.PopEvaluatedValue)}static PopFunction(){return new A(A.CommandType.PopFunction)}static PopTunnel(){return new A(A.CommandType.PopTunnel)}static BeginString(){return new A(A.CommandType.BeginString)}static EndString(){return new A(A.CommandType.EndString)}static NoOp(){return new A(A.CommandType.NoOp)}static ChoiceCount(){return new A(A.CommandType.ChoiceCount)}static Turns(){return new A(A.CommandType.Turns)}static TurnsSince(){return new A(A.CommandType.TurnsSince)}static ReadCount(){return new A(A.CommandType.ReadCount)}static Random(){return new A(A.CommandType.Random)}static SeedRandom(){return new A(A.CommandType.SeedRandom)}static VisitIndex(){return new A(A.CommandType.VisitIndex)}static SequenceShuffleIndex(){return new A(A.CommandType.SequenceShuffleIndex)}static StartThread(){return new A(A.CommandType.StartThread)}static Done(){return new A(A.CommandType.Done)}static End(){return new A(A.CommandType.End)}static ListFromInt(){return new A(A.CommandType.ListFromInt)}static ListRange(){return new A(A.CommandType.ListRange)}static ListRandom(){return new A(A.CommandType.ListRandom)}toString(){return this.commandType.toString()}}!function(t){let e;!function(t){t[t.NotSet=-1]="NotSet",t[t.EvalStart=0]="EvalStart",t[t.EvalOutput=1]="EvalOutput",t[t.EvalEnd=2]="EvalEnd",t[t.Duplicate=3]="Duplicate",t[t.PopEvaluatedValue=4]="PopEvaluatedValue",t[t.PopFunction=5]="PopFunction",t[t.PopTunnel=6]="PopTunnel",t[t.BeginString=7]="BeginString",t[t.EndString=8]="EndString",t[t.NoOp=9]="NoOp",t[t.ChoiceCount=10]="ChoiceCount",t[t.Turns=11]="Turns",t[t.TurnsSince=12]="TurnsSince",t[t.Random=13]="Random",t[t.SeedRandom=14]="SeedRandom",t[t.VisitIndex=15]="VisitIndex",t[t.SequenceShuffleIndex=16]="SequenceShuffleIndex",t[t.StartThread=17]="StartThread",t[t.Done=18]="Done",t[t.End=19]="End",t[t.ListFromInt=20]="ListFromInt",t[t.ListRange=21]="ListRange",t[t.ListRandom=22]="ListRandom",t[t.ReadCount=23]="ReadCount",t[t.TOTAL_VALUES=24]="TOTAL_VALUES"}(e=t.CommandType||(t.CommandType={}))}(A||(A={})),function(t){t[t.Tunnel=0]="Tunnel",t[t.Function=1]="Function",t[t.FunctionEvaluationFromGame=2]="FunctionEvaluationFromGame"}(r||(r={}));class I{constructor(){this.container=null,this.index=-1,2===arguments.length&&(this.container=arguments[0],this.index=arguments[1])}Resolve(){return this.index<0?this.container:null==this.container?null:0==this.container.content.length?this.container:this.index>=this.container.content.length?null:this.container.content[this.index]}get isNull(){return null==this.container}get path(){return this.isNull?null:this.index>=0?this.container.path.PathByAppendingComponent(new e.Component(this.index)):this.container.path}toString(){return this.container?"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index:"Ink Pointer (null)"}copy(){return new I(this.container,this.index)}static StartOf(t){return new I(t,0)}static get Null(){return new I(null,-1)}}class k extends p{constructor(t){super(),this._targetPath=null,this._targetPointer=I.Null,this.variableDivertName=null,this.pushesToStack=!1,this.stackPushType=0,this.isExternal=!1,this.externalArgs=0,this.isConditional=!1,this.pushesToStack=!1,void 0!==t&&(this.pushesToStack=!0,this.stackPushType=t)}get targetPath(){if(null!=this._targetPath&&this._targetPath.isRelative){let t=this.targetPointer.Resolve();t&&(this._targetPath=t.path)}return this._targetPath}set targetPath(t){this._targetPath=t,this._targetPointer=I.Null}get targetPointer(){if(this._targetPointer.isNull){let t=this.ResolvePath(this._targetPath).obj;if(null===this._targetPath)return d("this._targetPath");if(null===this._targetPath.lastComponent)return d("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(null===t)return d("targetObj");this._targetPointer.container=t.parent instanceof N?t.parent:null,this._targetPointer.index=this._targetPath.lastComponent.index}else this._targetPointer=I.StartOf(t instanceof N?t:null)}return this._targetPointer.copy()}get targetPathString(){return null==this.targetPath?null:this.CompactPathString(this.targetPath)}set targetPathString(t){this.targetPath=null==t?null:new e(t)}get hasVariableTarget(){return null!=this.variableDivertName}Equals(t){let e=t;return e instanceof k&&this.hasVariableTarget==e.hasVariableTarget&&(this.hasVariableTarget?this.variableDivertName==e.variableDivertName:null===this.targetPath?d("this.targetPath"):this.targetPath.Equals(e.targetPath))}toString(){if(this.hasVariableTarget)return"Divert(variable: "+this.variableDivertName+")";if(null==this.targetPath)return"Divert(null)";{let t=new m,e=this.targetPath.toString();return t.Append("Divert"),this.isConditional&&t.Append("?"),this.pushesToStack&&(this.stackPushType==r.Function?t.Append(" function"):t.Append(" tunnel")),t.Append(" -> "),t.Append(this.targetPathString),t.Append(" ("),t.Append(e),t.Append(")"),t.toString()}}}class W extends p{constructor(t=!0){super(),this._pathOnChoice=null,this.hasCondition=!1,this.hasStartContent=!1,this.hasChoiceOnlyContent=!1,this.isInvisibleDefault=!1,this.onceOnly=!0,this.onceOnly=t}get pathOnChoice(){if(null!=this._pathOnChoice&&this._pathOnChoice.isRelative){let t=this.choiceTarget;t&&(this._pathOnChoice=t.path)}return this._pathOnChoice}set pathOnChoice(t){this._pathOnChoice=t}get choiceTarget(){return null===this._pathOnChoice?d("ChoicePoint._pathOnChoice"):this.ResolvePath(this._pathOnChoice).container}get pathStringOnChoice(){return null===this.pathOnChoice?d("ChoicePoint.pathOnChoice"):this.CompactPathString(this.pathOnChoice)}set pathStringOnChoice(t){this.pathOnChoice=new e(t)}get flags(){let t=0;return this.hasCondition&&(t|=1),this.hasStartContent&&(t|=2),this.hasChoiceOnlyContent&&(t|=4),this.isInvisibleDefault&&(t|=8),this.onceOnly&&(t|=16),t}set flags(t){this.hasCondition=(1&t)>0,this.hasStartContent=(2&t)>0,this.hasChoiceOnlyContent=(4&t)>0,this.isInvisibleDefault=(8&t)>0,this.onceOnly=(16&t)>0}toString(){if(null===this.pathOnChoice)return d("ChoicePoint.pathOnChoice");return"Choice: -> "+this.pathOnChoice.toString()}}class F extends p{constructor(t=null){super(),this.pathForCount=null,this.name=t}get containerForCount(){return null===this.pathForCount?null:this.ResolvePath(this.pathForCount).container}get pathStringForCount(){return null===this.pathForCount?null:this.CompactPathString(this.pathForCount)}set pathStringForCount(t){this.pathForCount=null===t?null:new e(t)}toString(){if(null!=this.name)return"var("+this.name+")";return"read_count("+this.pathStringForCount+")"}}class V extends p{constructor(t,e){super(),this.variableName=t||null,this.isNewDeclaration=!!e,this.isGlobal=!1}toString(){return"VarAssign to "+this.variableName}}class L extends p{}class R extends p{constructor(){if(super(),this._name=null,this._numberOfParameters=0,this._prototype=null,this._isPrototype=!1,this._operationFuncs=null,0===arguments.length)R.GenerateNativeFunctionsIfNecessary();else if(1===arguments.length){let t=arguments[0];R.GenerateNativeFunctionsIfNecessary(),this.name=t}else if(2===arguments.length){let t=arguments[0],e=arguments[1];this._isPrototype=!0,this.name=t,this.numberOfParameters=e}}static CallWithName(t){return new R(t)}static CallExistsWithName(t){return this.GenerateNativeFunctionsIfNecessary(),this._nativeFunctions.get(t)}get name(){return null===this._name?d("NativeFunctionCall._name"):this._name}set name(t){this._name=t,this._isPrototype||(null===R._nativeFunctions?d("NativeFunctionCall._nativeFunctions"):this._prototype=R._nativeFunctions.get(this._name)||null)}get numberOfParameters(){return this._prototype?this._prototype.numberOfParameters:this._numberOfParameters}set numberOfParameters(t){this._numberOfParameters=t}Call(t){if(this._prototype)return this._prototype.Call(t);if(this.numberOfParameters!=t.length)throw new Error("Unexpected number of parameters");let e=!1;for(let n of t){if(n instanceof L)throw new S('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');n instanceof O&&(e=!0)}if(2==t.length&&e)return this.CallBinaryListOperation(t);let n=this.CoerceValuesToSingleType(t),r=n[0].valueType;return r==i.Int||r==i.Float||r==i.String||r==i.DivertTarget||r==i.List?this.CallType(n):null}CallType(t){let e=s(t[0],v),n=e.valueType,r=e,a=t.length;if(2==a||1==a){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(n);if(!l){const t=i[n];throw new S("Cannot perform operation "+this.name+" on "+t)}if(2==a){let e=s(t[1],v),n=l;if(null===r.value||null===e.value)return d("NativeFunctionCall.Call BinaryOp values");let i=n(r.value,e.value);return v.Create(i)}{let t=l;if(null===r.value)return d("NativeFunctionCall.Call UnaryOp value");let n=t(r.value);return this.name===R.Int?v.Create(n,i.Int):this.name===R.Float?v.Create(n,i.Float):v.Create(n,e.valueType)}}throw new Error("Unexpected number of parameters to NativeFunctionCall: "+t.length)}CallBinaryListOperation(t){if(("+"==this.name||"-"==this.name)&&t[0]instanceof O&&t[1]instanceof b)return this.CallListIncrementOperation(t);let e=s(t[0],v),n=s(t[1],v);if(!("&&"!=this.name&&"||"!=this.name||e.valueType==i.List&&n.valueType==i.List)){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let t=this._operationFuncs.get(i.Int);if(null===t)return d("NativeFunctionCall.CallBinaryListOperation op");let r=t(e.isTruthy?1:0,n.isTruthy?1:0);return new b(r)}if(e.valueType==i.List&&n.valueType==i.List)return this.CallType([e,n]);throw new S("Can not call use "+this.name+" operation on "+i[e.valueType]+" and "+i[n.valueType])}CallListIncrementOperation(t){let e=s(t[0],O),n=s(t[1],b),r=new g;if(null===e.value)return d("NativeFunctionCall.CallListIncrementOperation listVal.value");for(let[t,a]of e.value){let s=f.fromSerializedKey(t);if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(i.Int);if(null===n.value)return d("NativeFunctionCall.CallListIncrementOperation intVal.value");let o=l(a,n.value),u=null;if(null===e.value.origins)return d("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");for(let t of e.value.origins)if(t.name==s.originName){u=t;break}if(null!=u){let t=u.TryGetItemWithValue(o,f.Null);t.exists&&r.Add(t.result,o)}}return new O(r)}CoerceValuesToSingleType(t){let e=i.Int,n=null;for(let r of t){let t=s(r,v);t.valueType>e&&(e=t.valueType),t.valueType==i.List&&(n=a(t,O))}let r=[];if(i[e]==i[i.List])for(let e of t){let t=s(e,v);if(t.valueType==i.List)r.push(t);else{if(t.valueType!=i.Int){const e=i[t.valueType];throw new S("Cannot mix Lists and "+e+" values in this operation")}{let e=parseInt(t.valueObject);if(n=s(n,O),null===n.value)return d("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");let i=n.value.originOfMaxItem;if(null===i)return d("NativeFunctionCall.CoerceValuesToSingleType list");let a=i.TryGetItemWithValue(e,f.Null);if(!a.exists)throw new S("Could not find List item with the value "+e+" in "+i.name);{let t=new O(a.result,e);r.push(t)}}}}else for(let n of t){let t=s(n,v).Cast(e);r.push(t)}return r}static Identity(t){return t}static GenerateNativeFunctionsIfNecessary(){if(null==this._nativeFunctions){this._nativeFunctions=new Map,this.AddIntBinaryOp(this.Add,(t,e)=>t+e),this.AddIntBinaryOp(this.Subtract,(t,e)=>t-e),this.AddIntBinaryOp(this.Multiply,(t,e)=>t*e),this.AddIntBinaryOp(this.Divide,(t,e)=>Math.floor(t/e)),this.AddIntBinaryOp(this.Mod,(t,e)=>t%e),this.AddIntUnaryOp(this.Negate,t=>-t),this.AddIntBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddIntBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddIntBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddIntBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddIntBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddIntBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddIntUnaryOp(this.Not,t=>0==t?1:0),this.AddIntBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddIntBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddIntBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddIntBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddIntBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddIntUnaryOp(this.Floor,R.Identity),this.AddIntUnaryOp(this.Ceiling,R.Identity),this.AddIntUnaryOp(this.Int,R.Identity),this.AddIntUnaryOp(this.Float,t=>t),this.AddFloatBinaryOp(this.Add,(t,e)=>t+e),this.AddFloatBinaryOp(this.Subtract,(t,e)=>t-e),this.AddFloatBinaryOp(this.Multiply,(t,e)=>t*e),this.AddFloatBinaryOp(this.Divide,(t,e)=>t/e),this.AddFloatBinaryOp(this.Mod,(t,e)=>t%e),this.AddFloatUnaryOp(this.Negate,t=>-t),this.AddFloatBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddFloatBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddFloatBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddFloatBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddFloatBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddFloatBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddFloatUnaryOp(this.Not,t=>0==t?1:0),this.AddFloatBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddFloatBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddFloatBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddFloatBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddFloatBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddFloatUnaryOp(this.Floor,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Ceiling,t=>Math.ceil(t)),this.AddFloatUnaryOp(this.Int,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Float,R.Identity),this.AddStringBinaryOp(this.Add,(t,e)=>t+e),this.AddStringBinaryOp(this.Equal,(t,e)=>t===e?1:0),this.AddStringBinaryOp(this.NotEquals,(t,e)=>t!==e?1:0),this.AddStringBinaryOp(this.Has,(t,e)=>t.includes(e)?1:0),this.AddStringBinaryOp(this.Hasnt,(t,e)=>t.includes(e)?0:1),this.AddListBinaryOp(this.Add,(t,e)=>t.Union(e)),this.AddListBinaryOp(this.Subtract,(t,e)=>t.Without(e)),this.AddListBinaryOp(this.Has,(t,e)=>t.Contains(e)?1:0),this.AddListBinaryOp(this.Hasnt,(t,e)=>t.Contains(e)?0:1),this.AddListBinaryOp(this.Intersect,(t,e)=>t.Intersect(e)),this.AddListBinaryOp(this.Equal,(t,e)=>t.Equals(e)?1:0),this.AddListBinaryOp(this.Greater,(t,e)=>t.GreaterThan(e)?1:0),this.AddListBinaryOp(this.Less,(t,e)=>t.LessThan(e)?1:0),this.AddListBinaryOp(this.GreaterThanOrEquals,(t,e)=>t.GreaterThanOrEquals(e)?1:0),this.AddListBinaryOp(this.LessThanOrEquals,(t,e)=>t.LessThanOrEquals(e)?1:0),this.AddListBinaryOp(this.NotEquals,(t,e)=>t.Equals(e)?0:1),this.AddListBinaryOp(this.And,(t,e)=>t.Count>0&&e.Count>0?1:0),this.AddListBinaryOp(this.Or,(t,e)=>t.Count>0||e.Count>0?1:0),this.AddListUnaryOp(this.Not,t=>0==t.Count?1:0),this.AddListUnaryOp(this.Invert,t=>t.inverse),this.AddListUnaryOp(this.All,t=>t.all),this.AddListUnaryOp(this.ListMin,t=>t.MinAsList()),this.AddListUnaryOp(this.ListMax,t=>t.MaxAsList()),this.AddListUnaryOp(this.Count,t=>t.Count),this.AddListUnaryOp(this.ValueOfList,t=>t.maxItem.Value);let t=(t,e)=>t.Equals(e)?1:0,e=(t,e)=>t.Equals(e)?0:1;this.AddOpToNativeFunc(this.Equal,2,i.DivertTarget,t),this.AddOpToNativeFunc(this.NotEquals,2,i.DivertTarget,e)}}AddOpFuncForType(t,e){null==this._operationFuncs&&(this._operationFuncs=new Map),this._operationFuncs.set(t,e)}static AddOpToNativeFunc(t,e,n,i){if(null===this._nativeFunctions)return d("NativeFunctionCall._nativeFunctions");let r=this._nativeFunctions.get(t);r||(r=new R(t,e),this._nativeFunctions.set(t,r)),r.AddOpFuncForType(n,i)}static AddIntBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Int,e)}static AddIntUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Int,e)}static AddFloatBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Float,e)}static AddFloatUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Float,e)}static AddStringBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.String,e)}static AddListBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.List,e)}static AddListUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.List,e)}toString(){return'Native "'+this.name+'"'}}R.Add="+",R.Subtract="-",R.Divide="/",R.Multiply="*",R.Mod="%",R.Negate="_",R.Equal="==",R.Greater=">",R.Less="<",R.GreaterThanOrEquals=">=",R.LessThanOrEquals="<=",R.NotEquals="!=",R.Not="!",R.And="&&",R.Or="||",R.Min="MIN",R.Max="MAX",R.Pow="POW",R.Floor="FLOOR",R.Ceiling="CEILING",R.Int="INT",R.Float="FLOAT",R.Has="?",R.Hasnt="!?",R.Intersect="^",R.ListMin="LIST_MIN",R.ListMax="LIST_MAX",R.All="LIST_ALL",R.Count="LIST_COUNT",R.ValueOfList="LIST_VALUE",R.Invert="LIST_INVERT",R._nativeFunctions=null;class j extends p{constructor(t){super(),this.text=t.toString()||""}toString(){return"# "+this.text}}class D extends p{constructor(){super(...arguments),this.text="",this.index=0,this.threadAtGeneration=null,this.sourcePath="",this.targetPath=null,this.isInvisibleDefault=!1,this.originalThreadIndex=0}get pathStringOnChoice(){return null===this.targetPath?d("Choice.targetPath"):this.targetPath.toString()}set pathStringOnChoice(t){this.targetPath=new e(t)}}class G{constructor(t,e){this._name=t||"",this._items=null,this._itemNameToValues=e||new Map}get name(){return this._name}get items(){if(null==this._items){this._items=new Map;for(let[t,e]of this._itemNameToValues){let n=new f(this.name,t);this._items.set(n.serialized(),e)}}return this._items}ValueForItem(t){if(!t.itemName)return 0;let e=this._itemNameToValues.get(t.itemName);return void 0!==e?e:0}ContainsItem(t){return!!t.itemName&&(t.originName==this.name&&this._itemNameToValues.has(t.itemName))}ContainsItemWithName(t){return this._itemNameToValues.has(t)}TryGetItemWithValue(t,e){for(let[e,n]of this._itemNameToValues)if(n==t)return{result:new f(this.name,e),exists:!0};return{result:f.Null,exists:!1}}TryGetValueForItem(t,e){if(!t.itemName)return{result:0,exists:!1};let n=this._itemNameToValues.get(t.itemName);return n?{result:n,exists:!0}:{result:0,exists:!1}}}class B{constructor(t){this._lists=new Map,this._allUnambiguousListValueCache=new Map;for(let e of t){this._lists.set(e.name,e);for(let[t,n]of e.items){let e=f.fromSerializedKey(t),i=new O(e,n);if(!e.itemName)throw new Error("item.itemName is null or undefined.");this._allUnambiguousListValueCache.set(e.itemName,i),this._allUnambiguousListValueCache.set(e.fullName,i)}}}get lists(){let t=[];for(let[,e]of this._lists)t.push(e);return t}TryListGetDefinition(t,e){if(null===t)return{result:e,exists:!1};let n=this._lists.get(t);return n?{result:n,exists:!0}:{result:e,exists:!1}}FindSingleItemListWithName(t){if(null===t)return d("name");let e=this._allUnambiguousListValueCache.get(t);return void 0!==e?e:null}}class M{static JArrayToRuntimeObjList(t,e=!1){let n=t.length;e&&n--;let i=[];for(let e=0;e<n;e++){let n=t[e],r=this.JTokenToRuntimeObject(n);if(null===r)return d("runtimeObj");i.push(r)}return i}static WriteDictionaryRuntimeObjs(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WritePropertyStart(n),this.WriteRuntimeObject(t,i),t.WritePropertyEnd();t.WriteObjectEnd()}static WriteListRuntimeObjs(t,e){t.WriteArrayStart();for(let n of e)this.WriteRuntimeObject(t,n);t.WriteArrayEnd()}static WriteIntDictionary(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WriteIntProperty(n,i);t.WriteObjectEnd()}static WriteRuntimeObject(t,e){let n=a(e,N);if(n)return void this.WriteRuntimeContainer(t,n);let i=a(e,k);if(i){let e,n="->";return i.isExternal?n="x()":i.pushesToStack&&(i.stackPushType==r.Function?n="f()":i.stackPushType==r.Tunnel&&(n="->t->")),e=i.hasVariableTarget?i.variableDivertName:i.targetPathString,t.WriteObjectStart(),t.WriteProperty(n,e),i.hasVariableTarget&&t.WriteProperty("var",!0),i.isConditional&&t.WriteProperty("c",!0),i.externalArgs>0&&t.WriteIntProperty("exArgs",i.externalArgs),void t.WriteObjectEnd()}let s=a(e,W);if(s)return t.WriteObjectStart(),t.WriteProperty("*",s.pathStringOnChoice),t.WriteIntProperty("flg",s.flags),void t.WriteObjectEnd();let l=a(e,b);if(l)return void t.WriteInt(l.value);let o=a(e,_);if(o)return void t.WriteFloat(o.value);let u=a(e,T);if(u)return void(u.isNewline?t.Write("\n",!1):(t.WriteStringStart(),t.WriteStringInner("^"),t.WriteStringInner(u.value),t.WriteStringEnd()));let h=a(e,O);if(h)return void this.WriteInkList(t,h);let c=a(e,P);if(c)return t.WriteObjectStart(),null===c.value?d("divTargetVal.value"):(t.WriteProperty("^->",c.value.componentsString),void t.WriteObjectEnd());let p=a(e,w);if(p)return t.WriteObjectStart(),t.WriteProperty("^var",p.value),t.WriteIntProperty("ci",p.contextIndex),void t.WriteObjectEnd();if(a(e,x))return void t.Write("<>");let m=a(e,A);if(m)return void t.Write(M._controlCommandNames[m.commandType]);let f=a(e,R);if(f){let e=f.name;return"^"==e&&(e="L^"),void t.Write(e)}let g=a(e,F);if(g){t.WriteObjectStart();let e=g.pathStringForCount;return null!=e?t.WriteProperty("CNT?",e):t.WriteProperty("VAR?",g.name),void t.WriteObjectEnd()}let S=a(e,V);if(S){t.WriteObjectStart();let e=S.isGlobal?"VAR=":"temp=";return t.WriteProperty(e,S.variableName),S.isNewDeclaration||t.WriteProperty("re",!0),void t.WriteObjectEnd()}if(a(e,L))return void t.Write("void");let y=a(e,j);if(y)return t.WriteObjectStart(),t.WriteProperty("#",y.text),void t.WriteObjectEnd();let C=a(e,D);if(!C)throw new Error("Failed to convert runtime object to Json token: "+e);this.WriteChoice(t,C)}static JObjectToDictionaryRuntimeObjs(t){let e=new Map;for(let n in t)if(t.hasOwnProperty(n)){let i=this.JTokenToRuntimeObject(t[n]);if(null===i)return d("inkObject");e.set(n,i)}return e}static JObjectToIntDictionary(t){let e=new Map;for(let n in t)t.hasOwnProperty(n)&&e.set(n,parseInt(t[n]));return e}static JTokenToRuntimeObject(t){if("number"==typeof t&&!isNaN(t))return v.Create(t);if("string"==typeof t){let e=t.toString(),n=e[0];if("^"==n)return new T(e.substring(1));if("\n"==n&&1==e.length)return new T("\n");if("<>"==e)return new x;for(let t=0;t<M._controlCommandNames.length;++t){if(e==M._controlCommandNames[t])return new A(t)}if("L^"==e&&(e="^"),R.CallExistsWithName(e))return R.CallWithName(e);if("->->"==e)return A.PopTunnel();if("~ret"==e)return A.PopFunction();if("void"==e)return new L}if("object"==typeof t&&!Array.isArray(t)){let n,i=t;if(i["^->"])return n=i["^->"],new P(new e(n.toString()));if(i["^var"]){n=i["^var"];let t=new w(n.toString());return"ci"in i&&(n=i.ci,t.contextIndex=parseInt(n)),t}let a=!1,s=!1,l=r.Function,o=!1;if((n=i["->"])?a=!0:(n=i["f()"])?(a=!0,s=!0,l=r.Function):(n=i["->t->"])?(a=!0,s=!0,l=r.Tunnel):(n=i["x()"])&&(a=!0,o=!0,s=!1,l=r.Function),a){let t=new k;t.pushesToStack=s,t.stackPushType=l,t.isExternal=o;let e=n.toString();return(n=i.var)?t.variableDivertName=e:t.targetPathString=e,t.isConditional=!!i.c,o&&(n=i.exArgs)&&(t.externalArgs=parseInt(n)),t}if(n=i["*"]){let t=new W;return t.pathStringOnChoice=n.toString(),(n=i.flg)&&(t.flags=parseInt(n)),t}if(n=i["VAR?"])return new F(n.toString());if(n=i["CNT?"]){let t=new F;return t.pathStringForCount=n.toString(),t}let u=!1,h=!1;if((n=i["VAR="])?(u=!0,h=!0):(n=i["temp="])&&(u=!0,h=!1),u){let t=n.toString(),e=!i.re,r=new V(t,e);return r.isGlobal=h,r}if(void 0!==i["#"])return n=i["#"],new j(n.toString());if(n=i.list){let t=n,e=new g;if(n=i.origins){let t=n;e.SetInitialOriginNames(t)}for(let n in t)if(t.hasOwnProperty(n)){let i=t[n],r=new f(n),a=parseInt(i);e.Add(r,a)}return new O(e)}if(null!=i.originalChoicePath)return this.JObjectToChoice(i)}if(Array.isArray(t))return this.JArrayToContainer(t);if(null==t)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(t))}static WriteRuntimeContainer(t,e,n=!1){if(t.WriteArrayStart(),null===e)return d("container");for(let n of e.content)this.WriteRuntimeObject(t,n);let i=e.namedOnlyContent,r=e.countFlags,s=null!=e.name&&!n,l=null!=i||r>0||s;if(l&&t.WriteObjectStart(),null!=i)for(let[e,n]of i){let i=e,r=a(n,N);t.WritePropertyStart(i),this.WriteRuntimeContainer(t,r,!0),t.WritePropertyEnd()}s&&t.WriteProperty("#n",e.name),l?t.WriteObjectEnd():t.WriteNull(),t.WriteArrayEnd()}static JArrayToContainer(t){let e=new N;e.content=this.JArrayToRuntimeObjList(t,!0);let n=t[t.length-1];if(null!=n){let t=new Map;for(let i in n)if("#f"==i)e.countFlags=parseInt(n[i]);else if("#n"==i)e.name=n[i].toString();else{let e=this.JTokenToRuntimeObject(n[i]),r=a(e,N);r&&(r.name=i),t.set(i,e)}e.namedOnlyContent=t}return e}static JObjectToChoice(t){let e=new D;return e.text=t.text.toString(),e.index=parseInt(t.index),e.sourcePath=t.originalChoicePath.toString(),e.originalThreadIndex=parseInt(t.originalThreadIndex),e.pathStringOnChoice=t.targetPath.toString(),e}static WriteChoice(t,e){t.WriteObjectStart(),t.WriteProperty("text",e.text),t.WriteIntProperty("index",e.index),t.WriteProperty("originalChoicePath",e.sourcePath),t.WriteIntProperty("originalThreadIndex",e.originalThreadIndex),t.WriteProperty("targetPath",e.pathStringOnChoice),t.WriteObjectEnd()}static WriteInkList(t,e){let n=e.value;if(null===n)return d("rawList");t.WriteObjectStart(),t.WritePropertyStart("list"),t.WriteObjectStart();for(let[e,i]of n){let n=f.fromSerializedKey(e),r=i;if(null===n.itemName)return d("item.itemName");t.WritePropertyNameStart(),t.WritePropertyNameInner(n.originName?n.originName:"?"),t.WritePropertyNameInner("."),t.WritePropertyNameInner(n.itemName),t.WritePropertyNameEnd(),t.Write(r),t.WritePropertyEnd()}if(t.WriteObjectEnd(),t.WritePropertyEnd(),0==n.Count&&null!=n.originNames&&n.originNames.length>0){t.WritePropertyStart("origins"),t.WriteArrayStart();for(let e of n.originNames)t.Write(e);t.WriteArrayEnd(),t.WritePropertyEnd()}t.WriteObjectEnd()}static ListDefinitionsToJToken(t){let e={};for(let n of t.lists){let t={};for(let[e,i]of n.items){let n=f.fromSerializedKey(e);if(null===n.itemName)return d("item.itemName");t[n.itemName]=i}e[n.name]=t}return e}static JTokenToListDefinitions(t){let e=t,n=[];for(let t in e)if(e.hasOwnProperty(t)){let i=t.toString(),r=e[t],a=new Map;for(let n in r)if(e.hasOwnProperty(t)){let t=r[n];a.set(n,parseInt(t))}let s=new G(i,a);n.push(s)}return new B(n)}}M._controlCommandNames=(()=>{let t=[];t[A.CommandType.EvalStart]="ev",t[A.CommandType.EvalOutput]="out",t[A.CommandType.EvalEnd]="/ev",t[A.CommandType.Duplicate]="du",t[A.CommandType.PopEvaluatedValue]="pop",t[A.CommandType.PopFunction]="~ret",t[A.CommandType.PopTunnel]="->->",t[A.CommandType.BeginString]="str",t[A.CommandType.EndString]="/str",t[A.CommandType.NoOp]="nop",t[A.CommandType.ChoiceCount]="choiceCnt",t[A.CommandType.Turns]="turn",t[A.CommandType.TurnsSince]="turns",t[A.CommandType.ReadCount]="readc",t[A.CommandType.Random]="rnd",t[A.CommandType.SeedRandom]="srnd",t[A.CommandType.VisitIndex]="visit",t[A.CommandType.SequenceShuffleIndex]="seq",t[A.CommandType.StartThread]="thread",t[A.CommandType.Done]="done",t[A.CommandType.End]="end",t[A.CommandType.ListFromInt]="listInt",t[A.CommandType.ListRange]="range",t[A.CommandType.ListRandom]="lrnd";for(let e=0;e<A.CommandType.TOTAL_VALUES;++e)if(null==t[e])throw new Error("Control command not accounted for in serialisation");return t})();class q{constructor(){if(this._threadCounter=0,this._startOfRoot=I.Null,arguments[0]instanceof X){let t=arguments[0];this._startOfRoot=I.StartOf(t.rootContentContainer),this.Reset()}else{let t=arguments[0];this._threads=[];for(let e of t._threads)this._threads.push(e.Copy());this._threadCounter=t._threadCounter,this._startOfRoot=t._startOfRoot}}get elements(){return this.callStack}get depth(){return this.elements.length}get currentElement(){let t=this._threads[this._threads.length-1].callstack;return t[t.length-1]}get currentElementIndex(){return this.callStack.length-1}get currentThread(){return this._threads[this._threads.length-1]}set currentThread(t){n.Assert(1==this._threads.length,"Shouldn't be directly setting the current thread when we have a stack of them"),this._threads.length=0,this._threads.push(t)}get canPop(){return this.callStack.length>1}Reset(){this._threads=[],this._threads.push(new q.Thread),this._threads[0].callstack.push(new q.Element(r.Tunnel,this._startOfRoot))}SetJsonToken(t,e){this._threads.length=0;let n=t.threads;for(let t of n){let n=t,i=new q.Thread(n,e);this._threads.push(i)}this._threadCounter=parseInt(t.threadCounter),this._startOfRoot=I.StartOf(e.rootContentContainer)}WriteJson(t){t.WriteObject(t=>{t.WritePropertyStart("threads"),t.WriteArrayStart();for(let e of this._threads)e.WriteJson(t);t.WriteArrayEnd(),t.WritePropertyEnd(),t.WritePropertyStart("threadCounter"),t.WriteInt(this._threadCounter),t.WritePropertyEnd()})}PushThread(){let t=this.currentThread.Copy();this._threadCounter++,t.threadIndex=this._threadCounter,this._threads.push(t)}ForkThread(){let t=this.currentThread.Copy();return this._threadCounter++,t.threadIndex=this._threadCounter,t}PopThread(){if(!this.canPopThread)throw new Error("Can't pop thread");this._threads.splice(this._threads.indexOf(this.currentThread),1)}get canPopThread(){return this._threads.length>1&&!this.elementIsEvaluateFromGame}get elementIsEvaluateFromGame(){return this.currentElement.type==r.FunctionEvaluationFromGame}Push(t,e=0,n=0){let i=new q.Element(t,this.currentElement.currentPointer,!1);i.evaluationStackHeightWhenPushed=e,i.functionStartInOutputStream=n,this.callStack.push(i)}CanPop(t=null){return!!this.canPop&&(null==t||this.currentElement.type==t)}Pop(t=null){if(!this.CanPop(t))throw new Error("Mismatched push/pop in Callstack");this.callStack.pop()}GetTemporaryVariableWithName(t,e=-1){-1==e&&(e=this.currentElementIndex+1);let n=y(this.callStack[e-1].temporaryVariables,t,null);return n.exists?n.result:null}SetTemporaryVariable(t,e,n,i=-1){-1==i&&(i=this.currentElementIndex+1);let r=this.callStack[i-1];if(!n&&!r.temporaryVariables.get(t))throw new S("Could not find temporary variable to set: "+t);let a=y(r.temporaryVariables,t,null);a.exists&&O.RetainListOriginsForAssignment(a.result,e),r.temporaryVariables.set(t,e)}ContextForVariableNamed(t){return this.currentElement.temporaryVariables.get(t)?this.currentElementIndex+1:0}ThreadWithIndex(t){let e=this._threads.filter(e=>{if(e.threadIndex==t)return e});return e.length>0?e[0]:null}get callStack(){return this.currentThread.callstack}get callStackTrace(){let t=new m;for(let e=0;e<this._threads.length;e++){let n=this._threads[e],i=e==this._threads.length-1;t.AppendFormat("=== THREAD {0}/{1} {2}===\n",e+1,this._threads.length,i?"(current) ":"");for(let e=0;e<n.callstack.length;e++){n.callstack[e].type==r.Function?t.Append("  [FUNCTION] "):t.Append("  [TUNNEL] ");let i=n.callstack[e].currentPointer;if(!i.isNull){if(t.Append("<SOMEWHERE IN "),null===i.container)return d("pointer.container");t.Append(i.container.path.toString()),t.AppendLine(">")}}}return t.toString()}}!function(t){class n{constructor(t,e,n=!1){this.evaluationStackHeightWhenPushed=0,this.functionStartInOutputStream=0,this.currentPointer=e.copy(),this.inExpressionEvaluation=n,this.temporaryVariables=new Map,this.type=t}Copy(){let t=new n(this.type,this.currentPointer,this.inExpressionEvaluation);return t.temporaryVariables=new Map(this.temporaryVariables),t.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed,t.functionStartInOutputStream=this.functionStartInOutputStream,t}}t.Element=n;class i{constructor(){if(this.threadIndex=0,this.previousPointer=I.Null,this.callstack=[],arguments[0]&&arguments[1]){let t=arguments[0],i=arguments[1];this.threadIndex=parseInt(t.threadIndex);let r=t.callstack;for(let t of r){let r,a=t,s=parseInt(a.type),l=I.Null,o=a.cPath;if(void 0!==o){r=o.toString();let t=i.ContentAtPath(new e(r));if(l.container=t.container,l.index=parseInt(a.idx),null==t.obj)throw new Error("When loading state, internal story location couldn't be found: "+r+". Has the story changed since this save data was created?");if(t.approximate){if(null===l.container)return d("pointer.container");i.Warning("When loading state, exact internal story location couldn't be found: '"+r+"', so it was approximated to '"+l.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}let u=!!a.exp,h=new n(s,l,u),c=a.temp;void 0!==c?h.temporaryVariables=M.JObjectToDictionaryRuntimeObjs(c):h.temporaryVariables.clear(),this.callstack.push(h)}let a=t.previousContentObject;if(void 0!==a){let t=new e(a.toString());this.previousPointer=i.PointerAtPath(t)}}}Copy(){let t=new i;t.threadIndex=this.threadIndex;for(let e of this.callstack)t.callstack.push(e.Copy());return t.previousPointer=this.previousPointer.copy(),t}WriteJson(t){t.WriteObjectStart(),t.WritePropertyStart("callstack"),t.WriteArrayStart();for(let e of this.callstack){if(t.WriteObjectStart(),!e.currentPointer.isNull){if(null===e.currentPointer.container)return d("el.currentPointer.container");t.WriteProperty("cPath",e.currentPointer.container.path.componentsString),t.WriteIntProperty("idx",e.currentPointer.index)}t.WriteProperty("exp",e.inExpressionEvaluation),t.WriteIntProperty("type",e.type),e.temporaryVariables.size>0&&(t.WritePropertyStart("temp"),M.WriteDictionaryRuntimeObjs(t,e.temporaryVariables),t.WritePropertyEnd()),t.WriteObjectEnd()}if(t.WriteArrayEnd(),t.WritePropertyEnd(),t.WriteIntProperty("threadIndex",this.threadIndex),!this.previousPointer.isNull){let e=this.previousPointer.Resolve();if(null===e)return d("this.previousPointer.Resolve()");t.WriteProperty("previousContentObject",e.path.toString())}t.WriteObjectEnd()}}t.Thread=i}(q||(q={}));class J{constructor(t,e){this.variableChangedEventCallbacks=[],this.patch=null,this._batchObservingVariableChanges=!1,this._defaultGlobalVariables=new Map,this._changedVariablesForBatchObs=new Set,this._globalVariables=new Map,this._callStack=t,this._listDefsOrigin=e;try{return new Proxy(this,{get:(t,e)=>e in t?t[e]:t.$(e),set:(t,e,n)=>(e in t?t[e]=n:t.$(e,n),!0)})}catch(t){}}variableChangedEvent(t,e){for(let n of this.variableChangedEventCallbacks)n(t,e)}get batchObservingVariableChanges(){return this._batchObservingVariableChanges}set batchObservingVariableChanges(t){if(this._batchObservingVariableChanges=t,t)this._changedVariablesForBatchObs=new Set;else if(null!=this._changedVariablesForBatchObs){for(let t of this._changedVariablesForBatchObs){let e=this._globalVariables.get(t);e?this.variableChangedEvent(t,e):d("currentValue")}this._changedVariablesForBatchObs=null}}get callStack(){return this._callStack}set callStack(t){this._callStack=t}$(t,e){if(void 0===e){let e=null;return null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists)?e.result.valueObject:(e=this._globalVariables.get(t),void 0===e&&(e=this._defaultGlobalVariables.get(t)),void 0!==e?e.valueObject:null)}{if(void 0===this._defaultGlobalVariables.get(t))throw new S("Cannot assign to a variable ("+t+") that hasn't been declared in the story");let n=v.Create(e);if(null==n)throw new S(null==e?"Cannot pass null to VariableState":"Invalid value passed to VariableState: "+e.toString());this.SetGlobal(t,n)}}ApplyPatch(){if(null===this.patch)return d("this.patch");for(let[t,e]of this.patch.globals)this._globalVariables.set(t,e);if(null!==this._changedVariablesForBatchObs)for(let t of this.patch.changedVariables)this._changedVariablesForBatchObs.add(t);this.patch=null}SetJsonToken(t){this._globalVariables.clear();for(let[e,n]of this._defaultGlobalVariables){let i=t[e];if(void 0!==i){let t=M.JTokenToRuntimeObject(i);if(null===t)return d("tokenInkObject");this._globalVariables.set(e,t)}else this._globalVariables.set(e,n)}}WriteJson(t){t.WriteObjectStart();for(let[e,n]of this._globalVariables){let i=e,r=n;if(J.dontSaveDefaultValues&&this._defaultGlobalVariables.has(i)){let t=this._defaultGlobalVariables.get(i);if(this.RuntimeObjectsEqual(r,t))continue}t.WritePropertyStart(i),M.WriteRuntimeObject(t,r),t.WritePropertyEnd()}t.WriteObjectEnd()}RuntimeObjectsEqual(t,e){if(null===t)return d("obj1");if(null===e)return d("obj2");if(t.constructor!==e.constructor)return!1;let n=a(t,b);if(null!==n)return n.value===s(e,b).value;let i=a(t,_);if(null!==i)return i.value===s(e,_).value;let r=a(t,v),l=a(e,v);if(null!==r&&null!==l)return u(r.valueObject)&&u(l.valueObject)?r.valueObject.Equals(l.valueObject):r.valueObject===l.valueObject;throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: "+t.constructor.name)}GetVariableWithName(t,e=-1){let n=this.GetRawVariableWithName(t,e),i=a(n,w);return null!==i&&(n=this.ValueAtVariablePointer(i)),n}TryGetDefaultVariableValue(t){let e=y(this._defaultGlobalVariables,t,null);return e.exists?e.result:null}GlobalVariableExistsWithName(t){return this._globalVariables.has(t)||null!==this._defaultGlobalVariables&&this._defaultGlobalVariables.has(t)}GetRawVariableWithName(t,e){let n=null;if(0==e||-1==e){let e=null;if(null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists))return e.result;if(e=y(this._globalVariables,t,null),e.exists)return e.result;if(null!==this._defaultGlobalVariables&&(e=y(this._defaultGlobalVariables,t,null),e.exists))return e.result;if(null===this._listDefsOrigin)return d("VariablesState._listDefsOrigin");let n=this._listDefsOrigin.FindSingleItemListWithName(t);if(n)return n}return n=this._callStack.GetTemporaryVariableWithName(t,e),n}ValueAtVariablePointer(t){return this.GetVariableWithName(t.variableName,t.contextIndex)}Assign(t,e){let n=t.variableName;if(null===n)return d("name");let i=-1,r=!1;if(r=t.isNewDeclaration?t.isGlobal:this.GlobalVariableExistsWithName(n),t.isNewDeclaration){let t=a(e,w);if(null!==t){e=this.ResolveVariablePointer(t)}}else{let t=null;do{t=a(this.GetRawVariableWithName(n,i),w),null!=t&&(n=t.variableName,i=t.contextIndex,r=0==i)}while(null!=t)}r?this.SetGlobal(n,e):this._callStack.SetTemporaryVariable(n,e,t.isNewDeclaration,i)}SnapshotDefaultGlobals(){this._defaultGlobalVariables=new Map(this._globalVariables)}RetainListOriginsForAssignment(t,e){let n=s(t,O),i=s(e,O);n.value&&i.value&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames)}SetGlobal(t,e){let n=null;if(null===this.patch&&(n=y(this._globalVariables,t,null)),null!==this.patch&&(n=this.patch.TryGetGlobal(t,null),n.exists||(n=y(this._globalVariables,t,null))),O.RetainListOriginsForAssignment(n.result,e),null===t)return d("variableName");if(null!==this.patch?this.patch.SetGlobal(t,e):this._globalVariables.set(t,e),null!==this.variableChangedEvent&&null!==n&&e!==n.result)if(this.batchObservingVariableChanges){if(null===this._changedVariablesForBatchObs)return d("this._changedVariablesForBatchObs");null!==this.patch?this.patch.AddChangedVariable(t):null!==this._changedVariablesForBatchObs&&this._changedVariablesForBatchObs.add(t)}else this.variableChangedEvent(t,e)}ResolveVariablePointer(t){let e=t.contextIndex;-1==e&&(e=this.GetContextIndexOfVariableNamed(t.variableName));let n=a(this.GetRawVariableWithName(t.variableName,e),w);return null!=n?n:new w(t.variableName,e)}GetContextIndexOfVariableNamed(t){return this.GlobalVariableExistsWithName(t)?0:this._callStack.currentElementIndex}ObserveVariableChange(t){this.variableChangedEventCallbacks.push(t)}}J.dontSaveDefaultValues=!0;class K{constructor(t){this.seed=t%2147483647,this.seed<=0&&(this.seed+=2147483646)}next(){return this.seed=16807*this.seed%2147483647}nextFloat(){return(this.next()-1)/2147483646}}class U{constructor(){if(this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map,1===arguments.length&&null!==arguments[0]){let t=arguments[0];this._globals=new Map(t._globals),this._changedVariables=new Set(t._changedVariables),this._visitCounts=new Map(t._visitCounts),this._turnIndices=new Map(t._turnIndices)}else this._globals=new Map,this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map}get globals(){return this._globals}get changedVariables(){return this._changedVariables}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}TryGetGlobal(t,e){return null!==t&&this._globals.has(t)?{result:this._globals.get(t),exists:!0}:{result:e,exists:!1}}SetGlobal(t,e){this._globals.set(t,e)}AddChangedVariable(t){return this._changedVariables.add(t)}TryGetVisitCount(t,e){return this._visitCounts.has(t)?{result:this._visitCounts.get(t),exists:!0}:{result:e,exists:!1}}SetVisitCount(t,e){this._visitCounts.set(t,e)}SetTurnIndex(t,e){this._turnIndices.set(t,e)}TryGetTurnIndex(t,e){return this._turnIndices.has(t)?{result:this._turnIndices.get(t),exists:!0}:{result:e,exists:!1}}}class z{static TextToDictionary(t){return new z.Reader(t).ToDictionary()}static TextToArray(t){return new z.Reader(t).ToArray()}}!function(t){t.Reader=class{constructor(t){this._rootObject=JSON.parse(t)}ToDictionary(){return this._rootObject}ToArray(){return this._rootObject}};class e{constructor(){this._currentPropertyName=null,this._currentString=null,this._stateStack=[],this._collectionStack=[],this._propertyNameStack=[],this._jsonObject=null}WriteObject(t){this.WriteObjectStart(),t(this),this.WriteObjectEnd()}WriteObjectStart(){this.StartNewObject(!0);let e={};if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Object))}WriteObjectEnd(){this.Assert(this.state===t.Writer.State.Object),this._collectionStack.pop(),this._stateStack.pop()}WriteProperty(t,e){if(this.WritePropertyStart(t),arguments[1]instanceof Function){(0,arguments[1])(this)}else{let t=arguments[1];this.Write(t)}this.WritePropertyEnd()}WriteIntProperty(t,e){this.WritePropertyStart(t),this.WriteInt(e),this.WritePropertyEnd()}WriteFloatProperty(t,e){this.WritePropertyStart(t),this.WriteFloat(e),this.WritePropertyEnd()}WritePropertyStart(e){this.Assert(this.state===t.Writer.State.Object),this._propertyNameStack.push(e),this.IncrementChildCount(),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property))}WritePropertyEnd(){this.Assert(this.state===t.Writer.State.Property),this.Assert(1===this.childCount),this._stateStack.pop()}WritePropertyNameStart(){this.Assert(this.state===t.Writer.State.Object),this.IncrementChildCount(),this._currentPropertyName="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property)),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.PropertyName))}WritePropertyNameEnd(){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._propertyNameStack.push(this._currentPropertyName),this._currentPropertyName=null,this._stateStack.pop()}WritePropertyNameInner(e){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._currentPropertyName+=e}WriteArrayStart(){this.StartNewObject(!0);let e=[];if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Array))}WriteArrayEnd(){this.Assert(this.state===t.Writer.State.Array),this._collectionStack.pop(),this._stateStack.pop()}Write(t,e=!0){null!==t?(this.StartNewObject(!1),this._addToCurrentObject(t)):console.error("Warning: trying to write a null string")}WriteInt(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(Math.floor(t)))}WriteFloat(t){null!==t&&(this.StartNewObject(!1),t==Number.POSITIVE_INFINITY?this._addToCurrentObject(34e37):t==Number.NEGATIVE_INFINITY?this._addToCurrentObject(-34e37):isNaN(t)?this._addToCurrentObject(0):this._addToCurrentObject(t))}WriteNull(){this.StartNewObject(!1),this._addToCurrentObject(null)}WriteStringStart(){this.StartNewObject(!1),this._currentString="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.String))}WriteStringEnd(){this.Assert(this.state==t.Writer.State.String),this._stateStack.pop(),this._addToCurrentObject(this._currentString),this._currentString=null}WriteStringInner(e,n=!0){this.Assert(this.state===t.Writer.State.String),null!==e?this._currentString+=e:console.error("Warning: trying to write a null string")}ToString(){return null===this._jsonObject?"":JSON.stringify(this._jsonObject)}StartNewObject(e){e?this.Assert(this.state===t.Writer.State.None||this.state===t.Writer.State.Property||this.state===t.Writer.State.Array):this.Assert(this.state===t.Writer.State.Property||this.state===t.Writer.State.Array),this.state===t.Writer.State.Property&&this.Assert(0===this.childCount),this.state!==t.Writer.State.Array&&this.state!==t.Writer.State.Property||this.IncrementChildCount()}get state(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].type:t.Writer.State.None}get childCount(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].childCount:0}get currentCollection(){return this._collectionStack.length>0?this._collectionStack[this._collectionStack.length-1]:null}get currentPropertyName(){return this._propertyNameStack.length>0?this._propertyNameStack[this._propertyNameStack.length-1]:null}IncrementChildCount(){this.Assert(this._stateStack.length>0);let t=this._stateStack.pop();t.childCount++,this._stateStack.push(t)}Assert(t){if(!t)throw Error("Assert failed while writing JSON")}_addToCurrentObject(e){this.Assert(null!==this.currentCollection),this.state===t.Writer.State.Array?(this.Assert(Array.isArray(this.currentCollection)),this.currentCollection.push(e)):this.state===t.Writer.State.Property&&(this.Assert(!Array.isArray(this.currentCollection)),this.Assert(null!==this.currentPropertyName),this.currentCollection[this.currentPropertyName]=e,this._propertyNameStack.pop())}}t.Writer=e,function(e){let n;!function(t){t[t.None=0]="None",t[t.Object=1]="Object",t[t.Array=2]="Array",t[t.Property=3]="Property",t[t.PropertyName=4]="PropertyName",t[t.String=5]="String"}(n=e.State||(e.State={}));e.StateElement=class{constructor(e){this.type=t.Writer.State.None,this.childCount=0,this.type=e}}}(e=t.Writer||(t.Writer={}))}(z||(z={}));class H{constructor(t){this.kInkSaveStateVersion=8,this.kMinCompatibleLoadVersion=8,this._currentErrors=null,this._currentWarnings=null,this.divertedPointer=I.Null,this._currentTurnIndex=0,this.storySeed=0,this.previousRandom=0,this.didSafeExit=!1,this._currentText=null,this._currentTags=null,this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0,this._patch=null,this.story=t,this._outputStream=[],this.OutputStreamDirty(),this._evaluationStack=[],this.callStack=new q(t),this._variablesState=new J(this.callStack,t.listDefinitions),this._visitCounts=new Map,this._turnIndices=new Map,this.currentTurnIndex=-1;let e=(new Date).getTime();this.storySeed=new K(e).next()%100,this.previousRandom=0,this._currentChoices=[],this.GoToStart()}ToJson(t=!1){let e=new z.Writer;return this.WriteJson(e),e.ToString()}toJson(t=!1){return this.ToJson(t)}LoadJson(t){let e=z.TextToDictionary(t);this.LoadJsonObj(e)}VisitCountAtPathString(t){let n;if(null!==this._patch){let i=this.story.ContentAtPath(new e(t)).container;if(null===i)throw new Error("Content at path not found: "+t);if(n=this._patch.TryGetVisitCount(i,0),n.exists)return n.result}return n=y(this._visitCounts,t,null),n.exists?n.result:0}VisitCountForContainer(t){if(null===t)return d("container");if(!t.visitsShouldBeCounted)return this.story.Error("Read count for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),0;if(null!==this._patch){let e=this._patch.TryGetVisitCount(t,0);if(e.exists)return e.result}let e=t.path.toString(),n=y(this._visitCounts,e,null);return n.exists?n.result:0}IncrementVisitCountForContainer(t){if(null!==this._patch){let e=this.VisitCountForContainer(t);return e++,void this._patch.SetVisitCount(t,e)}let e=t.path.toString(),n=y(this._visitCounts,e,null);n.exists?this._visitCounts.set(e,n.result+1):this._visitCounts.set(e,1)}RecordTurnIndexVisitToContainer(t){if(null!==this._patch)return void this._patch.SetTurnIndex(t,this.currentTurnIndex);let e=t.path.toString();this._turnIndices.set(e,this.currentTurnIndex)}TurnsSinceForContainer(t){if(t.turnIndexShouldBeCounted||this.story.Error("TURNS_SINCE() for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),null!==this._patch){let e=this._patch.TryGetTurnIndex(t,0);if(e.exists)return this.currentTurnIndex-e.result}let e=t.path.toString(),n=y(this._turnIndices,e,0);return n.exists?this.currentTurnIndex-n.result:-1}get callstackDepth(){return this.callStack.depth}get outputStream(){return this._outputStream}get currentChoices(){return this.canContinue?[]:this._currentChoices}get generatedChoices(){return this._currentChoices}get currentErrors(){return this._currentErrors}get currentWarnings(){return this._currentWarnings}get variablesState(){return this._variablesState}set variablesState(t){this._variablesState=t}get evaluationStack(){return this._evaluationStack}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}get currentTurnIndex(){return this._currentTurnIndex}set currentTurnIndex(t){this._currentTurnIndex=t}get currentPathString(){let t=this.currentPointer;return t.isNull?null:null===t.path?d("pointer.path"):t.path.toString()}get currentPointer(){return this.callStack.currentElement.currentPointer.copy()}set currentPointer(t){this.callStack.currentElement.currentPointer=t.copy()}get previousPointer(){return this.callStack.currentThread.previousPointer.copy()}set previousPointer(t){this.callStack.currentThread.previousPointer=t.copy()}get canContinue(){return!this.currentPointer.isNull&&!this.hasError}get hasError(){return null!=this.currentErrors&&this.currentErrors.length>0}get hasWarning(){return null!=this.currentWarnings&&this.currentWarnings.length>0}get currentText(){if(this._outputStreamTextDirty){let t=new m;for(let e of this._outputStream){let n=a(e,T);null!==n&&t.Append(n.value)}this._currentText=this.CleanOutputWhitespace(t.toString()),this._outputStreamTextDirty=!1}return this._currentText}CleanOutputWhitespace(t){let e=new m,n=-1,i=0;for(let r=0;r<t.length;r++){let a=t.charAt(r),s=" "==a||"\t"==a;s&&-1==n&&(n=r),s||("\n"!=a&&n>0&&n!=i&&e.Append(" "),n=-1),"\n"==a&&(i=r+1),s||e.Append(a)}return e.toString()}get currentTags(){if(this._outputStreamTagsDirty){this._currentTags=[];for(let t of this._outputStream){let e=a(t,j);null!==e&&this._currentTags.push(e.text)}this._outputStreamTagsDirty=!1}return this._currentTags}get inExpressionEvaluation(){return this.callStack.currentElement.inExpressionEvaluation}set inExpressionEvaluation(t){this.callStack.currentElement.inExpressionEvaluation=t}GoToStart(){this.callStack.currentElement.currentPointer=I.StartOf(this.story.mainContentContainer)}CopyAndStartPatching(){let t=new H(this.story);return t._patch=new U(this._patch),t.outputStream.push.apply(t.outputStream,this._outputStream),t.OutputStreamDirty(),t._currentChoices.push.apply(t._currentChoices,this._currentChoices),this.hasError&&(t._currentErrors=[],t._currentErrors.push.apply(t._currentErrors,this.currentErrors||[])),this.hasWarning&&(t._currentWarnings=[],t._currentWarnings.push.apply(t._currentWarnings,this.currentWarnings||[])),t.callStack=new q(this.callStack),t.variablesState=this.variablesState,t.variablesState.callStack=t.callStack,t.variablesState.patch=t._patch,t.evaluationStack.push.apply(t.evaluationStack,this.evaluationStack),this.divertedPointer.isNull||(t.divertedPointer=this.divertedPointer.copy()),t.previousPointer=this.previousPointer.copy(),t._visitCounts=this._visitCounts,t._turnIndices=this._turnIndices,t.currentTurnIndex=this.currentTurnIndex,t.storySeed=this.storySeed,t.previousRandom=this.previousRandom,t.didSafeExit=this.didSafeExit,t}RestoreAfterPatch(){this.variablesState.callStack=this.callStack,this.variablesState.patch=this._patch}ApplyAnyPatch(){if(null!==this._patch){this.variablesState.ApplyPatch();for(let[t,e]of this._patch.visitCounts)this.ApplyCountChanges(t,e,!0);for(let[t,e]of this._patch.turnIndices)this.ApplyCountChanges(t,e,!1);this._patch=null}}ApplyCountChanges(t,e,n){(n?this._visitCounts:this._turnIndices).set(t.path.toString(),e)}WriteJson(t){t.WriteObjectStart();let e=!1;for(let n of this._currentChoices){if(null===n.threadAtGeneration)return d("c.threadAtGeneration");n.originalThreadIndex=n.threadAtGeneration.threadIndex,null===this.callStack.ThreadWithIndex(n.originalThreadIndex)&&(e||(e=!0,t.WritePropertyStart("choiceThreads"),t.WriteObjectStart()),t.WritePropertyStart(n.originalThreadIndex),n.threadAtGeneration.WriteJson(t),t.WritePropertyEnd())}if(e&&(t.WriteObjectEnd(),t.WritePropertyEnd()),t.WriteProperty("callstackThreads",t=>this.callStack.WriteJson(t)),t.WriteProperty("variablesState",t=>this.variablesState.WriteJson(t)),t.WriteProperty("evalStack",t=>M.WriteListRuntimeObjs(t,this.evaluationStack)),t.WriteProperty("outputStream",t=>M.WriteListRuntimeObjs(t,this._outputStream)),t.WriteProperty("currentChoices",t=>{t.WriteArrayStart();for(let e of this._currentChoices)M.WriteChoice(t,e);t.WriteArrayEnd()}),!this.divertedPointer.isNull){if(null===this.divertedPointer.path)return d("divertedPointer");t.WriteProperty("currentDivertTarget",this.divertedPointer.path.componentsString)}t.WriteProperty("visitCounts",t=>M.WriteIntDictionary(t,this._visitCounts)),t.WriteProperty("turnIndices",t=>M.WriteIntDictionary(t,this._turnIndices)),t.WriteIntProperty("turnIdx",this.currentTurnIndex),t.WriteIntProperty("storySeed",this.storySeed),t.WriteIntProperty("previousRandom",this.previousRandom),t.WriteIntProperty("inkSaveVersion",this.kInkSaveStateVersion),t.WriteIntProperty("inkFormatVersion",X.inkVersionCurrent),t.WriteObjectEnd()}LoadJsonObj(t){let n=t,i=n.inkSaveVersion;if(null==i)throw new S("ink save format incorrect, can't load.");if(parseInt(i)<this.kMinCompatibleLoadVersion)throw new S("Ink save format isn't compatible with the current version (saw '"+i+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.");this.callStack.SetJsonToken(n.callstackThreads,this.story),this.variablesState.SetJsonToken(n.variablesState),this._evaluationStack=M.JArrayToRuntimeObjList(n.evalStack),this._outputStream=M.JArrayToRuntimeObjList(n.outputStream),this.OutputStreamDirty(),this._currentChoices=M.JArrayToRuntimeObjList(n.currentChoices);let r=n.currentDivertTarget;if(null!=r){let t=new e(r.toString());this.divertedPointer=this.story.PointerAtPath(t)}this._visitCounts=M.JObjectToIntDictionary(n.visitCounts),this._turnIndices=M.JObjectToIntDictionary(n.turnIndices),this.currentTurnIndex=parseInt(n.turnIdx),this.storySeed=parseInt(n.storySeed),this.previousRandom=parseInt(n.previousRandom);let a=n.choiceThreads;for(let t of this._currentChoices){let e=this.callStack.ThreadWithIndex(t.originalThreadIndex);if(null!=e)t.threadAtGeneration=e.Copy();else{let e=a[t.originalThreadIndex.toString()];t.threadAtGeneration=new q.Thread(e,this.story)}}}ResetErrors(){this._currentErrors=null,this._currentWarnings=null}ResetOutput(t=null){this._outputStream.length=0,null!==t&&this._outputStream.push.apply(this._outputStream,t),this.OutputStreamDirty()}PushToOutputStream(t){let e=a(t,T);if(null!==e){let t=this.TrySplittingHeadTailWhitespace(e);if(null!==t){for(let e of t)this.PushToOutputStreamIndividual(e);return void this.OutputStreamDirty()}}this.PushToOutputStreamIndividual(t),this.OutputStreamDirty()}PopFromOutputStream(t){this.outputStream.splice(this.outputStream.length-t,t),this.OutputStreamDirty()}TrySplittingHeadTailWhitespace(t){let e=t.value;if(null===e)return d("single.value");let n=-1,i=-1;for(let t=0;t<e.length;++t){let r=e[t];if("\n"!=r){if(" "==r||"\t"==r)continue;break}-1==n&&(n=t),i=t}let r=-1,a=-1;for(let t=0;t<e.length;++t){let n=e[t];if("\n"!=n){if(" "==n||"\t"==n)continue;break}-1==r&&(r=t),a=t}if(-1==n&&-1==r)return null;let s=[],l=0,o=e.length;if(-1!=n){if(n>0){let t=new T(e.substring(0,n));s.push(t)}s.push(new T("\n")),l=i+1}if(-1!=r&&(o=a),o>l){let t=e.substring(l,o-l);s.push(new T(t))}if(-1!=r&&a>i&&(s.push(new T("\n")),r<e.length-1)){let t=e.length-r-1,n=new T(e.substring(r+1,t));s.push(n)}return s}PushToOutputStreamIndividual(t){let e=a(t,x),n=a(t,T),i=!0;if(e)this.TrimNewlinesFromOutputStream(),i=!0;else if(n){let t=-1,e=this.callStack.currentElement;e.type==r.Function&&(t=e.functionStartInOutputStream);let a=-1;for(let e=this._outputStream.length-1;e>=0;e--){let n=this._outputStream[e],i=n instanceof A?n:null;if(null!=(n instanceof x?n:null)){a=e;break}if(null!=i&&i.commandType==A.CommandType.BeginString){e>=t&&(t=-1);break}}let s=-1;if(s=-1!=a&&-1!=t?Math.min(t,a):-1!=a?a:t,-1!=s){if(n.isNewline)i=!1;else if(n.isNonWhitespace&&(a>-1&&this.RemoveExistingGlue(),t>-1)){let t=this.callStack.elements;for(let e=t.length-1;e>=0;e--){let n=t[e];if(n.type!=r.Function)break;n.functionStartInOutputStream=-1}}}else n.isNewline&&(!this.outputStreamEndsInNewline&&this.outputStreamContainsContent||(i=!1))}if(i){if(null===t)return d("obj");this._outputStream.push(t),this.OutputStreamDirty()}}TrimNewlinesFromOutputStream(){let t=-1,e=this._outputStream.length-1;for(;e>=0;){let n=this._outputStream[e],i=a(n,A),r=a(n,T);if(null!=i||null!=r&&r.isNonWhitespace)break;null!=r&&r.isNewline&&(t=e),e--}if(t>=0)for(e=t;e<this._outputStream.length;){a(this._outputStream[e],T)?this._outputStream.splice(e,1):e++}this.OutputStreamDirty()}RemoveExistingGlue(){for(let t=this._outputStream.length-1;t>=0;t--){let e=this._outputStream[t];if(e instanceof x)this._outputStream.splice(t,1);else if(e instanceof A)break}this.OutputStreamDirty()}get outputStreamEndsInNewline(){if(this._outputStream.length>0)for(let t=this._outputStream.length-1;t>=0;t--){if(this._outputStream[t]instanceof A)break;let e=this._outputStream[t];if(e instanceof T){if(e.isNewline)return!0;if(e.isNonWhitespace)break}}return!1}get outputStreamContainsContent(){for(let t=0;t<this._outputStream.length;t++)if(this._outputStream[t]instanceof T)return!0;return!1}get inStringEvaluation(){for(let t=this._outputStream.length-1;t>=0;t--){let e=a(this._outputStream[t],A);if(e instanceof A&&e.commandType==A.CommandType.BeginString)return!0}return!1}PushEvaluationStack(t){let e=a(t,O);if(e){let t=e.value;if(null===t)return d("rawList");if(null!=t.originNames){t.origins||(t.origins=[]),t.origins.length=0;for(let e of t.originNames){if(null===this.story.listDefinitions)return d("StoryState.story.listDefinitions");let n=this.story.listDefinitions.TryListGetDefinition(e,null);if(null===n.result)return d("StoryState def.result");t.origins.indexOf(n.result)<0&&t.origins.push(n.result)}}}if(null===t)return d("obj");this.evaluationStack.push(t)}PopEvaluationStack(t){if(void 0===t){return o(this.evaluationStack.pop())}if(t>this.evaluationStack.length)throw new Error("trying to pop too many objects");return o(this.evaluationStack.splice(this.evaluationStack.length-t,t))}PeekEvaluationStack(){return this.evaluationStack[this.evaluationStack.length-1]}ForceEnd(){this.callStack.Reset(),this._currentChoices.length=0,this.currentPointer=I.Null,this.previousPointer=I.Null,this.didSafeExit=!0}TrimWhitespaceFromFunctionEnd(){n.Assert(this.callStack.currentElement.type==r.Function);let t=this.callStack.currentElement.functionStartInOutputStream;-1==t&&(t=0);for(let e=this._outputStream.length-1;e>=t;e--){let t=this._outputStream[e],n=a(t,T),i=a(t,A);if(null!=n){if(i)break;if(!n.isNewline&&!n.isInlineWhitespace)break;this._outputStream.splice(e,1),this.OutputStreamDirty()}}}PopCallStack(t=null){this.callStack.currentElement.type==r.Function&&this.TrimWhitespaceFromFunctionEnd(),this.callStack.Pop(t)}SetChosenPath(t,e){this._currentChoices.length=0;let n=this.story.PointerAtPath(t);n.isNull||-1!=n.index||(n.index=0),this.currentPointer=n,e&&this.currentTurnIndex++}StartFunctionEvaluationFromGame(t,e){this.callStack.Push(r.FunctionEvaluationFromGame,this.evaluationStack.length),this.callStack.currentElement.currentPointer=I.StartOf(t),this.PassArgumentsToEvaluationStack(e)}PassArgumentsToEvaluationStack(t){if(null!=t)for(let e=0;e<t.length;e++){if("number"!=typeof t[e]&&"string"!=typeof t[e])throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");this.PushEvaluationStack(v.Create(t[e]))}}TryExitFunctionEvaluationFromGame(){return this.callStack.currentElement.type==r.FunctionEvaluationFromGame&&(this.currentPointer=I.Null,this.didSafeExit=!0,!0)}CompleteFunctionEvaluationFromGame(){if(this.callStack.currentElement.type!=r.FunctionEvaluationFromGame)throw new S("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace);let t=this.callStack.currentElement.evaluationStackHeightWhenPushed,e=null;for(;this.evaluationStack.length>t;){let t=this.PopEvaluationStack();null===e&&(e=t)}if(this.PopCallStack(r.FunctionEvaluationFromGame),e){if(e instanceof L)return null;let t=s(e,v);return t.valueType==i.DivertTarget?t.valueObject.toString():t.valueObject}return null}AddError(t,e){e?(null==this._currentWarnings&&(this._currentWarnings=[]),this._currentWarnings.push(t)):(null==this._currentErrors&&(this._currentErrors=[]),this._currentErrors.push(t))}OutputStreamDirty(){this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0}}class ${constructor(){this.startTime=void 0}get ElapsedMilliseconds(){return void 0===this.startTime?0:(new Date).getTime()-this.startTime}Start(){this.startTime=(new Date).getTime()}Stop(){this.startTime=void 0}}Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&t>-9007199254740992&&t<9007199254740992&&Math.floor(t)===t});class X extends p{constructor(){let t;super(),this.inkVersionMinimumCompatible=18,this._prevContainers=[],this.allowExternalFunctionFallbacks=!1,this._listDefinitions=null,this._variableObservers=null,this._hasValidatedExternals=!1,this._temporaryEvaluationContainer=null,this._asyncContinueActive=!1,this._stateSnapshotAtLastNewline=null,this._recursiveContinueCount=0,this._asyncSaving=!1,this._profiler=null;let e=null,n=null;if(arguments[0]instanceof N)t=arguments[0],void 0!==arguments[1]&&(e=arguments[1]),this._mainContentContainer=t;else if("string"==typeof arguments[0]){let t=arguments[0];n=z.TextToDictionary(t)}else n=arguments[0];if(null!=e&&(this._listDefinitions=new B(e)),this._externals=new Map,null!==n){let t=n,e=t.inkVersion;if(null==e)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");let i=parseInt(e);if(i>X.inkVersionCurrent)throw new Error("Version of ink used to build story was newer than the current version of the engine");if(i<this.inkVersionMinimumCompatible)throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");i!=X.inkVersionCurrent&&console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");let r,a=t.root;if(null==a)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");(r=t.listDefs)&&(this._listDefinitions=M.JTokenToListDefinitions(r)),this._mainContentContainer=s(M.JTokenToRuntimeObject(a),N),this.ResetState()}}get currentChoices(){let t=[];if(null===this._state)return d("this._state");for(let e of this._state.currentChoices)e.isInvisibleDefault||(e.index=t.length,t.push(e));return t}get currentText(){return this.IfAsyncWeCant("call currentText since it's a work in progress"),this.state.currentText}get currentTags(){return this.IfAsyncWeCant("call currentTags since it's a work in progress"),this.state.currentTags}get currentErrors(){return this.state.currentErrors}get currentWarnings(){return this.state.currentWarnings}get hasError(){return this.state.hasError}get hasWarning(){return this.state.hasWarning}get variablesState(){return this.state.variablesState}get listDefinitions(){return this._listDefinitions}get state(){return this._state}StartProfiling(){}EndProfiling(){}ToJson(t){let e=!1;if(t||(e=!0,t=new z.Writer),t.WriteObjectStart(),t.WriteIntProperty("inkVersion",X.inkVersionCurrent),t.WriteProperty("root",t=>M.WriteRuntimeContainer(t,this._mainContentContainer)),null!=this._listDefinitions){t.WritePropertyStart("listDefs"),t.WriteObjectStart();for(let e of this._listDefinitions.lists){t.WritePropertyStart(e.name),t.WriteObjectStart();for(let[n,i]of e.items){let e=f.fromSerializedKey(n),r=i;t.WriteIntProperty(e.itemName,r)}t.WriteObjectEnd(),t.WritePropertyEnd()}t.WriteObjectEnd(),t.WritePropertyEnd()}if(t.WriteObjectEnd(),e)return t.ToString()}ResetState(){this.IfAsyncWeCant("ResetState"),this._state=new H(this),this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this)),this.ResetGlobals()}ResetErrors(){if(null===this._state)return d("this._state");this._state.ResetErrors()}ResetCallstack(){if(this.IfAsyncWeCant("ResetCallstack"),null===this._state)return d("this._state");this._state.ForceEnd()}ResetGlobals(){if(this._mainContentContainer.namedContent.get("global decl")){let t=this.state.currentPointer.copy();this.ChoosePath(new e("global decl"),!1),this.ContinueInternal(),this.state.currentPointer=t}this.state.variablesState.SnapshotDefaultGlobals()}Continue(){return this.ContinueAsync(0),this.currentText}get canContinue(){return this.state.canContinue}get asyncContinueComplete(){return!this._asyncContinueActive}ContinueAsync(t){this._hasValidatedExternals||this.ValidateExternalBindings(),this.ContinueInternal(t)}ContinueInternal(t=0){null!=this._profiler&&this._profiler.PreContinue();let e=t>0;if(this._recursiveContinueCount++,!this._asyncContinueActive){if(this._asyncContinueActive=e,!this.canContinue)throw new S("Can't continue - should check canContinue before calling Continue");this._state.didSafeExit=!1,this._state.ResetOutput(),1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!0)}let n=new $;n.Start();let i=!1;do{try{i=this.ContinueSingleStep()}catch(t){if(!(t instanceof S))throw t;this.AddError(t.message,void 0,t.useEndLineNumber);break}if(i)break;if(this._asyncContinueActive&&n.ElapsedMilliseconds>t)break}while(this.canContinue);n.Stop(),!i&&this.canContinue||(null!==this._stateSnapshotAtLastNewline&&this.RestoreStateSnapshot(),this.canContinue||(this.state.callStack.canPopThread&&this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?"),0!=this.state.generatedChoices.length||this.state.didSafeExit||null!=this._temporaryEvaluationContainer||(this.state.callStack.CanPop(r.Tunnel)?this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?"):this.state.callStack.CanPop(r.Function)?this.AddError("unexpectedly reached end of content. Do you need a '~ return'?"):this.state.callStack.canPop?this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!"):this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?"))),this.state.didSafeExit=!1,1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!1),this._asyncContinueActive=!1),this._recursiveContinueCount--,null!=this._profiler&&this._profiler.PostContinue()}ContinueSingleStep(){if(null!=this._profiler&&this._profiler.PreStep(),this.Step(),null!=this._profiler&&this._profiler.PostStep(),this.canContinue||this.state.callStack.elementIsEvaluateFromGame||this.TryFollowDefaultInvisibleChoice(),null!=this._profiler&&this._profiler.PreSnapshot(),!this.state.inStringEvaluation){if(null!==this._stateSnapshotAtLastNewline){if(null===this._stateSnapshotAtLastNewline.currentTags)return d("this._stateAtLastNewline.currentTags");if(null===this.state.currentTags)return d("this.state.currentTags");let t=this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText,this.state.currentText,this._stateSnapshotAtLastNewline.currentTags.length,this.state.currentTags.length);if(t==X.OutputStateChange.ExtendedBeyondNewline)return this.RestoreStateSnapshot(),!0;t==X.OutputStateChange.NewlineRemoved&&this.DiscardSnapshot()}this.state.outputStreamEndsInNewline&&(this.canContinue?null==this._stateSnapshotAtLastNewline&&this.StateSnapshot():this.DiscardSnapshot())}return null!=this._profiler&&this._profiler.PostSnapshot(),!1}CalculateNewlineOutputStateChange(t,e,n,i){if(null===t)return d("prevText");if(null===e)return d("currText");let r=e.length>=t.length&&"\n"==e.charAt(t.length-1);if(n==i&&t.length==e.length&&r)return X.OutputStateChange.NoChange;if(!r)return X.OutputStateChange.NewlineRemoved;if(i>n)return X.OutputStateChange.ExtendedBeyondNewline;for(let n=t.length;n<e.length;n++){let t=e.charAt(n);if(" "!=t&&"\t"!=t)return X.OutputStateChange.ExtendedBeyondNewline}return X.OutputStateChange.NoChange}ContinueMaximally(){this.IfAsyncWeCant("ContinueMaximally");let t=new m;for(;this.canContinue;)t.Append(this.Continue());return t.toString()}ContentAtPath(t){return this.mainContentContainer.ContentAtPath(t)}KnotContainerWithName(t){let e=this.mainContentContainer.namedContent.get(t);return e instanceof N?e:null}PointerAtPath(t){if(0==t.length)return I.Null;let e=new I,n=t.length,i=null;return null===t.lastComponent?d("path.lastComponent"):(t.lastComponent.isIndex?(n=t.length-1,i=this.mainContentContainer.ContentAtPath(t,void 0,n),e.container=i.container,e.index=t.lastComponent.index):(i=this.mainContentContainer.ContentAtPath(t),e.container=i.container,e.index=-1),null==i.obj||i.obj==this.mainContentContainer&&n>0?this.Error("Failed to find content at path '"+t+"', and no approximation of it was possible."):i.approximate&&this.Warning("Failed to find content at path '"+t+"', so it was approximated to: '"+i.obj.path+"'."),e)}StateSnapshot(){this._stateSnapshotAtLastNewline=this._state,this._state=this._state.CopyAndStartPatching()}RestoreStateSnapshot(){null===this._stateSnapshotAtLastNewline&&d("_stateSnapshotAtLastNewline"),this._stateSnapshotAtLastNewline.RestoreAfterPatch(),this._state=this._stateSnapshotAtLastNewline,this._stateSnapshotAtLastNewline=null,this._asyncSaving||this._state.ApplyAnyPatch()}DiscardSnapshot(){this._asyncSaving||this._state.ApplyAnyPatch(),this._stateSnapshotAtLastNewline=null}CopyStateForBackgroundThreadSave(){if(this.IfAsyncWeCant("start saving on a background thread"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");let t=this._state;return this._state=this._state.CopyAndStartPatching(),this._asyncSaving=!0,t}BackgroundSaveComplete(){null===this._stateSnapshotAtLastNewline&&this._state.ApplyAnyPatch(),this._asyncSaving=!1}Step(){let t=!0,e=this.state.currentPointer.copy();if(e.isNull)return;let n=a(e.Resolve(),N);for(;n&&(this.VisitContainer(n,!0),0!=n.content.length);)e=I.StartOf(n),n=a(e.Resolve(),N);this.state.currentPointer=e.copy(),null!=this._profiler&&this._profiler.Step(this.state.callStack);let i=e.Resolve(),r=this.PerformLogicAndFlowControl(i);if(this.state.currentPointer.isNull)return;r&&(t=!1);let s=a(i,W);if(s){let e=this.ProcessChoice(s);e&&this.state.generatedChoices.push(e),i=null,t=!1}if(i instanceof N&&(t=!1),t){let t=a(i,w);if(t&&-1==t.contextIndex){let e=this.state.callStack.ContextForVariableNamed(t.variableName);i=new w(t.variableName,e)}this.state.inExpressionEvaluation?this.state.PushEvaluationStack(i):this.state.PushToOutputStream(i)}this.NextContent();let l=a(i,A);l&&l.commandType==A.CommandType.StartThread&&this.state.callStack.PushThread()}VisitContainer(t,e){t.countingAtStartOnly&&!e||(t.visitsShouldBeCounted&&this.state.IncrementVisitCountForContainer(t),t.turnIndexShouldBeCounted&&this.state.RecordTurnIndexVisitToContainer(t))}VisitChangedContainersDueToDivert(){let t=this.state.previousPointer.copy(),e=this.state.currentPointer.copy();if(e.isNull||-1==e.index)return;if(this._prevContainers.length=0,!t.isNull){let e=a(t.Resolve(),N)||a(t.container,N);for(;e;)this._prevContainers.push(e),e=a(e.parent,N)}let n=e.Resolve();if(null==n)return;let i=a(n.parent,N);for(;i&&(this._prevContainers.indexOf(i)<0||i.countingAtStartOnly);){let t=i.content.length>0&&n==i.content[0];this.VisitContainer(i,t),n=i,i=a(i.parent,N)}}ProcessChoice(t){let e=!0;if(t.hasCondition){let t=this.state.PopEvaluationStack();this.IsTruthy(t)||(e=!1)}let n="",i="";if(t.hasChoiceOnlyContent){i=s(this.state.PopEvaluationStack(),T).value||""}if(t.hasStartContent){n=s(this.state.PopEvaluationStack(),T).value||""}if(t.onceOnly){this.state.VisitCountForContainer(t.choiceTarget)>0&&(e=!1)}if(!e)return null;let r=new D;return r.targetPath=t.pathOnChoice,r.sourcePath=t.path.toString(),r.isInvisibleDefault=t.isInvisibleDefault,r.threadAtGeneration=this.state.callStack.ForkThread(),r.text=(n+i).replace(/^[ \t]+|[ \t]+$/g,""),r}IsTruthy(t){if(t instanceof v){let e=t;if(e instanceof P){let t=e;return this.Error("Shouldn't use a divert target (to "+t.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)"),!1}return e.isTruthy}return!1}PerformLogicAndFlowControl(t){if(null==t)return!1;if(t instanceof k){let e=t;if(e.isConditional){let t=this.state.PopEvaluationStack();if(!this.IsTruthy(t))return!0}if(e.hasVariableTarget){let t=e.variableDivertName,n=this.state.variablesState.GetVariableWithName(t);if(null==n)this.Error("Tried to divert using a target from a variable that could not be found ("+t+")");else if(!(n instanceof P)){let e=a(n,b),i="Tried to divert to a target from a variable, but the variable ("+t+") didn't contain a divert target, it ";e instanceof b&&0==e.value?i+="was empty/null (the value 0).":i+="contained '"+n+"'.",this.Error(i)}let i=s(n,P);this.state.divertedPointer=this.PointerAtPath(i.targetPath)}else{if(e.isExternal)return this.CallExternalFunction(e.targetPathString,e.externalArgs),!0;this.state.divertedPointer=e.targetPointer.copy()}return e.pushesToStack&&this.state.callStack.Push(e.stackPushType,void 0,this.state.outputStream.length),this.state.divertedPointer.isNull&&!e.isExternal&&(e&&e.debugMetadata&&null!=e.debugMetadata.sourceName?this.Error("Divert target doesn't exist: "+e.debugMetadata.sourceName):this.Error("Divert resolution failed: "+e)),!0}if(t instanceof A){let e=t;switch(e.commandType){case A.CommandType.EvalStart:this.Assert(!1===this.state.inExpressionEvaluation,"Already in expression evaluation?"),this.state.inExpressionEvaluation=!0;break;case A.CommandType.EvalEnd:this.Assert(!0===this.state.inExpressionEvaluation,"Not in expression evaluation mode"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EvalOutput:if(this.state.evaluationStack.length>0){let t=this.state.PopEvaluationStack();if(!(t instanceof L)){let e=new T(t.toString());this.state.PushToOutputStream(e)}}break;case A.CommandType.NoOp:break;case A.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case A.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case A.CommandType.PopFunction:case A.CommandType.PopTunnel:let t=e.commandType==A.CommandType.PopFunction?r.Function:r.Tunnel,n=null;if(t==r.Tunnel){let t=this.state.PopEvaluationStack();n=a(t,P),null===n&&this.Assert(t instanceof L,"Expected void if ->-> doesn't override target")}if(this.state.TryExitFunctionEvaluationFromGame())break;if(this.state.callStack.currentElement.type==t&&this.state.callStack.canPop)this.state.PopCallStack(),n&&(this.state.divertedPointer=this.PointerAtPath(n.targetPath));else{let e=new Map;e.set(r.Function,"function return statement (~ return)"),e.set(r.Tunnel,"tunnel onwards statement (->->)");let n=e.get(this.state.callStack.currentElement.type);this.state.callStack.canPop||(n="end of flow (-> END or choice)");let i="Found "+e.get(t)+", when expected "+n;this.Error(i)}break;case A.CommandType.BeginString:this.state.PushToOutputStream(e),this.Assert(!0===this.state.inExpressionEvaluation,"Expected to be in an expression when evaluating a string"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EndString:let i=[],l=0;for(let t=this.state.outputStream.length-1;t>=0;--t){let e=this.state.outputStream[t];l++;let n=a(e,A);if(n&&n.commandType==A.CommandType.BeginString)break;e instanceof T&&i.push(e)}this.state.PopFromOutputStream(l),i=i.reverse();let o=new m;for(let t of i)o.Append(t.toString());this.state.inExpressionEvaluation=!0,this.state.PushEvaluationStack(new T(o.toString()));break;case A.CommandType.ChoiceCount:let u=this.state.generatedChoices.length;this.state.PushEvaluationStack(new b(u));break;case A.CommandType.Turns:this.state.PushEvaluationStack(new b(this.state.currentTurnIndex+1));break;case A.CommandType.TurnsSince:case A.CommandType.ReadCount:let h=this.state.PopEvaluationStack();if(!(h instanceof P)){let t="";h instanceof b&&(t=". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?"),this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+h+t);break}let c,p=s(h,P),y=a(this.ContentAtPath(p.targetPath).correctObj,N);null!=y?c=e.commandType==A.CommandType.TurnsSince?this.state.TurnsSinceForContainer(y):this.state.VisitCountForContainer(y):(c=e.commandType==A.CommandType.TurnsSince?-1:0,this.Warning("Failed to find container for "+e.toString()+" lookup at "+p.targetPath.toString())),this.state.PushEvaluationStack(new b(c));break;case A.CommandType.Random:{let t=a(this.state.PopEvaluationStack(),b),e=a(this.state.PopEvaluationStack(),b);if(null==e||e instanceof b==!1)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(null==t||e instanceof b==!1)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(null===t.value)return d("maxInt.value");if(null===e.value)return d("minInt.value");let n=t.value-e.value+1;n<=0&&this.Error("RANDOM was called with minimum as "+e.value+" and maximum as "+t.value+". The maximum must be larger");let i=this.state.storySeed+this.state.previousRandom,r=new K(i).next(),s=r%n+e.value;this.state.PushEvaluationStack(new b(s)),this.state.previousRandom=r;break}case A.CommandType.SeedRandom:let C=a(this.state.PopEvaluationStack(),b);if(null==C||C instanceof b==!1)return this.Error("Invalid value passed to SEED_RANDOM");if(null===C.value)return d("minInt.value");this.state.storySeed=C.value,this.state.previousRandom=0,this.state.PushEvaluationStack(new L);break;case A.CommandType.VisitIndex:let _=this.state.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new b(_));break;case A.CommandType.SequenceShuffleIndex:let w=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new b(w));break;case A.CommandType.StartThread:break;case A.CommandType.Done:this.state.callStack.canPopThread?this.state.callStack.PopThread():(this.state.didSafeExit=!0,this.state.currentPointer=I.Null);break;case A.CommandType.End:this.state.ForceEnd();break;case A.CommandType.ListFromInt:let E=a(this.state.PopEvaluationStack(),b),x=s(this.state.PopEvaluationStack(),T);if(null===E)throw new S("Passed non-integer when creating a list element from a numerical value.");let k=null;if(null===this.listDefinitions)return d("this.listDefinitions");let W=this.listDefinitions.TryListGetDefinition(x.value,null);if(!W.exists)throw new S("Failed to find LIST called "+x.value);{if(null===E.value)return d("minInt.value");let t=W.result.TryGetItemWithValue(E.value,f.Null);t.exists&&(k=new O(t.result,E.value))}null==k&&(k=new O),this.state.PushEvaluationStack(k);break;case A.CommandType.ListRange:let F=a(this.state.PopEvaluationStack(),v),V=a(this.state.PopEvaluationStack(),v),R=a(this.state.PopEvaluationStack(),O);if(null===R||null===V||null===F)throw new S("Expected list, minimum and maximum for LIST_RANGE");if(null===R.value)return d("targetList.value");let j=R.value.ListWithSubRange(V.valueObject,F.valueObject);this.state.PushEvaluationStack(new O(j));break;case A.CommandType.ListRandom:{let t=this.state.PopEvaluationStack();if(null===t)throw new S("Expected list for LIST_RANDOM");let e=t.value,n=null;if(null===e)throw d("list");if(0==e.Count)n=new g;else{let t=this.state.storySeed+this.state.previousRandom,i=new K(t).next(),r=i%e.Count,a=e.entries();for(let t=0;t<=r-1;t++)a.next();let s=a.next().value,l={Key:f.fromSerializedKey(s[0]),Value:s[1]};if(null===l.Key.originName)return d("randomItem.Key.originName");n=new g(l.Key.originName,this),n.Add(l.Key,l.Value),this.state.previousRandom=i}this.state.PushEvaluationStack(new O(n));break}default:this.Error("unhandled ControlCommand: "+e)}return!0}if(t instanceof V){let e=t,n=this.state.PopEvaluationStack();return this.state.variablesState.Assign(e,n),!0}if(t instanceof F){let e=t,n=null;if(null!=e.pathForCount){let t=e.containerForCount,i=this.state.VisitCountForContainer(t);n=new b(i)}else n=this.state.variablesState.GetVariableWithName(e.name),null==n&&(this.Warning("Variable not found: '"+e.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state."),n=new b(0));return this.state.PushEvaluationStack(n),!0}if(t instanceof R){let e=t,n=this.state.PopEvaluationStack(e.numberOfParameters),i=e.Call(n);return this.state.PushEvaluationStack(i),!0}return!1}ChoosePathString(t,n=!0,i=[]){if(this.IfAsyncWeCant("call ChoosePathString right now"),n)this.ResetCallstack();else if(this.state.callStack.currentElement.type==r.Function){let e="",n=this.state.callStack.currentElement.currentPointer.container;throw null!=n&&(e="("+n.path.toString()+") "),new Error("Story was running a function "+e+"when you called ChoosePathString("+t+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}this.state.PassArgumentsToEvaluationStack(i),this.ChoosePath(new e(t))}IfAsyncWeCant(t){if(this._asyncContinueActive)throw new Error("Can't "+t+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}ChoosePath(t,e=!0){this.state.SetChosenPath(t,e),this.VisitChangedContainersDueToDivert()}ChooseChoiceIndex(t){t=t;let e=this.currentChoices;this.Assert(t>=0&&t<e.length,"choice out of range");let n=e[t];return null===n.threadAtGeneration?d("choiceToChoose.threadAtGeneration"):null===n.targetPath?d("choiceToChoose.targetPath"):(this.state.callStack.currentThread=n.threadAtGeneration,void this.ChoosePath(n.targetPath))}HasFunction(t){try{return null!=this.KnotContainerWithName(t)}catch(t){return!1}}EvaluateFunction(t,e=[],n=!1){if(this.IfAsyncWeCant("evaluate a function"),null==t)throw new Error("Function is null");if(""==t||""==t.trim())throw new Error("Function is empty or white space.");let i=this.KnotContainerWithName(t);if(null==i)throw new Error("Function doesn't exist: '"+t+"'");let r=[];r.push.apply(r,this.state.outputStream),this._state.ResetOutput(),this.state.StartFunctionEvaluationFromGame(i,e);let a=new m;for(;this.canContinue;)a.Append(this.Continue());let s=a.toString();this._state.ResetOutput(r);let l=this.state.CompleteFunctionEvaluationFromGame();return n?{returned:l,output:s}:l}EvaluateExpression(t){let e=this.state.callStack.elements.length;this.state.callStack.Push(r.Tunnel),this._temporaryEvaluationContainer=t,this.state.GoToStart();let n=this.state.evaluationStack.length;return this.Continue(),this._temporaryEvaluationContainer=null,this.state.callStack.elements.length>e&&this.state.PopCallStack(),this.state.evaluationStack.length>n?this.state.PopEvaluationStack():null}CallExternalFunction(t,e){if(null===t)return d("funcName");let n=this._externals.get(t),i=null;if(!(void 0!==n)){if(this.allowExternalFunctionFallbacks)return i=this.KnotContainerWithName(t),this.Assert(null!==i,"Trying to call EXTERNAL function '"+t+"' which has not been bound, and fallback ink function could not be found."),this.state.callStack.Push(r.Function,void 0,this.state.outputStream.length),void(this.state.divertedPointer=I.StartOf(i));this.Assert(!1,"Trying to call EXTERNAL function '"+t+"' which has not been bound (and ink fallbacks disabled).")}let a=[];for(let t=0;t<e;++t){let t=s(this.state.PopEvaluationStack(),v).valueObject;a.push(t)}a.reverse();let l=n(a),o=null;null!=l?(o=v.Create(l),this.Assert(null!==o,"Could not create ink value from returned object of type "+typeof l)):o=new L,this.state.PushEvaluationStack(o)}BindExternalFunctionGeneral(t,e){this.IfAsyncWeCant("bind an external function"),this.Assert(!this._externals.has(t),"Function '"+t+"' has already been bound."),this._externals.set(t,e)}TryCoerce(t){return t}BindExternalFunction(t,e){this.Assert(null!=e,"Can't bind a null function"),this.BindExternalFunctionGeneral(t,t=>{this.Assert(t.length>=e.length,"External function expected "+e.length+" arguments");let n=[];for(let e=0,i=t.length;e<i;e++)n[e]=this.TryCoerce(t[e]);return e.apply(null,n)})}UnbindExternalFunction(t){this.IfAsyncWeCant("unbind an external a function"),this.Assert(this._externals.has(t),"Function '"+t+"' has not been bound."),this._externals.delete(t)}ValidateExternalBindings(){let t=null,e=null,n=arguments[1]||new Set;if(arguments[0]instanceof N&&(t=arguments[0]),arguments[0]instanceof p&&(e=arguments[0]),null===t&&null===e)if(this.ValidateExternalBindings(this._mainContentContainer,n),this._hasValidatedExternals=!0,0==n.size)this._hasValidatedExternals=!0;else{let t="Error: Missing function binding for external";t+=n.size>1?"s":"",t+=": '",t+=Array.from(n).join("', '"),t+="' ",t+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)",this.Error(t)}else if(null!=t){for(let e of t.content){let t=e;null!=t&&t.hasValidName||this.ValidateExternalBindings(e,n)}for(let[,e]of t.namedContent)this.ValidateExternalBindings(a(e,p),n)}else if(null!=e){let t=a(e,k);if(t&&t.isExternal){let e=t.targetPathString;if(null===e)return d("name");if(!this._externals.has(e))if(this.allowExternalFunctionFallbacks){this.mainContentContainer.namedContent.has(e)||n.add(e)}else n.add(e)}}}ObserveVariable(t,e){if(this.IfAsyncWeCant("observe a new variable"),null===this._variableObservers&&(this._variableObservers=new Map),!this.state.variablesState.GlobalVariableExistsWithName(t))throw new S("Cannot observe variable '"+t+"' because it wasn't declared in the ink story.");this._variableObservers.has(t)?this._variableObservers.get(t).push(e):this._variableObservers.set(t,[e])}ObserveVariables(t,e){for(let n=0,i=t.length;n<i;n++)this.ObserveVariable(t[n],e[n])}RemoveVariableObserver(t,e){if(this.IfAsyncWeCant("remove a variable observer"),null!==this._variableObservers)if(void 0!==e){if(this._variableObservers.has(e)){let n=this._variableObservers.get(e);null!==t?n.splice(n.indexOf(t),1):this._variableObservers.delete(e)}}else if(null!==t){let e=this._variableObservers.keys();for(let n of e){let e=this._variableObservers.get(n);e.splice(e.indexOf(t),1)}}}VariableStateDidChangeEvent(t,e){if(null===this._variableObservers)return;let n=this._variableObservers.get(t);if(void 0!==n){if(!(e instanceof v))throw new Error("Tried to get the value of a variable that isn't a standard type");let i=s(e,v);for(let e of n)e(t,i.valueObject)}}get globalTags(){return this.TagsAtStartOfFlowContainerWithPathString("")}TagsForContentAtPath(t){return this.TagsAtStartOfFlowContainerWithPathString(t)}TagsAtStartOfFlowContainerWithPathString(t){let n=new e(t),i=this.ContentAtPath(n).container;if(null===i)return d("flowContainer");for(;;){let t=i.content[0];if(!(t instanceof N))break;i=t}let r=null;for(let t of i.content){let e=a(t,j);if(!e)break;null==r&&(r=[]),r.push(e.text)}return r}BuildStringOfHierarchy(){let t=new m;return this.mainContentContainer.BuildStringOfHierarchy(t,0,this.state.currentPointer.Resolve()),t.toString()}BuildStringOfContainer(t){let e=new m;return t.BuildStringOfHierarchy(e,0,this.state.currentPointer.Resolve()),e.toString()}NextContent(){if(this.state.previousPointer=this.state.currentPointer.copy(),!this.state.divertedPointer.isNull&&(this.state.currentPointer=this.state.divertedPointer.copy(),this.state.divertedPointer=I.Null,this.VisitChangedContainersDueToDivert(),!this.state.currentPointer.isNull))return;if(!this.IncrementContentPointer()){let t=!1;this.state.callStack.CanPop(r.Function)?(this.state.PopCallStack(r.Function),this.state.inExpressionEvaluation&&this.state.PushEvaluationStack(new L),t=!0):this.state.callStack.canPopThread?(this.state.callStack.PopThread(),t=!0):this.state.TryExitFunctionEvaluationFromGame(),t&&!this.state.currentPointer.isNull&&this.NextContent()}}IncrementContentPointer(){let t=!0,e=this.state.callStack.currentElement.currentPointer.copy();if(e.index++,null===e.container)return d("pointer.container");for(;e.index>=e.container.content.length;){t=!1;let n=a(e.container.parent,N);if(n instanceof N==!1)break;let i=n.content.indexOf(e.container);if(-1==i)break;if(e=new I(n,i),e.index++,t=!0,null===e.container)return d("pointer.container")}return t||(e=I.Null),this.state.callStack.currentElement.currentPointer=e.copy(),t}TryFollowDefaultInvisibleChoice(){let t=this._state.currentChoices,e=t.filter(t=>t.isInvisibleDefault);if(0==e.length||t.length>e.length)return!1;let n=e[0];return null===n.targetPath?d("choice.targetPath"):null===n.threadAtGeneration?d("choice.threadAtGeneration"):(this.state.callStack.currentThread=n.threadAtGeneration,this.ChoosePath(n.targetPath,!1),!0)}NextSequenceShuffleIndex(){let t=a(this.state.PopEvaluationStack(),b);if(!(t instanceof b))return this.Error("expected number of elements in sequence for shuffle index"),0;let e=this.state.currentPointer.container;if(null===e)return d("seqContainer");if(null===t.value)return d("numElementsIntVal.value");let n=t.value,i=s(this.state.PopEvaluationStack(),b).value;if(null===i)return d("seqCount");let r=i/n,l=i%n,o=e.path.toString(),u=0;for(let t=0,e=o.length;t<e;t++)u+=o.charCodeAt(t)||0;let h=u+r+this.state.storySeed,c=new K(Math.floor(h)),p=[];for(let t=0;t<n;++t)p.push(t);for(let t=0;t<=l;++t){let e=c.next()%p.length,n=p[e];if(p.splice(e,1),t==l)return n}throw new Error("Should never reach here")}Error(t,e=!1){let n=new S(t);throw n.useEndLineNumber=e,n}Warning(t){this.AddError(t,!0)}AddError(t,e=!1,n=!1){let i=this.currentDebugMetadata,r=e?"WARNING":"ERROR";if(null!=i){let e=n?i.endLineNumber:i.startLineNumber;t="RUNTIME "+r+": '"+i.fileName+"' line "+e+": "+t}else t=this.state.currentPointer.isNull?"RUNTIME "+r+": "+t:"RUNTIME "+r+": ("+this.state.currentPointer+"): "+t;this.state.AddError(t,e),e||this.state.ForceEnd()}Assert(t,e=null){if(0==t)throw null==e&&(e="Story assert"),new Error(e+" "+this.currentDebugMetadata)}get currentDebugMetadata(){let t,e=this.state.currentPointer;if(!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let n=this.state.callStack.elements.length-1;n>=0;--n)if(e=this.state.callStack.elements[n].currentPointer,!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let e=this.state.outputStream.length-1;e>=0;--e){if(t=this.state.outputStream[e].debugMetadata,null!==t)return t}return null}get mainContentContainer(){return this._temporaryEvaluationContainer?this._temporaryEvaluationContainer:this._mainContentContainer}}X.inkVersionCurrent=19,function(t){let e;!function(t){t[t.NoChange=0]="NoChange",t[t.ExtendedBeyondNewline=1]="ExtendedBeyondNewline",t[t.NewlineRemoved=2]="NewlineRemoved"}(e=t.OutputStateChange||(t.OutputStateChange={}))}(X||(X={})),t.InkList=g,t.Story=X,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=ink-es2015.js.map


/***/ }),

/***/ "./node_modules/inkjs/engine/CallStack.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/CallStack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStack = void 0;
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class CallStack {
    constructor() {
        this._threadCounter = 0;
        this._startOfRoot = Pointer_1.Pointer.Null;
        if (arguments[0] instanceof Story_1.Story) {
            let storyContext = arguments[0];
            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
            this.Reset();
        }
        else {
            let toCopy = arguments[0];
            this._threads = [];
            for (let otherThread of toCopy._threads) {
                this._threads.push(otherThread.Copy());
            }
            this._threadCounter = toCopy._threadCounter;
            this._startOfRoot = toCopy._startOfRoot;
        }
    }
    get elements() {
        return this.callStack;
    }
    get depth() {
        return this.elements.length;
    }
    get currentElement() {
        let thread = this._threads[this._threads.length - 1];
        let cs = thread.callstack;
        return cs[cs.length - 1];
    }
    get currentElementIndex() {
        return this.callStack.length - 1;
    }
    get currentThread() {
        return this._threads[this._threads.length - 1];
    }
    set currentThread(value) {
        Debug_1.Debug.Assert(this._threads.length == 1, "Shouldn't be directly setting the current thread when we have a stack of them");
        this._threads.length = 0;
        this._threads.push(value);
    }
    get canPop() {
        return this.callStack.length > 1;
    }
    Reset() {
        this._threads = [];
        this._threads.push(new CallStack.Thread());
        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));
    }
    SetJsonToken(jObject, storyContext) {
        this._threads.length = 0;
        // TODO: (List<object>) jObject ["threads"];
        let jThreads = jObject["threads"];
        for (let jThreadTok of jThreads) {
            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;
            let jThreadObj = jThreadTok;
            let thread = new CallStack.Thread(jThreadObj, storyContext);
            this._threads.push(thread);
        }
        // TODO: (int)jObject ["threadCounter"];
        this._threadCounter = parseInt(jObject["threadCounter"]);
        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
    }
    WriteJson(w) {
        w.WriteObject((writer) => {
            writer.WritePropertyStart("threads");
            writer.WriteArrayStart();
            for (let thread of this._threads) {
                thread.WriteJson(writer);
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WritePropertyStart("threadCounter");
            writer.WriteInt(this._threadCounter);
            writer.WritePropertyEnd();
        });
    }
    PushThread() {
        let newThread = this.currentThread.Copy();
        this._threadCounter++;
        newThread.threadIndex = this._threadCounter;
        this._threads.push(newThread);
    }
    ForkThread() {
        let forkedThread = this.currentThread.Copy();
        this._threadCounter++;
        forkedThread.threadIndex = this._threadCounter;
        return forkedThread;
    }
    PopThread() {
        if (this.canPopThread) {
            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()
        }
        else {
            throw new Error("Can't pop thread");
        }
    }
    get canPopThread() {
        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;
    }
    get elementIsEvaluateFromGame() {
        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;
    }
    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {
        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);
        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;
        element.functionStartInOutputStream = outputStreamLengthWithPushed;
        this.callStack.push(element);
    }
    CanPop(type = null) {
        if (!this.canPop)
            return false;
        if (type == null)
            return true;
        return this.currentElement.type == type;
    }
    Pop(type = null) {
        if (this.CanPop(type)) {
            this.callStack.pop();
            return;
        }
        else {
            throw new Error("Mismatched push/pop in Callstack");
        }
    }
    GetTemporaryVariableWithName(name, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        let varValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (varValue.exists) {
            return varValue.result;
        }
        else {
            return null;
        }
    }
    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        if (!declareNew && !contextElement.temporaryVariables.get(name)) {
            throw new StoryException_1.StoryException("Could not find temporary variable to set: " + name);
        }
        let oldValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (oldValue.exists)
            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        contextElement.temporaryVariables.set(name, value);
    }
    ContextForVariableNamed(name) {
        if (this.currentElement.temporaryVariables.get(name)) {
            return this.currentElementIndex + 1;
        }
        else {
            return 0;
        }
    }
    ThreadWithIndex(index) {
        let filtered = this._threads.filter((t) => {
            if (t.threadIndex == index)
                return t;
        });
        return filtered.length > 0 ? filtered[0] : null;
    }
    get callStack() {
        return this.currentThread.callstack;
    }
    get callStackTrace() {
        let sb = new StringBuilder_1.StringBuilder();
        for (let t = 0; t < this._threads.length; t++) {
            let thread = this._threads[t];
            let isCurrent = t == this._threads.length - 1;
            sb.AppendFormat("=== THREAD {0}/{1} {2}===\n", t + 1, this._threads.length, isCurrent ? "(current) " : "");
            for (let i = 0; i < thread.callstack.length; i++) {
                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)
                    sb.Append("  [FUNCTION] ");
                else
                    sb.Append("  [TUNNEL] ");
                let pointer = thread.callstack[i].currentPointer;
                if (!pointer.isNull) {
                    sb.Append("<SOMEWHERE IN ");
                    if (pointer.container === null) {
                        return NullException_1.throwNullException("pointer.container");
                    }
                    sb.Append(pointer.container.path.toString());
                    sb.AppendLine(">");
                }
            }
        }
        return sb.toString();
    }
}
exports.CallStack = CallStack;
(function (CallStack) {
    class Element {
        constructor(type, pointer, inExpressionEvaluation = false) {
            this.evaluationStackHeightWhenPushed = 0;
            this.functionStartInOutputStream = 0;
            this.currentPointer = pointer.copy();
            this.inExpressionEvaluation = inExpressionEvaluation;
            this.temporaryVariables = new Map();
            this.type = type;
        }
        Copy() {
            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);
            copy.temporaryVariables = new Map(this.temporaryVariables);
            copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;
            copy.functionStartInOutputStream = this.functionStartInOutputStream;
            return copy;
        }
    }
    CallStack.Element = Element;
    class Thread {
        constructor() {
            this.threadIndex = 0;
            this.previousPointer = Pointer_1.Pointer.Null;
            this.callstack = [];
            if (arguments[0] && arguments[1]) {
                let jThreadObj = arguments[0];
                let storyContext = arguments[1];
                // TODO: (int) jThreadObj['threadIndex'] can raise;
                this.threadIndex = parseInt(jThreadObj["threadIndex"]);
                let jThreadCallstack = jThreadObj["callstack"];
                for (let jElTok of jThreadCallstack) {
                    let jElementObj = jElTok;
                    // TODO: (int) jElementObj['type'] can raise;
                    let pushPopType = parseInt(jElementObj["type"]);
                    let pointer = Pointer_1.Pointer.Null;
                    let currentContainerPathStr;
                    // TODO: jElementObj.TryGetValue ("cPath", out currentContainerPathStrToken);
                    let currentContainerPathStrToken = jElementObj["cPath"];
                    if (typeof currentContainerPathStrToken !== "undefined") {
                        currentContainerPathStr = currentContainerPathStrToken.toString();
                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));
                        pointer.container = threadPointerResult.container;
                        pointer.index = parseInt(jElementObj["idx"]);
                        if (threadPointerResult.obj == null)
                            throw new Error("When loading state, internal story location couldn't be found: " +
                                currentContainerPathStr +
                                ". Has the story changed since this save data was created?");
                        else if (threadPointerResult.approximate) {
                            if (pointer.container === null) {
                                return NullException_1.throwNullException("pointer.container");
                            }
                            storyContext.Warning("When loading state, exact internal story location couldn't be found: '" +
                                currentContainerPathStr +
                                "', so it was approximated to '" +
                                pointer.container.path.toString() +
                                "' to recover. Has the story changed since this save data was created?");
                        }
                    }
                    let inExpressionEvaluation = !!jElementObj["exp"];
                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);
                    let temps = jElementObj["temp"];
                    if (typeof temps !== "undefined") {
                        el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);
                    }
                    else {
                        el.temporaryVariables.clear();
                    }
                    this.callstack.push(el);
                }
                let prevContentObjPath = jThreadObj["previousContentObject"];
                if (typeof prevContentObjPath !== "undefined") {
                    let prevPath = new Path_1.Path(prevContentObjPath.toString());
                    this.previousPointer = storyContext.PointerAtPath(prevPath);
                }
            }
        }
        Copy() {
            let copy = new Thread();
            copy.threadIndex = this.threadIndex;
            for (let e of this.callstack) {
                copy.callstack.push(e.Copy());
            }
            copy.previousPointer = this.previousPointer.copy();
            return copy;
        }
        WriteJson(writer) {
            writer.WriteObjectStart();
            writer.WritePropertyStart("callstack");
            writer.WriteArrayStart();
            for (let el of this.callstack) {
                writer.WriteObjectStart();
                if (!el.currentPointer.isNull) {
                    if (el.currentPointer.container === null) {
                        return NullException_1.throwNullException("el.currentPointer.container");
                    }
                    writer.WriteProperty("cPath", el.currentPointer.container.path.componentsString);
                    writer.WriteIntProperty("idx", el.currentPointer.index);
                }
                writer.WriteProperty("exp", el.inExpressionEvaluation);
                writer.WriteIntProperty("type", el.type);
                if (el.temporaryVariables.size > 0) {
                    writer.WritePropertyStart("temp");
                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);
                    writer.WritePropertyEnd();
                }
                writer.WriteObjectEnd();
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WriteIntProperty("threadIndex", this.threadIndex);
            if (!this.previousPointer.isNull) {
                let resolvedPointer = this.previousPointer.Resolve();
                if (resolvedPointer === null) {
                    return NullException_1.throwNullException("this.previousPointer.Resolve()");
                }
                writer.WriteProperty("previousContentObject", resolvedPointer.path.toString());
            }
            writer.WriteObjectEnd();
        }
    }
    CallStack.Thread = Thread;
})(CallStack = exports.CallStack || (exports.CallStack = {}));
//# sourceMappingURL=CallStack.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Choice.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Choice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Choice = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Choice extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.text = "";
        this.index = 0;
        this.threadAtGeneration = null;
        this.sourcePath = "";
        this.targetPath = null;
        this.isInvisibleDefault = false;
        this.originalThreadIndex = 0;
    }
    get pathStringOnChoice() {
        if (this.targetPath === null)
            return NullException_1.throwNullException("Choice.targetPath");
        return this.targetPath.toString();
    }
    set pathStringOnChoice(value) {
        this.targetPath = new Path_1.Path(value);
    }
}
exports.Choice = Choice;
//# sourceMappingURL=Choice.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ChoicePoint.js":
/*!**************************************************!*\
  !*** ./node_modules/inkjs/engine/ChoicePoint.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoicePoint = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ChoicePoint extends Object_1.InkObject {
    constructor(onceOnly = true) {
        super();
        this._pathOnChoice = null;
        this.hasCondition = false;
        this.hasStartContent = false;
        this.hasChoiceOnlyContent = false;
        this.isInvisibleDefault = false;
        this.onceOnly = true;
        this.onceOnly = onceOnly;
    }
    get pathOnChoice() {
        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {
            let choiceTargetObj = this.choiceTarget;
            if (choiceTargetObj) {
                this._pathOnChoice = choiceTargetObj.path;
            }
        }
        return this._pathOnChoice;
    }
    set pathOnChoice(value) {
        this._pathOnChoice = value;
    }
    get choiceTarget() {
        if (this._pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint._pathOnChoice");
        return this.ResolvePath(this._pathOnChoice).container;
    }
    get pathStringOnChoice() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        return this.CompactPathString(this.pathOnChoice);
    }
    set pathStringOnChoice(value) {
        this.pathOnChoice = new Path_1.Path(value);
    }
    get flags() {
        let flags = 0;
        if (this.hasCondition)
            flags |= 1;
        if (this.hasStartContent)
            flags |= 2;
        if (this.hasChoiceOnlyContent)
            flags |= 4;
        if (this.isInvisibleDefault)
            flags |= 8;
        if (this.onceOnly)
            flags |= 16;
        return flags;
    }
    set flags(value) {
        this.hasCondition = (value & 1) > 0;
        this.hasStartContent = (value & 2) > 0;
        this.hasChoiceOnlyContent = (value & 4) > 0;
        this.isInvisibleDefault = (value & 8) > 0;
        this.onceOnly = (value & 16) > 0;
    }
    toString() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);
        let targetLineNum = null;
        let targetString = this.pathOnChoice.toString();
        if (targetLineNum != null) {
            targetString = " line " + targetLineNum + "(" + targetString + ")";
        }
        return "Choice: -> " + targetString;
    }
}
exports.ChoicePoint = ChoicePoint;
//# sourceMappingURL=ChoicePoint.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Container.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/Container.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const SearchResult_1 = __webpack_require__(/*! ./SearchResult */ "./node_modules/inkjs/engine/SearchResult.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
class Container extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.name = "";
        this._content = [];
        this.namedContent = new Map();
        this.visitsShouldBeCounted = false;
        this.turnIndexShouldBeCounted = false;
        this.countingAtStartOnly = false;
        this._pathToFirstLeafContent = null;
    }
    get hasValidName() {
        return this.name != null && this.name.length > 0;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this.AddContent(value);
    }
    get namedOnlyContent() {
        let namedOnlyContentDict = new Map();
        for (let [key, value] of this.namedContent) {
            let inkObject = TypeAssertion_1.asOrThrows(value, Object_1.InkObject);
            namedOnlyContentDict.set(key, inkObject);
        }
        for (let c of this.content) {
            let named = TypeAssertion_1.asINamedContentOrNull(c);
            if (named != null && named.hasValidName) {
                namedOnlyContentDict.delete(named.name);
            }
        }
        if (namedOnlyContentDict.size == 0)
            namedOnlyContentDict = null;
        return namedOnlyContentDict;
    }
    set namedOnlyContent(value) {
        let existingNamedOnly = this.namedOnlyContent;
        if (existingNamedOnly != null) {
            for (let [key] of existingNamedOnly) {
                this.namedContent.delete(key);
            }
        }
        if (value == null)
            return;
        for (let [, val] of value) {
            let named = TypeAssertion_1.asINamedContentOrNull(val);
            if (named != null)
                this.AddToNamedContentOnly(named);
        }
    }
    get countFlags() {
        let flags = 0;
        if (this.visitsShouldBeCounted)
            flags |= Container.CountFlags.Visits;
        if (this.turnIndexShouldBeCounted)
            flags |= Container.CountFlags.Turns;
        if (this.countingAtStartOnly)
            flags |= Container.CountFlags.CountStartOnly;
        if (flags == Container.CountFlags.CountStartOnly) {
            flags = 0;
        }
        return flags;
    }
    set countFlags(value) {
        let flag = value;
        if ((flag & Container.CountFlags.Visits) > 0)
            this.visitsShouldBeCounted = true;
        if ((flag & Container.CountFlags.Turns) > 0)
            this.turnIndexShouldBeCounted = true;
        if ((flag & Container.CountFlags.CountStartOnly) > 0)
            this.countingAtStartOnly = true;
    }
    get pathToFirstLeafContent() {
        if (this._pathToFirstLeafContent == null)
            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);
        return this._pathToFirstLeafContent;
    }
    get internalPathToFirstLeafContent() {
        let components = [];
        let container = this;
        while (container instanceof Container) {
            if (container.content.length > 0) {
                components.push(new Path_1.Path.Component(0));
                container = container.content[0];
            }
        }
        return new Path_1.Path(components);
    }
    AddContent(contentObjOrList) {
        if (contentObjOrList instanceof Array) {
            let contentList = contentObjOrList;
            for (let c of contentList) {
                this.AddContent(c);
            }
        }
        else {
            let contentObj = contentObjOrList;
            this._content.push(contentObj);
            if (contentObj.parent) {
                throw new Error("content is already in " + contentObj.parent);
            }
            contentObj.parent = this;
            this.TryAddNamedContent(contentObj);
        }
    }
    TryAddNamedContent(contentObj) {
        let namedContentObj = TypeAssertion_1.asINamedContentOrNull(contentObj);
        if (namedContentObj != null && namedContentObj.hasValidName) {
            this.AddToNamedContentOnly(namedContentObj);
        }
    }
    AddToNamedContentOnly(namedContentObj) {
        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, "Can only add Runtime.Objects to a Runtime.Container");
        let runtimeObj = TypeAssertion_1.asOrThrows(namedContentObj, Object_1.InkObject);
        runtimeObj.parent = this;
        this.namedContent.set(namedContentObj.name, namedContentObj);
    }
    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {
        if (partialPathLength == -1)
            partialPathLength = path.length;
        let result = new SearchResult_1.SearchResult();
        result.approximate = false;
        let currentContainer = this;
        let currentObj = this;
        for (let i = partialPathStart; i < partialPathLength; ++i) {
            let comp = path.GetComponent(i);
            if (currentContainer == null) {
                result.approximate = true;
                break;
            }
            let foundObj = currentContainer.ContentWithPathComponent(comp);
            if (foundObj == null) {
                result.approximate = true;
                break;
            }
            currentObj = foundObj;
            currentContainer = TypeAssertion_1.asOrNull(foundObj, Container);
        }
        result.obj = currentObj;
        return result;
    }
    InsertContent(contentObj, index) {
        this.content[index] = contentObj;
        if (contentObj.parent) {
            throw new Error("content is already in " + contentObj.parent);
        }
        contentObj.parent = this;
        this.TryAddNamedContent(contentObj);
    }
    AddContentsOfContainer(otherContainer) {
        this.content = this.content.concat(otherContainer.content);
        for (let obj of otherContainer.content) {
            obj.parent = this;
            this.TryAddNamedContent(obj);
        }
    }
    ContentWithPathComponent(component) {
        if (component.isIndex) {
            if (component.index >= 0 && component.index < this.content.length) {
                return this.content[component.index];
            }
            else {
                return null;
            }
        }
        else if (component.isParent) {
            return this.parent;
        }
        else {
            if (component.name === null) {
                return NullException_1.throwNullException("component.name");
            }
            let foundContent = TryGetResult_1.tryGetValueFromMap(this.namedContent, component.name, null);
            if (foundContent.exists) {
                return TypeAssertion_1.asOrThrows(foundContent.result, Object_1.InkObject);
            }
            else {
                return null;
            }
        }
    }
    BuildStringOfHierarchy() {
        let sb;
        if (arguments.length == 0) {
            sb = new StringBuilder_1.StringBuilder();
            this.BuildStringOfHierarchy(sb, 0, null);
            return sb.toString();
        }
        sb = arguments[0];
        let indentation = arguments[1];
        let pointedObj = arguments[2];
        function appendIndentation() {
            const spacesPerIndent = 4; // Truly const in the original code
            for (let i = 0; i < spacesPerIndent * indentation; ++i) {
                sb.Append(" ");
            }
        }
        appendIndentation();
        sb.Append("[");
        if (this.hasValidName) {
            sb.AppendFormat(" ({0})", this.name);
        }
        if (this == pointedObj) {
            sb.Append("  <---");
        }
        sb.AppendLine();
        indentation++;
        for (let i = 0; i < this.content.length; ++i) {
            let obj = this.content[i];
            if (obj instanceof Container) {
                let container = obj;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
            }
            else {
                appendIndentation();
                if (obj instanceof Value_1.StringValue) {
                    sb.Append('"');
                    sb.Append(obj.toString().replace("\n", "\\n"));
                    sb.Append('"');
                }
                else {
                    sb.Append(obj.toString());
                }
            }
            if (i != this.content.length - 1) {
                sb.Append(",");
            }
            if (!(obj instanceof Container) && obj == pointedObj) {
                sb.Append("  <---");
            }
            sb.AppendLine();
        }
        let onlyNamed = new Map();
        for (let [key, value] of this.namedContent) {
            if (this.content.indexOf(TypeAssertion_1.asOrThrows(value, Object_1.InkObject)) >= 0) {
                continue;
            }
            else {
                onlyNamed.set(key, value);
            }
        }
        if (onlyNamed.size > 0) {
            appendIndentation();
            sb.AppendLine("-- named: --");
            for (let [, value] of onlyNamed) {
                Debug_1.Debug.AssertType(value, Container, "Can only print out named Containers");
                let container = value;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
                sb.AppendLine();
            }
        }
        indentation--;
        appendIndentation();
        sb.Append("]");
    }
}
exports.Container = Container;
(function (Container) {
    let CountFlags;
    (function (CountFlags) {
        CountFlags[CountFlags["Visits"] = 1] = "Visits";
        CountFlags[CountFlags["Turns"] = 2] = "Turns";
        CountFlags[CountFlags["CountStartOnly"] = 4] = "CountStartOnly";
    })(CountFlags = Container.CountFlags || (Container.CountFlags = {}));
})(Container = exports.Container || (exports.Container = {}));
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ControlCommand.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ControlCommand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlCommand = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class ControlCommand extends Object_1.InkObject {
    constructor(commandType = ControlCommand.CommandType.NotSet) {
        super();
        this._commandType = commandType;
    }
    get commandType() {
        return this._commandType;
    }
    Copy() {
        return new ControlCommand(this.commandType);
    }
    static EvalStart() {
        return new ControlCommand(ControlCommand.CommandType.EvalStart);
    }
    static EvalOutput() {
        return new ControlCommand(ControlCommand.CommandType.EvalOutput);
    }
    static EvalEnd() {
        return new ControlCommand(ControlCommand.CommandType.EvalEnd);
    }
    static Duplicate() {
        return new ControlCommand(ControlCommand.CommandType.Duplicate);
    }
    static PopEvaluatedValue() {
        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);
    }
    static PopFunction() {
        return new ControlCommand(ControlCommand.CommandType.PopFunction);
    }
    static PopTunnel() {
        return new ControlCommand(ControlCommand.CommandType.PopTunnel);
    }
    static BeginString() {
        return new ControlCommand(ControlCommand.CommandType.BeginString);
    }
    static EndString() {
        return new ControlCommand(ControlCommand.CommandType.EndString);
    }
    static NoOp() {
        return new ControlCommand(ControlCommand.CommandType.NoOp);
    }
    static ChoiceCount() {
        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);
    }
    static Turns() {
        return new ControlCommand(ControlCommand.CommandType.Turns);
    }
    static TurnsSince() {
        return new ControlCommand(ControlCommand.CommandType.TurnsSince);
    }
    static ReadCount() {
        return new ControlCommand(ControlCommand.CommandType.ReadCount);
    }
    static Random() {
        return new ControlCommand(ControlCommand.CommandType.Random);
    }
    static SeedRandom() {
        return new ControlCommand(ControlCommand.CommandType.SeedRandom);
    }
    static VisitIndex() {
        return new ControlCommand(ControlCommand.CommandType.VisitIndex);
    }
    static SequenceShuffleIndex() {
        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);
    }
    static StartThread() {
        return new ControlCommand(ControlCommand.CommandType.StartThread);
    }
    static Done() {
        return new ControlCommand(ControlCommand.CommandType.Done);
    }
    static End() {
        return new ControlCommand(ControlCommand.CommandType.End);
    }
    static ListFromInt() {
        return new ControlCommand(ControlCommand.CommandType.ListFromInt);
    }
    static ListRange() {
        return new ControlCommand(ControlCommand.CommandType.ListRange);
    }
    static ListRandom() {
        return new ControlCommand(ControlCommand.CommandType.ListRandom);
    }
    toString() {
        return this.commandType.toString();
    }
}
exports.ControlCommand = ControlCommand;
(function (ControlCommand) {
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["NotSet"] = -1] = "NotSet";
        CommandType[CommandType["EvalStart"] = 0] = "EvalStart";
        CommandType[CommandType["EvalOutput"] = 1] = "EvalOutput";
        CommandType[CommandType["EvalEnd"] = 2] = "EvalEnd";
        CommandType[CommandType["Duplicate"] = 3] = "Duplicate";
        CommandType[CommandType["PopEvaluatedValue"] = 4] = "PopEvaluatedValue";
        CommandType[CommandType["PopFunction"] = 5] = "PopFunction";
        CommandType[CommandType["PopTunnel"] = 6] = "PopTunnel";
        CommandType[CommandType["BeginString"] = 7] = "BeginString";
        CommandType[CommandType["EndString"] = 8] = "EndString";
        CommandType[CommandType["NoOp"] = 9] = "NoOp";
        CommandType[CommandType["ChoiceCount"] = 10] = "ChoiceCount";
        CommandType[CommandType["Turns"] = 11] = "Turns";
        CommandType[CommandType["TurnsSince"] = 12] = "TurnsSince";
        CommandType[CommandType["Random"] = 13] = "Random";
        CommandType[CommandType["SeedRandom"] = 14] = "SeedRandom";
        CommandType[CommandType["VisitIndex"] = 15] = "VisitIndex";
        CommandType[CommandType["SequenceShuffleIndex"] = 16] = "SequenceShuffleIndex";
        CommandType[CommandType["StartThread"] = 17] = "StartThread";
        CommandType[CommandType["Done"] = 18] = "Done";
        CommandType[CommandType["End"] = 19] = "End";
        CommandType[CommandType["ListFromInt"] = 20] = "ListFromInt";
        CommandType[CommandType["ListRange"] = 21] = "ListRange";
        CommandType[CommandType["ListRandom"] = 22] = "ListRandom";
        CommandType[CommandType["ReadCount"] = 23] = "ReadCount";
        CommandType[CommandType["TOTAL_VALUES"] = 24] = "TOTAL_VALUES";
    })(CommandType = ControlCommand.CommandType || (ControlCommand.CommandType = {}));
})(ControlCommand = exports.ControlCommand || (exports.ControlCommand = {}));
//# sourceMappingURL=ControlCommand.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Debug.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Debug.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Debug = void 0;
var Debug;
(function (Debug) {
    function AssertType(variable, type, message) {
        Assert(variable instanceof type, message);
    }
    Debug.AssertType = AssertType;
    function Assert(condition, message) {
        if (!condition) {
            if (typeof message !== "undefined") {
                console.warn(message);
            }
            if (console.trace) {
                console.trace();
            }
            throw new Error("");
        }
    }
    Debug.Assert = Assert;
})(Debug = exports.Debug || (exports.Debug = {}));
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Divert.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Divert.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Divert = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class Divert extends Object_1.InkObject {
    constructor(stackPushType) {
        super();
        this._targetPath = null;
        this._targetPointer = Pointer_1.Pointer.Null;
        this.variableDivertName = null;
        this.pushesToStack = false;
        this.stackPushType = 0;
        this.isExternal = false;
        this.externalArgs = 0;
        this.isConditional = false;
        this.pushesToStack = false;
        if (typeof stackPushType !== "undefined") {
            this.pushesToStack = true;
            this.stackPushType = stackPushType;
        }
    }
    get targetPath() {
        if (this._targetPath != null && this._targetPath.isRelative) {
            let targetObj = this.targetPointer.Resolve();
            if (targetObj) {
                this._targetPath = targetObj.path;
            }
        }
        return this._targetPath;
    }
    set targetPath(value) {
        this._targetPath = value;
        this._targetPointer = Pointer_1.Pointer.Null;
    }
    get targetPointer() {
        if (this._targetPointer.isNull) {
            let targetObj = this.ResolvePath(this._targetPath).obj;
            if (this._targetPath === null)
                return NullException_1.throwNullException("this._targetPath");
            if (this._targetPath.lastComponent === null)
                return NullException_1.throwNullException("this._targetPath.lastComponent");
            if (this._targetPath.lastComponent.isIndex) {
                if (targetObj === null)
                    return NullException_1.throwNullException("targetObj");
                this._targetPointer.container =
                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;
                this._targetPointer.index = this._targetPath.lastComponent.index;
            }
            else {
                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);
            }
        }
        return this._targetPointer.copy();
    }
    get targetPathString() {
        if (this.targetPath == null)
            return null;
        return this.CompactPathString(this.targetPath);
    }
    set targetPathString(value) {
        if (value == null) {
            this.targetPath = null;
        }
        else {
            this.targetPath = new Path_1.Path(value);
        }
    }
    get hasVariableTarget() {
        return this.variableDivertName != null;
    }
    Equals(obj) {
        let otherDivert = obj;
        if (otherDivert instanceof Divert) {
            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {
                if (this.hasVariableTarget) {
                    return this.variableDivertName == otherDivert.variableDivertName;
                }
                else {
                    if (this.targetPath === null)
                        return NullException_1.throwNullException("this.targetPath");
                    return this.targetPath.Equals(otherDivert.targetPath);
                }
            }
        }
        return false;
    }
    toString() {
        if (this.hasVariableTarget) {
            return "Divert(variable: " + this.variableDivertName + ")";
        }
        else if (this.targetPath == null) {
            return "Divert(null)";
        }
        else {
            let sb = new StringBuilder_1.StringBuilder();
            let targetStr = this.targetPath.toString();
            // int? targetLineNum = DebugLineNumberOfPath (targetPath);
            let targetLineNum = null;
            if (targetLineNum != null) {
                targetStr = "line " + targetLineNum;
            }
            sb.Append("Divert");
            if (this.isConditional)
                sb.Append("?");
            if (this.pushesToStack) {
                if (this.stackPushType == PushPop_1.PushPopType.Function) {
                    sb.Append(" function");
                }
                else {
                    sb.Append(" tunnel");
                }
            }
            sb.Append(" -> ");
            sb.Append(this.targetPathString);
            sb.Append(" (");
            sb.Append(targetStr);
            sb.Append(")");
            return sb.toString();
        }
    }
}
exports.Divert = Divert;
//# sourceMappingURL=Divert.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Glue.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Glue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Glue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Glue extends Object_1.InkObject {
    toString() {
        return "Glue";
    }
}
exports.Glue = Glue;
//# sourceMappingURL=Glue.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/InkList.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/InkList.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkList = exports.InkListItem = void 0;
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
class InkListItem {
    constructor() {
        // InkListItem is a struct
        this.originName = null;
        this.itemName = null;
        if (typeof arguments[1] !== "undefined") {
            let originName = arguments[0];
            let itemName = arguments[1];
            this.originName = originName;
            this.itemName = itemName;
        }
        else if (arguments[0]) {
            let fullName = arguments[0];
            let nameParts = fullName.toString().split(".");
            this.originName = nameParts[0];
            this.itemName = nameParts[1];
        }
    }
    static get Null() {
        return new InkListItem(null, null);
    }
    get isNull() {
        return this.originName == null && this.itemName == null;
    }
    get fullName() {
        return ((this.originName !== null ? this.originName : "?") + "." + this.itemName);
    }
    toString() {
        return this.fullName;
    }
    Equals(obj) {
        if (obj instanceof InkListItem) {
            let otherItem = obj;
            return (otherItem.itemName == this.itemName &&
                otherItem.originName == this.originName);
        }
        return false;
    }
    // These methods did not exist in the original C# code. Their purpose is to
    // make `InkListItem` mimics the value-type semantics of the original
    // struct. Please refer to the end of this file, for a more in-depth
    // explanation.
    /**
     * Returns a shallow clone of the current instance.
     */
    copy() {
        return new InkListItem(this.originName, this.itemName);
    }
    /**
     * Returns a `SerializedInkListItem` representing the current
     * instance. The result is intended to be used as a key inside a Map.
     */
    serialized() {
        // We are simply using a JSON representation as a value-typed key.
        return JSON.stringify({
            originName: this.originName,
            itemName: this.itemName,
        });
    }
    /**
     * Reconstructs a `InkListItem` from the given SerializedInkListItem.
     */
    static fromSerializedKey(key) {
        let obj = JSON.parse(key);
        if (!InkListItem.isLikeInkListItem(obj))
            return InkListItem.Null;
        let inkListItem = obj;
        return new InkListItem(inkListItem.originName, inkListItem.itemName);
    }
    /**
     * Determines whether the given item is sufficiently `InkListItem`-like
     * to be used as a template when reconstructing the InkListItem.
     */
    static isLikeInkListItem(item) {
        if (typeof item !== "object")
            return false;
        if (!item.hasOwnProperty("originName") || !item.hasOwnProperty("itemName"))
            return false;
        if (typeof item.originName !== "string" && typeof item.originName !== null)
            return false;
        if (typeof item.itemName !== "string" && typeof item.itemName !== null)
            return false;
        return true;
    }
}
exports.InkListItem = InkListItem;
class InkList extends Map {
    constructor() {
        // Trying to be smart here, this emulates the constructor inheritance found
        // in the original code, but only if otherList is an InkList. IIFE FTW.
        super((() => {
            if (arguments[0] instanceof InkList) {
                return arguments[0];
            }
            else {
                return [];
            }
        })());
        this.origins = null;
        this._originNames = [];
        if (arguments[0] instanceof InkList) {
            let otherList = arguments[0];
            if (otherList._originNames) {
                this._originNames = otherList._originNames.slice();
            }
        }
        else if (typeof arguments[0] === "string") {
            let singleOriginListName = arguments[0];
            let originStory = arguments[1]; /* as Story */
            this.SetInitialOriginName(singleOriginListName);
            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);
            if (def.exists) {
                this.origins = [def.result];
            }
            else {
                throw new Error("InkList origin could not be found in story when constructing new list: " +
                    singleOriginListName);
            }
        }
        else if (typeof arguments[0] === "object" &&
            arguments[0].hasOwnProperty("Key") &&
            arguments[0].hasOwnProperty("Value")) {
            let singleElement = arguments[0];
            this.Add(singleElement.Key, singleElement.Value);
        }
    }
    AddItem(itemOrItemName) {
        if (itemOrItemName instanceof InkListItem) {
            let item = itemOrItemName;
            if (item.originName == null) {
                this.AddItem(item.itemName);
                return;
            }
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (origin.name == item.originName) {
                    let intVal = origin.TryGetValueForItem(item, 0);
                    if (intVal.exists) {
                        this.Add(item, intVal.result);
                        return;
                    }
                    else {
                        throw new Error("Could not add the item " +
                            item +
                            " to this list because it doesn't exist in the original list definition in ink.");
                    }
                }
            }
            throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.");
        }
        else {
            let itemName = itemOrItemName;
            let foundListDef = null;
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (itemName === null)
                    return NullException_1.throwNullException("itemName");
                if (origin.ContainsItemWithName(itemName)) {
                    if (foundListDef != null) {
                        throw new Error("Could not add the item " +
                            itemName +
                            " to this list because it could come from either " +
                            origin.name +
                            " or " +
                            foundListDef.name);
                    }
                    else {
                        foundListDef = origin;
                    }
                }
            }
            if (foundListDef == null)
                throw new Error("Could not add the item " +
                    itemName +
                    " to this list because it isn't known to any list definitions previously associated with this list.");
            let item = new InkListItem(foundListDef.name, itemName);
            let itemVal = foundListDef.ValueForItem(item);
            this.Add(item, itemVal);
        }
    }
    ContainsItemNamed(itemName) {
        for (let [key] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (item.itemName == itemName)
                return true;
        }
        return false;
    }
    ContainsKey(key) {
        return this.has(key.serialized());
    }
    Add(key, value) {
        let serializedKey = key.serialized();
        if (this.has(serializedKey)) {
            // Throw an exception to match the C# behavior.
            throw new Error(`The Map already contains an entry for ${key}`);
        }
        this.set(serializedKey, value);
    }
    Remove(key) {
        return this.delete(key.serialized());
    }
    get Count() {
        return this.size;
    }
    get originOfMaxItem() {
        if (this.origins == null)
            return null;
        let maxOriginName = this.maxItem.Key.originName;
        let result = null;
        this.origins.every((origin) => {
            if (origin.name == maxOriginName) {
                result = origin;
                return false;
            }
            else
                return true;
        });
        return result;
    }
    get originNames() {
        if (this.Count > 0) {
            if (this._originNames == null && this.Count > 0)
                this._originNames = [];
            else {
                if (!this._originNames)
                    this._originNames = [];
                this._originNames.length = 0;
            }
            for (let [key] of this) {
                let item = InkListItem.fromSerializedKey(key);
                if (item.originName === null)
                    return NullException_1.throwNullException("item.originName");
                this._originNames.push(item.originName);
            }
        }
        return this._originNames;
    }
    SetInitialOriginName(initialOriginName) {
        this._originNames = [initialOriginName];
    }
    SetInitialOriginNames(initialOriginNames) {
        if (initialOriginNames == null)
            this._originNames = null;
        else
            this._originNames = initialOriginNames.slice(); // store a copy
    }
    get maxItem() {
        let max = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (max.Key.isNull || value > max.Value)
                max = { Key: item, Value: value };
        }
        return max;
    }
    get minItem() {
        let min = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (min.Key.isNull || value < min.Value) {
                min = { Key: item, Value: value };
            }
        }
        return min;
    }
    get inverse() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    if (!this.ContainsKey(item))
                        list.Add(item, value);
                }
            }
        }
        return list;
    }
    get all() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    list.set(item.serialized(), value);
                }
            }
        }
        return list;
    }
    Union(otherList) {
        let union = new InkList(this);
        for (let [key, value] of otherList) {
            union.set(key, value);
        }
        return union;
    }
    Intersect(otherList) {
        let intersection = new InkList();
        for (let [key, value] of this) {
            if (otherList.has(key))
                intersection.set(key, value);
        }
        return intersection;
    }
    Without(listToRemove) {
        let result = new InkList(this);
        for (let [key] of listToRemove) {
            result.delete(key);
        }
        return result;
    }
    Contains(otherList) {
        for (let [key] of otherList) {
            if (!this.has(key))
                return false;
        }
        return true;
    }
    GreaterThan(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return this.minItem.Value > otherList.maxItem.Value;
    }
    GreaterThanOrEquals(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return (this.minItem.Value >= otherList.minItem.Value &&
            this.maxItem.Value >= otherList.maxItem.Value);
    }
    LessThan(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return this.maxItem.Value < otherList.minItem.Value;
    }
    LessThanOrEquals(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return (this.maxItem.Value <= otherList.maxItem.Value &&
            this.minItem.Value <= otherList.minItem.Value);
    }
    MaxAsList() {
        if (this.Count > 0)
            return new InkList(this.maxItem);
        else
            return new InkList();
    }
    MinAsList() {
        if (this.Count > 0)
            return new InkList(this.minItem);
        else
            return new InkList();
    }
    ListWithSubRange(minBound, maxBound) {
        if (this.Count == 0)
            return new InkList();
        let ordered = this.orderedItems;
        let minValue = 0;
        let maxValue = Number.MAX_SAFE_INTEGER;
        if (Number.isInteger(minBound)) {
            minValue = minBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                minValue = minBound.minItem.Value;
        }
        if (Number.isInteger(maxBound)) {
            maxValue = maxBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                maxValue = maxBound.maxItem.Value;
        }
        let subList = new InkList();
        subList.SetInitialOriginNames(this.originNames);
        for (let item of ordered) {
            if (item.Value >= minValue && item.Value <= maxValue) {
                subList.Add(item.Key, item.Value);
            }
        }
        return subList;
    }
    Equals(otherInkList) {
        if (otherInkList instanceof InkList === false)
            return false;
        if (otherInkList.Count != this.Count)
            return false;
        for (let [key] of this) {
            if (!otherInkList.has(key))
                return false;
        }
        return true;
    }
    // GetHashCode not implemented
    get orderedItems() {
        // List<KeyValuePair<InkListItem, int>>
        let ordered = new Array();
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            ordered.push({ Key: item, Value: value });
        }
        ordered.sort((x, y) => {
            if (x.Key.originName === null) {
                return NullException_1.throwNullException("x.Key.originName");
            }
            if (y.Key.originName === null) {
                return NullException_1.throwNullException("y.Key.originName");
            }
            if (x.Value == y.Value) {
                return x.Key.originName.localeCompare(y.Key.originName);
            }
            else {
                // TODO: refactor this bit into a numberCompareTo method?
                if (x.Value < y.Value)
                    return -1;
                return x.Value > y.Value ? 1 : 0;
            }
        });
        return ordered;
    }
    toString() {
        let ordered = this.orderedItems;
        let sb = new StringBuilder_1.StringBuilder();
        for (let i = 0; i < ordered.length; i++) {
            if (i > 0)
                sb.Append(", ");
            let item = ordered[i].Key;
            if (item.itemName === null)
                return NullException_1.throwNullException("item.itemName");
            sb.Append(item.itemName);
        }
        return sb.toString();
    }
    // casting a InkList to a Number, for somereason, actually gives a number.
    // This messes up the type detection when creating a Value from a InkList.
    // Returning NaN here prevents that.
    valueOf() {
        return NaN;
    }
}
exports.InkList = InkList;
//# sourceMappingURL=InkList.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/JsonSerialisation.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/JsonSerialisation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerialisation = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const ListDefinition_1 = __webpack_require__(/*! ./ListDefinition */ "./node_modules/inkjs/engine/ListDefinition.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class JsonSerialisation {
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException("runtimeObj");
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static WriteDictionaryRuntimeObjs(writer, dictionary) {
        writer.WriteObjectStart();
        for (let [key, value] of dictionary) {
            writer.WritePropertyStart(key);
            this.WriteRuntimeObject(writer, value);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static WriteListRuntimeObjs(writer, list) {
        writer.WriteArrayStart();
        for (let value of list) {
            this.WriteRuntimeObject(writer, value);
        }
        writer.WriteArrayEnd();
    }
    static WriteIntDictionary(writer, dict) {
        writer.WriteObjectStart();
        for (let [key, value] of dict) {
            writer.WriteIntProperty(key, value);
        }
        writer.WriteObjectEnd();
    }
    static WriteRuntimeObject(writer, obj) {
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            this.WriteRuntimeContainer(writer, container);
            return;
        }
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = "->";
            if (divert.isExternal) {
                divTypeKey = "x()";
            }
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function) {
                    divTypeKey = "f()";
                }
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {
                    divTypeKey = "->t->";
                }
            }
            let targetStr;
            if (divert.hasVariableTarget) {
                targetStr = divert.variableDivertName;
            }
            else {
                targetStr = divert.targetPathString;
            }
            writer.WriteObjectStart();
            writer.WriteProperty(divTypeKey, targetStr);
            if (divert.hasVariableTarget) {
                writer.WriteProperty("var", true);
            }
            if (divert.isConditional) {
                writer.WriteProperty("c", true);
            }
            if (divert.externalArgs > 0) {
                writer.WriteIntProperty("exArgs", divert.externalArgs);
            }
            writer.WriteObjectEnd();
            return;
        }
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            writer.WriteObjectStart();
            writer.WriteProperty("*", choicePoint.pathStringOnChoice);
            writer.WriteIntProperty("flg", choicePoint.flags);
            writer.WriteObjectEnd();
            return;
        }
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal) {
            writer.WriteInt(intVal.value);
            return;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal) {
            writer.WriteFloat(floatVal.value);
            return;
        }
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline) {
                writer.Write("\n", false);
            }
            else {
                writer.WriteStringStart();
                writer.WriteStringInner("^");
                writer.WriteStringInner(strVal.value);
                writer.WriteStringEnd();
            }
            return;
        }
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            this.WriteInkList(writer, listVal);
            return;
        }
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            writer.WriteObjectStart();
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException("divTargetVal.value");
            }
            writer.WriteProperty("^->", divTargetVal.value.componentsString);
            writer.WriteObjectEnd();
            return;
        }
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            writer.WriteObjectStart();
            writer.WriteProperty("^var", varPtrVal.value);
            writer.WriteIntProperty("ci", varPtrVal.contextIndex);
            writer.WriteObjectEnd();
            return;
        }
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue) {
            writer.Write("<>");
            return;
        }
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);
            return;
        }
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == "^")
                name = "L^";
            writer.Write(name);
            return;
        }
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            writer.WriteObjectStart();
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                writer.WriteProperty("CNT?", readCountPath);
            }
            else {
                writer.WriteProperty("VAR?", varRef.name);
            }
            writer.WriteObjectEnd();
            return;
        }
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            writer.WriteObjectStart();
            let key = varAss.isGlobal ? "VAR=" : "temp=";
            writer.WriteProperty(key, varAss.variableName);
            // Reassignment?
            if (!varAss.isNewDeclaration)
                writer.WriteProperty("re", true);
            writer.WriteObjectEnd();
            return;
        }
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj) {
            writer.Write("void");
            return;
        }
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            writer.WriteObjectStart();
            writer.WriteProperty("#", tag.text);
            writer.WriteObjectEnd();
            return;
        }
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice) {
            this.WriteChoice(writer, choice);
            return;
        }
        throw new Error("Failed to convert runtime object to Json token: " + obj);
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException("inkObject");
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === "number" && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === "string") {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == "^")
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == "\n" && str.length == 1)
                return new Value_1.StringValue("\n");
            // Glue
            if (str == "<>")
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == "L^")
                str = "^";
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == "->->")
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == "~ret")
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == "void")
                return new Void_1.Void();
        }
        if (typeof token === "object" && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj["^->"]) {
                propValue = obj["^->"];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj["^var"]) {
                propValue = obj["^var"];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ("ci" in obj) {
                    propValue = obj["ci"];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if ((propValue = obj["->"])) {
                isDivert = true;
            }
            else if ((propValue = obj["f()"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if ((propValue = obj["->t->"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if ((propValue = obj["x()"])) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if ((propValue = obj["var"]))
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj["c"];
                if (external) {
                    if ((propValue = obj["exArgs"]))
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if ((propValue = obj["*"])) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if ((propValue = obj["flg"]))
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if ((propValue = obj["VAR?"])) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if ((propValue = obj["CNT?"])) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if ((propValue = obj["VAR="])) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if ((propValue = obj["temp="])) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj["re"];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj["#"] !== undefined) {
                propValue = obj["#"];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if ((propValue = obj["list"])) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if ((propValue = obj["origins"])) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj["originalChoicePath"] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error("Failed to convert token to runtime object: " + JSON.stringify(token));
    }
    static WriteRuntimeContainer(writer, container, withoutName = false) {
        writer.WriteArrayStart();
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        for (let c of container.content)
            this.WriteRuntimeObject(writer, c);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        let hasNameProperty = container.name != null && !withoutName;
        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;
        if (hasTerminator) {
            writer.WriteObjectStart();
        }
        if (namedOnlyContent != null) {
            for (let [key, value] of namedOnlyContent) {
                let name = key;
                let namedContainer = TypeAssertion_1.asOrNull(value, Container_1.Container);
                writer.WritePropertyStart(name);
                this.WriteRuntimeContainer(writer, namedContainer, true);
                writer.WritePropertyEnd();
            }
        }
        if (hasNameProperty)
            writer.WriteProperty("#n", container.name);
        if (hasTerminator)
            writer.WriteObjectEnd();
        else
            writer.WriteNull();
        writer.WriteArrayEnd();
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == "#f") {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == "#n") {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj["text"].toString();
        choice.index = parseInt(jObj["index"]);
        choice.sourcePath = jObj["originalChoicePath"].toString();
        choice.originalThreadIndex = parseInt(jObj["originalThreadIndex"]);
        choice.pathStringOnChoice = jObj["targetPath"].toString();
        return choice;
    }
    static WriteChoice(writer, choice) {
        writer.WriteObjectStart();
        writer.WriteProperty("text", choice.text);
        writer.WriteIntProperty("index", choice.index);
        writer.WriteProperty("originalChoicePath", choice.sourcePath);
        writer.WriteIntProperty("originalThreadIndex", choice.originalThreadIndex);
        writer.WriteProperty("targetPath", choice.pathStringOnChoice);
        writer.WriteObjectEnd();
    }
    static WriteInkList(writer, listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException("rawList");
        }
        writer.WriteObjectStart();
        writer.WritePropertyStart("list");
        writer.WriteObjectStart();
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            let itemVal = val;
            if (item.itemName === null) {
                return NullException_1.throwNullException("item.itemName");
            }
            writer.WritePropertyNameStart();
            writer.WritePropertyNameInner(item.originName ? item.originName : "?");
            writer.WritePropertyNameInner(".");
            writer.WritePropertyNameInner(item.itemName);
            writer.WritePropertyNameEnd();
            writer.Write(itemVal);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        writer.WritePropertyEnd();
        if (rawList.Count == 0 &&
            rawList.originNames != null &&
            rawList.originNames.length > 0) {
            writer.WritePropertyStart("origins");
            writer.WriteArrayStart();
            for (let name of rawList.originNames)
                writer.Write(name);
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException("item.itemName");
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
exports.JsonSerialisation = JsonSerialisation;
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = "ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = "out";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = "/ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = "du";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = "pop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = "~ret";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = "->->";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = "str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = "/str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = "nop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = "choiceCnt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = "turn";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = "turns";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = "readc";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = "rnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = "srnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = "visit";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =
        "seq";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = "thread";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = "done";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = "end";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = "listInt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = "range";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = "lrnd";
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error("Control command not accounted for in serialisation");
    }
    return _controlCommandNames;
})();
//# sourceMappingURL=JsonSerialisation.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinition.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinition = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
class ListDefinition {
    constructor(name, items) {
        this._name = name || "";
        this._items = null;
        this._itemNameToValues = items || new Map();
    }
    get name() {
        return this._name;
    }
    get items() {
        if (this._items == null) {
            this._items = new Map();
            for (let [key, value] of this._itemNameToValues) {
                let item = new InkList_1.InkListItem(this.name, key);
                this._items.set(item.serialized(), value);
            }
        }
        return this._items;
    }
    ValueForItem(item) {
        if (!item.itemName)
            return 0;
        let intVal = this._itemNameToValues.get(item.itemName);
        if (typeof intVal !== "undefined")
            return intVal;
        else
            return 0;
    }
    ContainsItem(item) {
        if (!item.itemName)
            return false;
        if (item.originName != this.name)
            return false;
        return this._itemNameToValues.has(item.itemName);
    }
    ContainsItemWithName(itemName) {
        return this._itemNameToValues.has(itemName);
    }
    TryGetItemWithValue(val, 
    /* out */ item) {
        for (let [key, value] of this._itemNameToValues) {
            if (value == val) {
                item = new InkList_1.InkListItem(this.name, key);
                return { result: item, exists: true };
            }
        }
        item = InkList_1.InkListItem.Null;
        return { result: item, exists: false };
    }
    TryGetValueForItem(item, 
    /* out */ intVal) {
        if (!item.itemName)
            return { result: 0, exists: false };
        let value = this._itemNameToValues.get(item.itemName);
        if (!value)
            return { result: 0, exists: false };
        return { result: value, exists: true };
    }
}
exports.ListDefinition = ListDefinition;
//# sourceMappingURL=ListDefinition.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js":
/*!************************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinitionsOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinitionsOrigin = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ListDefinitionsOrigin {
    constructor(lists) {
        this._lists = new Map();
        this._allUnambiguousListValueCache = new Map();
        for (let list of lists) {
            this._lists.set(list.name, list);
            for (let [key, val] of list.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                let listValue = new Value_1.ListValue(item, val);
                if (!item.itemName) {
                    throw new Error("item.itemName is null or undefined.");
                }
                this._allUnambiguousListValueCache.set(item.itemName, listValue);
                this._allUnambiguousListValueCache.set(item.fullName, listValue);
            }
        }
    }
    get lists() {
        let listOfLists = [];
        for (let [, value] of this._lists) {
            listOfLists.push(value);
        }
        return listOfLists;
    }
    TryListGetDefinition(name, 
    /* out */ def) {
        if (name === null) {
            return { result: def, exists: false };
        }
        // initially, this function returns a boolean and the second parameter is an out.
        let definition = this._lists.get(name);
        if (!definition)
            return { result: def, exists: false };
        return { result: definition, exists: true };
    }
    FindSingleItemListWithName(name) {
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let val = this._allUnambiguousListValueCache.get(name);
        if (typeof val !== "undefined") {
            return val;
        }
        return null;
    }
}
exports.ListDefinitionsOrigin = ListDefinitionsOrigin;
//# sourceMappingURL=ListDefinitionsOrigin.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NativeFunctionCall.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/NativeFunctionCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeFunctionCall = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class NativeFunctionCall extends Object_1.InkObject {
    constructor() {
        super();
        this._name = null;
        this._numberOfParameters = 0;
        this._prototype = null;
        this._isPrototype = false;
        this._operationFuncs = null;
        if (arguments.length === 0) {
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
        }
        else if (arguments.length === 1) {
            let name = arguments[0];
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
            this.name = name;
        }
        else if (arguments.length === 2) {
            let name = arguments[0];
            let numberOfParameters = arguments[1];
            this._isPrototype = true;
            this.name = name;
            this.numberOfParameters = numberOfParameters;
        }
    }
    static CallWithName(functionName) {
        return new NativeFunctionCall(functionName);
    }
    static CallExistsWithName(functionName) {
        this.GenerateNativeFunctionsIfNecessary();
        return this._nativeFunctions.get(functionName);
    }
    get name() {
        if (this._name === null)
            return NullException_1.throwNullException("NativeFunctionCall._name");
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._isPrototype) {
            if (NativeFunctionCall._nativeFunctions === null)
                NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
            else
                this._prototype =
                    NativeFunctionCall._nativeFunctions.get(this._name) || null;
        }
    }
    get numberOfParameters() {
        if (this._prototype) {
            return this._prototype.numberOfParameters;
        }
        else {
            return this._numberOfParameters;
        }
    }
    set numberOfParameters(value) {
        this._numberOfParameters = value;
    }
    Call(parameters) {
        if (this._prototype) {
            return this._prototype.Call(parameters);
        }
        if (this.numberOfParameters != parameters.length) {
            throw new Error("Unexpected number of parameters");
        }
        let hasList = false;
        for (let p of parameters) {
            if (p instanceof Void_1.Void)
                throw new StoryException_1.StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');
            if (p instanceof Value_1.ListValue)
                hasList = true;
        }
        if (parameters.length == 2 && hasList) {
            return this.CallBinaryListOperation(parameters);
        }
        let coercedParams = this.CoerceValuesToSingleType(parameters);
        let coercedType = coercedParams[0].valueType;
        if (coercedType == Value_1.ValueType.Int) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.Float) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.String) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.DivertTarget) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.List) {
            return this.CallType(coercedParams);
        }
        return null;
    }
    CallType(parametersOfSingleType) {
        let param1 = TypeAssertion_1.asOrThrows(parametersOfSingleType[0], Value_1.Value);
        let valType = param1.valueType;
        let val1 = param1;
        let paramCount = parametersOfSingleType.length;
        if (paramCount == 2 || paramCount == 1) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let opForTypeObj = this._operationFuncs.get(valType);
            if (!opForTypeObj) {
                const key = Value_1.ValueType[valType];
                throw new StoryException_1.StoryException("Cannot perform operation " + this.name + " on " + key);
            }
            if (paramCount == 2) {
                let param2 = TypeAssertion_1.asOrThrows(parametersOfSingleType[1], Value_1.Value);
                let val2 = param2;
                let opForType = opForTypeObj;
                if (val1.value === null || val2.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call BinaryOp values");
                let resultVal = opForType(val1.value, val2.value);
                return Value_1.Value.Create(resultVal);
            }
            else {
                let opForType = opForTypeObj;
                if (val1.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call UnaryOp value");
                let resultVal = opForType(val1.value);
                // This code is different from upstream. Since JavaScript treats
                // integers and floats as the same numbers, it's impossible
                // to force an number to be either an integer or a float.
                //
                // It can be useful to force a specific number type
                // (especially for divisions), so the result of INT() & FLOAT()
                // is coerced to the the proper value type.
                //
                // Note that we also force all other unary operation to
                // return the same value type, although this is only
                // meaningful for numbers. See `Value.Create`.
                if (this.name === NativeFunctionCall.Int) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);
                }
                else if (this.name === NativeFunctionCall.Float) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);
                }
                else {
                    return Value_1.Value.Create(resultVal, param1.valueType);
                }
            }
        }
        else {
            throw new Error("Unexpected number of parameters to NativeFunctionCall: " +
                parametersOfSingleType.length);
        }
    }
    CallBinaryListOperation(parameters) {
        if ((this.name == "+" || this.name == "-") &&
            parameters[0] instanceof Value_1.ListValue &&
            parameters[1] instanceof Value_1.IntValue)
            return this.CallListIncrementOperation(parameters);
        let v1 = TypeAssertion_1.asOrThrows(parameters[0], Value_1.Value);
        let v2 = TypeAssertion_1.asOrThrows(parameters[1], Value_1.Value);
        if ((this.name == "&&" || this.name == "||") &&
            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let op = this._operationFuncs.get(Value_1.ValueType.Int);
            if (op === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallBinaryListOperation op");
            let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);
            return new Value_1.IntValue(result);
        }
        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)
            return this.CallType([v1, v2]);
        throw new StoryException_1.StoryException("Can not call use " +
            this.name +
            " operation on " +
            Value_1.ValueType[v1.valueType] +
            " and " +
            Value_1.ValueType[v2.valueType]);
    }
    CallListIncrementOperation(listIntParams) {
        let listVal = TypeAssertion_1.asOrThrows(listIntParams[0], Value_1.ListValue);
        let intVal = TypeAssertion_1.asOrThrows(listIntParams[1], Value_1.IntValue);
        let resultInkList = new InkList_1.InkList();
        if (listVal.value === null)
            return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");
        for (let [listItemKey, listItemValue] of listVal.value) {
            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);
            if (intVal.value === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");
            let targetInt = intOp(listItemValue, intVal.value);
            let itemOrigin = null;
            if (listVal.value.origins === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");
            for (let origin of listVal.value.origins) {
                if (origin.name == listItem.originName) {
                    itemOrigin = origin;
                    break;
                }
            }
            if (itemOrigin != null) {
                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);
                if (incrementedItem.exists)
                    resultInkList.Add(incrementedItem.result, targetInt);
            }
        }
        return new Value_1.ListValue(resultInkList);
    }
    CoerceValuesToSingleType(parametersIn) {
        let valType = Value_1.ValueType.Int;
        let specialCaseList = null;
        for (let obj of parametersIn) {
            let val = TypeAssertion_1.asOrThrows(obj, Value_1.Value);
            if (val.valueType > valType) {
                valType = val.valueType;
            }
            if (val.valueType == Value_1.ValueType.List) {
                specialCaseList = TypeAssertion_1.asOrNull(val, Value_1.ListValue);
            }
        }
        let parametersOut = [];
        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                if (val.valueType == Value_1.ValueType.List) {
                    parametersOut.push(val);
                }
                else if (val.valueType == Value_1.ValueType.Int) {
                    let intVal = parseInt(val.valueObject);
                    specialCaseList = TypeAssertion_1.asOrThrows(specialCaseList, Value_1.ListValue);
                    if (specialCaseList.value === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");
                    let list = specialCaseList.value.originOfMaxItem;
                    if (list === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");
                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);
                    if (item.exists) {
                        let castedValue = new Value_1.ListValue(item.result, intVal);
                        parametersOut.push(castedValue);
                    }
                    else
                        throw new StoryException_1.StoryException("Could not find List item with the value " +
                            intVal +
                            " in " +
                            list.name);
                }
                else {
                    const key = Value_1.ValueType[val.valueType];
                    throw new StoryException_1.StoryException("Cannot mix Lists and " + key + " values in this operation");
                }
            }
        }
        else {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                let castedValue = val.Cast(valType);
                parametersOut.push(castedValue);
            }
        }
        return parametersOut;
    }
    static Identity(t) {
        return t;
    }
    static GenerateNativeFunctionsIfNecessary() {
        if (this._nativeFunctions == null) {
            this._nativeFunctions = new Map();
            // Int operations
            this.AddIntBinaryOp(this.Add, (x, y) => x + y);
            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));
            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);
            this.AddIntUnaryOp(this.Negate, (x) => -x);
            this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));
            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));
            this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Float, (x) => x);
            // Float operations
            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);
            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);
            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);
            this.AddFloatUnaryOp(this.Negate, (x) => -x);
            this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);
            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));
            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);
            // String operations
            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat
            this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));
            this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));
            this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));
            this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));
            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));
            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));
            this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));
            this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));
            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));
            this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);
            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);
            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));
            this.AddListUnaryOp(this.Invert, (x) => x.inverse);
            this.AddListUnaryOp(this.All, (x) => x.all);
            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());
            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());
            this.AddListUnaryOp(this.Count, (x) => x.Count);
            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);
            let divertTargetsEqual = (d1, d2) => (d1.Equals(d2) ? 1 : 0);
            let divertTargetsNotEqual = (d1, d2) => d1.Equals(d2) ? 0 : 1;
            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);
            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);
        }
    }
    AddOpFuncForType(valType, op) {
        if (this._operationFuncs == null) {
            this._operationFuncs = new Map();
        }
        this._operationFuncs.set(valType, op);
    }
    static AddOpToNativeFunc(name, args, valType, op) {
        if (this._nativeFunctions === null)
            return NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
        let nativeFunc = this._nativeFunctions.get(name);
        if (!nativeFunc) {
            nativeFunc = new NativeFunctionCall(name, args);
            this._nativeFunctions.set(name, nativeFunc);
        }
        nativeFunc.AddOpFuncForType(valType, op);
    }
    static AddIntBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);
    }
    static AddIntUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);
    }
    static AddFloatBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);
    }
    static AddFloatUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);
    }
    static AddStringBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);
    }
    static AddListBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);
    }
    static AddListUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);
    }
    toString() {
        return 'Native "' + this.name + '"';
    }
}
exports.NativeFunctionCall = NativeFunctionCall;
NativeFunctionCall.Add = "+";
NativeFunctionCall.Subtract = "-";
NativeFunctionCall.Divide = "/";
NativeFunctionCall.Multiply = "*";
NativeFunctionCall.Mod = "%";
NativeFunctionCall.Negate = "_";
NativeFunctionCall.Equal = "==";
NativeFunctionCall.Greater = ">";
NativeFunctionCall.Less = "<";
NativeFunctionCall.GreaterThanOrEquals = ">=";
NativeFunctionCall.LessThanOrEquals = "<=";
NativeFunctionCall.NotEquals = "!=";
NativeFunctionCall.Not = "!";
NativeFunctionCall.And = "&&";
NativeFunctionCall.Or = "||";
NativeFunctionCall.Min = "MIN";
NativeFunctionCall.Max = "MAX";
NativeFunctionCall.Pow = "POW";
NativeFunctionCall.Floor = "FLOOR";
NativeFunctionCall.Ceiling = "CEILING";
NativeFunctionCall.Int = "INT";
NativeFunctionCall.Float = "FLOAT";
NativeFunctionCall.Has = "?";
NativeFunctionCall.Hasnt = "!?";
NativeFunctionCall.Intersect = "^";
NativeFunctionCall.ListMin = "LIST_MIN";
NativeFunctionCall.ListMax = "LIST_MAX";
NativeFunctionCall.All = "LIST_ALL";
NativeFunctionCall.Count = "LIST_COUNT";
NativeFunctionCall.ValueOfList = "LIST_VALUE";
NativeFunctionCall.Invert = "LIST_INVERT";
NativeFunctionCall._nativeFunctions = null;
//# sourceMappingURL=NativeFunctionCall.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NullException.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/NullException.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.throwNullException = exports.NullException = void 0;
/**
 * In the original C# code, a SystemException would be thrown when passing
 * null to methods expected a valid instance. Javascript has no such
 * concept, but TypeScript will not allow `null` to be passed to methods
 * explicitely requiring a valid type.
 *
 * Whenever TypeScript complain about the possibility of a `null` value,
 * check the offending value and it it's null, throw this exception using
 * `throwNullException(name: string)`.
 */
class NullException extends Error {
}
exports.NullException = NullException;
/**
 * Throw a NullException.
 *
 * @param name a short description of the offending value (often its name within the code).
 */
function throwNullException(name) {
    throw new NullException(`${name} is null or undefined`);
}
exports.throwNullException = throwNullException;
//# sourceMappingURL=NullException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Object.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Object.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkObject = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class InkObject {
    constructor() {
        this.parent = null;
        this._debugMetadata = null;
        this._path = null;
    }
    get debugMetadata() {
        if (this._debugMetadata === null) {
            if (this.parent) {
                return this.parent.debugMetadata;
            }
        }
        return this._debugMetadata;
    }
    set debugMetadata(value) {
        this._debugMetadata = value;
    }
    get ownDebugMetadata() {
        return this._debugMetadata;
    }
    DebugLineNumberOfPath(path) {
        if (path === null)
            return null;
        // Try to get a line number from debug metadata
        let root = this.rootContentContainer;
        if (root) {
            let targetContent = root.ContentAtPath(path).obj;
            if (targetContent) {
                let dm = targetContent.debugMetadata;
                if (dm !== null) {
                    return dm.startLineNumber;
                }
            }
        }
        return null;
    }
    get path() {
        if (this._path == null) {
            if (this.parent == null) {
                this._path = new Path_1.Path();
            }
            else {
                let comps = [];
                let child = this;
                let container = TypeAssertion_1.asOrNull(child.parent, Container_1.Container);
                while (container !== null) {
                    let namedChild = TypeAssertion_1.asINamedContentOrNull(child);
                    if (namedChild != null && namedChild.hasValidName) {
                        comps.unshift(new Path_1.Path.Component(namedChild.name));
                    }
                    else {
                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));
                    }
                    child = container;
                    container = TypeAssertion_1.asOrNull(container.parent, Container_1.Container);
                }
                this._path = new Path_1.Path(comps);
            }
        }
        return this._path;
    }
    ResolvePath(path) {
        if (path === null)
            return NullException_1.throwNullException("path");
        if (path.isRelative) {
            let nearestContainer = TypeAssertion_1.asOrNull(this, Container_1.Container);
            if (nearestContainer === null) {
                Debug_1.Debug.Assert(this.parent !== null, "Can't resolve relative path because we don't have a parent");
                nearestContainer = TypeAssertion_1.asOrNull(this.parent, Container_1.Container);
                Debug_1.Debug.Assert(nearestContainer !== null, "Expected parent to be a container");
                Debug_1.Debug.Assert(path.GetComponent(0).isParent);
                path = path.tail;
            }
            if (nearestContainer === null) {
                return NullException_1.throwNullException("nearestContainer");
            }
            return nearestContainer.ContentAtPath(path);
        }
        else {
            let contentContainer = this.rootContentContainer;
            if (contentContainer === null) {
                return NullException_1.throwNullException("contentContainer");
            }
            return contentContainer.ContentAtPath(path);
        }
    }
    ConvertPathToRelative(globalPath) {
        let ownPath = this.path;
        let minPathLength = Math.min(globalPath.length, ownPath.length);
        let lastSharedPathCompIndex = -1;
        for (let i = 0; i < minPathLength; ++i) {
            let ownComp = ownPath.GetComponent(i);
            let otherComp = globalPath.GetComponent(i);
            if (ownComp.Equals(otherComp)) {
                lastSharedPathCompIndex = i;
            }
            else {
                break;
            }
        }
        // No shared path components, so just use global path
        if (lastSharedPathCompIndex == -1)
            return globalPath;
        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;
        let newPathComps = [];
        for (let up = 0; up < numUpwardsMoves; ++up)
            newPathComps.push(Path_1.Path.Component.ToParent());
        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)
            newPathComps.push(globalPath.GetComponent(down));
        let relativePath = new Path_1.Path(newPathComps, true);
        return relativePath;
    }
    CompactPathString(otherPath) {
        let globalPathStr = null;
        let relativePathStr = null;
        if (otherPath.isRelative) {
            relativePathStr = otherPath.componentsString;
            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;
        }
        else {
            let relativePath = this.ConvertPathToRelative(otherPath);
            relativePathStr = relativePath.componentsString;
            globalPathStr = otherPath.componentsString;
        }
        if (relativePathStr.length < globalPathStr.length)
            return relativePathStr;
        else
            return globalPathStr;
    }
    get rootContentContainer() {
        let ancestor = this;
        while (ancestor.parent) {
            ancestor = ancestor.parent;
        }
        return TypeAssertion_1.asOrNull(ancestor, Container_1.Container);
    }
    Copy() {
        throw Error("Not Implemented: Doesn't support copying");
    }
    // SetChild works slightly diferently in the js implementation.
    // Since we can't pass an objets property by reference, we instead pass
    // the object and the property string.
    // TODO: This method can probably be rewritten with type-safety in mind.
    SetChild(obj, prop, value) {
        if (obj[prop])
            obj[prop] = null;
        obj[prop] = value;
        if (obj[prop])
            obj[prop].parent = this;
    }
}
exports.InkObject = InkObject;
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PRNG.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/PRNG.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PRNG = void 0;
// Taken from https://gist.github.com/blixt/f17b47c62508be59987b
// Ink uses a seedable PRNG of which there is none in native javascript.
class PRNG {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0)
            this.seed += 2147483646;
    }
    next() {
        return (this.seed = (this.seed * 16807) % 2147483647);
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}
exports.PRNG = PRNG;
//# sourceMappingURL=PRNG.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Path.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
class Path {
    constructor() {
        this._components = [];
        this._componentsString = null;
        this._isRelative = false;
        if (typeof arguments[0] == "string") {
            let componentsString = arguments[0];
            this.componentsString = componentsString;
        }
        else if (arguments[0] instanceof Path.Component &&
            arguments[1] instanceof Path) {
            let head = arguments[0];
            let tail = arguments[1];
            this._components.push(head);
            this._components = this._components.concat(tail._components);
        }
        else if (arguments[0] instanceof Array) {
            let head = arguments[0];
            let relative = !!arguments[1];
            this._components = this._components.concat(head);
            this._isRelative = relative;
        }
    }
    get isRelative() {
        return this._isRelative;
    }
    get componentCount() {
        return this._components.length;
    }
    get head() {
        if (this._components.length > 0) {
            return this._components[0];
        }
        else {
            return null;
        }
    }
    get tail() {
        if (this._components.length >= 2) {
            // careful, the original code uses length-1 here. This is because the second argument of
            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index
            let tailComps = this._components.slice(1, this._components.length);
            return new Path(tailComps);
        }
        else {
            return Path.self;
        }
    }
    get length() {
        return this._components.length;
    }
    get lastComponent() {
        let lastComponentIdx = this._components.length - 1;
        if (lastComponentIdx >= 0) {
            return this._components[lastComponentIdx];
        }
        else {
            return null;
        }
    }
    get containsNamedComponent() {
        for (let i = 0, l = this._components.length; i < l; i++) {
            if (!this._components[i].isIndex) {
                return true;
            }
        }
        return false;
    }
    static get self() {
        let path = new Path();
        path._isRelative = true;
        return path;
    }
    GetComponent(index) {
        return this._components[index];
    }
    PathByAppendingPath(pathToAppend) {
        let p = new Path();
        let upwardMoves = 0;
        for (let i = 0; i < pathToAppend._components.length; ++i) {
            if (pathToAppend._components[i].isParent) {
                upwardMoves++;
            }
            else {
                break;
            }
        }
        for (let i = 0; i < this._components.length - upwardMoves; ++i) {
            p._components.push(this._components[i]);
        }
        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {
            p._components.push(pathToAppend._components[i]);
        }
        return p;
    }
    get componentsString() {
        if (this._componentsString == null) {
            this._componentsString = this._components.join(".");
            if (this.isRelative)
                this._componentsString = "." + this._componentsString;
        }
        return this._componentsString;
    }
    set componentsString(value) {
        this._components.length = 0;
        this._componentsString = value;
        if (this._componentsString == null || this._componentsString == "")
            return;
        if (this._componentsString[0] == ".") {
            this._isRelative = true;
            this._componentsString = this._componentsString.substring(1);
        }
        let componentStrings = this._componentsString.split(".");
        for (let str of componentStrings) {
            // we need to distinguish between named components that start with a number, eg "42somewhere", and indexed components
            // the normal parseInt won't do for the detection because it's too relaxed.
            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
            if (/^(\-|\+)?([0-9]+|Infinity)$/.test(str)) {
                this._components.push(new Path.Component(parseInt(str)));
            }
            else {
                this._components.push(new Path.Component(str));
            }
        }
    }
    toString() {
        return this.componentsString;
    }
    Equals(otherPath) {
        if (otherPath == null)
            return false;
        if (otherPath._components.length != this._components.length)
            return false;
        if (otherPath.isRelative != this.isRelative)
            return false;
        // the original code uses SequenceEqual here, so we need to iterate over the components manually.
        for (let i = 0, l = otherPath._components.length; i < l; i++) {
            // it's not quite clear whether this test should use Equals or a simple == operator,
            // see https://github.com/y-lohse/inkjs/issues/22
            if (!otherPath._components[i].Equals(this._components[i]))
                return false;
        }
        return true;
    }
    PathByAppendingComponent(c) {
        let p = new Path();
        p._components.push.apply(p._components, this._components);
        p._components.push(c);
        return p;
    }
}
exports.Path = Path;
Path.parentId = "^";
(function (Path) {
    class Component {
        constructor(indexOrName) {
            this.index = -1;
            this.name = null;
            if (typeof indexOrName == "string") {
                this.name = indexOrName;
            }
            else {
                this.index = indexOrName;
            }
        }
        get isIndex() {
            return this.index >= 0;
        }
        get isParent() {
            return this.name == Path.parentId;
        }
        static ToParent() {
            return new Component(Path.parentId);
        }
        toString() {
            if (this.isIndex) {
                return this.index.toString();
            }
            else {
                return this.name;
            }
        }
        Equals(otherComp) {
            if (otherComp != null && otherComp.isIndex == this.isIndex) {
                if (this.isIndex) {
                    return this.index == otherComp.index;
                }
                else {
                    return this.name == otherComp.name;
                }
            }
            return false;
        }
    }
    Path.Component = Component;
})(Path = exports.Path || (exports.Path = {}));
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Pointer.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/Pointer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class Pointer {
    constructor() {
        this.container = null;
        this.index = -1;
        if (arguments.length === 2) {
            this.container = arguments[0];
            this.index = arguments[1];
        }
    }
    Resolve() {
        if (this.index < 0)
            return this.container;
        if (this.container == null)
            return null;
        if (this.container.content.length == 0)
            return this.container;
        if (this.index >= this.container.content.length)
            return null;
        return this.container.content[this.index];
    }
    get isNull() {
        return this.container == null;
    }
    get path() {
        if (this.isNull)
            return null;
        if (this.index >= 0)
            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));
        else
            return this.container.path;
    }
    toString() {
        if (!this.container)
            return "Ink Pointer (null)";
        return ("Ink Pointer -> " +
            this.container.path.toString() +
            " -- index " +
            this.index);
    }
    // This method does not exist in the original C# code, but is here to maintain the
    // value semantics of Pointer.
    copy() {
        return new Pointer(this.container, this.index);
    }
    static StartOf(container) {
        return new Pointer(container, 0);
    }
    static get Null() {
        return new Pointer(null, -1);
    }
}
exports.Pointer = Pointer;
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PushPop.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/PushPop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPopType = void 0;
var PushPopType;
(function (PushPopType) {
    PushPopType[PushPopType["Tunnel"] = 0] = "Tunnel";
    PushPopType[PushPopType["Function"] = 1] = "Function";
    PushPopType[PushPopType["FunctionEvaluationFromGame"] = 2] = "FunctionEvaluationFromGame";
})(PushPopType = exports.PushPopType || (exports.PushPopType = {}));
//# sourceMappingURL=PushPop.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SearchResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/SearchResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
class SearchResult {
    constructor() {
        this.obj = null;
        this.approximate = false;
    }
    get correctObj() {
        return this.approximate ? null : this.obj;
    }
    get container() {
        return this.obj instanceof Container_1.Container ? this.obj : null;
    }
    copy() {
        let searchResult = new SearchResult();
        searchResult.obj = this.obj;
        searchResult.approximate = this.approximate;
        return searchResult;
    }
}
exports.SearchResult = SearchResult;
//# sourceMappingURL=SearchResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SimpleJson.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/SimpleJson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleJson = void 0;
class SimpleJson {
    static TextToDictionary(text) {
        return new SimpleJson.Reader(text).ToDictionary();
    }
    static TextToArray(text) {
        return new SimpleJson.Reader(text).ToArray();
    }
}
exports.SimpleJson = SimpleJson;
(function (SimpleJson) {
    class Reader {
        constructor(text) {
            this._rootObject = JSON.parse(text);
        }
        ToDictionary() {
            return this._rootObject;
        }
        ToArray() {
            return this._rootObject;
        }
    }
    SimpleJson.Reader = Reader;
    // In C#, this class writes json tokens directly to a StringWriter or
    // another stream. Here, a temporary hierarchy is created in the form
    // of a javascript object, which is serialised in the `toString` method.
    // See individual methods and properties for more information.
    class Writer {
        constructor() {
            // In addition to `_stateStack` present in the original code,
            // this implementation of SimpleJson use two other stacks and two
            // temporary variables holding the current context.
            // Used to keep track of the current property name being built
            // with `WritePropertyNameStart`, `WritePropertyNameInner` and
            // `WritePropertyNameEnd`.
            this._currentPropertyName = null;
            // Used to keep track of the current string value being built
            // with `WriteStringStart`, `WriteStringInner` and
            // `WriteStringEnd`.
            this._currentString = null;
            this._stateStack = [];
            // Keep track of the current collection being built (either an array
            // or an object). For instance, at the '?' step during the hiarchy
            // creation, this hierarchy:
            // [3, {a: [b, ?]}] will have this corresponding stack:
            // (bottom) [Array, Object, Array] (top)
            this._collectionStack = [];
            // Keep track of the current property being assigned. For instance, at
            // the '?' step during the hiarchy creation, this hierarchy:
            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:
            // (bottom) [a, c] (top)
            this._propertyNameStack = [];
            // Object containing the entire hiearchy.
            this._jsonObject = null;
        }
        WriteObject(inner) {
            this.WriteObjectStart();
            inner(this);
            this.WriteObjectEnd();
        }
        // Add a new object.
        WriteObjectStart() {
            this.StartNewObject(true);
            let newObject = {};
            if (this.state === SimpleJson.Writer.State.Property) {
                // This object is created as the value of a property,
                // inside an other object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This object is created as the child of an array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This object is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));
        }
        WriteObjectEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Write a property name / value pair to the current object.
        WriteProperty(name, innerOrContent) {
            this.WritePropertyStart(name);
            if (arguments[1] instanceof Function) {
                let inner = arguments[1];
                inner(this);
            }
            else {
                let content = arguments[1];
                this.Write(content);
            }
            this.WritePropertyEnd();
        }
        // Int and Float are separate calls, since there both are
        // numbers in JavaScript, but need to be handled differently.
        WriteIntProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteInt(content);
            this.WritePropertyEnd();
        }
        WriteFloatProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteFloat(content);
            this.WritePropertyEnd();
        }
        // Prepare a new property name, which will be use to add the
        // new object when calling _addToCurrentObject() from a Write
        // method.
        WritePropertyStart(name) {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._propertyNameStack.push(name);
            this.IncrementChildCount();
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
        }
        WritePropertyEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Property);
            this.Assert(this.childCount === 1);
            this._stateStack.pop();
        }
        // Prepare a new property name, except this time, the property name
        // will be created by concatenating all the strings passed to
        // WritePropertyNameInner.
        WritePropertyNameStart() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this.IncrementChildCount();
            this._currentPropertyName = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));
        }
        WritePropertyNameEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._propertyNameStack.push(this._currentPropertyName);
            this._currentPropertyName = null;
            this._stateStack.pop();
        }
        WritePropertyNameInner(str) {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._currentPropertyName += str;
        }
        // Add a new array.
        WriteArrayStart() {
            this.StartNewObject(true);
            let newObject = [];
            if (this.state === SimpleJson.Writer.State.Property) {
                // This array is created as the value of a property,
                // inside an object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This array is created as the child of another array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This array is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));
        }
        WriteArrayEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Array);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Add the value to the appropriate collection (array / object), given the current
        // context.
        Write(value, escape = true) {
            if (value === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this.StartNewObject(false);
            this._addToCurrentObject(value);
        }
        WriteInt(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            // Math.floor is used as a precaution:
            //     1. to ensure that the value is written as an integer
            //        (without a fractional part -> 1 instead of 1.0), even
            //        though it should be the default behaviour of
            //        JSON.serialize;
            //     2. to ensure that if a floating number is passed
            //        accidentally, it's converted to an integer.
            //
            // This guarantees savegame compatibility with the reference
            // implementation.
            this._addToCurrentObject(Math.floor(value));
        }
        // Since JSON doesn't support NaN and Infinity, these values
        // are converted here.
        WriteFloat(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            if (value == Number.POSITIVE_INFINITY) {
                this._addToCurrentObject(3.4e38);
            }
            else if (value == Number.NEGATIVE_INFINITY) {
                this._addToCurrentObject(-3.4e38);
            }
            else if (isNaN(value)) {
                this._addToCurrentObject(0.0);
            }
            else {
                this._addToCurrentObject(value);
            }
        }
        WriteNull() {
            this.StartNewObject(false);
            this._addToCurrentObject(null);
        }
        // Prepare a string before adding it to the current collection in
        // WriteStringEnd(). The string will be a concatenation of all the
        // strings passed to WriteStringInner.
        WriteStringStart() {
            this.StartNewObject(false);
            this._currentString = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));
        }
        WriteStringEnd() {
            this.Assert(this.state == SimpleJson.Writer.State.String);
            this._stateStack.pop();
            this._addToCurrentObject(this._currentString);
            this._currentString = null;
        }
        WriteStringInner(str, escape = true) {
            this.Assert(this.state === SimpleJson.Writer.State.String);
            if (str === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this._currentString += str;
        }
        // Serialise the root object into a JSON string.
        ToString() {
            if (this._jsonObject === null) {
                return "";
            }
            return JSON.stringify(this._jsonObject);
        }
        // Prepare the state stack when adding new objects / values.
        StartNewObject(container) {
            if (container) {
                this.Assert(this.state === SimpleJson.Writer.State.None ||
                    this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            else {
                this.Assert(this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(this.childCount === 0);
            }
            if (this.state === SimpleJson.Writer.State.Array ||
                this.state === SimpleJson.Writer.State.Property) {
                this.IncrementChildCount();
            }
        }
        // These getters peek all the different stacks.
        get state() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].type;
            }
            else {
                return SimpleJson.Writer.State.None;
            }
        }
        get childCount() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].childCount;
            }
            else {
                return 0;
            }
        }
        get currentCollection() {
            if (this._collectionStack.length > 0) {
                return this._collectionStack[this._collectionStack.length - 1];
            }
            else {
                return null;
            }
        }
        get currentPropertyName() {
            if (this._propertyNameStack.length > 0) {
                return this._propertyNameStack[this._propertyNameStack.length - 1];
            }
            else {
                return null;
            }
        }
        IncrementChildCount() {
            this.Assert(this._stateStack.length > 0);
            let currEl = this._stateStack.pop();
            currEl.childCount++;
            this._stateStack.push(currEl);
        }
        Assert(condition) {
            if (!condition)
                throw Error("Assert failed while writing JSON");
        }
        // This method did not exist in the original C# code. It adds
        // the given value to the current collection (used by Write methods).
        _addToCurrentObject(value) {
            this.Assert(this.currentCollection !== null);
            if (this.state === SimpleJson.Writer.State.Array) {
                this.Assert(Array.isArray(this.currentCollection));
                this.currentCollection.push(value);
            }
            else if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(!Array.isArray(this.currentCollection));
                this.Assert(this.currentPropertyName !== null);
                this.currentCollection[this.currentPropertyName] = value;
                this._propertyNameStack.pop();
            }
        }
    }
    SimpleJson.Writer = Writer;
    (function (Writer) {
        let State;
        (function (State) {
            State[State["None"] = 0] = "None";
            State[State["Object"] = 1] = "Object";
            State[State["Array"] = 2] = "Array";
            State[State["Property"] = 3] = "Property";
            State[State["PropertyName"] = 4] = "PropertyName";
            State[State["String"] = 5] = "String";
        })(State = Writer.State || (Writer.State = {}));
        class StateElement {
            constructor(type) {
                this.type = SimpleJson.Writer.State.None;
                this.childCount = 0;
                this.type = type;
            }
        }
        Writer.StateElement = StateElement;
    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));
})(SimpleJson = exports.SimpleJson || (exports.SimpleJson = {}));
//# sourceMappingURL=SimpleJson.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StatePatch.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StatePatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePatch = void 0;
class StatePatch {
    constructor() {
        this._changedVariables = new Set();
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        if (arguments.length === 1 && arguments[0] !== null) {
            let toCopy = arguments[0];
            this._globals = new Map(toCopy._globals);
            this._changedVariables = new Set(toCopy._changedVariables);
            this._visitCounts = new Map(toCopy._visitCounts);
            this._turnIndices = new Map(toCopy._turnIndices);
        }
        else {
            this._globals = new Map();
            this._changedVariables = new Set();
            this._visitCounts = new Map();
            this._turnIndices = new Map();
        }
    }
    get globals() {
        return this._globals;
    }
    get changedVariables() {
        return this._changedVariables;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    TryGetGlobal(name, /* out */ value) {
        if (name !== null && this._globals.has(name)) {
            return { result: this._globals.get(name), exists: true };
        }
        return { result: value, exists: false };
    }
    SetGlobal(name, value) {
        this._globals.set(name, value);
    }
    AddChangedVariable(name) {
        return this._changedVariables.add(name);
    }
    TryGetVisitCount(container, /* out */ count) {
        if (this._visitCounts.has(container)) {
            return { result: this._visitCounts.get(container), exists: true };
        }
        return { result: count, exists: false };
    }
    SetVisitCount(container, count) {
        this._visitCounts.set(container, count);
    }
    SetTurnIndex(container, index) {
        this._turnIndices.set(container, index);
    }
    TryGetTurnIndex(container, /* out */ index) {
        if (this._turnIndices.has(container)) {
            return { result: this._turnIndices.get(container), exists: true };
        }
        return { result: index, exists: false };
    }
}
exports.StatePatch = StatePatch;
//# sourceMappingURL=StatePatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StopWatch.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/StopWatch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopwatch = void 0;
// This is simple replacement of the Stopwatch class from the .NET Framework.
// The original class can count time with much more accuracy than the Javascript version.
// It might be worth considering using `window.performance` in the browser
// or `process.hrtime()` in node.
class Stopwatch {
    constructor() {
        this.startTime = undefined;
    }
    get ElapsedMilliseconds() {
        if (typeof this.startTime === "undefined") {
            return 0;
        }
        return new Date().getTime() - this.startTime;
    }
    Start() {
        this.startTime = new Date().getTime();
    }
    Stop() {
        this.startTime = undefined;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=StopWatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Story.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Story.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Story = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const StoryState_1 = __webpack_require__(/*! ./StoryState */ "./node_modules/inkjs/engine/StoryState.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const StopWatch_1 = __webpack_require__(/*! ./StopWatch */ "./node_modules/inkjs/engine/StopWatch.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
var InkList_2 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
Object.defineProperty(exports, "InkList", { enumerable: true, get: function () { return InkList_2.InkList; } });
if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return (typeof nVal === "number" &&
            isFinite(nVal) &&
            nVal > -9007199254740992 &&
            nVal < 9007199254740992 &&
            Math.floor(nVal) === nVal);
    };
}
class Story extends Object_1.InkObject {
    constructor() {
        super();
        this.inkVersionMinimumCompatible = 18;
        this._prevContainers = [];
        this.allowExternalFunctionFallbacks = false;
        this._listDefinitions = null;
        this._variableObservers = null;
        this._hasValidatedExternals = false;
        this._temporaryEvaluationContainer = null;
        this._asyncContinueActive = false;
        this._stateSnapshotAtLastNewline = null;
        this._recursiveContinueCount = 0;
        this._asyncSaving = false;
        this._profiler = null; // TODO: Profiler
        // Discrimination between constructors
        let contentContainer;
        let lists = null;
        let json = null;
        if (arguments[0] instanceof Container_1.Container) {
            contentContainer = arguments[0];
            if (typeof arguments[1] !== "undefined") {
                lists = arguments[1];
            }
            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
            this._mainContentContainer = contentContainer;
            // ------
        }
        else {
            if (typeof arguments[0] === "string") {
                let jsonString = arguments[0];
                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);
            }
            else {
                json = arguments[0];
            }
        }
        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
        if (lists != null)
            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);
        this._externals = new Map();
        // ------
        // ------ Story(string jsonString) : this((Container)null)
        if (json !== null) {
            let rootObject = json;
            let versionObj = rootObject["inkVersion"];
            if (versionObj == null)
                throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");
            let formatFromFile = parseInt(versionObj);
            if (formatFromFile > Story.inkVersionCurrent) {
                throw new Error("Version of ink used to build story was newer than the current version of the engine");
            }
            else if (formatFromFile < this.inkVersionMinimumCompatible) {
                throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");
            }
            else if (formatFromFile != Story.inkVersionCurrent) {
                console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");
            }
            let rootToken = rootObject["root"];
            if (rootToken == null)
                throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");
            let listDefsObj;
            if ((listDefsObj = rootObject["listDefs"])) {
                this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);
            }
            this._mainContentContainer = TypeAssertion_1.asOrThrows(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);
            this.ResetState();
        }
        // ------
    }
    get currentChoices() {
        let choices = [];
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        for (let c of this._state.currentChoices) {
            if (!c.isInvisibleDefault) {
                c.index = choices.length;
                choices.push(c);
            }
        }
        return choices;
    }
    get currentText() {
        this.IfAsyncWeCant("call currentText since it's a work in progress");
        return this.state.currentText;
    }
    get currentTags() {
        this.IfAsyncWeCant("call currentTags since it's a work in progress");
        return this.state.currentTags;
    }
    get currentErrors() {
        return this.state.currentErrors;
    }
    get currentWarnings() {
        return this.state.currentWarnings;
    }
    get hasError() {
        return this.state.hasError;
    }
    get hasWarning() {
        return this.state.hasWarning;
    }
    get variablesState() {
        return this.state.variablesState;
    }
    get listDefinitions() {
        return this._listDefinitions;
    }
    get state() {
        return this._state;
    }
    // TODO: Implement Profiler
    StartProfiling() {
        /* */
    }
    EndProfiling() {
        /* */
    }
    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.
    // Will only return a value if writer was not provided.
    ToJson(writer) {
        let shouldReturn = false;
        if (!writer) {
            shouldReturn = true;
            writer = new SimpleJson_1.SimpleJson.Writer();
        }
        writer.WriteObjectStart();
        writer.WriteIntProperty("inkVersion", Story.inkVersionCurrent);
        writer.WriteProperty("root", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));
        if (this._listDefinitions != null) {
            writer.WritePropertyStart("listDefs");
            writer.WriteObjectStart();
            for (let def of this._listDefinitions.lists) {
                writer.WritePropertyStart(def.name);
                writer.WriteObjectStart();
                for (let [key, value] of def.items) {
                    let item = InkList_1.InkListItem.fromSerializedKey(key);
                    let val = value;
                    writer.WriteIntProperty(item.itemName, val);
                }
                writer.WriteObjectEnd();
                writer.WritePropertyEnd();
            }
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        if (shouldReturn)
            return writer.ToString();
    }
    ResetState() {
        this.IfAsyncWeCant("ResetState");
        this._state = new StoryState_1.StoryState(this);
        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));
        this.ResetGlobals();
    }
    ResetErrors() {
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ResetErrors();
    }
    ResetCallstack() {
        this.IfAsyncWeCant("ResetCallstack");
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ForceEnd();
    }
    ResetGlobals() {
        if (this._mainContentContainer.namedContent.get("global decl")) {
            let originalPointer = this.state.currentPointer.copy();
            this.ChoosePath(new Path_1.Path("global decl"), false);
            this.ContinueInternal();
            this.state.currentPointer = originalPointer;
        }
        this.state.variablesState.SnapshotDefaultGlobals();
    }
    Continue() {
        this.ContinueAsync(0);
        return this.currentText;
    }
    get canContinue() {
        return this.state.canContinue;
    }
    get asyncContinueComplete() {
        return !this._asyncContinueActive;
    }
    ContinueAsync(millisecsLimitAsync) {
        if (!this._hasValidatedExternals)
            this.ValidateExternalBindings();
        this.ContinueInternal(millisecsLimitAsync);
    }
    ContinueInternal(millisecsLimitAsync = 0) {
        if (this._profiler != null)
            this._profiler.PreContinue();
        let isAsyncTimeLimited = millisecsLimitAsync > 0;
        this._recursiveContinueCount++;
        if (!this._asyncContinueActive) {
            this._asyncContinueActive = isAsyncTimeLimited;
            if (!this.canContinue) {
                throw new StoryException_1.StoryException("Can't continue - should check canContinue before calling Continue");
            }
            this._state.didSafeExit = false;
            this._state.ResetOutput();
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = true;
        }
        let durationStopwatch = new StopWatch_1.Stopwatch();
        durationStopwatch.Start();
        let outputStreamEndsInNewline = false;
        do {
            try {
                outputStreamEndsInNewline = this.ContinueSingleStep();
            }
            catch (e) {
                if (!(e instanceof StoryException_1.StoryException))
                    throw e;
                this.AddError(e.message, undefined, e.useEndLineNumber);
                break;
            }
            if (outputStreamEndsInNewline)
                break;
            if (this._asyncContinueActive &&
                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {
                break;
            }
        } while (this.canContinue);
        durationStopwatch.Stop();
        if (outputStreamEndsInNewline || !this.canContinue) {
            if (this._stateSnapshotAtLastNewline !== null) {
                this.RestoreStateSnapshot();
            }
            if (!this.canContinue) {
                if (this.state.callStack.canPopThread)
                    this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");
                if (this.state.generatedChoices.length == 0 &&
                    !this.state.didSafeExit &&
                    this._temporaryEvaluationContainer == null) {
                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))
                        this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))
                        this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");
                    else if (!this.state.callStack.canPop)
                        this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");
                    else
                        this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!");
                }
            }
            this.state.didSafeExit = false;
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = false;
            this._asyncContinueActive = false;
        }
        this._recursiveContinueCount--;
        if (this._profiler != null)
            this._profiler.PostContinue();
    }
    ContinueSingleStep() {
        if (this._profiler != null)
            this._profiler.PreStep();
        this.Step();
        if (this._profiler != null)
            this._profiler.PostStep();
        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {
            this.TryFollowDefaultInvisibleChoice();
        }
        if (this._profiler != null)
            this._profiler.PreSnapshot();
        if (!this.state.inStringEvaluation) {
            if (this._stateSnapshotAtLastNewline !== null) {
                if (this._stateSnapshotAtLastNewline.currentTags === null) {
                    return NullException_1.throwNullException("this._stateAtLastNewline.currentTags");
                }
                if (this.state.currentTags === null) {
                    return NullException_1.throwNullException("this.state.currentTags");
                }
                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);
                if (change == Story.OutputStateChange.ExtendedBeyondNewline) {
                    this.RestoreStateSnapshot();
                    return true;
                }
                else if (change == Story.OutputStateChange.NewlineRemoved) {
                    this.DiscardSnapshot();
                }
            }
            if (this.state.outputStreamEndsInNewline) {
                if (this.canContinue) {
                    if (this._stateSnapshotAtLastNewline == null)
                        this.StateSnapshot();
                }
                else {
                    this.DiscardSnapshot();
                }
            }
        }
        if (this._profiler != null)
            this._profiler.PostSnapshot();
        return false;
    }
    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {
        if (prevText === null) {
            return NullException_1.throwNullException("prevText");
        }
        if (currText === null) {
            return NullException_1.throwNullException("currText");
        }
        let newlineStillExists = currText.length >= prevText.length &&
            currText.charAt(prevText.length - 1) == "\n";
        if (prevTagCount == currTagCount &&
            prevText.length == currText.length &&
            newlineStillExists)
            return Story.OutputStateChange.NoChange;
        if (!newlineStillExists) {
            return Story.OutputStateChange.NewlineRemoved;
        }
        if (currTagCount > prevTagCount)
            return Story.OutputStateChange.ExtendedBeyondNewline;
        for (let i = prevText.length; i < currText.length; i++) {
            let c = currText.charAt(i);
            if (c != " " && c != "\t") {
                return Story.OutputStateChange.ExtendedBeyondNewline;
            }
        }
        return Story.OutputStateChange.NoChange;
    }
    ContinueMaximally() {
        this.IfAsyncWeCant("ContinueMaximally");
        let sb = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            sb.Append(this.Continue());
        }
        return sb.toString();
    }
    ContentAtPath(path) {
        return this.mainContentContainer.ContentAtPath(path);
    }
    KnotContainerWithName(name) {
        let namedContainer = this.mainContentContainer.namedContent.get(name);
        if (namedContainer instanceof Container_1.Container)
            return namedContainer;
        else
            return null;
    }
    PointerAtPath(path) {
        if (path.length == 0)
            return Pointer_1.Pointer.Null;
        let p = new Pointer_1.Pointer();
        let pathLengthToUse = path.length;
        let result = null;
        if (path.lastComponent === null) {
            return NullException_1.throwNullException("path.lastComponent");
        }
        if (path.lastComponent.isIndex) {
            pathLengthToUse = path.length - 1;
            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);
            p.container = result.container;
            p.index = path.lastComponent.index;
        }
        else {
            result = this.mainContentContainer.ContentAtPath(path);
            p.container = result.container;
            p.index = -1;
        }
        if (result.obj == null ||
            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {
            this.Error("Failed to find content at path '" +
                path +
                "', and no approximation of it was possible.");
        }
        else if (result.approximate)
            this.Warning("Failed to find content at path '" +
                path +
                "', so it was approximated to: '" +
                result.obj.path +
                "'.");
        return p;
    }
    StateSnapshot() {
        this._stateSnapshotAtLastNewline = this._state;
        this._state = this._state.CopyAndStartPatching();
    }
    RestoreStateSnapshot() {
        if (this._stateSnapshotAtLastNewline === null) {
            NullException_1.throwNullException("_stateSnapshotAtLastNewline");
        }
        this._stateSnapshotAtLastNewline.RestoreAfterPatch();
        this._state = this._stateSnapshotAtLastNewline;
        this._stateSnapshotAtLastNewline = null;
        if (!this._asyncSaving) {
            this._state.ApplyAnyPatch();
        }
    }
    DiscardSnapshot() {
        if (!this._asyncSaving)
            this._state.ApplyAnyPatch();
        this._stateSnapshotAtLastNewline = null;
    }
    CopyStateForBackgroundThreadSave() {
        this.IfAsyncWeCant("start saving on a background thread");
        if (this._asyncSaving)
            throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");
        let stateToSave = this._state;
        this._state = this._state.CopyAndStartPatching();
        this._asyncSaving = true;
        return stateToSave;
    }
    BackgroundSaveComplete() {
        if (this._stateSnapshotAtLastNewline === null) {
            this._state.ApplyAnyPatch();
        }
        this._asyncSaving = false;
    }
    Step() {
        let shouldAddToStream = true;
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull) {
            return;
        }
        // Container containerToEnter = pointer.Resolve () as Container;
        let containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        while (containerToEnter) {
            this.VisitContainer(containerToEnter, true);
            // No content? the most we can do is step past it
            if (containerToEnter.content.length == 0) {
                break;
            }
            pointer = Pointer_1.Pointer.StartOf(containerToEnter);
            // containerToEnter = pointer.Resolve() as Container;
            containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        }
        this.state.currentPointer = pointer.copy();
        if (this._profiler != null)
            this._profiler.Step(this.state.callStack);
        // Is the current content object:
        //  - Normal content
        //  - Or a logic/flow statement - if so, do it
        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot
        // that was diverted to rather than called as a function)
        let currentContentObj = pointer.Resolve();
        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);
        // Has flow been forced to end by flow control above?
        if (this.state.currentPointer.isNull) {
            return;
        }
        if (isLogicOrFlowControl) {
            shouldAddToStream = false;
        }
        // Choice with condition?
        // var choicePoint = currentContentObj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(currentContentObj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let choice = this.ProcessChoice(choicePoint);
            if (choice) {
                this.state.generatedChoices.push(choice);
            }
            currentContentObj = null;
            shouldAddToStream = false;
        }
        // If the container has no content, then it will be
        // the "content" itself, but we skip over it.
        if (currentContentObj instanceof Container_1.Container) {
            shouldAddToStream = false;
        }
        // Content to add to evaluation stack or the output stream
        if (shouldAddToStream) {
            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific
            // to our current (possibly temporary) context index. And make a copy of the pointer
            // so that we're not editing the original runtime object.
            // var varPointer = currentContentObj as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(currentContentObj, Value_1.VariablePointerValue);
            if (varPointer && varPointer.contextIndex == -1) {
                // Create new object so we're not overwriting the story's own data
                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);
                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);
            }
            // Expression evaluation content
            if (this.state.inExpressionEvaluation) {
                this.state.PushEvaluationStack(currentContentObj);
            }
            // Output stream content (i.e. not expression evaluation)
            else {
                this.state.PushToOutputStream(currentContentObj);
            }
        }
        // Increment the content pointer, following diverts if necessary
        this.NextContent();
        // Starting a thread should be done after the increment to the content pointer,
        // so that when returning from the thread, it returns to the content after this instruction.
        // var controlCmd = currentContentObj as ;
        let controlCmd = TypeAssertion_1.asOrNull(currentContentObj, ControlCommand_1.ControlCommand);
        if (controlCmd &&
            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {
            this.state.callStack.PushThread();
        }
    }
    VisitContainer(container, atStart) {
        if (!container.countingAtStartOnly || atStart) {
            if (container.visitsShouldBeCounted)
                this.state.IncrementVisitCountForContainer(container);
            if (container.turnIndexShouldBeCounted)
                this.state.RecordTurnIndexVisitToContainer(container);
        }
    }
    VisitChangedContainersDueToDivert() {
        let previousPointer = this.state.previousPointer.copy();
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull || pointer.index == -1)
            return;
        this._prevContainers.length = 0;
        if (!previousPointer.isNull) {
            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;
            let resolvedPreviousAncestor = previousPointer.Resolve();
            let prevAncestor = TypeAssertion_1.asOrNull(resolvedPreviousAncestor, Container_1.Container) ||
                TypeAssertion_1.asOrNull(previousPointer.container, Container_1.Container);
            while (prevAncestor) {
                this._prevContainers.push(prevAncestor);
                // prevAncestor = prevAncestor.parent as Container;
                prevAncestor = TypeAssertion_1.asOrNull(prevAncestor.parent, Container_1.Container);
            }
        }
        let currentChildOfContainer = pointer.Resolve();
        if (currentChildOfContainer == null)
            return;
        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;
        let currentContainerAncestor = TypeAssertion_1.asOrNull(currentChildOfContainer.parent, Container_1.Container);
        while (currentContainerAncestor &&
            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||
                currentContainerAncestor.countingAtStartOnly)) {
            // Check whether this ancestor container is being entered at the start,
            // by checking whether the child object is the first.
            let enteringAtStart = currentContainerAncestor.content.length > 0 &&
                currentChildOfContainer == currentContainerAncestor.content[0];
            // Mark a visit to this container
            this.VisitContainer(currentContainerAncestor, enteringAtStart);
            currentChildOfContainer = currentContainerAncestor;
            // currentContainerAncestor = currentContainerAncestor.parent as Container;
            currentContainerAncestor = TypeAssertion_1.asOrNull(currentContainerAncestor.parent, Container_1.Container);
        }
    }
    ProcessChoice(choicePoint) {
        let showChoice = true;
        // Don't create choice if choice point doesn't pass conditional
        if (choicePoint.hasCondition) {
            let conditionValue = this.state.PopEvaluationStack();
            if (!this.IsTruthy(conditionValue)) {
                showChoice = false;
            }
        }
        let startText = "";
        let choiceOnlyText = "";
        if (choicePoint.hasChoiceOnlyContent) {
            // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;
            let choiceOnlyStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            choiceOnlyText = choiceOnlyStrVal.value || "";
        }
        if (choicePoint.hasStartContent) {
            // var startStrVal = state.PopEvaluationStack () as StringValue;
            let startStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            startText = startStrVal.value || "";
        }
        // Don't create choice if player has already read this content
        if (choicePoint.onceOnly) {
            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);
            if (visitCount > 0) {
                showChoice = false;
            }
        }
        // We go through the full process of creating the choice above so
        // that we consume the content for it, since otherwise it'll
        // be shown on the output stream.
        if (!showChoice) {
            return null;
        }
        let choice = new Choice_1.Choice();
        choice.targetPath = choicePoint.pathOnChoice;
        choice.sourcePath = choicePoint.path.toString();
        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;
        choice.threadAtGeneration = this.state.callStack.ForkThread();
        choice.text = (startText + choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g, "");
        return choice;
    }
    IsTruthy(obj) {
        let truthy = false;
        if (obj instanceof Value_1.Value) {
            let val = obj;
            if (val instanceof Value_1.DivertTargetValue) {
                let divTarget = val;
                this.Error("Shouldn't use a divert target (to " +
                    divTarget.targetPath +
                    ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
                return false;
            }
            return val.isTruthy;
        }
        return truthy;
    }
    PerformLogicAndFlowControl(contentObj) {
        if (contentObj == null) {
            return false;
        }
        // Divert
        if (contentObj instanceof Divert_1.Divert) {
            let currentDivert = contentObj;
            if (currentDivert.isConditional) {
                let conditionValue = this.state.PopEvaluationStack();
                // False conditional? Cancel divert
                if (!this.IsTruthy(conditionValue))
                    return true;
            }
            if (currentDivert.hasVariableTarget) {
                let varName = currentDivert.variableDivertName;
                let varContents = this.state.variablesState.GetVariableWithName(varName);
                if (varContents == null) {
                    this.Error("Tried to divert using a target from a variable that could not be found (" +
                        varName +
                        ")");
                }
                else if (!(varContents instanceof Value_1.DivertTargetValue)) {
                    // var intContent = varContents as IntValue;
                    let intContent = TypeAssertion_1.asOrNull(varContents, Value_1.IntValue);
                    let errorMessage = "Tried to divert to a target from a variable, but the variable (" +
                        varName +
                        ") didn't contain a divert target, it ";
                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {
                        errorMessage += "was empty/null (the value 0).";
                    }
                    else {
                        errorMessage += "contained '" + varContents + "'.";
                    }
                    this.Error(errorMessage);
                }
                let target = TypeAssertion_1.asOrThrows(varContents, Value_1.DivertTargetValue);
                this.state.divertedPointer = this.PointerAtPath(target.targetPath);
            }
            else if (currentDivert.isExternal) {
                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);
                return true;
            }
            else {
                this.state.divertedPointer = currentDivert.targetPointer.copy();
            }
            if (currentDivert.pushesToStack) {
                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);
            }
            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {
                if (currentDivert &&
                    currentDivert.debugMetadata &&
                    currentDivert.debugMetadata.sourceName != null) {
                    this.Error("Divert target doesn't exist: " +
                        currentDivert.debugMetadata.sourceName);
                }
                else {
                    this.Error("Divert resolution failed: " + currentDivert);
                }
            }
            return true;
        }
        // Start/end an expression evaluation? Or print out the result?
        else if (contentObj instanceof ControlCommand_1.ControlCommand) {
            let evalCommand = contentObj;
            switch (evalCommand.commandType) {
                case ControlCommand_1.ControlCommand.CommandType.EvalStart:
                    this.Assert(this.state.inExpressionEvaluation === false, "Already in expression evaluation?");
                    this.state.inExpressionEvaluation = true;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:
                    this.Assert(this.state.inExpressionEvaluation === true, "Not in expression evaluation mode");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:
                    // If the expression turned out to be empty, there may not be anything on the stack
                    if (this.state.evaluationStack.length > 0) {
                        let output = this.state.PopEvaluationStack();
                        // Functions may evaluate to Void, in which case we skip output
                        if (!(output instanceof Void_1.Void)) {
                            // TODO: Should we really always blanket convert to string?
                            // It would be okay to have numbers in the output stream the
                            // only problem is when exporting text for viewing, it skips over numbers etc.
                            let text = new Value_1.StringValue(output.toString());
                            this.state.PushToOutputStream(text);
                        }
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.NoOp:
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Duplicate:
                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:
                    this.state.PopEvaluationStack();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopFunction:
                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:
                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction
                        ? PushPop_1.PushPopType.Function
                        : PushPop_1.PushPopType.Tunnel;
                    let overrideTunnelReturnTarget = null;
                    if (popType == PushPop_1.PushPopType.Tunnel) {
                        let popped = this.state.PopEvaluationStack();
                        // overrideTunnelReturnTarget = popped as DivertTargetValue;
                        overrideTunnelReturnTarget = TypeAssertion_1.asOrNull(popped, Value_1.DivertTargetValue);
                        if (overrideTunnelReturnTarget === null) {
                            this.Assert(popped instanceof Void_1.Void, "Expected void if ->-> doesn't override target");
                        }
                    }
                    if (this.state.TryExitFunctionEvaluationFromGame()) {
                        break;
                    }
                    else if (this.state.callStack.currentElement.type != popType ||
                        !this.state.callStack.canPop) {
                        let names = new Map();
                        names.set(PushPop_1.PushPopType.Function, "function return statement (~ return)");
                        names.set(PushPop_1.PushPopType.Tunnel, "tunnel onwards statement (->->)");
                        let expected = names.get(this.state.callStack.currentElement.type);
                        if (!this.state.callStack.canPop) {
                            expected = "end of flow (-> END or choice)";
                        }
                        let errorMsg = "Found " + names.get(popType) + ", when expected " + expected;
                        this.Error(errorMsg);
                    }
                    else {
                        this.state.PopCallStack();
                        if (overrideTunnelReturnTarget)
                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.BeginString:
                    this.state.PushToOutputStream(evalCommand);
                    this.Assert(this.state.inExpressionEvaluation === true, "Expected to be in an expression when evaluating a string");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EndString:
                    let contentStackForString = [];
                    let outputCountConsumed = 0;
                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
                        let obj = this.state.outputStream[i];
                        outputCountConsumed++;
                        // var command = obj as ControlCommand;
                        let command = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
                        if (command &&
                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                            break;
                        }
                        if (obj instanceof Value_1.StringValue) {
                            contentStackForString.push(obj);
                        }
                    }
                    // Consume the content that was produced for this string
                    this.state.PopFromOutputStream(outputCountConsumed);
                    // The C# version uses a Stack for contentStackForString, but we're
                    // using a simple array, so we need to reverse it before using it
                    contentStackForString = contentStackForString.reverse();
                    // Build string out of the content we collected
                    let sb = new StringBuilder_1.StringBuilder();
                    for (let c of contentStackForString) {
                        sb.Append(c.toString());
                    }
                    // Return to expression evaluation (from content mode)
                    this.state.inExpressionEvaluation = true;
                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:
                    let choiceCount = this.state.generatedChoices.length;
                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Turns:
                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:
                case ControlCommand_1.ControlCommand.CommandType.ReadCount:
                    let target = this.state.PopEvaluationStack();
                    if (!(target instanceof Value_1.DivertTargetValue)) {
                        let extraNote = "";
                        if (target instanceof Value_1.IntValue)
                            extraNote =
                                ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
                        this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw " +
                            target +
                            extraNote);
                        break;
                    }
                    // var divertTarget = target as DivertTargetValue;
                    let divertTarget = TypeAssertion_1.asOrThrows(target, Value_1.DivertTargetValue);
                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;
                    let container = TypeAssertion_1.asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);
                    let eitherCount;
                    if (container != null) {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = this.state.TurnsSinceForContainer(container);
                        else
                            eitherCount = this.state.VisitCountForContainer(container);
                    }
                    else {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = -1;
                        else
                            eitherCount = 0;
                        this.Warning("Failed to find container for " +
                            evalCommand.toString() +
                            " lookup at " +
                            divertTarget.targetPath.toString());
                    }
                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Random: {
                    let maxInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    let minInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (minInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");
                    if (maxInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (maxInt.value === null) {
                        return NullException_1.throwNullException("maxInt.value");
                    }
                    if (minInt.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    let randomRange = maxInt.value - minInt.value + 1;
                    if (randomRange <= 0)
                        this.Error("RANDOM was called with minimum as " +
                            minInt.value +
                            " and maximum as " +
                            maxInt.value +
                            ". The maximum must be larger");
                    let resultSeed = this.state.storySeed + this.state.previousRandom;
                    let random = new PRNG_1.PRNG(resultSeed);
                    let nextRandom = random.next();
                    let chosenValue = (nextRandom % randomRange) + minInt.value;
                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));
                    // Next random number (rather than keeping the Random object around)
                    this.state.previousRandom = nextRandom;
                    break;
                }
                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:
                    let seed = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (seed == null || seed instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value passed to SEED_RANDOM");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (seed.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    this.state.storySeed = seed.value;
                    this.state.previousRandom = 0;
                    this.state.PushEvaluationStack(new Void_1.Void());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:
                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count
                    this.state.PushEvaluationStack(new Value_1.IntValue(count));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:
                    let shuffleIndex = this.NextSequenceShuffleIndex();
                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.StartThread:
                    // Handled in main step function
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Done:
                    // We may exist in the context of the initial
                    // act of creating the thread, or in the context of
                    // evaluating the content.
                    if (this.state.callStack.canPopThread) {
                        this.state.callStack.PopThread();
                    }
                    // In normal flow - allow safe exit without warning
                    else {
                        this.state.didSafeExit = true;
                        // Stop flow in current thread
                        this.state.currentPointer = Pointer_1.Pointer.Null;
                    }
                    break;
                // Force flow to end completely
                case ControlCommand_1.ControlCommand.CommandType.End:
                    this.state.ForceEnd();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:
                    // var intVal = state.PopEvaluationStack () as IntValue;
                    let intVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    // var listNameVal = state.PopEvaluationStack () as StringValue;
                    let listNameVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
                    if (intVal === null) {
                        throw new StoryException_1.StoryException("Passed non-integer when creating a list element from a numerical value.");
                    }
                    let generatedListValue = null;
                    if (this.listDefinitions === null) {
                        return NullException_1.throwNullException("this.listDefinitions");
                    }
                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);
                    if (foundListDef.exists) {
                        // Originally a primitive type, but here, can be null.
                        // TODO: Replace by default value?
                        if (intVal.value === null) {
                            return NullException_1.throwNullException("minInt.value");
                        }
                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);
                        if (foundItem.exists) {
                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);
                        }
                    }
                    else {
                        throw new StoryException_1.StoryException("Failed to find LIST called " + listNameVal.value);
                    }
                    if (generatedListValue == null)
                        generatedListValue = new Value_1.ListValue();
                    this.state.PushEvaluationStack(generatedListValue);
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRange:
                    let max = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    let min = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    // var targetList = state.PopEvaluationStack () as ListValue;
                    let targetList = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.ListValue);
                    if (targetList === null || min === null || max === null)
                        throw new StoryException_1.StoryException("Expected list, minimum and maximum for LIST_RANGE");
                    if (targetList.value === null) {
                        return NullException_1.throwNullException("targetList.value");
                    }
                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);
                    this.state.PushEvaluationStack(new Value_1.ListValue(result));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {
                    let listVal = this.state.PopEvaluationStack();
                    if (listVal === null)
                        throw new StoryException_1.StoryException("Expected list for LIST_RANDOM");
                    let list = listVal.value;
                    let newList = null;
                    if (list === null) {
                        throw NullException_1.throwNullException("list");
                    }
                    if (list.Count == 0) {
                        newList = new InkList_1.InkList();
                    }
                    else {
                        // Generate a random index for the element to take
                        let resultSeed = this.state.storySeed + this.state.previousRandom;
                        let random = new PRNG_1.PRNG(resultSeed);
                        let nextRandom = random.next();
                        let listItemIndex = nextRandom % list.Count;
                        // This bit is a little different from the original
                        // C# code, since iterators do not work in the same way.
                        // First, we iterate listItemIndex - 1 times, calling next().
                        // The listItemIndex-th time is made outside of the loop,
                        // in order to retrieve the value.
                        let listEnumerator = list.entries();
                        for (let i = 0; i <= listItemIndex - 1; i++) {
                            listEnumerator.next();
                        }
                        let value = listEnumerator.next().value;
                        let randomItem = {
                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),
                            Value: value[1],
                        };
                        // Origin list is simply the origin of the one element
                        if (randomItem.Key.originName === null) {
                            return NullException_1.throwNullException("randomItem.Key.originName");
                        }
                        newList = new InkList_1.InkList(randomItem.Key.originName, this);
                        newList.Add(randomItem.Key, randomItem.Value);
                        this.state.previousRandom = nextRandom;
                    }
                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));
                    break;
                }
                default:
                    this.Error("unhandled ControlCommand: " + evalCommand);
                    break;
            }
            return true;
        }
        // Variable assignment
        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {
            let varAss = contentObj;
            let assignedVal = this.state.PopEvaluationStack();
            this.state.variablesState.Assign(varAss, assignedVal);
            return true;
        }
        // Variable reference
        else if (contentObj instanceof VariableReference_1.VariableReference) {
            let varRef = contentObj;
            let foundValue = null;
            // Explicit read count value
            if (varRef.pathForCount != null) {
                let container = varRef.containerForCount;
                let count = this.state.VisitCountForContainer(container);
                foundValue = new Value_1.IntValue(count);
            }
            // Normal variable reference
            else {
                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);
                if (foundValue == null) {
                    this.Warning("Variable not found: '" +
                        varRef.name +
                        "'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.");
                    foundValue = new Value_1.IntValue(0);
                }
            }
            this.state.PushEvaluationStack(foundValue);
            return true;
        }
        // Native function call
        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {
            let func = contentObj;
            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);
            let result = func.Call(funcParams);
            this.state.PushEvaluationStack(result);
            return true;
        }
        // No control content, must be ordinary content
        return false;
    }
    ChoosePathString(path, resetCallstack = true, args = []) {
        this.IfAsyncWeCant("call ChoosePathString right now");
        if (resetCallstack) {
            this.ResetCallstack();
        }
        else {
            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {
                let funcDetail = "";
                let container = this.state.callStack.currentElement.currentPointer
                    .container;
                if (container != null) {
                    funcDetail = "(" + container.path.toString() + ") ";
                }
                throw new Error("Story was running a function " +
                    funcDetail +
                    "when you called ChoosePathString(" +
                    path +
                    ") - this is almost certainly not not what you want! Full stack trace: \n" +
                    this.state.callStack.callStackTrace);
            }
        }
        this.state.PassArgumentsToEvaluationStack(args);
        this.ChoosePath(new Path_1.Path(path));
    }
    IfAsyncWeCant(activityStr) {
        if (this._asyncContinueActive)
            throw new Error("Can't " +
                activityStr +
                ". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.");
    }
    ChoosePath(p, incrementingTurnIndex = true) {
        this.state.SetChosenPath(p, incrementingTurnIndex);
        // Take a note of newly visited containers for read counts etc
        this.VisitChangedContainersDueToDivert();
    }
    ChooseChoiceIndex(choiceIdx) {
        choiceIdx = choiceIdx;
        let choices = this.currentChoices;
        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, "choice out of range");
        let choiceToChoose = choices[choiceIdx];
        if (choiceToChoose.threadAtGeneration === null) {
            return NullException_1.throwNullException("choiceToChoose.threadAtGeneration");
        }
        if (choiceToChoose.targetPath === null) {
            return NullException_1.throwNullException("choiceToChoose.targetPath");
        }
        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;
        this.ChoosePath(choiceToChoose.targetPath);
    }
    HasFunction(functionName) {
        try {
            return this.KnotContainerWithName(functionName) != null;
        }
        catch (e) {
            return false;
        }
    }
    EvaluateFunction(functionName, args = [], returnTextOutput = false) {
        // EvaluateFunction behaves slightly differently than the C# version.
        // In C#, you can pass a (second) parameter `out textOutput` to get the
        // text outputted by the function. This is not possible in js. Instead,
        // we maintain the regular signature (functionName, args), plus an
        // optional third parameter returnTextOutput. If set to true, we will
        // return both the textOutput and the returned value, as an object.
        this.IfAsyncWeCant("evaluate a function");
        if (functionName == null) {
            throw new Error("Function is null");
        }
        else if (functionName == "" || functionName.trim() == "") {
            throw new Error("Function is empty or white space.");
        }
        let funcContainer = this.KnotContainerWithName(functionName);
        if (funcContainer == null) {
            throw new Error("Function doesn't exist: '" + functionName + "'");
        }
        let outputStreamBefore = [];
        outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);
        this._state.ResetOutput();
        this.state.StartFunctionEvaluationFromGame(funcContainer, args);
        // Evaluate the function, and collect the string output
        let stringOutput = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            stringOutput.Append(this.Continue());
        }
        let textOutput = stringOutput.toString();
        this._state.ResetOutput(outputStreamBefore);
        let result = this.state.CompleteFunctionEvaluationFromGame();
        return returnTextOutput ? { returned: result, output: textOutput } : result;
    }
    EvaluateExpression(exprContainer) {
        let startCallStackHeight = this.state.callStack.elements.length;
        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);
        this._temporaryEvaluationContainer = exprContainer;
        this.state.GoToStart();
        let evalStackHeight = this.state.evaluationStack.length;
        this.Continue();
        this._temporaryEvaluationContainer = null;
        // Should have fallen off the end of the Container, which should
        // have auto-popped, but just in case we didn't for some reason,
        // manually pop to restore the state (including currentPath).
        if (this.state.callStack.elements.length > startCallStackHeight) {
            this.state.PopCallStack();
        }
        let endStackHeight = this.state.evaluationStack.length;
        if (endStackHeight > evalStackHeight) {
            return this.state.PopEvaluationStack();
        }
        else {
            return null;
        }
    }
    CallExternalFunction(funcName, numberOfArguments) {
        if (funcName === null) {
            return NullException_1.throwNullException("funcName");
        }
        let func = this._externals.get(funcName);
        let fallbackFunctionContainer = null;
        let foundExternal = typeof func !== "undefined";
        // Try to use fallback function?
        if (!foundExternal) {
            if (this.allowExternalFunctionFallbacks) {
                fallbackFunctionContainer = this.KnotContainerWithName(funcName);
                this.Assert(fallbackFunctionContainer !== null, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound, and fallback ink function could not be found.");
                // Divert direct into fallback function and we're done
                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);
                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);
                return;
            }
            else {
                this.Assert(false, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound (and ink fallbacks disabled).");
            }
        }
        // Pop arguments
        let args = [];
        for (let i = 0; i < numberOfArguments; ++i) {
            // var poppedObj = state.PopEvaluationStack () as Value;
            let poppedObj = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.Value);
            let valueObj = poppedObj.valueObject;
            args.push(valueObj);
        }
        // Reverse arguments from the order they were popped,
        // so they're the right way round again.
        args.reverse();
        // Run the function!
        let funcResult = func(args);
        // Convert return value (if any) to the a type that the ink engine can use
        let returnObj = null;
        if (funcResult != null) {
            returnObj = Value_1.Value.Create(funcResult);
            this.Assert(returnObj !== null, "Could not create ink value from returned object of type " +
                typeof funcResult);
        }
        else {
            returnObj = new Void_1.Void();
        }
        this.state.PushEvaluationStack(returnObj);
    }
    BindExternalFunctionGeneral(funcName, func) {
        this.IfAsyncWeCant("bind an external function");
        this.Assert(!this._externals.has(funcName), "Function '" + funcName + "' has already been bound.");
        this._externals.set(funcName, func);
    }
    TryCoerce(value) {
        // We're skipping type coercition in this implementation. First of, js
        // is loosely typed, so it's not that important. Secondly, there is no
        // clean way (AFAIK) for the user to describe what type of parameters
        // they expect.
        return value;
    }
    BindExternalFunction(funcName, func) {
        this.Assert(func != null, "Can't bind a null function");
        this.BindExternalFunctionGeneral(funcName, (args) => {
            this.Assert(args.length >= func.length, "External function expected " + func.length + " arguments");
            let coercedArgs = [];
            for (let i = 0, l = args.length; i < l; i++) {
                coercedArgs[i] = this.TryCoerce(args[i]);
            }
            return func.apply(null, coercedArgs);
        });
    }
    UnbindExternalFunction(funcName) {
        this.IfAsyncWeCant("unbind an external a function");
        this.Assert(this._externals.has(funcName), "Function '" + funcName + "' has not been bound.");
        this._externals.delete(funcName);
    }
    ValidateExternalBindings() {
        let c = null;
        let o = null;
        let missingExternals = arguments[1] || new Set();
        if (arguments[0] instanceof Container_1.Container) {
            c = arguments[0];
        }
        if (arguments[0] instanceof Object_1.InkObject) {
            o = arguments[0];
        }
        if (c === null && o === null) {
            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);
            this._hasValidatedExternals = true;
            // No problem! Validation complete
            if (missingExternals.size == 0) {
                this._hasValidatedExternals = true;
            }
            else {
                let message = "Error: Missing function binding for external";
                message += missingExternals.size > 1 ? "s" : "";
                message += ": '";
                message += Array.from(missingExternals).join("', '");
                message += "' ";
                message += this.allowExternalFunctionFallbacks
                    ? ", and no fallback ink function found."
                    : " (ink fallbacks disabled)";
                this.Error(message);
            }
        }
        else if (c != null) {
            for (let innerContent of c.content) {
                let container = innerContent;
                if (container == null || !container.hasValidName)
                    this.ValidateExternalBindings(innerContent, missingExternals);
            }
            for (let [, value] of c.namedContent) {
                this.ValidateExternalBindings(TypeAssertion_1.asOrNull(value, Object_1.InkObject), missingExternals);
            }
        }
        else if (o != null) {
            let divert = TypeAssertion_1.asOrNull(o, Divert_1.Divert);
            if (divert && divert.isExternal) {
                let name = divert.targetPathString;
                if (name === null) {
                    return NullException_1.throwNullException("name");
                }
                if (!this._externals.has(name)) {
                    if (this.allowExternalFunctionFallbacks) {
                        let fallbackFound = this.mainContentContainer.namedContent.has(name);
                        if (!fallbackFound) {
                            missingExternals.add(name);
                        }
                    }
                    else {
                        missingExternals.add(name);
                    }
                }
            }
        }
    }
    ObserveVariable(variableName, observer) {
        this.IfAsyncWeCant("observe a new variable");
        if (this._variableObservers === null)
            this._variableObservers = new Map();
        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))
            throw new StoryException_1.StoryException("Cannot observe variable '" +
                variableName +
                "' because it wasn't declared in the ink story.");
        if (this._variableObservers.has(variableName)) {
            this._variableObservers.get(variableName).push(observer);
        }
        else {
            this._variableObservers.set(variableName, [observer]);
        }
    }
    ObserveVariables(variableNames, observers) {
        for (let i = 0, l = variableNames.length; i < l; i++) {
            this.ObserveVariable(variableNames[i], observers[i]);
        }
    }
    RemoveVariableObserver(observer, specificVariableName) {
        this.IfAsyncWeCant("remove a variable observer");
        if (this._variableObservers === null)
            return;
        if (typeof specificVariableName !== "undefined") {
            if (this._variableObservers.has(specificVariableName)) {
                let observers = this._variableObservers.get(specificVariableName);
                if (observer !== null) {
                    observers.splice(observers.indexOf(observer), 1);
                }
                else {
                    this._variableObservers.delete(specificVariableName);
                }
            }
        }
        else if (observer !== null) {
            let keys = this._variableObservers.keys();
            for (let varName of keys) {
                let observers = this._variableObservers.get(varName);
                observers.splice(observers.indexOf(observer), 1);
            }
        }
    }
    VariableStateDidChangeEvent(variableName, newValueObj) {
        if (this._variableObservers === null)
            return;
        let observers = this._variableObservers.get(variableName);
        if (typeof observers !== "undefined") {
            if (!(newValueObj instanceof Value_1.Value)) {
                throw new Error("Tried to get the value of a variable that isn't a standard type");
            }
            // var val = newValueObj as Value;
            let val = TypeAssertion_1.asOrThrows(newValueObj, Value_1.Value);
            for (let observer of observers) {
                observer(variableName, val.valueObject);
            }
        }
    }
    get globalTags() {
        return this.TagsAtStartOfFlowContainerWithPathString("");
    }
    TagsForContentAtPath(path) {
        return this.TagsAtStartOfFlowContainerWithPathString(path);
    }
    TagsAtStartOfFlowContainerWithPathString(pathString) {
        let path = new Path_1.Path(pathString);
        let flowContainer = this.ContentAtPath(path).container;
        if (flowContainer === null) {
            return NullException_1.throwNullException("flowContainer");
        }
        while (true) {
            let firstContent = flowContainer.content[0];
            if (firstContent instanceof Container_1.Container)
                flowContainer = firstContent;
            else
                break;
        }
        let tags = null;
        for (let c of flowContainer.content) {
            // var tag = c as Runtime.Tag;
            let tag = TypeAssertion_1.asOrNull(c, Tag_1.Tag);
            if (tag) {
                if (tags == null)
                    tags = [];
                tags.push(tag.text);
            }
            else
                break;
        }
        return tags;
    }
    BuildStringOfHierarchy() {
        let sb = new StringBuilder_1.StringBuilder();
        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    BuildStringOfContainer(container) {
        let sb = new StringBuilder_1.StringBuilder();
        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    NextContent() {
        this.state.previousPointer = this.state.currentPointer.copy();
        if (!this.state.divertedPointer.isNull) {
            this.state.currentPointer = this.state.divertedPointer.copy();
            this.state.divertedPointer = Pointer_1.Pointer.Null;
            this.VisitChangedContainersDueToDivert();
            if (!this.state.currentPointer.isNull) {
                return;
            }
        }
        let successfulPointerIncrement = this.IncrementContentPointer();
        if (!successfulPointerIncrement) {
            let didPop = false;
            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {
                this.state.PopCallStack(PushPop_1.PushPopType.Function);
                if (this.state.inExpressionEvaluation) {
                    this.state.PushEvaluationStack(new Void_1.Void());
                }
                didPop = true;
            }
            else if (this.state.callStack.canPopThread) {
                this.state.callStack.PopThread();
                didPop = true;
            }
            else {
                this.state.TryExitFunctionEvaluationFromGame();
            }
            if (didPop && !this.state.currentPointer.isNull) {
                this.NextContent();
            }
        }
    }
    IncrementContentPointer() {
        let successfulIncrement = true;
        let pointer = this.state.callStack.currentElement.currentPointer.copy();
        pointer.index++;
        if (pointer.container === null) {
            return NullException_1.throwNullException("pointer.container");
        }
        while (pointer.index >= pointer.container.content.length) {
            successfulIncrement = false;
            // Container nextAncestor = pointer.container.parent as Container;
            let nextAncestor = TypeAssertion_1.asOrNull(pointer.container.parent, Container_1.Container);
            if (nextAncestor instanceof Container_1.Container === false) {
                break;
            }
            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);
            if (indexInAncestor == -1) {
                break;
            }
            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);
            pointer.index++;
            successfulIncrement = true;
            if (pointer.container === null) {
                return NullException_1.throwNullException("pointer.container");
            }
        }
        if (!successfulIncrement)
            pointer = Pointer_1.Pointer.Null;
        this.state.callStack.currentElement.currentPointer = pointer.copy();
        return successfulIncrement;
    }
    TryFollowDefaultInvisibleChoice() {
        let allChoices = this._state.currentChoices;
        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);
        if (invisibleChoices.length == 0 ||
            allChoices.length > invisibleChoices.length)
            return false;
        let choice = invisibleChoices[0];
        if (choice.targetPath === null) {
            return NullException_1.throwNullException("choice.targetPath");
        }
        if (choice.threadAtGeneration === null) {
            return NullException_1.throwNullException("choice.threadAtGeneration");
        }
        this.state.callStack.currentThread = choice.threadAtGeneration;
        this.ChoosePath(choice.targetPath, false);
        return true;
    }
    NextSequenceShuffleIndex() {
        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;
        let numElementsIntVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
        if (!(numElementsIntVal instanceof Value_1.IntValue)) {
            this.Error("expected number of elements in sequence for shuffle index");
            return 0;
        }
        let seqContainer = this.state.currentPointer.container;
        if (seqContainer === null) {
            return NullException_1.throwNullException("seqContainer");
        }
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (numElementsIntVal.value === null) {
            return NullException_1.throwNullException("numElementsIntVal.value");
        }
        let numElements = numElementsIntVal.value;
        // var seqCountVal = state.PopEvaluationStack () as IntValue;
        let seqCountVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.IntValue);
        let seqCount = seqCountVal.value;
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (seqCount === null) {
            return NullException_1.throwNullException("seqCount");
        }
        let loopIndex = seqCount / numElements;
        let iterationIndex = seqCount % numElements;
        let seqPathStr = seqContainer.path.toString();
        let sequenceHash = 0;
        for (let i = 0, l = seqPathStr.length; i < l; i++) {
            sequenceHash += seqPathStr.charCodeAt(i) || 0;
        }
        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;
        let random = new PRNG_1.PRNG(Math.floor(randomSeed));
        let unpickedIndices = [];
        for (let i = 0; i < numElements; ++i) {
            unpickedIndices.push(i);
        }
        for (let i = 0; i <= iterationIndex; ++i) {
            let chosen = random.next() % unpickedIndices.length;
            let chosenIndex = unpickedIndices[chosen];
            unpickedIndices.splice(chosen, 1);
            if (i == iterationIndex) {
                return chosenIndex;
            }
        }
        throw new Error("Should never reach here");
    }
    Error(message, useEndLineNumber = false) {
        let e = new StoryException_1.StoryException(message);
        e.useEndLineNumber = useEndLineNumber;
        throw e;
    }
    Warning(message) {
        this.AddError(message, true);
    }
    AddError(message, isWarning = false, useEndLineNumber = false) {
        let dm = this.currentDebugMetadata;
        let errorTypeStr = isWarning ? "WARNING" : "ERROR";
        if (dm != null) {
            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": '" +
                    dm.fileName +
                    "' line " +
                    lineNum +
                    ": " +
                    message;
        }
        else if (!this.state.currentPointer.isNull) {
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": (" +
                    this.state.currentPointer +
                    "): " +
                    message;
        }
        else {
            message = "RUNTIME " + errorTypeStr + ": " + message;
        }
        this.state.AddError(message, isWarning);
        // In a broken state don't need to know about any other errors.
        if (!isWarning)
            this.state.ForceEnd();
    }
    Assert(condition, message = null) {
        if (condition == false) {
            if (message == null) {
                message = "Story assert";
            }
            throw new Error(message + " " + this.currentDebugMetadata);
        }
    }
    get currentDebugMetadata() {
        let dm;
        let pointer = this.state.currentPointer;
        if (!pointer.isNull && pointer.Resolve() !== null) {
            dm = pointer.Resolve().debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {
            pointer = this.state.callStack.elements[i].currentPointer;
            if (!pointer.isNull && pointer.Resolve() !== null) {
                dm = pointer.Resolve().debugMetadata;
                if (dm !== null) {
                    return dm;
                }
            }
        }
        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
            let outputObj = this.state.outputStream[i];
            dm = outputObj.debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        return null;
    }
    get mainContentContainer() {
        if (this._temporaryEvaluationContainer) {
            return this._temporaryEvaluationContainer;
        }
        else {
            return this._mainContentContainer;
        }
    }
}
exports.Story = Story;
Story.inkVersionCurrent = 19;
(function (Story) {
    let OutputStateChange;
    (function (OutputStateChange) {
        OutputStateChange[OutputStateChange["NoChange"] = 0] = "NoChange";
        OutputStateChange[OutputStateChange["ExtendedBeyondNewline"] = 1] = "ExtendedBeyondNewline";
        OutputStateChange[OutputStateChange["NewlineRemoved"] = 2] = "NewlineRemoved";
    })(OutputStateChange = Story.OutputStateChange || (Story.OutputStateChange = {}));
})(Story = exports.Story || (exports.Story = {}));
//# sourceMappingURL=Story.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryException.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryException.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryException = void 0;
class StoryException extends Error {
    constructor(message) {
        super(message);
        this.useEndLineNumber = false;
        this.message = message;
        this.name = "StoryException";
    }
}
exports.StoryException = StoryException;
//# sourceMappingURL=StoryException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryState.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryState.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryState = void 0;
const CallStack_1 = __webpack_require__(/*! ./CallStack */ "./node_modules/inkjs/engine/CallStack.js");
const VariablesState_1 = __webpack_require__(/*! ./VariablesState */ "./node_modules/inkjs/engine/VariablesState.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StatePatch_1 = __webpack_require__(/*! ./StatePatch */ "./node_modules/inkjs/engine/StatePatch.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this._patch = null;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this.currentTurnIndex = -1;
        let timeSeed = new Date().getTime();
        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        let writer = new SimpleJson_1.SimpleJson.Writer();
        this.WriteJson(writer);
        return writer.ToString();
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);
        this.LoadJsonObj(jObject);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut;
        if (this._patch !== null) {
            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;
            if (container === null)
                throw new Error("Content at path not found: " + pathString);
            visitCountOut = this._patch.TryGetVisitCount(container, 0);
            if (visitCountOut.exists)
                return visitCountOut.result;
        }
        visitCountOut = TryGetResult_1.tryGetValueFromMap(this._visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    VisitCountForContainer(container) {
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        if (!container.visitsShouldBeCounted) {
            this.story.Error("Read count for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
            return 0;
        }
        if (this._patch !== null) {
            let count = this._patch.TryGetVisitCount(container, 0);
            if (count.exists) {
                return count.result;
            }
        }
        let containerPathStr = container.path.toString();
        let count2 = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count2.exists) {
            return count2.result;
        }
        return 0;
    }
    IncrementVisitCountForContainer(container) {
        if (this._patch !== null) {
            let currCount = this.VisitCountForContainer(container);
            currCount++;
            this._patch.SetVisitCount(container, currCount);
            return;
        }
        let containerPathStr = container.path.toString();
        let count = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count.exists) {
            this._visitCounts.set(containerPathStr, count.result + 1);
        }
        else {
            this._visitCounts.set(containerPathStr, 1);
        }
    }
    RecordTurnIndexVisitToContainer(container) {
        if (this._patch !== null) {
            this._patch.SetTurnIndex(container, this.currentTurnIndex);
            return;
        }
        let containerPathStr = container.path.toString();
        this._turnIndices.set(containerPathStr, this.currentTurnIndex);
    }
    TurnsSinceForContainer(container) {
        if (!container.turnIndexShouldBeCounted) {
            this.story.Error("TURNS_SINCE() for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
        }
        if (this._patch !== null) {
            let index = this._patch.TryGetTurnIndex(container, 0);
            if (index.exists) {
                return this.currentTurnIndex - index.result;
            }
        }
        let containerPathStr = container.path.toString();
        let index2 = TryGetResult_1.tryGetValueFromMap(this._turnIndices, containerPathStr, 0);
        if (index2.exists) {
            return this.currentTurnIndex - index2.result;
        }
        else {
            return -1;
        }
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    set variablesState(value) {
        this._variablesState = value;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    set currentTurnIndex(value) {
        this._currentTurnIndex = value;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException("pointer.path");
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = c == " " || c == "\t";
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != "\n" &&
                    currentWhitespaceStart > 0 &&
                    currentWhitespaceStart != startOfLine) {
                    sb.Append(" ");
                }
                currentWhitespaceStart = -1;
            }
            if (c == "\n")
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    CopyAndStartPatching() {
        let copy = new StoryState(this.story);
        copy._patch = new StatePatch_1.StatePatch(this._patch);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        copy.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy.variablesState = this.variablesState;
        copy.variablesState.callStack = copy.callStack;
        copy.variablesState.patch = copy._patch;
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = this._visitCounts;
        copy._turnIndices = this._turnIndices;
        copy.currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    RestoreAfterPatch() {
        this.variablesState.callStack = this.callStack;
        this.variablesState.patch = this._patch;
    }
    ApplyAnyPatch() {
        if (this._patch === null)
            return;
        this.variablesState.ApplyPatch();
        for (let [key, value] of this._patch.visitCounts)
            this.ApplyCountChanges(key, value, true);
        for (let [key, value] of this._patch.turnIndices)
            this.ApplyCountChanges(key, value, false);
        this._patch = null;
    }
    ApplyCountChanges(container, newCount, isVisit) {
        let counts = isVisit ? this._visitCounts : this._turnIndices;
        counts.set(container.path.toString(), newCount);
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        let hasChoiceThreads = false;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException("c.threadAtGeneration");
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {
                if (!hasChoiceThreads) {
                    hasChoiceThreads = true;
                    writer.WritePropertyStart("choiceThreads");
                    writer.WriteObjectStart();
                }
                writer.WritePropertyStart(c.originalThreadIndex);
                c.threadAtGeneration.WriteJson(writer);
                writer.WritePropertyEnd();
            }
        }
        if (hasChoiceThreads) {
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        // In the following two calls, `WriteJson` is called inside an arrow
        // function to make sure `this` is correctly bound and passed down
        // the call hierarchy.
        writer.WriteProperty("callstackThreads", (w) => this.callStack.WriteJson(w));
        writer.WriteProperty("variablesState", (w) => this.variablesState.WriteJson(w));
        writer.WriteProperty("evalStack", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));
        writer.WriteProperty("outputStream", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream));
        writer.WriteProperty("currentChoices", (w) => {
            w.WriteArrayStart();
            for (let c of this._currentChoices)
                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);
            w.WriteArrayEnd();
        });
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException("divertedPointer");
            }
            writer.WriteProperty("currentDivertTarget", this.divertedPointer.path.componentsString);
        }
        writer.WriteProperty("visitCounts", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));
        writer.WriteProperty("turnIndices", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));
        writer.WriteIntProperty("turnIdx", this.currentTurnIndex);
        writer.WriteIntProperty("storySeed", this.storySeed);
        writer.WriteIntProperty("previousRandom", this.previousRandom);
        writer.WriteIntProperty("inkSaveVersion", this.kInkSaveStateVersion);
        writer.WriteIntProperty("inkFormatVersion", Story_1.Story.inkVersionCurrent);
        writer.WriteObjectEnd();
    }
    LoadJsonObj(value) {
        let jObject = value;
        let jSaveVersion = jObject["inkSaveVersion"];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" +
                jSaveVersion +
                "', but minimum is " +
                this.kMinCompatibleLoadVersion +
                "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject["callstackThreads"], this.story);
        this.variablesState.SetJsonToken(jObject["variablesState"]);
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);
        let currentDivertTargetPath = jObject["currentDivertTarget"];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);
        this.currentTurnIndex = parseInt(jObject["turnIdx"]);
        this.storySeed = parseInt(jObject["storySeed"]);
        this.previousRandom = parseInt(jObject["previousRandom"]);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject["choiceThreads"];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException("single.value");
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue("\n"));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue("\n"));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = str.length - tailLastNewlineIdx - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;
                let g = o instanceof Glue_1.Glue ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null &&
                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException("obj");
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand &&
                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException("rawList");
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException("StoryState.story.listDefinitions");
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException("StoryState def.result");
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException("obj");
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === "undefined") {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error("trying to pop too many objects");
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement
            .functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex) {
            this.currentTurnIndex++;
        }
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === "number" || typeof args[i] === "string")) {
                    throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type ==
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type !=
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException("Expected external function evaluation to be complete. Stack trace: " +
                this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement
            .evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StringBuilder.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/StringBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StringBuilder = void 0;
class StringBuilder {
    constructor(str) {
        str = typeof str !== "undefined" ? str.toString() : "";
        this.string = str;
    }
    get Length() {
        return this.string.length;
    }
    Append(str) {
        if (str !== null) {
            this.string += str;
        }
    }
    AppendLine(str) {
        if (typeof str !== "undefined")
            this.Append(str);
        this.string += "\n";
    }
    AppendFormat(format, ...args) {
        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format
        this.string += format.replace(/{(\d+)}/g, (match, num) => typeof args[num] != "undefined" ? args[num] : match);
    }
    toString() {
        return this.string;
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Tag.js":
/*!******************************************!*\
  !*** ./node_modules/inkjs/engine/Tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Tag extends Object_1.InkObject {
    constructor(tagText) {
        super();
        this.text = tagText.toString() || "";
    }
    toString() {
        return "# " + this.text;
    }
}
exports.Tag = Tag;
//# sourceMappingURL=Tag.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TryGetResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/TryGetResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseFloat = exports.tryParseInt = exports.tryGetValueFromMap = void 0;
function tryGetValueFromMap(map, key, 
/* out */ value) {
    if (map === null) {
        return { result: value, exists: false };
    }
    let val = map.get(key);
    if (typeof val === "undefined") {
        return { result: value, exists: false };
    }
    else {
        return { result: val, exists: true };
    }
}
exports.tryGetValueFromMap = tryGetValueFromMap;
function tryParseInt(value, 
/* out */ defaultValue = 0) {
    let val = parseInt(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseInt = tryParseInt;
function tryParseFloat(value, 
/* out */ defaultValue = 0) {
    let val = parseFloat(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseFloat = tryParseFloat;
//# sourceMappingURL=TryGetResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TypeAssertion.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/TypeAssertion.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isEquatable = exports.nullIfUndefined = exports.asINamedContentOrNull = exports.asNumberOrThrows = exports.asOrThrows = exports.asOrNull = void 0;
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === "number") {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === "undefined") {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function isEquatable(type) {
    return typeof type === "object" && typeof type.Equals === "function";
}
exports.isEquatable = isEquatable;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Value.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Value.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = exports.ListValue = exports.VariablePointerValue = exports.DivertTargetValue = exports.StringValue = exports.FloatValue = exports.IntValue = exports.Value = exports.AbstractValue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class AbstractValue extends Object_1.InkObject {
    static Create(val, preferredNumberType) {
        // This code doesn't exist in upstream and is simply here to enforce
        // the creation of the proper number value.
        // If `preferredNumberType` is not provided or if value doesn't match
        // `preferredNumberType`, this conditional does nothing.
        if (preferredNumberType) {
            if (preferredNumberType === ValueType.Int &&
                Number.isInteger(Number(val))) {
                return new IntValue(Number(val));
            }
            else if (preferredNumberType === ValueType.Float &&
                !isNaN(val)) {
                return new FloatValue(Number(val));
            }
        }
        // Implicitly convert bools into ints
        if (typeof val === "boolean") {
            let b = !!val;
            val = b ? 1 : 0;
        }
        // https://github.com/y-lohse/inkjs/issues/425
        // Changed condition sequence, because Number('') is
        // parsed to 0, which made setting string to empty
        // impossible
        if (typeof val === "string") {
            return new StringValue(String(val));
        }
        else if (Number.isInteger(Number(val))) {
            return new IntValue(Number(val));
        }
        else if (!isNaN(val)) {
            return new FloatValue(Number(val));
        }
        else if (val instanceof Path_1.Path) {
            return new DivertTargetValue(TypeAssertion_1.asOrThrows(val, Path_1.Path));
        }
        else if (val instanceof InkList_1.InkList) {
            return new ListValue(TypeAssertion_1.asOrThrows(val, InkList_1.InkList));
        }
        return null;
    }
    Copy() {
        return TypeAssertion_1.asOrThrows(AbstractValue.Create(this), Object_1.InkObject);
    }
    BadCastException(targetType) {
        return new StoryException_1.StoryException("Can't cast " +
            this.valueObject +
            " from " +
            this.valueType +
            " to " +
            targetType);
    }
}
exports.AbstractValue = AbstractValue;
class Value extends AbstractValue {
    constructor(val) {
        super();
        this.value = val;
    }
    get valueObject() {
        return this.value;
    }
    toString() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.toString();
    }
}
exports.Value = Value;
class IntValue extends Value {
    constructor(val) {
        super(val || 0);
    }
    get isTruthy() {
        return this.value != 0;
    }
    get valueType() {
        return ValueType.Int;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Float) {
            return new FloatValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.IntValue = IntValue;
class FloatValue extends Value {
    constructor(val) {
        super(val || 0.0);
    }
    get isTruthy() {
        return this.value != 0.0;
    }
    get valueType() {
        return ValueType.Float;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            return new IntValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.FloatValue = FloatValue;
class StringValue extends Value {
    constructor(val) {
        super(val || "");
        this._isNewline = this.value == "\n";
        this._isInlineWhitespace = true;
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (this.value.length > 0) {
            this.value.split("").every((c) => {
                if (c != " " && c != "\t") {
                    this._isInlineWhitespace = false;
                    return false;
                }
                return true;
            });
        }
    }
    get valueType() {
        return ValueType.String;
    }
    get isTruthy() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.length > 0;
    }
    get isNewline() {
        return this._isNewline;
    }
    get isInlineWhitespace() {
        return this._isInlineWhitespace;
    }
    get isNonWhitespace() {
        return !this.isNewline && !this.isInlineWhitespace;
    }
    Cast(newType) {
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            let parsedInt = TryGetResult_1.tryParseInt(this.value);
            if (parsedInt.exists) {
                return new IntValue(parsedInt.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        if (newType == ValueType.Float) {
            let parsedFloat = TryGetResult_1.tryParseFloat(this.value);
            if (parsedFloat.exists) {
                return new FloatValue(parsedFloat.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        throw this.BadCastException(newType);
    }
}
exports.StringValue = StringValue;
class DivertTargetValue extends Value {
    constructor(targetPath) {
        super(targetPath);
    }
    get valueType() {
        return ValueType.DivertTarget;
    }
    get targetPath() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set targetPath(value) {
        this.value = value;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a divert target");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "DivertTargetValue(" + this.targetPath + ")";
    }
}
exports.DivertTargetValue = DivertTargetValue;
class VariablePointerValue extends Value {
    constructor(variableName, contextIndex = -1) {
        super(variableName);
        this._contextIndex = contextIndex;
    }
    get contextIndex() {
        return this._contextIndex;
    }
    set contextIndex(value) {
        this._contextIndex = value;
    }
    get variableName() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set variableName(value) {
        this.value = value;
    }
    get valueType() {
        return ValueType.VariablePointer;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a variable pointer");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "VariablePointerValue(" + this.variableName + ")";
    }
    Copy() {
        return new VariablePointerValue(this.variableName, this.contextIndex);
    }
}
exports.VariablePointerValue = VariablePointerValue;
class ListValue extends Value {
    get isTruthy() {
        if (this.value === null) {
            return NullException_1.throwNullException("this.value");
        }
        return this.value.Count > 0;
    }
    get valueType() {
        return ValueType.List;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == ValueType.Int) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new IntValue(0);
            else
                return new IntValue(max.Value);
        }
        else if (newType == ValueType.Float) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new FloatValue(0.0);
            else
                return new FloatValue(max.Value);
        }
        else if (newType == ValueType.String) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new StringValue("");
            else {
                return new StringValue(max.Key.toString());
            }
        }
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    constructor(listOrSingleItem, singleValue) {
        super(null);
        if (!listOrSingleItem && !singleValue) {
            this.value = new InkList_1.InkList();
        }
        else if (listOrSingleItem instanceof InkList_1.InkList) {
            this.value = new InkList_1.InkList(listOrSingleItem);
        }
        else if (listOrSingleItem instanceof InkList_1.InkListItem &&
            typeof singleValue === "number") {
            this.value = new InkList_1.InkList({
                Key: listOrSingleItem,
                Value: singleValue,
            });
        }
    }
    static RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrNull(oldValue, ListValue);
        let newList = TypeAssertion_1.asOrNull(newValue, ListValue);
        if (newList && newList.value === null)
            return NullException_1.throwNullException("newList.value");
        if (oldList && oldList.value === null)
            return NullException_1.throwNullException("oldList.value");
        // When assigning the empty list, try to retain any initial origin names
        if (oldList && newList && newList.value.Count == 0)
            newList.value.SetInitialOriginNames(oldList.value.originNames);
    }
}
exports.ListValue = ListValue;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 0] = "Int";
    ValueType[ValueType["Float"] = 1] = "Float";
    ValueType[ValueType["List"] = 2] = "List";
    ValueType[ValueType["String"] = 3] = "String";
    ValueType[ValueType["DivertTarget"] = 4] = "DivertTarget";
    ValueType[ValueType["VariablePointer"] = 5] = "VariablePointer";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=Value.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableAssignment.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableAssignment.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableAssignment = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class VariableAssignment extends Object_1.InkObject {
    constructor(variableName, isNewDeclaration) {
        super();
        this.variableName = variableName || null;
        this.isNewDeclaration = !!isNewDeclaration;
        this.isGlobal = false;
    }
    toString() {
        return "VarAssign to " + this.variableName;
    }
}
exports.VariableAssignment = VariableAssignment;
//# sourceMappingURL=VariableAssignment.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableReference.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableReference.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReference = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class VariableReference extends Object_1.InkObject {
    constructor(name = null) {
        super();
        this.pathForCount = null;
        this.name = name;
    }
    get containerForCount() {
        if (this.pathForCount === null)
            return null;
        return this.ResolvePath(this.pathForCount).container;
    }
    get pathStringForCount() {
        if (this.pathForCount === null)
            return null;
        return this.CompactPathString(this.pathForCount);
    }
    set pathStringForCount(value) {
        if (value === null)
            this.pathForCount = null;
        else
            this.pathForCount = new Path_1.Path(value);
    }
    toString() {
        if (this.name != null) {
            return "var(" + this.name + ")";
        }
        else {
            let pathStr = this.pathStringForCount;
            return "read_count(" + pathStr + ")";
        }
    }
}
exports.VariableReference = VariableReference;
//# sourceMappingURL=VariableReference.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariablesState.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/VariablesState.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesState = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class VariablesState {
    constructor(callStack, listDefsOrigin) {
        // The way variableChangedEvent is a bit different than the reference implementation.
        // Originally it uses the C# += operator to add delegates, but in js we need to maintain
        // an actual collection of delegates (ie. callbacks) to register a new one, there is a
        // special ObserveVariableChange method below.
        this.variableChangedEventCallbacks = [];
        this.patch = null;
        this._batchObservingVariableChanges = false;
        this._defaultGlobalVariables = new Map();
        this._changedVariablesForBatchObs = new Set();
        this._globalVariables = new Map();
        this._callStack = callStack;
        this._listDefsOrigin = listDefsOrigin;
        // if es6 proxies are available, use them.
        try {
            // the proxy is used to allow direct manipulation of global variables.
            // It first tries to access the objects own property, and if none is
            // found it delegates the call to the $ method, defined below
            let p = new Proxy(this, {
                get(target, name) {
                    return name in target ? target[name] : target.$(name);
                },
                set(target, name, value) {
                    if (name in target)
                        target[name] = value;
                    else
                        target.$(name, value);
                    return true; // returning a falsy value make the trap fail
                },
            });
            return p;
        }
        catch (e) {
            // thr proxy object is not available in this context. we should warn the
            // dev but writting to the console feels a bit intrusive.
            // console.log("ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.");
        }
    }
    variableChangedEvent(variableName, newValue) {
        for (let callback of this.variableChangedEventCallbacks) {
            callback(variableName, newValue);
        }
    }
    get batchObservingVariableChanges() {
        return this._batchObservingVariableChanges;
    }
    set batchObservingVariableChanges(value) {
        this._batchObservingVariableChanges = value;
        if (value) {
            this._changedVariablesForBatchObs = new Set();
        }
        else {
            if (this._changedVariablesForBatchObs != null) {
                for (let variableName of this._changedVariablesForBatchObs) {
                    let currentValue = this._globalVariables.get(variableName);
                    if (!currentValue) {
                        NullException_1.throwNullException("currentValue");
                    }
                    else {
                        this.variableChangedEvent(variableName, currentValue);
                    }
                }
                this._changedVariablesForBatchObs = null;
            }
        }
    }
    get callStack() {
        return this._callStack;
    }
    set callStack(callStack) {
        this._callStack = callStack;
    }
    // the original code uses a magic getter and setter for global variables,
    // allowing things like variableState['varname]. This is not quite possible
    // in js without a Proxy, so it is replaced with this $ function.
    $(variableName, value) {
        if (typeof value === "undefined") {
            let varContents = null;
            if (this.patch !== null) {
                varContents = this.patch.TryGetGlobal(variableName, null);
                if (varContents.exists)
                    return varContents.result.valueObject;
            }
            varContents = this._globalVariables.get(variableName);
            if (typeof varContents === "undefined") {
                varContents = this._defaultGlobalVariables.get(variableName);
            }
            if (typeof varContents !== "undefined")
                return varContents.valueObject;
            else
                return null;
        }
        else {
            if (typeof this._defaultGlobalVariables.get(variableName) === "undefined")
                throw new StoryException_1.StoryException("Cannot assign to a variable (" +
                    variableName +
                    ") that hasn't been declared in the story");
            let val = Value_1.Value.Create(value);
            if (val == null) {
                if (value == null) {
                    throw new StoryException_1.StoryException("Cannot pass null to VariableState");
                }
                else {
                    throw new StoryException_1.StoryException("Invalid value passed to VariableState: " + value.toString());
                }
            }
            this.SetGlobal(variableName, val);
        }
    }
    ApplyPatch() {
        if (this.patch === null) {
            return NullException_1.throwNullException("this.patch");
        }
        for (let [namedVarKey, namedVarValue] of this.patch.globals) {
            this._globalVariables.set(namedVarKey, namedVarValue);
        }
        if (this._changedVariablesForBatchObs !== null) {
            for (let name of this.patch.changedVariables) {
                this._changedVariablesForBatchObs.add(name);
            }
        }
        this.patch = null;
    }
    SetJsonToken(jToken) {
        this._globalVariables.clear();
        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {
            let loadedToken = jToken[varValKey];
            if (typeof loadedToken !== "undefined") {
                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);
                if (tokenInkObject === null) {
                    return NullException_1.throwNullException("tokenInkObject");
                }
                this._globalVariables.set(varValKey, tokenInkObject);
            }
            else {
                this._globalVariables.set(varValKey, varValValue);
            }
        }
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        for (let [keyValKey, keyValValue] of this._globalVariables) {
            let name = keyValKey;
            let val = keyValValue;
            if (VariablesState.dontSaveDefaultValues) {
                if (this._defaultGlobalVariables.has(name)) {
                    let defaultVal = this._defaultGlobalVariables.get(name);
                    if (this.RuntimeObjectsEqual(val, defaultVal))
                        continue;
                }
            }
            writer.WritePropertyStart(name);
            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    RuntimeObjectsEqual(obj1, obj2) {
        if (obj1 === null) {
            return NullException_1.throwNullException("obj1");
        }
        if (obj2 === null) {
            return NullException_1.throwNullException("obj2");
        }
        if (obj1.constructor !== obj2.constructor)
            return false;
        let intVal = TypeAssertion_1.asOrNull(obj1, Value_1.IntValue);
        if (intVal !== null) {
            return intVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.IntValue).value;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj1, Value_1.FloatValue);
        if (floatVal !== null) {
            return floatVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.FloatValue).value;
        }
        let val1 = TypeAssertion_1.asOrNull(obj1, Value_1.Value);
        let val2 = TypeAssertion_1.asOrNull(obj2, Value_1.Value);
        if (val1 !== null && val2 !== null) {
            if (TypeAssertion_1.isEquatable(val1.valueObject) && TypeAssertion_1.isEquatable(val2.valueObject)) {
                return val1.valueObject.Equals(val2.valueObject);
            }
            else {
                return val1.valueObject === val2.valueObject;
            }
        }
        throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: " +
            obj1.constructor.name);
    }
    GetVariableWithName(name, contextIndex = -1) {
        let varValue = this.GetRawVariableWithName(name, contextIndex);
        // var varPointer = varValue as VariablePointerValue;
        let varPointer = TypeAssertion_1.asOrNull(varValue, Value_1.VariablePointerValue);
        if (varPointer !== null) {
            varValue = this.ValueAtVariablePointer(varPointer);
        }
        return varValue;
    }
    TryGetDefaultVariableValue(name) {
        let val = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
        return val.exists ? val.result : null;
    }
    GlobalVariableExistsWithName(name) {
        return (this._globalVariables.has(name) ||
            (this._defaultGlobalVariables !== null &&
                this._defaultGlobalVariables.has(name)));
    }
    GetRawVariableWithName(name, contextIndex) {
        let varValue = null;
        if (contextIndex == 0 || contextIndex == -1) {
            let variableValue = null;
            if (this.patch !== null) {
                variableValue = this.patch.TryGetGlobal(name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            // this is a conditional assignment
            variableValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, name, null);
            if (variableValue.exists)
                return variableValue.result;
            if (this._defaultGlobalVariables !== null) {
                variableValue = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            if (this._listDefsOrigin === null)
                return NullException_1.throwNullException("VariablesState._listDefsOrigin");
            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);
            if (listItemValue)
                return listItemValue;
        }
        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);
        return varValue;
    }
    ValueAtVariablePointer(pointer) {
        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);
    }
    Assign(varAss, value) {
        let name = varAss.variableName;
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let contextIndex = -1;
        let setGlobal = false;
        if (varAss.isNewDeclaration) {
            setGlobal = varAss.isGlobal;
        }
        else {
            setGlobal = this.GlobalVariableExistsWithName(name);
        }
        if (varAss.isNewDeclaration) {
            // var varPointer = value as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(value, Value_1.VariablePointerValue);
            if (varPointer !== null) {
                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);
                value = fullyResolvedVariablePointer;
            }
        }
        else {
            let existingPointer = null;
            do {
                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;
                existingPointer = TypeAssertion_1.asOrNull(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);
                if (existingPointer != null) {
                    name = existingPointer.variableName;
                    contextIndex = existingPointer.contextIndex;
                    setGlobal = contextIndex == 0;
                }
            } while (existingPointer != null);
        }
        if (setGlobal) {
            this.SetGlobal(name, value);
        }
        else {
            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);
        }
    }
    SnapshotDefaultGlobals() {
        this._defaultGlobalVariables = new Map(this._globalVariables);
    }
    RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrThrows(oldValue, Value_1.ListValue);
        let newList = TypeAssertion_1.asOrThrows(newValue, Value_1.ListValue);
        if (oldList.value && newList.value && newList.value.Count == 0) {
            newList.value.SetInitialOriginNames(oldList.value.originNames);
        }
    }
    SetGlobal(variableName, value) {
        let oldValue = null;
        if (this.patch === null) {
            oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
        }
        if (this.patch !== null) {
            oldValue = this.patch.TryGetGlobal(variableName, null);
            if (!oldValue.exists) {
                oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
            }
        }
        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        if (variableName === null) {
            return NullException_1.throwNullException("variableName");
        }
        if (this.patch !== null) {
            this.patch.SetGlobal(variableName, value);
        }
        else {
            this._globalVariables.set(variableName, value);
        }
        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)
        if (this.variableChangedEvent !== null &&
            oldValue !== null &&
            value !== oldValue.result) {
            if (this.batchObservingVariableChanges) {
                if (this._changedVariablesForBatchObs === null) {
                    return NullException_1.throwNullException("this._changedVariablesForBatchObs");
                }
                if (this.patch !== null) {
                    this.patch.AddChangedVariable(variableName);
                }
                else if (this._changedVariablesForBatchObs !== null) {
                    this._changedVariablesForBatchObs.add(variableName);
                }
            }
            else {
                this.variableChangedEvent(variableName, value);
            }
        }
    }
    ResolveVariablePointer(varPointer) {
        let contextIndex = varPointer.contextIndex;
        if (contextIndex == -1)
            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);
        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);
        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;
        let doubleRedirectionPointer = TypeAssertion_1.asOrNull(valueOfVariablePointedTo, Value_1.VariablePointerValue);
        if (doubleRedirectionPointer != null) {
            return doubleRedirectionPointer;
        }
        else {
            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);
        }
    }
    GetContextIndexOfVariableNamed(varName) {
        if (this.GlobalVariableExistsWithName(varName))
            return 0;
        return this._callStack.currentElementIndex;
    }
    /**
     * This function is specific to the js version of ink. It allows to register a
     * callback that will be called when a variable changes. The original code uses
     * `state.variableChangedEvent += callback` instead.
     *
     * @param {function} callback
     */
    ObserveVariableChange(callback) {
        this.variableChangedEventCallbacks.push(callback);
    }
}
exports.VariablesState = VariablesState;
VariablesState.dontSaveDefaultValues = true;
//# sourceMappingURL=VariablesState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Void.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Void.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Void extends Object_1.InkObject {
}
exports.Void = Void;
//# sourceMappingURL=Void.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/GameMain.ts":
/*!*************************!*\
  !*** ./src/GameMain.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _unittest_UnitTest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unittest/UnitTest */ "./src/unittest/UnitTest.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _game_module_login_ui_UIServerListItem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./game/module/login/ui/UIServerListItem */ "./src/game/module/login/ui/UIServerListItem.ts");







class GameMain {
    constructor() {
        csharp__WEBPACK_IMPORTED_MODULE_1__["JsManager"].Instance.JsOnApplicationQuit = () => this.onApplicationQuit();
        csharp__WEBPACK_IMPORTED_MODULE_1__["JsManager"].Instance.JsOnDispose = () => this.onDispose();
    }
    async start() {
        try {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("Game start in JS....");
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].StoryManager.initialize();
            //预加载excel数据
            //ExcelManager.Instance(ExcelManager);
            //加载通用FairyGUI资源
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.loadFairyGUIPackage(_data_ui_common__WEBPACK_IMPORTED_MODULE_5__["commonUI"].PackageName);
            //do Unit Test
            _unittest_UnitTest__WEBPACK_IMPORTED_MODULE_0__["UnitTest"].doTest();
            //进入登录模块
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_2__["SceneDef"].LoginScene);
            //JS启动完成，通知C#层
            csharp__WEBPACK_IMPORTED_MODULE_1__["GameLaunch"].Instance.JsLuanchFinish();
            let extItem = () => {
                let item = new _game_module_login_ui_UIServerListItem__WEBPACK_IMPORTED_MODULE_6__["UIServerListItem"]();
                // pool.push(item)
                return item;
            };
            // let pool = []
            csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].UIObjectFactory.SetPackageItemExtension("ui://l64dumk9feeg54", extItem);
        }
        catch (ex) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].error(ex);
        }
    }
    onApplicationQuit() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].GameObjectPool.cleanup(true);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("Game onApplicationQuit in JS....");
    }
    onDispose() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("Game onDispose in JS....");
    }
}
new GameMain().start();


/***/ }),

/***/ "./src/data/excel/SkillConfig.ts":
/*!***************************************!*\
  !*** ./src/data/excel/SkillConfig.ts ***!
  \***************************************/
/*! exports provided: SkillConfigTR, SkillConfigTB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkillConfigTR", function() { return SkillConfigTR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkillConfigTB", function() { return SkillConfigTB; });
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");

class SkillConfigTR {
    constructor(_id, _Name, _Description, _CoolTime, _CostSP, _AttackDistance, _AttackAngle, _AttackTargetTags, _ImpactType, _NextBattlerId, _AtkRatio, _DurationTime, _AtkInterval, _SkillPrefab, _AnimationName, _HitFxPrefab, _Level, _AttackType, _SelectorType) {
        this._id = _id;
        this._Name = _Name;
        this._Description = _Description;
        this._CoolTime = _CoolTime;
        this._CostSP = _CostSP;
        this._AttackDistance = _AttackDistance;
        this._AttackAngle = _AttackAngle;
        this._AttackTargetTags = _AttackTargetTags;
        this._ImpactType = _ImpactType;
        this._NextBattlerId = _NextBattlerId;
        this._AtkRatio = _AtkRatio;
        this._DurationTime = _DurationTime;
        this._AtkInterval = _AtkInterval;
        this._SkillPrefab = _SkillPrefab;
        this._AnimationName = _AnimationName;
        this._HitFxPrefab = _HitFxPrefab;
        this._Level = _Level;
        this._AttackType = _AttackType;
        this._SelectorType = _SelectorType;
    }
}
class SkillConfigTB extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.trs = new Map();
        this.trs.set(1001, new SkillConfigTR(1001, "降龙十八掌", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill1", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1002, new SkillConfigTR(1002, "暴雨梨花", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill2", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1003, new SkillConfigTR(1003, "排山倒海", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill3", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1004, new SkillConfigTR(1004, "葵花点穴手", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill4", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
    }
}


/***/ }),

/***/ "./src/data/pb/Opcode.ts":
/*!*******************************!*\
  !*** ./src/data/pb/Opcode.ts ***!
  \*******************************/
/*! exports provided: DecodeMsg, Opcode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecodeMsg", function() { return DecodeMsg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Opcode", function() { return Opcode; });
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_gen_pb__WEBPACK_IMPORTED_MODULE_0__);

class DecodeMsg {
}
class Opcode {
    static decode(opcode, msg) {
        let msgObj = this.map[opcode]["decode"](msg);
        let decodeMsg = new DecodeMsg();
        decodeMsg.rpcId = msgObj.RpcId;
        decodeMsg.msgObj = msgObj;
        return decodeMsg;
    }
    static encode(opcode, msg) {
        let buf = this.map[opcode]["encode"](msg).finish();
        return buf;
    }
}
Opcode.MSG_C2R_Login = 1000;
Opcode.MSG_R2C_Login = 1001;
Opcode.MSG_C2G_LoginGate = 1002;
Opcode.MSG_G2C_LoginGate = 1003;
Opcode.MSG_C2GS_Test = 2001;
Opcode.MSG_GS2C_Test = 2002;
Opcode.map = {
    1000: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.encode },
    1001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.encode },
    1002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.encode },
    1003: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.encode },
    2001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.encode },
    2002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.encode }
};


/***/ }),

/***/ "./src/data/pb/gen/pb.js":
/*!*******************************!*\
  !*** ./src/data/pb/gen/pb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
$protobuf.util.Long = Long;
$protobuf.configure();


// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.nice_ts = (function() {

    /**
     * Namespace nice_ts.
     * @exports nice_ts
     * @namespace
     */
    var nice_ts = {};

    nice_ts.C2R_Login = (function() {

        /**
         * Properties of a C2R_Login.
         * @memberof nice_ts
         * @interface IC2R_Login
         * @property {string|null} [Account] C2R_Login Account
         * @property {string|null} [Password] C2R_Login Password
         */

        /**
         * Constructs a new C2R_Login.
         * @memberof nice_ts
         * @classdesc Represents a C2R_Login.
         * @implements IC2R_Login
         * @constructor
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         */
        function C2R_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2R_Login Account.
         * @member {string} Account
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Account = "";

        /**
         * C2R_Login Password.
         * @member {string} Password
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Password = "";

        /**
         * Creates a new C2R_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         * @returns {nice_ts.C2R_Login} C2R_Login instance
         */
        C2R_Login.create = function create(properties) {
            return new C2R_Login(properties);
        };

        /**
         * Encodes the specified C2R_Login message. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && Object.hasOwnProperty.call(message, "Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && Object.hasOwnProperty.call(message, "Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified C2R_Login message, length delimited. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2R_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2R_Login message.
         * @function verify
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2R_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        /**
         * Creates a C2R_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2R_Login} C2R_Login
         */
        C2R_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2R_Login)
                return object;
            var message = new $root.nice_ts.C2R_Login();
            if (object.Account != null)
                message.Account = String(object.Account);
            if (object.Password != null)
                message.Password = String(object.Password);
            return message;
        };

        /**
         * Creates a plain object from a C2R_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.C2R_Login} message C2R_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2R_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Account = "";
                object.Password = "";
            }
            if (message.Account != null && message.hasOwnProperty("Account"))
                object.Account = message.Account;
            if (message.Password != null && message.hasOwnProperty("Password"))
                object.Password = message.Password;
            return object;
        };

        /**
         * Converts this C2R_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.C2R_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2R_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2R_Login;
    })();

    nice_ts.R2C_Login = (function() {

        /**
         * Properties of a R2C_Login.
         * @memberof nice_ts
         * @interface IR2C_Login
         * @property {number|null} [Error] R2C_Login Error
         * @property {string|null} [Message] R2C_Login Message
         * @property {string|null} [Address] R2C_Login Address
         * @property {number|Long|null} [Key] R2C_Login Key
         * @property {number|Long|null} [GateId] R2C_Login GateId
         */

        /**
         * Constructs a new R2C_Login.
         * @memberof nice_ts
         * @classdesc Represents a R2C_Login.
         * @implements IR2C_Login
         * @constructor
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         */
        function R2C_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * R2C_Login Error.
         * @member {number} Error
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Error = 0;

        /**
         * R2C_Login Message.
         * @member {string} Message
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Message = "";

        /**
         * R2C_Login Address.
         * @member {string} Address
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Address = "";

        /**
         * R2C_Login Key.
         * @member {number|Long} Key
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * R2C_Login GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new R2C_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         * @returns {nice_ts.R2C_Login} R2C_Login instance
         */
        R2C_Login.create = function create(properties) {
            return new R2C_Login(properties);
        };

        /**
         * Encodes the specified R2C_Login message. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Address != null && Object.hasOwnProperty.call(message, "Address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Address);
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GateId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified R2C_Login message, length delimited. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.R2C_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.Address = reader.string();
                    break;
                case 2:
                    message.Key = reader.int64();
                    break;
                case 3:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a R2C_Login message.
         * @function verify
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        R2C_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.Address != null && message.hasOwnProperty("Address"))
                if (!$util.isString(message.Address))
                    return "Address: string expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a R2C_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.R2C_Login} R2C_Login
         */
        R2C_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.R2C_Login)
                return object;
            var message = new $root.nice_ts.R2C_Login();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.Address != null)
                message.Address = String(object.Address);
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a R2C_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.R2C_Login} message R2C_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        R2C_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.Address != null && message.hasOwnProperty("Address"))
                object.Address = message.Address;
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this R2C_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.R2C_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        R2C_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return R2C_Login;
    })();

    nice_ts.C2G_LoginGate = (function() {

        /**
         * Properties of a C2G_LoginGate.
         * @memberof nice_ts
         * @interface IC2G_LoginGate
         * @property {number|Long|null} [Key] C2G_LoginGate Key
         * @property {number|Long|null} [GateId] C2G_LoginGate GateId
         */

        /**
         * Constructs a new C2G_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a C2G_LoginGate.
         * @implements IC2G_LoginGate
         * @constructor
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         */
        function C2G_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2G_LoginGate Key.
         * @member {number|Long} Key
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2G_LoginGate GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2G_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate instance
         */
        C2G_LoginGate.create = function create(properties) {
            return new C2G_LoginGate(properties);
        };

        /**
         * Encodes the specified C2G_LoginGate message. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.GateId);
            return writer;
        };

        /**
         * Encodes the specified C2G_LoginGate message, length delimited. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2G_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Key = reader.int64();
                    break;
                case 2:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2G_LoginGate message.
         * @function verify
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2G_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2G_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         */
        C2G_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2G_LoginGate)
                return object;
            var message = new $root.nice_ts.C2G_LoginGate();
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2G_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.C2G_LoginGate} message C2G_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2G_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
            }
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            return object;
        };

        /**
         * Converts this C2G_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2G_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2G_LoginGate;
    })();

    nice_ts.G2C_LoginGate = (function() {

        /**
         * Properties of a G2C_LoginGate.
         * @memberof nice_ts
         * @interface IG2C_LoginGate
         * @property {number|null} [Error] G2C_LoginGate Error
         * @property {string|null} [Message] G2C_LoginGate Message
         * @property {number|Long|null} [PlayerId] G2C_LoginGate PlayerId
         */

        /**
         * Constructs a new G2C_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a G2C_LoginGate.
         * @implements IG2C_LoginGate
         * @constructor
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         */
        function G2C_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2C_LoginGate Error.
         * @member {number} Error
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Error = 0;

        /**
         * G2C_LoginGate Message.
         * @member {string} Message
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Message = "";

        /**
         * G2C_LoginGate PlayerId.
         * @member {number|Long} PlayerId
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.PlayerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new G2C_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate instance
         */
        G2C_LoginGate.create = function create(properties) {
            return new G2C_LoginGate(properties);
        };

        /**
         * Encodes the specified G2C_LoginGate message. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerId != null && Object.hasOwnProperty.call(message, "PlayerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PlayerId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified G2C_LoginGate message, length delimited. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.G2C_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.PlayerId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2C_LoginGate message.
         * @function verify
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2C_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (!$util.isInteger(message.PlayerId) && !(message.PlayerId && $util.isInteger(message.PlayerId.low) && $util.isInteger(message.PlayerId.high)))
                    return "PlayerId: integer|Long expected";
            return null;
        };

        /**
         * Creates a G2C_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         */
        G2C_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.G2C_LoginGate)
                return object;
            var message = new $root.nice_ts.G2C_LoginGate();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.PlayerId != null)
                if ($util.Long)
                    (message.PlayerId = $util.Long.fromValue(object.PlayerId)).unsigned = false;
                else if (typeof object.PlayerId === "string")
                    message.PlayerId = parseInt(object.PlayerId, 10);
                else if (typeof object.PlayerId === "number")
                    message.PlayerId = object.PlayerId;
                else if (typeof object.PlayerId === "object")
                    message.PlayerId = new $util.LongBits(object.PlayerId.low >>> 0, object.PlayerId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a G2C_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.G2C_LoginGate} message G2C_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        G2C_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.PlayerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PlayerId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (typeof message.PlayerId === "number")
                    object.PlayerId = options.longs === String ? String(message.PlayerId) : message.PlayerId;
                else
                    object.PlayerId = options.longs === String ? $util.Long.prototype.toString.call(message.PlayerId) : options.longs === Number ? new $util.LongBits(message.PlayerId.low >>> 0, message.PlayerId.high >>> 0).toNumber() : message.PlayerId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this G2C_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        G2C_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return G2C_LoginGate;
    })();

    nice_ts.C2GS_Test = (function() {

        /**
         * Properties of a C2GS_Test.
         * @memberof nice_ts
         * @interface IC2GS_Test
         * @property {number|null} [testID] C2GS_Test testID
         * @property {string|null} [testName] C2GS_Test testName
         */

        /**
         * Constructs a new C2GS_Test.
         * @memberof nice_ts
         * @classdesc Represents a C2GS_Test.
         * @implements IC2GS_Test
         * @constructor
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         */
        function C2GS_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2GS_Test testID.
         * @member {number} testID
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testID = 0;

        /**
         * C2GS_Test testName.
         * @member {string} testName
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testName = "";

        /**
         * Creates a new C2GS_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         * @returns {nice_ts.C2GS_Test} C2GS_Test instance
         */
        C2GS_Test.create = function create(properties) {
            return new C2GS_Test(properties);
        };

        /**
         * Encodes the specified C2GS_Test message. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testID != null && Object.hasOwnProperty.call(message, "testID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.testID);
            if (message.testName != null && Object.hasOwnProperty.call(message, "testName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testName);
            return writer;
        };

        /**
         * Encodes the specified C2GS_Test message, length delimited. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2GS_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.testID = reader.int32();
                    break;
                case 2:
                    message.testName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2GS_Test message.
         * @function verify
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2GS_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.testID != null && message.hasOwnProperty("testID"))
                if (!$util.isInteger(message.testID))
                    return "testID: integer expected";
            if (message.testName != null && message.hasOwnProperty("testName"))
                if (!$util.isString(message.testName))
                    return "testName: string expected";
            return null;
        };

        /**
         * Creates a C2GS_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         */
        C2GS_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2GS_Test)
                return object;
            var message = new $root.nice_ts.C2GS_Test();
            if (object.testID != null)
                message.testID = object.testID | 0;
            if (object.testName != null)
                message.testName = String(object.testName);
            return message;
        };

        /**
         * Creates a plain object from a C2GS_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.C2GS_Test} message C2GS_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2GS_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testID = 0;
                object.testName = "";
            }
            if (message.testID != null && message.hasOwnProperty("testID"))
                object.testID = message.testID;
            if (message.testName != null && message.hasOwnProperty("testName"))
                object.testName = message.testName;
            return object;
        };

        /**
         * Converts this C2GS_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.C2GS_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2GS_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2GS_Test;
    })();

    nice_ts.GS2C_Test = (function() {

        /**
         * Properties of a GS2C_Test.
         * @memberof nice_ts
         * @interface IGS2C_Test
         * @property {number|null} [Error] GS2C_Test Error
         * @property {string|null} [Message] GS2C_Test Message
         * @property {string|null} [testResponse] GS2C_Test testResponse
         */

        /**
         * Constructs a new GS2C_Test.
         * @memberof nice_ts
         * @classdesc Represents a GS2C_Test.
         * @implements IGS2C_Test
         * @constructor
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         */
        function GS2C_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GS2C_Test Error.
         * @member {number} Error
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Error = 0;

        /**
         * GS2C_Test Message.
         * @member {string} Message
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Message = "";

        /**
         * GS2C_Test testResponse.
         * @member {string} testResponse
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.testResponse = "";

        /**
         * Creates a new GS2C_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         * @returns {nice_ts.GS2C_Test} GS2C_Test instance
         */
        GS2C_Test.create = function create(properties) {
            return new GS2C_Test(properties);
        };

        /**
         * Encodes the specified GS2C_Test message. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testResponse != null && Object.hasOwnProperty.call(message, "testResponse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.testResponse);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified GS2C_Test message, length delimited. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.GS2C_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.testResponse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GS2C_Test message.
         * @function verify
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GS2C_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                if (!$util.isString(message.testResponse))
                    return "testResponse: string expected";
            return null;
        };

        /**
         * Creates a GS2C_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         */
        GS2C_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.GS2C_Test)
                return object;
            var message = new $root.nice_ts.GS2C_Test();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.testResponse != null)
                message.testResponse = String(object.testResponse);
            return message;
        };

        /**
         * Creates a plain object from a GS2C_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.GS2C_Test} message GS2C_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GS2C_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testResponse = "";
                object.Error = 0;
                object.Message = "";
            }
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                object.testResponse = message.testResponse;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this GS2C_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.GS2C_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GS2C_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GS2C_Test;
    })();

    return nice_ts;
})();

module.exports = $root;


/***/ }),

/***/ "./src/data/ui/combat.ts":
/*!*******************************!*\
  !*** ./src/data/ui/combat.ts ***!
  \*******************************/
/*! exports provided: combatUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combatUI", function() { return combatUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class combatUI {
}
combatUI.PackageName = "combat";
combatUI.PackageBytes = "combat_fui.bytes";
combatUI.UItest = "test";
combatUI.UICard = "Card";
combatUI.UICombatPage = "CombatPage";
combatUI.UIRoom = "Room";


/***/ }),

/***/ "./src/data/ui/common.ts":
/*!*******************************!*\
  !*** ./src/data/ui/common.ts ***!
  \*******************************/
/*! exports provided: commonUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonUI", function() { return commonUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class commonUI {
}
commonUI.PackageName = "common";
commonUI.PackageBytes = "common_fui.bytes";
commonUI.UILoadingPage = "LoadingPage";
commonUI.UIUIGuideWin = "UIGuideWin";
commonUI.UIUINoticeWin = "UINoticeWin";


/***/ }),

/***/ "./src/data/ui/home.ts":
/*!*****************************!*\
  !*** ./src/data/ui/home.ts ***!
  \*****************************/
/*! exports provided: homeUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homeUI", function() { return homeUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class homeUI {
}
homeUI.PackageName = "home";
homeUI.PackageBytes = "home_fui.bytes";
homeUI.UIHomePage = "HomePage";
homeUI.UILevelPage = "LevelPage";
homeUI.UIShopPage = "ShopPage";


/***/ }),

/***/ "./src/data/ui/login.ts":
/*!******************************!*\
  !*** ./src/data/ui/login.ts ***!
  \******************************/
/*! exports provided: loginUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loginUI", function() { return loginUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class loginUI {
}
loginUI.PackageName = "login";
loginUI.PackageBytes = "login_fui.bytes";
loginUI.UILoginPage = "LoginPage";
loginUI.UISelServerWin = "SelServerWin";
loginUI.UIAreaItem = "AreaItem";


/***/ }),

/***/ "./src/data/ui/story.ts":
/*!******************************!*\
  !*** ./src/data/ui/story.ts ***!
  \******************************/
/*! exports provided: storyUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storyUI", function() { return storyUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class storyUI {
}
storyUI.PackageName = "story";
storyUI.PackageBytes = "story_fui.bytes";
storyUI.UIStoryWin = "StoryWin";


/***/ }),

/***/ "./src/framework/common/GameObjectPool.ts":
/*!************************************************!*\
  !*** ./src/framework/common/GameObjectPool.ts ***!
  \************************************************/
/*! exports provided: GameObjectPool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameObjectPool", function() { return GameObjectPool; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



// -- GameObject缓存池
// -- 注意：
// -- 1、所有需要预设都从这里加载，不要直接到ResourcesManager去加载，由这里统一做缓存管理
// -- 2、缓存分为两部分：从资源层加载的原始GameObject(Asset)，从GameObject实例化出来的多个Inst
class GameObjectPool extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.__cacheTransRoot = null;
        this.__goPool = new Map();
        this.__instCache = new Map();
        let go = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Find("GameObjectCacheRoot");
        if (go == undefined) {
            go = new csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject("GameObjectCacheRoot");
            csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].Object.DontDestroyOnLoad(go);
        }
        this.__cacheTransRoot = go.transform;
    }
    //-- 检测是否已经被缓存
    checkHasCached(path) {
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            return true;
        }
        let pooledGo = this.__goPool.get(path);
        return pooledGo != undefined;
    }
    //-- 缓存并实例化GameObject
    cacheAndInstGameObject(path, go, inst_count = 1) {
        this.__goPool.set(path, go);
        if (inst_count > 0) {
            let cachedInst = this.__instCache.get(path);
            for (let i = 0; i < inst_count; i++) {
                let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(go);
                inst.transform.SetParent(this.__cacheTransRoot);
                inst.SetActive(false);
                cachedInst.push(inst);
            }
        }
    }
    //-- 尝试从缓存中获取
    tryGetFromCache(path) {
        if (!this.checkHasCached(path)) {
            return null;
        }
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            let inst = cachedInst.pop();
            return inst;
        }
        let pooledGo = this.__goPool.get(path);
        if (pooledGo != undefined) {
            let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(pooledGo);
            return inst;
        }
        return null;
    }
    //预加载：可提供初始实例化个数
    async preLoadGameObjectAsync(path, inst_count, callback, ...params) {
        if (this.checkHasCached(path)) {
            if (callback != null) {
                callback(params);
            }
            return;
        }
        let go = await _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).loadPrefab(path);
        if (go != undefined) {
            this.cacheAndInstGameObject(path, go, inst_count);
        }
        if (callback != null) {
            callback(params);
        }
    }
    //-- 异步获取：必要时加载
    async getGameObjectAsync(path, callback, ...params) {
        let inst = this.tryGetFromCache(path);
        if (inst == null) {
            await this.preLoadGameObjectAsync(path, 1, callback, params);
        }
        inst = this.tryGetFromCache(path);
        inst.SetActive(true);
    }
    //-- 回收
    recycleGameObject(path, inst) {
        inst.transform.SetParent(this.__cacheTransRoot);
        inst.SetActive(false);
        let cachedInst = this.__instCache.get(path) || new Array();
        cachedInst.push(inst);
        this.__instCache.set(path, cachedInst);
    }
    //-- 清理缓存
    cleanup(includePooledGo = false) {
        this.__instCache.forEach((values, key) => {
            for (let inst of values) {
                if (inst != null) {
                    csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Destroy(inst);
                }
            }
        });
        this.__instCache.clear();
        if (includePooledGo) {
            this.__goPool.forEach((go, key) => {
                if (go != null) {
                    _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).releaseAddressGO(go);
                }
            });
            this.__goPool.clear();
        }
    }
}


/***/ }),

/***/ "./src/framework/common/Messenger.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Messenger.ts ***!
  \*******************************************/
/*! exports provided: MesObj, Messenger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MesObj", function() { return MesObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Messenger", function() { return Messenger; });
class MesObj {
}
class Messenger {
    constructor() {
        this.listenerMap = new Map();
    }
    addListener(e_type, e_obj, e_listner) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) == "undefined") {
            msgObj = new MesObj();
            msgObj.obj = e_obj;
            msgObj.listeners = new Array();
        }
        msgObj.listeners.push(e_listner);
        this.listenerMap.set(e_type, msgObj);
    }
    getListener(e_type) {
        return this.listenerMap.get(e_type);
    }
    broadcast(e_type, ...params) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let l of msgObj.listeners) {
                l.apply(msgObj.obj, params);
            }
        }
    }
    removeListenerByType(e_type) {
        this.listenerMap.delete(e_type);
    }
    removeListener(e_type, e_listener) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let i = 0; i < msgObj.listeners.length; i++) {
                if (msgObj.listeners[i] == e_listener) {
                    msgObj.listeners.splice(i, 1);
                }
            }
        }
    }
    clearup() {
        this.listenerMap.clear();
    }
}


/***/ }),

/***/ "./src/framework/common/NiceDecorator.ts":
/*!***********************************************!*\
  !*** ./src/framework/common/NiceDecorator.ts ***!
  \***********************************************/
/*! exports provided: binder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binder", function() { return binder; });
// FairyGUI 元件 绑定器
function binder(name) {
    return function (target, key) {
        target["binders"] = target["binders"] || {};
        target["binders"][key] = name;
    };
}


/***/ }),

/***/ "./src/framework/common/ResManager.ts":
/*!********************************************!*\
  !*** ./src/framework/common/ResManager.ts ***!
  \********************************************/
/*! exports provided: ResManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResManager", function() { return ResManager; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class ResManager extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this._pkgMap = new Map();
    }
    async loadFairyGUIPackage(packageName) {
        try {
            let count = this._pkgMap.get(packageName);
            if (count == null || count < 1) {
                //没有缓存，加载
                let address = packageName + "_fui.bytes";
                let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadFairyGUIPackage(address, packageName);
                await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
                this._pkgMap.set(packageName, 1);
            }
            else {
                this._pkgMap.set(packageName, count + 1);
            }
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load fairyGUI :${packageName} : ${ex}`);
        }
    }
    releaseFairyGUIPackage(packageName) {
        let count = this._pkgMap.get(packageName);
        if (count != null && count > 1) {
            this._pkgMap.set(packageName, count - 1);
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log(`release fagui package:${packageName}`);
            this._pkgMap.delete(packageName);
            csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseFGUIPackage(packageName);
        }
    }
    async loadScene(sceneName, mode = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].SceneManagement.LoadSceneMode.Single) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadScene(sceneName, mode, (progress) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("load scene: " + progress);
            });
            let scenInstance = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return scenInstance;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load Scene :${sceneName} : ${ex}`);
            return null;
        }
    }
    async unloadScene(sceneInstance) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadScene(sceneInstance);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Unload scene  : ${ex}`);
            return null;
        }
    }
    unloadSceneByName(sceneName) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadSceneByName(sceneName);
    }
    async loadPrefab(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadPrefab(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load prefab :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextAsset(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextAsset(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load textasset :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextBytes(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextBytes(address);
            let bytes = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return bytes;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`LoadTextBytes :${address} : ${ex}`);
        }
    }
    async loadSprite(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadSprite(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load sprite :${address} : ${ex}`);
            return null;
        }
    }
    releaseAddressGO(go) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseAddressGO(go);
    }
}


/***/ }),

/***/ "./src/framework/common/Singleton.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Singleton.ts ***!
  \*******************************************/
/*! exports provided: Singleton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Singleton", function() { return Singleton; });
class Singleton {
    static Instance(c) {
        if (this.instance == null) {
            this.instance = new c();
        }
        return this.instance;
    }
}
Singleton.instance = null;


/***/ }),

/***/ "./src/framework/core/ArrayMap.ts":
/*!****************************************!*\
  !*** ./src/framework/core/ArrayMap.ts ***!
  \****************************************/
/*! exports provided: ArrayMap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayMap", function() { return ArrayMap; });
class ArrayMap {
    constructor() {
        this._arr = new Array();
        this._map = new Map();
    }
    add(key, value) {
        this._map.set(key, value);
        this._arr.push(value);
        return value;
    }
    get(key) {
        return this._map.get(key);
    }
    remove(key) {
        var obj = this._map.get(key);
        if (!obj)
            return null;
        var index = this._arr.indexOf(obj);
        this._arr.splice(index, 1);
        this._map.delete(key);
        return obj;
    }
    /**
     * 返回新的数组实例
     */
    getArr() {
        return this._arr;
    }
    dispose() {
        this._arr.length = 0;
        this._map.clear();
    }
}


/***/ }),

/***/ "./src/framework/entity/AEntity.ts":
/*!*****************************************!*\
  !*** ./src/framework/entity/AEntity.ts ***!
  \*****************************************/
/*! exports provided: AEntity */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AEntity", function() { return AEntity; });
/* harmony import */ var _core_ArrayMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/ArrayMap */ "./src/framework/core/ArrayMap.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");


class AEntity {
    constructor() {
        this.uuid = 0;
        this.eventsMap = new Map();
        this.components = new Map();
        this.parent = null;
        this._children = new _core_ArrayMap__WEBPACK_IMPORTED_MODULE_0__["ArrayMap"]();
        this._typeChildren = new Map();
    }
    addChild(child, c) {
        child.parent = this;
        this._children.add(child.uuid, child);
        let childrenArr = this._typeChildren.get(c.name);
        if (childrenArr == null) {
            childrenArr = new Array();
            this._typeChildren.set(c.name, childrenArr);
        }
        childrenArr.push(child);
    }
    removeChild(child) {
        let entity = this._children.remove(child.uuid);
        entity.dispose();
    }
    getChildren() {
        return this._children.getArr();
    }
    getChildByUUID(uuid) {
        return this._children.get(uuid);
    }
    getChildrenByType(c) {
        return this._typeChildren.get(c.name);
    }
    getChildByType(c) {
        return this.getChildrenByType(c)[0];
    }
    addComponent(c) {
        let cc = new c();
        cc.entity = this;
        this.components[c.name] = cc;
        return cc;
    }
    getComponent(c) {
        return this.components[c.name];
    }
    getOrAddComponent(c) {
        let com = this.getComponent(c);
        if (com == null) {
            com = this.addComponent(c);
        }
        return com;
    }
    publish(event, c) {
        let array = this.eventsMap.get(c.name);
        if (array == null || array.length == 0) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("this event not subscribed...");
            return;
        }
        for (let i = 0; i < array.length; i++) {
            let f = array[i];
            if (f != null)
                f(event);
        }
    }
    subscribe(action, c) {
        let array = this.eventsMap.get(c.name);
        if (array == null) {
            array = new Array();
            this.eventsMap.set(c.name, array);
        }
        array.push(action);
    }
    unSubscribe(action, c) {
        let array = this.eventsMap.get(c.name);
        let index = array.indexOf(action, 0);
        if (index > -1) {
            array.splice(index, 1);
        }
    }
    dispose() {
        let children = this.getChildren;
        for (let i = 0; i < children.length; i++) {
            children[i].dispose();
        }
        this.components.clear();
        this.eventsMap.clear();
        this._typeChildren.clear();
        this._children.dispose();
        this.parent = null;
    }
}


/***/ }),

/***/ "./src/framework/entity/Component.ts":
/*!*******************************************!*\
  !*** ./src/framework/entity/Component.ts ***!
  \*******************************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
class Component {
    publish(event, c) {
        this.entity.publish(event, c);
    }
    subscribe(action, c) {
        this.entity.subscribe(action, c);
    }
    unSubscribe(action, c) {
        this.entity.unSubscribe(action, c);
    }
}


/***/ }),

/***/ "./src/framework/entity/EntityFactory.ts":
/*!***********************************************!*\
  !*** ./src/framework/entity/EntityFactory.ts ***!
  \***********************************************/
/*! exports provided: EntityFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EntityFactory", function() { return EntityFactory; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");

class EntityFactory extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super(...arguments);
        this.autoID = 0;
    }
    create(c) {
        let cc = new c();
        cc.uuid = ++this.autoID;
        cc.onAwake(null);
        return cc;
    }
    createWithData(initData, c) {
        let cc = new c();
        cc.uuid = ++this.autoID;
        cc.onAwake(initData);
        return cc;
    }
}


/***/ }),

/***/ "./src/framework/ink/InkStateInspector.ts":
/*!************************************************!*\
  !*** ./src/framework/ink/InkStateInspector.ts ***!
  \************************************************/
/*! exports provided: InkStateInspector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkStateInspector", function() { return InkStateInspector; });
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");

class InkStateInspector {
    BindInkMethods(inkStory) {
        //3参数以下采用此方式
        this.bindInkMethodOnce(inkStory, "GetCharacterName", this.getCharacterName);
        //3参数以上采用此方式 
        this.bindInkMethodOnceGeneral(inkStory, "GetCharacterNameByMutiParams", this.getCharacterNameMutiParams);
    }
    getCharacterName() {
        return "Justin Test Puerts";
    }
    getCharacterNameMutiParams(p1, p2, p3) {
        return "Justin Muti Params";
    }
    bindInkMethodOnce(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunction(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    bindInkMethodOnceGeneral(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunctionGeneral(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    unbindInkMethod(inkStory, funcName) {
        try {
            inkStory.UnbindExternalFunction(funcName);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
}


/***/ }),

/***/ "./src/framework/ink/InkWriter.ts":
/*!****************************************!*\
  !*** ./src/framework/ink/InkWriter.ts ***!
  \****************************************/
/*! exports provided: InkWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkWriter", function() { return InkWriter; });
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inkjs/engine/Story */ "./node_modules/inkjs/engine/Story.js");
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkStateInspector */ "./src/framework/ink/InkStateInspector.ts");
/* harmony import */ var _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");




class InkWriter {
    constructor(storyJson) {
        this._allInkCommands = new Map();
        this.setupInkCommands();
        this.createStroy(storyJson);
        this.load();
    }
    load() {
        let storyState = "";
        if (storyState != null && storyState != "") {
            this._currentStory.state.LoadJson(storyState);
        }
    }
    createStroy(json) {
        this._currentStory = new inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__["Story"](json);
    }
    beginStory(knotName) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
            return;
        }
        this._currentStory.ChoosePathString(knotName, true);
        let inkState = new _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__["InkStateInspector"]();
        inkState.BindInkMethods(this._currentStory);
        this.advanceStory();
    }
    giveReward() {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("give reward...");
        return true;
    }
    setupInkCommands() {
        this._allInkCommands.set("GIVE_REWARD", this.giveReward);
    }
    handleCommand(command, args) {
        if (this._allInkCommands.has(command)) {
            return this._allInkCommands.get(command)(args);
        }
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].error("Could not find InkCommand with name:" + command);
        return true;
    }
    parseCommandName(text) {
        let num = text.indexOf(InkWriter.COMMAND_PREFIX);
        let num2 = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num2 == -1) {
            num2 = text.length;
        }
        let length = num2 - (num + InkWriter.COMMAND_PREFIX.length);
        return text.substr(num + InkWriter.COMMAND_PREFIX.length, length).trim();
    }
    parseCommandArgs(text) {
        let num = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num == -1) {
            return [];
        }
        let length = text.length - (num + 1);
        let list = text.substr(num + 1, length).
            trim().
            split(InkWriter.COMMAND_ARG_DELIMITER);
        for (let i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
        }
        return list;
    }
    extractSpeaker(line) {
        if (line.startsWith(InkWriter.COMMAND_PREFIX)) {
            return ["0", line.trim()];
        }
        let array = line.split(':', 2);
        if (array.length > 1) {
            let speakID = array[0].trim();
            let speakContent = array[1].trim();
            return [speakID, speakContent];
        }
        return ["0", line.trim()];
    }
    saveCurrentStory() {
        let currState = this._currentStory.state.toJson();
        //TODOｓａｖｅ
    }
    canContinue() {
        return this._currentStory.canContinue;
    }
    advanceStory() {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
        }
        else if (this._currentStory.canContinue) {
            let text = this._currentStory.Continue().trim();
            if (text == "") {
                this.advanceStory();
                return;
            }
            let speakID;
            let speakContent;
            [speakID, speakContent] = this.extractSpeaker(text);
            let commandName = null;
            let args = null;
            if (speakContent.startsWith(InkWriter.COMMAND_PREFIX)) {
                commandName = this.parseCommandName(speakContent);
                args = this.parseCommandArgs(speakContent);
                if (commandName != null && commandName != "") {
                    if (this.handleCommand(commandName, args)) {
                        this.advanceStory();
                    }
                }
            }
            else {
                //OnContentReady
                _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastContentReady(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCONTENTREADY, speakContent, speakID, this._currentStory.currentTags, this._currentStory.currentChoices);
            }
        }
        else if (this._currentStory.currentChoices.length > 0) {
            //OnChoicesPresented
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastChoicesPresented(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCHOICESPRESENTED, this._currentStory.currentChoices);
        }
        else {
            //OnStoryFinished
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastStoryFinished(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONSTORYFINISHED);
        }
    }
    selectChoice(choiceIndex) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to ChooseChoice in InkWriter when no story has begun");
            return;
        }
        this._currentStory.ChooseChoiceIndex(choiceIndex);
        this.advanceStory();
    }
    getVariable(variableName) {
        return this._currentStory.variablesState.GetVariableWithName(variableName);
    }
    setVariable(variableName, value) {
        this._currentStory.variablesState.$(variableName, value);
    }
}
InkWriter.DEBUG_STORY_ID = "DEBUG_STORY";
InkWriter.COMMAND_PREFIX = ">>>";
InkWriter.COMMAND_DELIMITER = ":";
InkWriter.COMMAND_ARG_DELIMITER = ',';


/***/ }),

/***/ "./src/framework/ink/StoryManager.ts":
/*!*******************************************!*\
  !*** ./src/framework/ink/StoryManager.ts ***!
  \*******************************************/
/*! exports provided: StoryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryManager", function() { return StoryManager; });
/* harmony import */ var _common_ResManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _InkWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkWriter */ "./src/framework/ink/InkWriter.ts");



class StoryManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super();
        this.storyAddress = "Story/TestStory.json";
    }
    get inkWriter() {
        return this._inkWriter;
    }
    async initialize() {
        if (this._inkWriter == null) {
            var json = (await _common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"].Instance(_common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"]).loadTextAsset(this.storyAddress)).text;
            this._inkWriter = new _InkWriter__WEBPACK_IMPORTED_MODULE_2__["InkWriter"](json);
        }
    }
    beginStory(knotName) {
        this._inkWriter.beginStory(knotName);
    }
    canContinue() {
        return this._inkWriter.canContinue;
    }
    advanceStory() {
        this._inkWriter.advanceStory();
    }
    selectChoice(choice) {
        this._inkWriter.selectChoice(choice.index);
    }
    loadCurrent() {
        if (this._inkWriter != null)
            this._inkWriter.load();
    }
    getVariable(variableName) {
        return this._inkWriter.getVariable(variableName);
    }
    setVariable(variableName, value) {
        this.inkWriter.setVariable(variableName, value);
    }
}


/***/ }),

/***/ "./src/framework/ink/StoryMessageManager.ts":
/*!**************************************************!*\
  !*** ./src/framework/ink/StoryMessageManager.ts ***!
  \**************************************************/
/*! exports provided: StoryMessageManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryMessageManager", function() { return StoryMessageManager; });
/* harmony import */ var _common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");


class StoryMessageManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.storyMessage = new _common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.storyMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.storyMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.storyMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.storyMessage.clearup();
    }
    broadcastContentReady(msgCode, speakerContent, speakerId, currentTags, currentChoices) {
        this.storyMessage.broadcast(msgCode, speakerContent, speakerId, currentTags, currentChoices);
    }
    broadcastChoicesPresented(mesgCode, currentChoices) {
        this.storyMessage.broadcast(mesgCode, currentChoices);
    }
    broadcastStoryFinished(mesgCode) {
        this.storyMessage.broadcast(mesgCode);
    }
}
StoryMessageManager.ONCONTENTREADY = 1001;
StoryMessageManager.ONCHOICESPRESENTED = 1002;
StoryMessageManager.ONSTORYFINISHED = 1003;


/***/ }),

/***/ "./src/framework/logger/Logger.ts":
/*!****************************************!*\
  !*** ./src/framework/logger/Logger.ts ***!
  \****************************************/
/*! exports provided: Logger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");


var LogType;
(function (LogType) {
    LogType[LogType["Error"] = 0] = "Error";
    LogType[LogType["Assert"] = 1] = "Assert";
    LogType[LogType["Warning"] = 2] = "Warning";
    LogType[LogType["Log"] = 3] = "Log";
    LogType[LogType["Exception"] = 4] = "Exception";
})(LogType || (LogType = {}));
class Logger {
    static getPrintStack(type, showStack, ...args) {
        let message = '';
        for (let i = 0; i < args.length; i++) {
            const element = args[i];
            if (typeof element === 'object' && Logger.LOG_OBJECT_TO_JSON) {
                message += JSON.stringify(element);
            }
            else {
                message += element;
            }
            if (i < args.length - 1) {
                message += ' ';
            }
        }
        if (showStack || csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Application.isEditor) {
            var stacks = new Error().stack.split('\n');
            for (let i = 3; i < stacks.length; i++) {
                const line = stacks[i];
                message += '\n';
                message += line;
            }
        }
        if (!Logger.unity_log_target) {
            Logger.unity_log_target = new csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Object();
        }
        return message;
    }
    static log(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /**
     * Outputs a warning message to the Logger.
     * @param message  list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static warn(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Warning, true, args);
        console.warn(msg);
    }
    /**
     * Outputs an error message to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static error(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Error, true, args);
        console.error(msg);
    }
    /** Outputs a stack trace to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
    */
    static trace(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /** Log JavaScript Objects as JSON format */
    static LOG_OBJECT_TO_JSON(...args) {
        return false;
    }
}
Logger.unity_log_target = null;


/***/ }),

/***/ "./src/framework/net/GameSession.ts":
/*!******************************************!*\
  !*** ./src/framework/net/GameSession.ts ***!
  \******************************************/
/*! exports provided: MsgPack, GameSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MsgPack", function() { return MsgPack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSession", function() { return GameSession; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MessageParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MessageParser */ "./src/framework/net/MessageParser.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");






class MsgPack {
    constructor() {
        this.retryTimes = 0;
    }
}
class GameSession extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.id = 0; //session ID
        this.reSendInterval = 10000; //10秒重发一次
        this.timeoutInterval = 5000; //5秒检查一次是否超时
        this.maxReSendTimes = 5; //最大重发次数
        this._rpcId = 1;
        this.requestCallback = new Map();
        this.listeners = new Map();
        //返回的服务器ID, 类型
        this._serverId = -1;
        this._serverType = 1;
    }
    get rpcId() {
        return ++this._rpcId;
    }
    //address-> ip:port
    connectChannel(address, connCaback) {
        this.channel = csharp__WEBPACK_IMPORTED_MODULE_3__["NiceTS"].TService.Instance.GetChannel();
        this.channel.errorCallback = (channel, code) => {
            if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__["NetErrorCode"].ERR_SocketConnSucc) {
                this.timeoutIimer = setInterval(() => {
                    this.checkTimeoutMsg();
                }, this.timeoutInterval);
            }
            connCaback(channel, code);
        };
        this.channel.readCallback = (buffer) => {
            this.onReceive(buffer);
        };
        this.channel.Connect(address);
        return this;
    }
    //接收服务器通知
    listen(opcode, callback) {
        this.listeners.set(opcode, callback);
    }
    //发送protoubf消息
    //消息： rpc_id[4] - opcode[2] - server_id[2] - server_type[1] - 
    send(opcode, rpcid, message, callBack) {
        //封装消息：
        let rpcBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeInt(rpcid); //4
        let opcodeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(opcode); //2
        let serveridBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(this._serverId); //2
        let servertypeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeByte(this._serverType); //1
        let sendArray = new Uint8Array(4 + 2 + 2 + 1 + message.length);
        sendArray.set(rpcBuf);
        sendArray.set(opcodeBuf, 4);
        sendArray.set(serveridBuf, 4 + 2);
        sendArray.set(servertypeBuf, 4 + 2 + 2);
        sendArray.set(message, 4 + 2 + 2 + 1);
        if (callBack != null) {
            let msgPack = new MsgPack();
            msgPack.sendTime = new Date().getTime();
            msgPack.callback = callBack;
            msgPack.bytes = sendArray;
            this.requestCallback.set(rpcid, msgPack);
        }
        // for(let i in sendArray){
        //     Logger.log("TS -- send array: "+i);
        // }
        //Logger.log("send array: "+sendArray);
        this.channel.Send(sendArray);
    }
    reSend(bytes) {
        this.channel.Send(bytes);
    }
    onReceive(buffer) {
        let msgBuf = new Uint8Array(buffer);
        let rpcid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeInt(msgBuf.subarray(0, 4));
        let opcode = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(4, 6));
        let serverid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(6, 8));
        let servertype = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeByte(msgBuf.subarray(8, 9));
        this._serverId = serverid;
        this._serverType = servertype;
        let msgBytes = msgBuf.subarray(9);
        try {
            let decodeMsg = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].decode(opcode, msgBytes);
            if (rpcid == undefined || !this.requestCallback.has(rpcid)) {
                //检查是否是服务器下发的消息
                if (this.listeners.has(opcode)) {
                    let listen = this.listeners.get(opcode);
                    listen(decodeMsg.msgObj);
                }
            }
            else {
                let msgPack = this.requestCallback.get(rpcid);
                msgPack.callback(decodeMsg.msgObj);
                this.requestCallback.delete(rpcid);
            }
        }
        catch (e) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].error("parse msg error, opcode:" + opcode);
        }
    }
    checkTimeoutMsg() {
        let currTime = new Date().getTime();
        this.requestCallback.forEach((value, key) => {
            if (value.retryTimes >= this.maxReSendTimes) {
                //超过最大重发次数，丢弃
                _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`Message resend too more, opcode:${key}, lastsend:${value.sendTime}`);
                this.requestCallback.delete(key);
            }
            else {
                if ((currTime - value.sendTime) >= this.reSendInterval) {
                    value.retryTimes++;
                    value.sendTime = currTime;
                    //重发消息
                    this.reSend(value.bytes);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`resend message:, opcode:${key}, retry times:${value.retryTimes}`);
                }
            }
        });
    }
    disconnect() {
        clearInterval(this.timeoutIimer);
        this.channel.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/net/HttpManager.ts":
/*!******************************************!*\
  !*** ./src/framework/net/HttpManager.ts ***!
  \******************************************/
/*! exports provided: HttpManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpManager", function() { return HttpManager; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class HttpManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    constructor() {
        super();
    }
    async get(url) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Get(url);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Get error :${url} : ${ex}`);
            return null;
        }
    }
    async post(url, form) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Post(url, form);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Post error :${url} : ${ex}`);
            return null;
        }
    }
}


/***/ }),

/***/ "./src/framework/net/MessageParser.ts":
/*!********************************************!*\
  !*** ./src/framework/net/MessageParser.ts ***!
  \********************************************/
/*! exports provided: MessageParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageParser", function() { return MessageParser; });
class MessageParser {
    static encodeInt(n) {
        let buffer = new Uint8Array(4);
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        return buffer;
    }
    static decodeInt(buffer) {
        let n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        return n;
    }
    static encodeShort(n) {
        let buffer = new Uint8Array(2);
        buffer[0] = n >>> 8;
        buffer[1] = n & 0xff;
        return buffer;
    }
    static decodeShort(buffer) {
        let n = buffer[0] << 8 | buffer[1];
        return n;
    }
    static encodeByte(n) {
        let buffer = new Uint8Array(1);
        buffer[0] = n & 0xff;
        return buffer;
    }
    static decodeByte(buffer) {
        let n = buffer[0];
        return n;
    }
}


/***/ }),

/***/ "./src/framework/net/NetErrorCode.ts":
/*!*******************************************!*\
  !*** ./src/framework/net/NetErrorCode.ts ***!
  \*******************************************/
/*! exports provided: NetErrorCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetErrorCode", function() { return NetErrorCode; });
class NetErrorCode {
}
NetErrorCode.ERR_SocketConnSucc = 100000;
NetErrorCode.ERR_ConnectGateKeyError = 100006;
NetErrorCode.ERR_PeerDisconnect = 102008;
NetErrorCode.ERR_SocketCantSend = 102009;
NetErrorCode.ERR_SocketError = 102010;
NetErrorCode.ERR_SocketConnError = 102011;


/***/ }),

/***/ "./src/framework/net/SessionManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/net/SessionManager.ts ***!
  \*********************************************/
/*! exports provided: SessionManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionManager", function() { return SessionManager; });
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");






class SessionManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    get realmRpcID() {
        return this.sessionReam.rpcId;
    }
    get gateRpcID() {
        return this.sessionGate.rpcId;
    }
    async connectRealmServer() {
        let promise = new Promise(resove => {
            this.sessionReam = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerIP + ":" + _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerPort, (channel, code) => {
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionReam.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("login reamserver err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectRealmServer() {
        this.sessionReam.disconnect();
        this.sessionReam = null;
    }
    async sendRealmMsg(opcode, msg) {
        let rpcID = this.sessionReam.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionReam.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
    async connectGateServer(address) {
        let promise = new Promise(resove => {
            this.sessionGate = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(address, (channel, code) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("login Gate Server: " + code);
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionGate.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("gate server err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectGateServer() {
        this.sessionGate.disconnect();
        this.sessionGate = null;
    }
    async sendGateMsg(opcode, msg) {
        let rpcID = this.sessionGate.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionGate.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/framework/redhints/RedHintsManager.ts":
/*!***************************************************!*\
  !*** ./src/framework/redhints/RedHintsManager.ts ***!
  \***************************************************/
/*! exports provided: enumRedHints, RedHintsManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enumRedHints", function() { return enumRedHints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedHintsManager", function() { return RedHintsManager; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");



var enumRedHints;
(function (enumRedHints) {
    /** 标记位 */
    enumRedHints[enumRedHints["none"] = 0] = "none";
    /** 聊天 */
    enumRedHints[enumRedHints["chat"] = 1] = "chat";
    /** 聊天世界频道 */
    enumRedHints[enumRedHints["chat_world"] = 2] = "chat_world";
    /** 聊天公会频道 */
    enumRedHints[enumRedHints["chat_family"] = 3] = "chat_family";
    /** 聊天系统频道 */
    enumRedHints[enumRedHints["chat_system"] = 4] = "chat_system";
})(enumRedHints || (enumRedHints = {}));
class RedHintsManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.init();
    }
    init() {
        this._data = [0]; //第一位无意义
        this._parentIndex = [0];
        this._childNum = [0];
        this._childIndex = [0];
        //------------------------记录父子关系-----------------------
        //聊天
        this.setParent(enumRedHints.chat_world, enumRedHints.chat);
        this.setParent(enumRedHints.chat_family, enumRedHints.chat);
        this.setParent(enumRedHints.chat_system, enumRedHints.chat);
    }
    /**
     * 设置红点的开启和关闭
    */
    setRedHintOpenOrClose(red, isOpen) {
        if (this._childNum[red] > 0) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("红点数据设置错误：不能直接对高级的红点数据操作");
            return;
        }
        this.doSetRedHintOpenOrClose(red, isOpen ? 1 : 0);
    }
    /**
     * 记录父子关系：子---父
    */
    setParent(child, parent) {
        if (this._parentIndex[parent] == child) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("关系反了");
            return;
        }
        if (this._parentIndex[child]) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("重复设置");
            return;
        }
        this._parentIndex[child] = parent;
        if (isNaN(this._childNum[parent])) {
            this._childNum[parent] = 0;
        }
        this._childNum[parent]++; //子项数量增加
        this._childIndex[child] = this._childNum[parent]; //子项的索引 从1开始
    }
    doSetRedHintOpenOrClose(red, value) {
        if (this._data[red] != value) {
            this._data[red] = value;
            let _parent = this._parentIndex[red];
            if (_parent) {
                //如果有父级，更新父级
                let index = this._childIndex[red]; //获取在父级中的索引
                this.doSetRedHintOpenOrClose(_parent, value > 0 ? this._data[_parent] | this.addV(index) : this._data[_parent] & this.subV(index)); //设置父级的值
            }
            //发改变事件:全局事件
            //emit(RedHintsManager.RED_HINT_VALUE_CHANGED, red);
            //红点事件，局部事件
            _RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_2__["RedHintsMessageManager"].Instance(_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_2__["RedHintsMessageManager"]).broadcast(red, value);
        }
    }
    addV(index) {
        return 1 << (index - 1);
    }
    subV(index) {
        return ~this.addV(index);
    }
    /**
     * 查看红点是否开启
    */
    checkRedIsOpen(red) {
        return this._data[red] > 0;
    }
}
/**
 * 红点值改变
*/
RedHintsManager.RED_HINT_VALUE_CHANGED = "RED_HINT_VALUE_CHANGED";


/***/ }),

/***/ "./src/framework/redhints/RedHintsMessageManager.ts":
/*!**********************************************************!*\
  !*** ./src/framework/redhints/RedHintsMessageManager.ts ***!
  \**********************************************************/
/*! exports provided: RedHintsMessageManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedHintsMessageManager", function() { return RedHintsMessageManager; });
/* harmony import */ var _common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");


class RedHintsMessageManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.redhintsMessage = new _common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.redhintsMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.redhintsMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.redhintsMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.redhintsMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.redhintsMessage.broadcast(msgCode, params);
    }
}


/***/ }),

/***/ "./src/framework/scene/BaseScene.ts":
/*!******************************************!*\
  !*** ./src/framework/scene/BaseScene.ts ***!
  \******************************************/
/*! exports provided: BaseScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseScene", function() { return BaseScene; });
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");

class BaseScene {
    constructor() {
        this.finishCount = 0;
        this.totalCount = 0;
        this.preloadPrefab = new Map();
        this.finishCount = 0;
    }
    addPreloadPrefab(address, instCount) {
        if (!this.preloadPrefab.has(address)) {
            this.preloadPrefab.set(address, instCount);
            return;
        }
        this.preloadPrefab.set(address, this.preloadPrefab.get(address) + instCount);
    }
    setSceneInstance(sceneInstance) {
        this.sceneInstance = sceneInstance;
    }
    async loadAssetsAsync() {
        this.totalCount = this.preloadPrefab.size;
        let premises = [];
        this.preloadPrefab.forEach((value, key) => {
            let premise = _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.preLoadGameObjectAsync(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        await Promise.all(premises);
    }
    onDestroy() {
        //清理资源缓存
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.cleanup(true);
        //卸载场景
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].ResManager.unloadScene(this.sceneInstance);
        this.preloadPrefab.clear();
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneDef.ts":
/*!*****************************************!*\
  !*** ./src/framework/scene/SceneDef.ts ***!
  \*****************************************/
/*! exports provided: SceneDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneDef", function() { return SceneDef; });
class SceneDef {
}
SceneDef.LoadingScene = "LoadingScene";
SceneDef.LaunchScene = "LaunchScene";
SceneDef.HomeScene = "HomeScene";
SceneDef.LoginScene = "LoginScene";
SceneDef.PveScene = "PveScene";


/***/ }),

/***/ "./src/framework/scene/SceneFactory.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneFactory.ts ***!
  \*********************************************/
/*! exports provided: SceneFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneFactory", function() { return SceneFactory; });
/* harmony import */ var _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/pve/scene/PveScene */ "./src/game/module/pve/scene/PveScene.ts");
/* harmony import */ var _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/scene/HomeScene */ "./src/game/module/home/scene/HomeScene.ts");
/* harmony import */ var _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../game/module/login/scene/LoginScene */ "./src/game/module/login/scene/LoginScene.ts");
/* harmony import */ var _SceneDef__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SceneDef */ "./src/framework/scene/SceneDef.ts");




class SceneFactory {
    static createScene(sceneName) {
        let scene = null;
        switch (sceneName) {
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].LoginScene:
                scene = new _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__["LoginScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].HomeScene:
                scene = new _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__["HomeScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].PveScene:
                scene = new _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__["PveScene"]();
                break;
        }
        return scene;
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneManager.ts ***!
  \*********************************************/
/*! exports provided: SceneManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneManager", function() { return SceneManager; });
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _SceneFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SceneFactory */ "./src/framework/scene/SceneFactory.ts");






class SceneManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_3__["Singleton"] {
    constructor() {
        super();
        this.currentScene = null;
    }
    async loadScene(scene) {
        try {
            //打开Loading界面
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
            //清理旧场景
            if (this.currentScene) {
                this.currentScene.onLeave();
                this.currentScene.onDestroy();
            }
            //开始加载场景
            let sceneInstance = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].ResManager.loadScene(scene);
            //开始加载进入场景的资源
            this.currentScene = _SceneFactory__WEBPACK_IMPORTED_MODULE_5__["SceneFactory"].createScene(scene);
            this.currentScene.setSceneInstance(sceneInstance);
            this.currentScene.onEnter();
            //设置当前场景加载进度Timer
            let progressInterval = setInterval(() => {
                let progress = this.currentScene.finishCount / this.currentScene.totalCount;
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("progress:" + progress + " = " + this.currentScene.finishCount + " = " + this.currentScene.totalCount);
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIMessageManger.broadcast(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__["UIMessage"].MSG_SCENE_PROGRESS, progress * 100);
            }, 100);
            //加载资源
            await this.currentScene.loadAssetsAsync();
            //加载完成
            clearInterval(progressInterval);
            this.currentScene.onComplete();
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.closeLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("load scene excep:" + ex);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIDefine.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIDefine.ts ***!
  \**************************************/
/*! exports provided: UITypeDef, UILayerDef, UIComDefs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UITypeDef", function() { return UITypeDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILayerDef", function() { return UILayerDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIComDefs", function() { return UIComDefs; });
var UITypeDef;
(function (UITypeDef) {
    UITypeDef[UITypeDef["Unkown"] = 0] = "Unkown";
    UITypeDef[UITypeDef["Page"] = 1] = "Page";
    UITypeDef[UITypeDef["Window"] = 2] = "Window";
    UITypeDef[UITypeDef["Widget"] = 3] = "Widget";
    UITypeDef[UITypeDef["Loading"] = 4] = "Loading";
})(UITypeDef || (UITypeDef = {}));
class UILayerDef {
    static getDefaultLayer(type) {
        switch (type) {
            case UITypeDef.Loading: return this.Loading;
            case UITypeDef.Widget: return this.Widget;
            case UITypeDef.Window: return this.NormalWindow;
            case UITypeDef.Page: return this.Page;
            case UITypeDef.Unkown: return this.Unkown;
            default: return this.Unkown;
        }
    }
}
UILayerDef.Background = 0;
UILayerDef.Page = 1000;
UILayerDef.NormalWindow = 2000;
UILayerDef.TopWindow = 3000;
UILayerDef.Widget = 4000;
UILayerDef.Loading = 5000;
UILayerDef.Unkown = 9999;
class UIComDefs {
}
UIComDefs.BackBtn = "back_btn";
UIComDefs.WindowCloseBtn = "win_close_btn";


/***/ }),

/***/ "./src/framework/ui/UIFactory.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIFactory.ts ***!
  \***************************************/
/*! exports provided: UIFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIFactory", function() { return UIFactory; });
/* harmony import */ var _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/login/ui/UILoginPage */ "./src/game/module/login/ui/UILoginPage.ts");
/* harmony import */ var _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/ui/UIHomePage */ "./src/game/module/home/ui/UIHomePage.ts");
/* harmony import */ var _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UILib/UILoading */ "./src/framework/ui/UILib/UILoading.ts");
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UILib/UIMsgBox */ "./src/framework/ui/UILib/UIMsgBox.ts");
/* harmony import */ var _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../game/module/login/ui/UISelServerWin */ "./src/game/module/login/ui/UISelServerWin.ts");
/* harmony import */ var _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../game/module/home/ui/UIShopPage */ "./src/game/module/home/ui/UIShopPage.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../game/module/story/UIStoryWin */ "./src/game/module/story/UIStoryWin.ts");
/* harmony import */ var _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../data/ui/combat */ "./src/data/ui/combat.ts");
/* harmony import */ var _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../game/module/guide/UIGuideWin */ "./src/game/module/guide/UIGuideWin.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");














const CS = __webpack_require__(/*! csharp */ "csharp");
class UIFactory {
    static createUI(pkg, name) {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].log(`create UI: ${pkg}:${name}`);
        let comp = CS.FairyGUI.UIPackage.CreateObject(pkg, name).asCom;
        let ui = this.uiCache.get(name);
        if (!ui) {
            switch (pkg) {
                case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].PackageName:
                    switch (name) {
                        //common
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUINoticeWin:
                            ui = new _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__["UIMsgBox"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UILoadingPage:
                            ui = new _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__["UILoading"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUIGuideWin:
                            ui = new _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__["UIGuideWin"]();
                    }
                    break;
                case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName:
                    switch (name) {
                        //login
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UILoginPage:
                            ui = new _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__["UILoginPage"]();
                            break;
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin:
                            ui = new _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__["UISelServerWin"]();
                            break;
                    }
                    break;
                case _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__["combatUI"].PackageName:
                    break;
                case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].PackageName:
                    switch (name) {
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIHomePage:
                            ui = new _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__["UIHomePage"]();
                            break;
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIShopPage:
                            ui = new _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__["UIShopPage"]();
                            break;
                    }
                    break;
                case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].PackageName:
                    switch (name) {
                        case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].UIStoryWin:
                            ui = new _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__["UIStoryWin"]();
                            break;
                    }
                    break;
            }
            this.uiCache.set(name, ui);
        }
        if (ui != null) {
            ui.fui = comp;
            ui.name = name;
            ui.pkgName = pkg;
            //绑定FairyGUI控件
            ui.bindAll(ui);
            ui.awake();
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].error(`not create ui: ${pkg}-${name}`);
        }
        return ui;
    }
}
UIFactory.uiCache = new Map();


/***/ }),

/***/ "./src/framework/ui/UILib/UILoading.ts":
/*!*********************************************!*\
  !*** ./src/framework/ui/UILib/UILoading.ts ***!
  \*********************************************/
/*! exports provided: UILoading */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoading", function() { return UILoading; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class UILoading extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    onAwake() {
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Loading;
    }
    onShow(arg) {
        this.progressLoading.value = 0;
        this.progressLoading.visible = true;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.addListener(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS, this, (progress) => {
            this.progressLoading.TweenValue(progress, 0.1);
        });
    }
    onClose(arg) {
        this.progressLoading.visible = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.removeListenerByCode(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS);
    }
}
__decorate([
    Object(_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__["binder"])("loading_pregress")
], UILoading.prototype, "progressLoading", void 0);


/***/ }),

/***/ "./src/framework/ui/UILib/UIMsgBox.ts":
/*!********************************************!*\
  !*** ./src/framework/ui/UILib/UIMsgBox.ts ***!
  \********************************************/
/*! exports provided: UIMsgBoxArg, UIMsgBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBoxArg", function() { return UIMsgBoxArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBox", function() { return UIMsgBox; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


// 通用弹窗
class UIMsgBoxArg {
    constructor() {
        this.title = "";
        this.content = "";
        this.btnText = ""; //"确定|取消|关闭"
    }
}
class UIMsgBox extends _UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.bindAll(this);
    }
    onShow(arg) {
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("msgTxt")
], UIMsgBox.prototype, "m_txt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("okBtn")
], UIMsgBox.prototype, "m_okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("cancelBtn")
], UIMsgBox.prototype, "m_cancelBtn", void 0);


/***/ }),

/***/ "./src/framework/ui/UIManager.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIManager.ts ***!
  \***************************************/
/*! exports provided: UIPageTrack, UIManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPageTrack", function() { return UIPageTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIManager", function() { return UIManager; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _UIFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIFactory */ "./src/framework/ui/UIFactory.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");





class UIPageTrack {
}
class UIManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.m_pageTrackStack = new Array();
        this.m_listLoadedPanel = new Array();
    }
    distroyAllLoadedPanel() {
        for (let i = this.m_listLoadedPanel.length - 1; i >= 0; i--) {
            let panel = this.m_listLoadedPanel[i];
            if (panel.isOpen) {
                panel.close();
            }
            //卸载资源
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.releaseFairyGUIPackage(panel.pkgName);
            panel.dispose();
        }
        this.m_listLoadedPanel.length = 0;
    }
    clean() {
        this.distroyAllLoadedPanel();
        this.m_pageTrackStack.length = 0;
        this.m_listLoadedPanel.length = 0;
    }
    async open(pkg, name, arg) {
        let ui = this.getUI(name);
        if (ui == null) {
            //加载 package
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.loadFairyGUIPackage(pkg);
            ui = _UIFactory__WEBPACK_IMPORTED_MODULE_1__["UIFactory"].createUI(pkg, name);
            this.m_listLoadedPanel.push(ui);
        }
        if (ui != null) {
            // ###  ui as any 调用私有方法
            ui._internalOpen(arg);
        }
        return ui;
    }
    getUI(name) {
        for (const panel of this.m_listLoadedPanel) {
            if (panel.name == name) {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("find panel in cache: " + name);
                return panel;
            }
        }
        return null;
    }
    //打开场景页面,此页面不计入页面栈,无返回上一面按钮
    openPageInScene(pkg, page, arg) {
        this.openPageWorker(pkg, page, arg);
    }
    //==========================================================UILoading
    //打开Loading界面
    openLoading(pkg, name, arg) {
        this.openPageInScene(pkg, name, arg);
    }
    //关闭Loading界面
    closeLoading(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================Page
    openPageWorker(pkg, page, arg) {
        this.m_currentPage = new UIPageTrack();
        this.m_currentPage.pkg = pkg;
        this.m_currentPage.name = page;
        this.m_currentPage.arg = arg;
        this.distroyAllLoadedPanel();
        this.open(pkg, page, arg);
    }
    //打开页面, 会关闭上一个页面上的所有窗口,Widiget等
    openPage(pkg, name, arg) {
        if (this.m_currentPage != undefined && this.m_currentPage.name != name) {
            this.m_pageTrackStack.push(this.m_currentPage);
        }
        this.openPageWorker(pkg, name, arg);
    }
    //返回上一个页面
    goBackPage() {
        if (this.m_pageTrackStack.length > 0) {
            let track = this.m_pageTrackStack.pop();
            this.openPageWorker(track.pkg, track.name, track.arg);
        }
        else {
            this.enterMainPage();
        }
    }
    //回到主城
    enterMainPage() {
        this.m_pageTrackStack.length = 0;
        this.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].UIHomePage, null);
    }
    //==========================================================UIWindow
    //打开窗口
    async openWindow(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //关闭窗口
    closeWindow(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================UIWidget
    //打开Widiget
    async openWidget(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //u关闭Widiget
    closeWidget(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPage.ts":
/*!************************************!*\
  !*** ./src/framework/ui/UIPage.ts ***!
  \************************************/
/*! exports provided: UIPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPage", function() { return UIPage; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");



class UIPage extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Page;
    }
    onAwake() {
        this.m_btnGoBack = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].BackBtn);
        if (this.m_btnGoBack != undefined) {
            this.m_btnGoBack.onClick.Add(() => {
                this.onBtnGoBack();
            });
        }
    }
    onShow(vo) {
    }
    onClose(arg) {
    }
    onBtnGoBack() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.goBackPage();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPanel.ts":
/*!*************************************!*\
  !*** ./src/framework/ui/UIPanel.ts ***!
  \*************************************/
/*! exports provided: UIPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPanel", function() { return UIPanel; });
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_1__);


class UIPanel {
    constructor() {
        this.m_layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].Unkown;
    }
    set name(v) {
        this._name = v;
    }
    get name() {
        return this._name;
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UITypeDef"].Unkown;
    }
    get layer() {
        return this.m_layer;
    }
    set layer(v) {
        this.m_layer = v;
    }
    get isOpen() {
        return this.fui.visible;
    }
    onUpdate() { }
    awake() {
        this.onAwake();
    }
    //绑定FairyGUI元件
    bindAll(target) {
        for (let k in target["binders"]) {
            let fguiName = this["binders"][k];
            this[k] = this.fui.GetChild(fguiName);
        }
    }
    update() {
        this.onUpdate();
    }
    /**
     * 此私有方法在UI Manager中调用 ，特殊调用。
     * @param arg
     */
    _internalOpen(arg) {
        this.layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].getDefaultLayer(this.uiType);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.AddChild(this.fui);
        this.onShow(arg);
    }
    close(arg = null) {
        this.onClose(arg);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.RemoveChild(this.fui);
    }
    dispose() {
        this.fui.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIWindow.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIWindow.ts ***!
  \**************************************/
/*! exports provided: UIWindow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIWindow", function() { return UIWindow; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



class UIWindow extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Window;
    }
    onAwake() {
        this.m_btnClose = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].WindowCloseBtn);
    }
    onShow(arg) {
        this.fui.x = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.width / 2 - this.fui.width / 2;
        this.fui.y = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.height / 2 - this.fui.height / 2;
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Add(this.onBtnClose);
        }
    }
    onClose(arg) {
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Remove(this.onBtnClose);
        }
    }
    onBtnClose() {
        this.close(0);
    }
}


/***/ }),

/***/ "./src/framework/util/TimeUtil.ts":
/*!****************************************!*\
  !*** ./src/framework/util/TimeUtil.ts ***!
  \****************************************/
/*! exports provided: TimeUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimeUtil", function() { return TimeUtil; });
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");

class TimeUtil {
    static prefixInteger(num, length) {
        return (Array(length).join('0') + num).slice(-length);
    }
    //将一个时间数转换成"00:00:00"格式
    static getTimeString1(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${hourstr}:${minutestr}:${secondstr}`;
        }
    }
    //将一个时间数转换成"00:00"格式
    static getTimeString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${hourstr}:${minutestr}`;
        }
    }
    //将一个时间数转换成"00"分格式
    static getTimeMinuteString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${minutestr}`;
        }
    }
    //将一个时间数转换成"00“秒格式
    static getTimeSecondString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${secondstr}`;
        }
    }
    //获取本月1号是星期几
    static getWeekOfMonthFirstDay(time) {
        let date = new Date(time);
        date.setDate(1);
        return date.getDay();
    }
    //判断是否为闰年
    static isLeapYear(year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
            return true;
        }
        return false;
    }
    static getMonthDays_(year, month) {
        if (month == 2) {
            if (this.isLeapYear(year))
                return 29;
            else {
                return 28;
            }
        }
        else {
            return this.months[month];
        }
    }
    static getMonthDays(time) {
        let t = new Date(time);
        return this.getMonthDays_(t.getFullYear(), t.getMonth());
    }
    static async sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve('');
            }, ms);
        });
    }
    static test() {
        let t1 = this.getTimeString1(5000);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log(t1);
        let t2 = this.getTimeString(5000);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log(t2);
        let t3 = this.getTimeMinuteString(5000);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log(t3);
        let t4 = this.getTimeSecondString(5000);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log(t4);
        let time = new Date().getTime();
        let t5 = this.getWeekOfMonthFirstDay(time);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log("getWeekOfMonthFirstDay: " + t5 + " ,time:" + time);
        let t6 = this.getMonthDays(time);
        _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].log("getMonthDays: " + t6);
    }
}
//每个月对应的天数
TimeUtil.months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];


/***/ }),

/***/ "./src/game/api/LoginAPI.ts":
/*!**********************************!*\
  !*** ./src/game/api/LoginAPI.ts ***!
  \**********************************/
/*! exports provided: LoginAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginAPI", function() { return LoginAPI; });
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");




class LoginAPI {
    static async benchmarkTest() {
        for (let i = 1; i < 2; i++) {
            let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.create();
            msg.testID = i;
            msg.testName = "benchmark test";
            let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2GS_Test, msg);
            let test = response;
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].log("code: " + test.Error + ",msg:" + test.Message + ",res:" + test.testResponse);
        }
    }
    static async loginRealmServer(account, password) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.create();
        msg.Account = account;
        msg.Password = password;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendRealmMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2R_Login, msg);
        return response;
    }
    static async loginGateServer(gateId, gateKey) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.create();
        msg.GateId = gateId;
        msg.Key = gateKey;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2G_LoginGate, msg);
        return response;
    }
}


/***/ }),

/***/ "./src/game/entity/Player.ts":
/*!***********************************!*\
  !*** ./src/game/entity/Player.ts ***!
  \***********************************/
/*! exports provided: Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Player", function() { return Player; });
/* harmony import */ var _framework_entity_AEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/entity/AEntity */ "./src/framework/entity/AEntity.ts");

class Player extends _framework_entity_AEntity__WEBPACK_IMPORTED_MODULE_0__["AEntity"] {
    constructor() {
        super();
        this.level = 1;
        this.hp = 100;
    }
    onAwake(initData) {
    }
}


/***/ }),

/***/ "./src/game/entity/PlayerManager.ts":
/*!******************************************!*\
  !*** ./src/game/entity/PlayerManager.ts ***!
  \******************************************/
/*! exports provided: PlayerManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlayerManager", function() { return PlayerManager; });
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _framework_entity_EntityFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../framework/entity/EntityFactory */ "./src/framework/entity/EntityFactory.ts");
/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player */ "./src/game/entity/Player.ts");



class PlayerManager extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    getPlayer(reCreate = false) {
        if (reCreate) {
            this.player = null;
            this.player = _framework_entity_EntityFactory__WEBPACK_IMPORTED_MODULE_1__["EntityFactory"].Instance(_framework_entity_EntityFactory__WEBPACK_IMPORTED_MODULE_1__["EntityFactory"]).create(_Player__WEBPACK_IMPORTED_MODULE_2__["Player"]);
        }
        else {
            if (this.player == null) {
                this.player = _framework_entity_EntityFactory__WEBPACK_IMPORTED_MODULE_1__["EntityFactory"].Instance(_framework_entity_EntityFactory__WEBPACK_IMPORTED_MODULE_1__["EntityFactory"]).create(_Player__WEBPACK_IMPORTED_MODULE_2__["Player"]);
            }
        }
        return this.player;
    }
}


/***/ }),

/***/ "./src/game/entity/component/BagComponent.ts":
/*!***************************************************!*\
  !*** ./src/game/entity/component/BagComponent.ts ***!
  \***************************************************/
/*! exports provided: BagComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BagComponent", function() { return BagComponent; });
/* harmony import */ var _framework_entity_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/entity/Component */ "./src/framework/entity/Component.ts");

class BagComponent extends _framework_entity_Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    constructor() {
        super(...arguments);
        this.name = "hello";
        this.size = 100;
    }
}


/***/ }),

/***/ "./src/game/entity/component/PlayerInfoComponent.ts":
/*!**********************************************************!*\
  !*** ./src/game/entity/component/PlayerInfoComponent.ts ***!
  \**********************************************************/
/*! exports provided: PlayerInfoComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlayerInfoComponent", function() { return PlayerInfoComponent; });
/* harmony import */ var _framework_entity_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/entity/Component */ "./src/framework/entity/Component.ts");

class PlayerInfoComponent extends _framework_entity_Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
    constructor() {
        super(...arguments);
        this.nickName = "Justin";
        this.money = 1000001;
    }
}


/***/ }),

/***/ "./src/game/event/UIMessage.ts":
/*!*************************************!*\
  !*** ./src/game/event/UIMessage.ts ***!
  \*************************************/
/*! exports provided: UIMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessage", function() { return UIMessage; });
class UIMessage {
}
UIMessage.MSG_SELECT_SERVER = 1000;
UIMessage.MSG_SCENE_PROGRESS = 1001;


/***/ }),

/***/ "./src/game/event/UIMessageManager.ts":
/*!********************************************!*\
  !*** ./src/game/event/UIMessageManager.ts ***!
  \********************************************/
/*! exports provided: UIMessageManger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessageManger", function() { return UIMessageManger; });
/* harmony import */ var _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");


class UIMessageManger extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.uiMessage = new _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.uiMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.uiMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.uiMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.uiMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.uiMessage.broadcast(msgCode, params);
    }
}


/***/ }),

/***/ "./src/game/module/guide/UIGuideWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/guide/UIGuideWin.ts ***!
  \*********************************************/
/*! exports provided: UIGuideWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIGuideWin", function() { return UIGuideWin; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class UIGuideWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.m_focus.alpha = 0.2;
        this.m_focus.SetXY(520, 550);
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("focus")
], UIGuideWin.prototype, "m_focus", void 0);


/***/ }),

/***/ "./src/game/module/home/scene/HomeScene.ts":
/*!*************************************************!*\
  !*** ./src/game/module/home/scene/HomeScene.ts ***!
  \*************************************************/
/*! exports provided: HomeScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HomeScene", function() { return HomeScene; });
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vo/VoHome */ "./src/game/module/home/vo/VoHome.ts");




class HomeScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
        let vo = new _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__["VoHome"]();
        vo.name = "Justin";
        vo.hp = 1200;
        vo.mp = 3300;
        vo.money = 666;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].UIHomePage, vo);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/home/ui/UIHomePage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIHomePage.ts ***!
  \***********************************************/
/*! exports provided: UIHomePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIHomePage", function() { return UIHomePage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








class UIHomePage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
        this.m_chatBtn.onClick.Add(() => {
            this.onchatBtn();
        });
        this.m_bagBtn.onClick.Add(() => {
            this.onbagBtn();
        });
        this.m_shopBtn.onClick.Add(() => {
            this.onshopBtn();
        });
        this.m_levelBtn.onClick.Add(() => {
            this.onlevelBtn();
        });
    }
    onShow(vo) {
        super.onShow(vo);
        this.m_nameLbl.text = vo.name;
        this.m_mpLbl.text = vo.mp.toString();
        this.m_hpLbl.text = vo.hp.toString();
        this.m_moneyLbl.text = vo.money.toString();
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].GameSession.listen(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__["Opcode"].MSG_GS2C_Test, function (msg) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("收到服务器下发的消息。。。。" + msg.testResponse);
        });
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onchatBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].UIUINoticeWin, null);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on chat...");
    }
    onbagBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on bag ..");
        //benchmark test
        _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__["LoginAPI"].benchmarkTest();
    }
    onshopBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openPage(_data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].UIShopPage);
    }
    onlevelBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on level...");
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("chatBtn")
], UIHomePage.prototype, "m_chatBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("bagBtn")
], UIHomePage.prototype, "m_bagBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("shopBtn")
], UIHomePage.prototype, "m_shopBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("levelBtn")
], UIHomePage.prototype, "m_levelBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("nameTxt")
], UIHomePage.prototype, "m_nameLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hpTxt")
], UIHomePage.prototype, "m_hpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("mpTxt")
], UIHomePage.prototype, "m_mpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("moneyTxt")
], UIHomePage.prototype, "m_moneyLbl", void 0);


/***/ }),

/***/ "./src/game/module/home/ui/UIShopPage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIShopPage.ts ***!
  \***********************************************/
/*! exports provided: UIShopPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIShopPage", function() { return UIShopPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");

class UIShopPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}


/***/ }),

/***/ "./src/game/module/home/vo/VoHome.ts":
/*!*******************************************!*\
  !*** ./src/game/module/home/vo/VoHome.ts ***!
  \*******************************************/
/*! exports provided: VoHome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoHome", function() { return VoHome; });
class VoHome {
}


/***/ }),

/***/ "./src/game/module/login/scene/LoginScene.ts":
/*!***************************************************!*\
  !*** ./src/game/module/login/scene/LoginScene.ts ***!
  \***************************************************/
/*! exports provided: LoginScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginScene", function() { return LoginScene; });
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");



class LoginScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    onEnter() {
    }
    onComplete() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].UILoginPage, null);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/login/ui/UILoginPage.ts":
/*!*************************************************!*\
  !*** ./src/game/module/login/ui/UILoginPage.ts ***!
  \*************************************************/
/*! exports provided: UILoginPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoginPage", function() { return UILoginPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vo/VoServer */ "./src/game/module/login/vo/VoServer.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











class UILoginPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    constructor() {
        super(...arguments);
        this._effectGo = null;
    }
    async onAwake() {
        super.onAwake();
        this.m_loginBtn.onClick.Add(() => {
            this.onLoginClick();
        });
        this.m_storyBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].PackageName, _data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].UIStoryWin, null);
        });
        this.m_newGuideBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].UIUIGuideWin, null);
        });
        this.m_selserverBtn.onClick.Add(() => {
            this.openSelServerWin();
        });
        // let connected = await S.SessionManager.connectRealmServer();
        // this.m_loginBtn.enabled = connected;
        // Logger.log("connect ream server: "+connected)
    }
    onSelectServer(serverItem) {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(" server selected: " + serverItem.serverName);
        this.m_selserverBtn.text = serverItem.serverName;
    }
    async onShow(vo) {
        super.onShow(vo);
        //加载特效
        this._effectGo = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.loadPrefab("Effect/Prefab/UI/ef_ui_pet_rank_yellow_test.prefab");
        let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(this._effectGo);
        let wrapper = new csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GoWrapper(inst);
        this.m_holder.SetNativeObject(wrapper);
        //监听选服消息
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.addListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this, this.onSelectServer);
    }
    onClose(arg) {
        super.onClose(arg);
        //卸载铁效
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.releaseAddressGO(this._effectGo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.removeListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this.onSelectServer);
    }
    openSelServerWin() {
        // 测试数据
        let voServer = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServer"]();
        for (let i = 1; i < 10; i++) {
            voServer.areaMap.set(i, "分区" + i);
            voServer.serverMap.set(i, new Array());
            for (let j = 1; j < 200; j++) {
                let voServerItem = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServerItem"]();
                voServerItem.areaId = i;
                voServerItem.serverId = j;
                voServerItem.serverName = "测试服务器" + i + ":" + j;
                voServerItem.serverStatus = Math.floor(Math.random() * 3 + 1);
                voServer.serverMap.get(i).push(voServerItem);
            }
        }
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin, voServer);
    }
    async onLoginClick() {
        let account = this.m_account.text;
        let password = this.m_password.text;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`account:${account} - password: ${password}`);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__["SceneDef"].HomeScene);
        // if(account != "" && password != ""){
        //     let msg = await LoginAPI.loginRealmServer(account, password)
        //     this.gateId = msg.GateId;
        //     this.gateKey = msg.Key;
        //     Logger.log("login ream succ, gate addr:"+msg.Address + ",key:"+msg.Key);
        //     S.SessionManager.disconnectRealmServer();
        //     //登录网关服
        //     let connected = await S.SessionManager.connectGateServer(msg.Address);
        //     if(connected){
        //         Logger.log("connect gate succ")
        //         let msg = await LoginAPI.loginGateServer( this.gateId, this.gateKey)
        //         let playerID = msg.PlayerId;
        //         Logger.log("login gate response.." +playerID);
        //         S.SceneManager.loadScene(SceneDef.HomeScene);
        //     }else{
        //     Logger.log("connect gate err ")
        //     }
        //  }
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("account")
], UILoginPage.prototype, "m_account", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("password")
], UILoginPage.prototype, "m_password", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("selserverBtn")
], UILoginPage.prototype, "m_selserverBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("loginBtn")
], UILoginPage.prototype, "m_loginBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("storyBtn")
], UILoginPage.prototype, "m_storyBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("newGuideBtn")
], UILoginPage.prototype, "m_newGuideBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hold")
], UILoginPage.prototype, "m_holder", void 0);


/***/ }),

/***/ "./src/game/module/login/ui/UISelServerWin.ts":
/*!****************************************************!*\
  !*** ./src/game/module/login/ui/UISelServerWin.ts ***!
  \****************************************************/
/*! exports provided: UISelServerWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UISelServerWin", function() { return UISelServerWin; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _UIServerListItem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UIServerListItem */ "./src/game/module/login/ui/UIServerListItem.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class UISelServerWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.clickAreaIndex = 0;
        this.clickServerIndex = 0;
    }
    onAwake() {
        super.onAwake();
        this.backBtn.onClick.Add(() => {
            this.close();
        });
        this.okBtn.onClick.Add(() => {
            this.onSelectServer();
        });
        this.areaList.onClickItem.Add((event) => {
            this.clickAreaIndex = this.areaList.GetChildIndex(event.data);
            this.serverList.numItems = this.voServer.serverMap.get(this.clickAreaIndex + 1).length;
            this.serverList.RefreshVirtualList();
        });
        this.serverList.onClickItem.Add((event) => {
            this.clickServerIndex = this.serverList.GetChildIndex(event.data);
            this.title.text = "已选择服务器：" + this.clickServerIndex;
        });
        let pool = [];
    }
    onSelectServer() {
        let selItem = this.voServer.serverMap.get(this.clickAreaIndex + 1)[this.clickServerIndex];
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIMessageManger.broadcast(_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SELECT_SERVER, selItem);
        this.close();
    }
    onShow(vo) {
        super.onShow(vo);
        this.voServer = vo;
        this.areaList.SetVirtual();
        this.areaList.itemRenderer = (index, obj) => {
            this.renderAreaListItem(index, obj);
        };
        this.areaList.numItems = vo.areaMap.size;
        this.serverList.SetVirtual();
        this.serverList.itemRenderer = (index, obj) => {
            this.renderServerListItem(index, obj);
        };
        this.serverList.numItems = vo.serverMap.get(this.clickAreaIndex + 1).length;
    }
    renderAreaListItem(index, obj) {
        let areaBtn = obj.asButton;
        areaBtn.text = this.voServer.areaMap.get(index + 1);
    }
    renderServerListItem(index, item) {
        if (item instanceof _UIServerListItem__WEBPACK_IMPORTED_MODULE_4__["UIServerListItem"]) {
            console.log("1111111111111111111111");
        }
        else {
            console.log("333333333333333333");
        }
        item.itemLabel = this.voServer.serverMap.get(this.clickAreaIndex + 1)[index].serverName;
        //serverBtn.icon = FairyGUI.UIPackage.
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("areaList")
], UISelServerWin.prototype, "areaList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("serverList")
], UISelServerWin.prototype, "serverList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("backBtn")
], UISelServerWin.prototype, "backBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("okBtn")
], UISelServerWin.prototype, "okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("title")
], UISelServerWin.prototype, "title", void 0);


/***/ }),

/***/ "./src/game/module/login/ui/UIServerListItem.ts":
/*!******************************************************!*\
  !*** ./src/game/module/login/ui/UIServerListItem.ts ***!
  \******************************************************/
/*! exports provided: UIServerListItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIServerListItem", function() { return UIServerListItem; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);

/**
 *
 *  此处之所以要引用 UIServerListItem 对象，是因为 V8会GC掉此对象， 但是c#端确仍然存在此Delegate
 *  注意：要将宏： FAIRYGUI_PUERTS 打开才能有效释放引用
 *
 */
let __cacheListItemMap = new Map();
let __id = 0;
class UIServerListItem extends csharp__WEBPACK_IMPORTED_MODULE_0__["FairyGUI"].GButton {
    constructor() {
        super();
        this.itemid = 0;
        this["__onDispose"] = () => { this.onDispose(); };
        __id++;
        this.itemid = __id;
        __cacheListItemMap.set(this.itemid, this);
    }
    onDispose() {
        __cacheListItemMap.delete(this.itemid);
    }
    set itemLabel(txt) {
        this.text = txt;
    }
}


/***/ }),

/***/ "./src/game/module/login/vo/VoServer.ts":
/*!**********************************************!*\
  !*** ./src/game/module/login/vo/VoServer.ts ***!
  \**********************************************/
/*! exports provided: VoServerItem, VoServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServerItem", function() { return VoServerItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServer", function() { return VoServer; });
class VoServerItem {
}
class VoServer {
    constructor() {
        this.serverMap = new Map();
        this.areaMap = new Map();
    }
}


/***/ }),

/***/ "./src/game/module/pve/scene/PveScene.ts":
/*!***********************************************!*\
  !*** ./src/game/module/pve/scene/PveScene.ts ***!
  \***********************************************/
/*! exports provided: PveScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PveScene", function() { return PveScene; });
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");

class PveScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/story/UIStoryWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/story/UIStoryWin.ts ***!
  \*********************************************/
/*! exports provided: UIStoryWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIStoryWin", function() { return UIStoryWin; });
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class UIStoryWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.shouldContineStory = false;
        this.optionsMap = new Map();
    }
    onAwake() {
        super.onAwake();
        this.m_btnList.itemRenderer = (index, obj) => {
            this.renderBtnList(index, obj);
        };
        this.m_btnList.onClickItem.Add((event) => {
            let clickId = this.m_btnList.GetChildIndex(event.data);
            if (this.shouldContineStory) {
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.advanceStory();
            }
            else {
                this.optionsMap.clear();
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.selectChoice(this.allChoices[clickId]);
            }
        });
    }
    onShow(vo) {
        super.onShow(vo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this, this.OnStoryFinished);
        this.optionsMap.clear();
        this.shouldContineStory = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.beginStory("story2");
    }
    OnContentReady(speakerContent, speakerId, currentTags, currentChoices) {
        this.m_speakerTxt.text = speakerContent;
        if (_global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.canContinue) {
            this.shouldContineStory = true;
            this.m_btnList.numItems = 1;
        }
        if (currentChoices.length > 0) {
            this.allChoices = currentChoices;
            this.shouldContineStory = false;
            let len = currentChoices.length;
            for (let i = 0; i < len; i++) {
                this.optionsMap.set(i, currentChoices[i].text);
            }
            this.m_btnList.numItems = len;
        }
    }
    renderBtnList(index, obj) {
        let continueBtn = obj.asButton;
        if (this.optionsMap.size > 0) {
            continueBtn.text = this.optionsMap.get(index);
        }
        else {
            continueBtn.text = "点击继续";
        }
    }
    OnChoicesPresented(currentChoices) {
        this.shouldContineStory = false;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("....OnChoicesPresented......");
    }
    OnStoryFinished() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Story Finished");
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].UIManager.closeWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_0__["storyUI"].UIStoryWin, null);
    }
    onClose(arg) {
        super.onClose(arg);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this.OnStoryFinished);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("speakerTxt")
], UIStoryWin.prototype, "m_speakerTxt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("btnList")
], UIStoryWin.prototype, "m_btnList", void 0);


/***/ }),

/***/ "./src/global/GameConfig.ts":
/*!**********************************!*\
  !*** ./src/global/GameConfig.ts ***!
  \**********************************/
/*! exports provided: GameConfig, S */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameConfig", function() { return GameConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return S; });
/* harmony import */ var _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
/* harmony import */ var _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../framework/net/GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../framework/net/HttpManager */ "./src/framework/net/HttpManager.ts");
/* harmony import */ var _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
/* harmony import */ var _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
/* harmony import */ var _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
/* harmony import */ var _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");










class GameConfig {
}
GameConfig.debug = true;
GameConfig.realmServerIP = "127.0.0.1";
GameConfig.realmServerPort = 9001;
class S {
}
S.UIManager = _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"].Instance(_framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"]);
S.UIMessageManger = _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"].Instance(_game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"]);
S.SceneManager = _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"].Instance(_framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"]);
S.GameObjectPool = _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"].Instance(_framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"]);
S.ResManager = _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]);
S.StoryManager = _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"].Instance(_framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"]);
S.SessionManager = _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"].Instance(_framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"]);
S.GameSession = _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]);
S.StoryMessageManager = _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]);
S.HttpManager = _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"].Instance(_framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"]);


/***/ }),

/***/ "./src/unittest/SingletonTest.ts":
/*!***************************************!*\
  !*** ./src/unittest/SingletonTest.ts ***!
  \***************************************/
/*! exports provided: SingletonTest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SingletonTest", function() { return SingletonTest; });
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/logger/Logger */ "./src/framework/logger/Logger.ts");


class SingletonTest extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.num = 0;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("SingletonTest call constructor");
    }
    add() {
        this.num += 1;
    }
    test() {
        return this.num;
    }
}


/***/ }),

/***/ "./src/unittest/UnitTest.ts":
/*!**********************************!*\
  !*** ./src/unittest/UnitTest.ts ***!
  \**********************************/
/*! exports provided: UnitTest, Event */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnitTest", function() { return UnitTest; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Event", function() { return Event; });
/* harmony import */ var _framework_util_TimeUtil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/util/TimeUtil */ "./src/framework/util/TimeUtil.ts");
/* harmony import */ var _SingletonTest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SingletonTest */ "./src/unittest/SingletonTest.ts");
/* harmony import */ var _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _data_excel_SkillConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../data/excel/SkillConfig */ "./src/data/excel/SkillConfig.ts");
/* harmony import */ var _framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../framework/redhints/RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");
/* harmony import */ var _framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../framework/redhints/RedHintsManager */ "./src/framework/redhints/RedHintsManager.ts");
/* harmony import */ var inkjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! inkjs */ "./node_modules/inkjs/dist/ink-es2015.js");
/* harmony import */ var inkjs__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(inkjs__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _game_entity_PlayerManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../game/entity/PlayerManager */ "./src/game/entity/PlayerManager.ts");
/* harmony import */ var _game_entity_component_BagComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../game/entity/component/BagComponent */ "./src/game/entity/component/BagComponent.ts");
/* harmony import */ var _game_entity_component_PlayerInfoComponent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../game/entity/component/PlayerInfoComponent */ "./src/game/entity/component/PlayerInfoComponent.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_14__);















class UnitTest {
    static async doTest() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("TimeUtil =============================");
        _framework_util_TimeUtil__WEBPACK_IMPORTED_MODULE_0__["TimeUtil"].test();
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("Singleton =============================");
        _SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"].Instance(_SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"]);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("===");
        let t1 = _SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"].Instance(_SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"]);
        let t2 = _SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"].Instance(_SingletonTest__WEBPACK_IMPORTED_MODULE_1__["SingletonTest"]);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(t1.test() + " : " + t2.test());
        t1.add();
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(t1.test() + " : " + t2.test());
        t2.add();
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(t1.test() + " : " + t2.test());
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("Messager =============================");
        let messenger = new _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_2__["Messenger"]();
        let listen = function (a, b) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`listen call: ${a} , ${b}`);
        };
        let listen2 = function (a, b) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`listen call2: ${a} , ${b}`);
        };
        let EVENT_CODE = 100;
        messenger.addListener(EVENT_CODE, this, listen);
        messenger.addListener(EVENT_CODE, this, listen2);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.removeListener(EVENT_CODE, listen);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.clearup();
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("Timer =============================");
        let interval = setInterval(() => {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("inter val..");
        }, 1000);
        let timeout = setTimeout(() => {
            clearInterval(interval);
        }, 5000);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("ResourceManager =============================");
        // let prefab = await ResManager.Instance(ResManager).loadPrefab("Models/1001/Character.prefab") ;
        //Logger.log(prefab);
        //let inst = CS.UnityEngine.GameObject.Instantiate(prefab);
        //inst.name = "Test Ch";
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("引用类型 =============================");
        let testMap = new Map();
        testMap.set("key1", new Array());
        let arr1 = testMap.get("key1");
        arr1.push(12);
        arr1.push(333);
        let arr2 = testMap.get("key1");
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(arr2);
        // Logger.log("FariyGUI =============================");
        //  let page:UI_LoginPage = new UI_LoginPage();
        //  CS.FairyGUI.GRoot.inst.AddChild(page._ui);
        //  Logger.log(page._ui);
        // Logger.log("ModuleManager =============================");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.LoginModule,"create login");
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.LoginModule, "test1",2233);
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.HomeModule, "test2",2233);
        // Logger.log("then create Home");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.HomeModule,"create login");
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("UIManager =============================");
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("excel data =============================");
        let skillMap = _data_excel_SkillConfig__WEBPACK_IMPORTED_MODULE_4__["SkillConfigTB"].Instance(_data_excel_SkillConfig__WEBPACK_IMPORTED_MODULE_4__["SkillConfigTB"]).trs;
        let skilltr = skillMap.get(1003);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`${skilltr._Name} : ${skilltr._AttackType}`);
        let impacttype = skilltr._ImpactType;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(impacttype);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("Protobuf =============================");
        try {
            let c2rLogin = {
                "Account": "test",
                "Password": "1234"
            };
            //验证
            let v1 = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__["nice_ts"].C2R_Login.verify(c2rLogin);
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("verify pb: " + v1);
            let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__["nice_ts"].C2R_Login.create(c2rLogin);
            msg.Account = "test1";
            msg.Password = "1122";
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(msg);
            let buf = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__["nice_ts"].C2R_Login.encode(msg).finish();
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(buf);
            let de_buf = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_8__["nice_ts"].C2R_Login.decode(buf);
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(de_buf.Account);
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(de_buf.Password);
        }
        catch (ex) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(ex);
        }
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("UintArray =============================");
        let opcode_arr = new Uint8Array([257, 25]);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(opcode_arr.subarray(0, 1));
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(opcode_arr.length);
        let opcode_arr2 = new Uint8Array([33]);
        //合并 Uint8Array
        let merge_arr = new Uint8Array(opcode_arr.length + opcode_arr2.length);
        merge_arr.set(opcode_arr2);
        merge_arr.set(opcode_arr, opcode_arr2.length);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(merge_arr.length);
        let n = 5678;
        let buffer = new Uint8Array(4);
        // << 左移  >> 右移  >>> 无符号右移
        //n转uint8Array
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        //unit8Array转n
        n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(n);
        n = 300;
        let buffer1 = new Uint8Array(2);
        buffer1[0] = n >>> 8;
        buffer1[1] = n & 0xff;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(buffer1);
        n = buffer1[0] << 8 | buffer1[1];
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(n);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("sleep =============================");
        await _framework_util_TimeUtil__WEBPACK_IMPORTED_MODULE_0__["TimeUtil"].sleep(1000);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("sleep ..end");
        // Logger.log("flatbuffer =============================");
        // try{
        //     let bytes:ArrayBuffer = await ResManager.Instance(ResManager).loadTextBytes("Config/fb/unitconfig.bytes")
        //     let unitByte = new flatbuffers.ByteBuffer(new Uint8Array(bytes));
        //     Logger.log(unitByte);
        //     let unitconfig:fb.unitconfigTB = fb.unitconfigTB.getRootAsunitconfigTB(unitByte)
        //     Logger.log(unitconfig.unitconfigTRSLength());
        //     for(let i=0; i<unitconfig.unitconfigTRSLength(); i++){
        //         let a =  unitconfig.unitconfigTRS(i);
        //         Logger.log(a.Name());
        //     }
        // }catch(ex){
        //     Logger.error(ex);
        // }
        try {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("测试红点系统 =============================");
            _framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"].Instance(_framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"]).addListener(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat, this, function () {
                _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("red hints chat...");
            });
            _framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"].Instance(_framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"]).addListener(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat_family, this, function () {
                _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("red hints chat_family...");
            });
            _framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"].Instance(_framework_redhints_RedHintsMessageManager__WEBPACK_IMPORTED_MODULE_5__["RedHintsMessageManager"]).addListener(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat_system, this, function () {
                _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("red hints chat...");
            });
            _framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"].Instance(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"]).setRedHintOpenOrClose(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat_family, true);
            let r_chat = _framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"].Instance(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"]).checkRedIsOpen(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat);
            let r_chat_family = _framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"].Instance(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"]).checkRedIsOpen(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat_family);
            let r_chat_system = _framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"].Instance(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["RedHintsManager"]).checkRedIsOpen(_framework_redhints_RedHintsManager__WEBPACK_IMPORTED_MODULE_6__["enumRedHints"].chat_system);
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(r_chat, r_chat_family, r_chat_system);
        }
        catch (error) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(error);
        }
        try {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("Ink Story =============================");
            var json = await (await _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_3__["ResManager"].Instance(_framework_common_ResManager__WEBPACK_IMPORTED_MODULE_3__["ResManager"]).loadTextAsset("Story/TestStory.json")).text;
            let story = new inkjs__WEBPACK_IMPORTED_MODULE_7__["Story"](json);
            story.ChoosePathString("story1", true);
            story.BindExternalFunction("GetCharacterName", () => {
                return "Justin Test";
            });
            story.BindExternalFunctionGeneral("GetCharacterNameByMutiParams", (args) => {
                _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(args.length);
                return "TTTT";
            });
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(story.Continue());
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(story.Continue());
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(story.Continue());
        }
        catch (error) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(error);
        }
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log("HttpManager=========================");
        let txt = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].HttpManager.get("https://www.baidu.com/");
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(txt);
        //Logger.log("entity=========================")
        let player = _game_entity_PlayerManager__WEBPACK_IMPORTED_MODULE_11__["PlayerManager"].Instance(_game_entity_PlayerManager__WEBPACK_IMPORTED_MODULE_11__["PlayerManager"]).getPlayer();
        let bagC = player.addComponent(_game_entity_component_BagComponent__WEBPACK_IMPORTED_MODULE_12__["BagComponent"]);
        //Logger.log(bagC.name);
        let infoC = player.addComponent(_game_entity_component_PlayerInfoComponent__WEBPACK_IMPORTED_MODULE_13__["PlayerInfoComponent"]);
        //Logger.log(infoC.nickName);
        //测试事件
        let event = new Event();
        event.name = "helloEvent";
        //Lambda 表达式订阅
        bagC.subscribe((e) => {
            //Logger.log("Event trigger:"+e.name)
        }, Event);
        let trigger2 = (e) => {
            //Logger.log("Event trigger2:"+e.name)
        };
        //订阅
        bagC.subscribe(trigger2, Event);
        //取消订阅
        bagC.unSubscribe(trigger2, Event);
        bagC.publish(event, Event);
        //test delegate
        csharp__WEBPACK_IMPORTED_MODULE_14__["TestC"].SetPackageItemExtension(new TTestC());
        setInterval(() => {
            let p = csharp__WEBPACK_IMPORTED_MODULE_14__["TestC"].getObj();
            if (p instanceof TTestC) {
                console.log("aaaaaaaaaaaaaaaa");
            }
            else {
                console.log("bbbbbbbbbbbbbbbbbbbb");
            }
        }, 1000);
    }
}
UnitTest.testVar = 10000;
class TTestC extends csharp__WEBPACK_IMPORTED_MODULE_14__["TestP"] {
    test() {
        console.log("hello test delegate");
    }
}
class Event {
}


/***/ }),

/***/ "csharp":
/*!*************************!*\
  !*** external "csharp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("csharp");

/***/ }),

/***/ "puerts":
/*!*************************!*\
  !*** external "puerts" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("puerts");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9kaXN0L2luay1lczIwMTUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DYWxsU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRyb2xDb21tYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvRGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9EaXZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9HbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvSW5rTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0pzb25TZXJpYWxpc2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTGlzdERlZmluaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9MaXN0RGVmaW5pdGlvbnNPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OYXRpdmVGdW5jdGlvbkNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OdWxsRXhjZXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUFJORy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Qb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUHVzaFBvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NlYXJjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NpbXBsZUpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdGF0ZVBhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcFdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdG9yeUV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3J5U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdHJpbmdCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHJ5R2V0UmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHlwZUFzc2VydGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVBc3NpZ25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVSZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9WYXJpYWJsZXNTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2FtZU1haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjZWwvU2tpbGxDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvcGIvT3Bjb2RlLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3BiL2dlbi9wYi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9jb21iYXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvY29tbW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3VpL2hvbWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvbG9naW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvc3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vR2FtZU9iamVjdFBvb2wudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vTWVzc2VuZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vUmVzTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb3JlL0FycmF5TWFwLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvZW50aXR5L0FFbnRpdHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9lbnRpdHkvQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvZW50aXR5L0VudGl0eUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvSW5rU3RhdGVJbnNwZWN0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvSW5rV3JpdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL1N0b3J5TWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9TdG9yeU1lc3NhZ2VNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9HYW1lU2Vzc2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9IdHRwTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9NZXNzYWdlUGFyc2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbmV0L05ldEVycm9yQ29kZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9TZXNzaW9uTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3JlZGhpbnRzL1JlZEhpbnRzTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3JlZGhpbnRzL1JlZEhpbnRzTWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZURlZi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3NjZW5lL1NjZW5lRmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJRGVmaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlMaWIvVUlMb2FkaW5nLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlMaWIvVUlNc2dCb3gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSVBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSVBhbmVsLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlXaW5kb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91dGlsL1RpbWVVdGlsLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2FwaS9Mb2dpbkFQSS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9lbnRpdHkvUGxheWVyLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2VudGl0eS9QbGF5ZXJNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2VudGl0eS9jb21wb25lbnQvQmFnQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2VudGl0eS9jb21wb25lbnQvUGxheWVySW5mb0NvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9ldmVudC9VSU1lc3NhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvZXZlbnQvVUlNZXNzYWdlTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvZ3VpZGUvVUlHdWlkZVdpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS9zY2VuZS9Ib21lU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlIb21lUGFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS91aS9VSVNob3BQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3ZvL1ZvSG9tZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vc2NlbmUvTG9naW5TY2VuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlMb2dpblBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJU2VsU2VydmVyV2luLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlcnZlckxpc3RJdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi92by9Wb1NlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvcHZlL3NjZW5lL1B2ZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9zdG9yeS9VSVN0b3J5V2luLnRzIiwid2VicGFjazovLy8uL3NyYy9nbG9iYWwvR2FtZUNvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdW5pdHRlc3QvU2luZ2xldG9uVGVzdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvdW5pdHRlc3QvVW5pdFRlc3QudHMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY3NoYXJwXCIiLCJ3ZWJwYWNrOi8vL2V4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QUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFJOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSyxJQUFJOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlVYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQSxLQUFLLGFBQWE7QUFDbEI7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCYTtBQUNiOztBQUVBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLFVBQVU7QUFDVixXQUFXLE9BQU87QUFDbEIsYUFBYSxXQUFXO0FBQ3hCOztBQUVBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBLFVBQVU7QUFDVixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsV0FBVztBQUN4QixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4R0EsZUFBZSxLQUFvRCxZQUFZLFNBQW1GLENBQUMsbUJBQW1CLGFBQWEsUUFBUSxjQUFjLHNHQUFzRyxtQkFBbUIsd0JBQXdCLHNFQUFzRSxrQ0FBa0MsaUZBQWlGLHNDQUFzQyxvQ0FBb0MsZ0VBQWdFLGlCQUFpQix3QkFBd0IscUJBQXFCLCtCQUErQixXQUFXLDBEQUEwRCxXQUFXLCtCQUErQix3REFBd0QsZ0JBQWdCLGNBQWMsYUFBYSwrQkFBK0Isb0JBQW9CLGdDQUFnQyxxQ0FBcUMsNkJBQTZCLHNDQUFzQyxJQUFJLDZDQUE2QyxTQUFTLGtCQUFrQixZQUFZLDBCQUEwQixnQkFBZ0IsMkJBQTJCLHVCQUF1QixnQkFBZ0IsWUFBWSxrREFBa0QsUUFBUSxZQUFZLDRCQUE0Qiw0Q0FBNEMsWUFBWSx1QkFBdUIseUNBQXlDLFNBQVMsdUJBQXVCLHFMQUFxTCx3QkFBd0Isc0hBQXNILGlIQUFpSCx3Q0FBd0MsbUpBQW1KLFdBQVcsNkJBQTZCLFVBQVUsb0JBQW9CLDBEQUEwRCwwQ0FBMEMsbUNBQW1DLElBQUksOERBQThELFNBQVMsNEJBQTRCLFlBQVkseUZBQXlGLFVBQVUsZ0JBQWdCLGdDQUFnQyxnQkFBZ0IsOEJBQThCLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLEdBQUcsY0FBYyxxQ0FBcUMsY0FBYyx5QkFBeUIsY0FBYyxzREFBc0QsZ0JBQWdCLFNBQVMsMkJBQTJCLFFBQVEsZUFBZSx5RUFBeUUsY0FBYyxxQkFBcUIsZUFBZSw2QkFBNkIsa0JBQWtCLHlCQUF5QixXQUFXLG9EQUFvRCxVQUFVLCtGQUErRixjQUFjLFNBQVMsZUFBZSxnQkFBZ0IscUZBQXFGLDZCQUE2QixvQkFBb0IsWUFBWSxTQUFTLEdBQUcsdUJBQXVCLGNBQWMsdUNBQXVDLFFBQVEsY0FBYywwREFBMEQsb0JBQW9CLDZGQUE2RixxQkFBcUIsc0JBQXNCLHVCQUF1QiwyQkFBMkIseUJBQXlCLHdCQUF3QixnQ0FBZ0MsTUFBTSw2QkFBNkIsTUFBTSxzQkFBc0Isc0NBQXNDLFlBQVksV0FBVywwREFBMEQsS0FBSyxnQ0FBZ0MsS0FBSyxTQUFTLEVBQUUsV0FBVyxnSUFBZ0ksb0JBQW9CLGtCQUFrQixlQUFlLDZCQUE2QixpQkFBaUIsZ0JBQWdCLHdSQUF3UixnQ0FBZ0MsMERBQTBELHlCQUF5QixtREFBbUQsWUFBWSxJQUFJLEtBQUssNENBQTRDLHNCQUFzQixJQUFJLGtCQUFrQixnQ0FBZ0MsWUFBWSxJQUFJLG1DQUFtQyxjQUFjLG1CQUFtQiw4QkFBOEIsbUJBQW1CLHFCQUFxQixrQkFBa0IseUZBQXlGLEtBQUssc0VBQXNFLDZCQUE2QiwyQkFBMkIsV0FBVyxLQUFLLFNBQVMsWUFBWSxjQUFjLE9BQU8sd0RBQXdELGdCQUFnQixtREFBbUQsUUFBUSxlQUFlLDJDQUEyQyxhQUFhLDBCQUEwQixVQUFVLDJCQUEyQixjQUFjLDZDQUE2QyxxQkFBcUIseUJBQXlCLE1BQU0sZ0NBQWdDLFdBQVcsb0JBQW9CLFFBQVEsY0FBYyxrRUFBa0Usa0NBQWtDLGtDQUFrQyxzQkFBc0IseUNBQXlDLHlDQUF5QyxrQkFBa0Isd0JBQXdCLGFBQWEsa0RBQWtELGVBQWUscUVBQXFFLFdBQVcscUJBQXFCLFVBQVUsbUJBQW1CLFFBQVEsZ0VBQWdFLFNBQVMsT0FBTyw0Q0FBNEMsYUFBYSx1QkFBdUIsa0RBQWtELEVBQUUsNEJBQTRCLG9CQUFvQix5Q0FBeUMsUUFBUSxzQ0FBc0MsNEJBQTRCLHVOQUF1TixvQkFBb0IsY0FBYyxvSEFBb0gsbUJBQW1CLDJEQUEyRCx1Q0FBdUMsa0NBQWtDLDZCQUE2QixxREFBcUQsMEdBQTBHLHdCQUF3QixpSEFBaUgsbUJBQW1CLHlCQUF5QixXQUFXLG1CQUFtQixRQUFRLDJEQUEyRCxnREFBZ0QsbURBQW1ELGdDQUFnQyw2Q0FBNkMsOEhBQThILGtPQUFrTyxlQUFlLGdEQUFnRCwyQkFBMkIsaUNBQWlDLDhCQUE4QixnSUFBZ0ksS0FBSyw2SkFBNkosMENBQTBDLGVBQWUscUJBQXFCLG1CQUFtQiwrQ0FBK0MsU0FBUyxlQUFlLGdDQUFnQyxTQUFTLHFCQUFxQiwyRUFBMkUsY0FBYyxVQUFVLG1DQUFtQyxZQUFZLGlCQUFpQixzQkFBc0Isa0NBQWtDLHlDQUF5QyxvREFBb0Qsa0JBQWtCLGlCQUFpQixrSUFBa0ksbUJBQW1CLDZCQUE2QixtREFBbUQsc0NBQXNDLHlCQUF5Qix3QkFBd0Isc0JBQXNCLHlCQUF5Qix5Q0FBeUMsY0FBYyxPQUFPLG9CQUFvQixxQkFBcUIsNkJBQTZCLCtCQUErQixjQUFjLEVBQUUsU0FBUyxjQUFjLE9BQU8sb0JBQW9CLHFCQUFxQiw2QkFBNkIsK0JBQStCLGNBQWMsRUFBRSxTQUFTLGNBQWMsWUFBWSx3RUFBd0UsNkJBQTZCLGdDQUFnQyxTQUFTLFVBQVUsWUFBWSx3RUFBd0UsNkJBQTZCLHdCQUF3QixTQUFTLFNBQVMsa0JBQWtCLDRCQUE0QixTQUFTLGFBQWEsWUFBWSx5Q0FBeUMsU0FBUyxXQUFXLGtCQUFrQiwyQkFBMkIsU0FBUyxZQUFZLHdDQUF3QyxTQUFTLGVBQWUsdUVBQXVFLHVCQUF1Qiw2R0FBNkcsWUFBWSx1RUFBdUUsb0JBQW9CLDZHQUE2RyxZQUFZLDhDQUE4QyxZQUFZLDhDQUE4QyxzQkFBc0IsOEJBQThCLHNEQUFzRCw4SUFBOEksWUFBWSwwQ0FBMEMsNERBQTRELFNBQVMsVUFBVSwrQkFBK0IsZ0NBQWdDLHdDQUF3QyxTQUFTLG1CQUFtQixnQkFBZ0IscUJBQXFCLDZCQUE2QixRQUFRLGNBQWMsRUFBRSw2TkFBNk4sV0FBVyxnQ0FBZ0MsWUFBWSxXQUFXLEtBQUssb0JBQW9CLGVBQWUsK0NBQStDLHFCQUFxQixvQkFBb0IsVUFBVSxZQUFZLHNCQUFzQixlQUFlLDZFQUE2RSxrQkFBa0IsbUJBQW1CLG9CQUFvQixlQUFlLG1CQUFtQixtQkFBbUIsRUFBRSxvQkFBb0Isa0JBQWtCLG1CQUFtQixNQUFNLGtFQUFrRSxrREFBa0Qsd0JBQXdCLFVBQVUsZ0xBQWdMLE9BQU8sMkJBQTJCLG9CQUFvQiwrRUFBK0Usa0JBQWtCLGVBQWUscUJBQXFCLGtCQUFrQixrQkFBa0IsV0FBVyxpRUFBaUUsa0JBQWtCLGVBQWUsWUFBWSxlQUFlLHFCQUFxQixnQkFBZ0IsYUFBYSxRQUFRLDZDQUE2QyxpQ0FBaUMsdUNBQXVDLDJDQUEyQyxnQ0FBZ0Msa0JBQWtCLGVBQWUsWUFBWSxlQUFlLHFCQUFxQixnQkFBZ0IsZUFBZSxRQUFRLDZDQUE2QyxpQ0FBaUMscUNBQXFDLDJDQUEyQyxnQ0FBZ0Msa0JBQWtCLGVBQWUsdUhBQXVILHNHQUFzRyxnQkFBZ0IsZ0JBQWdCLGVBQWUsOERBQThELGdCQUFnQix1QkFBdUIseUJBQXlCLGdDQUFnQyxzQkFBc0IsZ0RBQWdELFFBQVEsaUNBQWlDLGFBQWEsc0JBQXNCLGtCQUFrQix3QkFBd0IsbUJBQW1CLEVBQUUsb0JBQW9CLGFBQWEsbUNBQW1DLCtCQUErQixlQUFlLHNCQUFzQixvQkFBb0Isd0JBQXdCLG1CQUFtQixFQUFFLG9CQUFvQixhQUFhLG1DQUFtQywrQkFBK0IsZ0NBQWdDLGtCQUFrQixlQUFlLFNBQVMsZ0JBQWdCLHNCQUFzQixpQkFBaUIscURBQXFELGtCQUFrQixhQUFhLGVBQWUsMkVBQTJFLFFBQVEsaUNBQWlDLCtCQUErQixXQUFXLGdEQUFnRCxrQkFBa0Isb0JBQW9CLDhCQUE4QixtQkFBbUIsMEJBQTBCLG9CQUFvQixxQkFBcUIsbUJBQW1CLHFEQUFxRCxvQkFBb0IsYUFBYSxnQkFBZ0IseUJBQXlCLGVBQWUsOEVBQThFLFFBQVEsaUNBQWlDLCtCQUErQixXQUFXLG9EQUFvRCxPQUFPLG1EQUFtRCxrQkFBa0IsZUFBZSw0REFBNEQsZ0JBQWdCLGNBQWMsUUFBUSw2Q0FBNkMsYUFBYSx5QkFBeUIsNENBQTRDLGVBQWUseUJBQXlCLDRDQUE0QyxnQkFBZ0IseUJBQXlCLHNEQUFzRCxpQ0FBaUMsK0JBQStCLGlCQUFpQiwyR0FBMkcsY0FBYyxvQkFBb0IsMkNBQTJDLHNCQUFzQixtS0FBbUssYUFBYSw0SkFBNEosU0FBUyxHQUFHLFFBQVEsY0FBYyxrQ0FBa0MsaUJBQWlCLHNDQUFzQyxnQkFBZ0IsMkNBQTJDLE9BQU8sWUFBWSx3REFBd0Qsa0JBQWtCLGNBQWMseU1BQXlNLG1CQUFtQiwyQ0FBMkMsY0FBYyxxQkFBcUIsZUFBZSxtQkFBbUIsdUJBQXVCLGNBQWMsa0NBQWtDLGFBQWEsV0FBVywyQkFBMkIsV0FBVywwQ0FBMEMsNkJBQTZCLHdCQUF3Qiw0QkFBNEIsc0RBQXNELDRCQUE0QixXQUFXLHdDQUF3QyxpQkFBaUIsUUFBUSxzTkFBc04sa0JBQWtCLFFBQVEseUxBQXlMLDZCQUE2QiwwS0FBMEsscUNBQXFDLGdCQUFnQixLQUFLLGVBQWUsaUVBQWlFLGdCQUFnQixjQUFjLHVCQUF1QixRQUFRLGtDQUFrQyxLQUFLLFFBQVEscUZBQXFGLDBDQUEwQyxzQkFBc0IsV0FBVyx1REFBdUQseUJBQXlCLDJIQUEySCwwQkFBMEIsb0JBQW9CLFlBQVksaUJBQWlCLGtCQUFrQixZQUFZLElBQUksS0FBSyx3QkFBd0IsWUFBWSxpQkFBaUIsTUFBTSxvQ0FBb0MsWUFBWSxpQkFBaUIsTUFBTSxhQUFhLGlCQUFpQixtQkFBbUIsaUZBQWlGLHlDQUF5QywwQkFBMEIsNENBQTRDLGdFQUFnRSw0QkFBNEIsdUZBQXVGLGtDQUFrQyw0Q0FBNEMsdUNBQXVDLG9DQUFvQyx5QkFBeUIsTUFBTSx5RkFBeUYsZUFBZSxrQ0FBa0MsYUFBYSxZQUFZLE1BQU0sa0JBQWtCLHdEQUF3RCxFQUFFLDZEQUE2RCxZQUFZLHNCQUFzQixLQUFLLHNCQUFzQixtQkFBbUIsZ0NBQWdDLHdIQUF3SCxnR0FBZ0csY0FBYyw2RUFBNkUsYUFBYSxpQ0FBaUMsaUJBQWlCLHdHQUF3Ryx1QkFBdUIsYUFBYSxNQUFNLGFBQWEsbUZBQW1GLGlDQUFpQyxHQUFHLFNBQVMsR0FBRyxrQkFBa0IsV0FBVyxjQUFjLGtCQUFrQixvQ0FBb0MsNEJBQTRCLGtCQUFrQix5QkFBeUIsT0FBTywrQkFBK0IsbUJBQW1CLHNDQUFzQyxvQkFBb0IsdUNBQXVDLGlCQUFpQixvQ0FBb0MsbUJBQW1CLHNDQUFzQywyQkFBMkIsOENBQThDLHFCQUFxQix3Q0FBd0MsbUJBQW1CLHNDQUFzQyxxQkFBcUIsd0NBQXdDLG1CQUFtQixzQ0FBc0MsY0FBYyxpQ0FBaUMscUJBQXFCLHdDQUF3QyxlQUFlLGtDQUFrQyxvQkFBb0IsdUNBQXVDLG1CQUFtQixzQ0FBc0MsZ0JBQWdCLG1DQUFtQyxvQkFBb0IsdUNBQXVDLG9CQUFvQix1Q0FBdUMsOEJBQThCLGlEQUFpRCxxQkFBcUIsd0NBQXdDLGNBQWMsaUNBQWlDLGFBQWEsZ0NBQWdDLHFCQUFxQix3Q0FBd0MsbUJBQW1CLHNDQUFzQyxvQkFBb0IsdUNBQXVDLFdBQVcsb0NBQW9DLGFBQWEsTUFBTSxhQUFhLG94QkFBb3hCLG1DQUFtQyxHQUFHLFNBQVMsZUFBZSxpSEFBaUgsU0FBUyxHQUFHLFFBQVEsY0FBYyw4R0FBOEcsVUFBVSwrTEFBK0wsYUFBYSw0QkFBNEIsV0FBVyxvSUFBb0ksV0FBVyxvSEFBb0gsT0FBTyx3Q0FBd0Msa0JBQWtCLGtCQUFrQixrQkFBa0IsdUJBQXVCLGtCQUFrQixlQUFlLDZRQUE2USxpQkFBaUIsd0RBQXdELG1DQUFtQyw2QkFBNkIsd0JBQXdCLGtCQUFrQiw4Q0FBOEMsb0JBQW9CLCtCQUErQiw2Q0FBNkMsd0RBQXdELG9GQUFvRiwyQ0FBMkMsa0NBQWtDLGlJQUFpSSwwREFBMEQsa0NBQWtDLHVCQUF1QiwwRUFBMEUsd0JBQXdCLHNDQUFzQyx3QkFBd0IscUNBQXFDLFVBQVUsUUFBUSw0TkFBNE4sV0FBVyxnRkFBZ0YsK0NBQStDLHlDQUF5QyxvUUFBb1Esa0JBQWtCLGtCQUFrQixzS0FBc0ssbUJBQW1CLDREQUE0RCx3QkFBd0IsK0JBQStCLDBCQUEwQixvQkFBb0IscUJBQXFCLG1CQUFtQiwrR0FBK0cseUJBQXlCLHdHQUF3RywwQkFBMEIsMkJBQTJCLFlBQVksUUFBUSx5SkFBeUosYUFBYSxnSkFBZ0osV0FBVyxpRUFBaUUsa0RBQWtELGtCQUFrQixvQkFBb0IsMkNBQTJDLHdCQUF3QixtRkFBbUYseUJBQXlCLCtFQUErRSwwQkFBMEIseUNBQXlDLFdBQVcsOENBQThDLGlEQUFpRCxrQkFBa0IsaUJBQWlCLDZFQUE2RSxXQUFXLHlDQUF5QyxtQkFBbUIsa0JBQWtCLGNBQWMsc0xBQXNMLDhCQUE4QixtQkFBbUIsbURBQW1ELDhCQUE4QixrQ0FBa0MsNERBQTRELHVCQUF1QixnQkFBZ0IsNkJBQTZCLDhFQUE4RSxXQUFXLGtFQUFrRSxZQUFZLDhKQUE4Six5QkFBeUIsbUZBQW1GLDBCQUEwQiwyQkFBMkIsUUFBUSxrREFBa0Qsd0ZBQXdGLFNBQVMsZ0JBQWdCLHNKQUFzSix1QkFBdUIseURBQXlELHdEQUF3RCw2RkFBNkYsWUFBWSw2Q0FBNkMsZUFBZSw4RUFBOEUsa0NBQWtDLE9BQU8sYUFBYSw0REFBNEQsU0FBUyxvQkFBb0Isc0ZBQXNGLHlCQUF5QixvQkFBb0IsUUFBUSxvRUFBb0UsaUJBQWlCLDRHQUE0RyxvRkFBb0YsMkJBQTJCLGtIQUFrSCw0QkFBNEIsa0ZBQWtGLDhFQUE4RSxzQ0FBc0Msc0VBQXNFLHVDQUF1QyxnQkFBZ0Isd0VBQXdFLGtHQUFrRyw4QkFBOEIsb0NBQW9DLDBGQUEwRix3QkFBd0IsNkJBQTZCLDhFQUE4RSxzQ0FBc0MseUZBQXlGLDBCQUEwQiwwR0FBMEcsc0RBQXNELElBQUksTUFBTSxZQUFZLHNDQUFzQyw2QkFBNkIsZ0JBQWdCLDRCQUE0QixtQkFBbUIsZ0JBQWdCLGFBQWEsK0RBQStELFNBQVMsbUNBQW1DLGFBQWEsaUNBQWlDLEtBQUssdUJBQXVCLHVCQUF1QixvRUFBb0UsOEJBQThCLHlHQUF5Ryw4QkFBOEIseUVBQXlFLHNDQUFzQyxzRkFBc0Ysd0JBQXdCLGFBQWEscUJBQXFCLHFCQUFxQixVQUFVLFNBQVMsbUJBQW1CLFNBQVMsNENBQTRDLGdDQUFnQyx1L0dBQXUvRyxzREFBc0QsaUhBQWlILHNCQUFzQix5RkFBeUYsa0NBQWtDLGdGQUFnRixtQ0FBbUMseUVBQXlFLDJCQUEyQixvQ0FBb0MsMEJBQTBCLG9DQUFvQyw2QkFBNkIsc0NBQXNDLDRCQUE0QixzQ0FBc0MsOEJBQThCLHVDQUF1Qyw0QkFBNEIscUNBQXFDLDJCQUEyQixxQ0FBcUMsV0FBVyxnQ0FBZ0MsMGZBQTBmLGtCQUFrQixlQUFlLG1DQUFtQyxXQUFXLHNCQUFzQixrQkFBa0IsY0FBYyx5S0FBeUsseUJBQXlCLGdGQUFnRiwwQkFBMEIsMEJBQTBCLFFBQVEsaUJBQWlCLG9FQUFvRSxXQUFXLGtCQUFrQixZQUFZLHNCQUFzQixvQkFBb0IsdUNBQXVDLHlCQUF5QixtQ0FBbUMsbUJBQW1CLGdCQUFnQix3QkFBd0IsNkNBQTZDLHNCQUFzQixnQkFBZ0Isc0ZBQXNGLHdCQUF3QixxQ0FBcUMseUJBQXlCLHFEQUFxRCxxQ0FBcUMsT0FBTyx5QkFBeUIsd0JBQXdCLHNCQUFzQixvQkFBb0IsNkNBQTZDLFVBQVUsbUJBQW1CLEVBQUUscUJBQXFCLFFBQVEsZUFBZSwrREFBK0QsZ0JBQWdCLDBCQUEwQix3QkFBd0IsMENBQTBDLHNFQUFzRSw0R0FBNEcsWUFBWSxTQUFTLG9DQUFvQyxTQUFTLDBCQUEwQixtQkFBbUIsb0JBQW9CLHlCQUF5QixVQUFVLG1CQUFtQixFQUFFLG9CQUFvQiw4QkFBOEIsNkJBQTZCLGdEQUFnRCwwQkFBMEIsUUFBUSxzQ0FBc0MsZUFBZSxPQUFPLFNBQVMsWUFBWSxJQUFJLEtBQUssMkNBQTJDLG1DQUFtQyxVQUFVLFNBQVMsdUNBQXVDLHFCQUFxQiwyRkFBMkYsbUJBQW1CLGlDQUFpQyxvQkFBb0IsNENBQTRDLGtCQUFrQiwrQkFBK0IscUJBQXFCLHlDQUF5QyxtQkFBbUIsK0JBQStCLGFBQWEsaURBQWlELGFBQWEsTUFBTSxhQUFhLGdaQUFnWixhQUFhLHFJQUFxSSxhQUFhLHFDQUFxQyxhQUFhLHVDQUF1QyxhQUFhLDZJQUE2SSxhQUFhLHdDQUF3QyxhQUFhLGtKQUFrSixhQUFhLGlJQUFpSSxvQ0FBb0MsYUFBYSxnRUFBZ0UsYUFBYSxNQUFNLGFBQWEsdUNBQXVDLGFBQWEsTUFBTSxxQkFBcUIsMkJBQTJCLGdHQUFnRyxhQUFhLE1BQU0scUJBQXFCLGdDQUFnQyw4R0FBOEcsc0NBQXNDLGFBQWEscUZBQXFGLGFBQWEsNEVBQTRFLHNCQUFzQix5Q0FBeUMsY0FBYyx1Q0FBdUMsdUNBQXVDLGtDQUFrQyxXQUFXLFNBQVMsaUNBQWlDLGNBQWMsNERBQTRELFNBQVMsZ0NBQWdDLG9EQUFvRCx1QkFBdUIsMEJBQTBCLHVDQUF1QywyQ0FBMkMsd0JBQXdCLFlBQVksZ0NBQWdDLEtBQUssZ0RBQWdELHFFQUFxRSxrQ0FBa0Msb0NBQW9DLDBCQUEwQiwwQ0FBMEMsVUFBVSx5REFBeUQsY0FBYyxZQUFZLDBCQUEwQixzREFBc0QsZ0NBQWdDLCtJQUErSSxZQUFZLG1EQUFtRCxtQkFBbUIsa0lBQWtJLGFBQWEsWUFBWSw0RUFBNEUsMENBQTBDLGdCQUFnQixZQUFZLDJDQUEyQyxjQUFjLDREQUE0RCx3Q0FBd0Msc0JBQXNCLHVEQUF1RCxhQUFhLGdCQUFnQixnQkFBZ0IsUUFBUSwyQkFBMkIsdUNBQXVDLG9DQUFvQyxXQUFXLGdCQUFnQiw2REFBNkQscURBQXFELHVCQUF1QixpRkFBaUYsdUNBQXVDLHNEQUFzRCxvREFBb0QsNkVBQTZFLHFEQUFxRCxpQkFBaUIsZ0ZBQWdGLHFGQUFxRiw0QkFBNEIsWUFBWSw0Q0FBNEMsb0JBQW9CLFlBQVksY0FBYyxzREFBc0QsdUNBQXVDLEtBQUssZ0RBQWdELHlCQUF5QixxQkFBcUIsU0FBUywwQkFBMEIsWUFBWSw0TUFBNE0sd0JBQXdCLGlSQUFpUix5QkFBeUIsY0FBYyxnQ0FBZ0MsdUVBQXVFLGtCQUFrQixpQ0FBaUMsK0NBQStDLCtNQUErTSxvR0FBb0csb0RBQW9ELHNDQUFzQyx1Q0FBdUMsbUJBQW1CLGtDQUFrQyxTQUFTLHNCQUFzQixTQUFTLHdCQUF3Qiw2QkFBNkIsK0NBQStDLGdCQUFnQixZQUFZLFNBQVMsa0NBQWtDLGFBQWEsdUNBQXVDLG9DQUFvQyx1Q0FBdUMsV0FBVyxxQkFBcUIsaUJBQWlCLFVBQVUsaUJBQWlCLDZCQUE2QixTQUFTLDJ6QkFBMnpCLFlBQVksNkJBQTZCLHdGQUF3RixTQUFTLElBQUksUUFBUSxjQUFjLDRFQUE0RSxtQkFBbUIsaUVBQWlFLEtBQUssbUJBQW1CLGlCQUFpQixxREFBcUQsdUVBQXVFLGVBQWUsc0JBQXNCLFlBQVksNEJBQTRCLHFCQUFxQixzREFBc0QscUJBQXFCLDBCQUEwQiwrQkFBK0Isb0JBQW9CLDZDQUE2QyxxQkFBcUIsK0pBQStKLGFBQWEsK0JBQStCLFFBQVEsNkhBQTZILGtCQUFrQix1QkFBdUIsZ0JBQWdCLGdCQUFnQiw0QkFBNEIsc0JBQXNCLGtHQUFrRyxhQUFhLGtCQUFrQixvREFBb0QsMENBQTBDLGtJQUFrSSxFQUFFLGFBQWEsZ0NBQWdDLDhFQUE4RSxhQUFhLGdDQUFnQyxpRUFBaUUsWUFBWSwwREFBMEQsa0VBQWtFLG1CQUFtQiwrREFBK0QsZ0NBQWdDLDhEQUE4RCxnQkFBZ0IsNkRBQTZELDJGQUEyRixlQUFlLDREQUE0RCxZQUFZLHVFQUF1RSxxQkFBcUIscUNBQXFDLHNDQUFzQyx1REFBdUQsOEJBQThCLGlDQUFpQyxzQ0FBc0MsMEJBQTBCLGdHQUFnRyxxQ0FBcUMscUZBQXFGLDJCQUEyQixrRkFBa0YsbUJBQW1CLCtCQUErQiw2QkFBNkIsRUFBRSw0QkFBNEIsZ0JBQWdCLG9DQUFvQyxxQkFBcUIsWUFBWSxZQUFZLHVCQUF1QixLQUFLLG1EQUFtRCw0QkFBNEIsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLG1EQUFtRCxZQUFZLHFCQUFxQixLQUFLLGtGQUFrRixvQ0FBb0MsY0FBYywrRUFBK0UsMERBQTBELHFCQUFxQixhQUFhLFFBQVEsc0JBQXNCLGlMQUFpTCxPQUFPLHVFQUF1RSxzTUFBc00sWUFBWSxRQUFRLGNBQWMsZ0dBQWdHLGtDQUFrQyx5Q0FBeUMsa0JBQWtCLGdCQUFnQixnREFBZ0QsZUFBZSxlQUFlLGdDQUFnQyxnTkFBZ04sa0JBQWtCLG9EQUFvRCw0TkFBNE4sc0NBQXNDLHdIQUF3SCw4QkFBOEIsZUFBZSwwQkFBMEIsMENBQTBDLE9BQU8sWUFBWSwrQkFBK0IsdURBQXVELHVEQUF1RCxhQUFhLDJFQUEyRSw2QkFBNkIsa0RBQWtELDZFQUE2RSwySEFBMkgsMk9BQTJPLDJIQUEySCxxQ0FBcUMsdURBQXVELDJEQUEyRCxvQkFBb0IsV0FBVyxTQUFTLEdBQUcsUUFBUSxpQkFBaUIsbVBBQW1QLElBQUksdUJBQXVCLHVFQUF1RSxFQUFFLFdBQVcsMEJBQTBCLHVEQUF1RCxvQ0FBb0MsMkNBQTJDLHFDQUFxQyxxRkFBcUYsaURBQWlELGdEQUFnRCxtQ0FBbUMsbURBQW1ELHdDQUF3QyxnQkFBZ0IsdUJBQXVCLGlCQUFpQixrQkFBa0IsT0FBTyxlQUFlLFdBQVcsZ05BQWdOLDBJQUEwSSxrQkFBa0IsMkhBQTJILHFCQUFxQixhQUFhLDRDQUE0QyxpRUFBaUUsOEhBQThILGdCQUFnQixnQkFBZ0IsOEJBQThCLDZDQUE2QyxXQUFXLGVBQWUsaUNBQWlDLHVDQUF1QywrQkFBK0IscUNBQXFDLGFBQWEscUJBQXFCLHNDQUFzQyxZQUFZLGlFQUFpRSwwQ0FBMEMsMENBQTBDLHVFQUF1RSxtQkFBbUIseUJBQXlCLDZCQUE2Qiw2QkFBNkIsMENBQTBDLGFBQWEsMENBQTBDLGFBQWEsMENBQTBDLHNCQUFzQixrSUFBa0ksbUdBQW1HLDRCQUE0QixnREFBZ0Qsc0RBQXNELDhCQUE4Qiw2Q0FBNkMsOEJBQThCLGdDQUFnQyw4R0FBOEcsNEJBQTRCLFdBQVcsZ0JBQWdCLFdBQVcsbUZBQW1GLDhEQUE4RCw0R0FBNEcsMEVBQTBFLHlEQUF5RCxjQUFjLDZEQUE2RCwwQkFBMEIsK0RBQStELFlBQVkscUJBQXFCLDZCQUE2QixjQUFjLDRGQUE0RixhQUFhLGFBQWEsa0NBQWtDLEtBQUssV0FBVyxHQUFHLDRGQUE0RixlQUFlLHFGQUFxRix5QkFBeUIsNERBQTRELG9DQUFvQyxzQkFBc0IsdUZBQXVGLGVBQWUsV0FBVyw4T0FBOE8sOEtBQThLLDBGQUEwRixzSUFBc0ksb0NBQW9DLDBCQUEwQixxQkFBcUIsK0RBQStELHlEQUF5RCx5Q0FBeUMsa0NBQWtDLGtGQUFrRix5QkFBeUIsNENBQTRDLDJCQUEyQixRQUFRLGVBQWUsNkRBQTZELE9BQU8sNENBQTRDLFlBQVksa0NBQWtDLFFBQVEsY0FBYyxpSUFBaUksbUJBQW1CLDBLQUEwSyw4R0FBOEcsY0FBYyxxQkFBcUIsdUJBQXVCLDhCQUE4QixrQkFBa0IseUJBQXlCLGtCQUFrQix5QkFBeUIsa0JBQWtCLHVDQUF1QyxzQ0FBc0MsRUFBRSxvQkFBb0IsZUFBZSx1QkFBdUIsc0JBQXNCLHFDQUFxQyxzQkFBc0IsaUNBQWlDLDBDQUEwQyxFQUFFLG9CQUFvQixtQkFBbUIsMkJBQTJCLGtCQUFrQiwyQkFBMkIscUJBQXFCLGlDQUFpQywwQ0FBMEMsRUFBRSxxQkFBcUIsUUFBUSwyQkFBMkIsc0NBQXNDLHNCQUFzQixrQ0FBa0MsYUFBYSxlQUFlLGVBQWUsK0JBQStCLGVBQWUsd0JBQXdCLFVBQVUsMEJBQTBCLFFBQVEsY0FBYyxzSkFBc0osZUFBZSxzREFBc0QsbUJBQW1CLHdCQUF3QixTQUFTLHlDQUF5Qyx3RkFBd0Ysb0NBQW9DLDBEQUEwRCxrUEFBa1Asd0VBQXdFLGlCQUFpQixtR0FBbUcsbUJBQW1CLCtEQUErRCx1QkFBdUIsS0FBSyxtQkFBbUIsY0FBYyx3QkFBd0Isc0JBQXNCLG9FQUFvRSx3QkFBd0Isc0VBQXNFLHNCQUFzQixxTEFBcUwsbUJBQW1CLDBHQUEwRyx5QkFBeUIsZ1FBQWdRLHVCQUF1QixrTkFBa04sMEJBQTBCLGlJQUFpSSxrQkFBa0Isd0JBQXdCLFNBQVMseUNBQXlDLHdGQUF3RixvQ0FBb0MsMERBQTBELGtQQUFrUCx1RUFBdUUsZ0JBQWdCLGtHQUFrRyxjQUFjLHVIQUF1SCxZQUFZLDRFQUE0RSxjQUFjLDhOQUE4TixZQUFZLHVEQUF1RCxtQkFBbUIsdUhBQXVILGlCQUFpQiw2SUFBNkkseUJBQXlCLHdJQUF3SSxXQUFXLG1FQUFtRSxrQkFBa0IseVhBQXlYLFlBQVksc0dBQXNHLGlCQUFpQiwwRkFBMEYsd0JBQXdCLGlHQUFpRywwQkFBMEIsdUdBQXVHLHNCQUFzQix1Q0FBdUMsNkJBQTZCLHdDQUF3QyxVQUFVLHNEQUFzRCx1QkFBdUIsNFhBQTRYLHVCQUF1QixNQUFNLGFBQWEsb0pBQW9KLHVCQUF1QixHQUFHLHFCQUFxQixlQUFlLDhEQUE4RCx5QkFBeUIsR0FBRyxTQUFTLEdBQUcsUUFBUSxlQUFlLHFsQkFBcWxCLDJCQUEyQixrR0FBa0csYUFBYSxtQkFBbUIsc0NBQXNDLGFBQWEsc0JBQXNCLFlBQVksNEJBQTRCLG9CQUFvQiwwQkFBMEIsTUFBTSx1QkFBdUIsbURBQW1ELDZEQUE2RCxnRUFBZ0UseURBQXlELDBCQUEwQixrQ0FBa0MsK0xBQStMLHVCQUF1Qix3Q0FBd0MsNEJBQTRCLHNEQUFzRCwyQkFBMkIsbUNBQW1DLHVCQUF1QixxQ0FBcUMsK0NBQStDLHNEQUFzRCx3RUFBd0UsbUNBQW1DLG9GQUFvRix3QkFBd0IsK0NBQStDLDBCQUEwQixnTkFBZ04sdUNBQXVDLGtEQUFrRCxtREFBbUQsa0RBQWtELHFCQUFxQiw0QkFBNEIsbUJBQW1CLDBCQUEwQixxQkFBcUIsZ0RBQWdELHVCQUF1Qiw0QkFBNEIsb0JBQW9CLDJCQUEyQixzQkFBc0IsNkJBQTZCLHFCQUFxQiw0QkFBNEIsc0JBQXNCLHVCQUF1QixzQkFBc0IsNkJBQTZCLGtCQUFrQix5QkFBeUIsa0JBQWtCLHlCQUF5Qix1QkFBdUIsOEJBQThCLHdCQUF3Qix5QkFBeUIsd0JBQXdCLDBCQUEwQix1RUFBdUUscUJBQXFCLDJEQUEyRCxzQkFBc0Isc0RBQXNELHNCQUFzQiwyREFBMkQsdUJBQXVCLHNEQUFzRCxrQkFBa0Isa0RBQWtELGVBQWUsNkRBQTZELGlCQUFpQixpRUFBaUUsa0JBQWtCLGdDQUFnQyxZQUFZLGlDQUFpQyxhQUFhLDRCQUE0QiwwRkFBMEYseUJBQXlCLHlCQUF5QixxQkFBcUIsWUFBWSxXQUFXLEtBQUssb0NBQW9DLDRGQUE0RixvQkFBb0Isa0JBQWtCLGdDQUFnQyxxQkFBcUIsaUNBQWlDLGFBQWEseUNBQXlDLCtCQUErQix5QkFBeUIsNkJBQTZCLDREQUE0RCw4QkFBOEIsdURBQXVELFlBQVksd0ZBQXdGLHVCQUF1Qix3QkFBd0IsbTdCQUFtN0Isb0JBQW9CLG1GQUFtRixnQkFBZ0IsdUJBQXVCLGlDQUFpQyxzRUFBc0Usc0VBQXNFLGtCQUFrQix5QkFBeUIsaUVBQWlFLGFBQWEscUJBQXFCLFNBQVMsbUNBQW1DLGdFQUFnRSwrUkFBK1IsNlhBQTZYLG9CQUFvQixxREFBcUQsa0JBQWtCLGdDQUFnQyxnRUFBZ0Usa0ZBQWtGLGljQUFpYyxlQUFlLDJCQUEyQixpRUFBaUUsd01BQXdNLCtUQUErVCw0QkFBNEIsWUFBWSwwQkFBMEIsaURBQWlELGtQQUFrUCxzQkFBc0IsbUNBQW1DLDREQUE0RCx5Q0FBeUMsS0FBSywwQ0FBMEMsa0RBQWtELGNBQWMsb0RBQW9ELG9CQUFvQixtSEFBbUgsc0JBQXNCLGFBQWEsYUFBYSw2Q0FBNkMsYUFBYSxvREFBb0Qsc0NBQXNDLDhEQUE4RCx1QkFBdUIsZ0ZBQWdGLGtDQUFrQyxjQUFjLHFDQUFxQyxjQUFjLFlBQVksV0FBVyxLQUFLLFdBQVcsWUFBWSw0QkFBNEIsTUFBTSxpQkFBaUIsY0FBYyxZQUFZLFdBQVcsS0FBSyxXQUFXLFlBQVksNEJBQTRCLE1BQU0saUJBQWlCLDRCQUE0Qix3QkFBd0IsVUFBVSxRQUFRLDhCQUE4QixVQUFVLDBCQUEwQixxQkFBcUIseUJBQXlCLGlCQUFpQixtREFBbUQsK0NBQStDLFVBQVUsU0FBUyxnQ0FBZ0MsMkJBQTJCLDhDQUE4QyxXQUFXLHlDQUF5QyxzREFBc0QsU0FBUyxzQ0FBc0MsS0FBSyxLQUFLLG9EQUFvRCxrQ0FBa0MsSUFBSSxNQUFNLHNEQUFzRCxhQUFhLE9BQU8sU0FBUyxpREFBaUQsb0JBQW9CLG1FQUFtRSw4QkFBOEIscUJBQXFCLEtBQUssS0FBSyxXQUFXLDRCQUE0QixtQ0FBbUMsOEZBQThGLE1BQU0sNEJBQTRCLHFEQUFxRCwrQkFBK0IsdUNBQXVDLEtBQUssS0FBSyxFQUFFLDhDQUE4Qyw2Q0FBNkMsZ0NBQWdDLGdCQUFnQiw0QkFBNEIsRUFBRSw4REFBOEQseUJBQXlCLHFCQUFxQixzQ0FBc0MsS0FBSyxLQUFLLDRCQUE0QixpREFBaUQsNkJBQTZCLHlCQUF5QixnQ0FBZ0MscUVBQXFFLEtBQUssS0FBSywyQ0FBMkMsNEJBQTRCLG1CQUFtQix3QkFBd0IsNEJBQTRCLFNBQVMsa0NBQWtDLFlBQVksNEJBQTRCLGtEQUFrRCxTQUFTLHlCQUF5QixzQ0FBc0MsS0FBSyxLQUFLLGlDQUFpQyxxRUFBcUUsU0FBUyx1QkFBdUIsYUFBYSxNQUFNLGNBQWMsZ0NBQWdDLHdCQUF3Qiw2Q0FBNkMsNEJBQTRCLGtGQUFrRiw4REFBOEQscURBQXFELDBEQUEwRCw0QkFBNEIsNkJBQTZCLHNCQUFzQixlQUFlLHFDQUFxQyxtRkFBbUYsdUVBQXVFLHNCQUFzQiwyREFBMkQsV0FBVyxnSUFBZ0ksZ0NBQWdDLHlEQUF5RCxnRUFBZ0UsYUFBYSxzQ0FBc0MsS0FBSyxLQUFLLDhDQUE4QyxZQUFZLFdBQVcsNkNBQTZDLDBEQUEwRCxxQkFBcUIsMkdBQTJHLG1CQUFtQiw4QkFBOEIsa0NBQWtDLG9GQUFvRixxQ0FBcUMsK0tBQStLLGtDQUFrQyx1QkFBdUIsV0FBVyxLQUFLLDhLQUE4SywwQ0FBMEMsb0NBQW9DLDZIQUE2SCxxQ0FBcUMscUxBQXFMLDJFQUEyRSxLQUFLLDhCQUE4QixFQUFFLGdDQUFnQyxnQkFBZ0Isc0RBQXNELDhCQUE4QixhQUFhLDBFQUEwRSxZQUFZLGNBQWMsNEtBQTRLLG9CQUFvQiwrREFBK0QsUUFBUSxjQUFjLHNCQUFzQiwwQkFBMEIscUVBQXFFLFFBQVEsb0NBQW9DLE9BQU8sdUJBQXVCLGdEQUFnRCxrR0FBa0csRUFBRSxrQkFBa0IsY0FBYyxNQUFNLHFYQUFxWCxrQkFBa0IsZ0hBQWdILHVDQUF1QyxtQkFBbUIsd0JBQXdCLG9CQUFvQiwrRUFBK0UsdUJBQXVCLHNHQUFzRyxrQkFBa0IsZ0lBQWdJLGtKQUFrSix3S0FBd0ssZUFBZSxxR0FBcUcsbUpBQW1KLHFCQUFxQixTQUFTLDhDQUE4QywyRkFBMkYsU0FBUyxrQkFBa0IsbUdBQW1HLGtCQUFrQixtR0FBbUcsb0JBQW9CLGdDQUFnQyxzQkFBc0Isa0NBQWtDLGVBQWUsMkJBQTJCLGlCQUFpQiw2QkFBNkIscUJBQXFCLGlDQUFpQyxzQkFBc0IsNkJBQTZCLFlBQVksbUJBQW1CLGtCQUFrQixnQkFBZ0IsVUFBVSxTQUFTLG9OQUFvTixzREFBc0QsMENBQTBDLGtEQUFrRCx3QkFBd0IsaUNBQWlDLGlDQUFpQyx3Q0FBd0Msd0NBQXdDLDRDQUE0QyxhQUFhLDJLQUEySyxjQUFjLDhDQUE4QywwQkFBMEIsaUJBQWlCLG1GQUFtRix1QkFBdUIsZUFBZSwrREFBK0QsdUNBQXVDLDZGQUE2RixtREFBbUQsV0FBVyw4Q0FBOEMsa0JBQWtCLDhCQUE4Qiw0QkFBNEIsaUNBQWlDLGlCQUFpQixzRkFBc0Ysc0JBQXNCLG1EQUFtRCxVQUFVLDhEQUE4RCxrSUFBa0ksb0pBQW9KLFlBQVksVUFBVSxTQUFTLEdBQUcsSUFBSSw0QkFBNEIsU0FBUyw2QkFBNkIsbURBQW1ELE1BQU0sV0FBVyw0REFBNEQsd0JBQXdCLDJoQ0FBMmhDLHFCQUFxQiwwU0FBMFMsNENBQTRDLHdHQUF3RyxvRUFBb0Usb01BQW9NLHNGQUFzRiw4REFBOEQsNklBQTZJLDhEQUE4RCwyQ0FBMkMsaUNBQWlDLGlDQUFpQyxxREFBcUQsbUVBQW1FLGdEQUFnRCx3REFBd0QsbUJBQW1CLFdBQVcsS0FBSyxrQkFBa0Isb0VBQW9FLG9DQUFvQyxvQkFBb0Isd0NBQXdDLFlBQVksS0FBSyxpQkFBaUIsMkJBQTJCLG9CQUFvQixpQkFBaUIsa0RBQWtELHlCQUF5QixvREFBb0QsNkJBQTZCLGlCQUFpQiw2QkFBNkIsOEJBQThCLHFpQkFBcWlCLGdCQUFnQiw0RkFBNEYsdUJBQXVCLGlRQUFpUSxrQkFBa0IscUZBQXFGLG1DQUFtQyxpTUFBaU0sa0JBQWtCLDZFQUE2RSx5QkFBeUIsMEZBQTBGLE9BQU8sNENBQTRDLG1CQUFtQix1QkFBdUIsS0FBSyxtREFBbUQsbUNBQW1DLG1HQUFtRyx1REFBdUQsMkNBQTJDLFVBQVUsYUFBYSxNQUFNLDRCQUE0QixtREFBbUQsNkJBQTZCLGFBQWEsMEJBQTBCLG1FQUFtRSwwQkFBMEIscUdBQXFHLG1CQUFtQixhQUFhLCtFQUErRSxvQkFBb0IsOEtBQThLLG9DQUFvQywyRUFBMkUsZ0NBQWdDLDRDQUE0Qyx5Q0FBeUMsS0FBSyxFQUFFLDhDQUE4QyxrQkFBa0Isa0JBQWtCLG9CQUFvQixLQUFLLDhEQUE4RCxFQUFFLDBDQUEwQyw4Q0FBOEMsaUJBQWlCLFNBQVMsbUJBQW1CLHNDQUFzQyx5QkFBeUIsY0FBYywyQkFBMkIsaURBQWlELHNCQUFzQixpREFBaUQsZUFBZSw0REFBNEQsa0JBQWtCLFlBQVksaU5BQWlOLFlBQVksbUJBQW1CLFFBQVEsbUJBQW1CLFFBQVEsOExBQThMLGtCQUFrQixTQUFTLDhCQUE4QixvQkFBb0IsbUJBQW1CLFFBQVEsb0JBQW9CLHNDQUFzQyw4QkFBOEIsd0JBQXdCLDhFQUE4RSx3R0FBd0csMkJBQTJCLDJIQUEySCxvR0FBb0csYUFBYSw0REFBNEQsS0FBSyx1RkFBdUYsa0RBQWtELHVVQUF1VSxtQkFBbUIsUUFBUSxzQkFBc0IsMEpBQTBKLE1BQU0sd0pBQXdKLE1BQU0sc0VBQXNFLHNDQUFzQyxzQkFBc0IsMEJBQTBCLGtDQUFrQyxNQUFNLDhCQUE4Qiw4RkFBOEYsTUFBTSxxRUFBcUUsTUFBTSxzSUFBc0ksZ0JBQWdCLHNDQUFzQywrRkFBK0Ysd0RBQXdELHVLQUF1SyxLQUFLLGNBQWMsMkdBQTJHLHNEQUFzRCxrRUFBa0UsNkNBQTZDLGNBQWMsTUFBTSxvTkFBb04sTUFBTSwwQ0FBMEMsMkNBQTJDLEtBQUssS0FBSyxpQ0FBaUMsSUFBSSxhQUFhLHFEQUFxRCwwQkFBMEIsZ0RBQWdELFlBQVksc0NBQXNDLHlGQUF5RixNQUFNLHdFQUF3RSx5Q0FBeUMsTUFBTSw4RkFBOEYsTUFBTSxpR0FBaUcsc0JBQXNCLFNBQVMsNE5BQTROLE1BQU0sa0VBQWtFLHVUQUF1VCxNQUFNLDJCQUEyQixrRkFBa0YsNEdBQTRHLDRHQUE0RywyQ0FBMkMsMkNBQTJDLHdCQUF3Qix5SEFBeUgscUZBQXFGLHFFQUFxRSxNQUFNLHlFQUF5RSx3RkFBd0YsMkNBQTJDLCtGQUErRixNQUFNLDZHQUE2Ryx5Q0FBeUMsTUFBTSw4RUFBOEUseUNBQXlDLE1BQU0scUNBQXFDLHdKQUF3SixNQUFNLDZDQUE2QyxNQUFNLGlIQUFpSCxtR0FBbUcsV0FBVyxnRUFBZ0UsOERBQThELGlFQUFpRSwyQ0FBMkMsbURBQW1ELHNDQUFzQyxxREFBcUQsTUFBTSxzSkFBc0osaUdBQWlHLCtDQUErQyw0REFBNEQseUNBQXlDLE1BQU0sK0JBQStCLHNDQUFzQyx5REFBeUQscUJBQXFCLDRCQUE0QixzQkFBc0IsS0FBSyxpR0FBaUcsWUFBWSxPQUFPLGFBQWEsd0JBQXdCLDBDQUEwQyxpRUFBaUUsZ0ZBQWdGLHlDQUF5QyxNQUFNLG1EQUFtRCxTQUFTLG1CQUFtQiwwQ0FBMEMsZ0RBQWdELG1CQUFtQixlQUFlLHlCQUF5QixpRUFBaUUsV0FBVyxxVkFBcVYsNENBQTRDLG1CQUFtQiwwRUFBMEUsNENBQTRDLFNBQVMsOEJBQThCLGlGQUFpRiw4REFBOEQsd0VBQXdFLGdQQUFnUCx1RUFBdUUsaUJBQWlCLGtMQUFrTCxtQkFBbUIsdUVBQXVFLHFCQUFxQixJQUFJLDBCQUEwQixvREFBb0QsV0FBVywwTkFBME4sZUFBZSxJQUFJLDJDQUEyQyxTQUFTLFVBQVUsOEJBQThCLHlGQUF5Riw0RUFBNEUsb0NBQW9DLDhEQUE4RCxTQUFTLGtIQUFrSCxZQUFZLEtBQUssaUJBQWlCLDJCQUEyQixtQkFBbUIsMkJBQTJCLHNEQUFzRCxVQUFVLG9CQUFvQixHQUFHLHNCQUFzQiwyQ0FBMkMsZ0dBQWdHLHdDQUF3QywwTUFBME0sMEJBQTBCLGlDQUFpQyxvQ0FBb0Msa0JBQWtCLGlWQUFpVixrSEFBa0gsU0FBUyxZQUFZLElBQUksS0FBSyx1REFBdUQsVUFBVSxZQUFZLGtCQUFrQiw0SkFBNEosaUNBQWlDLHlKQUF5SixhQUFhLFNBQVMsMEJBQTBCLHlGQUF5RixvRkFBb0YsU0FBUyx1QkFBdUIsSUFBSSw4QkFBOEIsdUJBQXVCLEVBQUUsMEJBQTBCLHlKQUF5SiwyQkFBMkIsMENBQTBDLG1QQUFtUCxLQUFLLHFEQUFxRCwyTEFBMkwsaUJBQWlCLHdCQUF3QixRQUFRLDREQUE0RCxxRUFBcUUsaUJBQWlCLGFBQWEsb0JBQW9CLHlCQUF5Qiw2QkFBNkIsbUVBQW1FLHdEQUF3RCxnQkFBZ0IscUJBQXFCLHlRQUF5USx5R0FBeUcsc0JBQXNCLHVCQUF1QixJQUFJLG9DQUFvQyw0QkFBNEIsa0dBQWtHLG1DQUFtQyxxQ0FBcUMscUVBQXFFLGtCQUFrQixxQ0FBcUMsZ0JBQWdCLHFDQUFxQywyQkFBMkIsaUNBQWlDLHlDQUF5QyxxQ0FBcUMsZUFBZSx3R0FBd0csYUFBYSxtQ0FBbUMsaUJBQWlCLHlEQUF5RCx3QkFBd0Isd0RBQXdELDRDQUE0QyxpREFBaUQsc0NBQXNDLE1BQU0sRUFBRSxtQkFBbUIsMkJBQTJCLElBQUksV0FBVyx3QkFBd0IsYUFBYSxZQUFZLCtCQUErQixTQUFTLHlCQUF5QixZQUFZLDhHQUE4RywwQkFBMEIsWUFBWSxzRkFBc0YsY0FBYyxxUkFBcVIsb0NBQW9DLFNBQVMsK1VBQStVLDBCQUEwQixxRUFBcUUsOERBQThELEtBQUssb0NBQW9DLEVBQUUsS0FBSyw4QkFBOEIsNEJBQTRCLHFDQUFxQyxlQUFlLGdGQUFnRixtRkFBbUYsa0NBQWtDLHFFQUFxRSwyQ0FBMkMsV0FBVywyTUFBMk0sMkJBQTJCLDJDQUEyQyxzR0FBc0csMENBQTBDLHFDQUFxQyxzREFBc0QsMkRBQTJELGlDQUFpQyx3Q0FBd0MsdUJBQXVCLElBQUksMEJBQTBCLDJEQUEyRCxZQUFZLElBQUksY0FBYyxZQUFZLEtBQUssS0FBSywrQkFBK0IsK0JBQStCLDJDQUEyQyxjQUFjLGVBQWUsNkJBQTZCLFdBQVcsb0JBQW9CLHNCQUFzQixzREFBc0QsWUFBWSwwQ0FBMEMsbURBQW1ELGlIQUFpSCxrREFBa0QsaUJBQWlCLHFGQUFxRiwyQkFBMkIsa0NBQWtDLGtGQUFrRixpREFBaUQsS0FBSyx3SUFBd0ksMkNBQTJDLEtBQUssS0FBSyxnRUFBZ0UsWUFBWSwyQkFBMkIseUdBQXlHLG1DQUFtQyxNQUFNLGFBQWEsdUhBQXVILCtDQUErQyxHQUFHLFNBQVMsK0RBQStELFNBQVMsRUFBRTtBQUNoeDlHOzs7Ozs7Ozs7Ozs7O0FDRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsNkVBQXFCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx1QkFBdUIsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNuRCwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBbUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFFBQVE7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyw4RUFBOEU7QUFDbkYsQ0FBQyw4Q0FBOEM7QUFDL0MsaUM7Ozs7Ozs7Ozs7OztBQ3hsRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7Ozs7Ozs7QUNaYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNkRBQWE7QUFDekMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxpREFBTztBQUM3QixlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pELDRCQUE0QixtQkFBTyxDQUFDLDZFQUFxQjtBQUN6RCxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLHVCQUF1QixtQkFBTyxDQUFDLG1FQUFnQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLCtEQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLCtEQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7Ozs7Ozs7Ozs7OztBQzcwQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEO0FBQzNELGlDOzs7Ozs7Ozs7Ozs7QUMvVWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7Ozs7Ozs7QUNoQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsNkVBQXFCO0FBQ3pELHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LHNCQUFzQiw4Q0FBOEM7QUFDL0UsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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YSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFD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QUFZLE1BQU0sRUFBQztnQkFDbkIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQzthQUNsQztpQkFBSTtnQkFDRCxPQUFPLENBQUMsR0FBRyxDQUFDLHNCQUFzQixDQUFDO2FBQ3RDO1FBRUwsQ0FBQyxFQUFDLElBQUksQ0FBQztJQUVYLENBQUM7O0FBbFVhLGdCQUFPLEdBQVUsS0FBSyxDQUFDO0FBdVV6QyxNQUFNLE1BQU8sU0FBUSw2Q0FBSztJQUVmLElBQUk7UUFDUCxPQUFPLENBQUMsR0FBRyxDQUFDLHFCQUFxQixDQUFDO0lBQ3RDLENBQUM7Q0FDSjtBQUlNLE1BQU0sS0FBSztDQUdqQjs7Ozs7Ozs7Ozs7O0FDcldELG1DOzs7Ozs7Ozs7OztBQ0FBLG1DIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL0dhbWVNYWluLnRzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIiFmdW5jdGlvbih0LGUpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLGUpOmUoKHQ9dHx8c2VsZikuaW5ranM9e30pfSh0aGlzLChmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtjbGFzcyBle2NvbnN0cnVjdG9yKCl7aWYodGhpcy5fY29tcG9uZW50cz1bXSx0aGlzLl9jb21wb25lbnRzU3RyaW5nPW51bGwsdGhpcy5faXNSZWxhdGl2ZT0hMSxcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtsZXQgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wb25lbnRzU3RyaW5nPXR9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGUuQ29tcG9uZW50JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGUpe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLl9jb21wb25lbnRzLnB1c2godCksdGhpcy5fY29tcG9uZW50cz10aGlzLl9jb21wb25lbnRzLmNvbmNhdChlLl9jb21wb25lbnRzKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2xldCB0PWFyZ3VtZW50c1swXSxlPSEhYXJndW1lbnRzWzFdO3RoaXMuX2NvbXBvbmVudHM9dGhpcy5fY29tcG9uZW50cy5jb25jYXQodCksdGhpcy5faXNSZWxhdGl2ZT1lfX1nZXQgaXNSZWxhdGl2ZSgpe3JldHVybiB0aGlzLl9pc1JlbGF0aXZlfWdldCBjb21wb25lbnRDb3VudCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aH1nZXQgaGVhZCgpe3JldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aD4wP3RoaXMuX2NvbXBvbmVudHNbMF06bnVsbH1nZXQgdGFpbCgpe2lmKHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoPj0yKXtsZXQgdD10aGlzLl9jb21wb25lbnRzLnNsaWNlKDEsdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpO3JldHVybiBuZXcgZSh0KX1yZXR1cm4gZS5zZWxmfWdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGh9Z2V0IGxhc3RDb21wb25lbnQoKXtsZXQgdD10aGlzLl9jb21wb25lbnRzLmxlbmd0aC0xO3JldHVybiB0Pj0wP3RoaXMuX2NvbXBvbmVudHNbdF06bnVsbH1nZXQgY29udGFpbnNOYW1lZENvbXBvbmVudCgpe2ZvcihsZXQgdD0wLGU9dGhpcy5fY29tcG9uZW50cy5sZW5ndGg7dDxlO3QrKylpZighdGhpcy5fY29tcG9uZW50c1t0XS5pc0luZGV4KXJldHVybiEwO3JldHVybiExfXN0YXRpYyBnZXQgc2VsZigpe2xldCB0PW5ldyBlO3JldHVybiB0Ll9pc1JlbGF0aXZlPSEwLHR9R2V0Q29tcG9uZW50KHQpe3JldHVybiB0aGlzLl9jb21wb25lbnRzW3RdfVBhdGhCeUFwcGVuZGluZ1BhdGgodCl7bGV0IG49bmV3IGUsaT0wO2ZvcihsZXQgZT0wO2U8dC5fY29tcG9uZW50cy5sZW5ndGgmJnQuX2NvbXBvbmVudHNbZV0uaXNQYXJlbnQ7KytlKWkrKztmb3IobGV0IHQ9MDt0PHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoLWk7Kyt0KW4uX2NvbXBvbmVudHMucHVzaCh0aGlzLl9jb21wb25lbnRzW3RdKTtmb3IobGV0IGU9aTtlPHQuX2NvbXBvbmVudHMubGVuZ3RoOysrZSluLl9jb21wb25lbnRzLnB1c2godC5fY29tcG9uZW50c1tlXSk7cmV0dXJuIG59Z2V0IGNvbXBvbmVudHNTdHJpbmcoKXtyZXR1cm4gbnVsbD09dGhpcy5fY29tcG9uZW50c1N0cmluZyYmKHRoaXMuX2NvbXBvbmVudHNTdHJpbmc9dGhpcy5fY29tcG9uZW50cy5qb2luKFwiLlwiKSx0aGlzLmlzUmVsYXRpdmUmJih0aGlzLl9jb21wb25lbnRzU3RyaW5nPVwiLlwiK3RoaXMuX2NvbXBvbmVudHNTdHJpbmcpKSx0aGlzLl9jb21wb25lbnRzU3RyaW5nfXNldCBjb21wb25lbnRzU3RyaW5nKHQpe2lmKHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoPTAsdGhpcy5fY29tcG9uZW50c1N0cmluZz10LG51bGw9PXRoaXMuX2NvbXBvbmVudHNTdHJpbmd8fFwiXCI9PXRoaXMuX2NvbXBvbmVudHNTdHJpbmcpcmV0dXJuO1wiLlwiPT10aGlzLl9jb21wb25lbnRzU3RyaW5nWzBdJiYodGhpcy5faXNSZWxhdGl2ZT0hMCx0aGlzLl9jb21wb25lbnRzU3RyaW5nPXRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3Vic3RyaW5nKDEpKTtsZXQgbj10aGlzLl9jb21wb25lbnRzU3RyaW5nLnNwbGl0KFwiLlwiKTtmb3IobGV0IHQgb2YgbikvXihcXC18XFwrKT8oWzAtOV0rfEluZmluaXR5KSQvLnRlc3QodCk/dGhpcy5fY29tcG9uZW50cy5wdXNoKG5ldyBlLkNvbXBvbmVudChwYXJzZUludCh0KSkpOnRoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgZS5Db21wb25lbnQodCkpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29tcG9uZW50c1N0cmluZ31FcXVhbHModCl7aWYobnVsbD09dClyZXR1cm4hMTtpZih0Ll9jb21wb25lbnRzLmxlbmd0aCE9dGhpcy5fY29tcG9uZW50cy5sZW5ndGgpcmV0dXJuITE7aWYodC5pc1JlbGF0aXZlIT10aGlzLmlzUmVsYXRpdmUpcmV0dXJuITE7Zm9yKGxldCBlPTAsbj10Ll9jb21wb25lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKCF0Ll9jb21wb25lbnRzW2VdLkVxdWFscyh0aGlzLl9jb21wb25lbnRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH1QYXRoQnlBcHBlbmRpbmdDb21wb25lbnQodCl7bGV0IG49bmV3IGU7cmV0dXJuIG4uX2NvbXBvbmVudHMucHVzaC5hcHBseShuLl9jb21wb25lbnRzLHRoaXMuX2NvbXBvbmVudHMpLG4uX2NvbXBvbmVudHMucHVzaCh0KSxufX12YXIgbixpLHI7ZnVuY3Rpb24gYSh0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgZT9oKHQpOm51bGx9ZnVuY3Rpb24gcyh0LGUpe2lmKHQgaW5zdGFuY2VvZiBlKXJldHVybiBoKHQpO3Rocm93IG5ldyBFcnJvcihgJHt0fSBpcyBub3Qgb2YgdHlwZSAke2V9YCl9ZnVuY3Rpb24gbCh0KXtyZXR1cm4gdC5oYXNWYWxpZE5hbWUmJnQubmFtZT90Om51bGx9ZnVuY3Rpb24gbyh0KXtyZXR1cm4gdm9pZCAwPT09dD9udWxsOnR9ZnVuY3Rpb24gdSh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC5FcXVhbHN9ZnVuY3Rpb24gaCh0LGUpe3JldHVybiB0fWUucGFyZW50SWQ9XCJeXCIsZnVuY3Rpb24odCl7Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmluZGV4PS0xLHRoaXMubmFtZT1udWxsLFwic3RyaW5nXCI9PXR5cGVvZiB0P3RoaXMubmFtZT10OnRoaXMuaW5kZXg9dH1nZXQgaXNJbmRleCgpe3JldHVybiB0aGlzLmluZGV4Pj0wfWdldCBpc1BhcmVudCgpe3JldHVybiB0aGlzLm5hbWU9PXQucGFyZW50SWR9c3RhdGljIFRvUGFyZW50KCl7cmV0dXJuIG5ldyBlKHQucGFyZW50SWQpfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuaXNJbmRleD90aGlzLmluZGV4LnRvU3RyaW5nKCk6dGhpcy5uYW1lfUVxdWFscyh0KXtyZXR1cm4gbnVsbCE9dCYmdC5pc0luZGV4PT10aGlzLmlzSW5kZXgmJih0aGlzLmlzSW5kZXg/dGhpcy5pbmRleD09dC5pbmRleDp0aGlzLm5hbWU9PXQubmFtZSl9fXQuQ29tcG9uZW50PWV9KGV8fChlPXt9KSksZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0LGUpe2lmKCF0KXRocm93IHZvaWQgMCE9PWUmJmNvbnNvbGUud2FybihlKSxjb25zb2xlLnRyYWNlJiZjb25zb2xlLnRyYWNlKCksbmV3IEVycm9yKFwiXCIpfXQuQXNzZXJ0VHlwZT1mdW5jdGlvbih0LG4saSl7ZSh0IGluc3RhbmNlb2YgbixpKX0sdC5Bc3NlcnQ9ZX0obnx8KG49e30pKTtjbGFzcyBjIGV4dGVuZHMgRXJyb3J7fWZ1bmN0aW9uIGQodCl7dGhyb3cgbmV3IGModCtcIiBpcyBudWxsIG9yIHVuZGVmaW5lZFwiKX1jbGFzcyBwe2NvbnN0cnVjdG9yKCl7dGhpcy5wYXJlbnQ9bnVsbCx0aGlzLl9kZWJ1Z01ldGFkYXRhPW51bGwsdGhpcy5fcGF0aD1udWxsfWdldCBkZWJ1Z01ldGFkYXRhKCl7cmV0dXJuIG51bGw9PT10aGlzLl9kZWJ1Z01ldGFkYXRhJiZ0aGlzLnBhcmVudD90aGlzLnBhcmVudC5kZWJ1Z01ldGFkYXRhOnRoaXMuX2RlYnVnTWV0YWRhdGF9c2V0IGRlYnVnTWV0YWRhdGEodCl7dGhpcy5fZGVidWdNZXRhZGF0YT10fWdldCBvd25EZWJ1Z01ldGFkYXRhKCl7cmV0dXJuIHRoaXMuX2RlYnVnTWV0YWRhdGF9RGVidWdMaW5lTnVtYmVyT2ZQYXRoKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2xldCBlPXRoaXMucm9vdENvbnRlbnRDb250YWluZXI7aWYoZSl7bGV0IG49ZS5Db250ZW50QXRQYXRoKHQpLm9iajtpZihuKXtsZXQgdD1uLmRlYnVnTWV0YWRhdGE7aWYobnVsbCE9PXQpcmV0dXJuIHQuc3RhcnRMaW5lTnVtYmVyfX1yZXR1cm4gbnVsbH1nZXQgcGF0aCgpe2lmKG51bGw9PXRoaXMuX3BhdGgpaWYobnVsbD09dGhpcy5wYXJlbnQpdGhpcy5fcGF0aD1uZXcgZTtlbHNle2xldCB0PVtdLG49dGhpcyxpPWEobi5wYXJlbnQsTik7Zm9yKDtudWxsIT09aTspe2xldCByPWwobik7bnVsbCE9ciYmci5oYXNWYWxpZE5hbWU/dC51bnNoaWZ0KG5ldyBlLkNvbXBvbmVudChyLm5hbWUpKTp0LnVuc2hpZnQobmV3IGUuQ29tcG9uZW50KGkuY29udGVudC5pbmRleE9mKG4pKSksbj1pLGk9YShpLnBhcmVudCxOKX10aGlzLl9wYXRoPW5ldyBlKHQpfXJldHVybiB0aGlzLl9wYXRofVJlc29sdmVQYXRoKHQpe2lmKG51bGw9PT10KXJldHVybiBkKFwicGF0aFwiKTtpZih0LmlzUmVsYXRpdmUpe2xldCBlPWEodGhpcyxOKTtyZXR1cm4gbnVsbD09PWUmJihuLkFzc2VydChudWxsIT09dGhpcy5wYXJlbnQsXCJDYW4ndCByZXNvbHZlIHJlbGF0aXZlIHBhdGggYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgcGFyZW50XCIpLGU9YSh0aGlzLnBhcmVudCxOKSxuLkFzc2VydChudWxsIT09ZSxcIkV4cGVjdGVkIHBhcmVudCB0byBiZSBhIGNvbnRhaW5lclwiKSxuLkFzc2VydCh0LkdldENvbXBvbmVudCgwKS5pc1BhcmVudCksdD10LnRhaWwpLG51bGw9PT1lP2QoXCJuZWFyZXN0Q29udGFpbmVyXCIpOmUuQ29udGVudEF0UGF0aCh0KX17bGV0IGU9dGhpcy5yb290Q29udGVudENvbnRhaW5lcjtyZXR1cm4gbnVsbD09PWU/ZChcImNvbnRlbnRDb250YWluZXJcIik6ZS5Db250ZW50QXRQYXRoKHQpfX1Db252ZXJ0UGF0aFRvUmVsYXRpdmUodCl7bGV0IG49dGhpcy5wYXRoLGk9TWF0aC5taW4odC5sZW5ndGgsbi5sZW5ndGgpLHI9LTE7Zm9yKGxldCBlPTA7ZTxpOysrZSl7bGV0IGk9bi5HZXRDb21wb25lbnQoZSksYT10LkdldENvbXBvbmVudChlKTtpZighaS5FcXVhbHMoYSkpYnJlYWs7cj1lfWlmKC0xPT1yKXJldHVybiB0O2xldCBhPW4uY29tcG9uZW50Q291bnQtMS1yLHM9W107Zm9yKGxldCB0PTA7dDxhOysrdClzLnB1c2goZS5Db21wb25lbnQuVG9QYXJlbnQoKSk7Zm9yKGxldCBlPXIrMTtlPHQuY29tcG9uZW50Q291bnQ7KytlKXMucHVzaCh0LkdldENvbXBvbmVudChlKSk7cmV0dXJuIG5ldyBlKHMsITApfUNvbXBhY3RQYXRoU3RyaW5nKHQpe2xldCBlPW51bGwsbj1udWxsO2lmKHQuaXNSZWxhdGl2ZSluPXQuY29tcG9uZW50c1N0cmluZyxlPXRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKHQpLmNvbXBvbmVudHNTdHJpbmc7ZWxzZXtuPXRoaXMuQ29udmVydFBhdGhUb1JlbGF0aXZlKHQpLmNvbXBvbmVudHNTdHJpbmcsZT10LmNvbXBvbmVudHNTdHJpbmd9cmV0dXJuIG4ubGVuZ3RoPGUubGVuZ3RoP246ZX1nZXQgcm9vdENvbnRlbnRDb250YWluZXIoKXtsZXQgdD10aGlzO2Zvcig7dC5wYXJlbnQ7KXQ9dC5wYXJlbnQ7cmV0dXJuIGEodCxOKX1Db3B5KCl7dGhyb3cgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWQ6IERvZXNuJ3Qgc3VwcG9ydCBjb3B5aW5nXCIpfVNldENoaWxkKHQsZSxuKXt0W2VdJiYodFtlXT1udWxsKSx0W2VdPW4sdFtlXSYmKHRbZV0ucGFyZW50PXRoaXMpfX1jbGFzcyBte2NvbnN0cnVjdG9yKHQpe3Q9dm9pZCAwIT09dD90LnRvU3RyaW5nKCk6XCJcIix0aGlzLnN0cmluZz10fWdldCBMZW5ndGgoKXtyZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RofUFwcGVuZCh0KXtudWxsIT09dCYmKHRoaXMuc3RyaW5nKz10KX1BcHBlbmRMaW5lKHQpe3ZvaWQgMCE9PXQmJnRoaXMuQXBwZW5kKHQpLHRoaXMuc3RyaW5nKz1cIlxcblwifUFwcGVuZEZvcm1hdCh0LC4uLmUpe3RoaXMuc3RyaW5nKz10LnJlcGxhY2UoL3soXFxkKyl9L2csKHQsbik9PnZvaWQgMCE9PWVbbl0/ZVtuXTp0KX10b1N0cmluZygpe3JldHVybiB0aGlzLnN0cmluZ319Y2xhc3MgZntjb25zdHJ1Y3Rvcigpe2lmKHRoaXMub3JpZ2luTmFtZT1udWxsLHRoaXMuaXRlbU5hbWU9bnVsbCx2b2lkIDAhPT1hcmd1bWVudHNbMV0pe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm9yaWdpbk5hbWU9dCx0aGlzLml0ZW1OYW1lPWV9ZWxzZSBpZihhcmd1bWVudHNbMF0pe2xldCB0PWFyZ3VtZW50c1swXS50b1N0cmluZygpLnNwbGl0KFwiLlwiKTt0aGlzLm9yaWdpbk5hbWU9dFswXSx0aGlzLml0ZW1OYW1lPXRbMV19fXN0YXRpYyBnZXQgTnVsbCgpe3JldHVybiBuZXcgZihudWxsLG51bGwpfWdldCBpc051bGwoKXtyZXR1cm4gbnVsbD09dGhpcy5vcmlnaW5OYW1lJiZudWxsPT10aGlzLml0ZW1OYW1lfWdldCBmdWxsTmFtZSgpe3JldHVybihudWxsIT09dGhpcy5vcmlnaW5OYW1lP3RoaXMub3JpZ2luTmFtZTpcIj9cIikrXCIuXCIrdGhpcy5pdGVtTmFtZX10b1N0cmluZygpe3JldHVybiB0aGlzLmZ1bGxOYW1lfUVxdWFscyh0KXtpZih0IGluc3RhbmNlb2YgZil7bGV0IGU9dDtyZXR1cm4gZS5pdGVtTmFtZT09dGhpcy5pdGVtTmFtZSYmZS5vcmlnaW5OYW1lPT10aGlzLm9yaWdpbk5hbWV9cmV0dXJuITF9Y29weSgpe3JldHVybiBuZXcgZih0aGlzLm9yaWdpbk5hbWUsdGhpcy5pdGVtTmFtZSl9c2VyaWFsaXplZCgpe3JldHVybiBKU09OLnN0cmluZ2lmeSh7b3JpZ2luTmFtZTp0aGlzLm9yaWdpbk5hbWUsaXRlbU5hbWU6dGhpcy5pdGVtTmFtZX0pfXN0YXRpYyBmcm9tU2VyaWFsaXplZEtleSh0KXtsZXQgZT1KU09OLnBhcnNlKHQpO2lmKCFmLmlzTGlrZUlua0xpc3RJdGVtKGUpKXJldHVybiBmLk51bGw7bGV0IG49ZTtyZXR1cm4gbmV3IGYobi5vcmlnaW5OYW1lLG4uaXRlbU5hbWUpfXN0YXRpYyBpc0xpa2VJbmtMaXN0SXRlbSh0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmKCEoIXQuaGFzT3duUHJvcGVydHkoXCJvcmlnaW5OYW1lXCIpfHwhdC5oYXNPd25Qcm9wZXJ0eShcIml0ZW1OYW1lXCIpKSYmKChcInN0cmluZ1wiPT10eXBlb2YgdC5vcmlnaW5OYW1lfHxudWxsPT09dHlwZW9mIHQub3JpZ2luTmFtZSkmJihcInN0cmluZ1wiPT10eXBlb2YgdC5pdGVtTmFtZXx8bnVsbD09PXR5cGVvZiB0Lml0ZW1OYW1lKSkpfX1jbGFzcyBnIGV4dGVuZHMgTWFwe2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnP2FyZ3VtZW50c1swXTpbXSksdGhpcy5vcmlnaW5zPW51bGwsdGhpcy5fb3JpZ2luTmFtZXM9W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXtsZXQgdD1hcmd1bWVudHNbMF07dC5fb3JpZ2luTmFtZXMmJih0aGlzLl9vcmlnaW5OYW1lcz10Ll9vcmlnaW5OYW1lcy5zbGljZSgpKX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2xldCB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLlNldEluaXRpYWxPcmlnaW5OYW1lKHQpO2xldCBuPWUubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKHQsbnVsbCk7aWYoIW4uZXhpc3RzKXRocm93IG5ldyBFcnJvcihcIklua0xpc3Qgb3JpZ2luIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiBzdG9yeSB3aGVuIGNvbnN0cnVjdGluZyBuZXcgbGlzdDogXCIrdCk7dGhpcy5vcmlnaW5zPVtuLnJlc3VsdF19ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoXCJLZXlcIikmJmFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShcIlZhbHVlXCIpKXtsZXQgdD1hcmd1bWVudHNbMF07dGhpcy5BZGQodC5LZXksdC5WYWx1ZSl9fUFkZEl0ZW0odCl7aWYodCBpbnN0YW5jZW9mIGYpe2xldCBlPXQ7aWYobnVsbD09ZS5vcmlnaW5OYW1lKXJldHVybiB2b2lkIHRoaXMuQWRkSXRlbShlLml0ZW1OYW1lKTtpZihudWxsPT09dGhpcy5vcmlnaW5zKXJldHVybiBkKFwidGhpcy5vcmlnaW5zXCIpO2ZvcihsZXQgdCBvZiB0aGlzLm9yaWdpbnMpaWYodC5uYW1lPT1lLm9yaWdpbk5hbWUpe2xldCBuPXQuVHJ5R2V0VmFsdWVGb3JJdGVtKGUsMCk7aWYobi5leGlzdHMpcmV0dXJuIHZvaWQgdGhpcy5BZGQoZSxuLnJlc3VsdCk7dGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIitlK1wiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIGxpc3QgZGVmaW5pdGlvbiBpbiBpbmsuXCIpfXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhZGQgaXRlbSB0byBsaXN0IGJlY2F1c2UgdGhlIGl0ZW0gd2FzIGZyb20gYSBuZXcgbGlzdCBkZWZpbml0aW9uIHRoYXQgd2Fzbid0IHByZXZpb3VzbHkga25vd24gdG8gdGhpcyBsaXN0LiBPbmx5IGl0ZW1zIGZyb20gcHJldmlvdXNseSBrbm93biBsaXN0cyBjYW4gYmUgdXNlZCwgc28gdGhhdCB0aGUgaW50IHZhbHVlIGNhbiBiZSBmb3VuZC5cIil9e2xldCBlPXQsbj1udWxsO2lmKG51bGw9PT10aGlzLm9yaWdpbnMpcmV0dXJuIGQoXCJ0aGlzLm9yaWdpbnNcIik7Zm9yKGxldCB0IG9mIHRoaXMub3JpZ2lucyl7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJpdGVtTmFtZVwiKTtpZih0LkNvbnRhaW5zSXRlbVdpdGhOYW1lKGUpKXtpZihudWxsIT1uKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIrZStcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBjb3VsZCBjb21lIGZyb20gZWl0aGVyIFwiK3QubmFtZStcIiBvciBcIituLm5hbWUpO249dH19aWYobnVsbD09bil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiK2UrXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgaXNuJ3Qga25vd24gdG8gYW55IGxpc3QgZGVmaW5pdGlvbnMgcHJldmlvdXNseSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsaXN0LlwiKTtsZXQgaT1uZXcgZihuLm5hbWUsZSkscj1uLlZhbHVlRm9ySXRlbShpKTt0aGlzLkFkZChpLHIpfX1Db250YWluc0l0ZW1OYW1lZCh0KXtmb3IobGV0W2Vdb2YgdGhpcyl7aWYoZi5mcm9tU2VyaWFsaXplZEtleShlKS5pdGVtTmFtZT09dClyZXR1cm4hMH1yZXR1cm4hMX1Db250YWluc0tleSh0KXtyZXR1cm4gdGhpcy5oYXModC5zZXJpYWxpemVkKCkpfUFkZCh0LGUpe2xldCBuPXQuc2VyaWFsaXplZCgpO2lmKHRoaXMuaGFzKG4pKXRocm93IG5ldyBFcnJvcihcIlRoZSBNYXAgYWxyZWFkeSBjb250YWlucyBhbiBlbnRyeSBmb3IgXCIrdCk7dGhpcy5zZXQobixlKX1SZW1vdmUodCl7cmV0dXJuIHRoaXMuZGVsZXRlKHQuc2VyaWFsaXplZCgpKX1nZXQgQ291bnQoKXtyZXR1cm4gdGhpcy5zaXplfWdldCBvcmlnaW5PZk1heEl0ZW0oKXtpZihudWxsPT10aGlzLm9yaWdpbnMpcmV0dXJuIG51bGw7bGV0IHQ9dGhpcy5tYXhJdGVtLktleS5vcmlnaW5OYW1lLGU9bnVsbDtyZXR1cm4gdGhpcy5vcmlnaW5zLmV2ZXJ5KG49Pm4ubmFtZSE9dHx8KGU9biwhMSkpLGV9Z2V0IG9yaWdpbk5hbWVzKCl7aWYodGhpcy5Db3VudD4wKXtudWxsPT10aGlzLl9vcmlnaW5OYW1lcyYmdGhpcy5Db3VudD4wP3RoaXMuX29yaWdpbk5hbWVzPVtdOih0aGlzLl9vcmlnaW5OYW1lc3x8KHRoaXMuX29yaWdpbk5hbWVzPVtdKSx0aGlzLl9vcmlnaW5OYW1lcy5sZW5ndGg9MCk7Zm9yKGxldFt0XW9mIHRoaXMpe2xldCBlPWYuZnJvbVNlcmlhbGl6ZWRLZXkodCk7aWYobnVsbD09PWUub3JpZ2luTmFtZSlyZXR1cm4gZChcIml0ZW0ub3JpZ2luTmFtZVwiKTt0aGlzLl9vcmlnaW5OYW1lcy5wdXNoKGUub3JpZ2luTmFtZSl9fXJldHVybiB0aGlzLl9vcmlnaW5OYW1lc31TZXRJbml0aWFsT3JpZ2luTmFtZSh0KXt0aGlzLl9vcmlnaW5OYW1lcz1bdF19U2V0SW5pdGlhbE9yaWdpbk5hbWVzKHQpe3RoaXMuX29yaWdpbk5hbWVzPW51bGw9PXQ/bnVsbDp0LnNsaWNlKCl9Z2V0IG1heEl0ZW0oKXtsZXQgdD17S2V5OmYuTnVsbCxWYWx1ZTowfTtmb3IobGV0W2Usbl1vZiB0aGlzKXtsZXQgaT1mLmZyb21TZXJpYWxpemVkS2V5KGUpOyh0LktleS5pc051bGx8fG4+dC5WYWx1ZSkmJih0PXtLZXk6aSxWYWx1ZTpufSl9cmV0dXJuIHR9Z2V0IG1pbkl0ZW0oKXtsZXQgdD17S2V5OmYuTnVsbCxWYWx1ZTowfTtmb3IobGV0W2Usbl1vZiB0aGlzKXtsZXQgaT1mLmZyb21TZXJpYWxpemVkS2V5KGUpOyh0LktleS5pc051bGx8fG48dC5WYWx1ZSkmJih0PXtLZXk6aSxWYWx1ZTpufSl9cmV0dXJuIHR9Z2V0IGludmVyc2UoKXtsZXQgdD1uZXcgZztpZihudWxsIT10aGlzLm9yaWdpbnMpZm9yKGxldCBlIG9mIHRoaXMub3JpZ2lucylmb3IobGV0W24saV1vZiBlLml0ZW1zKXtsZXQgZT1mLmZyb21TZXJpYWxpemVkS2V5KG4pO3RoaXMuQ29udGFpbnNLZXkoZSl8fHQuQWRkKGUsaSl9cmV0dXJuIHR9Z2V0IGFsbCgpe2xldCB0PW5ldyBnO2lmKG51bGwhPXRoaXMub3JpZ2lucylmb3IobGV0IGUgb2YgdGhpcy5vcmlnaW5zKWZvcihsZXRbbixpXW9mIGUuaXRlbXMpe2xldCBlPWYuZnJvbVNlcmlhbGl6ZWRLZXkobik7dC5zZXQoZS5zZXJpYWxpemVkKCksaSl9cmV0dXJuIHR9VW5pb24odCl7bGV0IGU9bmV3IGcodGhpcyk7Zm9yKGxldFtuLGldb2YgdCllLnNldChuLGkpO3JldHVybiBlfUludGVyc2VjdCh0KXtsZXQgZT1uZXcgZztmb3IobGV0W24saV1vZiB0aGlzKXQuaGFzKG4pJiZlLnNldChuLGkpO3JldHVybiBlfVdpdGhvdXQodCl7bGV0IGU9bmV3IGcodGhpcyk7Zm9yKGxldFtuXW9mIHQpZS5kZWxldGUobik7cmV0dXJuIGV9Q29udGFpbnModCl7Zm9yKGxldFtlXW9mIHQpaWYoIXRoaXMuaGFzKGUpKXJldHVybiExO3JldHVybiEwfUdyZWF0ZXJUaGFuKHQpe3JldHVybiAwIT10aGlzLkNvdW50JiYoMD09dC5Db3VudHx8dGhpcy5taW5JdGVtLlZhbHVlPnQubWF4SXRlbS5WYWx1ZSl9R3JlYXRlclRoYW5PckVxdWFscyh0KXtyZXR1cm4gMCE9dGhpcy5Db3VudCYmKDA9PXQuQ291bnR8fHRoaXMubWluSXRlbS5WYWx1ZT49dC5taW5JdGVtLlZhbHVlJiZ0aGlzLm1heEl0ZW0uVmFsdWU+PXQubWF4SXRlbS5WYWx1ZSl9TGVzc1RoYW4odCl7cmV0dXJuIDAhPXQuQ291bnQmJigwPT10aGlzLkNvdW50fHx0aGlzLm1heEl0ZW0uVmFsdWU8dC5taW5JdGVtLlZhbHVlKX1MZXNzVGhhbk9yRXF1YWxzKHQpe3JldHVybiAwIT10LkNvdW50JiYoMD09dGhpcy5Db3VudHx8dGhpcy5tYXhJdGVtLlZhbHVlPD10Lm1heEl0ZW0uVmFsdWUmJnRoaXMubWluSXRlbS5WYWx1ZTw9dC5taW5JdGVtLlZhbHVlKX1NYXhBc0xpc3QoKXtyZXR1cm4gdGhpcy5Db3VudD4wP25ldyBnKHRoaXMubWF4SXRlbSk6bmV3IGd9TWluQXNMaXN0KCl7cmV0dXJuIHRoaXMuQ291bnQ+MD9uZXcgZyh0aGlzLm1pbkl0ZW0pOm5ldyBnfUxpc3RXaXRoU3ViUmFuZ2UodCxlKXtpZigwPT10aGlzLkNvdW50KXJldHVybiBuZXcgZztsZXQgbj10aGlzLm9yZGVyZWRJdGVtcyxpPTAscj1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtOdW1iZXIuaXNJbnRlZ2VyKHQpP2k9dDp0IGluc3RhbmNlb2YgZyYmdC5Db3VudD4wJiYoaT10Lm1pbkl0ZW0uVmFsdWUpLE51bWJlci5pc0ludGVnZXIoZSk/cj1lOnQgaW5zdGFuY2VvZiBnJiZ0LkNvdW50PjAmJihyPWUubWF4SXRlbS5WYWx1ZSk7bGV0IGE9bmV3IGc7YS5TZXRJbml0aWFsT3JpZ2luTmFtZXModGhpcy5vcmlnaW5OYW1lcyk7Zm9yKGxldCB0IG9mIG4pdC5WYWx1ZT49aSYmdC5WYWx1ZTw9ciYmYS5BZGQodC5LZXksdC5WYWx1ZSk7cmV0dXJuIGF9RXF1YWxzKHQpe2lmKHQgaW5zdGFuY2VvZiBnPT0hMSlyZXR1cm4hMTtpZih0LkNvdW50IT10aGlzLkNvdW50KXJldHVybiExO2ZvcihsZXRbZV1vZiB0aGlzKWlmKCF0LmhhcyhlKSlyZXR1cm4hMTtyZXR1cm4hMH1nZXQgb3JkZXJlZEl0ZW1zKCl7bGV0IHQ9bmV3IEFycmF5O2ZvcihsZXRbZSxuXW9mIHRoaXMpe2xldCBpPWYuZnJvbVNlcmlhbGl6ZWRLZXkoZSk7dC5wdXNoKHtLZXk6aSxWYWx1ZTpufSl9cmV0dXJuIHQuc29ydCgodCxlKT0+bnVsbD09PXQuS2V5Lm9yaWdpbk5hbWU/ZChcInguS2V5Lm9yaWdpbk5hbWVcIik6bnVsbD09PWUuS2V5Lm9yaWdpbk5hbWU/ZChcInkuS2V5Lm9yaWdpbk5hbWVcIik6dC5WYWx1ZT09ZS5WYWx1ZT90LktleS5vcmlnaW5OYW1lLmxvY2FsZUNvbXBhcmUoZS5LZXkub3JpZ2luTmFtZSk6dC5WYWx1ZTxlLlZhbHVlPy0xOnQuVmFsdWU+ZS5WYWx1ZT8xOjApLHR9dG9TdHJpbmcoKXtsZXQgdD10aGlzLm9yZGVyZWRJdGVtcyxlPW5ldyBtO2ZvcihsZXQgbj0wO248dC5sZW5ndGg7bisrKXtuPjAmJmUuQXBwZW5kKFwiLCBcIik7bGV0IGk9dFtuXS5LZXk7aWYobnVsbD09PWkuaXRlbU5hbWUpcmV0dXJuIGQoXCJpdGVtLml0ZW1OYW1lXCIpO2UuQXBwZW5kKGkuaXRlbU5hbWUpfXJldHVybiBlLnRvU3RyaW5nKCl9dmFsdWVPZigpe3JldHVybiBOYU59fWNsYXNzIFMgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KSx0aGlzLnVzZUVuZExpbmVOdW1iZXI9ITEsdGhpcy5tZXNzYWdlPXQsdGhpcy5uYW1lPVwiU3RvcnlFeGNlcHRpb25cIn19ZnVuY3Rpb24geSh0LGUsbil7aWYobnVsbD09PXQpcmV0dXJue3Jlc3VsdDpuLGV4aXN0czohMX07bGV0IGk9dC5nZXQoZSk7cmV0dXJuIHZvaWQgMD09PWk/e3Jlc3VsdDpuLGV4aXN0czohMX06e3Jlc3VsdDppLGV4aXN0czohMH19Y2xhc3MgQyBleHRlbmRzIHB7c3RhdGljIENyZWF0ZSh0LG4pe2lmKG4pe2lmKG49PT1pLkludCYmTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodCkpKXJldHVybiBuZXcgYihOdW1iZXIodCkpO2lmKG49PT1pLkZsb2F0JiYhaXNOYU4odCkpcmV0dXJuIG5ldyBfKE51bWJlcih0KSl9aWYoXCJib29sZWFuXCI9PXR5cGVvZiB0KXt0PSEhdD8xOjB9cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/bmV3IFQoU3RyaW5nKHQpKTpOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih0KSk/bmV3IGIoTnVtYmVyKHQpKTppc05hTih0KT90IGluc3RhbmNlb2YgZT9uZXcgUChzKHQsZSkpOnQgaW5zdGFuY2VvZiBnP25ldyBPKHModCxnKSk6bnVsbDpuZXcgXyhOdW1iZXIodCkpfUNvcHkoKXtyZXR1cm4gcyhDLkNyZWF0ZSh0aGlzKSxwKX1CYWRDYXN0RXhjZXB0aW9uKHQpe3JldHVybiBuZXcgUyhcIkNhbid0IGNhc3QgXCIrdGhpcy52YWx1ZU9iamVjdCtcIiBmcm9tIFwiK3RoaXMudmFsdWVUeXBlK1wiIHRvIFwiK3QpfX1jbGFzcyB2IGV4dGVuZHMgQ3tjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudmFsdWU9dH1nZXQgdmFsdWVPYmplY3QoKXtyZXR1cm4gdGhpcy52YWx1ZX10b1N0cmluZygpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZT9kKFwiVmFsdWUudmFsdWVcIik6dGhpcy52YWx1ZS50b1N0cmluZygpfX1jbGFzcyBiIGV4dGVuZHMgdntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0fHwwKX1nZXQgaXNUcnV0aHkoKXtyZXR1cm4gMCE9dGhpcy52YWx1ZX1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuSW50fUNhc3QodCl7aWYobnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIGQoXCJWYWx1ZS52YWx1ZVwiKTtpZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpcztpZih0PT1pLkZsb2F0KXJldHVybiBuZXcgXyh0aGlzLnZhbHVlKTtpZih0PT1pLlN0cmluZylyZXR1cm4gbmV3IFQoXCJcIit0aGlzLnZhbHVlKTt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9fWNsYXNzIF8gZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKHQpe3N1cGVyKHR8fDApfWdldCBpc1RydXRoeSgpe3JldHVybiAwIT10aGlzLnZhbHVlfWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5GbG9hdH1DYXN0KHQpe2lmKG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBkKFwiVmFsdWUudmFsdWVcIik7aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7aWYodD09aS5JbnQpcmV0dXJuIG5ldyBiKHRoaXMudmFsdWUpO2lmKHQ9PWkuU3RyaW5nKXJldHVybiBuZXcgVChcIlwiK3RoaXMudmFsdWUpO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX19Y2xhc3MgVCBleHRlbmRzIHZ7Y29uc3RydWN0b3IodCl7aWYoc3VwZXIodHx8XCJcIiksdGhpcy5faXNOZXdsaW5lPVwiXFxuXCI9PXRoaXMudmFsdWUsdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlPSEwLG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBkKFwiVmFsdWUudmFsdWVcIik7dGhpcy52YWx1ZS5sZW5ndGg+MCYmdGhpcy52YWx1ZS5zcGxpdChcIlwiKS5ldmVyeSh0PT5cIiBcIj09dHx8XCJcXHRcIj09dHx8KHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZT0hMSwhMSkpfWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5TdHJpbmd9Z2V0IGlzVHJ1dGh5KCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlP2QoXCJWYWx1ZS52YWx1ZVwiKTp0aGlzLnZhbHVlLmxlbmd0aD4wfWdldCBpc05ld2xpbmUoKXtyZXR1cm4gdGhpcy5faXNOZXdsaW5lfWdldCBpc0lubGluZVdoaXRlc3BhY2UoKXtyZXR1cm4gdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlfWdldCBpc05vbldoaXRlc3BhY2UoKXtyZXR1cm4hdGhpcy5pc05ld2xpbmUmJiF0aGlzLmlzSW5saW5lV2hpdGVzcGFjZX1DYXN0KHQpe2lmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO2lmKHQ9PWkuSW50KXtsZXQgZT1mdW5jdGlvbih0LGU9MCl7bGV0IG49cGFyc2VJbnQodCk7cmV0dXJuIE51bWJlci5pc05hTihuKT97cmVzdWx0OmUsZXhpc3RzOiExfTp7cmVzdWx0Om4sZXhpc3RzOiEwfX0odGhpcy52YWx1ZSk7aWYoZS5leGlzdHMpcmV0dXJuIG5ldyBiKGUucmVzdWx0KTt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9aWYodD09aS5GbG9hdCl7bGV0IGU9ZnVuY3Rpb24odCxlPTApe2xldCBuPXBhcnNlRmxvYXQodCk7cmV0dXJuIE51bWJlci5pc05hTihuKT97cmVzdWx0OmUsZXhpc3RzOiExfTp7cmVzdWx0Om4sZXhpc3RzOiEwfX0odGhpcy52YWx1ZSk7aWYoZS5leGlzdHMpcmV0dXJuIG5ldyBfKGUucmVzdWx0KTt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfX1jbGFzcyBQIGV4dGVuZHMgdntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0KX1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuRGl2ZXJ0VGFyZ2V0fWdldCB0YXJnZXRQYXRoKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlP2QoXCJWYWx1ZS52YWx1ZVwiKTp0aGlzLnZhbHVlfXNldCB0YXJnZXRQYXRoKHQpe3RoaXMudmFsdWU9dH1nZXQgaXNUcnV0aHkoKXt0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGRuJ3QgYmUgY2hlY2tpbmcgdGhlIHRydXRoaW5lc3Mgb2YgYSBkaXZlcnQgdGFyZ2V0XCIpfUNhc3QodCl7aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfXRvU3RyaW5nKCl7cmV0dXJuXCJEaXZlcnRUYXJnZXRWYWx1ZShcIit0aGlzLnRhcmdldFBhdGgrXCIpXCJ9fWNsYXNzIHcgZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKHQsZT0tMSl7c3VwZXIodCksdGhpcy5fY29udGV4dEluZGV4PWV9Z2V0IGNvbnRleHRJbmRleCgpe3JldHVybiB0aGlzLl9jb250ZXh0SW5kZXh9c2V0IGNvbnRleHRJbmRleCh0KXt0aGlzLl9jb250ZXh0SW5kZXg9dH1nZXQgdmFyaWFibGVOYW1lKCl7cmV0dXJuIG51bGw9PT10aGlzLnZhbHVlP2QoXCJWYWx1ZS52YWx1ZVwiKTp0aGlzLnZhbHVlfXNldCB2YXJpYWJsZU5hbWUodCl7dGhpcy52YWx1ZT10fWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5WYXJpYWJsZVBvaW50ZXJ9Z2V0IGlzVHJ1dGh5KCl7dGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkbid0IGJlIGNoZWNraW5nIHRoZSB0cnV0aGluZXNzIG9mIGEgdmFyaWFibGUgcG9pbnRlclwiKX1DYXN0KHQpe2lmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX10b1N0cmluZygpe3JldHVyblwiVmFyaWFibGVQb2ludGVyVmFsdWUoXCIrdGhpcy52YXJpYWJsZU5hbWUrXCIpXCJ9Q29weSgpe3JldHVybiBuZXcgdyh0aGlzLnZhcmlhYmxlTmFtZSx0aGlzLmNvbnRleHRJbmRleCl9fWNsYXNzIE8gZXh0ZW5kcyB2e2dldCBpc1RydXRoeSgpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZT9kKFwidGhpcy52YWx1ZVwiKTp0aGlzLnZhbHVlLkNvdW50PjB9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLkxpc3R9Q2FzdCh0KXtpZihudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gZChcIlZhbHVlLnZhbHVlXCIpO2lmKHQ9PWkuSW50KXtsZXQgdD10aGlzLnZhbHVlLm1heEl0ZW07cmV0dXJuIHQuS2V5LmlzTnVsbD9uZXcgYigwKTpuZXcgYih0LlZhbHVlKX1pZih0PT1pLkZsb2F0KXtsZXQgdD10aGlzLnZhbHVlLm1heEl0ZW07cmV0dXJuIHQuS2V5LmlzTnVsbD9uZXcgXygwKTpuZXcgXyh0LlZhbHVlKX1pZih0PT1pLlN0cmluZyl7bGV0IHQ9dGhpcy52YWx1ZS5tYXhJdGVtO3JldHVybiB0LktleS5pc051bGw/bmV3IFQoXCJcIik6bmV3IFQodC5LZXkudG9TdHJpbmcoKSl9aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfWNvbnN0cnVjdG9yKHQsZSl7c3VwZXIobnVsbCksdHx8ZT90IGluc3RhbmNlb2YgZz90aGlzLnZhbHVlPW5ldyBnKHQpOnQgaW5zdGFuY2VvZiBmJiZcIm51bWJlclwiPT10eXBlb2YgZSYmKHRoaXMudmFsdWU9bmV3IGcoe0tleTp0LFZhbHVlOmV9KSk6dGhpcy52YWx1ZT1uZXcgZ31zdGF0aWMgUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KHQsZSl7bGV0IG49YSh0LE8pLGk9YShlLE8pO3JldHVybiBpJiZudWxsPT09aS52YWx1ZT9kKFwibmV3TGlzdC52YWx1ZVwiKTpuJiZudWxsPT09bi52YWx1ZT9kKFwib2xkTGlzdC52YWx1ZVwiKTp2b2lkKG4mJmkmJjA9PWkudmFsdWUuQ291bnQmJmkudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG4udmFsdWUub3JpZ2luTmFtZXMpKX19IWZ1bmN0aW9uKHQpe3RbdC5JbnQ9MF09XCJJbnRcIix0W3QuRmxvYXQ9MV09XCJGbG9hdFwiLHRbdC5MaXN0PTJdPVwiTGlzdFwiLHRbdC5TdHJpbmc9M109XCJTdHJpbmdcIix0W3QuRGl2ZXJ0VGFyZ2V0PTRdPVwiRGl2ZXJ0VGFyZ2V0XCIsdFt0LlZhcmlhYmxlUG9pbnRlcj01XT1cIlZhcmlhYmxlUG9pbnRlclwifShpfHwoaT17fSkpO2NsYXNzIEV7Y29uc3RydWN0b3IoKXt0aGlzLm9iaj1udWxsLHRoaXMuYXBwcm94aW1hdGU9ITF9Z2V0IGNvcnJlY3RPYmooKXtyZXR1cm4gdGhpcy5hcHByb3hpbWF0ZT9udWxsOnRoaXMub2JqfWdldCBjb250YWluZXIoKXtyZXR1cm4gdGhpcy5vYmogaW5zdGFuY2VvZiBOP3RoaXMub2JqOm51bGx9Y29weSgpe2xldCB0PW5ldyBFO3JldHVybiB0Lm9iaj10aGlzLm9iaix0LmFwcHJveGltYXRlPXRoaXMuYXBwcm94aW1hdGUsdH19Y2xhc3MgTiBleHRlbmRzIHB7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMubmFtZT1cIlwiLHRoaXMuX2NvbnRlbnQ9W10sdGhpcy5uYW1lZENvbnRlbnQ9bmV3IE1hcCx0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZD0hMSx0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZD0hMSx0aGlzLmNvdW50aW5nQXRTdGFydE9ubHk9ITEsdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudD1udWxsfWdldCBoYXNWYWxpZE5hbWUoKXtyZXR1cm4gbnVsbCE9dGhpcy5uYW1lJiZ0aGlzLm5hbWUubGVuZ3RoPjB9Z2V0IGNvbnRlbnQoKXtyZXR1cm4gdGhpcy5fY29udGVudH1zZXQgY29udGVudCh0KXt0aGlzLkFkZENvbnRlbnQodCl9Z2V0IG5hbWVkT25seUNvbnRlbnQoKXtsZXQgdD1uZXcgTWFwO2ZvcihsZXRbZSxuXW9mIHRoaXMubmFtZWRDb250ZW50KXtsZXQgaT1zKG4scCk7dC5zZXQoZSxpKX1mb3IobGV0IGUgb2YgdGhpcy5jb250ZW50KXtsZXQgbj1sKGUpO251bGwhPW4mJm4uaGFzVmFsaWROYW1lJiZ0LmRlbGV0ZShuLm5hbWUpfXJldHVybiAwPT10LnNpemUmJih0PW51bGwpLHR9c2V0IG5hbWVkT25seUNvbnRlbnQodCl7bGV0IGU9dGhpcy5uYW1lZE9ubHlDb250ZW50O2lmKG51bGwhPWUpZm9yKGxldFt0XW9mIGUpdGhpcy5uYW1lZENvbnRlbnQuZGVsZXRlKHQpO2lmKG51bGwhPXQpZm9yKGxldFssZV1vZiB0KXtsZXQgdD1sKGUpO251bGwhPXQmJnRoaXMuQWRkVG9OYW1lZENvbnRlbnRPbmx5KHQpfX1nZXQgY291bnRGbGFncygpe2xldCB0PTA7cmV0dXJuIHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkJiYodHw9Ti5Db3VudEZsYWdzLlZpc2l0cyksdGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQmJih0fD1OLkNvdW50RmxhZ3MuVHVybnMpLHRoaXMuY291bnRpbmdBdFN0YXJ0T25seSYmKHR8PU4uQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSksdD09Ti5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5JiYodD0wKSx0fXNldCBjb3VudEZsYWdzKHQpe2xldCBlPXQ7KGUmTi5Db3VudEZsYWdzLlZpc2l0cyk+MCYmKHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkPSEwKSwoZSZOLkNvdW50RmxhZ3MuVHVybnMpPjAmJih0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZD0hMCksKGUmTi5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KT4wJiYodGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5PSEwKX1nZXQgcGF0aFRvRmlyc3RMZWFmQ29udGVudCgpe3JldHVybiBudWxsPT10aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50JiYodGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudD10aGlzLnBhdGguUGF0aEJ5QXBwZW5kaW5nUGF0aCh0aGlzLmludGVybmFsUGF0aFRvRmlyc3RMZWFmQ29udGVudCkpLHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnR9Z2V0IGludGVybmFsUGF0aFRvRmlyc3RMZWFmQ29udGVudCgpe2xldCB0PVtdLG49dGhpcztmb3IoO24gaW5zdGFuY2VvZiBOOyluLmNvbnRlbnQubGVuZ3RoPjAmJih0LnB1c2gobmV3IGUuQ29tcG9uZW50KDApKSxuPW4uY29udGVudFswXSk7cmV0dXJuIG5ldyBlKHQpfUFkZENvbnRlbnQodCl7aWYodCBpbnN0YW5jZW9mIEFycmF5KXtsZXQgZT10O2ZvcihsZXQgdCBvZiBlKXRoaXMuQWRkQ29udGVudCh0KX1lbHNle2xldCBlPXQ7aWYodGhpcy5fY29udGVudC5wdXNoKGUpLGUucGFyZW50KXRocm93IG5ldyBFcnJvcihcImNvbnRlbnQgaXMgYWxyZWFkeSBpbiBcIitlLnBhcmVudCk7ZS5wYXJlbnQ9dGhpcyx0aGlzLlRyeUFkZE5hbWVkQ29udGVudChlKX19VHJ5QWRkTmFtZWRDb250ZW50KHQpe2xldCBlPWwodCk7bnVsbCE9ZSYmZS5oYXNWYWxpZE5hbWUmJnRoaXMuQWRkVG9OYW1lZENvbnRlbnRPbmx5KGUpfUFkZFRvTmFtZWRDb250ZW50T25seSh0KXtuLkFzc2VydFR5cGUodCxwLFwiQ2FuIG9ubHkgYWRkIFJ1bnRpbWUuT2JqZWN0cyB0byBhIFJ1bnRpbWUuQ29udGFpbmVyXCIpLHModCxwKS5wYXJlbnQ9dGhpcyx0aGlzLm5hbWVkQ29udGVudC5zZXQodC5uYW1lLHQpfUNvbnRlbnRBdFBhdGgodCxlPTAsbj0tMSl7LTE9PW4mJihuPXQubGVuZ3RoKTtsZXQgaT1uZXcgRTtpLmFwcHJveGltYXRlPSExO2xldCByPXRoaXMscz10aGlzO2ZvcihsZXQgbD1lO2w8bjsrK2wpe2xldCBlPXQuR2V0Q29tcG9uZW50KGwpO2lmKG51bGw9PXIpe2kuYXBwcm94aW1hdGU9ITA7YnJlYWt9bGV0IG49ci5Db250ZW50V2l0aFBhdGhDb21wb25lbnQoZSk7aWYobnVsbD09bil7aS5hcHByb3hpbWF0ZT0hMDticmVha31zPW4scj1hKG4sTil9cmV0dXJuIGkub2JqPXMsaX1JbnNlcnRDb250ZW50KHQsZSl7aWYodGhpcy5jb250ZW50W2VdPXQsdC5wYXJlbnQpdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiK3QucGFyZW50KTt0LnBhcmVudD10aGlzLHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KHQpfUFkZENvbnRlbnRzT2ZDb250YWluZXIodCl7dGhpcy5jb250ZW50PXRoaXMuY29udGVudC5jb25jYXQodC5jb250ZW50KTtmb3IobGV0IGUgb2YgdC5jb250ZW50KWUucGFyZW50PXRoaXMsdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoZSl9Q29udGVudFdpdGhQYXRoQ29tcG9uZW50KHQpe2lmKHQuaXNJbmRleClyZXR1cm4gdC5pbmRleD49MCYmdC5pbmRleDx0aGlzLmNvbnRlbnQubGVuZ3RoP3RoaXMuY29udGVudFt0LmluZGV4XTpudWxsO2lmKHQuaXNQYXJlbnQpcmV0dXJuIHRoaXMucGFyZW50O3tpZihudWxsPT09dC5uYW1lKXJldHVybiBkKFwiY29tcG9uZW50Lm5hbWVcIik7bGV0IGU9eSh0aGlzLm5hbWVkQ29udGVudCx0Lm5hbWUsbnVsbCk7cmV0dXJuIGUuZXhpc3RzP3MoZS5yZXN1bHQscCk6bnVsbH19QnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpe2xldCB0O2lmKDA9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHQ9bmV3IG0sdGhpcy5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHQsMCxudWxsKSx0LnRvU3RyaW5nKCk7dD1hcmd1bWVudHNbMF07bGV0IGU9YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO2Z1bmN0aW9uIHIoKXtmb3IobGV0IG49MDtuPDQqZTsrK24pdC5BcHBlbmQoXCIgXCIpfXIoKSx0LkFwcGVuZChcIltcIiksdGhpcy5oYXNWYWxpZE5hbWUmJnQuQXBwZW5kRm9ybWF0KFwiICh7MH0pXCIsdGhpcy5uYW1lKSx0aGlzPT1pJiZ0LkFwcGVuZChcIiAgPC0tLVwiKSx0LkFwcGVuZExpbmUoKSxlKys7Zm9yKGxldCBuPTA7bjx0aGlzLmNvbnRlbnQubGVuZ3RoOysrbil7bGV0IGE9dGhpcy5jb250ZW50W25dO2lmKGEgaW5zdGFuY2VvZiBOKXthLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkodCxlLGkpfWVsc2UgcigpLGEgaW5zdGFuY2VvZiBUPyh0LkFwcGVuZCgnXCInKSx0LkFwcGVuZChhLnRvU3RyaW5nKCkucmVwbGFjZShcIlxcblwiLFwiXFxcXG5cIikpLHQuQXBwZW5kKCdcIicpKTp0LkFwcGVuZChhLnRvU3RyaW5nKCkpO24hPXRoaXMuY29udGVudC5sZW5ndGgtMSYmdC5BcHBlbmQoXCIsXCIpLGEgaW5zdGFuY2VvZiBOfHxhIT1pfHx0LkFwcGVuZChcIiAgPC0tLVwiKSx0LkFwcGVuZExpbmUoKX1sZXQgYT1uZXcgTWFwO2ZvcihsZXRbdCxlXW9mIHRoaXMubmFtZWRDb250ZW50KXRoaXMuY29udGVudC5pbmRleE9mKHMoZSxwKSk+PTB8fGEuc2V0KHQsZSk7aWYoYS5zaXplPjApe3IoKSx0LkFwcGVuZExpbmUoXCItLSBuYW1lZDogLS1cIik7Zm9yKGxldFsscl1vZiBhKXtuLkFzc2VydFR5cGUocixOLFwiQ2FuIG9ubHkgcHJpbnQgb3V0IG5hbWVkIENvbnRhaW5lcnNcIiksci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHQsZSxpKSx0LkFwcGVuZExpbmUoKX19ZS0tLHIoKSx0LkFwcGVuZChcIl1cIil9fSFmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0LlZpc2l0cz0xXT1cIlZpc2l0c1wiLHRbdC5UdXJucz0yXT1cIlR1cm5zXCIsdFt0LkNvdW50U3RhcnRPbmx5PTRdPVwiQ291bnRTdGFydE9ubHlcIn0oZT10LkNvdW50RmxhZ3N8fCh0LkNvdW50RmxhZ3M9e30pKX0oTnx8KE49e30pKTtjbGFzcyB4IGV4dGVuZHMgcHt0b1N0cmluZygpe3JldHVyblwiR2x1ZVwifX1jbGFzcyBBIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0PUEuQ29tbWFuZFR5cGUuTm90U2V0KXtzdXBlcigpLHRoaXMuX2NvbW1hbmRUeXBlPXR9Z2V0IGNvbW1hbmRUeXBlKCl7cmV0dXJuIHRoaXMuX2NvbW1hbmRUeXBlfUNvcHkoKXtyZXR1cm4gbmV3IEEodGhpcy5jb21tYW5kVHlwZSl9c3RhdGljIEV2YWxTdGFydCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkV2YWxTdGFydCl9c3RhdGljIEV2YWxPdXRwdXQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5FdmFsT3V0cHV0KX1zdGF0aWMgRXZhbEVuZCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkV2YWxFbmQpfXN0YXRpYyBEdXBsaWNhdGUoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5EdXBsaWNhdGUpfXN0YXRpYyBQb3BFdmFsdWF0ZWRWYWx1ZSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlKX1zdGF0aWMgUG9wRnVuY3Rpb24oKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbil9c3RhdGljIFBvcFR1bm5lbCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlBvcFR1bm5lbCl9c3RhdGljIEJlZ2luU3RyaW5nKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpfXN0YXRpYyBFbmRTdHJpbmcoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5FbmRTdHJpbmcpfXN0YXRpYyBOb09wKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuTm9PcCl9c3RhdGljIENob2ljZUNvdW50KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnQpfXN0YXRpYyBUdXJucygpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlR1cm5zKX1zdGF0aWMgVHVybnNTaW5jZSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpfXN0YXRpYyBSZWFkQ291bnQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5SZWFkQ291bnQpfXN0YXRpYyBSYW5kb20oKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5SYW5kb20pfXN0YXRpYyBTZWVkUmFuZG9tKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbSl9c3RhdGljIFZpc2l0SW5kZXgoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5WaXNpdEluZGV4KX1zdGF0aWMgU2VxdWVuY2VTaHVmZmxlSW5kZXgoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleCl9c3RhdGljIFN0YXJ0VGhyZWFkKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQpfXN0YXRpYyBEb25lKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRG9uZSl9c3RhdGljIEVuZCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkVuZCl9c3RhdGljIExpc3RGcm9tSW50KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQpfXN0YXRpYyBMaXN0UmFuZ2UoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5MaXN0UmFuZ2UpfXN0YXRpYyBMaXN0UmFuZG9tKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbSl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb21tYW5kVHlwZS50b1N0cmluZygpfX0hZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5Ob3RTZXQ9LTFdPVwiTm90U2V0XCIsdFt0LkV2YWxTdGFydD0wXT1cIkV2YWxTdGFydFwiLHRbdC5FdmFsT3V0cHV0PTFdPVwiRXZhbE91dHB1dFwiLHRbdC5FdmFsRW5kPTJdPVwiRXZhbEVuZFwiLHRbdC5EdXBsaWNhdGU9M109XCJEdXBsaWNhdGVcIix0W3QuUG9wRXZhbHVhdGVkVmFsdWU9NF09XCJQb3BFdmFsdWF0ZWRWYWx1ZVwiLHRbdC5Qb3BGdW5jdGlvbj01XT1cIlBvcEZ1bmN0aW9uXCIsdFt0LlBvcFR1bm5lbD02XT1cIlBvcFR1bm5lbFwiLHRbdC5CZWdpblN0cmluZz03XT1cIkJlZ2luU3RyaW5nXCIsdFt0LkVuZFN0cmluZz04XT1cIkVuZFN0cmluZ1wiLHRbdC5Ob09wPTldPVwiTm9PcFwiLHRbdC5DaG9pY2VDb3VudD0xMF09XCJDaG9pY2VDb3VudFwiLHRbdC5UdXJucz0xMV09XCJUdXJuc1wiLHRbdC5UdXJuc1NpbmNlPTEyXT1cIlR1cm5zU2luY2VcIix0W3QuUmFuZG9tPTEzXT1cIlJhbmRvbVwiLHRbdC5TZWVkUmFuZG9tPTE0XT1cIlNlZWRSYW5kb21cIix0W3QuVmlzaXRJbmRleD0xNV09XCJWaXNpdEluZGV4XCIsdFt0LlNlcXVlbmNlU2h1ZmZsZUluZGV4PTE2XT1cIlNlcXVlbmNlU2h1ZmZsZUluZGV4XCIsdFt0LlN0YXJ0VGhyZWFkPTE3XT1cIlN0YXJ0VGhyZWFkXCIsdFt0LkRvbmU9MThdPVwiRG9uZVwiLHRbdC5FbmQ9MTldPVwiRW5kXCIsdFt0Lkxpc3RGcm9tSW50PTIwXT1cIkxpc3RGcm9tSW50XCIsdFt0Lkxpc3RSYW5nZT0yMV09XCJMaXN0UmFuZ2VcIix0W3QuTGlzdFJhbmRvbT0yMl09XCJMaXN0UmFuZG9tXCIsdFt0LlJlYWRDb3VudD0yM109XCJSZWFkQ291bnRcIix0W3QuVE9UQUxfVkFMVUVTPTI0XT1cIlRPVEFMX1ZBTFVFU1wifShlPXQuQ29tbWFuZFR5cGV8fCh0LkNvbW1hbmRUeXBlPXt9KSl9KEF8fChBPXt9KSksZnVuY3Rpb24odCl7dFt0LlR1bm5lbD0wXT1cIlR1bm5lbFwiLHRbdC5GdW5jdGlvbj0xXT1cIkZ1bmN0aW9uXCIsdFt0LkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lPTJdPVwiRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWVcIn0ocnx8KHI9e30pKTtjbGFzcyBJe2NvbnN0cnVjdG9yKCl7dGhpcy5jb250YWluZXI9bnVsbCx0aGlzLmluZGV4PS0xLDI9PT1hcmd1bWVudHMubGVuZ3RoJiYodGhpcy5jb250YWluZXI9YXJndW1lbnRzWzBdLHRoaXMuaW5kZXg9YXJndW1lbnRzWzFdKX1SZXNvbHZlKCl7cmV0dXJuIHRoaXMuaW5kZXg8MD90aGlzLmNvbnRhaW5lcjpudWxsPT10aGlzLmNvbnRhaW5lcj9udWxsOjA9PXRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoP3RoaXMuY29udGFpbmVyOnRoaXMuaW5kZXg+PXRoaXMuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoP251bGw6dGhpcy5jb250YWluZXIuY29udGVudFt0aGlzLmluZGV4XX1nZXQgaXNOdWxsKCl7cmV0dXJuIG51bGw9PXRoaXMuY29udGFpbmVyfWdldCBwYXRoKCl7cmV0dXJuIHRoaXMuaXNOdWxsP251bGw6dGhpcy5pbmRleD49MD90aGlzLmNvbnRhaW5lci5wYXRoLlBhdGhCeUFwcGVuZGluZ0NvbXBvbmVudChuZXcgZS5Db21wb25lbnQodGhpcy5pbmRleCkpOnRoaXMuY29udGFpbmVyLnBhdGh9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5jb250YWluZXI/XCJJbmsgUG9pbnRlciAtPiBcIit0aGlzLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkrXCIgLS0gaW5kZXggXCIrdGhpcy5pbmRleDpcIkluayBQb2ludGVyIChudWxsKVwifWNvcHkoKXtyZXR1cm4gbmV3IEkodGhpcy5jb250YWluZXIsdGhpcy5pbmRleCl9c3RhdGljIFN0YXJ0T2YodCl7cmV0dXJuIG5ldyBJKHQsMCl9c3RhdGljIGdldCBOdWxsKCl7cmV0dXJuIG5ldyBJKG51bGwsLTEpfX1jbGFzcyBrIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMuX3RhcmdldFBhdGg9bnVsbCx0aGlzLl90YXJnZXRQb2ludGVyPUkuTnVsbCx0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZT1udWxsLHRoaXMucHVzaGVzVG9TdGFjaz0hMSx0aGlzLnN0YWNrUHVzaFR5cGU9MCx0aGlzLmlzRXh0ZXJuYWw9ITEsdGhpcy5leHRlcm5hbEFyZ3M9MCx0aGlzLmlzQ29uZGl0aW9uYWw9ITEsdGhpcy5wdXNoZXNUb1N0YWNrPSExLHZvaWQgMCE9PXQmJih0aGlzLnB1c2hlc1RvU3RhY2s9ITAsdGhpcy5zdGFja1B1c2hUeXBlPXQpfWdldCB0YXJnZXRQYXRoKCl7aWYobnVsbCE9dGhpcy5fdGFyZ2V0UGF0aCYmdGhpcy5fdGFyZ2V0UGF0aC5pc1JlbGF0aXZlKXtsZXQgdD10aGlzLnRhcmdldFBvaW50ZXIuUmVzb2x2ZSgpO3QmJih0aGlzLl90YXJnZXRQYXRoPXQucGF0aCl9cmV0dXJuIHRoaXMuX3RhcmdldFBhdGh9c2V0IHRhcmdldFBhdGgodCl7dGhpcy5fdGFyZ2V0UGF0aD10LHRoaXMuX3RhcmdldFBvaW50ZXI9SS5OdWxsfWdldCB0YXJnZXRQb2ludGVyKCl7aWYodGhpcy5fdGFyZ2V0UG9pbnRlci5pc051bGwpe2xldCB0PXRoaXMuUmVzb2x2ZVBhdGgodGhpcy5fdGFyZ2V0UGF0aCkub2JqO2lmKG51bGw9PT10aGlzLl90YXJnZXRQYXRoKXJldHVybiBkKFwidGhpcy5fdGFyZ2V0UGF0aFwiKTtpZihudWxsPT09dGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50KXJldHVybiBkKFwidGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50XCIpO2lmKHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pc0luZGV4KXtpZihudWxsPT09dClyZXR1cm4gZChcInRhcmdldE9ialwiKTt0aGlzLl90YXJnZXRQb2ludGVyLmNvbnRhaW5lcj10LnBhcmVudCBpbnN0YW5jZW9mIE4/dC5wYXJlbnQ6bnVsbCx0aGlzLl90YXJnZXRQb2ludGVyLmluZGV4PXRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pbmRleH1lbHNlIHRoaXMuX3RhcmdldFBvaW50ZXI9SS5TdGFydE9mKHQgaW5zdGFuY2VvZiBOP3Q6bnVsbCl9cmV0dXJuIHRoaXMuX3RhcmdldFBvaW50ZXIuY29weSgpfWdldCB0YXJnZXRQYXRoU3RyaW5nKCl7cmV0dXJuIG51bGw9PXRoaXMudGFyZ2V0UGF0aD9udWxsOnRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy50YXJnZXRQYXRoKX1zZXQgdGFyZ2V0UGF0aFN0cmluZyh0KXt0aGlzLnRhcmdldFBhdGg9bnVsbD09dD9udWxsOm5ldyBlKHQpfWdldCBoYXNWYXJpYWJsZVRhcmdldCgpe3JldHVybiBudWxsIT10aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZX1FcXVhbHModCl7bGV0IGU9dDtyZXR1cm4gZSBpbnN0YW5jZW9mIGsmJnRoaXMuaGFzVmFyaWFibGVUYXJnZXQ9PWUuaGFzVmFyaWFibGVUYXJnZXQmJih0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0P3RoaXMudmFyaWFibGVEaXZlcnROYW1lPT1lLnZhcmlhYmxlRGl2ZXJ0TmFtZTpudWxsPT09dGhpcy50YXJnZXRQYXRoP2QoXCJ0aGlzLnRhcmdldFBhdGhcIik6dGhpcy50YXJnZXRQYXRoLkVxdWFscyhlLnRhcmdldFBhdGgpKX10b1N0cmluZygpe2lmKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQpcmV0dXJuXCJEaXZlcnQodmFyaWFibGU6IFwiK3RoaXMudmFyaWFibGVEaXZlcnROYW1lK1wiKVwiO2lmKG51bGw9PXRoaXMudGFyZ2V0UGF0aClyZXR1cm5cIkRpdmVydChudWxsKVwiO3tsZXQgdD1uZXcgbSxlPXRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpO3JldHVybiB0LkFwcGVuZChcIkRpdmVydFwiKSx0aGlzLmlzQ29uZGl0aW9uYWwmJnQuQXBwZW5kKFwiP1wiKSx0aGlzLnB1c2hlc1RvU3RhY2smJih0aGlzLnN0YWNrUHVzaFR5cGU9PXIuRnVuY3Rpb24/dC5BcHBlbmQoXCIgZnVuY3Rpb25cIik6dC5BcHBlbmQoXCIgdHVubmVsXCIpKSx0LkFwcGVuZChcIiAtPiBcIiksdC5BcHBlbmQodGhpcy50YXJnZXRQYXRoU3RyaW5nKSx0LkFwcGVuZChcIiAoXCIpLHQuQXBwZW5kKGUpLHQuQXBwZW5kKFwiKVwiKSx0LnRvU3RyaW5nKCl9fX1jbGFzcyBXIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0PSEwKXtzdXBlcigpLHRoaXMuX3BhdGhPbkNob2ljZT1udWxsLHRoaXMuaGFzQ29uZGl0aW9uPSExLHRoaXMuaGFzU3RhcnRDb250ZW50PSExLHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQ9ITEsdGhpcy5pc0ludmlzaWJsZURlZmF1bHQ9ITEsdGhpcy5vbmNlT25seT0hMCx0aGlzLm9uY2VPbmx5PXR9Z2V0IHBhdGhPbkNob2ljZSgpe2lmKG51bGwhPXRoaXMuX3BhdGhPbkNob2ljZSYmdGhpcy5fcGF0aE9uQ2hvaWNlLmlzUmVsYXRpdmUpe2xldCB0PXRoaXMuY2hvaWNlVGFyZ2V0O3QmJih0aGlzLl9wYXRoT25DaG9pY2U9dC5wYXRoKX1yZXR1cm4gdGhpcy5fcGF0aE9uQ2hvaWNlfXNldCBwYXRoT25DaG9pY2UodCl7dGhpcy5fcGF0aE9uQ2hvaWNlPXR9Z2V0IGNob2ljZVRhcmdldCgpe3JldHVybiBudWxsPT09dGhpcy5fcGF0aE9uQ2hvaWNlP2QoXCJDaG9pY2VQb2ludC5fcGF0aE9uQ2hvaWNlXCIpOnRoaXMuUmVzb2x2ZVBhdGgodGhpcy5fcGF0aE9uQ2hvaWNlKS5jb250YWluZXJ9Z2V0IHBhdGhTdHJpbmdPbkNob2ljZSgpe3JldHVybiBudWxsPT09dGhpcy5wYXRoT25DaG9pY2U/ZChcIkNob2ljZVBvaW50LnBhdGhPbkNob2ljZVwiKTp0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aE9uQ2hvaWNlKX1zZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHQpe3RoaXMucGF0aE9uQ2hvaWNlPW5ldyBlKHQpfWdldCBmbGFncygpe2xldCB0PTA7cmV0dXJuIHRoaXMuaGFzQ29uZGl0aW9uJiYodHw9MSksdGhpcy5oYXNTdGFydENvbnRlbnQmJih0fD0yKSx0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50JiYodHw9NCksdGhpcy5pc0ludmlzaWJsZURlZmF1bHQmJih0fD04KSx0aGlzLm9uY2VPbmx5JiYodHw9MTYpLHR9c2V0IGZsYWdzKHQpe3RoaXMuaGFzQ29uZGl0aW9uPSgxJnQpPjAsdGhpcy5oYXNTdGFydENvbnRlbnQ9KDImdCk+MCx0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50PSg0JnQpPjAsdGhpcy5pc0ludmlzaWJsZURlZmF1bHQ9KDgmdCk+MCx0aGlzLm9uY2VPbmx5PSgxNiZ0KT4wfXRvU3RyaW5nKCl7aWYobnVsbD09PXRoaXMucGF0aE9uQ2hvaWNlKXJldHVybiBkKFwiQ2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlXCIpO3JldHVyblwiQ2hvaWNlOiAtPiBcIit0aGlzLnBhdGhPbkNob2ljZS50b1N0cmluZygpfX1jbGFzcyBGIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0PW51bGwpe3N1cGVyKCksdGhpcy5wYXRoRm9yQ291bnQ9bnVsbCx0aGlzLm5hbWU9dH1nZXQgY29udGFpbmVyRm9yQ291bnQoKXtyZXR1cm4gbnVsbD09PXRoaXMucGF0aEZvckNvdW50P251bGw6dGhpcy5SZXNvbHZlUGF0aCh0aGlzLnBhdGhGb3JDb3VudCkuY29udGFpbmVyfWdldCBwYXRoU3RyaW5nRm9yQ291bnQoKXtyZXR1cm4gbnVsbD09PXRoaXMucGF0aEZvckNvdW50P251bGw6dGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnBhdGhGb3JDb3VudCl9c2V0IHBhdGhTdHJpbmdGb3JDb3VudCh0KXt0aGlzLnBhdGhGb3JDb3VudD1udWxsPT09dD9udWxsOm5ldyBlKHQpfXRvU3RyaW5nKCl7aWYobnVsbCE9dGhpcy5uYW1lKXJldHVyblwidmFyKFwiK3RoaXMubmFtZStcIilcIjtyZXR1cm5cInJlYWRfY291bnQoXCIrdGhpcy5wYXRoU3RyaW5nRm9yQ291bnQrXCIpXCJ9fWNsYXNzIFYgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKHQsZSl7c3VwZXIoKSx0aGlzLnZhcmlhYmxlTmFtZT10fHxudWxsLHRoaXMuaXNOZXdEZWNsYXJhdGlvbj0hIWUsdGhpcy5pc0dsb2JhbD0hMX10b1N0cmluZygpe3JldHVyblwiVmFyQXNzaWduIHRvIFwiK3RoaXMudmFyaWFibGVOYW1lfX1jbGFzcyBMIGV4dGVuZHMgcHt9Y2xhc3MgUiBleHRlbmRzIHB7Y29uc3RydWN0b3IoKXtpZihzdXBlcigpLHRoaXMuX25hbWU9bnVsbCx0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnM9MCx0aGlzLl9wcm90b3R5cGU9bnVsbCx0aGlzLl9pc1Byb3RvdHlwZT0hMSx0aGlzLl9vcGVyYXRpb25GdW5jcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVIuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2xldCB0PWFyZ3VtZW50c1swXTtSLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKSx0aGlzLm5hbWU9dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5faXNQcm90b3R5cGU9ITAsdGhpcy5uYW1lPXQsdGhpcy5udW1iZXJPZlBhcmFtZXRlcnM9ZX19c3RhdGljIENhbGxXaXRoTmFtZSh0KXtyZXR1cm4gbmV3IFIodCl9c3RhdGljIENhbGxFeGlzdHNXaXRoTmFtZSh0KXtyZXR1cm4gdGhpcy5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCksdGhpcy5fbmF0aXZlRnVuY3Rpb25zLmdldCh0KX1nZXQgbmFtZSgpe3JldHVybiBudWxsPT09dGhpcy5fbmFtZT9kKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYW1lXCIpOnRoaXMuX25hbWV9c2V0IG5hbWUodCl7dGhpcy5fbmFtZT10LHRoaXMuX2lzUHJvdG90eXBlfHwobnVsbD09PVIuX25hdGl2ZUZ1bmN0aW9ucz9kKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnNcIik6dGhpcy5fcHJvdG90eXBlPVIuX25hdGl2ZUZ1bmN0aW9ucy5nZXQodGhpcy5fbmFtZSl8fG51bGwpfWdldCBudW1iZXJPZlBhcmFtZXRlcnMoKXtyZXR1cm4gdGhpcy5fcHJvdG90eXBlP3RoaXMuX3Byb3RvdHlwZS5udW1iZXJPZlBhcmFtZXRlcnM6dGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzfXNldCBudW1iZXJPZlBhcmFtZXRlcnModCl7dGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzPXR9Q2FsbCh0KXtpZih0aGlzLl9wcm90b3R5cGUpcmV0dXJuIHRoaXMuX3Byb3RvdHlwZS5DYWxsKHQpO2lmKHRoaXMubnVtYmVyT2ZQYXJhbWV0ZXJzIT10Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzXCIpO2xldCBlPSExO2ZvcihsZXQgbiBvZiB0KXtpZihuIGluc3RhbmNlb2YgTCl0aHJvdyBuZXcgUygnQXR0ZW1wdGluZyB0byBwZXJmb3JtIG9wZXJhdGlvbiBvbiBhIHZvaWQgdmFsdWUuIERpZCB5b3UgZm9yZ2V0IHRvIFwicmV0dXJuXCIgYSB2YWx1ZSBmcm9tIGEgZnVuY3Rpb24geW91IGNhbGxlZCBoZXJlPycpO24gaW5zdGFuY2VvZiBPJiYoZT0hMCl9aWYoMj09dC5sZW5ndGgmJmUpcmV0dXJuIHRoaXMuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24odCk7bGV0IG49dGhpcy5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUodCkscj1uWzBdLnZhbHVlVHlwZTtyZXR1cm4gcj09aS5JbnR8fHI9PWkuRmxvYXR8fHI9PWkuU3RyaW5nfHxyPT1pLkRpdmVydFRhcmdldHx8cj09aS5MaXN0P3RoaXMuQ2FsbFR5cGUobik6bnVsbH1DYWxsVHlwZSh0KXtsZXQgZT1zKHRbMF0sdiksbj1lLnZhbHVlVHlwZSxyPWUsYT10Lmxlbmd0aDtpZigyPT1hfHwxPT1hKXtpZihudWxsPT09dGhpcy5fb3BlcmF0aW9uRnVuY3MpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO2xldCBsPXRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChuKTtpZighbCl7Y29uc3QgdD1pW25dO3Rocm93IG5ldyBTKFwiQ2Fubm90IHBlcmZvcm0gb3BlcmF0aW9uIFwiK3RoaXMubmFtZStcIiBvbiBcIit0KX1pZigyPT1hKXtsZXQgZT1zKHRbMV0sdiksbj1sO2lmKG51bGw9PT1yLnZhbHVlfHxudWxsPT09ZS52YWx1ZSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIEJpbmFyeU9wIHZhbHVlc1wiKTtsZXQgaT1uKHIudmFsdWUsZS52YWx1ZSk7cmV0dXJuIHYuQ3JlYXRlKGkpfXtsZXQgdD1sO2lmKG51bGw9PT1yLnZhbHVlKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGwgVW5hcnlPcCB2YWx1ZVwiKTtsZXQgbj10KHIudmFsdWUpO3JldHVybiB0aGlzLm5hbWU9PT1SLkludD92LkNyZWF0ZShuLGkuSW50KTp0aGlzLm5hbWU9PT1SLkZsb2F0P3YuQ3JlYXRlKG4saS5GbG9hdCk6di5DcmVhdGUobixlLnZhbHVlVHlwZSl9fXRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgdG8gTmF0aXZlRnVuY3Rpb25DYWxsOiBcIit0Lmxlbmd0aCl9Q2FsbEJpbmFyeUxpc3RPcGVyYXRpb24odCl7aWYoKFwiK1wiPT10aGlzLm5hbWV8fFwiLVwiPT10aGlzLm5hbWUpJiZ0WzBdaW5zdGFuY2VvZiBPJiZ0WzFdaW5zdGFuY2VvZiBiKXJldHVybiB0aGlzLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uKHQpO2xldCBlPXModFswXSx2KSxuPXModFsxXSx2KTtpZighKFwiJiZcIiE9dGhpcy5uYW1lJiZcInx8XCIhPXRoaXMubmFtZXx8ZS52YWx1ZVR5cGU9PWkuTGlzdCYmbi52YWx1ZVR5cGU9PWkuTGlzdCkpe2lmKG51bGw9PT10aGlzLl9vcGVyYXRpb25GdW5jcylyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7bGV0IHQ9dGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KGkuSW50KTtpZihudWxsPT09dClyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsQmluYXJ5TGlzdE9wZXJhdGlvbiBvcFwiKTtsZXQgcj10KGUuaXNUcnV0aHk/MTowLG4uaXNUcnV0aHk/MTowKTtyZXR1cm4gbmV3IGIocil9aWYoZS52YWx1ZVR5cGU9PWkuTGlzdCYmbi52YWx1ZVR5cGU9PWkuTGlzdClyZXR1cm4gdGhpcy5DYWxsVHlwZShbZSxuXSk7dGhyb3cgbmV3IFMoXCJDYW4gbm90IGNhbGwgdXNlIFwiK3RoaXMubmFtZStcIiBvcGVyYXRpb24gb24gXCIraVtlLnZhbHVlVHlwZV0rXCIgYW5kIFwiK2lbbi52YWx1ZVR5cGVdKX1DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbih0KXtsZXQgZT1zKHRbMF0sTyksbj1zKHRbMV0sYikscj1uZXcgZztpZihudWxsPT09ZS52YWx1ZSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBsaXN0VmFsLnZhbHVlXCIpO2ZvcihsZXRbdCxhXW9mIGUudmFsdWUpe2xldCBzPWYuZnJvbVNlcmlhbGl6ZWRLZXkodCk7aWYobnVsbD09PXRoaXMuX29wZXJhdGlvbkZ1bmNzKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtsZXQgbD10aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQoaS5JbnQpO2lmKG51bGw9PT1uLnZhbHVlKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGludFZhbC52YWx1ZVwiKTtsZXQgbz1sKGEsbi52YWx1ZSksdT1udWxsO2lmKG51bGw9PT1lLnZhbHVlLm9yaWdpbnMpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZS5vcmlnaW5zXCIpO2ZvcihsZXQgdCBvZiBlLnZhbHVlLm9yaWdpbnMpaWYodC5uYW1lPT1zLm9yaWdpbk5hbWUpe3U9dDticmVha31pZihudWxsIT11KXtsZXQgdD11LlRyeUdldEl0ZW1XaXRoVmFsdWUobyxmLk51bGwpO3QuZXhpc3RzJiZyLkFkZCh0LnJlc3VsdCxvKX19cmV0dXJuIG5ldyBPKHIpfUNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSh0KXtsZXQgZT1pLkludCxuPW51bGw7Zm9yKGxldCByIG9mIHQpe2xldCB0PXMocix2KTt0LnZhbHVlVHlwZT5lJiYoZT10LnZhbHVlVHlwZSksdC52YWx1ZVR5cGU9PWkuTGlzdCYmKG49YSh0LE8pKX1sZXQgcj1bXTtpZihpW2VdPT1pW2kuTGlzdF0pZm9yKGxldCBlIG9mIHQpe2xldCB0PXMoZSx2KTtpZih0LnZhbHVlVHlwZT09aS5MaXN0KXIucHVzaCh0KTtlbHNle2lmKHQudmFsdWVUeXBlIT1pLkludCl7Y29uc3QgZT1pW3QudmFsdWVUeXBlXTt0aHJvdyBuZXcgUyhcIkNhbm5vdCBtaXggTGlzdHMgYW5kIFwiK2UrXCIgdmFsdWVzIGluIHRoaXMgb3BlcmF0aW9uXCIpfXtsZXQgZT1wYXJzZUludCh0LnZhbHVlT2JqZWN0KTtpZihuPXMobixPKSxudWxsPT09bi52YWx1ZSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUgc3BlY2lhbENhc2VMaXN0LnZhbHVlXCIpO2xldCBpPW4udmFsdWUub3JpZ2luT2ZNYXhJdGVtO2lmKG51bGw9PT1pKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSBsaXN0XCIpO2xldCBhPWkuVHJ5R2V0SXRlbVdpdGhWYWx1ZShlLGYuTnVsbCk7aWYoIWEuZXhpc3RzKXRocm93IG5ldyBTKFwiQ291bGQgbm90IGZpbmQgTGlzdCBpdGVtIHdpdGggdGhlIHZhbHVlIFwiK2UrXCIgaW4gXCIraS5uYW1lKTt7bGV0IHQ9bmV3IE8oYS5yZXN1bHQsZSk7ci5wdXNoKHQpfX19fWVsc2UgZm9yKGxldCBuIG9mIHQpe2xldCB0PXMobix2KS5DYXN0KGUpO3IucHVzaCh0KX1yZXR1cm4gcn1zdGF0aWMgSWRlbnRpdHkodCl7cmV0dXJuIHR9c3RhdGljIEdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKXtpZihudWxsPT10aGlzLl9uYXRpdmVGdW5jdGlvbnMpe3RoaXMuX25hdGl2ZUZ1bmN0aW9ucz1uZXcgTWFwLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5BZGQsKHQsZSk9PnQrZSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCh0LGUpPT50LWUpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NdWx0aXBseSwodCxlKT0+dCplKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuRGl2aWRlLCh0LGUpPT5NYXRoLmZsb29yKHQvZSkpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Nb2QsKHQsZSk9PnQlZSksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTmVnYXRlLHQ9Pi10KSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuRXF1YWwsKHQsZSk9PnQ9PWU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlciwodCxlKT0+dD5lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkxlc3MsKHQsZSk9PnQ8ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCh0LGUpPT50Pj1lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsKHQsZSk9PnQ8PWU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCh0LGUpPT50IT1lPzE6MCksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTm90LHQ9PjA9PXQ/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQW5kLCh0LGUpPT4wIT10JiYwIT1lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk9yLCh0LGUpPT4wIT10fHwwIT1lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1heCwodCxlKT0+TWF0aC5tYXgodCxlKSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1pbiwodCxlKT0+TWF0aC5taW4odCxlKSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlBvdywodCxlKT0+TWF0aC5wb3codCxlKSksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvb3IsUi5JZGVudGl0eSksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuQ2VpbGluZyxSLklkZW50aXR5KSx0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5JbnQsUi5JZGVudGl0eSksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuRmxvYXQsdD0+dCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuQWRkLCh0LGUpPT50K2UpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCh0LGUpPT50LWUpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCh0LGUpPT50KmUpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkRpdmlkZSwodCxlKT0+dC9lKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Nb2QsKHQsZSk9PnQlZSksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5OZWdhdGUsdD0+LXQpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkVxdWFsLCh0LGUpPT50PT1lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwodCxlKT0+dD5lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTGVzcywodCxlKT0+dDxlPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywodCxlKT0+dD49ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsKHQsZSk9PnQ8PWU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsKHQsZSk9PnQhPWU/MTowKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLk5vdCx0PT4wPT10PzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuQW5kLCh0LGUpPT4wIT10JiYwIT1lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuT3IsKHQsZSk9PjAhPXR8fDAhPWU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NYXgsKHQsZSk9Pk1hdGgubWF4KHQsZSkpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1pbiwodCxlKT0+TWF0aC5taW4odCxlKSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuUG93LCh0LGUpPT5NYXRoLnBvdyh0LGUpKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkZsb29yLHQ9Pk1hdGguZmxvb3IodCkpLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuQ2VpbGluZyx0PT5NYXRoLmNlaWwodCkpLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuSW50LHQ9Pk1hdGguZmxvb3IodCkpLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvYXQsUi5JZGVudGl0eSksdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkFkZCwodCxlKT0+dCtlKSx0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuRXF1YWwsKHQsZSk9PnQ9PT1lPzE6MCksdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywodCxlKT0+dCE9PWU/MTowKSx0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuSGFzLCh0LGUpPT50LmluY2x1ZGVzKGUpPzE6MCksdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhc250LCh0LGUpPT50LmluY2x1ZGVzKGUpPzA6MSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BZGQsKHQsZSk9PnQuVW5pb24oZSkpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsKHQsZSk9PnQuV2l0aG91dChlKSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXMsKHQsZSk9PnQuQ29udGFpbnMoZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkhhc250LCh0LGUpPT50LkNvbnRhaW5zKGUpPzA6MSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5JbnRlcnNlY3QsKHQsZSk9PnQuSW50ZXJzZWN0KGUpKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkVxdWFsLCh0LGUpPT50LkVxdWFscyhlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwodCxlKT0+dC5HcmVhdGVyVGhhbihlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzcywodCxlKT0+dC5MZXNzVGhhbihlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywodCxlKT0+dC5HcmVhdGVyVGhhbk9yRXF1YWxzKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCh0LGUpPT50Lkxlc3NUaGFuT3JFcXVhbHMoZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywodCxlKT0+dC5FcXVhbHMoZSk/MDoxKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkFuZCwodCxlKT0+dC5Db3VudD4wJiZlLkNvdW50PjA/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLk9yLCh0LGUpPT50LkNvdW50PjB8fGUuQ291bnQ+MD8xOjApLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5Ob3QsdD0+MD09dC5Db3VudD8xOjApLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5JbnZlcnQsdD0+dC5pbnZlcnNlKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQWxsLHQ9PnQuYWxsKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTGlzdE1pbix0PT50Lk1pbkFzTGlzdCgpKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTGlzdE1heCx0PT50Lk1heEFzTGlzdCgpKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuQ291bnQsdD0+dC5Db3VudCksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLlZhbHVlT2ZMaXN0LHQ9PnQubWF4SXRlbS5WYWx1ZSk7bGV0IHQ9KHQsZSk9PnQuRXF1YWxzKGUpPzE6MCxlPSh0LGUpPT50LkVxdWFscyhlKT8wOjE7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLkVxdWFsLDIsaS5EaXZlcnRUYXJnZXQsdCksdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLk5vdEVxdWFscywyLGkuRGl2ZXJ0VGFyZ2V0LGUpfX1BZGRPcEZ1bmNGb3JUeXBlKHQsZSl7bnVsbD09dGhpcy5fb3BlcmF0aW9uRnVuY3MmJih0aGlzLl9vcGVyYXRpb25GdW5jcz1uZXcgTWFwKSx0aGlzLl9vcGVyYXRpb25GdW5jcy5zZXQodCxlKX1zdGF0aWMgQWRkT3BUb05hdGl2ZUZ1bmModCxlLG4saSl7aWYobnVsbD09PXRoaXMuX25hdGl2ZUZ1bmN0aW9ucylyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpO2xldCByPXRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5nZXQodCk7cnx8KHI9bmV3IFIodCxlKSx0aGlzLl9uYXRpdmVGdW5jdGlvbnMuc2V0KHQscikpLHIuQWRkT3BGdW5jRm9yVHlwZShuLGkpfXN0YXRpYyBBZGRJbnRCaW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwyLGkuSW50LGUpfXN0YXRpYyBBZGRJbnRVbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDEsaS5JbnQsZSl9c3RhdGljIEFkZEZsb2F0QmluYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMixpLkZsb2F0LGUpfXN0YXRpYyBBZGRGbG9hdFVuYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMSxpLkZsb2F0LGUpfXN0YXRpYyBBZGRTdHJpbmdCaW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwyLGkuU3RyaW5nLGUpfXN0YXRpYyBBZGRMaXN0QmluYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMixpLkxpc3QsZSl9c3RhdGljIEFkZExpc3RVbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDEsaS5MaXN0LGUpfXRvU3RyaW5nKCl7cmV0dXJuJ05hdGl2ZSBcIicrdGhpcy5uYW1lKydcIid9fVIuQWRkPVwiK1wiLFIuU3VidHJhY3Q9XCItXCIsUi5EaXZpZGU9XCIvXCIsUi5NdWx0aXBseT1cIipcIixSLk1vZD1cIiVcIixSLk5lZ2F0ZT1cIl9cIixSLkVxdWFsPVwiPT1cIixSLkdyZWF0ZXI9XCI+XCIsUi5MZXNzPVwiPFwiLFIuR3JlYXRlclRoYW5PckVxdWFscz1cIj49XCIsUi5MZXNzVGhhbk9yRXF1YWxzPVwiPD1cIixSLk5vdEVxdWFscz1cIiE9XCIsUi5Ob3Q9XCIhXCIsUi5BbmQ9XCImJlwiLFIuT3I9XCJ8fFwiLFIuTWluPVwiTUlOXCIsUi5NYXg9XCJNQVhcIixSLlBvdz1cIlBPV1wiLFIuRmxvb3I9XCJGTE9PUlwiLFIuQ2VpbGluZz1cIkNFSUxJTkdcIixSLkludD1cIklOVFwiLFIuRmxvYXQ9XCJGTE9BVFwiLFIuSGFzPVwiP1wiLFIuSGFzbnQ9XCIhP1wiLFIuSW50ZXJzZWN0PVwiXlwiLFIuTGlzdE1pbj1cIkxJU1RfTUlOXCIsUi5MaXN0TWF4PVwiTElTVF9NQVhcIixSLkFsbD1cIkxJU1RfQUxMXCIsUi5Db3VudD1cIkxJU1RfQ09VTlRcIixSLlZhbHVlT2ZMaXN0PVwiTElTVF9WQUxVRVwiLFIuSW52ZXJ0PVwiTElTVF9JTlZFUlRcIixSLl9uYXRpdmVGdW5jdGlvbnM9bnVsbDtjbGFzcyBqIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0KXtzdXBlcigpLHRoaXMudGV4dD10LnRvU3RyaW5nKCl8fFwiXCJ9dG9TdHJpbmcoKXtyZXR1cm5cIiMgXCIrdGhpcy50ZXh0fX1jbGFzcyBEIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy50ZXh0PVwiXCIsdGhpcy5pbmRleD0wLHRoaXMudGhyZWFkQXRHZW5lcmF0aW9uPW51bGwsdGhpcy5zb3VyY2VQYXRoPVwiXCIsdGhpcy50YXJnZXRQYXRoPW51bGwsdGhpcy5pc0ludmlzaWJsZURlZmF1bHQ9ITEsdGhpcy5vcmlnaW5hbFRocmVhZEluZGV4PTB9Z2V0IHBhdGhTdHJpbmdPbkNob2ljZSgpe3JldHVybiBudWxsPT09dGhpcy50YXJnZXRQYXRoP2QoXCJDaG9pY2UudGFyZ2V0UGF0aFwiKTp0aGlzLnRhcmdldFBhdGgudG9TdHJpbmcoKX1zZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHQpe3RoaXMudGFyZ2V0UGF0aD1uZXcgZSh0KX19Y2xhc3MgR3tjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuX25hbWU9dHx8XCJcIix0aGlzLl9pdGVtcz1udWxsLHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXM9ZXx8bmV3IE1hcH1nZXQgbmFtZSgpe3JldHVybiB0aGlzLl9uYW1lfWdldCBpdGVtcygpe2lmKG51bGw9PXRoaXMuX2l0ZW1zKXt0aGlzLl9pdGVtcz1uZXcgTWFwO2ZvcihsZXRbdCxlXW9mIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMpe2xldCBuPW5ldyBmKHRoaXMubmFtZSx0KTt0aGlzLl9pdGVtcy5zZXQobi5zZXJpYWxpemVkKCksZSl9fXJldHVybiB0aGlzLl9pdGVtc31WYWx1ZUZvckl0ZW0odCl7aWYoIXQuaXRlbU5hbWUpcmV0dXJuIDA7bGV0IGU9dGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5nZXQodC5pdGVtTmFtZSk7cmV0dXJuIHZvaWQgMCE9PWU/ZTowfUNvbnRhaW5zSXRlbSh0KXtyZXR1cm4hIXQuaXRlbU5hbWUmJih0Lm9yaWdpbk5hbWU9PXRoaXMubmFtZSYmdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5oYXModC5pdGVtTmFtZSkpfUNvbnRhaW5zSXRlbVdpdGhOYW1lKHQpe3JldHVybiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyh0KX1UcnlHZXRJdGVtV2l0aFZhbHVlKHQsZSl7Zm9yKGxldFtlLG5db2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcylpZihuPT10KXJldHVybntyZXN1bHQ6bmV3IGYodGhpcy5uYW1lLGUpLGV4aXN0czohMH07cmV0dXJue3Jlc3VsdDpmLk51bGwsZXhpc3RzOiExfX1UcnlHZXRWYWx1ZUZvckl0ZW0odCxlKXtpZighdC5pdGVtTmFtZSlyZXR1cm57cmVzdWx0OjAsZXhpc3RzOiExfTtsZXQgbj10aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmdldCh0Lml0ZW1OYW1lKTtyZXR1cm4gbj97cmVzdWx0Om4sZXhpc3RzOiEwfTp7cmVzdWx0OjAsZXhpc3RzOiExfX19Y2xhc3MgQntjb25zdHJ1Y3Rvcih0KXt0aGlzLl9saXN0cz1uZXcgTWFwLHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGU9bmV3IE1hcDtmb3IobGV0IGUgb2YgdCl7dGhpcy5fbGlzdHMuc2V0KGUubmFtZSxlKTtmb3IobGV0W3Qsbl1vZiBlLml0ZW1zKXtsZXQgZT1mLmZyb21TZXJpYWxpemVkS2V5KHQpLGk9bmV3IE8oZSxuKTtpZighZS5pdGVtTmFtZSl0aHJvdyBuZXcgRXJyb3IoXCJpdGVtLml0ZW1OYW1lIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiKTt0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChlLml0ZW1OYW1lLGkpLHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuc2V0KGUuZnVsbE5hbWUsaSl9fX1nZXQgbGlzdHMoKXtsZXQgdD1bXTtmb3IobGV0WyxlXW9mIHRoaXMuX2xpc3RzKXQucHVzaChlKTtyZXR1cm4gdH1UcnlMaXN0R2V0RGVmaW5pdGlvbih0LGUpe2lmKG51bGw9PT10KXJldHVybntyZXN1bHQ6ZSxleGlzdHM6ITF9O2xldCBuPXRoaXMuX2xpc3RzLmdldCh0KTtyZXR1cm4gbj97cmVzdWx0Om4sZXhpc3RzOiEwfTp7cmVzdWx0OmUsZXhpc3RzOiExfX1GaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZSh0KXtpZihudWxsPT09dClyZXR1cm4gZChcIm5hbWVcIik7bGV0IGU9dGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5nZXQodCk7cmV0dXJuIHZvaWQgMCE9PWU/ZTpudWxsfX1jbGFzcyBNe3N0YXRpYyBKQXJyYXlUb1J1bnRpbWVPYmpMaXN0KHQsZT0hMSl7bGV0IG49dC5sZW5ndGg7ZSYmbi0tO2xldCBpPVtdO2ZvcihsZXQgZT0wO2U8bjtlKyspe2xldCBuPXRbZV0scj10aGlzLkpUb2tlblRvUnVudGltZU9iamVjdChuKTtpZihudWxsPT09cilyZXR1cm4gZChcInJ1bnRpbWVPYmpcIik7aS5wdXNoKHIpfXJldHVybiBpfXN0YXRpYyBXcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh0LGUpe3QuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXRbbixpXW9mIGUpdC5Xcml0ZVByb3BlcnR5U3RhcnQobiksdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3QodCxpKSx0LldyaXRlUHJvcGVydHlFbmQoKTt0LldyaXRlT2JqZWN0RW5kKCl9c3RhdGljIFdyaXRlTGlzdFJ1bnRpbWVPYmpzKHQsZSl7dC5Xcml0ZUFycmF5U3RhcnQoKTtmb3IobGV0IG4gb2YgZSl0aGlzLldyaXRlUnVudGltZU9iamVjdCh0LG4pO3QuV3JpdGVBcnJheUVuZCgpfXN0YXRpYyBXcml0ZUludERpY3Rpb25hcnkodCxlKXt0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0W24saV1vZiBlKXQuV3JpdGVJbnRQcm9wZXJ0eShuLGkpO3QuV3JpdGVPYmplY3RFbmQoKX1zdGF0aWMgV3JpdGVSdW50aW1lT2JqZWN0KHQsZSl7bGV0IG49YShlLE4pO2lmKG4pcmV0dXJuIHZvaWQgdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIodCxuKTtsZXQgaT1hKGUsayk7aWYoaSl7bGV0IGUsbj1cIi0+XCI7cmV0dXJuIGkuaXNFeHRlcm5hbD9uPVwieCgpXCI6aS5wdXNoZXNUb1N0YWNrJiYoaS5zdGFja1B1c2hUeXBlPT1yLkZ1bmN0aW9uP249XCJmKClcIjppLnN0YWNrUHVzaFR5cGU9PXIuVHVubmVsJiYobj1cIi0+dC0+XCIpKSxlPWkuaGFzVmFyaWFibGVUYXJnZXQ/aS52YXJpYWJsZURpdmVydE5hbWU6aS50YXJnZXRQYXRoU3RyaW5nLHQuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eShuLGUpLGkuaGFzVmFyaWFibGVUYXJnZXQmJnQuV3JpdGVQcm9wZXJ0eShcInZhclwiLCEwKSxpLmlzQ29uZGl0aW9uYWwmJnQuV3JpdGVQcm9wZXJ0eShcImNcIiwhMCksaS5leHRlcm5hbEFyZ3M+MCYmdC5Xcml0ZUludFByb3BlcnR5KFwiZXhBcmdzXCIsaS5leHRlcm5hbEFyZ3MpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpfWxldCBzPWEoZSxXKTtpZihzKXJldHVybiB0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHkoXCIqXCIscy5wYXRoU3RyaW5nT25DaG9pY2UpLHQuV3JpdGVJbnRQcm9wZXJ0eShcImZsZ1wiLHMuZmxhZ3MpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpO2xldCBsPWEoZSxiKTtpZihsKXJldHVybiB2b2lkIHQuV3JpdGVJbnQobC52YWx1ZSk7bGV0IG89YShlLF8pO2lmKG8pcmV0dXJuIHZvaWQgdC5Xcml0ZUZsb2F0KG8udmFsdWUpO2xldCB1PWEoZSxUKTtpZih1KXJldHVybiB2b2lkKHUuaXNOZXdsaW5lP3QuV3JpdGUoXCJcXG5cIiwhMSk6KHQuV3JpdGVTdHJpbmdTdGFydCgpLHQuV3JpdGVTdHJpbmdJbm5lcihcIl5cIiksdC5Xcml0ZVN0cmluZ0lubmVyKHUudmFsdWUpLHQuV3JpdGVTdHJpbmdFbmQoKSkpO2xldCBoPWEoZSxPKTtpZihoKXJldHVybiB2b2lkIHRoaXMuV3JpdGVJbmtMaXN0KHQsaCk7bGV0IGM9YShlLFApO2lmKGMpcmV0dXJuIHQuV3JpdGVPYmplY3RTdGFydCgpLG51bGw9PT1jLnZhbHVlP2QoXCJkaXZUYXJnZXRWYWwudmFsdWVcIik6KHQuV3JpdGVQcm9wZXJ0eShcIl4tPlwiLGMudmFsdWUuY29tcG9uZW50c1N0cmluZyksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCkpO2xldCBwPWEoZSx3KTtpZihwKXJldHVybiB0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHkoXCJedmFyXCIscC52YWx1ZSksdC5Xcml0ZUludFByb3BlcnR5KFwiY2lcIixwLmNvbnRleHRJbmRleCksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCk7aWYoYShlLHgpKXJldHVybiB2b2lkIHQuV3JpdGUoXCI8PlwiKTtsZXQgbT1hKGUsQSk7aWYobSlyZXR1cm4gdm9pZCB0LldyaXRlKE0uX2NvbnRyb2xDb21tYW5kTmFtZXNbbS5jb21tYW5kVHlwZV0pO2xldCBmPWEoZSxSKTtpZihmKXtsZXQgZT1mLm5hbWU7cmV0dXJuXCJeXCI9PWUmJihlPVwiTF5cIiksdm9pZCB0LldyaXRlKGUpfWxldCBnPWEoZSxGKTtpZihnKXt0LldyaXRlT2JqZWN0U3RhcnQoKTtsZXQgZT1nLnBhdGhTdHJpbmdGb3JDb3VudDtyZXR1cm4gbnVsbCE9ZT90LldyaXRlUHJvcGVydHkoXCJDTlQ/XCIsZSk6dC5Xcml0ZVByb3BlcnR5KFwiVkFSP1wiLGcubmFtZSksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCl9bGV0IFM9YShlLFYpO2lmKFMpe3QuV3JpdGVPYmplY3RTdGFydCgpO2xldCBlPVMuaXNHbG9iYWw/XCJWQVI9XCI6XCJ0ZW1wPVwiO3JldHVybiB0LldyaXRlUHJvcGVydHkoZSxTLnZhcmlhYmxlTmFtZSksUy5pc05ld0RlY2xhcmF0aW9ufHx0LldyaXRlUHJvcGVydHkoXCJyZVwiLCEwKSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKX1pZihhKGUsTCkpcmV0dXJuIHZvaWQgdC5Xcml0ZShcInZvaWRcIik7bGV0IHk9YShlLGopO2lmKHkpcmV0dXJuIHQuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eShcIiNcIix5LnRleHQpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpO2xldCBDPWEoZSxEKTtpZighQyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCBydW50aW1lIG9iamVjdCB0byBKc29uIHRva2VuOiBcIitlKTt0aGlzLldyaXRlQ2hvaWNlKHQsQyl9c3RhdGljIEpPYmplY3RUb0RpY3Rpb25hcnlSdW50aW1lT2Jqcyh0KXtsZXQgZT1uZXcgTWFwO2ZvcihsZXQgbiBpbiB0KWlmKHQuaGFzT3duUHJvcGVydHkobikpe2xldCBpPXRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KHRbbl0pO2lmKG51bGw9PT1pKXJldHVybiBkKFwiaW5rT2JqZWN0XCIpO2Uuc2V0KG4saSl9cmV0dXJuIGV9c3RhdGljIEpPYmplY3RUb0ludERpY3Rpb25hcnkodCl7bGV0IGU9bmV3IE1hcDtmb3IobGV0IG4gaW4gdCl0Lmhhc093blByb3BlcnR5KG4pJiZlLnNldChuLHBhcnNlSW50KHRbbl0pKTtyZXR1cm4gZX1zdGF0aWMgSlRva2VuVG9SdW50aW1lT2JqZWN0KHQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0JiYhaXNOYU4odCkpcmV0dXJuIHYuQ3JlYXRlKHQpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0KXtsZXQgZT10LnRvU3RyaW5nKCksbj1lWzBdO2lmKFwiXlwiPT1uKXJldHVybiBuZXcgVChlLnN1YnN0cmluZygxKSk7aWYoXCJcXG5cIj09biYmMT09ZS5sZW5ndGgpcmV0dXJuIG5ldyBUKFwiXFxuXCIpO2lmKFwiPD5cIj09ZSlyZXR1cm4gbmV3IHg7Zm9yKGxldCB0PTA7dDxNLl9jb250cm9sQ29tbWFuZE5hbWVzLmxlbmd0aDsrK3Qpe2lmKGU9PU0uX2NvbnRyb2xDb21tYW5kTmFtZXNbdF0pcmV0dXJuIG5ldyBBKHQpfWlmKFwiTF5cIj09ZSYmKGU9XCJeXCIpLFIuQ2FsbEV4aXN0c1dpdGhOYW1lKGUpKXJldHVybiBSLkNhbGxXaXRoTmFtZShlKTtpZihcIi0+LT5cIj09ZSlyZXR1cm4gQS5Qb3BUdW5uZWwoKTtpZihcIn5yZXRcIj09ZSlyZXR1cm4gQS5Qb3BGdW5jdGlvbigpO2lmKFwidm9pZFwiPT1lKXJldHVybiBuZXcgTH1pZihcIm9iamVjdFwiPT10eXBlb2YgdCYmIUFycmF5LmlzQXJyYXkodCkpe2xldCBuLGk9dDtpZihpW1wiXi0+XCJdKXJldHVybiBuPWlbXCJeLT5cIl0sbmV3IFAobmV3IGUobi50b1N0cmluZygpKSk7aWYoaVtcIl52YXJcIl0pe249aVtcIl52YXJcIl07bGV0IHQ9bmV3IHcobi50b1N0cmluZygpKTtyZXR1cm5cImNpXCJpbiBpJiYobj1pLmNpLHQuY29udGV4dEluZGV4PXBhcnNlSW50KG4pKSx0fWxldCBhPSExLHM9ITEsbD1yLkZ1bmN0aW9uLG89ITE7aWYoKG49aVtcIi0+XCJdKT9hPSEwOihuPWlbXCJmKClcIl0pPyhhPSEwLHM9ITAsbD1yLkZ1bmN0aW9uKToobj1pW1wiLT50LT5cIl0pPyhhPSEwLHM9ITAsbD1yLlR1bm5lbCk6KG49aVtcIngoKVwiXSkmJihhPSEwLG89ITAscz0hMSxsPXIuRnVuY3Rpb24pLGEpe2xldCB0PW5ldyBrO3QucHVzaGVzVG9TdGFjaz1zLHQuc3RhY2tQdXNoVHlwZT1sLHQuaXNFeHRlcm5hbD1vO2xldCBlPW4udG9TdHJpbmcoKTtyZXR1cm4obj1pLnZhcik/dC52YXJpYWJsZURpdmVydE5hbWU9ZTp0LnRhcmdldFBhdGhTdHJpbmc9ZSx0LmlzQ29uZGl0aW9uYWw9ISFpLmMsbyYmKG49aS5leEFyZ3MpJiYodC5leHRlcm5hbEFyZ3M9cGFyc2VJbnQobikpLHR9aWYobj1pW1wiKlwiXSl7bGV0IHQ9bmV3IFc7cmV0dXJuIHQucGF0aFN0cmluZ09uQ2hvaWNlPW4udG9TdHJpbmcoKSwobj1pLmZsZykmJih0LmZsYWdzPXBhcnNlSW50KG4pKSx0fWlmKG49aVtcIlZBUj9cIl0pcmV0dXJuIG5ldyBGKG4udG9TdHJpbmcoKSk7aWYobj1pW1wiQ05UP1wiXSl7bGV0IHQ9bmV3IEY7cmV0dXJuIHQucGF0aFN0cmluZ0ZvckNvdW50PW4udG9TdHJpbmcoKSx0fWxldCB1PSExLGg9ITE7aWYoKG49aVtcIlZBUj1cIl0pPyh1PSEwLGg9ITApOihuPWlbXCJ0ZW1wPVwiXSkmJih1PSEwLGg9ITEpLHUpe2xldCB0PW4udG9TdHJpbmcoKSxlPSFpLnJlLHI9bmV3IFYodCxlKTtyZXR1cm4gci5pc0dsb2JhbD1oLHJ9aWYodm9pZCAwIT09aVtcIiNcIl0pcmV0dXJuIG49aVtcIiNcIl0sbmV3IGoobi50b1N0cmluZygpKTtpZihuPWkubGlzdCl7bGV0IHQ9bixlPW5ldyBnO2lmKG49aS5vcmlnaW5zKXtsZXQgdD1uO2UuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKHQpfWZvcihsZXQgbiBpbiB0KWlmKHQuaGFzT3duUHJvcGVydHkobikpe2xldCBpPXRbbl0scj1uZXcgZihuKSxhPXBhcnNlSW50KGkpO2UuQWRkKHIsYSl9cmV0dXJuIG5ldyBPKGUpfWlmKG51bGwhPWkub3JpZ2luYWxDaG9pY2VQYXRoKXJldHVybiB0aGlzLkpPYmplY3RUb0Nob2ljZShpKX1pZihBcnJheS5pc0FycmF5KHQpKXJldHVybiB0aGlzLkpBcnJheVRvQ29udGFpbmVyKHQpO2lmKG51bGw9PXQpcmV0dXJuIG51bGw7dGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgdG9rZW4gdG8gcnVudGltZSBvYmplY3Q6IFwiK0pTT04uc3RyaW5naWZ5KHQpKX1zdGF0aWMgV3JpdGVSdW50aW1lQ29udGFpbmVyKHQsZSxuPSExKXtpZih0LldyaXRlQXJyYXlTdGFydCgpLG51bGw9PT1lKXJldHVybiBkKFwiY29udGFpbmVyXCIpO2ZvcihsZXQgbiBvZiBlLmNvbnRlbnQpdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3QodCxuKTtsZXQgaT1lLm5hbWVkT25seUNvbnRlbnQscj1lLmNvdW50RmxhZ3Mscz1udWxsIT1lLm5hbWUmJiFuLGw9bnVsbCE9aXx8cj4wfHxzO2lmKGwmJnQuV3JpdGVPYmplY3RTdGFydCgpLG51bGwhPWkpZm9yKGxldFtlLG5db2YgaSl7bGV0IGk9ZSxyPWEobixOKTt0LldyaXRlUHJvcGVydHlTdGFydChpKSx0aGlzLldyaXRlUnVudGltZUNvbnRhaW5lcih0LHIsITApLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfXMmJnQuV3JpdGVQcm9wZXJ0eShcIiNuXCIsZS5uYW1lKSxsP3QuV3JpdGVPYmplY3RFbmQoKTp0LldyaXRlTnVsbCgpLHQuV3JpdGVBcnJheUVuZCgpfXN0YXRpYyBKQXJyYXlUb0NvbnRhaW5lcih0KXtsZXQgZT1uZXcgTjtlLmNvbnRlbnQ9dGhpcy5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KHQsITApO2xldCBuPXRbdC5sZW5ndGgtMV07aWYobnVsbCE9bil7bGV0IHQ9bmV3IE1hcDtmb3IobGV0IGkgaW4gbilpZihcIiNmXCI9PWkpZS5jb3VudEZsYWdzPXBhcnNlSW50KG5baV0pO2Vsc2UgaWYoXCIjblwiPT1pKWUubmFtZT1uW2ldLnRvU3RyaW5nKCk7ZWxzZXtsZXQgZT10aGlzLkpUb2tlblRvUnVudGltZU9iamVjdChuW2ldKSxyPWEoZSxOKTtyJiYoci5uYW1lPWkpLHQuc2V0KGksZSl9ZS5uYW1lZE9ubHlDb250ZW50PXR9cmV0dXJuIGV9c3RhdGljIEpPYmplY3RUb0Nob2ljZSh0KXtsZXQgZT1uZXcgRDtyZXR1cm4gZS50ZXh0PXQudGV4dC50b1N0cmluZygpLGUuaW5kZXg9cGFyc2VJbnQodC5pbmRleCksZS5zb3VyY2VQYXRoPXQub3JpZ2luYWxDaG9pY2VQYXRoLnRvU3RyaW5nKCksZS5vcmlnaW5hbFRocmVhZEluZGV4PXBhcnNlSW50KHQub3JpZ2luYWxUaHJlYWRJbmRleCksZS5wYXRoU3RyaW5nT25DaG9pY2U9dC50YXJnZXRQYXRoLnRvU3RyaW5nKCksZX1zdGF0aWMgV3JpdGVDaG9pY2UodCxlKXt0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHkoXCJ0ZXh0XCIsZS50ZXh0KSx0LldyaXRlSW50UHJvcGVydHkoXCJpbmRleFwiLGUuaW5kZXgpLHQuV3JpdGVQcm9wZXJ0eShcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiLGUuc291cmNlUGF0aCksdC5Xcml0ZUludFByb3BlcnR5KFwib3JpZ2luYWxUaHJlYWRJbmRleFwiLGUub3JpZ2luYWxUaHJlYWRJbmRleCksdC5Xcml0ZVByb3BlcnR5KFwidGFyZ2V0UGF0aFwiLGUucGF0aFN0cmluZ09uQ2hvaWNlKSx0LldyaXRlT2JqZWN0RW5kKCl9c3RhdGljIFdyaXRlSW5rTGlzdCh0LGUpe2xldCBuPWUudmFsdWU7aWYobnVsbD09PW4pcmV0dXJuIGQoXCJyYXdMaXN0XCIpO3QuV3JpdGVPYmplY3RTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdFwiKSx0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0W2UsaV1vZiBuKXtsZXQgbj1mLmZyb21TZXJpYWxpemVkS2V5KGUpLHI9aTtpZihudWxsPT09bi5pdGVtTmFtZSlyZXR1cm4gZChcIml0ZW0uaXRlbU5hbWVcIik7dC5Xcml0ZVByb3BlcnR5TmFtZVN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKG4ub3JpZ2luTmFtZT9uLm9yaWdpbk5hbWU6XCI/XCIpLHQuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihcIi5cIiksdC5Xcml0ZVByb3BlcnR5TmFtZUlubmVyKG4uaXRlbU5hbWUpLHQuV3JpdGVQcm9wZXJ0eU5hbWVFbmQoKSx0LldyaXRlKHIpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfWlmKHQuV3JpdGVPYmplY3RFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKSwwPT1uLkNvdW50JiZudWxsIT1uLm9yaWdpbk5hbWVzJiZuLm9yaWdpbk5hbWVzLmxlbmd0aD4wKXt0LldyaXRlUHJvcGVydHlTdGFydChcIm9yaWdpbnNcIiksdC5Xcml0ZUFycmF5U3RhcnQoKTtmb3IobGV0IGUgb2Ygbi5vcmlnaW5OYW1lcyl0LldyaXRlKGUpO3QuV3JpdGVBcnJheUVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfXQuV3JpdGVPYmplY3RFbmQoKX1zdGF0aWMgTGlzdERlZmluaXRpb25zVG9KVG9rZW4odCl7bGV0IGU9e307Zm9yKGxldCBuIG9mIHQubGlzdHMpe2xldCB0PXt9O2ZvcihsZXRbZSxpXW9mIG4uaXRlbXMpe2xldCBuPWYuZnJvbVNlcmlhbGl6ZWRLZXkoZSk7aWYobnVsbD09PW4uaXRlbU5hbWUpcmV0dXJuIGQoXCJpdGVtLml0ZW1OYW1lXCIpO3Rbbi5pdGVtTmFtZV09aX1lW24ubmFtZV09dH1yZXR1cm4gZX1zdGF0aWMgSlRva2VuVG9MaXN0RGVmaW5pdGlvbnModCl7bGV0IGU9dCxuPVtdO2ZvcihsZXQgdCBpbiBlKWlmKGUuaGFzT3duUHJvcGVydHkodCkpe2xldCBpPXQudG9TdHJpbmcoKSxyPWVbdF0sYT1uZXcgTWFwO2ZvcihsZXQgbiBpbiByKWlmKGUuaGFzT3duUHJvcGVydHkodCkpe2xldCB0PXJbbl07YS5zZXQobixwYXJzZUludCh0KSl9bGV0IHM9bmV3IEcoaSxhKTtuLnB1c2gocyl9cmV0dXJuIG5ldyBCKG4pfX1NLl9jb250cm9sQ29tbWFuZE5hbWVzPSgoKT0+e2xldCB0PVtdO3RbQS5Db21tYW5kVHlwZS5FdmFsU3RhcnRdPVwiZXZcIix0W0EuQ29tbWFuZFR5cGUuRXZhbE91dHB1dF09XCJvdXRcIix0W0EuQ29tbWFuZFR5cGUuRXZhbEVuZF09XCIvZXZcIix0W0EuQ29tbWFuZFR5cGUuRHVwbGljYXRlXT1cImR1XCIsdFtBLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlXT1cInBvcFwiLHRbQS5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbl09XCJ+cmV0XCIsdFtBLkNvbW1hbmRUeXBlLlBvcFR1bm5lbF09XCItPi0+XCIsdFtBLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nXT1cInN0clwiLHRbQS5Db21tYW5kVHlwZS5FbmRTdHJpbmddPVwiL3N0clwiLHRbQS5Db21tYW5kVHlwZS5Ob09wXT1cIm5vcFwiLHRbQS5Db21tYW5kVHlwZS5DaG9pY2VDb3VudF09XCJjaG9pY2VDbnRcIix0W0EuQ29tbWFuZFR5cGUuVHVybnNdPVwidHVyblwiLHRbQS5Db21tYW5kVHlwZS5UdXJuc1NpbmNlXT1cInR1cm5zXCIsdFtBLkNvbW1hbmRUeXBlLlJlYWRDb3VudF09XCJyZWFkY1wiLHRbQS5Db21tYW5kVHlwZS5SYW5kb21dPVwicm5kXCIsdFtBLkNvbW1hbmRUeXBlLlNlZWRSYW5kb21dPVwic3JuZFwiLHRbQS5Db21tYW5kVHlwZS5WaXNpdEluZGV4XT1cInZpc2l0XCIsdFtBLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4XT1cInNlcVwiLHRbQS5Db21tYW5kVHlwZS5TdGFydFRocmVhZF09XCJ0aHJlYWRcIix0W0EuQ29tbWFuZFR5cGUuRG9uZV09XCJkb25lXCIsdFtBLkNvbW1hbmRUeXBlLkVuZF09XCJlbmRcIix0W0EuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnRdPVwibGlzdEludFwiLHRbQS5Db21tYW5kVHlwZS5MaXN0UmFuZ2VdPVwicmFuZ2VcIix0W0EuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbV09XCJscm5kXCI7Zm9yKGxldCBlPTA7ZTxBLkNvbW1hbmRUeXBlLlRPVEFMX1ZBTFVFUzsrK2UpaWYobnVsbD09dFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJDb250cm9sIGNvbW1hbmQgbm90IGFjY291bnRlZCBmb3IgaW4gc2VyaWFsaXNhdGlvblwiKTtyZXR1cm4gdH0pKCk7Y2xhc3MgcXtjb25zdHJ1Y3Rvcigpe2lmKHRoaXMuX3RocmVhZENvdW50ZXI9MCx0aGlzLl9zdGFydE9mUm9vdD1JLk51bGwsYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBYKXtsZXQgdD1hcmd1bWVudHNbMF07dGhpcy5fc3RhcnRPZlJvb3Q9SS5TdGFydE9mKHQucm9vdENvbnRlbnRDb250YWluZXIpLHRoaXMuUmVzZXQoKX1lbHNle2xldCB0PWFyZ3VtZW50c1swXTt0aGlzLl90aHJlYWRzPVtdO2ZvcihsZXQgZSBvZiB0Ll90aHJlYWRzKXRoaXMuX3RocmVhZHMucHVzaChlLkNvcHkoKSk7dGhpcy5fdGhyZWFkQ291bnRlcj10Ll90aHJlYWRDb3VudGVyLHRoaXMuX3N0YXJ0T2ZSb290PXQuX3N0YXJ0T2ZSb290fX1nZXQgZWxlbWVudHMoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2t9Z2V0IGRlcHRoKCl7cmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RofWdldCBjdXJyZW50RWxlbWVudCgpe2xldCB0PXRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGgtMV0uY2FsbHN0YWNrO3JldHVybiB0W3QubGVuZ3RoLTFdfWdldCBjdXJyZW50RWxlbWVudEluZGV4KCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmxlbmd0aC0xfWdldCBjdXJyZW50VGhyZWFkKCl7cmV0dXJuIHRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGgtMV19c2V0IGN1cnJlbnRUaHJlYWQodCl7bi5Bc3NlcnQoMT09dGhpcy5fdGhyZWFkcy5sZW5ndGgsXCJTaG91bGRuJ3QgYmUgZGlyZWN0bHkgc2V0dGluZyB0aGUgY3VycmVudCB0aHJlYWQgd2hlbiB3ZSBoYXZlIGEgc3RhY2sgb2YgdGhlbVwiKSx0aGlzLl90aHJlYWRzLmxlbmd0aD0wLHRoaXMuX3RocmVhZHMucHVzaCh0KX1nZXQgY2FuUG9wKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmxlbmd0aD4xfVJlc2V0KCl7dGhpcy5fdGhyZWFkcz1bXSx0aGlzLl90aHJlYWRzLnB1c2gobmV3IHEuVGhyZWFkKSx0aGlzLl90aHJlYWRzWzBdLmNhbGxzdGFjay5wdXNoKG5ldyBxLkVsZW1lbnQoci5UdW5uZWwsdGhpcy5fc3RhcnRPZlJvb3QpKX1TZXRKc29uVG9rZW4odCxlKXt0aGlzLl90aHJlYWRzLmxlbmd0aD0wO2xldCBuPXQudGhyZWFkcztmb3IobGV0IHQgb2Ygbil7bGV0IG49dCxpPW5ldyBxLlRocmVhZChuLGUpO3RoaXMuX3RocmVhZHMucHVzaChpKX10aGlzLl90aHJlYWRDb3VudGVyPXBhcnNlSW50KHQudGhyZWFkQ291bnRlciksdGhpcy5fc3RhcnRPZlJvb3Q9SS5TdGFydE9mKGUucm9vdENvbnRlbnRDb250YWluZXIpfVdyaXRlSnNvbih0KXt0LldyaXRlT2JqZWN0KHQ9Pnt0LldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZHNcIiksdC5Xcml0ZUFycmF5U3RhcnQoKTtmb3IobGV0IGUgb2YgdGhpcy5fdGhyZWFkcyllLldyaXRlSnNvbih0KTt0LldyaXRlQXJyYXlFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKSx0LldyaXRlUHJvcGVydHlTdGFydChcInRocmVhZENvdW50ZXJcIiksdC5Xcml0ZUludCh0aGlzLl90aHJlYWRDb3VudGVyKSx0LldyaXRlUHJvcGVydHlFbmQoKX0pfVB1c2hUaHJlYWQoKXtsZXQgdD10aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO3RoaXMuX3RocmVhZENvdW50ZXIrKyx0LnRocmVhZEluZGV4PXRoaXMuX3RocmVhZENvdW50ZXIsdGhpcy5fdGhyZWFkcy5wdXNoKHQpfUZvcmtUaHJlYWQoKXtsZXQgdD10aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO3JldHVybiB0aGlzLl90aHJlYWRDb3VudGVyKyssdC50aHJlYWRJbmRleD10aGlzLl90aHJlYWRDb3VudGVyLHR9UG9wVGhyZWFkKCl7aWYoIXRoaXMuY2FuUG9wVGhyZWFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBvcCB0aHJlYWRcIik7dGhpcy5fdGhyZWFkcy5zcGxpY2UodGhpcy5fdGhyZWFkcy5pbmRleE9mKHRoaXMuY3VycmVudFRocmVhZCksMSl9Z2V0IGNhblBvcFRocmVhZCgpe3JldHVybiB0aGlzLl90aHJlYWRzLmxlbmd0aD4xJiYhdGhpcy5lbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lfWdldCBlbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lKCl7cmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnQudHlwZT09ci5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZX1QdXNoKHQsZT0wLG49MCl7bGV0IGk9bmV3IHEuRWxlbWVudCh0LHRoaXMuY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIsITEpO2kuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZD1lLGkuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtPW4sdGhpcy5jYWxsU3RhY2sucHVzaChpKX1DYW5Qb3AodD1udWxsKXtyZXR1cm4hIXRoaXMuY2FuUG9wJiYobnVsbD09dHx8dGhpcy5jdXJyZW50RWxlbWVudC50eXBlPT10KX1Qb3AodD1udWxsKXtpZighdGhpcy5DYW5Qb3AodCkpdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwdXNoL3BvcCBpbiBDYWxsc3RhY2tcIik7dGhpcy5jYWxsU3RhY2sucG9wKCl9R2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZSh0LGU9LTEpey0xPT1lJiYoZT10aGlzLmN1cnJlbnRFbGVtZW50SW5kZXgrMSk7bGV0IG49eSh0aGlzLmNhbGxTdGFja1tlLTFdLnRlbXBvcmFyeVZhcmlhYmxlcyx0LG51bGwpO3JldHVybiBuLmV4aXN0cz9uLnJlc3VsdDpudWxsfVNldFRlbXBvcmFyeVZhcmlhYmxlKHQsZSxuLGk9LTEpey0xPT1pJiYoaT10aGlzLmN1cnJlbnRFbGVtZW50SW5kZXgrMSk7bGV0IHI9dGhpcy5jYWxsU3RhY2tbaS0xXTtpZighbiYmIXIudGVtcG9yYXJ5VmFyaWFibGVzLmdldCh0KSl0aHJvdyBuZXcgUyhcIkNvdWxkIG5vdCBmaW5kIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBzZXQ6IFwiK3QpO2xldCBhPXkoci50ZW1wb3JhcnlWYXJpYWJsZXMsdCxudWxsKTthLmV4aXN0cyYmTy5SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQoYS5yZXN1bHQsZSksci50ZW1wb3JhcnlWYXJpYWJsZXMuc2V0KHQsZSl9Q29udGV4dEZvclZhcmlhYmxlTmFtZWQodCl7cmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLmdldCh0KT90aGlzLmN1cnJlbnRFbGVtZW50SW5kZXgrMTowfVRocmVhZFdpdGhJbmRleCh0KXtsZXQgZT10aGlzLl90aHJlYWRzLmZpbHRlcihlPT57aWYoZS50aHJlYWRJbmRleD09dClyZXR1cm4gZX0pO3JldHVybiBlLmxlbmd0aD4wP2VbMF06bnVsbH1nZXQgY2FsbFN0YWNrKCl7cmV0dXJuIHRoaXMuY3VycmVudFRocmVhZC5jYWxsc3RhY2t9Z2V0IGNhbGxTdGFja1RyYWNlKCl7bGV0IHQ9bmV3IG07Zm9yKGxldCBlPTA7ZTx0aGlzLl90aHJlYWRzLmxlbmd0aDtlKyspe2xldCBuPXRoaXMuX3RocmVhZHNbZV0saT1lPT10aGlzLl90aHJlYWRzLmxlbmd0aC0xO3QuQXBwZW5kRm9ybWF0KFwiPT09IFRIUkVBRCB7MH0vezF9IHsyfT09PVxcblwiLGUrMSx0aGlzLl90aHJlYWRzLmxlbmd0aCxpP1wiKGN1cnJlbnQpIFwiOlwiXCIpO2ZvcihsZXQgZT0wO2U8bi5jYWxsc3RhY2subGVuZ3RoO2UrKyl7bi5jYWxsc3RhY2tbZV0udHlwZT09ci5GdW5jdGlvbj90LkFwcGVuZChcIiAgW0ZVTkNUSU9OXSBcIik6dC5BcHBlbmQoXCIgIFtUVU5ORUxdIFwiKTtsZXQgaT1uLmNhbGxzdGFja1tlXS5jdXJyZW50UG9pbnRlcjtpZighaS5pc051bGwpe2lmKHQuQXBwZW5kKFwiPFNPTUVXSEVSRSBJTiBcIiksbnVsbD09PWkuY29udGFpbmVyKXJldHVybiBkKFwicG9pbnRlci5jb250YWluZXJcIik7dC5BcHBlbmQoaS5jb250YWluZXIucGF0aC50b1N0cmluZygpKSx0LkFwcGVuZExpbmUoXCI+XCIpfX19cmV0dXJuIHQudG9TdHJpbmcoKX19IWZ1bmN0aW9uKHQpe2NsYXNzIG57Y29uc3RydWN0b3IodCxlLG49ITEpe3RoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZD0wLHRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtPTAsdGhpcy5jdXJyZW50UG9pbnRlcj1lLmNvcHkoKSx0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb249bix0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcz1uZXcgTWFwLHRoaXMudHlwZT10fUNvcHkoKXtsZXQgdD1uZXcgbih0aGlzLnR5cGUsdGhpcy5jdXJyZW50UG9pbnRlcix0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pO3JldHVybiB0LnRlbXBvcmFyeVZhcmlhYmxlcz1uZXcgTWFwKHRoaXMudGVtcG9yYXJ5VmFyaWFibGVzKSx0LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ9dGhpcy5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkLHQuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtPXRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtLHR9fXQuRWxlbWVudD1uO2NsYXNzIGl7Y29uc3RydWN0b3IoKXtpZih0aGlzLnRocmVhZEluZGV4PTAsdGhpcy5wcmV2aW91c1BvaW50ZXI9SS5OdWxsLHRoaXMuY2FsbHN0YWNrPVtdLGFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzFdKXtsZXQgdD1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy50aHJlYWRJbmRleD1wYXJzZUludCh0LnRocmVhZEluZGV4KTtsZXQgcj10LmNhbGxzdGFjaztmb3IobGV0IHQgb2Ygcil7bGV0IHIsYT10LHM9cGFyc2VJbnQoYS50eXBlKSxsPUkuTnVsbCxvPWEuY1BhdGg7aWYodm9pZCAwIT09byl7cj1vLnRvU3RyaW5nKCk7bGV0IHQ9aS5Db250ZW50QXRQYXRoKG5ldyBlKHIpKTtpZihsLmNvbnRhaW5lcj10LmNvbnRhaW5lcixsLmluZGV4PXBhcnNlSW50KGEuaWR4KSxudWxsPT10Lm9iail0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiBcIityK1wiLiBIYXMgdGhlIHN0b3J5IGNoYW5nZWQgc2luY2UgdGhpcyBzYXZlIGRhdGEgd2FzIGNyZWF0ZWQ/XCIpO2lmKHQuYXBwcm94aW1hdGUpe2lmKG51bGw9PT1sLmNvbnRhaW5lcilyZXR1cm4gZChcInBvaW50ZXIuY29udGFpbmVyXCIpO2kuV2FybmluZyhcIldoZW4gbG9hZGluZyBzdGF0ZSwgZXhhY3QgaW50ZXJuYWwgc3RvcnkgbG9jYXRpb24gY291bGRuJ3QgYmUgZm91bmQ6ICdcIityK1wiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0byAnXCIrbC5jb250YWluZXIucGF0aC50b1N0cmluZygpK1wiJyB0byByZWNvdmVyLiBIYXMgdGhlIHN0b3J5IGNoYW5nZWQgc2luY2UgdGhpcyBzYXZlIGRhdGEgd2FzIGNyZWF0ZWQ/XCIpfX1sZXQgdT0hIWEuZXhwLGg9bmV3IG4ocyxsLHUpLGM9YS50ZW1wO3ZvaWQgMCE9PWM/aC50ZW1wb3JhcnlWYXJpYWJsZXM9TS5KT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianMoYyk6aC50ZW1wb3JhcnlWYXJpYWJsZXMuY2xlYXIoKSx0aGlzLmNhbGxzdGFjay5wdXNoKGgpfWxldCBhPXQucHJldmlvdXNDb250ZW50T2JqZWN0O2lmKHZvaWQgMCE9PWEpe2xldCB0PW5ldyBlKGEudG9TdHJpbmcoKSk7dGhpcy5wcmV2aW91c1BvaW50ZXI9aS5Qb2ludGVyQXRQYXRoKHQpfX19Q29weSgpe2xldCB0PW5ldyBpO3QudGhyZWFkSW5kZXg9dGhpcy50aHJlYWRJbmRleDtmb3IobGV0IGUgb2YgdGhpcy5jYWxsc3RhY2spdC5jYWxsc3RhY2sucHVzaChlLkNvcHkoKSk7cmV0dXJuIHQucHJldmlvdXNQb2ludGVyPXRoaXMucHJldmlvdXNQb2ludGVyLmNvcHkoKSx0fVdyaXRlSnNvbih0KXt0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHlTdGFydChcImNhbGxzdGFja1wiKSx0LldyaXRlQXJyYXlTdGFydCgpO2ZvcihsZXQgZSBvZiB0aGlzLmNhbGxzdGFjayl7aWYodC5Xcml0ZU9iamVjdFN0YXJ0KCksIWUuY3VycmVudFBvaW50ZXIuaXNOdWxsKXtpZihudWxsPT09ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXIpcmV0dXJuIGQoXCJlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXJcIik7dC5Xcml0ZVByb3BlcnR5KFwiY1BhdGhcIixlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpLHQuV3JpdGVJbnRQcm9wZXJ0eShcImlkeFwiLGUuY3VycmVudFBvaW50ZXIuaW5kZXgpfXQuV3JpdGVQcm9wZXJ0eShcImV4cFwiLGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiksdC5Xcml0ZUludFByb3BlcnR5KFwidHlwZVwiLGUudHlwZSksZS50ZW1wb3JhcnlWYXJpYWJsZXMuc2l6ZT4wJiYodC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0ZW1wXCIpLE0uV3JpdGVEaWN0aW9uYXJ5UnVudGltZU9ianModCxlLnRlbXBvcmFyeVZhcmlhYmxlcyksdC5Xcml0ZVByb3BlcnR5RW5kKCkpLHQuV3JpdGVPYmplY3RFbmQoKX1pZih0LldyaXRlQXJyYXlFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKSx0LldyaXRlSW50UHJvcGVydHkoXCJ0aHJlYWRJbmRleFwiLHRoaXMudGhyZWFkSW5kZXgpLCF0aGlzLnByZXZpb3VzUG9pbnRlci5pc051bGwpe2xldCBlPXRoaXMucHJldmlvdXNQb2ludGVyLlJlc29sdmUoKTtpZihudWxsPT09ZSlyZXR1cm4gZChcInRoaXMucHJldmlvdXNQb2ludGVyLlJlc29sdmUoKVwiKTt0LldyaXRlUHJvcGVydHkoXCJwcmV2aW91c0NvbnRlbnRPYmplY3RcIixlLnBhdGgudG9TdHJpbmcoKSl9dC5Xcml0ZU9iamVjdEVuZCgpfX10LlRocmVhZD1pfShxfHwocT17fSkpO2NsYXNzIEp7Y29uc3RydWN0b3IodCxlKXt0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzPVtdLHRoaXMucGF0Y2g9bnVsbCx0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcz0hMSx0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzPW5ldyBNYXAsdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzPW5ldyBTZXQsdGhpcy5fZ2xvYmFsVmFyaWFibGVzPW5ldyBNYXAsdGhpcy5fY2FsbFN0YWNrPXQsdGhpcy5fbGlzdERlZnNPcmlnaW49ZTt0cnl7cmV0dXJuIG5ldyBQcm94eSh0aGlzLHtnZXQ6KHQsZSk9PmUgaW4gdD90W2VdOnQuJChlKSxzZXQ6KHQsZSxuKT0+KGUgaW4gdD90W2VdPW46dC4kKGUsbiksITApfSl9Y2F0Y2godCl7fX12YXJpYWJsZUNoYW5nZWRFdmVudCh0LGUpe2ZvcihsZXQgbiBvZiB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzKW4odCxlKX1nZXQgYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMoKXtyZXR1cm4gdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXN9c2V0IGJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKHQpe2lmKHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzPXQsdCl0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnM9bmV3IFNldDtlbHNlIGlmKG51bGwhPXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyl7Zm9yKGxldCB0IG9mIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyl7bGV0IGU9dGhpcy5fZ2xvYmFsVmFyaWFibGVzLmdldCh0KTtlP3RoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQodCxlKTpkKFwiY3VycmVudFZhbHVlXCIpfXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icz1udWxsfX1nZXQgY2FsbFN0YWNrKCl7cmV0dXJuIHRoaXMuX2NhbGxTdGFja31zZXQgY2FsbFN0YWNrKHQpe3RoaXMuX2NhbGxTdGFjaz10fSQodCxlKXtpZih2b2lkIDA9PT1lKXtsZXQgZT1udWxsO3JldHVybiBudWxsIT09dGhpcy5wYXRjaCYmKGU9dGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodCxudWxsKSxlLmV4aXN0cyk/ZS5yZXN1bHQudmFsdWVPYmplY3Q6KGU9dGhpcy5fZ2xvYmFsVmFyaWFibGVzLmdldCh0KSx2b2lkIDA9PT1lJiYoZT10aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh0KSksdm9pZCAwIT09ZT9lLnZhbHVlT2JqZWN0Om51bGwpfXtpZih2b2lkIDA9PT10aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh0KSl0aHJvdyBuZXcgUyhcIkNhbm5vdCBhc3NpZ24gdG8gYSB2YXJpYWJsZSAoXCIrdCtcIikgdGhhdCBoYXNuJ3QgYmVlbiBkZWNsYXJlZCBpbiB0aGUgc3RvcnlcIik7bGV0IG49di5DcmVhdGUoZSk7aWYobnVsbD09bil0aHJvdyBuZXcgUyhudWxsPT1lP1wiQ2Fubm90IHBhc3MgbnVsbCB0byBWYXJpYWJsZVN0YXRlXCI6XCJJbnZhbGlkIHZhbHVlIHBhc3NlZCB0byBWYXJpYWJsZVN0YXRlOiBcIitlLnRvU3RyaW5nKCkpO3RoaXMuU2V0R2xvYmFsKHQsbil9fUFwcGx5UGF0Y2goKXtpZihudWxsPT09dGhpcy5wYXRjaClyZXR1cm4gZChcInRoaXMucGF0Y2hcIik7Zm9yKGxldFt0LGVdb2YgdGhpcy5wYXRjaC5nbG9iYWxzKXRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodCxlKTtpZihudWxsIT09dGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKWZvcihsZXQgdCBvZiB0aGlzLnBhdGNoLmNoYW5nZWRWYXJpYWJsZXMpdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzLmFkZCh0KTt0aGlzLnBhdGNoPW51bGx9U2V0SnNvblRva2VuKHQpe3RoaXMuX2dsb2JhbFZhcmlhYmxlcy5jbGVhcigpO2ZvcihsZXRbZSxuXW9mIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMpe2xldCBpPXRbZV07aWYodm9pZCAwIT09aSl7bGV0IHQ9TS5KVG9rZW5Ub1J1bnRpbWVPYmplY3QoaSk7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJ0b2tlbklua09iamVjdFwiKTt0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KGUsdCl9ZWxzZSB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KGUsbil9fVdyaXRlSnNvbih0KXt0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0W2Usbl1vZiB0aGlzLl9nbG9iYWxWYXJpYWJsZXMpe2xldCBpPWUscj1uO2lmKEouZG9udFNhdmVEZWZhdWx0VmFsdWVzJiZ0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyhpKSl7bGV0IHQ9dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQoaSk7aWYodGhpcy5SdW50aW1lT2JqZWN0c0VxdWFsKHIsdCkpY29udGludWV9dC5Xcml0ZVByb3BlcnR5U3RhcnQoaSksTS5Xcml0ZVJ1bnRpbWVPYmplY3QodCxyKSx0LldyaXRlUHJvcGVydHlFbmQoKX10LldyaXRlT2JqZWN0RW5kKCl9UnVudGltZU9iamVjdHNFcXVhbCh0LGUpe2lmKG51bGw9PT10KXJldHVybiBkKFwib2JqMVwiKTtpZihudWxsPT09ZSlyZXR1cm4gZChcIm9iajJcIik7aWYodC5jb25zdHJ1Y3RvciE9PWUuY29uc3RydWN0b3IpcmV0dXJuITE7bGV0IG49YSh0LGIpO2lmKG51bGwhPT1uKXJldHVybiBuLnZhbHVlPT09cyhlLGIpLnZhbHVlO2xldCBpPWEodCxfKTtpZihudWxsIT09aSlyZXR1cm4gaS52YWx1ZT09PXMoZSxfKS52YWx1ZTtsZXQgcj1hKHQsdiksbD1hKGUsdik7aWYobnVsbCE9PXImJm51bGwhPT1sKXJldHVybiB1KHIudmFsdWVPYmplY3QpJiZ1KGwudmFsdWVPYmplY3QpP3IudmFsdWVPYmplY3QuRXF1YWxzKGwudmFsdWVPYmplY3QpOnIudmFsdWVPYmplY3Q9PT1sLnZhbHVlT2JqZWN0O3Rocm93IG5ldyBFcnJvcihcIkZhc3RSb3VnaERlZmluaXRlbHlFcXVhbHM6IFVuc3VwcG9ydGVkIHJ1bnRpbWUgb2JqZWN0IHR5cGU6IFwiK3QuY29uc3RydWN0b3IubmFtZSl9R2V0VmFyaWFibGVXaXRoTmFtZSh0LGU9LTEpe2xldCBuPXRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZSh0LGUpLGk9YShuLHcpO3JldHVybiBudWxsIT09aSYmKG49dGhpcy5WYWx1ZUF0VmFyaWFibGVQb2ludGVyKGkpKSxufVRyeUdldERlZmF1bHRWYXJpYWJsZVZhbHVlKHQpe2xldCBlPXkodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyx0LG51bGwpO3JldHVybiBlLmV4aXN0cz9lLnJlc3VsdDpudWxsfUdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodCl7cmV0dXJuIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5oYXModCl8fG51bGwhPT10aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzJiZ0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyh0KX1HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKHQsZSl7bGV0IG49bnVsbDtpZigwPT1lfHwtMT09ZSl7bGV0IGU9bnVsbDtpZihudWxsIT09dGhpcy5wYXRjaCYmKGU9dGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodCxudWxsKSxlLmV4aXN0cykpcmV0dXJuIGUucmVzdWx0O2lmKGU9eSh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsdCxudWxsKSxlLmV4aXN0cylyZXR1cm4gZS5yZXN1bHQ7aWYobnVsbCE9PXRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMmJihlPXkodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyx0LG51bGwpLGUuZXhpc3RzKSlyZXR1cm4gZS5yZXN1bHQ7aWYobnVsbD09PXRoaXMuX2xpc3REZWZzT3JpZ2luKXJldHVybiBkKFwiVmFyaWFibGVzU3RhdGUuX2xpc3REZWZzT3JpZ2luXCIpO2xldCBuPXRoaXMuX2xpc3REZWZzT3JpZ2luLkZpbmRTaW5nbGVJdGVtTGlzdFdpdGhOYW1lKHQpO2lmKG4pcmV0dXJuIG59cmV0dXJuIG49dGhpcy5fY2FsbFN0YWNrLkdldFRlbXBvcmFyeVZhcmlhYmxlV2l0aE5hbWUodCxlKSxufVZhbHVlQXRWYXJpYWJsZVBvaW50ZXIodCl7cmV0dXJuIHRoaXMuR2V0VmFyaWFibGVXaXRoTmFtZSh0LnZhcmlhYmxlTmFtZSx0LmNvbnRleHRJbmRleCl9QXNzaWduKHQsZSl7bGV0IG49dC52YXJpYWJsZU5hbWU7aWYobnVsbD09PW4pcmV0dXJuIGQoXCJuYW1lXCIpO2xldCBpPS0xLHI9ITE7aWYocj10LmlzTmV3RGVjbGFyYXRpb24/dC5pc0dsb2JhbDp0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUobiksdC5pc05ld0RlY2xhcmF0aW9uKXtsZXQgdD1hKGUsdyk7aWYobnVsbCE9PXQpe2U9dGhpcy5SZXNvbHZlVmFyaWFibGVQb2ludGVyKHQpfX1lbHNle2xldCB0PW51bGw7ZG97dD1hKHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZShuLGkpLHcpLG51bGwhPXQmJihuPXQudmFyaWFibGVOYW1lLGk9dC5jb250ZXh0SW5kZXgscj0wPT1pKX13aGlsZShudWxsIT10KX1yP3RoaXMuU2V0R2xvYmFsKG4sZSk6dGhpcy5fY2FsbFN0YWNrLlNldFRlbXBvcmFyeVZhcmlhYmxlKG4sZSx0LmlzTmV3RGVjbGFyYXRpb24saSl9U25hcHNob3REZWZhdWx0R2xvYmFscygpe3RoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXM9bmV3IE1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMpfVJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudCh0LGUpe2xldCBuPXModCxPKSxpPXMoZSxPKTtuLnZhbHVlJiZpLnZhbHVlJiYwPT1pLnZhbHVlLkNvdW50JiZpLnZhbHVlLlNldEluaXRpYWxPcmlnaW5OYW1lcyhuLnZhbHVlLm9yaWdpbk5hbWVzKX1TZXRHbG9iYWwodCxlKXtsZXQgbj1udWxsO2lmKG51bGw9PT10aGlzLnBhdGNoJiYobj15KHRoaXMuX2dsb2JhbFZhcmlhYmxlcyx0LG51bGwpKSxudWxsIT09dGhpcy5wYXRjaCYmKG49dGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodCxudWxsKSxuLmV4aXN0c3x8KG49eSh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsdCxudWxsKSkpLE8uUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG4ucmVzdWx0LGUpLG51bGw9PT10KXJldHVybiBkKFwidmFyaWFibGVOYW1lXCIpO2lmKG51bGwhPT10aGlzLnBhdGNoP3RoaXMucGF0Y2guU2V0R2xvYmFsKHQsZSk6dGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh0LGUpLG51bGwhPT10aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50JiZudWxsIT09biYmZSE9PW4ucmVzdWx0KWlmKHRoaXMuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMpe2lmKG51bGw9PT10aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpcmV0dXJuIGQoXCJ0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnNcIik7bnVsbCE9PXRoaXMucGF0Y2g/dGhpcy5wYXRjaC5BZGRDaGFuZ2VkVmFyaWFibGUodCk6bnVsbCE9PXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyYmdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzLmFkZCh0KX1lbHNlIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQodCxlKX1SZXNvbHZlVmFyaWFibGVQb2ludGVyKHQpe2xldCBlPXQuY29udGV4dEluZGV4Oy0xPT1lJiYoZT10aGlzLkdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh0LnZhcmlhYmxlTmFtZSkpO2xldCBuPWEodGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKHQudmFyaWFibGVOYW1lLGUpLHcpO3JldHVybiBudWxsIT1uP246bmV3IHcodC52YXJpYWJsZU5hbWUsZSl9R2V0Q29udGV4dEluZGV4T2ZWYXJpYWJsZU5hbWVkKHQpe3JldHVybiB0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodCk/MDp0aGlzLl9jYWxsU3RhY2suY3VycmVudEVsZW1lbnRJbmRleH1PYnNlcnZlVmFyaWFibGVDaGFuZ2UodCl7dGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcy5wdXNoKHQpfX1KLmRvbnRTYXZlRGVmYXVsdFZhbHVlcz0hMDtjbGFzcyBLe2NvbnN0cnVjdG9yKHQpe3RoaXMuc2VlZD10JTIxNDc0ODM2NDcsdGhpcy5zZWVkPD0wJiYodGhpcy5zZWVkKz0yMTQ3NDgzNjQ2KX1uZXh0KCl7cmV0dXJuIHRoaXMuc2VlZD0xNjgwNyp0aGlzLnNlZWQlMjE0NzQ4MzY0N31uZXh0RmxvYXQoKXtyZXR1cm4odGhpcy5uZXh0KCktMSkvMjE0NzQ4MzY0Nn19Y2xhc3MgVXtjb25zdHJ1Y3Rvcigpe2lmKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXM9bmV3IFNldCx0aGlzLl92aXNpdENvdW50cz1uZXcgTWFwLHRoaXMuX3R1cm5JbmRpY2VzPW5ldyBNYXAsMT09PWFyZ3VtZW50cy5sZW5ndGgmJm51bGwhPT1hcmd1bWVudHNbMF0pe2xldCB0PWFyZ3VtZW50c1swXTt0aGlzLl9nbG9iYWxzPW5ldyBNYXAodC5fZ2xvYmFscyksdGhpcy5fY2hhbmdlZFZhcmlhYmxlcz1uZXcgU2V0KHQuX2NoYW5nZWRWYXJpYWJsZXMpLHRoaXMuX3Zpc2l0Q291bnRzPW5ldyBNYXAodC5fdmlzaXRDb3VudHMpLHRoaXMuX3R1cm5JbmRpY2VzPW5ldyBNYXAodC5fdHVybkluZGljZXMpfWVsc2UgdGhpcy5fZ2xvYmFscz1uZXcgTWFwLHRoaXMuX2NoYW5nZWRWYXJpYWJsZXM9bmV3IFNldCx0aGlzLl92aXNpdENvdW50cz1uZXcgTWFwLHRoaXMuX3R1cm5JbmRpY2VzPW5ldyBNYXB9Z2V0IGdsb2JhbHMoKXtyZXR1cm4gdGhpcy5fZ2xvYmFsc31nZXQgY2hhbmdlZFZhcmlhYmxlcygpe3JldHVybiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzfWdldCB2aXNpdENvdW50cygpe3JldHVybiB0aGlzLl92aXNpdENvdW50c31nZXQgdHVybkluZGljZXMoKXtyZXR1cm4gdGhpcy5fdHVybkluZGljZXN9VHJ5R2V0R2xvYmFsKHQsZSl7cmV0dXJuIG51bGwhPT10JiZ0aGlzLl9nbG9iYWxzLmhhcyh0KT97cmVzdWx0OnRoaXMuX2dsb2JhbHMuZ2V0KHQpLGV4aXN0czohMH06e3Jlc3VsdDplLGV4aXN0czohMX19U2V0R2xvYmFsKHQsZSl7dGhpcy5fZ2xvYmFscy5zZXQodCxlKX1BZGRDaGFuZ2VkVmFyaWFibGUodCl7cmV0dXJuIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMuYWRkKHQpfVRyeUdldFZpc2l0Q291bnQodCxlKXtyZXR1cm4gdGhpcy5fdmlzaXRDb3VudHMuaGFzKHQpP3tyZXN1bHQ6dGhpcy5fdmlzaXRDb3VudHMuZ2V0KHQpLGV4aXN0czohMH06e3Jlc3VsdDplLGV4aXN0czohMX19U2V0VmlzaXRDb3VudCh0LGUpe3RoaXMuX3Zpc2l0Q291bnRzLnNldCh0LGUpfVNldFR1cm5JbmRleCh0LGUpe3RoaXMuX3R1cm5JbmRpY2VzLnNldCh0LGUpfVRyeUdldFR1cm5JbmRleCh0LGUpe3JldHVybiB0aGlzLl90dXJuSW5kaWNlcy5oYXModCk/e3Jlc3VsdDp0aGlzLl90dXJuSW5kaWNlcy5nZXQodCksZXhpc3RzOiEwfTp7cmVzdWx0OmUsZXhpc3RzOiExfX19Y2xhc3MgentzdGF0aWMgVGV4dFRvRGljdGlvbmFyeSh0KXtyZXR1cm4gbmV3IHouUmVhZGVyKHQpLlRvRGljdGlvbmFyeSgpfXN0YXRpYyBUZXh0VG9BcnJheSh0KXtyZXR1cm4gbmV3IHouUmVhZGVyKHQpLlRvQXJyYXkoKX19IWZ1bmN0aW9uKHQpe3QuUmVhZGVyPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuX3Jvb3RPYmplY3Q9SlNPTi5wYXJzZSh0KX1Ub0RpY3Rpb25hcnkoKXtyZXR1cm4gdGhpcy5fcm9vdE9iamVjdH1Ub0FycmF5KCl7cmV0dXJuIHRoaXMuX3Jvb3RPYmplY3R9fTtjbGFzcyBle2NvbnN0cnVjdG9yKCl7dGhpcy5fY3VycmVudFByb3BlcnR5TmFtZT1udWxsLHRoaXMuX2N1cnJlbnRTdHJpbmc9bnVsbCx0aGlzLl9zdGF0ZVN0YWNrPVtdLHRoaXMuX2NvbGxlY3Rpb25TdGFjaz1bXSx0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjaz1bXSx0aGlzLl9qc29uT2JqZWN0PW51bGx9V3JpdGVPYmplY3QodCl7dGhpcy5Xcml0ZU9iamVjdFN0YXJ0KCksdCh0aGlzKSx0aGlzLldyaXRlT2JqZWN0RW5kKCl9V3JpdGVPYmplY3RTdGFydCgpe3RoaXMuU3RhcnROZXdPYmplY3QoITApO2xldCBlPXt9O2lmKHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSl7dGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudENvbGxlY3Rpb24pLHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUpO2xldCB0PXRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO3RoaXMuY3VycmVudENvbGxlY3Rpb25bdF09ZSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKX1lbHNlIHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheT8odGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudENvbGxlY3Rpb24pLHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChlKSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKSk6KHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Ob25lKSx0aGlzLl9qc29uT2JqZWN0PWUsdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSkpO3RoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLk9iamVjdCkpfVdyaXRlT2JqZWN0RW5kKCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk9iamVjdCksdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpLHRoaXMuX3N0YXRlU3RhY2sucG9wKCl9V3JpdGVQcm9wZXJ0eSh0LGUpe2lmKHRoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KHQpLGFyZ3VtZW50c1sxXWluc3RhbmNlb2YgRnVuY3Rpb24peygwLGFyZ3VtZW50c1sxXSkodGhpcyl9ZWxzZXtsZXQgdD1hcmd1bWVudHNbMV07dGhpcy5Xcml0ZSh0KX10aGlzLldyaXRlUHJvcGVydHlFbmQoKX1Xcml0ZUludFByb3BlcnR5KHQsZSl7dGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQodCksdGhpcy5Xcml0ZUludChlKSx0aGlzLldyaXRlUHJvcGVydHlFbmQoKX1Xcml0ZUZsb2F0UHJvcGVydHkodCxlKXt0aGlzLldyaXRlUHJvcGVydHlTdGFydCh0KSx0aGlzLldyaXRlRmxvYXQoZSksdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCl9V3JpdGVQcm9wZXJ0eVN0YXJ0KGUpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5PYmplY3QpLHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnB1c2goZSksdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCksdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKX1Xcml0ZVByb3BlcnR5RW5kKCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5KSx0aGlzLkFzc2VydCgxPT09dGhpcy5jaGlsZENvdW50KSx0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpfVdyaXRlUHJvcGVydHlOYW1lU3RhcnQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuT2JqZWN0KSx0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKSx0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lPVwiXCIsdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKSx0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpKX1Xcml0ZVByb3BlcnR5TmFtZUVuZCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpLHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKSx0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wdXNoKHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUpLHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWU9bnVsbCx0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpfVdyaXRlUHJvcGVydHlOYW1lSW5uZXIoZSl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSksdGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUpLHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUrPWV9V3JpdGVBcnJheVN0YXJ0KCl7dGhpcy5TdGFydE5ld09iamVjdCghMCk7bGV0IGU9W107aWYodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5KXt0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50Q29sbGVjdGlvbiksdGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudFByb3BlcnR5TmFtZSk7bGV0IHQ9dGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7dGhpcy5jdXJyZW50Q29sbGVjdGlvblt0XT1lLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpfWVsc2UgdGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5Pyh0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50Q29sbGVjdGlvbiksdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKGUpLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpKToodGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk5vbmUpLHRoaXMuX2pzb25PYmplY3Q9ZSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKSk7dGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuQXJyYXkpKX1Xcml0ZUFycmF5RW5kKCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5KSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucG9wKCksdGhpcy5fc3RhdGVTdGFjay5wb3AoKX1Xcml0ZSh0LGU9ITApe251bGwhPT10Pyh0aGlzLlN0YXJ0TmV3T2JqZWN0KCExKSx0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodCkpOmNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB0cnlpbmcgdG8gd3JpdGUgYSBudWxsIHN0cmluZ1wiKX1Xcml0ZUludCh0KXtudWxsIT09dCYmKHRoaXMuU3RhcnROZXdPYmplY3QoITEpLHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdChNYXRoLmZsb29yKHQpKSl9V3JpdGVGbG9hdCh0KXtudWxsIT09dCYmKHRoaXMuU3RhcnROZXdPYmplY3QoITEpLHQ9PU51bWJlci5QT1NJVElWRV9JTkZJTklUWT90aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoMzRlMzcpOnQ9PU51bWJlci5ORUdBVElWRV9JTkZJTklUWT90aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoLTM0ZTM3KTppc05hTih0KT90aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoMCk6dGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHQpKX1Xcml0ZU51bGwoKXt0aGlzLlN0YXJ0TmV3T2JqZWN0KCExKSx0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QobnVsbCl9V3JpdGVTdHJpbmdTdGFydCgpe3RoaXMuU3RhcnROZXdPYmplY3QoITEpLHRoaXMuX2N1cnJlbnRTdHJpbmc9XCJcIix0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5TdHJpbmcpKX1Xcml0ZVN0cmluZ0VuZCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PXQuV3JpdGVyLlN0YXRlLlN0cmluZyksdGhpcy5fc3RhdGVTdGFjay5wb3AoKSx0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodGhpcy5fY3VycmVudFN0cmluZyksdGhpcy5fY3VycmVudFN0cmluZz1udWxsfVdyaXRlU3RyaW5nSW5uZXIoZSxuPSEwKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuU3RyaW5nKSxudWxsIT09ZT90aGlzLl9jdXJyZW50U3RyaW5nKz1lOmNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB0cnlpbmcgdG8gd3JpdGUgYSBudWxsIHN0cmluZ1wiKX1Ub1N0cmluZygpe3JldHVybiBudWxsPT09dGhpcy5fanNvbk9iamVjdD9cIlwiOkpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb25PYmplY3QpfVN0YXJ0TmV3T2JqZWN0KGUpe2U/dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk5vbmV8fHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eXx8dGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLkFycmF5KTp0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHl8fHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheSksdGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5JiZ0aGlzLkFzc2VydCgwPT09dGhpcy5jaGlsZENvdW50KSx0aGlzLnN0YXRlIT09dC5Xcml0ZXIuU3RhdGUuQXJyYXkmJnRoaXMuc3RhdGUhPT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eXx8dGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCl9Z2V0IHN0YXRlKCl7cmV0dXJuIHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoPjA/dGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aC0xXS50eXBlOnQuV3JpdGVyLlN0YXRlLk5vbmV9Z2V0IGNoaWxkQ291bnQoKXtyZXR1cm4gdGhpcy5fc3RhdGVTdGFjay5sZW5ndGg+MD90aGlzLl9zdGF0ZVN0YWNrW3RoaXMuX3N0YXRlU3RhY2subGVuZ3RoLTFdLmNoaWxkQ291bnQ6MH1nZXQgY3VycmVudENvbGxlY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aD4wP3RoaXMuX2NvbGxlY3Rpb25TdGFja1t0aGlzLl9jb2xsZWN0aW9uU3RhY2subGVuZ3RoLTFdOm51bGx9Z2V0IGN1cnJlbnRQcm9wZXJ0eU5hbWUoKXtyZXR1cm4gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoPjA/dGhpcy5fcHJvcGVydHlOYW1lU3RhY2tbdGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoLTFdOm51bGx9SW5jcmVtZW50Q2hpbGRDb3VudCgpe3RoaXMuQXNzZXJ0KHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoPjApO2xldCB0PXRoaXMuX3N0YXRlU3RhY2sucG9wKCk7dC5jaGlsZENvdW50KyssdGhpcy5fc3RhdGVTdGFjay5wdXNoKHQpfUFzc2VydCh0KXtpZighdCl0aHJvdyBFcnJvcihcIkFzc2VydCBmYWlsZWQgd2hpbGUgd3JpdGluZyBKU09OXCIpfV9hZGRUb0N1cnJlbnRPYmplY3QoZSl7dGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudENvbGxlY3Rpb24pLHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheT8odGhpcy5Bc3NlcnQoQXJyYXkuaXNBcnJheSh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSksdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKGUpKTp0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkmJih0aGlzLkFzc2VydCghQXJyYXkuaXNBcnJheSh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSksdGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudFByb3BlcnR5TmFtZSksdGhpcy5jdXJyZW50Q29sbGVjdGlvblt0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWVdPWUsdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCkpfX10LldyaXRlcj1lLGZ1bmN0aW9uKGUpe2xldCBuOyFmdW5jdGlvbih0KXt0W3QuTm9uZT0wXT1cIk5vbmVcIix0W3QuT2JqZWN0PTFdPVwiT2JqZWN0XCIsdFt0LkFycmF5PTJdPVwiQXJyYXlcIix0W3QuUHJvcGVydHk9M109XCJQcm9wZXJ0eVwiLHRbdC5Qcm9wZXJ0eU5hbWU9NF09XCJQcm9wZXJ0eU5hbWVcIix0W3QuU3RyaW5nPTVdPVwiU3RyaW5nXCJ9KG49ZS5TdGF0ZXx8KGUuU3RhdGU9e30pKTtlLlN0YXRlRWxlbWVudD1jbGFzc3tjb25zdHJ1Y3RvcihlKXt0aGlzLnR5cGU9dC5Xcml0ZXIuU3RhdGUuTm9uZSx0aGlzLmNoaWxkQ291bnQ9MCx0aGlzLnR5cGU9ZX19fShlPXQuV3JpdGVyfHwodC5Xcml0ZXI9e30pKX0oenx8KHo9e30pKTtjbGFzcyBIe2NvbnN0cnVjdG9yKHQpe3RoaXMua0lua1NhdmVTdGF0ZVZlcnNpb249OCx0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb249OCx0aGlzLl9jdXJyZW50RXJyb3JzPW51bGwsdGhpcy5fY3VycmVudFdhcm5pbmdzPW51bGwsdGhpcy5kaXZlcnRlZFBvaW50ZXI9SS5OdWxsLHRoaXMuX2N1cnJlbnRUdXJuSW5kZXg9MCx0aGlzLnN0b3J5U2VlZD0wLHRoaXMucHJldmlvdXNSYW5kb209MCx0aGlzLmRpZFNhZmVFeGl0PSExLHRoaXMuX2N1cnJlbnRUZXh0PW51bGwsdGhpcy5fY3VycmVudFRhZ3M9bnVsbCx0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHk9ITAsdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5PSEwLHRoaXMuX3BhdGNoPW51bGwsdGhpcy5zdG9yeT10LHRoaXMuX291dHB1dFN0cmVhbT1bXSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCksdGhpcy5fZXZhbHVhdGlvblN0YWNrPVtdLHRoaXMuY2FsbFN0YWNrPW5ldyBxKHQpLHRoaXMuX3ZhcmlhYmxlc1N0YXRlPW5ldyBKKHRoaXMuY2FsbFN0YWNrLHQubGlzdERlZmluaXRpb25zKSx0aGlzLl92aXNpdENvdW50cz1uZXcgTWFwLHRoaXMuX3R1cm5JbmRpY2VzPW5ldyBNYXAsdGhpcy5jdXJyZW50VHVybkluZGV4PS0xO2xldCBlPShuZXcgRGF0ZSkuZ2V0VGltZSgpO3RoaXMuc3RvcnlTZWVkPW5ldyBLKGUpLm5leHQoKSUxMDAsdGhpcy5wcmV2aW91c1JhbmRvbT0wLHRoaXMuX2N1cnJlbnRDaG9pY2VzPVtdLHRoaXMuR29Ub1N0YXJ0KCl9VG9Kc29uKHQ9ITEpe2xldCBlPW5ldyB6LldyaXRlcjtyZXR1cm4gdGhpcy5Xcml0ZUpzb24oZSksZS5Ub1N0cmluZygpfXRvSnNvbih0PSExKXtyZXR1cm4gdGhpcy5Ub0pzb24odCl9TG9hZEpzb24odCl7bGV0IGU9ei5UZXh0VG9EaWN0aW9uYXJ5KHQpO3RoaXMuTG9hZEpzb25PYmooZSl9VmlzaXRDb3VudEF0UGF0aFN0cmluZyh0KXtsZXQgbjtpZihudWxsIT09dGhpcy5fcGF0Y2gpe2xldCBpPXRoaXMuc3RvcnkuQ29udGVudEF0UGF0aChuZXcgZSh0KSkuY29udGFpbmVyO2lmKG51bGw9PT1pKXRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgYXQgcGF0aCBub3QgZm91bmQ6IFwiK3QpO2lmKG49dGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudChpLDApLG4uZXhpc3RzKXJldHVybiBuLnJlc3VsdH1yZXR1cm4gbj15KHRoaXMuX3Zpc2l0Q291bnRzLHQsbnVsbCksbi5leGlzdHM/bi5yZXN1bHQ6MH1WaXNpdENvdW50Rm9yQ29udGFpbmVyKHQpe2lmKG51bGw9PT10KXJldHVybiBkKFwiY29udGFpbmVyXCIpO2lmKCF0LnZpc2l0c1Nob3VsZEJlQ291bnRlZClyZXR1cm4gdGhpcy5zdG9yeS5FcnJvcihcIlJlYWQgY291bnQgZm9yIHRhcmdldCAoXCIrdC5uYW1lK1wiIC0gb24gXCIrdC5kZWJ1Z01ldGFkYXRhK1wiKSB1bmtub3duLiBUaGUgc3RvcnkgbWF5IG5lZWQgdG8gYmUgY29tcGlsZWQgd2l0aCBjb3VudEFsbFZpc2l0cyBmbGFnICgtYykuXCIpLDA7aWYobnVsbCE9PXRoaXMuX3BhdGNoKXtsZXQgZT10aGlzLl9wYXRjaC5UcnlHZXRWaXNpdENvdW50KHQsMCk7aWYoZS5leGlzdHMpcmV0dXJuIGUucmVzdWx0fWxldCBlPXQucGF0aC50b1N0cmluZygpLG49eSh0aGlzLl92aXNpdENvdW50cyxlLG51bGwpO3JldHVybiBuLmV4aXN0cz9uLnJlc3VsdDowfUluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIodCl7aWYobnVsbCE9PXRoaXMuX3BhdGNoKXtsZXQgZT10aGlzLlZpc2l0Q291bnRGb3JDb250YWluZXIodCk7cmV0dXJuIGUrKyx2b2lkIHRoaXMuX3BhdGNoLlNldFZpc2l0Q291bnQodCxlKX1sZXQgZT10LnBhdGgudG9TdHJpbmcoKSxuPXkodGhpcy5fdmlzaXRDb3VudHMsZSxudWxsKTtuLmV4aXN0cz90aGlzLl92aXNpdENvdW50cy5zZXQoZSxuLnJlc3VsdCsxKTp0aGlzLl92aXNpdENvdW50cy5zZXQoZSwxKX1SZWNvcmRUdXJuSW5kZXhWaXNpdFRvQ29udGFpbmVyKHQpe2lmKG51bGwhPT10aGlzLl9wYXRjaClyZXR1cm4gdm9pZCB0aGlzLl9wYXRjaC5TZXRUdXJuSW5kZXgodCx0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO2xldCBlPXQucGF0aC50b1N0cmluZygpO3RoaXMuX3R1cm5JbmRpY2VzLnNldChlLHRoaXMuY3VycmVudFR1cm5JbmRleCl9VHVybnNTaW5jZUZvckNvbnRhaW5lcih0KXtpZih0LnR1cm5JbmRleFNob3VsZEJlQ291bnRlZHx8dGhpcy5zdG9yeS5FcnJvcihcIlRVUk5TX1NJTkNFKCkgZm9yIHRhcmdldCAoXCIrdC5uYW1lK1wiIC0gb24gXCIrdC5kZWJ1Z01ldGFkYXRhK1wiKSB1bmtub3duLiBUaGUgc3RvcnkgbWF5IG5lZWQgdG8gYmUgY29tcGlsZWQgd2l0aCBjb3VudEFsbFZpc2l0cyBmbGFnICgtYykuXCIpLG51bGwhPT10aGlzLl9wYXRjaCl7bGV0IGU9dGhpcy5fcGF0Y2guVHJ5R2V0VHVybkluZGV4KHQsMCk7aWYoZS5leGlzdHMpcmV0dXJuIHRoaXMuY3VycmVudFR1cm5JbmRleC1lLnJlc3VsdH1sZXQgZT10LnBhdGgudG9TdHJpbmcoKSxuPXkodGhpcy5fdHVybkluZGljZXMsZSwwKTtyZXR1cm4gbi5leGlzdHM/dGhpcy5jdXJyZW50VHVybkluZGV4LW4ucmVzdWx0Oi0xfWdldCBjYWxsc3RhY2tEZXB0aCgpe3JldHVybiB0aGlzLmNhbGxTdGFjay5kZXB0aH1nZXQgb3V0cHV0U3RyZWFtKCl7cmV0dXJuIHRoaXMuX291dHB1dFN0cmVhbX1nZXQgY3VycmVudENob2ljZXMoKXtyZXR1cm4gdGhpcy5jYW5Db250aW51ZT9bXTp0aGlzLl9jdXJyZW50Q2hvaWNlc31nZXQgZ2VuZXJhdGVkQ2hvaWNlcygpe3JldHVybiB0aGlzLl9jdXJyZW50Q2hvaWNlc31nZXQgY3VycmVudEVycm9ycygpe3JldHVybiB0aGlzLl9jdXJyZW50RXJyb3JzfWdldCBjdXJyZW50V2FybmluZ3MoKXtyZXR1cm4gdGhpcy5fY3VycmVudFdhcm5pbmdzfWdldCB2YXJpYWJsZXNTdGF0ZSgpe3JldHVybiB0aGlzLl92YXJpYWJsZXNTdGF0ZX1zZXQgdmFyaWFibGVzU3RhdGUodCl7dGhpcy5fdmFyaWFibGVzU3RhdGU9dH1nZXQgZXZhbHVhdGlvblN0YWNrKCl7cmV0dXJuIHRoaXMuX2V2YWx1YXRpb25TdGFja31nZXQgdmlzaXRDb3VudHMoKXtyZXR1cm4gdGhpcy5fdmlzaXRDb3VudHN9Z2V0IHR1cm5JbmRpY2VzKCl7cmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzfWdldCBjdXJyZW50VHVybkluZGV4KCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXh9c2V0IGN1cnJlbnRUdXJuSW5kZXgodCl7dGhpcy5fY3VycmVudFR1cm5JbmRleD10fWdldCBjdXJyZW50UGF0aFN0cmluZygpe2xldCB0PXRoaXMuY3VycmVudFBvaW50ZXI7cmV0dXJuIHQuaXNOdWxsP251bGw6bnVsbD09PXQucGF0aD9kKFwicG9pbnRlci5wYXRoXCIpOnQucGF0aC50b1N0cmluZygpfWdldCBjdXJyZW50UG9pbnRlcigpe3JldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb3B5KCl9c2V0IGN1cnJlbnRQb2ludGVyKHQpe3RoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyPXQuY29weSgpfWdldCBwcmV2aW91c1BvaW50ZXIoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXIuY29weSgpfXNldCBwcmV2aW91c1BvaW50ZXIodCl7dGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXI9dC5jb3B5KCl9Z2V0IGNhbkNvbnRpbnVlKCl7cmV0dXJuIXRoaXMuY3VycmVudFBvaW50ZXIuaXNOdWxsJiYhdGhpcy5oYXNFcnJvcn1nZXQgaGFzRXJyb3IoKXtyZXR1cm4gbnVsbCE9dGhpcy5jdXJyZW50RXJyb3JzJiZ0aGlzLmN1cnJlbnRFcnJvcnMubGVuZ3RoPjB9Z2V0IGhhc1dhcm5pbmcoKXtyZXR1cm4gbnVsbCE9dGhpcy5jdXJyZW50V2FybmluZ3MmJnRoaXMuY3VycmVudFdhcm5pbmdzLmxlbmd0aD4wfWdldCBjdXJyZW50VGV4dCgpe2lmKHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSl7bGV0IHQ9bmV3IG07Zm9yKGxldCBlIG9mIHRoaXMuX291dHB1dFN0cmVhbSl7bGV0IG49YShlLFQpO251bGwhPT1uJiZ0LkFwcGVuZChuLnZhbHVlKX10aGlzLl9jdXJyZW50VGV4dD10aGlzLkNsZWFuT3V0cHV0V2hpdGVzcGFjZSh0LnRvU3RyaW5nKCkpLHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eT0hMX1yZXR1cm4gdGhpcy5fY3VycmVudFRleHR9Q2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHQpe2xldCBlPW5ldyBtLG49LTEsaT0wO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtsZXQgYT10LmNoYXJBdChyKSxzPVwiIFwiPT1hfHxcIlxcdFwiPT1hO3MmJi0xPT1uJiYobj1yKSxzfHwoXCJcXG5cIiE9YSYmbj4wJiZuIT1pJiZlLkFwcGVuZChcIiBcIiksbj0tMSksXCJcXG5cIj09YSYmKGk9cisxKSxzfHxlLkFwcGVuZChhKX1yZXR1cm4gZS50b1N0cmluZygpfWdldCBjdXJyZW50VGFncygpe2lmKHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSl7dGhpcy5fY3VycmVudFRhZ3M9W107Zm9yKGxldCB0IG9mIHRoaXMuX291dHB1dFN0cmVhbSl7bGV0IGU9YSh0LGopO251bGwhPT1lJiZ0aGlzLl9jdXJyZW50VGFncy5wdXNoKGUudGV4dCl9dGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5PSExfXJldHVybiB0aGlzLl9jdXJyZW50VGFnc31nZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbigpe3JldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5pbkV4cHJlc3Npb25FdmFsdWF0aW9ufXNldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKHQpe3RoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb249dH1Hb1RvU3RhcnQoKXt0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlcj1JLlN0YXJ0T2YodGhpcy5zdG9yeS5tYWluQ29udGVudENvbnRhaW5lcil9Q29weUFuZFN0YXJ0UGF0Y2hpbmcoKXtsZXQgdD1uZXcgSCh0aGlzLnN0b3J5KTtyZXR1cm4gdC5fcGF0Y2g9bmV3IFUodGhpcy5fcGF0Y2gpLHQub3V0cHV0U3RyZWFtLnB1c2guYXBwbHkodC5vdXRwdXRTdHJlYW0sdGhpcy5fb3V0cHV0U3RyZWFtKSx0Lk91dHB1dFN0cmVhbURpcnR5KCksdC5fY3VycmVudENob2ljZXMucHVzaC5hcHBseSh0Ll9jdXJyZW50Q2hvaWNlcyx0aGlzLl9jdXJyZW50Q2hvaWNlcyksdGhpcy5oYXNFcnJvciYmKHQuX2N1cnJlbnRFcnJvcnM9W10sdC5fY3VycmVudEVycm9ycy5wdXNoLmFwcGx5KHQuX2N1cnJlbnRFcnJvcnMsdGhpcy5jdXJyZW50RXJyb3JzfHxbXSkpLHRoaXMuaGFzV2FybmluZyYmKHQuX2N1cnJlbnRXYXJuaW5ncz1bXSx0Ll9jdXJyZW50V2FybmluZ3MucHVzaC5hcHBseSh0Ll9jdXJyZW50V2FybmluZ3MsdGhpcy5jdXJyZW50V2FybmluZ3N8fFtdKSksdC5jYWxsU3RhY2s9bmV3IHEodGhpcy5jYWxsU3RhY2spLHQudmFyaWFibGVzU3RhdGU9dGhpcy52YXJpYWJsZXNTdGF0ZSx0LnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjaz10LmNhbGxTdGFjayx0LnZhcmlhYmxlc1N0YXRlLnBhdGNoPXQuX3BhdGNoLHQuZXZhbHVhdGlvblN0YWNrLnB1c2guYXBwbHkodC5ldmFsdWF0aW9uU3RhY2ssdGhpcy5ldmFsdWF0aW9uU3RhY2spLHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbHx8KHQuZGl2ZXJ0ZWRQb2ludGVyPXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmNvcHkoKSksdC5wcmV2aW91c1BvaW50ZXI9dGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpLHQuX3Zpc2l0Q291bnRzPXRoaXMuX3Zpc2l0Q291bnRzLHQuX3R1cm5JbmRpY2VzPXRoaXMuX3R1cm5JbmRpY2VzLHQuY3VycmVudFR1cm5JbmRleD10aGlzLmN1cnJlbnRUdXJuSW5kZXgsdC5zdG9yeVNlZWQ9dGhpcy5zdG9yeVNlZWQsdC5wcmV2aW91c1JhbmRvbT10aGlzLnByZXZpb3VzUmFuZG9tLHQuZGlkU2FmZUV4aXQ9dGhpcy5kaWRTYWZlRXhpdCx0fVJlc3RvcmVBZnRlclBhdGNoKCl7dGhpcy52YXJpYWJsZXNTdGF0ZS5jYWxsU3RhY2s9dGhpcy5jYWxsU3RhY2ssdGhpcy52YXJpYWJsZXNTdGF0ZS5wYXRjaD10aGlzLl9wYXRjaH1BcHBseUFueVBhdGNoKCl7aWYobnVsbCE9PXRoaXMuX3BhdGNoKXt0aGlzLnZhcmlhYmxlc1N0YXRlLkFwcGx5UGF0Y2goKTtmb3IobGV0W3QsZV1vZiB0aGlzLl9wYXRjaC52aXNpdENvdW50cyl0aGlzLkFwcGx5Q291bnRDaGFuZ2VzKHQsZSwhMCk7Zm9yKGxldFt0LGVdb2YgdGhpcy5fcGF0Y2gudHVybkluZGljZXMpdGhpcy5BcHBseUNvdW50Q2hhbmdlcyh0LGUsITEpO3RoaXMuX3BhdGNoPW51bGx9fUFwcGx5Q291bnRDaGFuZ2VzKHQsZSxuKXsobj90aGlzLl92aXNpdENvdW50czp0aGlzLl90dXJuSW5kaWNlcykuc2V0KHQucGF0aC50b1N0cmluZygpLGUpfVdyaXRlSnNvbih0KXt0LldyaXRlT2JqZWN0U3RhcnQoKTtsZXQgZT0hMTtmb3IobGV0IG4gb2YgdGhpcy5fY3VycmVudENob2ljZXMpe2lmKG51bGw9PT1uLnRocmVhZEF0R2VuZXJhdGlvbilyZXR1cm4gZChcImMudGhyZWFkQXRHZW5lcmF0aW9uXCIpO24ub3JpZ2luYWxUaHJlYWRJbmRleD1uLnRocmVhZEF0R2VuZXJhdGlvbi50aHJlYWRJbmRleCxudWxsPT09dGhpcy5jYWxsU3RhY2suVGhyZWFkV2l0aEluZGV4KG4ub3JpZ2luYWxUaHJlYWRJbmRleCkmJihlfHwoZT0hMCx0LldyaXRlUHJvcGVydHlTdGFydChcImNob2ljZVRocmVhZHNcIiksdC5Xcml0ZU9iamVjdFN0YXJ0KCkpLHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KG4ub3JpZ2luYWxUaHJlYWRJbmRleCksbi50aHJlYWRBdEdlbmVyYXRpb24uV3JpdGVKc29uKHQpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpKX1pZihlJiYodC5Xcml0ZU9iamVjdEVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpKSx0LldyaXRlUHJvcGVydHkoXCJjYWxsc3RhY2tUaHJlYWRzXCIsdD0+dGhpcy5jYWxsU3RhY2suV3JpdGVKc29uKHQpKSx0LldyaXRlUHJvcGVydHkoXCJ2YXJpYWJsZXNTdGF0ZVwiLHQ9PnRoaXMudmFyaWFibGVzU3RhdGUuV3JpdGVKc29uKHQpKSx0LldyaXRlUHJvcGVydHkoXCJldmFsU3RhY2tcIix0PT5NLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHQsdGhpcy5ldmFsdWF0aW9uU3RhY2spKSx0LldyaXRlUHJvcGVydHkoXCJvdXRwdXRTdHJlYW1cIix0PT5NLldyaXRlTGlzdFJ1bnRpbWVPYmpzKHQsdGhpcy5fb3V0cHV0U3RyZWFtKSksdC5Xcml0ZVByb3BlcnR5KFwiY3VycmVudENob2ljZXNcIix0PT57dC5Xcml0ZUFycmF5U3RhcnQoKTtmb3IobGV0IGUgb2YgdGhpcy5fY3VycmVudENob2ljZXMpTS5Xcml0ZUNob2ljZSh0LGUpO3QuV3JpdGVBcnJheUVuZCgpfSksIXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCl7aWYobnVsbD09PXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLnBhdGgpcmV0dXJuIGQoXCJkaXZlcnRlZFBvaW50ZXJcIik7dC5Xcml0ZVByb3BlcnR5KFwiY3VycmVudERpdmVydFRhcmdldFwiLHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLnBhdGguY29tcG9uZW50c1N0cmluZyl9dC5Xcml0ZVByb3BlcnR5KFwidmlzaXRDb3VudHNcIix0PT5NLldyaXRlSW50RGljdGlvbmFyeSh0LHRoaXMuX3Zpc2l0Q291bnRzKSksdC5Xcml0ZVByb3BlcnR5KFwidHVybkluZGljZXNcIix0PT5NLldyaXRlSW50RGljdGlvbmFyeSh0LHRoaXMuX3R1cm5JbmRpY2VzKSksdC5Xcml0ZUludFByb3BlcnR5KFwidHVybklkeFwiLHRoaXMuY3VycmVudFR1cm5JbmRleCksdC5Xcml0ZUludFByb3BlcnR5KFwic3RvcnlTZWVkXCIsdGhpcy5zdG9yeVNlZWQpLHQuV3JpdGVJbnRQcm9wZXJ0eShcInByZXZpb3VzUmFuZG9tXCIsdGhpcy5wcmV2aW91c1JhbmRvbSksdC5Xcml0ZUludFByb3BlcnR5KFwiaW5rU2F2ZVZlcnNpb25cIix0aGlzLmtJbmtTYXZlU3RhdGVWZXJzaW9uKSx0LldyaXRlSW50UHJvcGVydHkoXCJpbmtGb3JtYXRWZXJzaW9uXCIsWC5pbmtWZXJzaW9uQ3VycmVudCksdC5Xcml0ZU9iamVjdEVuZCgpfUxvYWRKc29uT2JqKHQpe2xldCBuPXQsaT1uLmlua1NhdmVWZXJzaW9uO2lmKG51bGw9PWkpdGhyb3cgbmV3IFMoXCJpbmsgc2F2ZSBmb3JtYXQgaW5jb3JyZWN0LCBjYW4ndCBsb2FkLlwiKTtpZihwYXJzZUludChpKTx0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24pdGhyb3cgbmV3IFMoXCJJbmsgc2F2ZSBmb3JtYXQgaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gKHNhdyAnXCIraStcIicsIGJ1dCBtaW5pbXVtIGlzIFwiK3RoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbitcIiksIHNvIGNhbid0IGxvYWQuXCIpO3RoaXMuY2FsbFN0YWNrLlNldEpzb25Ub2tlbihuLmNhbGxzdGFja1RocmVhZHMsdGhpcy5zdG9yeSksdGhpcy52YXJpYWJsZXNTdGF0ZS5TZXRKc29uVG9rZW4obi52YXJpYWJsZXNTdGF0ZSksdGhpcy5fZXZhbHVhdGlvblN0YWNrPU0uSkFycmF5VG9SdW50aW1lT2JqTGlzdChuLmV2YWxTdGFjayksdGhpcy5fb3V0cHV0U3RyZWFtPU0uSkFycmF5VG9SdW50aW1lT2JqTGlzdChuLm91dHB1dFN0cmVhbSksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpLHRoaXMuX2N1cnJlbnRDaG9pY2VzPU0uSkFycmF5VG9SdW50aW1lT2JqTGlzdChuLmN1cnJlbnRDaG9pY2VzKTtsZXQgcj1uLmN1cnJlbnREaXZlcnRUYXJnZXQ7aWYobnVsbCE9cil7bGV0IHQ9bmV3IGUoci50b1N0cmluZygpKTt0aGlzLmRpdmVydGVkUG9pbnRlcj10aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgodCl9dGhpcy5fdmlzaXRDb3VudHM9TS5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KG4udmlzaXRDb3VudHMpLHRoaXMuX3R1cm5JbmRpY2VzPU0uSk9iamVjdFRvSW50RGljdGlvbmFyeShuLnR1cm5JbmRpY2VzKSx0aGlzLmN1cnJlbnRUdXJuSW5kZXg9cGFyc2VJbnQobi50dXJuSWR4KSx0aGlzLnN0b3J5U2VlZD1wYXJzZUludChuLnN0b3J5U2VlZCksdGhpcy5wcmV2aW91c1JhbmRvbT1wYXJzZUludChuLnByZXZpb3VzUmFuZG9tKTtsZXQgYT1uLmNob2ljZVRocmVhZHM7Zm9yKGxldCB0IG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKXtsZXQgZT10aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgodC5vcmlnaW5hbFRocmVhZEluZGV4KTtpZihudWxsIT1lKXQudGhyZWFkQXRHZW5lcmF0aW9uPWUuQ29weSgpO2Vsc2V7bGV0IGU9YVt0Lm9yaWdpbmFsVGhyZWFkSW5kZXgudG9TdHJpbmcoKV07dC50aHJlYWRBdEdlbmVyYXRpb249bmV3IHEuVGhyZWFkKGUsdGhpcy5zdG9yeSl9fX1SZXNldEVycm9ycygpe3RoaXMuX2N1cnJlbnRFcnJvcnM9bnVsbCx0aGlzLl9jdXJyZW50V2FybmluZ3M9bnVsbH1SZXNldE91dHB1dCh0PW51bGwpe3RoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg9MCxudWxsIT09dCYmdGhpcy5fb3V0cHV0U3RyZWFtLnB1c2guYXBwbHkodGhpcy5fb3V0cHV0U3RyZWFtLHQpLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX1QdXNoVG9PdXRwdXRTdHJlYW0odCl7bGV0IGU9YSh0LFQpO2lmKG51bGwhPT1lKXtsZXQgdD10aGlzLlRyeVNwbGl0dGluZ0hlYWRUYWlsV2hpdGVzcGFjZShlKTtpZihudWxsIT09dCl7Zm9yKGxldCBlIG9mIHQpdGhpcy5QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKGUpO3JldHVybiB2b2lkIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX19dGhpcy5QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKHQpLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX1Qb3BGcm9tT3V0cHV0U3RyZWFtKHQpe3RoaXMub3V0cHV0U3RyZWFtLnNwbGljZSh0aGlzLm91dHB1dFN0cmVhbS5sZW5ndGgtdCx0KSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9VHJ5U3BsaXR0aW5nSGVhZFRhaWxXaGl0ZXNwYWNlKHQpe2xldCBlPXQudmFsdWU7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJzaW5nbGUudmFsdWVcIik7bGV0IG49LTEsaT0tMTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoOysrdCl7bGV0IHI9ZVt0XTtpZihcIlxcblwiIT1yKXtpZihcIiBcIj09cnx8XCJcXHRcIj09ciljb250aW51ZTticmVha30tMT09biYmKG49dCksaT10fWxldCByPS0xLGE9LTE7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDsrK3Qpe2xldCBuPWVbdF07aWYoXCJcXG5cIiE9bil7aWYoXCIgXCI9PW58fFwiXFx0XCI9PW4pY29udGludWU7YnJlYWt9LTE9PXImJihyPXQpLGE9dH1pZigtMT09biYmLTE9PXIpcmV0dXJuIG51bGw7bGV0IHM9W10sbD0wLG89ZS5sZW5ndGg7aWYoLTEhPW4pe2lmKG4+MCl7bGV0IHQ9bmV3IFQoZS5zdWJzdHJpbmcoMCxuKSk7cy5wdXNoKHQpfXMucHVzaChuZXcgVChcIlxcblwiKSksbD1pKzF9aWYoLTEhPXImJihvPWEpLG8+bCl7bGV0IHQ9ZS5zdWJzdHJpbmcobCxvLWwpO3MucHVzaChuZXcgVCh0KSl9aWYoLTEhPXImJmE+aSYmKHMucHVzaChuZXcgVChcIlxcblwiKSkscjxlLmxlbmd0aC0xKSl7bGV0IHQ9ZS5sZW5ndGgtci0xLG49bmV3IFQoZS5zdWJzdHJpbmcocisxLHQpKTtzLnB1c2gobil9cmV0dXJuIHN9UHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbCh0KXtsZXQgZT1hKHQseCksbj1hKHQsVCksaT0hMDtpZihlKXRoaXMuVHJpbU5ld2xpbmVzRnJvbU91dHB1dFN0cmVhbSgpLGk9ITA7ZWxzZSBpZihuKXtsZXQgdD0tMSxlPXRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50O2UudHlwZT09ci5GdW5jdGlvbiYmKHQ9ZS5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0pO2xldCBhPS0xO2ZvcihsZXQgZT10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7ZT49MDtlLS0pe2xldCBuPXRoaXMuX291dHB1dFN0cmVhbVtlXSxpPW4gaW5zdGFuY2VvZiBBP246bnVsbDtpZihudWxsIT0obiBpbnN0YW5jZW9mIHg/bjpudWxsKSl7YT1lO2JyZWFrfWlmKG51bGwhPWkmJmkuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpe2U+PXQmJih0PS0xKTticmVha319bGV0IHM9LTE7aWYocz0tMSE9YSYmLTEhPXQ/TWF0aC5taW4odCxhKTotMSE9YT9hOnQsLTEhPXMpe2lmKG4uaXNOZXdsaW5lKWk9ITE7ZWxzZSBpZihuLmlzTm9uV2hpdGVzcGFjZSYmKGE+LTEmJnRoaXMuUmVtb3ZlRXhpc3RpbmdHbHVlKCksdD4tMSkpe2xldCB0PXRoaXMuY2FsbFN0YWNrLmVsZW1lbnRzO2ZvcihsZXQgZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXtsZXQgbj10W2VdO2lmKG4udHlwZSE9ci5GdW5jdGlvbilicmVhaztuLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbT0tMX19fWVsc2Ugbi5pc05ld2xpbmUmJighdGhpcy5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lJiZ0aGlzLm91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudHx8KGk9ITEpKX1pZihpKXtpZihudWxsPT09dClyZXR1cm4gZChcIm9ialwiKTt0aGlzLl9vdXRwdXRTdHJlYW0ucHVzaCh0KSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9fVRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKXtsZXQgdD0tMSxlPXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTtmb3IoO2U+PTA7KXtsZXQgbj10aGlzLl9vdXRwdXRTdHJlYW1bZV0saT1hKG4sQSkscj1hKG4sVCk7aWYobnVsbCE9aXx8bnVsbCE9ciYmci5pc05vbldoaXRlc3BhY2UpYnJlYWs7bnVsbCE9ciYmci5pc05ld2xpbmUmJih0PWUpLGUtLX1pZih0Pj0wKWZvcihlPXQ7ZTx0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoOyl7YSh0aGlzLl9vdXRwdXRTdHJlYW1bZV0sVCk/dGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShlLDEpOmUrK310aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9UmVtb3ZlRXhpc3RpbmdHbHVlKCl7Zm9yKGxldCB0PXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTt0Pj0wO3QtLSl7bGV0IGU9dGhpcy5fb3V0cHV0U3RyZWFtW3RdO2lmKGUgaW5zdGFuY2VvZiB4KXRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UodCwxKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBBKWJyZWFrfXRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKX1nZXQgb3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSgpe2lmKHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg+MClmb3IobGV0IHQ9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO3Q+PTA7dC0tKXtpZih0aGlzLl9vdXRwdXRTdHJlYW1bdF1pbnN0YW5jZW9mIEEpYnJlYWs7bGV0IGU9dGhpcy5fb3V0cHV0U3RyZWFtW3RdO2lmKGUgaW5zdGFuY2VvZiBUKXtpZihlLmlzTmV3bGluZSlyZXR1cm4hMDtpZihlLmlzTm9uV2hpdGVzcGFjZSlicmVha319cmV0dXJuITF9Z2V0IG91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudCgpe2ZvcihsZXQgdD0wO3Q8dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aDt0KyspaWYodGhpcy5fb3V0cHV0U3RyZWFtW3RdaW5zdGFuY2VvZiBUKXJldHVybiEwO3JldHVybiExfWdldCBpblN0cmluZ0V2YWx1YXRpb24oKXtmb3IobGV0IHQ9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO3Q+PTA7dC0tKXtsZXQgZT1hKHRoaXMuX291dHB1dFN0cmVhbVt0XSxBKTtpZihlIGluc3RhbmNlb2YgQSYmZS5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5CZWdpblN0cmluZylyZXR1cm4hMH1yZXR1cm4hMX1QdXNoRXZhbHVhdGlvblN0YWNrKHQpe2xldCBlPWEodCxPKTtpZihlKXtsZXQgdD1lLnZhbHVlO2lmKG51bGw9PT10KXJldHVybiBkKFwicmF3TGlzdFwiKTtpZihudWxsIT10Lm9yaWdpbk5hbWVzKXt0Lm9yaWdpbnN8fCh0Lm9yaWdpbnM9W10pLHQub3JpZ2lucy5sZW5ndGg9MDtmb3IobGV0IGUgb2YgdC5vcmlnaW5OYW1lcyl7aWYobnVsbD09PXRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zKXJldHVybiBkKFwiU3RvcnlTdGF0ZS5zdG9yeS5saXN0RGVmaW5pdGlvbnNcIik7bGV0IG49dGhpcy5zdG9yeS5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24oZSxudWxsKTtpZihudWxsPT09bi5yZXN1bHQpcmV0dXJuIGQoXCJTdG9yeVN0YXRlIGRlZi5yZXN1bHRcIik7dC5vcmlnaW5zLmluZGV4T2Yobi5yZXN1bHQpPDAmJnQub3JpZ2lucy5wdXNoKG4ucmVzdWx0KX19fWlmKG51bGw9PT10KXJldHVybiBkKFwib2JqXCIpO3RoaXMuZXZhbHVhdGlvblN0YWNrLnB1c2godCl9UG9wRXZhbHVhdGlvblN0YWNrKHQpe2lmKHZvaWQgMD09PXQpe3JldHVybiBvKHRoaXMuZXZhbHVhdGlvblN0YWNrLnBvcCgpKX1pZih0PnRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJ0cnlpbmcgdG8gcG9wIHRvbyBtYW55IG9iamVjdHNcIik7cmV0dXJuIG8odGhpcy5ldmFsdWF0aW9uU3RhY2suc3BsaWNlKHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aC10LHQpKX1QZWVrRXZhbHVhdGlvblN0YWNrKCl7cmV0dXJuIHRoaXMuZXZhbHVhdGlvblN0YWNrW3RoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aC0xXX1Gb3JjZUVuZCgpe3RoaXMuY2FsbFN0YWNrLlJlc2V0KCksdGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoPTAsdGhpcy5jdXJyZW50UG9pbnRlcj1JLk51bGwsdGhpcy5wcmV2aW91c1BvaW50ZXI9SS5OdWxsLHRoaXMuZGlkU2FmZUV4aXQ9ITB9VHJpbVdoaXRlc3BhY2VGcm9tRnVuY3Rpb25FbmQoKXtuLkFzc2VydCh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlPT1yLkZ1bmN0aW9uKTtsZXQgdD10aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07LTE9PXQmJih0PTApO2ZvcihsZXQgZT10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7ZT49dDtlLS0pe2xldCB0PXRoaXMuX291dHB1dFN0cmVhbVtlXSxuPWEodCxUKSxpPWEodCxBKTtpZihudWxsIT1uKXtpZihpKWJyZWFrO2lmKCFuLmlzTmV3bGluZSYmIW4uaXNJbmxpbmVXaGl0ZXNwYWNlKWJyZWFrO3RoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoZSwxKSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9fX1Qb3BDYWxsU3RhY2sodD1udWxsKXt0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlPT1yLkZ1bmN0aW9uJiZ0aGlzLlRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCksdGhpcy5jYWxsU3RhY2suUG9wKHQpfVNldENob3NlblBhdGgodCxlKXt0aGlzLl9jdXJyZW50Q2hvaWNlcy5sZW5ndGg9MDtsZXQgbj10aGlzLnN0b3J5LlBvaW50ZXJBdFBhdGgodCk7bi5pc051bGx8fC0xIT1uLmluZGV4fHwobi5pbmRleD0wKSx0aGlzLmN1cnJlbnRQb2ludGVyPW4sZSYmdGhpcy5jdXJyZW50VHVybkluZGV4Kyt9U3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSh0LGUpe3RoaXMuY2FsbFN0YWNrLlB1c2goci5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSx0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpLHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyPUkuU3RhcnRPZih0KSx0aGlzLlBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhlKX1QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2sodCl7aWYobnVsbCE9dClmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKyl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHRbZV0mJlwic3RyaW5nXCIhPXR5cGVvZiB0W2VdKXRocm93IG5ldyBFcnJvcihcImluayBhcmd1bWVudHMgd2hlbiBjYWxsaW5nIEV2YWx1YXRlRnVuY3Rpb24gLyBDaG9vc2VQYXRoU3RyaW5nV2l0aFBhcmFtZXRlcnMgIG11c3QgYmUgaW50LCBmbG9hdCBvciBzdHJpbmdcIik7dGhpcy5QdXNoRXZhbHVhdGlvblN0YWNrKHYuQ3JlYXRlKHRbZV0pKX19VHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGU9PXIuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUmJih0aGlzLmN1cnJlbnRQb2ludGVyPUkuTnVsbCx0aGlzLmRpZFNhZmVFeGl0PSEwLCEwKX1Db21wbGV0ZUZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCl7aWYodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSE9ci5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSl0aHJvdyBuZXcgUyhcIkV4cGVjdGVkIGV4dGVybmFsIGZ1bmN0aW9uIGV2YWx1YXRpb24gdG8gYmUgY29tcGxldGUuIFN0YWNrIHRyYWNlOiBcIit0aGlzLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSk7bGV0IHQ9dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCxlPW51bGw7Zm9yKDt0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGg+dDspe2xldCB0PXRoaXMuUG9wRXZhbHVhdGlvblN0YWNrKCk7bnVsbD09PWUmJihlPXQpfWlmKHRoaXMuUG9wQ2FsbFN0YWNrKHIuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpLGUpe2lmKGUgaW5zdGFuY2VvZiBMKXJldHVybiBudWxsO2xldCB0PXMoZSx2KTtyZXR1cm4gdC52YWx1ZVR5cGU9PWkuRGl2ZXJ0VGFyZ2V0P3QudmFsdWVPYmplY3QudG9TdHJpbmcoKTp0LnZhbHVlT2JqZWN0fXJldHVybiBudWxsfUFkZEVycm9yKHQsZSl7ZT8obnVsbD09dGhpcy5fY3VycmVudFdhcm5pbmdzJiYodGhpcy5fY3VycmVudFdhcm5pbmdzPVtdKSx0aGlzLl9jdXJyZW50V2FybmluZ3MucHVzaCh0KSk6KG51bGw9PXRoaXMuX2N1cnJlbnRFcnJvcnMmJih0aGlzLl9jdXJyZW50RXJyb3JzPVtdKSx0aGlzLl9jdXJyZW50RXJyb3JzLnB1c2godCkpfU91dHB1dFN0cmVhbURpcnR5KCl7dGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5PSEwLHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eT0hMH19Y2xhc3MgJHtjb25zdHJ1Y3Rvcigpe3RoaXMuc3RhcnRUaW1lPXZvaWQgMH1nZXQgRWxhcHNlZE1pbGxpc2Vjb25kcygpe3JldHVybiB2b2lkIDA9PT10aGlzLnN0YXJ0VGltZT8wOihuZXcgRGF0ZSkuZ2V0VGltZSgpLXRoaXMuc3RhcnRUaW1lfVN0YXJ0KCl7dGhpcy5zdGFydFRpbWU9KG5ldyBEYXRlKS5nZXRUaW1lKCl9U3RvcCgpe3RoaXMuc3RhcnRUaW1lPXZvaWQgMH19TnVtYmVyLmlzSW50ZWdlcnx8KE51bWJlci5pc0ludGVnZXI9ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpJiZ0Pi05MDA3MTk5MjU0NzQwOTkyJiZ0PDkwMDcxOTkyNTQ3NDA5OTImJk1hdGguZmxvb3IodCk9PT10fSk7Y2xhc3MgWCBleHRlbmRzIHB7Y29uc3RydWN0b3IoKXtsZXQgdDtzdXBlcigpLHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlPTE4LHRoaXMuX3ByZXZDb250YWluZXJzPVtdLHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzPSExLHRoaXMuX2xpc3REZWZpbml0aW9ucz1udWxsLHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzPW51bGwsdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzPSExLHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI9bnVsbCx0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlPSExLHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lPW51bGwsdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudD0wLHRoaXMuX2FzeW5jU2F2aW5nPSExLHRoaXMuX3Byb2ZpbGVyPW51bGw7bGV0IGU9bnVsbCxuPW51bGw7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBOKXQ9YXJndW1lbnRzWzBdLHZvaWQgMCE9PWFyZ3VtZW50c1sxXSYmKGU9YXJndW1lbnRzWzFdKSx0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcj10O2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7bGV0IHQ9YXJndW1lbnRzWzBdO249ei5UZXh0VG9EaWN0aW9uYXJ5KHQpfWVsc2Ugbj1hcmd1bWVudHNbMF07aWYobnVsbCE9ZSYmKHRoaXMuX2xpc3REZWZpbml0aW9ucz1uZXcgQihlKSksdGhpcy5fZXh0ZXJuYWxzPW5ldyBNYXAsbnVsbCE9PW4pe2xldCB0PW4sZT10Lmlua1ZlcnNpb247aWYobnVsbD09ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmsgdmVyc2lvbiBudW1iZXIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgaXQncyBhIHZhbGlkIC5pbmsuanNvbiBmaWxlP1wiKTtsZXQgaT1wYXJzZUludChlKTtpZihpPlguaW5rVmVyc2lvbkN1cnJlbnQpdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSB3YXMgbmV3ZXIgdGhhbiB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7aWYoaTx0aGlzLmlua1ZlcnNpb25NaW5pbXVtQ29tcGF0aWJsZSl0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IGlzIHRvbyBvbGQgdG8gYmUgbG9hZGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgZW5naW5lXCIpO2khPVguaW5rVmVyc2lvbkN1cnJlbnQmJmNvbnNvbGUud2FybihcIldBUk5JTkc6IFZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgZG9lc24ndCBtYXRjaCBjdXJyZW50IHZlcnNpb24gb2YgZW5naW5lLiBOb24tY3JpdGljYWwsIGJ1dCByZWNvbW1lbmQgc3luY2hyb25pc2luZy5cIik7bGV0IHIsYT10LnJvb3Q7aWYobnVsbD09YSl0aHJvdyBuZXcgRXJyb3IoXCJSb290IG5vZGUgZm9yIGluayBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpOyhyPXQubGlzdERlZnMpJiYodGhpcy5fbGlzdERlZmluaXRpb25zPU0uSlRva2VuVG9MaXN0RGVmaW5pdGlvbnMocikpLHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyPXMoTS5KVG9rZW5Ub1J1bnRpbWVPYmplY3QoYSksTiksdGhpcy5SZXNldFN0YXRlKCl9fWdldCBjdXJyZW50Q2hvaWNlcygpe2xldCB0PVtdO2lmKG51bGw9PT10aGlzLl9zdGF0ZSlyZXR1cm4gZChcInRoaXMuX3N0YXRlXCIpO2ZvcihsZXQgZSBvZiB0aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcyllLmlzSW52aXNpYmxlRGVmYXVsdHx8KGUuaW5kZXg9dC5sZW5ndGgsdC5wdXNoKGUpKTtyZXR1cm4gdH1nZXQgY3VycmVudFRleHQoKXtyZXR1cm4gdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGV4dCBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKSx0aGlzLnN0YXRlLmN1cnJlbnRUZXh0fWdldCBjdXJyZW50VGFncygpe3JldHVybiB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIGN1cnJlbnRUYWdzIHNpbmNlIGl0J3MgYSB3b3JrIGluIHByb2dyZXNzXCIpLHRoaXMuc3RhdGUuY3VycmVudFRhZ3N9Z2V0IGN1cnJlbnRFcnJvcnMoKXtyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50RXJyb3JzfWdldCBjdXJyZW50V2FybmluZ3MoKXtyZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50V2FybmluZ3N9Z2V0IGhhc0Vycm9yKCl7cmV0dXJuIHRoaXMuc3RhdGUuaGFzRXJyb3J9Z2V0IGhhc1dhcm5pbmcoKXtyZXR1cm4gdGhpcy5zdGF0ZS5oYXNXYXJuaW5nfWdldCB2YXJpYWJsZXNTdGF0ZSgpe3JldHVybiB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlfWdldCBsaXN0RGVmaW5pdGlvbnMoKXtyZXR1cm4gdGhpcy5fbGlzdERlZmluaXRpb25zfWdldCBzdGF0ZSgpe3JldHVybiB0aGlzLl9zdGF0ZX1TdGFydFByb2ZpbGluZygpe31FbmRQcm9maWxpbmcoKXt9VG9Kc29uKHQpe2xldCBlPSExO2lmKHR8fChlPSEwLHQ9bmV3IHouV3JpdGVyKSx0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlSW50UHJvcGVydHkoXCJpbmtWZXJzaW9uXCIsWC5pbmtWZXJzaW9uQ3VycmVudCksdC5Xcml0ZVByb3BlcnR5KFwicm9vdFwiLHQ9Pk0uV3JpdGVSdW50aW1lQ29udGFpbmVyKHQsdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIpKSxudWxsIT10aGlzLl9saXN0RGVmaW5pdGlvbnMpe3QuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdERlZnNcIiksdC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldCBlIG9mIHRoaXMuX2xpc3REZWZpbml0aW9ucy5saXN0cyl7dC5Xcml0ZVByb3BlcnR5U3RhcnQoZS5uYW1lKSx0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0W24saV1vZiBlLml0ZW1zKXtsZXQgZT1mLmZyb21TZXJpYWxpemVkS2V5KG4pLHI9aTt0LldyaXRlSW50UHJvcGVydHkoZS5pdGVtTmFtZSxyKX10LldyaXRlT2JqZWN0RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCl9dC5Xcml0ZU9iamVjdEVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfWlmKHQuV3JpdGVPYmplY3RFbmQoKSxlKXJldHVybiB0LlRvU3RyaW5nKCl9UmVzZXRTdGF0ZSgpe3RoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0U3RhdGVcIiksdGhpcy5fc3RhdGU9bmV3IEgodGhpcyksdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuT2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlKHRoaXMuVmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50LmJpbmQodGhpcykpLHRoaXMuUmVzZXRHbG9iYWxzKCl9UmVzZXRFcnJvcnMoKXtpZihudWxsPT09dGhpcy5fc3RhdGUpcmV0dXJuIGQoXCJ0aGlzLl9zdGF0ZVwiKTt0aGlzLl9zdGF0ZS5SZXNldEVycm9ycygpfVJlc2V0Q2FsbHN0YWNrKCl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwiUmVzZXRDYWxsc3RhY2tcIiksbnVsbD09PXRoaXMuX3N0YXRlKXJldHVybiBkKFwidGhpcy5fc3RhdGVcIik7dGhpcy5fc3RhdGUuRm9yY2VFbmQoKX1SZXNldEdsb2JhbHMoKXtpZih0aGlzLl9tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuZ2V0KFwiZ2xvYmFsIGRlY2xcIikpe2xldCB0PXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO3RoaXMuQ2hvb3NlUGF0aChuZXcgZShcImdsb2JhbCBkZWNsXCIpLCExKSx0aGlzLkNvbnRpbnVlSW50ZXJuYWwoKSx0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyPXR9dGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5TbmFwc2hvdERlZmF1bHRHbG9iYWxzKCl9Q29udGludWUoKXtyZXR1cm4gdGhpcy5Db250aW51ZUFzeW5jKDApLHRoaXMuY3VycmVudFRleHR9Z2V0IGNhbkNvbnRpbnVlKCl7cmV0dXJuIHRoaXMuc3RhdGUuY2FuQ29udGludWV9Z2V0IGFzeW5jQ29udGludWVDb21wbGV0ZSgpe3JldHVybiF0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlfUNvbnRpbnVlQXN5bmModCl7dGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzfHx0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncygpLHRoaXMuQ29udGludWVJbnRlcm5hbCh0KX1Db250aW51ZUludGVybmFsKHQ9MCl7bnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlByZUNvbnRpbnVlKCk7bGV0IGU9dD4wO2lmKHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQrKywhdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSl7aWYodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZT1lLCF0aGlzLmNhbkNvbnRpbnVlKXRocm93IG5ldyBTKFwiQ2FuJ3QgY29udGludWUgLSBzaG91bGQgY2hlY2sgY2FuQ29udGludWUgYmVmb3JlIGNhbGxpbmcgQ29udGludWVcIik7dGhpcy5fc3RhdGUuZGlkU2FmZUV4aXQ9ITEsdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQoKSwxPT10aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50JiYodGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM9ITApfWxldCBuPW5ldyAkO24uU3RhcnQoKTtsZXQgaT0hMTtkb3t0cnl7aT10aGlzLkNvbnRpbnVlU2luZ2xlU3RlcCgpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7dGhpcy5BZGRFcnJvcih0Lm1lc3NhZ2Usdm9pZCAwLHQudXNlRW5kTGluZU51bWJlcik7YnJlYWt9aWYoaSlicmVhaztpZih0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlJiZuLkVsYXBzZWRNaWxsaXNlY29uZHM+dClicmVha313aGlsZSh0aGlzLmNhbkNvbnRpbnVlKTtuLlN0b3AoKSwhaSYmdGhpcy5jYW5Db250aW51ZXx8KG51bGwhPT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSYmdGhpcy5SZXN0b3JlU3RhdGVTbmFwc2hvdCgpLHRoaXMuY2FuQ29udGludWV8fCh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQmJnRoaXMuQWRkRXJyb3IoXCJUaHJlYWQgYXZhaWxhYmxlIHRvIHBvcCwgdGhyZWFkcyBzaG91bGQgYWx3YXlzIGJlIGZsYXQgYnkgdGhlIGVuZCBvZiBldmFsdWF0aW9uP1wiKSwwIT10aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMubGVuZ3RofHx0aGlzLnN0YXRlLmRpZFNhZmVFeGl0fHxudWxsIT10aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyfHwodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKHIuVHVubmVsKT90aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJy0+LT4nIHRvIHJldHVybiBmcm9tIGEgdHVubmVsP1wiKTp0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3Aoci5GdW5jdGlvbik/dGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICd+IHJldHVybic/XCIpOnRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcD90aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQgZm9yIHVua25vd24gcmVhc29uLiBQbGVhc2UgZGVidWcgY29tcGlsZXIhXCIpOnRoaXMuQWRkRXJyb3IoXCJyYW4gb3V0IG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJy0+IERPTkUnIG9yICctPiBFTkQnP1wiKSkpLHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQ9ITEsMT09dGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCYmKHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzPSExKSx0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlPSExKSx0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50LS0sbnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlBvc3RDb250aW51ZSgpfUNvbnRpbnVlU2luZ2xlU3RlcCgpe2lmKG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5QcmVTdGVwKCksdGhpcy5TdGVwKCksbnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlBvc3RTdGVwKCksdGhpcy5jYW5Db250aW51ZXx8dGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZXx8dGhpcy5UcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCksbnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlByZVNuYXBzaG90KCksIXRoaXMuc3RhdGUuaW5TdHJpbmdFdmFsdWF0aW9uKXtpZihudWxsIT09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUpe2lmKG51bGw9PT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGFncylyZXR1cm4gZChcInRoaXMuX3N0YXRlQXRMYXN0TmV3bGluZS5jdXJyZW50VGFnc1wiKTtpZihudWxsPT09dGhpcy5zdGF0ZS5jdXJyZW50VGFncylyZXR1cm4gZChcInRoaXMuc3RhdGUuY3VycmVudFRhZ3NcIik7bGV0IHQ9dGhpcy5DYWxjdWxhdGVOZXdsaW5lT3V0cHV0U3RhdGVDaGFuZ2UodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRleHQsdGhpcy5zdGF0ZS5jdXJyZW50VGV4dCx0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGFncy5sZW5ndGgsdGhpcy5zdGF0ZS5jdXJyZW50VGFncy5sZW5ndGgpO2lmKHQ9PVguT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lKXJldHVybiB0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCksITA7dD09WC5PdXRwdXRTdGF0ZUNoYW5nZS5OZXdsaW5lUmVtb3ZlZCYmdGhpcy5EaXNjYXJkU25hcHNob3QoKX10aGlzLnN0YXRlLm91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUmJih0aGlzLmNhbkNvbnRpbnVlP251bGw9PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lJiZ0aGlzLlN0YXRlU25hcHNob3QoKTp0aGlzLkRpc2NhcmRTbmFwc2hvdCgpKX1yZXR1cm4gbnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlBvc3RTbmFwc2hvdCgpLCExfUNhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZSh0LGUsbixpKXtpZihudWxsPT09dClyZXR1cm4gZChcInByZXZUZXh0XCIpO2lmKG51bGw9PT1lKXJldHVybiBkKFwiY3VyclRleHRcIik7bGV0IHI9ZS5sZW5ndGg+PXQubGVuZ3RoJiZcIlxcblwiPT1lLmNoYXJBdCh0Lmxlbmd0aC0xKTtpZihuPT1pJiZ0Lmxlbmd0aD09ZS5sZW5ndGgmJnIpcmV0dXJuIFguT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2U7aWYoIXIpcmV0dXJuIFguT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQ7aWYoaT5uKXJldHVybiBYLk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZTtmb3IobGV0IG49dC5sZW5ndGg7bjxlLmxlbmd0aDtuKyspe2xldCB0PWUuY2hhckF0KG4pO2lmKFwiIFwiIT10JiZcIlxcdFwiIT10KXJldHVybiBYLk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZX1yZXR1cm4gWC5PdXRwdXRTdGF0ZUNoYW5nZS5Ob0NoYW5nZX1Db250aW51ZU1heGltYWxseSgpe3RoaXMuSWZBc3luY1dlQ2FudChcIkNvbnRpbnVlTWF4aW1hbGx5XCIpO2xldCB0PW5ldyBtO2Zvcig7dGhpcy5jYW5Db250aW51ZTspdC5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtyZXR1cm4gdC50b1N0cmluZygpfUNvbnRlbnRBdFBhdGgodCl7cmV0dXJuIHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aCh0KX1Lbm90Q29udGFpbmVyV2l0aE5hbWUodCl7bGV0IGU9dGhpcy5tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuZ2V0KHQpO3JldHVybiBlIGluc3RhbmNlb2YgTj9lOm51bGx9UG9pbnRlckF0UGF0aCh0KXtpZigwPT10Lmxlbmd0aClyZXR1cm4gSS5OdWxsO2xldCBlPW5ldyBJLG49dC5sZW5ndGgsaT1udWxsO3JldHVybiBudWxsPT09dC5sYXN0Q29tcG9uZW50P2QoXCJwYXRoLmxhc3RDb21wb25lbnRcIik6KHQubGFzdENvbXBvbmVudC5pc0luZGV4PyhuPXQubGVuZ3RoLTEsaT10aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgodCx2b2lkIDAsbiksZS5jb250YWluZXI9aS5jb250YWluZXIsZS5pbmRleD10Lmxhc3RDb21wb25lbnQuaW5kZXgpOihpPXRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aCh0KSxlLmNvbnRhaW5lcj1pLmNvbnRhaW5lcixlLmluZGV4PS0xKSxudWxsPT1pLm9ianx8aS5vYmo9PXRoaXMubWFpbkNvbnRlbnRDb250YWluZXImJm4+MD90aGlzLkVycm9yKFwiRmFpbGVkIHRvIGZpbmQgY29udGVudCBhdCBwYXRoICdcIit0K1wiJywgYW5kIG5vIGFwcHJveGltYXRpb24gb2YgaXQgd2FzIHBvc3NpYmxlLlwiKTppLmFwcHJveGltYXRlJiZ0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250ZW50IGF0IHBhdGggJ1wiK3QrXCInLCBzbyBpdCB3YXMgYXBwcm94aW1hdGVkIHRvOiAnXCIraS5vYmoucGF0aCtcIicuXCIpLGUpfVN0YXRlU25hcHNob3QoKXt0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZT10aGlzLl9zdGF0ZSx0aGlzLl9zdGF0ZT10aGlzLl9zdGF0ZS5Db3B5QW5kU3RhcnRQYXRjaGluZygpfVJlc3RvcmVTdGF0ZVNuYXBzaG90KCl7bnVsbD09PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lJiZkKFwiX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lXCIpLHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLlJlc3RvcmVBZnRlclBhdGNoKCksdGhpcy5fc3RhdGU9dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUsdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU9bnVsbCx0aGlzLl9hc3luY1NhdmluZ3x8dGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpfURpc2NhcmRTbmFwc2hvdCgpe3RoaXMuX2FzeW5jU2F2aW5nfHx0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCksdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU9bnVsbH1Db3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSgpe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcInN0YXJ0IHNhdmluZyBvbiBhIGJhY2tncm91bmQgdGhyZWFkXCIpLHRoaXMuX2FzeW5jU2F2aW5nKXRocm93IG5ldyBFcnJvcihcIlN0b3J5IGlzIGFscmVhZHkgaW4gYmFja2dyb3VuZCBzYXZpbmcgbW9kZSwgY2FuJ3QgY2FsbCBDb3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSBhZ2FpbiFcIik7bGV0IHQ9dGhpcy5fc3RhdGU7cmV0dXJuIHRoaXMuX3N0YXRlPXRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCksdGhpcy5fYXN5bmNTYXZpbmc9ITAsdH1CYWNrZ3JvdW5kU2F2ZUNvbXBsZXRlKCl7bnVsbD09PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lJiZ0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCksdGhpcy5fYXN5bmNTYXZpbmc9ITF9U3RlcCgpe2xldCB0PSEwLGU9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7aWYoZS5pc051bGwpcmV0dXJuO2xldCBuPWEoZS5SZXNvbHZlKCksTik7Zm9yKDtuJiYodGhpcy5WaXNpdENvbnRhaW5lcihuLCEwKSwwIT1uLmNvbnRlbnQubGVuZ3RoKTspZT1JLlN0YXJ0T2Yobiksbj1hKGUuUmVzb2x2ZSgpLE4pO3RoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI9ZS5jb3B5KCksbnVsbCE9dGhpcy5fcHJvZmlsZXImJnRoaXMuX3Byb2ZpbGVyLlN0ZXAodGhpcy5zdGF0ZS5jYWxsU3RhY2spO2xldCBpPWUuUmVzb2x2ZSgpLHI9dGhpcy5QZXJmb3JtTG9naWNBbmRGbG93Q29udHJvbChpKTtpZih0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbClyZXR1cm47ciYmKHQ9ITEpO2xldCBzPWEoaSxXKTtpZihzKXtsZXQgZT10aGlzLlByb2Nlc3NDaG9pY2Uocyk7ZSYmdGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLnB1c2goZSksaT1udWxsLHQ9ITF9aWYoaSBpbnN0YW5jZW9mIE4mJih0PSExKSx0KXtsZXQgdD1hKGksdyk7aWYodCYmLTE9PXQuY29udGV4dEluZGV4KXtsZXQgZT10aGlzLnN0YXRlLmNhbGxTdGFjay5Db250ZXh0Rm9yVmFyaWFibGVOYW1lZCh0LnZhcmlhYmxlTmFtZSk7aT1uZXcgdyh0LnZhcmlhYmxlTmFtZSxlKX10aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24/dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGkpOnRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGkpfXRoaXMuTmV4dENvbnRlbnQoKTtsZXQgbD1hKGksQSk7bCYmbC5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5TdGFydFRocmVhZCYmdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaFRocmVhZCgpfVZpc2l0Q29udGFpbmVyKHQsZSl7dC5jb3VudGluZ0F0U3RhcnRPbmx5JiYhZXx8KHQudmlzaXRzU2hvdWxkQmVDb3VudGVkJiZ0aGlzLnN0YXRlLkluY3JlbWVudFZpc2l0Q291bnRGb3JDb250YWluZXIodCksdC50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQmJnRoaXMuc3RhdGUuUmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcih0KSl9VmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCl7bGV0IHQ9dGhpcy5zdGF0ZS5wcmV2aW91c1BvaW50ZXIuY29weSgpLGU9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7aWYoZS5pc051bGx8fC0xPT1lLmluZGV4KXJldHVybjtpZih0aGlzLl9wcmV2Q29udGFpbmVycy5sZW5ndGg9MCwhdC5pc051bGwpe2xldCBlPWEodC5SZXNvbHZlKCksTil8fGEodC5jb250YWluZXIsTik7Zm9yKDtlOyl0aGlzLl9wcmV2Q29udGFpbmVycy5wdXNoKGUpLGU9YShlLnBhcmVudCxOKX1sZXQgbj1lLlJlc29sdmUoKTtpZihudWxsPT1uKXJldHVybjtsZXQgaT1hKG4ucGFyZW50LE4pO2Zvcig7aSYmKHRoaXMuX3ByZXZDb250YWluZXJzLmluZGV4T2YoaSk8MHx8aS5jb3VudGluZ0F0U3RhcnRPbmx5KTspe2xldCB0PWkuY29udGVudC5sZW5ndGg+MCYmbj09aS5jb250ZW50WzBdO3RoaXMuVmlzaXRDb250YWluZXIoaSx0KSxuPWksaT1hKGkucGFyZW50LE4pfX1Qcm9jZXNzQ2hvaWNlKHQpe2xldCBlPSEwO2lmKHQuaGFzQ29uZGl0aW9uKXtsZXQgdD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO3RoaXMuSXNUcnV0aHkodCl8fChlPSExKX1sZXQgbj1cIlwiLGk9XCJcIjtpZih0Lmhhc0Nob2ljZU9ubHlDb250ZW50KXtpPXModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxUKS52YWx1ZXx8XCJcIn1pZih0Lmhhc1N0YXJ0Q29udGVudCl7bj1zKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksVCkudmFsdWV8fFwiXCJ9aWYodC5vbmNlT25seSl7dGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHQuY2hvaWNlVGFyZ2V0KT4wJiYoZT0hMSl9aWYoIWUpcmV0dXJuIG51bGw7bGV0IHI9bmV3IEQ7cmV0dXJuIHIudGFyZ2V0UGF0aD10LnBhdGhPbkNob2ljZSxyLnNvdXJjZVBhdGg9dC5wYXRoLnRvU3RyaW5nKCksci5pc0ludmlzaWJsZURlZmF1bHQ9dC5pc0ludmlzaWJsZURlZmF1bHQsci50aHJlYWRBdEdlbmVyYXRpb249dGhpcy5zdGF0ZS5jYWxsU3RhY2suRm9ya1RocmVhZCgpLHIudGV4dD0obitpKS5yZXBsYWNlKC9eWyBcXHRdK3xbIFxcdF0rJC9nLFwiXCIpLHJ9SXNUcnV0aHkodCl7aWYodCBpbnN0YW5jZW9mIHYpe2xldCBlPXQ7aWYoZSBpbnN0YW5jZW9mIFApe2xldCB0PWU7cmV0dXJuIHRoaXMuRXJyb3IoXCJTaG91bGRuJ3QgdXNlIGEgZGl2ZXJ0IHRhcmdldCAodG8gXCIrdC50YXJnZXRQYXRoK1wiKSBhcyBhIGNvbmRpdGlvbmFsIHZhbHVlLiBEaWQgeW91IGludGVuZCBhIGZ1bmN0aW9uIGNhbGwgJ2xpa2VUaGlzKCknIG9yIGEgcmVhZCBjb3VudCBjaGVjayAnbGlrZVRoaXMnPyAobm8gYXJyb3dzKVwiKSwhMX1yZXR1cm4gZS5pc1RydXRoeX1yZXR1cm4hMX1QZXJmb3JtTG9naWNBbmRGbG93Q29udHJvbCh0KXtpZihudWxsPT10KXJldHVybiExO2lmKHQgaW5zdGFuY2VvZiBrKXtsZXQgZT10O2lmKGUuaXNDb25kaXRpb25hbCl7bGV0IHQ9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtpZighdGhpcy5Jc1RydXRoeSh0KSlyZXR1cm4hMH1pZihlLmhhc1ZhcmlhYmxlVGFyZ2V0KXtsZXQgdD1lLnZhcmlhYmxlRGl2ZXJ0TmFtZSxuPXRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh0KTtpZihudWxsPT1uKXRoaXMuRXJyb3IoXCJUcmllZCB0byBkaXZlcnQgdXNpbmcgYSB0YXJnZXQgZnJvbSBhIHZhcmlhYmxlIHRoYXQgY291bGQgbm90IGJlIGZvdW5kIChcIit0K1wiKVwiKTtlbHNlIGlmKCEobiBpbnN0YW5jZW9mIFApKXtsZXQgZT1hKG4sYiksaT1cIlRyaWVkIHRvIGRpdmVydCB0byBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUsIGJ1dCB0aGUgdmFyaWFibGUgKFwiK3QrXCIpIGRpZG4ndCBjb250YWluIGEgZGl2ZXJ0IHRhcmdldCwgaXQgXCI7ZSBpbnN0YW5jZW9mIGImJjA9PWUudmFsdWU/aSs9XCJ3YXMgZW1wdHkvbnVsbCAodGhlIHZhbHVlIDApLlwiOmkrPVwiY29udGFpbmVkICdcIituK1wiJy5cIix0aGlzLkVycm9yKGkpfWxldCBpPXMobixQKTt0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlcj10aGlzLlBvaW50ZXJBdFBhdGgoaS50YXJnZXRQYXRoKX1lbHNle2lmKGUuaXNFeHRlcm5hbClyZXR1cm4gdGhpcy5DYWxsRXh0ZXJuYWxGdW5jdGlvbihlLnRhcmdldFBhdGhTdHJpbmcsZS5leHRlcm5hbEFyZ3MpLCEwO3RoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyPWUudGFyZ2V0UG9pbnRlci5jb3B5KCl9cmV0dXJuIGUucHVzaGVzVG9TdGFjayYmdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChlLnN0YWNrUHVzaFR5cGUsdm9pZCAwLHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCksdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsJiYhZS5pc0V4dGVybmFsJiYoZSYmZS5kZWJ1Z01ldGFkYXRhJiZudWxsIT1lLmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZT90aGlzLkVycm9yKFwiRGl2ZXJ0IHRhcmdldCBkb2Vzbid0IGV4aXN0OiBcIitlLmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZSk6dGhpcy5FcnJvcihcIkRpdmVydCByZXNvbHV0aW9uIGZhaWxlZDogXCIrZSkpLCEwfWlmKHQgaW5zdGFuY2VvZiBBKXtsZXQgZT10O3N3aXRjaChlLmNvbW1hbmRUeXBlKXtjYXNlIEEuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0OnRoaXMuQXNzZXJ0KCExPT09dGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uLFwiQWxyZWFkeSBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24/XCIpLHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj0hMDticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRXZhbEVuZDp0aGlzLkFzc2VydCghMD09PXRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbixcIk5vdCBpbiBleHByZXNzaW9uIGV2YWx1YXRpb24gbW9kZVwiKSx0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb249ITE7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXQ6aWYodGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoPjApe2xldCB0PXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7aWYoISh0IGluc3RhbmNlb2YgTCkpe2xldCBlPW5ldyBUKHQudG9TdHJpbmcoKSk7dGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oZSl9fWJyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5Ob09wOmJyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5EdXBsaWNhdGU6dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKHRoaXMuc3RhdGUuUGVla0V2YWx1YXRpb25TdGFjaygpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWU6dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb246Y2FzZSBBLkNvbW1hbmRUeXBlLlBvcFR1bm5lbDpsZXQgdD1lLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uP3IuRnVuY3Rpb246ci5UdW5uZWwsbj1udWxsO2lmKHQ9PXIuVHVubmVsKXtsZXQgdD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO249YSh0LFApLG51bGw9PT1uJiZ0aGlzLkFzc2VydCh0IGluc3RhbmNlb2YgTCxcIkV4cGVjdGVkIHZvaWQgaWYgLT4tPiBkb2Vzbid0IG92ZXJyaWRlIHRhcmdldFwiKX1pZih0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpKWJyZWFrO2lmKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGU9PXQmJnRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcCl0aGlzLnN0YXRlLlBvcENhbGxTdGFjaygpLG4mJih0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlcj10aGlzLlBvaW50ZXJBdFBhdGgobi50YXJnZXRQYXRoKSk7ZWxzZXtsZXQgZT1uZXcgTWFwO2Uuc2V0KHIuRnVuY3Rpb24sXCJmdW5jdGlvbiByZXR1cm4gc3RhdGVtZW50ICh+IHJldHVybilcIiksZS5zZXQoci5UdW5uZWwsXCJ0dW5uZWwgb253YXJkcyBzdGF0ZW1lbnQgKC0+LT4pXCIpO2xldCBuPWUuZ2V0KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUpO3RoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcHx8KG49XCJlbmQgb2YgZmxvdyAoLT4gRU5EIG9yIGNob2ljZSlcIik7bGV0IGk9XCJGb3VuZCBcIitlLmdldCh0KStcIiwgd2hlbiBleHBlY3RlZCBcIituO3RoaXMuRXJyb3IoaSl9YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nOnRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGUpLHRoaXMuQXNzZXJ0KCEwPT09dGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uLFwiRXhwZWN0ZWQgdG8gYmUgaW4gYW4gZXhwcmVzc2lvbiB3aGVuIGV2YWx1YXRpbmcgYSBzdHJpbmdcIiksdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPSExO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5FbmRTdHJpbmc6bGV0IGk9W10sbD0wO2ZvcihsZXQgdD10aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgtMTt0Pj0wOy0tdCl7bGV0IGU9dGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1bdF07bCsrO2xldCBuPWEoZSxBKTtpZihuJiZuLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKWJyZWFrO2UgaW5zdGFuY2VvZiBUJiZpLnB1c2goZSl9dGhpcy5zdGF0ZS5Qb3BGcm9tT3V0cHV0U3RyZWFtKGwpLGk9aS5yZXZlcnNlKCk7bGV0IG89bmV3IG07Zm9yKGxldCB0IG9mIGkpby5BcHBlbmQodC50b1N0cmluZygpKTt0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb249ITAsdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBUKG8udG9TdHJpbmcoKSkpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5DaG9pY2VDb3VudDpsZXQgdT10aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMubGVuZ3RoO3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYih1KSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlR1cm5zOnRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYih0aGlzLnN0YXRlLmN1cnJlbnRUdXJuSW5kZXgrMSkpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5UdXJuc1NpbmNlOmNhc2UgQS5Db21tYW5kVHlwZS5SZWFkQ291bnQ6bGV0IGg9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtpZighKGggaW5zdGFuY2VvZiBQKSl7bGV0IHQ9XCJcIjtoIGluc3RhbmNlb2YgYiYmKHQ9XCIuIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgYSByZWFkIGNvdW50ICgna25vdF9uYW1lJykgaW5zdGVhZCBvZiBhIHRhcmdldCAoJy0+IGtub3RfbmFtZScpP1wiKSx0aGlzLkVycm9yKFwiVFVSTlNfU0lOQ0UgLyBSRUFEX0NPVU5UIGV4cGVjdGVkIGEgZGl2ZXJ0IHRhcmdldCAoa25vdCwgc3RpdGNoLCBsYWJlbCBuYW1lKSwgYnV0IHNhdyBcIitoK3QpO2JyZWFrfWxldCBjLHA9cyhoLFApLHk9YSh0aGlzLkNvbnRlbnRBdFBhdGgocC50YXJnZXRQYXRoKS5jb3JyZWN0T2JqLE4pO251bGwhPXk/Yz1lLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLlR1cm5zU2luY2U/dGhpcy5zdGF0ZS5UdXJuc1NpbmNlRm9yQ29udGFpbmVyKHkpOnRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcih5KTooYz1lLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLlR1cm5zU2luY2U/LTE6MCx0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250YWluZXIgZm9yIFwiK2UudG9TdHJpbmcoKStcIiBsb29rdXAgYXQgXCIrcC50YXJnZXRQYXRoLnRvU3RyaW5nKCkpKSx0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIoYykpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5SYW5kb206e2xldCB0PWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKSxlPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKTtpZihudWxsPT1lfHxlIGluc3RhbmNlb2YgYj09ITEpcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtaW5pbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO2lmKG51bGw9PXR8fGUgaW5zdGFuY2VvZiBiPT0hMSlyZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG1heGltdW0gcGFyYW1ldGVyIG9mIFJBTkRPTShtaW4sIG1heClcIik7aWYobnVsbD09PXQudmFsdWUpcmV0dXJuIGQoXCJtYXhJbnQudmFsdWVcIik7aWYobnVsbD09PWUudmFsdWUpcmV0dXJuIGQoXCJtaW5JbnQudmFsdWVcIik7bGV0IG49dC52YWx1ZS1lLnZhbHVlKzE7bjw9MCYmdGhpcy5FcnJvcihcIlJBTkRPTSB3YXMgY2FsbGVkIHdpdGggbWluaW11bSBhcyBcIitlLnZhbHVlK1wiIGFuZCBtYXhpbXVtIGFzIFwiK3QudmFsdWUrXCIuIFRoZSBtYXhpbXVtIG11c3QgYmUgbGFyZ2VyXCIpO2xldCBpPXRoaXMuc3RhdGUuc3RvcnlTZWVkK3RoaXMuc3RhdGUucHJldmlvdXNSYW5kb20scj1uZXcgSyhpKS5uZXh0KCkscz1yJW4rZS52YWx1ZTt0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIocykpLHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb209cjticmVha31jYXNlIEEuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbTpsZXQgQz1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYik7aWYobnVsbD09Q3x8QyBpbnN0YW5jZW9mIGI9PSExKXJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gU0VFRF9SQU5ET01cIik7aWYobnVsbD09PUMudmFsdWUpcmV0dXJuIGQoXCJtaW5JbnQudmFsdWVcIik7dGhpcy5zdGF0ZS5zdG9yeVNlZWQ9Qy52YWx1ZSx0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tPTAsdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBMKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuVmlzaXRJbmRleDpsZXQgXz10aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXIpLTE7dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKF8pKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXg6bGV0IHc9dGhpcy5OZXh0U2VxdWVuY2VTaHVmZmxlSW5kZXgoKTt0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIodykpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5TdGFydFRocmVhZDpicmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRG9uZTp0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQ/dGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCk6KHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQ9ITAsdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcj1JLk51bGwpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5FbmQ6dGhpcy5zdGF0ZS5Gb3JjZUVuZCgpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5MaXN0RnJvbUludDpsZXQgRT1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYikseD1zKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksVCk7aWYobnVsbD09PUUpdGhyb3cgbmV3IFMoXCJQYXNzZWQgbm9uLWludGVnZXIgd2hlbiBjcmVhdGluZyBhIGxpc3QgZWxlbWVudCBmcm9tIGEgbnVtZXJpY2FsIHZhbHVlLlwiKTtsZXQgaz1udWxsO2lmKG51bGw9PT10aGlzLmxpc3REZWZpbml0aW9ucylyZXR1cm4gZChcInRoaXMubGlzdERlZmluaXRpb25zXCIpO2xldCBXPXRoaXMubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKHgudmFsdWUsbnVsbCk7aWYoIVcuZXhpc3RzKXRocm93IG5ldyBTKFwiRmFpbGVkIHRvIGZpbmQgTElTVCBjYWxsZWQgXCIreC52YWx1ZSk7e2lmKG51bGw9PT1FLnZhbHVlKXJldHVybiBkKFwibWluSW50LnZhbHVlXCIpO2xldCB0PVcucmVzdWx0LlRyeUdldEl0ZW1XaXRoVmFsdWUoRS52YWx1ZSxmLk51bGwpO3QuZXhpc3RzJiYoaz1uZXcgTyh0LnJlc3VsdCxFLnZhbHVlKSl9bnVsbD09ayYmKGs9bmV3IE8pLHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhrKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuTGlzdFJhbmdlOmxldCBGPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSx2KSxWPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSx2KSxSPWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxPKTtpZihudWxsPT09Unx8bnVsbD09PVZ8fG51bGw9PT1GKXRocm93IG5ldyBTKFwiRXhwZWN0ZWQgbGlzdCwgbWluaW11bSBhbmQgbWF4aW11bSBmb3IgTElTVF9SQU5HRVwiKTtpZihudWxsPT09Ui52YWx1ZSlyZXR1cm4gZChcInRhcmdldExpc3QudmFsdWVcIik7bGV0IGo9Ui52YWx1ZS5MaXN0V2l0aFN1YlJhbmdlKFYudmFsdWVPYmplY3QsRi52YWx1ZU9iamVjdCk7dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBPKGopKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbTp7bGV0IHQ9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtpZihudWxsPT09dCl0aHJvdyBuZXcgUyhcIkV4cGVjdGVkIGxpc3QgZm9yIExJU1RfUkFORE9NXCIpO2xldCBlPXQudmFsdWUsbj1udWxsO2lmKG51bGw9PT1lKXRocm93IGQoXCJsaXN0XCIpO2lmKDA9PWUuQ291bnQpbj1uZXcgZztlbHNle2xldCB0PXRoaXMuc3RhdGUuc3RvcnlTZWVkK3RoaXMuc3RhdGUucHJldmlvdXNSYW5kb20saT1uZXcgSyh0KS5uZXh0KCkscj1pJWUuQ291bnQsYT1lLmVudHJpZXMoKTtmb3IobGV0IHQ9MDt0PD1yLTE7dCsrKWEubmV4dCgpO2xldCBzPWEubmV4dCgpLnZhbHVlLGw9e0tleTpmLmZyb21TZXJpYWxpemVkS2V5KHNbMF0pLFZhbHVlOnNbMV19O2lmKG51bGw9PT1sLktleS5vcmlnaW5OYW1lKXJldHVybiBkKFwicmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZVwiKTtuPW5ldyBnKGwuS2V5Lm9yaWdpbk5hbWUsdGhpcyksbi5BZGQobC5LZXksbC5WYWx1ZSksdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbT1pfXRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgTyhuKSk7YnJlYWt9ZGVmYXVsdDp0aGlzLkVycm9yKFwidW5oYW5kbGVkIENvbnRyb2xDb21tYW5kOiBcIitlKX1yZXR1cm4hMH1pZih0IGluc3RhbmNlb2YgVil7bGV0IGU9dCxuPXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7cmV0dXJuIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuQXNzaWduKGUsbiksITB9aWYodCBpbnN0YW5jZW9mIEYpe2xldCBlPXQsbj1udWxsO2lmKG51bGwhPWUucGF0aEZvckNvdW50KXtsZXQgdD1lLmNvbnRhaW5lckZvckNvdW50LGk9dGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHQpO249bmV3IGIoaSl9ZWxzZSBuPXRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZShlLm5hbWUpLG51bGw9PW4mJih0aGlzLldhcm5pbmcoXCJWYXJpYWJsZSBub3QgZm91bmQ6ICdcIitlLm5hbWUrXCInLiBVc2luZyBkZWZhdWx0IHZhbHVlIG9mIDAgKGZhbHNlKS4gVGhpcyBjYW4gaGFwcGVuIHdpdGggdGVtcG9yYXJ5IHZhcmlhYmxlcyBpZiB0aGUgZGVjbGFyYXRpb24gaGFzbid0IHlldCBiZWVuIGhpdC4gR2xvYmFscyBhcmUgYWx3YXlzIGdpdmVuIGEgZGVmYXVsdCB2YWx1ZSBvbiBsb2FkIGlmIGEgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2F2ZSBzdGF0ZS5cIiksbj1uZXcgYigwKSk7cmV0dXJuIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuKSwhMH1pZih0IGluc3RhbmNlb2YgUil7bGV0IGU9dCxuPXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKGUubnVtYmVyT2ZQYXJhbWV0ZXJzKSxpPWUuQ2FsbChuKTtyZXR1cm4gdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGkpLCEwfXJldHVybiExfUNob29zZVBhdGhTdHJpbmcodCxuPSEwLGk9W10pe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgQ2hvb3NlUGF0aFN0cmluZyByaWdodCBub3dcIiksbil0aGlzLlJlc2V0Q2FsbHN0YWNrKCk7ZWxzZSBpZih0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlPT1yLkZ1bmN0aW9uKXtsZXQgZT1cIlwiLG49dGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29udGFpbmVyO3Rocm93IG51bGwhPW4mJihlPVwiKFwiK24ucGF0aC50b1N0cmluZygpK1wiKSBcIiksbmV3IEVycm9yKFwiU3Rvcnkgd2FzIHJ1bm5pbmcgYSBmdW5jdGlvbiBcIitlK1wid2hlbiB5b3UgY2FsbGVkIENob29zZVBhdGhTdHJpbmcoXCIrdCtcIikgLSB0aGlzIGlzIGFsbW9zdCBjZXJ0YWlubHkgbm90IG5vdCB3aGF0IHlvdSB3YW50ISBGdWxsIHN0YWNrIHRyYWNlOiBcXG5cIit0aGlzLnN0YXRlLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSl9dGhpcy5zdGF0ZS5QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soaSksdGhpcy5DaG9vc2VQYXRoKG5ldyBlKHQpKX1JZkFzeW5jV2VDYW50KHQpe2lmKHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgXCIrdCtcIi4gU3RvcnkgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIENvbnRpbnVlQXN5bmMoKS4gTWFrZSBtb3JlIENvbnRpbnVlQXN5bmMoKSBjYWxscyBvciBhIHNpbmdsZSBDb250aW51ZSgpIGNhbGwgYmVmb3JlaGFuZC5cIil9Q2hvb3NlUGF0aCh0LGU9ITApe3RoaXMuc3RhdGUuU2V0Q2hvc2VuUGF0aCh0LGUpLHRoaXMuVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCl9Q2hvb3NlQ2hvaWNlSW5kZXgodCl7dD10O2xldCBlPXRoaXMuY3VycmVudENob2ljZXM7dGhpcy5Bc3NlcnQodD49MCYmdDxlLmxlbmd0aCxcImNob2ljZSBvdXQgb2YgcmFuZ2VcIik7bGV0IG49ZVt0XTtyZXR1cm4gbnVsbD09PW4udGhyZWFkQXRHZW5lcmF0aW9uP2QoXCJjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb25cIik6bnVsbD09PW4udGFyZ2V0UGF0aD9kKFwiY2hvaWNlVG9DaG9vc2UudGFyZ2V0UGF0aFwiKToodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZD1uLnRocmVhZEF0R2VuZXJhdGlvbix2b2lkIHRoaXMuQ2hvb3NlUGF0aChuLnRhcmdldFBhdGgpKX1IYXNGdW5jdGlvbih0KXt0cnl7cmV0dXJuIG51bGwhPXRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKHQpfWNhdGNoKHQpe3JldHVybiExfX1FdmFsdWF0ZUZ1bmN0aW9uKHQsZT1bXSxuPSExKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJldmFsdWF0ZSBhIGZ1bmN0aW9uXCIpLG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgbnVsbFwiKTtpZihcIlwiPT10fHxcIlwiPT10LnRyaW0oKSl0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBlbXB0eSBvciB3aGl0ZSBzcGFjZS5cIik7bGV0IGk9dGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUodCk7aWYobnVsbD09aSl0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBkb2Vzbid0IGV4aXN0OiAnXCIrdCtcIidcIik7bGV0IHI9W107ci5wdXNoLmFwcGx5KHIsdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0pLHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCksdGhpcy5zdGF0ZS5TdGFydEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKGksZSk7bGV0IGE9bmV3IG07Zm9yKDt0aGlzLmNhbkNvbnRpbnVlOylhLkFwcGVuZCh0aGlzLkNvbnRpbnVlKCkpO2xldCBzPWEudG9TdHJpbmcoKTt0aGlzLl9zdGF0ZS5SZXNldE91dHB1dChyKTtsZXQgbD10aGlzLnN0YXRlLkNvbXBsZXRlRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKTtyZXR1cm4gbj97cmV0dXJuZWQ6bCxvdXRwdXQ6c306bH1FdmFsdWF0ZUV4cHJlc3Npb24odCl7bGV0IGU9dGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoO3RoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goci5UdW5uZWwpLHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI9dCx0aGlzLnN0YXRlLkdvVG9TdGFydCgpO2xldCBuPXRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aDtyZXR1cm4gdGhpcy5Db250aW51ZSgpLHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI9bnVsbCx0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGg+ZSYmdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKSx0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg+bj90aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpOm51bGx9Q2FsbEV4dGVybmFsRnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gZChcImZ1bmNOYW1lXCIpO2xldCBuPXRoaXMuX2V4dGVybmFscy5nZXQodCksaT1udWxsO2lmKCEodm9pZCAwIT09bikpe2lmKHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzKXJldHVybiBpPXRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKHQpLHRoaXMuQXNzZXJ0KG51bGwhPT1pLFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiK3QrXCInIHdoaWNoIGhhcyBub3QgYmVlbiBib3VuZCwgYW5kIGZhbGxiYWNrIGluayBmdW5jdGlvbiBjb3VsZCBub3QgYmUgZm91bmQuXCIpLHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goci5GdW5jdGlvbix2b2lkIDAsdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKSx2b2lkKHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyPUkuU3RhcnRPZihpKSk7dGhpcy5Bc3NlcnQoITEsXCJUcnlpbmcgdG8gY2FsbCBFWFRFUk5BTCBmdW5jdGlvbiAnXCIrdCtcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kIChhbmQgaW5rIGZhbGxiYWNrcyBkaXNhYmxlZCkuXCIpfWxldCBhPVtdO2ZvcihsZXQgdD0wO3Q8ZTsrK3Qpe2xldCB0PXModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSx2KS52YWx1ZU9iamVjdDthLnB1c2godCl9YS5yZXZlcnNlKCk7bGV0IGw9bihhKSxvPW51bGw7bnVsbCE9bD8obz12LkNyZWF0ZShsKSx0aGlzLkFzc2VydChudWxsIT09byxcIkNvdWxkIG5vdCBjcmVhdGUgaW5rIHZhbHVlIGZyb20gcmV0dXJuZWQgb2JqZWN0IG9mIHR5cGUgXCIrdHlwZW9mIGwpKTpvPW5ldyBMLHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhvKX1CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwodCxlKXt0aGlzLklmQXN5bmNXZUNhbnQoXCJiaW5kIGFuIGV4dGVybmFsIGZ1bmN0aW9uXCIpLHRoaXMuQXNzZXJ0KCF0aGlzLl9leHRlcm5hbHMuaGFzKHQpLFwiRnVuY3Rpb24gJ1wiK3QrXCInIGhhcyBhbHJlYWR5IGJlZW4gYm91bmQuXCIpLHRoaXMuX2V4dGVybmFscy5zZXQodCxlKX1UcnlDb2VyY2UodCl7cmV0dXJuIHR9QmluZEV4dGVybmFsRnVuY3Rpb24odCxlKXt0aGlzLkFzc2VydChudWxsIT1lLFwiQ2FuJ3QgYmluZCBhIG51bGwgZnVuY3Rpb25cIiksdGhpcy5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwodCx0PT57dGhpcy5Bc3NlcnQodC5sZW5ndGg+PWUubGVuZ3RoLFwiRXh0ZXJuYWwgZnVuY3Rpb24gZXhwZWN0ZWQgXCIrZS5sZW5ndGgrXCIgYXJndW1lbnRzXCIpO2xldCBuPVtdO2ZvcihsZXQgZT0wLGk9dC5sZW5ndGg7ZTxpO2UrKyluW2VdPXRoaXMuVHJ5Q29lcmNlKHRbZV0pO3JldHVybiBlLmFwcGx5KG51bGwsbil9KX1VbmJpbmRFeHRlcm5hbEZ1bmN0aW9uKHQpe3RoaXMuSWZBc3luY1dlQ2FudChcInVuYmluZCBhbiBleHRlcm5hbCBhIGZ1bmN0aW9uXCIpLHRoaXMuQXNzZXJ0KHRoaXMuX2V4dGVybmFscy5oYXModCksXCJGdW5jdGlvbiAnXCIrdCtcIicgaGFzIG5vdCBiZWVuIGJvdW5kLlwiKSx0aGlzLl9leHRlcm5hbHMuZGVsZXRlKHQpfVZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncygpe2xldCB0PW51bGwsZT1udWxsLG49YXJndW1lbnRzWzFdfHxuZXcgU2V0O2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTiYmKHQ9YXJndW1lbnRzWzBdKSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHAmJihlPWFyZ3VtZW50c1swXSksbnVsbD09PXQmJm51bGw9PT1lKWlmKHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLG4pLHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscz0hMCwwPT1uLnNpemUpdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzPSEwO2Vsc2V7bGV0IHQ9XCJFcnJvcjogTWlzc2luZyBmdW5jdGlvbiBiaW5kaW5nIGZvciBleHRlcm5hbFwiO3QrPW4uc2l6ZT4xP1wic1wiOlwiXCIsdCs9XCI6ICdcIix0Kz1BcnJheS5mcm9tKG4pLmpvaW4oXCInLCAnXCIpLHQrPVwiJyBcIix0Kz10aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcz9cIiwgYW5kIG5vIGZhbGxiYWNrIGluayBmdW5jdGlvbiBmb3VuZC5cIjpcIiAoaW5rIGZhbGxiYWNrcyBkaXNhYmxlZClcIix0aGlzLkVycm9yKHQpfWVsc2UgaWYobnVsbCE9dCl7Zm9yKGxldCBlIG9mIHQuY29udGVudCl7bGV0IHQ9ZTtudWxsIT10JiZ0Lmhhc1ZhbGlkTmFtZXx8dGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoZSxuKX1mb3IobGV0WyxlXW9mIHQubmFtZWRDb250ZW50KXRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKGEoZSxwKSxuKX1lbHNlIGlmKG51bGwhPWUpe2xldCB0PWEoZSxrKTtpZih0JiZ0LmlzRXh0ZXJuYWwpe2xldCBlPXQudGFyZ2V0UGF0aFN0cmluZztpZihudWxsPT09ZSlyZXR1cm4gZChcIm5hbWVcIik7aWYoIXRoaXMuX2V4dGVybmFscy5oYXMoZSkpaWYodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3Mpe3RoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmhhcyhlKXx8bi5hZGQoZSl9ZWxzZSBuLmFkZChlKX19fU9ic2VydmVWYXJpYWJsZSh0LGUpe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcIm9ic2VydmUgYSBuZXcgdmFyaWFibGVcIiksbnVsbD09PXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzJiYodGhpcy5fdmFyaWFibGVPYnNlcnZlcnM9bmV3IE1hcCksIXRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh0KSl0aHJvdyBuZXcgUyhcIkNhbm5vdCBvYnNlcnZlIHZhcmlhYmxlICdcIit0K1wiJyBiZWNhdXNlIGl0IHdhc24ndCBkZWNsYXJlZCBpbiB0aGUgaW5rIHN0b3J5LlwiKTt0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXModCk/dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHQpLnB1c2goZSk6dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuc2V0KHQsW2VdKX1PYnNlcnZlVmFyaWFibGVzKHQsZSl7Zm9yKGxldCBuPTAsaT10Lmxlbmd0aDtuPGk7bisrKXRoaXMuT2JzZXJ2ZVZhcmlhYmxlKHRbbl0sZVtuXSl9UmVtb3ZlVmFyaWFibGVPYnNlcnZlcih0LGUpe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcInJlbW92ZSBhIHZhcmlhYmxlIG9ic2VydmVyXCIpLG51bGwhPT10aGlzLl92YXJpYWJsZU9ic2VydmVycylpZih2b2lkIDAhPT1lKXtpZih0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXMoZSkpe2xldCBuPXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldChlKTtudWxsIT09dD9uLnNwbGljZShuLmluZGV4T2YodCksMSk6dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZGVsZXRlKGUpfX1lbHNlIGlmKG51bGwhPT10KXtsZXQgZT10aGlzLl92YXJpYWJsZU9ic2VydmVycy5rZXlzKCk7Zm9yKGxldCBuIG9mIGUpe2xldCBlPXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldChuKTtlLnNwbGljZShlLmluZGV4T2YodCksMSl9fX1WYXJpYWJsZVN0YXRlRGlkQ2hhbmdlRXZlbnQodCxlKXtpZihudWxsPT09dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMpcmV0dXJuO2xldCBuPXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh0KTtpZih2b2lkIDAhPT1uKXtpZighKGUgaW5zdGFuY2VvZiB2KSl0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBnZXQgdGhlIHZhbHVlIG9mIGEgdmFyaWFibGUgdGhhdCBpc24ndCBhIHN0YW5kYXJkIHR5cGVcIik7bGV0IGk9cyhlLHYpO2ZvcihsZXQgZSBvZiBuKWUodCxpLnZhbHVlT2JqZWN0KX19Z2V0IGdsb2JhbFRhZ3MoKXtyZXR1cm4gdGhpcy5UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKFwiXCIpfVRhZ3NGb3JDb250ZW50QXRQYXRoKHQpe3JldHVybiB0aGlzLlRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcodCl9VGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyh0KXtsZXQgbj1uZXcgZSh0KSxpPXRoaXMuQ29udGVudEF0UGF0aChuKS5jb250YWluZXI7aWYobnVsbD09PWkpcmV0dXJuIGQoXCJmbG93Q29udGFpbmVyXCIpO2Zvcig7Oyl7bGV0IHQ9aS5jb250ZW50WzBdO2lmKCEodCBpbnN0YW5jZW9mIE4pKWJyZWFrO2k9dH1sZXQgcj1udWxsO2ZvcihsZXQgdCBvZiBpLmNvbnRlbnQpe2xldCBlPWEodCxqKTtpZighZSlicmVhaztudWxsPT1yJiYocj1bXSksci5wdXNoKGUudGV4dCl9cmV0dXJuIHJ9QnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpe2xldCB0PW5ldyBtO3JldHVybiB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkodCwwLHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuUmVzb2x2ZSgpKSx0LnRvU3RyaW5nKCl9QnVpbGRTdHJpbmdPZkNvbnRhaW5lcih0KXtsZXQgZT1uZXcgbTtyZXR1cm4gdC5CdWlsZFN0cmluZ09mSGllcmFyY2h5KGUsMCx0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLlJlc29sdmUoKSksZS50b1N0cmluZygpfU5leHRDb250ZW50KCl7aWYodGhpcy5zdGF0ZS5wcmV2aW91c1BvaW50ZXI9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCksIXRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCYmKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI9dGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuY29weSgpLHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyPUkuTnVsbCx0aGlzLlZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpLCF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkpcmV0dXJuO2lmKCF0aGlzLkluY3JlbWVudENvbnRlbnRQb2ludGVyKCkpe2xldCB0PSExO3RoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChyLkZ1bmN0aW9uKT8odGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soci5GdW5jdGlvbiksdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uJiZ0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IEwpLHQ9ITApOnRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZD8odGhpcy5zdGF0ZS5jYWxsU3RhY2suUG9wVGhyZWFkKCksdD0hMCk6dGhpcy5zdGF0ZS5UcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSx0JiYhdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwmJnRoaXMuTmV4dENvbnRlbnQoKX19SW5jcmVtZW50Q29udGVudFBvaW50ZXIoKXtsZXQgdD0hMCxlPXRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKTtpZihlLmluZGV4KyssbnVsbD09PWUuY29udGFpbmVyKXJldHVybiBkKFwicG9pbnRlci5jb250YWluZXJcIik7Zm9yKDtlLmluZGV4Pj1lLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aDspe3Q9ITE7bGV0IG49YShlLmNvbnRhaW5lci5wYXJlbnQsTik7aWYobiBpbnN0YW5jZW9mIE49PSExKWJyZWFrO2xldCBpPW4uY29udGVudC5pbmRleE9mKGUuY29udGFpbmVyKTtpZigtMT09aSlicmVhaztpZihlPW5ldyBJKG4saSksZS5pbmRleCsrLHQ9ITAsbnVsbD09PWUuY29udGFpbmVyKXJldHVybiBkKFwicG9pbnRlci5jb250YWluZXJcIil9cmV0dXJuIHR8fChlPUkuTnVsbCksdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXI9ZS5jb3B5KCksdH1UcnlGb2xsb3dEZWZhdWx0SW52aXNpYmxlQ2hvaWNlKCl7bGV0IHQ9dGhpcy5fc3RhdGUuY3VycmVudENob2ljZXMsZT10LmZpbHRlcih0PT50LmlzSW52aXNpYmxlRGVmYXVsdCk7aWYoMD09ZS5sZW5ndGh8fHQubGVuZ3RoPmUubGVuZ3RoKXJldHVybiExO2xldCBuPWVbMF07cmV0dXJuIG51bGw9PT1uLnRhcmdldFBhdGg/ZChcImNob2ljZS50YXJnZXRQYXRoXCIpOm51bGw9PT1uLnRocmVhZEF0R2VuZXJhdGlvbj9kKFwiY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvblwiKToodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudFRocmVhZD1uLnRocmVhZEF0R2VuZXJhdGlvbix0aGlzLkNob29zZVBhdGgobi50YXJnZXRQYXRoLCExKSwhMCl9TmV4dFNlcXVlbmNlU2h1ZmZsZUluZGV4KCl7bGV0IHQ9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpO2lmKCEodCBpbnN0YW5jZW9mIGIpKXJldHVybiB0aGlzLkVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHNlcXVlbmNlIGZvciBzaHVmZmxlIGluZGV4XCIpLDA7bGV0IGU9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXI7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJzZXFDb250YWluZXJcIik7aWYobnVsbD09PXQudmFsdWUpcmV0dXJuIGQoXCJudW1FbGVtZW50c0ludFZhbC52YWx1ZVwiKTtsZXQgbj10LnZhbHVlLGk9cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpLnZhbHVlO2lmKG51bGw9PT1pKXJldHVybiBkKFwic2VxQ291bnRcIik7bGV0IHI9aS9uLGw9aSVuLG89ZS5wYXRoLnRvU3RyaW5nKCksdT0wO2ZvcihsZXQgdD0wLGU9by5sZW5ndGg7dDxlO3QrKyl1Kz1vLmNoYXJDb2RlQXQodCl8fDA7bGV0IGg9dStyK3RoaXMuc3RhdGUuc3RvcnlTZWVkLGM9bmV3IEsoTWF0aC5mbG9vcihoKSkscD1bXTtmb3IobGV0IHQ9MDt0PG47Kyt0KXAucHVzaCh0KTtmb3IobGV0IHQ9MDt0PD1sOysrdCl7bGV0IGU9Yy5uZXh0KCklcC5sZW5ndGgsbj1wW2VdO2lmKHAuc3BsaWNlKGUsMSksdD09bClyZXR1cm4gbn10aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKX1FcnJvcih0LGU9ITEpe2xldCBuPW5ldyBTKHQpO3Rocm93IG4udXNlRW5kTGluZU51bWJlcj1lLG59V2FybmluZyh0KXt0aGlzLkFkZEVycm9yKHQsITApfUFkZEVycm9yKHQsZT0hMSxuPSExKXtsZXQgaT10aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhLHI9ZT9cIldBUk5JTkdcIjpcIkVSUk9SXCI7aWYobnVsbCE9aSl7bGV0IGU9bj9pLmVuZExpbmVOdW1iZXI6aS5zdGFydExpbmVOdW1iZXI7dD1cIlJVTlRJTUUgXCIrcitcIjogJ1wiK2kuZmlsZU5hbWUrXCInIGxpbmUgXCIrZStcIjogXCIrdH1lbHNlIHQ9dGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGw/XCJSVU5USU1FIFwiK3IrXCI6IFwiK3Q6XCJSVU5USU1FIFwiK3IrXCI6IChcIit0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyK1wiKTogXCIrdDt0aGlzLnN0YXRlLkFkZEVycm9yKHQsZSksZXx8dGhpcy5zdGF0ZS5Gb3JjZUVuZCgpfUFzc2VydCh0LGU9bnVsbCl7aWYoMD09dCl0aHJvdyBudWxsPT1lJiYoZT1cIlN0b3J5IGFzc2VydFwiKSxuZXcgRXJyb3IoZStcIiBcIit0aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhKX1nZXQgY3VycmVudERlYnVnTWV0YWRhdGEoKXtsZXQgdCxlPXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI7aWYoIWUuaXNOdWxsJiZudWxsIT09ZS5SZXNvbHZlKCkmJih0PWUuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGEsbnVsbCE9PXQpKXJldHVybiB0O2ZvcihsZXQgbj10aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGgtMTtuPj0wOy0tbilpZihlPXRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzW25dLmN1cnJlbnRQb2ludGVyLCFlLmlzTnVsbCYmbnVsbCE9PWUuUmVzb2x2ZSgpJiYodD1lLlJlc29sdmUoKS5kZWJ1Z01ldGFkYXRhLG51bGwhPT10KSlyZXR1cm4gdDtmb3IobGV0IGU9dGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7ZT49MDstLWUpe2lmKHQ9dGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1bZV0uZGVidWdNZXRhZGF0YSxudWxsIT09dClyZXR1cm4gdH1yZXR1cm4gbnVsbH1nZXQgbWFpbkNvbnRlbnRDb250YWluZXIoKXtyZXR1cm4gdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcj90aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyOnRoaXMuX21haW5Db250ZW50Q29udGFpbmVyfX1YLmlua1ZlcnNpb25DdXJyZW50PTE5LGZ1bmN0aW9uKHQpe2xldCBlOyFmdW5jdGlvbih0KXt0W3QuTm9DaGFuZ2U9MF09XCJOb0NoYW5nZVwiLHRbdC5FeHRlbmRlZEJleW9uZE5ld2xpbmU9MV09XCJFeHRlbmRlZEJleW9uZE5ld2xpbmVcIix0W3QuTmV3bGluZVJlbW92ZWQ9Ml09XCJOZXdsaW5lUmVtb3ZlZFwifShlPXQuT3V0cHV0U3RhdGVDaGFuZ2V8fCh0Lk91dHB1dFN0YXRlQ2hhbmdlPXt9KSl9KFh8fChYPXt9KSksdC5JbmtMaXN0PWcsdC5TdG9yeT1YLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5rLWVzMjAxNS5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsU3RhY2sgPSB2b2lkIDA7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFN0b3J5XzEgPSByZXF1aXJlKFwiLi9TdG9yeVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgQ2FsbFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFN0b3J5XzEuU3RvcnkpIHtcbiAgICAgICAgICAgIGxldCBzdG9yeUNvbnRleHQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2Yoc3RvcnlDb250ZXh0LnJvb3RDb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b0NvcHkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBvdGhlclRocmVhZCBvZiB0b0NvcHkuX3RocmVhZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2gob3RoZXJUaHJlYWQuQ29weSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIgPSB0b0NvcHkuX3RocmVhZENvdW50ZXI7XG4gICAgICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IHRvQ29weS5fc3RhcnRPZlJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2s7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVsZW1lbnQoKSB7XG4gICAgICAgIGxldCB0aHJlYWQgPSB0aGlzLl90aHJlYWRzW3RoaXMuX3RocmVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBjcyA9IHRocmVhZC5jYWxsc3RhY2s7XG4gICAgICAgIHJldHVybiBjc1tjcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbGVtZW50SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRUaHJlYWQodmFsdWUpIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5fdGhyZWFkcy5sZW5ndGggPT0gMSwgXCJTaG91bGRuJ3QgYmUgZGlyZWN0bHkgc2V0dGluZyB0aGUgY3VycmVudCB0aHJlYWQgd2hlbiB3ZSBoYXZlIGEgc3RhY2sgb2YgdGhlbVwiKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBnZXQgY2FuUG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2subGVuZ3RoID4gMTtcbiAgICB9XG4gICAgUmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3RocmVhZHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKG5ldyBDYWxsU3RhY2suVGhyZWFkKCkpO1xuICAgICAgICB0aGlzLl90aHJlYWRzWzBdLmNhbGxzdGFjay5wdXNoKG5ldyBDYWxsU3RhY2suRWxlbWVudChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsLCB0aGlzLl9zdGFydE9mUm9vdCkpO1xuICAgIH1cbiAgICBTZXRKc29uVG9rZW4oak9iamVjdCwgc3RvcnlDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3RocmVhZHMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gVE9ETzogKExpc3Q8b2JqZWN0Pikgak9iamVjdCBbXCJ0aHJlYWRzXCJdO1xuICAgICAgICBsZXQgalRocmVhZHMgPSBqT2JqZWN0W1widGhyZWFkc1wiXTtcbiAgICAgICAgZm9yIChsZXQgalRocmVhZFRvayBvZiBqVGhyZWFkcykge1xuICAgICAgICAgICAgLy8gVE9ETzogdmFyIGpUaHJlYWRPYmogPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4palRocmVhZFRvaztcbiAgICAgICAgICAgIGxldCBqVGhyZWFkT2JqID0galRocmVhZFRvaztcbiAgICAgICAgICAgIGxldCB0aHJlYWQgPSBuZXcgQ2FsbFN0YWNrLlRocmVhZChqVGhyZWFkT2JqLCBzdG9yeUNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKHRocmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogKGludClqT2JqZWN0IFtcInRocmVhZENvdW50ZXJcIl07XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIgPSBwYXJzZUludChqT2JqZWN0W1widGhyZWFkQ291bnRlclwiXSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihzdG9yeUNvbnRleHQucm9vdENvbnRlbnRDb250YWluZXIpO1xuICAgIH1cbiAgICBXcml0ZUpzb24odykge1xuICAgICAgICB3LldyaXRlT2JqZWN0KCh3cml0ZXIpID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRzXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdGhyZWFkIG9mIHRoaXMuX3RocmVhZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJlYWQuV3JpdGVKc29uKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRDb3VudGVyXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50KHRoaXMuX3RocmVhZENvdW50ZXIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFB1c2hUaHJlYWQoKSB7XG4gICAgICAgIGxldCBuZXdUaHJlYWQgPSB0aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyKys7XG4gICAgICAgIG5ld1RocmVhZC50aHJlYWRJbmRleCA9IHRoaXMuX3RocmVhZENvdW50ZXI7XG4gICAgICAgIHRoaXMuX3RocmVhZHMucHVzaChuZXdUaHJlYWQpO1xuICAgIH1cbiAgICBGb3JrVGhyZWFkKCkge1xuICAgICAgICBsZXQgZm9ya2VkVGhyZWFkID0gdGhpcy5jdXJyZW50VGhyZWFkLkNvcHkoKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlcisrO1xuICAgICAgICBmb3JrZWRUaHJlYWQudGhyZWFkSW5kZXggPSB0aGlzLl90aHJlYWRDb3VudGVyO1xuICAgICAgICByZXR1cm4gZm9ya2VkVGhyZWFkO1xuICAgIH1cbiAgICBQb3BUaHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyZWFkcy5zcGxpY2UodGhpcy5fdGhyZWFkcy5pbmRleE9mKHRoaXMuY3VycmVudFRocmVhZCksIDEpOyAvLyBzaG91bGQgYmUgZXF1aXZhbGVudCB0byBhIHBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgdGhyZWFkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYW5Qb3BUaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aHJlYWRzLmxlbmd0aCA+IDEgJiYgIXRoaXMuZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lO1xuICAgIH1cbiAgICBQdXNoKHR5cGUsIGV4dGVybmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0ID0gMCwgb3V0cHV0U3RyZWFtTGVuZ3RoV2l0aFB1c2hlZCA9IDApIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgQ2FsbFN0YWNrLkVsZW1lbnQodHlwZSwgdGhpcy5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQgPSBleHRlcm5hbEV2YWx1YXRpb25TdGFja0hlaWdodDtcbiAgICAgICAgZWxlbWVudC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0gPSBvdXRwdXRTdHJlYW1MZW5ndGhXaXRoUHVzaGVkO1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBDYW5Qb3AodHlwZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblBvcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC50eXBlID09IHR5cGU7XG4gICAgfVxuICAgIFBvcCh0eXBlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5DYW5Qb3AodHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwdXNoL3BvcCBpbiBDYWxsc3RhY2tcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXggPSAtMSkge1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IC0xKVxuICAgICAgICAgICAgY29udGV4dEluZGV4ID0gdGhpcy5jdXJyZW50RWxlbWVudEluZGV4ICsgMTtcbiAgICAgICAgbGV0IGNvbnRleHRFbGVtZW50ID0gdGhpcy5jYWxsU3RhY2tbY29udGV4dEluZGV4IC0gMV07XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcChjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICBpZiAodmFyVmFsdWUuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyVmFsdWUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0VGVtcG9yYXJ5VmFyaWFibGUobmFtZSwgdmFsdWUsIGRlY2xhcmVOZXcsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICBsZXQgY29udGV4dEVsZW1lbnQgPSB0aGlzLmNhbGxTdGFja1tjb250ZXh0SW5kZXggLSAxXTtcbiAgICAgICAgaWYgKCFkZWNsYXJlTmV3ICYmICFjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBmaW5kIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZFZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICBWYWx1ZV8xLkxpc3RWYWx1ZS5SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUucmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgIGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBDb250ZXh0Rm9yVmFyaWFibGVOYW1lZChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGhyZWFkV2l0aEluZGV4KGluZGV4KSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IHRoaXMuX3RocmVhZHMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC50aHJlYWRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPiAwID8gZmlsdGVyZWRbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGhyZWFkLmNhbGxzdGFjaztcbiAgICB9XG4gICAgZ2V0IGNhbGxTdGFja1RyYWNlKCkge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl90aHJlYWRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGhyZWFkID0gdGhpcy5fdGhyZWFkc1t0XTtcbiAgICAgICAgICAgIGxldCBpc0N1cnJlbnQgPSB0ID09IHRoaXMuX3RocmVhZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHNiLkFwcGVuZEZvcm1hdChcIj09PSBUSFJFQUQgezB9L3sxfSB7Mn09PT1cXG5cIiwgdCArIDEsIHRoaXMuX3RocmVhZHMubGVuZ3RoLCBpc0N1cnJlbnQgPyBcIihjdXJyZW50KSBcIiA6IFwiXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHJlYWQuY2FsbHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocmVhZC5jYWxsc3RhY2tbaV0udHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgW0ZVTkNUSU9OXSBcIik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgIFtUVU5ORUxdIFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHRocmVhZC5jYWxsc3RhY2tbaV0uY3VycmVudFBvaW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCI8U09NRVdIRVJFIElOIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChwb2ludGVyLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmRMaW5lKFwiPlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsU3RhY2sgPSBDYWxsU3RhY2s7XG4oZnVuY3Rpb24gKENhbGxTdGFjaykge1xuICAgIGNsYXNzIEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwb2ludGVyLCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBpbkV4cHJlc3Npb25FdmFsdWF0aW9uO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIENvcHkoKSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBFbGVtZW50KHRoaXMudHlwZSwgdGhpcy5jdXJyZW50UG9pbnRlciwgdGhpcy5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgIGNvcHkudGVtcG9yYXJ5VmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcyk7XG4gICAgICAgICAgICBjb3B5LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQgPSB0aGlzLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ7XG4gICAgICAgICAgICBjb3B5LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IHRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbFN0YWNrLkVsZW1lbnQgPSBFbGVtZW50O1xuICAgIGNsYXNzIFRocmVhZCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy50aHJlYWRJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLmNhbGxzdGFjayA9IFtdO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgalRocmVhZE9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcnlDb250ZXh0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IChpbnQpIGpUaHJlYWRPYmpbJ3RocmVhZEluZGV4J10gY2FuIHJhaXNlO1xuICAgICAgICAgICAgICAgIHRoaXMudGhyZWFkSW5kZXggPSBwYXJzZUludChqVGhyZWFkT2JqW1widGhyZWFkSW5kZXhcIl0pO1xuICAgICAgICAgICAgICAgIGxldCBqVGhyZWFkQ2FsbHN0YWNrID0galRocmVhZE9ialtcImNhbGxzdGFja1wiXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqRWxUb2sgb2YgalRocmVhZENhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgakVsZW1lbnRPYmogPSBqRWxUb2s7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IChpbnQpIGpFbGVtZW50T2JqWyd0eXBlJ10gY2FuIHJhaXNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHVzaFBvcFR5cGUgPSBwYXJzZUludChqRWxlbWVudE9ialtcInR5cGVcIl0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyUGF0aFN0cjtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogakVsZW1lbnRPYmouVHJ5R2V0VmFsdWUgKFwiY1BhdGhcIiwgb3V0IGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbiA9IGpFbGVtZW50T2JqW1wiY1BhdGhcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgPSBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGhyZWFkUG9pbnRlclJlc3VsdCA9IHN0b3J5Q29udGV4dC5Db250ZW50QXRQYXRoKG5ldyBQYXRoXzEuUGF0aChjdXJyZW50Q29udGFpbmVyUGF0aFN0cikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5jb250YWluZXIgPSB0aHJlYWRQb2ludGVyUmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuaW5kZXggPSBwYXJzZUludChqRWxlbWVudE9ialtcImlkeFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyZWFkUG9pbnRlclJlc3VsdC5vYmogPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJQYXRoU3RyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aHJlYWRQb2ludGVyUmVzdWx0LmFwcHJveGltYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5Q29udGV4dC5XYXJuaW5nKFwiV2hlbiBsb2FkaW5nIHN0YXRlLCBleGFjdCBpbnRlcm5hbCBzdG9yeSBsb2NhdGlvbiBjb3VsZG4ndCBiZSBmb3VuZDogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG8gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5jb250YWluZXIucGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIHRvIHJlY292ZXIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSAhIWpFbGVtZW50T2JqW1wiZXhwXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBuZXcgRWxlbWVudChwdXNoUG9wVHlwZSwgcG9pbnRlciwgaW5FeHByZXNzaW9uRXZhbHVhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wcyA9IGpFbGVtZW50T2JqW1widGVtcFwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwudGVtcG9yYXJ5VmFyaWFibGVzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianModGVtcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwudGVtcG9yYXJ5VmFyaWFibGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsc3RhY2sucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwcmV2Q29udGVudE9ialBhdGggPSBqVGhyZWFkT2JqW1wicHJldmlvdXNDb250ZW50T2JqZWN0XCJdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldkNvbnRlbnRPYmpQYXRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2UGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwcmV2Q29udGVudE9ialBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gc3RvcnlDb250ZXh0LlBvaW50ZXJBdFBhdGgocHJldlBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDb3B5KCkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgVGhyZWFkKCk7XG4gICAgICAgICAgICBjb3B5LnRocmVhZEluZGV4ID0gdGhpcy50aHJlYWRJbmRleDtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdGhpcy5jYWxsc3RhY2spIHtcbiAgICAgICAgICAgICAgICBjb3B5LmNhbGxzdGFjay5wdXNoKGUuQ29weSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcHkucHJldmlvdXNQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVKc29uKHdyaXRlcikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjYWxsc3RhY2tcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmNhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjUGF0aFwiLCBlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpZHhcIiwgZWwuY3VycmVudFBvaW50ZXIuaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImV4cFwiLCBlbC5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInR5cGVcIiwgZWwudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRlbXBvcmFyeVZhcmlhYmxlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGVtcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh3cml0ZXIsIGVsLnRlbXBvcmFyeVZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInRocmVhZEluZGV4XCIsIHRoaXMudGhyZWFkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZWRQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKClcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicHJldmlvdXNDb250ZW50T2JqZWN0XCIsIHJlc29sdmVkUG9pbnRlci5wYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbFN0YWNrLlRocmVhZCA9IFRocmVhZDtcbn0pKENhbGxTdGFjayA9IGV4cG9ydHMuQ2FsbFN0YWNrIHx8IChleHBvcnRzLkNhbGxTdGFjayA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWxsU3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNob2ljZSA9IHZvaWQgMDtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50aHJlYWRBdEdlbmVyYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZVBhdGggPSBcIlwiO1xuICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVGhyZWFkSW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2UudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaG9pY2UgPSBDaG9pY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaG9pY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNob2ljZVBvaW50ID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIENob2ljZVBvaW50IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihvbmNlT25seSA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcGF0aE9uQ2hvaWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb25kaXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdGFydENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbmNlT25seSA9IG9uY2VPbmx5O1xuICAgIH1cbiAgICBnZXQgcGF0aE9uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aE9uQ2hvaWNlICE9IG51bGwgJiYgdGhpcy5fcGF0aE9uQ2hvaWNlLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCBjaG9pY2VUYXJnZXRPYmogPSB0aGlzLmNob2ljZVRhcmdldDtcbiAgICAgICAgICAgIGlmIChjaG9pY2VUYXJnZXRPYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoT25DaG9pY2UgPSBjaG9pY2VUYXJnZXRPYmoucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aE9uQ2hvaWNlO1xuICAgIH1cbiAgICBzZXQgcGF0aE9uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BhdGhPbkNob2ljZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY2hvaWNlVGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5fcGF0aE9uQ2hvaWNlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLl9wYXRoT25DaG9pY2UpLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IHBhdGhTdHJpbmdPbkNob2ljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aE9uQ2hvaWNlKTtcbiAgICB9XG4gICAgc2V0IHBhdGhTdHJpbmdPbkNob2ljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhdGhPbkNob2ljZSA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29uZGl0aW9uKVxuICAgICAgICAgICAgZmxhZ3MgfD0gMTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRDb250ZW50KVxuICAgICAgICAgICAgZmxhZ3MgfD0gMjtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQpXG4gICAgICAgICAgICBmbGFncyB8PSA0O1xuICAgICAgICBpZiAodGhpcy5pc0ludmlzaWJsZURlZmF1bHQpXG4gICAgICAgICAgICBmbGFncyB8PSA4O1xuICAgICAgICBpZiAodGhpcy5vbmNlT25seSlcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2O1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfVxuICAgIHNldCBmbGFncyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhc0NvbmRpdGlvbiA9ICh2YWx1ZSAmIDEpID4gMDtcbiAgICAgICAgdGhpcy5oYXNTdGFydENvbnRlbnQgPSAodmFsdWUgJiAyKSA+IDA7XG4gICAgICAgIHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQgPSAodmFsdWUgJiA0KSA+IDA7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gKHZhbHVlICYgOCkgPiAwO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gKHZhbHVlICYgMTYpID4gMDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhPbkNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiQ2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlXCIpO1xuICAgICAgICAvLyBpbnQ/IHRhcmdldExpbmVOdW0gPSBEZWJ1Z0xpbmVOdW1iZXJPZlBhdGggKHBhdGhPbkNob2ljZSk7XG4gICAgICAgIGxldCB0YXJnZXRMaW5lTnVtID0gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldFN0cmluZyA9IHRoaXMucGF0aE9uQ2hvaWNlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0YXJnZXRMaW5lTnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRhcmdldFN0cmluZyA9IFwiIGxpbmUgXCIgKyB0YXJnZXRMaW5lTnVtICsgXCIoXCIgKyB0YXJnZXRTdHJpbmcgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJDaG9pY2U6IC0+IFwiICsgdGFyZ2V0U3RyaW5nO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hvaWNlUG9pbnQgPSBDaG9pY2VQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNob2ljZVBvaW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250YWluZXIgPSB2b2lkIDA7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgU2VhcmNoUmVzdWx0XzEgPSByZXF1aXJlKFwiLi9TZWFyY2hSZXN1bHRcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLm5hbWVkQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaGFzVmFsaWROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICE9IG51bGwgJiYgdGhpcy5uYW1lLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5BZGRDb250ZW50KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVkT25seUNvbnRlbnQoKSB7XG4gICAgICAgIGxldCBuYW1lZE9ubHlDb250ZW50RGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMubmFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgaW5rT2JqZWN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsdWUsIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdC5zZXQoa2V5LCBpbmtPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbmFtZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKGMpO1xuICAgICAgICAgICAgaWYgKG5hbWVkICE9IG51bGwgJiYgbmFtZWQuaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZWRPbmx5Q29udGVudERpY3QuZGVsZXRlKG5hbWVkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lZE9ubHlDb250ZW50RGljdC5zaXplID09IDApXG4gICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBuYW1lZE9ubHlDb250ZW50RGljdDtcbiAgICB9XG4gICAgc2V0IG5hbWVkT25seUNvbnRlbnQodmFsdWUpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nTmFtZWRPbmx5ID0gdGhpcy5uYW1lZE9ubHlDb250ZW50O1xuICAgICAgICBpZiAoZXhpc3RpbmdOYW1lZE9ubHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgZXhpc3RpbmdOYW1lZE9ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVkQ29udGVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgWywgdmFsXSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG5hbWVkID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbCh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWVkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5BZGRUb05hbWVkQ29udGVudE9ubHkobmFtZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb3VudEZsYWdzKCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAwO1xuICAgICAgICBpZiAodGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICBmbGFncyB8PSBDb250YWluZXIuQ291bnRGbGFncy5WaXNpdHM7XG4gICAgICAgIGlmICh0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgIGZsYWdzIHw9IENvbnRhaW5lci5Db3VudEZsYWdzLlR1cm5zO1xuICAgICAgICBpZiAodGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5KVxuICAgICAgICAgICAgZmxhZ3MgfD0gQ29udGFpbmVyLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHk7XG4gICAgICAgIGlmIChmbGFncyA9PSBDb250YWluZXIuQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSkge1xuICAgICAgICAgICAgZmxhZ3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG4gICAgc2V0IGNvdW50RmxhZ3ModmFsdWUpIHtcbiAgICAgICAgbGV0IGZsYWcgPSB2YWx1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuVmlzaXRzKSA+IDApXG4gICAgICAgICAgICB0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICgoZmxhZyAmIENvbnRhaW5lci5Db3VudEZsYWdzLlR1cm5zKSA+IDApXG4gICAgICAgICAgICB0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICgoZmxhZyAmIENvbnRhaW5lci5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KSA+IDApXG4gICAgICAgICAgICB0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgcGF0aFRvRmlyc3RMZWFmQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPSB0aGlzLnBhdGguUGF0aEJ5QXBwZW5kaW5nUGF0aCh0aGlzLmludGVybmFsUGF0aFRvRmlyc3RMZWFmQ29udGVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50O1xuICAgIH1cbiAgICBnZXQgaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KCkge1xuICAgICAgICBsZXQgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2gobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudCgwKSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNvbnRlbnRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoXzEuUGF0aChjb21wb25lbnRzKTtcbiAgICB9XG4gICAgQWRkQ29udGVudChjb250ZW50T2JqT3JMaXN0KSB7XG4gICAgICAgIGlmIChjb250ZW50T2JqT3JMaXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50TGlzdCA9IGNvbnRlbnRPYmpPckxpc3Q7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRlbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5BZGRDb250ZW50KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPYmogPSBjb250ZW50T2JqT3JMaXN0O1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5wdXNoKGNvbnRlbnRPYmopO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRPYmoucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiICsgY29udGVudE9iai5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudE9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJ5QWRkTmFtZWRDb250ZW50KGNvbnRlbnRPYmopIHtcbiAgICAgICAgbGV0IG5hbWVkQ29udGVudE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwoY29udGVudE9iaik7XG4gICAgICAgIGlmIChuYW1lZENvbnRlbnRPYmogIT0gbnVsbCAmJiBuYW1lZENvbnRlbnRPYmouaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZENvbnRlbnRPYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZENvbnRlbnRPYmopIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnRUeXBlKG5hbWVkQ29udGVudE9iaiwgT2JqZWN0XzEuSW5rT2JqZWN0LCBcIkNhbiBvbmx5IGFkZCBSdW50aW1lLk9iamVjdHMgdG8gYSBSdW50aW1lLkNvbnRhaW5lclwiKTtcbiAgICAgICAgbGV0IHJ1bnRpbWVPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuYW1lZENvbnRlbnRPYmosIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgIHJ1bnRpbWVPYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lZENvbnRlbnQuc2V0KG5hbWVkQ29udGVudE9iai5uYW1lLCBuYW1lZENvbnRlbnRPYmopO1xuICAgIH1cbiAgICBDb250ZW50QXRQYXRoKHBhdGgsIHBhcnRpYWxQYXRoU3RhcnQgPSAwLCBwYXJ0aWFsUGF0aExlbmd0aCA9IC0xKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsUGF0aExlbmd0aCA9PSAtMSlcbiAgICAgICAgICAgIHBhcnRpYWxQYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgU2VhcmNoUmVzdWx0XzEuU2VhcmNoUmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdC5hcHByb3hpbWF0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgIGxldCBjdXJyZW50T2JqID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhcnRpYWxQYXRoU3RhcnQ7IGkgPCBwYXJ0aWFsUGF0aExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY29tcCA9IHBhdGguR2V0Q29tcG9uZW50KGkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHByb3hpbWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmRPYmogPSBjdXJyZW50Q29udGFpbmVyLkNvbnRlbnRXaXRoUGF0aENvbXBvbmVudChjb21wKTtcbiAgICAgICAgICAgIGlmIChmb3VuZE9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRPYmogPSBmb3VuZE9iajtcbiAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoZm91bmRPYmosIENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm9iaiA9IGN1cnJlbnRPYmo7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEluc2VydENvbnRlbnQoY29udGVudE9iaiwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W2luZGV4XSA9IGNvbnRlbnRPYmo7XG4gICAgICAgIGlmIChjb250ZW50T2JqLnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiICsgY29udGVudE9iai5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRPYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaik7XG4gICAgfVxuICAgIEFkZENvbnRlbnRzT2ZDb250YWluZXIob3RoZXJDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LmNvbmNhdChvdGhlckNvbnRhaW5lci5jb250ZW50KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIG90aGVyQ29udGFpbmVyLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQob2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb250ZW50V2l0aFBhdGhDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQuaXNJbmRleCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pbmRleCA+PSAwICYmIGNvbXBvbmVudC5pbmRleCA8IHRoaXMuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2NvbXBvbmVudC5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQuaXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQubmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29tcG9uZW50Lm5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmRDb250ZW50ID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMubmFtZWRDb250ZW50LCBjb21wb25lbnQubmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoZm91bmRDb250ZW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhmb3VuZENvbnRlbnQucmVzdWx0LCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpIHtcbiAgICAgICAgbGV0IHNiO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCAwLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHNiID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBsZXQgaW5kZW50YXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGxldCBwb2ludGVkT2JqID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmRJbmRlbnRhdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlc1BlckluZGVudCA9IDQ7IC8vIFRydWx5IGNvbnN0IGluIHRoZSBvcmlnaW5hbCBjb2RlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYWNlc1BlckluZGVudCAqIGluZGVudGF0aW9uOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgIHNiLkFwcGVuZChcIltcIik7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgc2IuQXBwZW5kRm9ybWF0KFwiICh7MH0pXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgPT0gcG9pbnRlZE9iaikge1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiICA8LS0tXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNiLkFwcGVuZExpbmUoKTtcbiAgICAgICAgaW5kZW50YXRpb24rKztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG9iajtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgaW5kZW50YXRpb24sIHBvaW50ZWRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChvYmoudG9TdHJpbmcoKS5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikpO1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQob2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcikgJiYgb2JqID09IHBvaW50ZWRPYmopIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgIDwtLS1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9ubHlOYW1lZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMubmFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmluZGV4T2YoVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsdWUsIE9iamVjdF8xLklua09iamVjdCkpID49IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ubHlOYW1lZC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ubHlOYW1lZC5zaXplID4gMCkge1xuICAgICAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoXCItLSBuYW1lZDogLS1cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBbLCB2YWx1ZV0gb2Ygb25seU5hbWVkKSB7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnRUeXBlKHZhbHVlLCBDb250YWluZXIsIFwiQ2FuIG9ubHkgcHJpbnQgb3V0IG5hbWVkIENvbnRhaW5lcnNcIik7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCBpbmRlbnRhdGlvbiwgcG9pbnRlZE9iaik7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGVudGF0aW9uLS07XG4gICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgIHNiLkFwcGVuZChcIl1cIik7XG4gICAgfVxufVxuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4oZnVuY3Rpb24gKENvbnRhaW5lcikge1xuICAgIGxldCBDb3VudEZsYWdzO1xuICAgIChmdW5jdGlvbiAoQ291bnRGbGFncykge1xuICAgICAgICBDb3VudEZsYWdzW0NvdW50RmxhZ3NbXCJWaXNpdHNcIl0gPSAxXSA9IFwiVmlzaXRzXCI7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIlR1cm5zXCJdID0gMl0gPSBcIlR1cm5zXCI7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIkNvdW50U3RhcnRPbmx5XCJdID0gNF0gPSBcIkNvdW50U3RhcnRPbmx5XCI7XG4gICAgfSkoQ291bnRGbGFncyA9IENvbnRhaW5lci5Db3VudEZsYWdzIHx8IChDb250YWluZXIuQ291bnRGbGFncyA9IHt9KSk7XG59KShDb250YWluZXIgPSBleHBvcnRzLkNvbnRhaW5lciB8fCAoZXhwb3J0cy5Db250YWluZXIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cm9sQ29tbWFuZCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgQ29udHJvbENvbW1hbmQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRUeXBlID0gQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm90U2V0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRUeXBlID0gY29tbWFuZFR5cGU7XG4gICAgfVxuICAgIGdldCBjb21tYW5kVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRUeXBlO1xuICAgIH1cbiAgICBDb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKHRoaXMuY29tbWFuZFR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgRXZhbFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxTdGFydCk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXQpO1xuICAgIH1cbiAgICBzdGF0aWMgRXZhbEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsRW5kKTtcbiAgICB9XG4gICAgc3RhdGljIER1cGxpY2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGUpO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wRXZhbHVhdGVkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wVHVubmVsKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcFR1bm5lbCk7XG4gICAgfVxuICAgIHN0YXRpYyBCZWdpblN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZyk7XG4gICAgfVxuICAgIHN0YXRpYyBFbmRTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kU3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIE5vT3AoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm9PcCk7XG4gICAgfVxuICAgIHN0YXRpYyBDaG9pY2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5DaG9pY2VDb3VudCk7XG4gICAgfVxuICAgIHN0YXRpYyBUdXJucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJucyk7XG4gICAgfVxuICAgIHN0YXRpYyBUdXJuc1NpbmNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgUmVhZENvdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJlYWRDb3VudCk7XG4gICAgfVxuICAgIHN0YXRpYyBSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tKTtcbiAgICB9XG4gICAgc3RhdGljIFNlZWRSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbSk7XG4gICAgfVxuICAgIHN0YXRpYyBWaXNpdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU2VxdWVuY2VTaHVmZmxlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU3RhcnRUaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQpO1xuICAgIH1cbiAgICBzdGF0aWMgRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lKTtcbiAgICB9XG4gICAgc3RhdGljIEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmQpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdEZyb21JbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdFJhbmdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5nZSk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0UmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb20pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZFR5cGUudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyb2xDb21tYW5kID0gQ29udHJvbENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbnRyb2xDb21tYW5kKSB7XG4gICAgbGV0IENvbW1hbmRUeXBlO1xuICAgIChmdW5jdGlvbiAoQ29tbWFuZFR5cGUpIHtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJOb3RTZXRcIl0gPSAtMV0gPSBcIk5vdFNldFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxTdGFydFwiXSA9IDBdID0gXCJFdmFsU3RhcnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFdmFsT3V0cHV0XCJdID0gMV0gPSBcIkV2YWxPdXRwdXRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFdmFsRW5kXCJdID0gMl0gPSBcIkV2YWxFbmRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJEdXBsaWNhdGVcIl0gPSAzXSA9IFwiRHVwbGljYXRlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUG9wRXZhbHVhdGVkVmFsdWVcIl0gPSA0XSA9IFwiUG9wRXZhbHVhdGVkVmFsdWVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJQb3BGdW5jdGlvblwiXSA9IDVdID0gXCJQb3BGdW5jdGlvblwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlBvcFR1bm5lbFwiXSA9IDZdID0gXCJQb3BUdW5uZWxcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJCZWdpblN0cmluZ1wiXSA9IDddID0gXCJCZWdpblN0cmluZ1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkVuZFN0cmluZ1wiXSA9IDhdID0gXCJFbmRTdHJpbmdcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJOb09wXCJdID0gOV0gPSBcIk5vT3BcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJDaG9pY2VDb3VudFwiXSA9IDEwXSA9IFwiQ2hvaWNlQ291bnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUdXJuc1wiXSA9IDExXSA9IFwiVHVybnNcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUdXJuc1NpbmNlXCJdID0gMTJdID0gXCJUdXJuc1NpbmNlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUmFuZG9tXCJdID0gMTNdID0gXCJSYW5kb21cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJTZWVkUmFuZG9tXCJdID0gMTRdID0gXCJTZWVkUmFuZG9tXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVmlzaXRJbmRleFwiXSA9IDE1XSA9IFwiVmlzaXRJbmRleFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlNlcXVlbmNlU2h1ZmZsZUluZGV4XCJdID0gMTZdID0gXCJTZXF1ZW5jZVNodWZmbGVJbmRleFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlN0YXJ0VGhyZWFkXCJdID0gMTddID0gXCJTdGFydFRocmVhZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkRvbmVcIl0gPSAxOF0gPSBcIkRvbmVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFbmRcIl0gPSAxOV0gPSBcIkVuZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkxpc3RGcm9tSW50XCJdID0gMjBdID0gXCJMaXN0RnJvbUludFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkxpc3RSYW5nZVwiXSA9IDIxXSA9IFwiTGlzdFJhbmdlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdFJhbmRvbVwiXSA9IDIyXSA9IFwiTGlzdFJhbmRvbVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlJlYWRDb3VudFwiXSA9IDIzXSA9IFwiUmVhZENvdW50XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVE9UQUxfVkFMVUVTXCJdID0gMjRdID0gXCJUT1RBTF9WQUxVRVNcIjtcbiAgICB9KShDb21tYW5kVHlwZSA9IENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlIHx8IChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZSA9IHt9KSk7XG59KShDb250cm9sQ29tbWFuZCA9IGV4cG9ydHMuQ29udHJvbENvbW1hbmQgfHwgKGV4cG9ydHMuQ29udHJvbENvbW1hbmQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbENvbW1hbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlYnVnID0gdm9pZCAwO1xudmFyIERlYnVnO1xuKGZ1bmN0aW9uIChEZWJ1Zykge1xuICAgIGZ1bmN0aW9uIEFzc2VydFR5cGUodmFyaWFibGUsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgQXNzZXJ0KHZhcmlhYmxlIGluc3RhbmNlb2YgdHlwZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIERlYnVnLkFzc2VydFR5cGUgPSBBc3NlcnRUeXBlO1xuICAgIGZ1bmN0aW9uIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlYnVnLkFzc2VydCA9IEFzc2VydDtcbn0pKERlYnVnID0gZXhwb3J0cy5EZWJ1ZyB8fCAoZXhwb3J0cy5EZWJ1ZyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWJ1Zy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGl2ZXJ0ID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgRGl2ZXJ0IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihzdGFja1B1c2hUeXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy52YXJpYWJsZURpdmVydE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFja1B1c2hUeXBlID0gMDtcbiAgICAgICAgdGhpcy5pc0V4dGVybmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxBcmdzID0gMDtcbiAgICAgICAgdGhpcy5pc0NvbmRpdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrUHVzaFR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YWNrUHVzaFR5cGUgPSBzdGFja1B1c2hUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0YXJnZXRQYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aCAhPSBudWxsICYmIHRoaXMuX3RhcmdldFBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldE9iaiA9IHRoaXMudGFyZ2V0UG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0T2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UGF0aCA9IHRhcmdldE9iai5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQYXRoO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0UGF0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90YXJnZXRQYXRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UG9pbnRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0T2JqID0gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLl90YXJnZXRQYXRoKS5vYmo7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3RhcmdldFBhdGhcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldE9iaiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0YXJnZXRPYmpcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlci5jb250YWluZXIgPVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRPYmoucGFyZW50IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGFyZ2V0T2JqLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlci5pbmRleCA9IHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHRhcmdldE9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA/IHRhcmdldE9iaiA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQb2ludGVyLmNvcHkoKTtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGhTdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldFBhdGggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0UGF0aFN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc1ZhcmlhYmxlVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZURpdmVydE5hbWUgIT0gbnVsbDtcbiAgICB9XG4gICAgRXF1YWxzKG9iaikge1xuICAgICAgICBsZXQgb3RoZXJEaXZlcnQgPSBvYmo7XG4gICAgICAgIGlmIChvdGhlckRpdmVydCBpbnN0YW5jZW9mIERpdmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQgPT0gb3RoZXJEaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZURpdmVydE5hbWUgPT0gb3RoZXJEaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy50YXJnZXRQYXRoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQYXRoLkVxdWFscyhvdGhlckRpdmVydC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkRpdmVydCh2YXJpYWJsZTogXCIgKyB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJEaXZlcnQobnVsbClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgbGV0IHRhcmdldFN0ciA9IHRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gaW50PyB0YXJnZXRMaW5lTnVtID0gRGVidWdMaW5lTnVtYmVyT2ZQYXRoICh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRMaW5lTnVtID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRMaW5lTnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBcImxpbmUgXCIgKyB0YXJnZXRMaW5lTnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuQXBwZW5kKFwiRGl2ZXJ0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25kaXRpb25hbClcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCI/XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrUHVzaFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiB0dW5uZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuQXBwZW5kKFwiIC0+IFwiKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0aGlzLnRhcmdldFBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiIChcIik7XG4gICAgICAgICAgICBzYi5BcHBlbmQodGFyZ2V0U3RyKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZChcIilcIik7XG4gICAgICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGl2ZXJ0ID0gRGl2ZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGl2ZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HbHVlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBHbHVlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiR2x1ZVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuR2x1ZSA9IEdsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbHVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmtMaXN0ID0gZXhwb3J0cy5JbmtMaXN0SXRlbSA9IHZvaWQgMDtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY2xhc3MgSW5rTGlzdEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBJbmtMaXN0SXRlbSBpcyBhIHN0cnVjdFxuICAgICAgICB0aGlzLm9yaWdpbk5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLml0ZW1OYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5OYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IGl0ZW1OYW1lID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5OYW1lID0gb3JpZ2luTmFtZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbU5hbWUgPSBpdGVtTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgIGxldCBmdWxsTmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBuYW1lUGFydHMgPSBmdWxsTmFtZS50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luTmFtZSA9IG5hbWVQYXJ0c1swXTtcbiAgICAgICAgICAgIHRoaXMuaXRlbU5hbWUgPSBuYW1lUGFydHNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBOdWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBnZXQgaXNOdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5OYW1lID09IG51bGwgJiYgdGhpcy5pdGVtTmFtZSA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgZnVsbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMub3JpZ2luTmFtZSAhPT0gbnVsbCA/IHRoaXMub3JpZ2luTmFtZSA6IFwiP1wiKSArIFwiLlwiICsgdGhpcy5pdGVtTmFtZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxsTmFtZTtcbiAgICB9XG4gICAgRXF1YWxzKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgSW5rTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBvdGhlckl0ZW0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVySXRlbS5pdGVtTmFtZSA9PSB0aGlzLml0ZW1OYW1lICYmXG4gICAgICAgICAgICAgICAgb3RoZXJJdGVtLm9yaWdpbk5hbWUgPT0gdGhpcy5vcmlnaW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZXNlIG1ldGhvZHMgZGlkIG5vdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgQyMgY29kZS4gVGhlaXIgcHVycG9zZSBpcyB0b1xuICAgIC8vIG1ha2UgYElua0xpc3RJdGVtYCBtaW1pY3MgdGhlIHZhbHVlLXR5cGUgc2VtYW50aWNzIG9mIHRoZSBvcmlnaW5hbFxuICAgIC8vIHN0cnVjdC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBlbmQgb2YgdGhpcyBmaWxlLCBmb3IgYSBtb3JlIGluLWRlcHRoXG4gICAgLy8gZXhwbGFuYXRpb24uXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0SXRlbSh0aGlzLm9yaWdpbk5hbWUsIHRoaXMuaXRlbU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYFNlcmlhbGl6ZWRJbmtMaXN0SXRlbWAgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50XG4gICAgICogaW5zdGFuY2UuIFRoZSByZXN1bHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIGtleSBpbnNpZGUgYSBNYXAuXG4gICAgICovXG4gICAgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgLy8gV2UgYXJlIHNpbXBseSB1c2luZyBhIEpTT04gcmVwcmVzZW50YXRpb24gYXMgYSB2YWx1ZS10eXBlZCBrZXkuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBvcmlnaW5OYW1lOiB0aGlzLm9yaWdpbk5hbWUsXG4gICAgICAgICAgICBpdGVtTmFtZTogdGhpcy5pdGVtTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uc3RydWN0cyBhIGBJbmtMaXN0SXRlbWAgZnJvbSB0aGUgZ2l2ZW4gU2VyaWFsaXplZElua0xpc3RJdGVtLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VyaWFsaXplZEtleShrZXkpIHtcbiAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2Uoa2V5KTtcbiAgICAgICAgaWYgKCFJbmtMaXN0SXRlbS5pc0xpa2VJbmtMaXN0SXRlbShvYmopKVxuICAgICAgICAgICAgcmV0dXJuIElua0xpc3RJdGVtLk51bGw7XG4gICAgICAgIGxldCBpbmtMaXN0SXRlbSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0SXRlbShpbmtMaXN0SXRlbS5vcmlnaW5OYW1lLCBpbmtMaXN0SXRlbS5pdGVtTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gaXRlbSBpcyBzdWZmaWNpZW50bHkgYElua0xpc3RJdGVtYC1saWtlXG4gICAgICogdG8gYmUgdXNlZCBhcyBhIHRlbXBsYXRlIHdoZW4gcmVjb25zdHJ1Y3RpbmcgdGhlIElua0xpc3RJdGVtLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xpa2VJbmtMaXN0SXRlbShpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KFwib3JpZ2luTmFtZVwiKSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eShcIml0ZW1OYW1lXCIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ub3JpZ2luTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbS5vcmlnaW5OYW1lICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uaXRlbU5hbWUgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGl0ZW0uaXRlbU5hbWUgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5rTGlzdEl0ZW0gPSBJbmtMaXN0SXRlbTtcbmNsYXNzIElua0xpc3QgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBUcnlpbmcgdG8gYmUgc21hcnQgaGVyZSwgdGhpcyBlbXVsYXRlcyB0aGUgY29uc3RydWN0b3IgaW5oZXJpdGFuY2UgZm91bmRcbiAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIGNvZGUsIGJ1dCBvbmx5IGlmIG90aGVyTGlzdCBpcyBhbiBJbmtMaXN0LiBJSUZFIEZUVy5cbiAgICAgICAgc3VwZXIoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBJbmtMaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSk7XG4gICAgICAgIHRoaXMub3JpZ2lucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW107XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBJbmtMaXN0KSB7XG4gICAgICAgICAgICBsZXQgb3RoZXJMaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKG90aGVyTGlzdC5fb3JpZ2luTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IG90aGVyTGlzdC5fb3JpZ2luTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgc2luZ2xlT3JpZ2luTGlzdE5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgb3JpZ2luU3RvcnkgPSBhcmd1bWVudHNbMV07IC8qIGFzIFN0b3J5ICovXG4gICAgICAgICAgICB0aGlzLlNldEluaXRpYWxPcmlnaW5OYW1lKHNpbmdsZU9yaWdpbkxpc3ROYW1lKTtcbiAgICAgICAgICAgIGxldCBkZWYgPSBvcmlnaW5TdG9yeS5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24oc2luZ2xlT3JpZ2luTGlzdE5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKGRlZi5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbnMgPSBbZGVmLnJlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmtMaXN0IG9yaWdpbiBjb3VsZCBub3QgYmUgZm91bmQgaW4gc3Rvcnkgd2hlbiBjb25zdHJ1Y3RpbmcgbmV3IGxpc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlT3JpZ2luTGlzdE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSAmJlxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGxldCBzaW5nbGVFbGVtZW50ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5BZGQoc2luZ2xlRWxlbWVudC5LZXksIHNpbmdsZUVsZW1lbnQuVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZEl0ZW0oaXRlbU9ySXRlbU5hbWUpIHtcbiAgICAgICAgaWYgKGl0ZW1Pckl0ZW1OYW1lIGluc3RhbmNlb2YgSW5rTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gaXRlbU9ySXRlbU5hbWU7XG4gICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW5OYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZEl0ZW0oaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLm5hbWUgPT0gaXRlbS5vcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRWYWwgPSBvcmlnaW4uVHJ5R2V0VmFsdWVGb3JJdGVtKGl0ZW0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50VmFsLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGQoaXRlbSwgaW50VmFsLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBsaXN0IGRlZmluaXRpb24gaW4gaW5rLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhZGQgaXRlbSB0byBsaXN0IGJlY2F1c2UgdGhlIGl0ZW0gd2FzIGZyb20gYSBuZXcgbGlzdCBkZWZpbml0aW9uIHRoYXQgd2Fzbid0IHByZXZpb3VzbHkga25vd24gdG8gdGhpcyBsaXN0LiBPbmx5IGl0ZW1zIGZyb20gcHJldmlvdXNseSBrbm93biBsaXN0cyBjYW4gYmUgdXNlZCwgc28gdGhhdCB0aGUgaW50IHZhbHVlIGNhbiBiZSBmb3VuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBpdGVtT3JJdGVtTmFtZTtcbiAgICAgICAgICAgIGxldCBmb3VuZExpc3REZWYgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbU5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5Db250YWluc0l0ZW1XaXRoTmFtZShpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kTGlzdERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgY291bGQgY29tZSBmcm9tIGVpdGhlciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZExpc3REZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZExpc3REZWYgPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1OYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgaXNuJ3Qga25vd24gdG8gYW55IGxpc3QgZGVmaW5pdGlvbnMgcHJldmlvdXNseSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsaXN0LlwiKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RJdGVtKGZvdW5kTGlzdERlZi5uYW1lLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICBsZXQgaXRlbVZhbCA9IGZvdW5kTGlzdERlZi5WYWx1ZUZvckl0ZW0oaXRlbSk7XG4gICAgICAgICAgICB0aGlzLkFkZChpdGVtLCBpdGVtVmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb250YWluc0l0ZW1OYW1lZChpdGVtTmFtZSkge1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PSBpdGVtTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENvbnRhaW5zS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXMoa2V5LnNlcmlhbGl6ZWQoKSk7XG4gICAgfVxuICAgIEFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkS2V5ID0ga2V5LnNlcmlhbGl6ZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzKHNlcmlhbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gdG8gbWF0Y2ggdGhlIEMjIGJlaGF2aW9yLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgTWFwIGFscmVhZHkgY29udGFpbnMgYW4gZW50cnkgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHNlcmlhbGl6ZWRLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgUmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5LnNlcmlhbGl6ZWQoKSk7XG4gICAgfVxuICAgIGdldCBDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IG9yaWdpbk9mTWF4SXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXhPcmlnaW5OYW1lID0gdGhpcy5tYXhJdGVtLktleS5vcmlnaW5OYW1lO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5zLmV2ZXJ5KChvcmlnaW4pID0+IHtcbiAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBtYXhPcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCBvcmlnaW5OYW1lcygpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luTmFtZXMgPT0gbnVsbCAmJiB0aGlzLkNvdW50ID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtdO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5OYW1lcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW5OYW1lID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0ub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcy5wdXNoKGl0ZW0ub3JpZ2luTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbk5hbWVzO1xuICAgIH1cbiAgICBTZXRJbml0aWFsT3JpZ2luTmFtZShpbml0aWFsT3JpZ2luTmFtZSkge1xuICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtpbml0aWFsT3JpZ2luTmFtZV07XG4gICAgfVxuICAgIFNldEluaXRpYWxPcmlnaW5OYW1lcyhpbml0aWFsT3JpZ2luTmFtZXMpIHtcbiAgICAgICAgaWYgKGluaXRpYWxPcmlnaW5OYW1lcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IGluaXRpYWxPcmlnaW5OYW1lcy5zbGljZSgpOyAvLyBzdG9yZSBhIGNvcHlcbiAgICB9XG4gICAgZ2V0IG1heEl0ZW0oKSB7XG4gICAgICAgIGxldCBtYXggPSB7XG4gICAgICAgICAgICBLZXk6IElua0xpc3RJdGVtLk51bGwsXG4gICAgICAgICAgICBWYWx1ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbCB8fCB2YWx1ZSA+IG1heC5WYWx1ZSlcbiAgICAgICAgICAgICAgICBtYXggPSB7IEtleTogaXRlbSwgVmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IG1pbkl0ZW0oKSB7XG4gICAgICAgIGxldCBtaW4gPSB7XG4gICAgICAgICAgICBLZXk6IElua0xpc3RJdGVtLk51bGwsXG4gICAgICAgICAgICBWYWx1ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChtaW4uS2V5LmlzTnVsbCB8fCB2YWx1ZSA8IG1pbi5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHsgS2V5OiBpdGVtLCBWYWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgaW52ZXJzZSgpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3JpZ2luLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLkNvbnRhaW5zS2V5KGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5BZGQoaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZ2V0IGFsbCgpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3JpZ2luLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zZXQoaXRlbS5zZXJpYWxpemVkKCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIFVuaW9uKG90aGVyTGlzdCkge1xuICAgICAgICBsZXQgdW5pb24gPSBuZXcgSW5rTGlzdCh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG90aGVyTGlzdCkge1xuICAgICAgICAgICAgdW5pb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlvbjtcbiAgICB9XG4gICAgSW50ZXJzZWN0KG90aGVyTGlzdCkge1xuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChvdGhlckxpc3QuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICBXaXRob3V0KGxpc3RUb1JlbW92ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IElua0xpc3QodGhpcyk7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIGxpc3RUb1JlbW92ZSkge1xuICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvbnRhaW5zKG90aGVyTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiBvdGhlckxpc3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIEdyZWF0ZXJUaGFuKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluSXRlbS5WYWx1ZSA+IG90aGVyTGlzdC5tYXhJdGVtLlZhbHVlO1xuICAgIH1cbiAgICBHcmVhdGVyVGhhbk9yRXF1YWxzKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1pbkl0ZW0uVmFsdWUgPj0gb3RoZXJMaXN0Lm1pbkl0ZW0uVmFsdWUgJiZcbiAgICAgICAgICAgIHRoaXMubWF4SXRlbS5WYWx1ZSA+PSBvdGhlckxpc3QubWF4SXRlbS5WYWx1ZSk7XG4gICAgfVxuICAgIExlc3NUaGFuKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4SXRlbS5WYWx1ZSA8IG90aGVyTGlzdC5taW5JdGVtLlZhbHVlO1xuICAgIH1cbiAgICBMZXNzVGhhbk9yRXF1YWxzKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1heEl0ZW0uVmFsdWUgPD0gb3RoZXJMaXN0Lm1heEl0ZW0uVmFsdWUgJiZcbiAgICAgICAgICAgIHRoaXMubWluSXRlbS5WYWx1ZSA8PSBvdGhlckxpc3QubWluSXRlbS5WYWx1ZSk7XG4gICAgfVxuICAgIE1heEFzTGlzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KHRoaXMubWF4SXRlbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgIH1cbiAgICBNaW5Bc0xpc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCh0aGlzLm1pbkl0ZW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QoKTtcbiAgICB9XG4gICAgTGlzdFdpdGhTdWJSYW5nZShtaW5Cb3VuZCwgbWF4Qm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBsZXQgb3JkZXJlZCA9IHRoaXMub3JkZXJlZEl0ZW1zO1xuICAgICAgICBsZXQgbWluVmFsdWUgPSAwO1xuICAgICAgICBsZXQgbWF4VmFsdWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWluQm91bmQpKSB7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IG1pbkJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pbkJvdW5kIGluc3RhbmNlb2YgSW5rTGlzdCAmJiBtaW5Cb3VuZC5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5Cb3VuZC5taW5JdGVtLlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG1heEJvdW5kKSkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSBtYXhCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtaW5Cb3VuZCBpbnN0YW5jZW9mIElua0xpc3QgJiYgbWluQm91bmQuQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gbWF4Qm91bmQubWF4SXRlbS5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViTGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIHN1Ykxpc3QuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKHRoaXMub3JpZ2luTmFtZXMpO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIG9yZGVyZWQpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLlZhbHVlID49IG1pblZhbHVlICYmIGl0ZW0uVmFsdWUgPD0gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdWJMaXN0LkFkZChpdGVtLktleSwgaXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ykxpc3Q7XG4gICAgfVxuICAgIEVxdWFscyhvdGhlcklua0xpc3QpIHtcbiAgICAgICAgaWYgKG90aGVySW5rTGlzdCBpbnN0YW5jZW9mIElua0xpc3QgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJJbmtMaXN0LkNvdW50ICE9IHRoaXMuQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXJJbmtMaXN0LmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gR2V0SGFzaENvZGUgbm90IGltcGxlbWVudGVkXG4gICAgZ2V0IG9yZGVyZWRJdGVtcygpIHtcbiAgICAgICAgLy8gTGlzdDxLZXlWYWx1ZVBhaXI8SW5rTGlzdEl0ZW0sIGludD4+XG4gICAgICAgIGxldCBvcmRlcmVkID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBvcmRlcmVkLnB1c2goeyBLZXk6IGl0ZW0sIFZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvcmRlcmVkLnNvcnQoKHgsIHkpID0+IHtcbiAgICAgICAgICAgIGlmICh4LktleS5vcmlnaW5OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ4LktleS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkuS2V5Lm9yaWdpbk5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInkuS2V5Lm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5WYWx1ZSA9PSB5LlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguS2V5Lm9yaWdpbk5hbWUubG9jYWxlQ29tcGFyZSh5LktleS5vcmlnaW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgYml0IGludG8gYSBudW1iZXJDb21wYXJlVG8gbWV0aG9kP1xuICAgICAgICAgICAgICAgIGlmICh4LlZhbHVlIDwgeS5WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiB4LlZhbHVlID4geS5WYWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9yZGVyZWQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgb3JkZXJlZCA9IHRoaXMub3JkZXJlZEl0ZW1zO1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiLCBcIik7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG9yZGVyZWRbaV0uS2V5O1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBjYXN0aW5nIGEgSW5rTGlzdCB0byBhIE51bWJlciwgZm9yIHNvbWVyZWFzb24sIGFjdHVhbGx5IGdpdmVzIGEgbnVtYmVyLlxuICAgIC8vIFRoaXMgbWVzc2VzIHVwIHRoZSB0eXBlIGRldGVjdGlvbiB3aGVuIGNyZWF0aW5nIGEgVmFsdWUgZnJvbSBhIElua0xpc3QuXG4gICAgLy8gUmV0dXJuaW5nIE5hTiBoZXJlIHByZXZlbnRzIHRoYXQuXG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG59XG5leHBvcnRzLklua0xpc3QgPSBJbmtMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5rTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvblNlcmlhbGlzYXRpb24gPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IEdsdWVfMSA9IHJlcXVpcmUoXCIuL0dsdWVcIik7XG5jb25zdCBDb250cm9sQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29udHJvbENvbW1hbmRcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgRGl2ZXJ0XzEgPSByZXF1aXJlKFwiLi9EaXZlcnRcIik7XG5jb25zdCBDaG9pY2VQb2ludF8xID0gcmVxdWlyZShcIi4vQ2hvaWNlUG9pbnRcIik7XG5jb25zdCBWYXJpYWJsZVJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVSZWZlcmVuY2VcIik7XG5jb25zdCBWYXJpYWJsZUFzc2lnbm1lbnRfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlQXNzaWdubWVudFwiKTtcbmNvbnN0IE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xID0gcmVxdWlyZShcIi4vTmF0aXZlRnVuY3Rpb25DYWxsXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENob2ljZV8xID0gcmVxdWlyZShcIi4vQ2hvaWNlXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25fMSA9IHJlcXVpcmUoXCIuL0xpc3REZWZpbml0aW9uXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25zT3JpZ2luXzEgPSByZXF1aXJlKFwiLi9MaXN0RGVmaW5pdGlvbnNPcmlnaW5cIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBKc29uU2VyaWFsaXNhdGlvbiB7XG4gICAgc3RhdGljIEpBcnJheVRvUnVudGltZU9iakxpc3QoakFycmF5LCBza2lwTGFzdCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjb3VudCA9IGpBcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChza2lwTGFzdClcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGpUb2sgPSBqQXJyYXlbaV07XG4gICAgICAgICAgICBsZXQgcnVudGltZU9iaiA9IHRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KGpUb2spO1xuICAgICAgICAgICAgaWYgKHJ1bnRpbWVPYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInJ1bnRpbWVPYmpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2gocnVudGltZU9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh3cml0ZXIsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlTGlzdFJ1bnRpbWVPYmpzKHdyaXRlciwgbGlzdCkge1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUludERpY3Rpb25hcnkod3JpdGVyLCBkaWN0KSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkaWN0KSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIG9iaikge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBjb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXZlcnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBEaXZlcnRfMS5EaXZlcnQpO1xuICAgICAgICBpZiAoZGl2ZXJ0KSB7XG4gICAgICAgICAgICBsZXQgZGl2VHlwZUtleSA9IFwiLT5cIjtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcIngoKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2ZXJ0LnB1c2hlc1RvU3RhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2ZXJ0LnN0YWNrUHVzaFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcImYoKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZlcnQuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcIi0+dC0+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRhcmdldFN0cjtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBkaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U3RyID0gZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoZGl2VHlwZUtleSwgdGFyZ2V0U3RyKTtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZhclwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXZlcnQuaXNDb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY1wiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXZlcnQuZXh0ZXJuYWxBcmdzID4gMCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiZXhBcmdzXCIsIGRpdmVydC5leHRlcm5hbEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZVBvaW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ2hvaWNlUG9pbnRfMS5DaG9pY2VQb2ludCk7XG4gICAgICAgIGlmIChjaG9pY2VQb2ludCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiKlwiLCBjaG9pY2VQb2ludC5wYXRoU3RyaW5nT25DaG9pY2UpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJmbGdcIiwgY2hvaWNlUG9pbnQuZmxhZ3MpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBpZiAoaW50VmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnQoaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxvYXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkZsb2F0VmFsdWUpO1xuICAgICAgICBpZiAoZmxvYXRWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUZsb2F0KGZsb2F0VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgIGlmIChzdHJWYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJWYWwuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlKFwiXFxuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ1N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nSW5uZXIoXCJeXCIpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ0lubmVyKHN0clZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpc3RWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChsaXN0VmFsKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlSW5rTGlzdCh3cml0ZXIsIGxpc3RWYWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXZUYXJnZXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgaWYgKGRpdlRhcmdldFZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGlmIChkaXZUYXJnZXRWYWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImRpdlRhcmdldFZhbC52YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiXi0+XCIsIGRpdlRhcmdldFZhbC52YWx1ZS5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YXJQdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKHZhclB0clZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiXnZhclwiLCB2YXJQdHJWYWwudmFsdWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJjaVwiLCB2YXJQdHJWYWwuY29udGV4dEluZGV4KTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgR2x1ZV8xLkdsdWUpO1xuICAgICAgICBpZiAoZ2x1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKFwiPD5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRyb2xDbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgaWYgKGNvbnRyb2xDbWQpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShKc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lc1tjb250cm9sQ21kLmNvbW1hbmRUeXBlXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hdGl2ZUZ1bmMgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwpO1xuICAgICAgICBpZiAobmF0aXZlRnVuYykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBuYXRpdmVGdW5jLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcIl5cIilcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJMXlwiO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YXJSZWYgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKTtcbiAgICAgICAgaWYgKHZhclJlZikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGxldCByZWFkQ291bnRQYXRoID0gdmFyUmVmLnBhdGhTdHJpbmdGb3JDb3VudDtcbiAgICAgICAgICAgIGlmIChyZWFkQ291bnRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIkNOVD9cIiwgcmVhZENvdW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIlZBUj9cIiwgdmFyUmVmLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhckFzcyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhcmlhYmxlQXNzaWdubWVudF8xLlZhcmlhYmxlQXNzaWdubWVudCk7XG4gICAgICAgIGlmICh2YXJBc3MpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBsZXQga2V5ID0gdmFyQXNzLmlzR2xvYmFsID8gXCJWQVI9XCIgOiBcInRlbXA9XCI7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShrZXksIHZhckFzcy52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgLy8gUmVhc3NpZ25tZW50P1xuICAgICAgICAgICAgaWYgKCF2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInJlXCIsIHRydWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZvaWRPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWb2lkXzEuVm9pZCk7XG4gICAgICAgIGlmICh2b2lkT2JqKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCJ2b2lkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBUYWdfMS5UYWcpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIjXCIsIHRhZy50ZXh0KTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaG9pY2UgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDaG9pY2VfMS5DaG9pY2UpO1xuICAgICAgICBpZiAoY2hvaWNlKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlQ2hvaWNlKHdyaXRlciwgY2hvaWNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCBydW50aW1lIG9iamVjdCB0byBKc29uIHRva2VuOiBcIiArIG9iaik7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianMoak9iamVjdCkge1xuICAgICAgICBsZXQgZGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGpPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChqT2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5rT2JqZWN0ID0gdGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3Qoak9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5rT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaW5rT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWN0LnNldChrZXksIGlua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3QpIHtcbiAgICAgICAgbGV0IGRpY3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBqT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoak9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGljdC5zZXQoa2V5LCBwYXJzZUludChqT2JqZWN0W2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gICAgc3RhdGljIEpUb2tlblRvUnVudGltZU9iamVjdCh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm51bWJlclwiICYmICFpc05hTih0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBTdHJpbmcgdmFsdWVcbiAgICAgICAgICAgIGxldCBmaXJzdENoYXIgPSBzdHJbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09IFwiXlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzdHIuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0Q2hhciA9PSBcIlxcblwiICYmIHN0ci5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIik7XG4gICAgICAgICAgICAvLyBHbHVlXG4gICAgICAgICAgICBpZiAoc3RyID09IFwiPD5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdsdWVfMS5HbHVlKCk7XG4gICAgICAgICAgICAvLyBDb250cm9sIGNvbW1hbmRzICh3b3VsZCBsb29raW5nIHVwIGluIGEgaGFzaCBzZXQgYmUgZmFzdGVyPylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY21kTmFtZSA9IEpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gY21kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmF0aXZlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHN0ciA9PSBcIkxeXCIpXG4gICAgICAgICAgICAgICAgc3RyID0gXCJeXCI7XG4gICAgICAgICAgICBpZiAoTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxFeGlzdHNXaXRoTmFtZShzdHIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbFdpdGhOYW1lKHN0cik7XG4gICAgICAgICAgICAvLyBQb3BcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCItPi0+XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuUG9wVHVubmVsKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJ+cmV0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuUG9wRnVuY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIFZvaWRcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCJ2b2lkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkXzEuVm9pZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdG9rZW47XG4gICAgICAgICAgICBsZXQgcHJvcFZhbHVlO1xuICAgICAgICAgICAgLy8gRGl2ZXJ0IHRhcmdldCB2YWx1ZSB0byBwYXRoXG4gICAgICAgICAgICBpZiAob2JqW1wiXi0+XCJdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiXi0+XCJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZShuZXcgUGF0aF8xLlBhdGgocHJvcFZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhcmlhYmxlUG9pbnRlclZhbHVlXG4gICAgICAgICAgICBpZiAob2JqW1wiXnZhclwiXSkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcIl52YXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IHZhclB0ciA9IG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJjaVwiIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCJjaVwiXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyUHRyLmNvbnRleHRJbmRleCA9IHBhcnNlSW50KHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJQdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXZlcnRcbiAgICAgICAgICAgIGxldCBpc0RpdmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIGxldCBleHRlcm5hbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCItPlwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZigpXCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCItPnQtPlwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaGVzVG9TdGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGl2UHVzaFR5cGUgPSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIngoKVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpdmVydCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXZlcnQgPSBuZXcgRGl2ZXJ0XzEuRGl2ZXJ0KCk7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LnB1c2hlc1RvU3RhY2sgPSBwdXNoZXNUb1N0YWNrO1xuICAgICAgICAgICAgICAgIGRpdmVydC5zdGFja1B1c2hUeXBlID0gZGl2UHVzaFR5cGU7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LmlzRXh0ZXJuYWwgPSBleHRlcm5hbDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJ2YXJcIl0pKVxuICAgICAgICAgICAgICAgICAgICBkaXZlcnQudmFyaWFibGVEaXZlcnROYW1lID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmcgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LmlzQ29uZGl0aW9uYWwgPSAhIW9ialtcImNcIl07XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZXhBcmdzXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVydC5leHRlcm5hbEFyZ3MgPSBwYXJzZUludChwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2ZXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hvaWNlXG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIipcIl0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgY2hvaWNlLnBhdGhTdHJpbmdPbkNob2ljZSA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZmxnXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmZsYWdzID0gcGFyc2VJbnQocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIlZBUj9cIl0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJDTlQ/XCJdKSkge1xuICAgICAgICAgICAgICAgIGxldCByZWFkQ291bnRWYXJSZWYgPSBuZXcgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIHJlYWRDb3VudFZhclJlZi5wYXRoU3RyaW5nRm9yQ291bnQgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvdW50VmFyUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGUgYXNzaWdubWVudFxuICAgICAgICAgICAgbGV0IGlzVmFyQXNzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXNHbG9iYWxWYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiVkFSPVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhckFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNHbG9iYWxWYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcInRlbXA9XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzVmFyQXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc0dsb2JhbFZhciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFyQXNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhck5hbWUgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNOZXdEZWNsID0gIW9ialtcInJlXCJdO1xuICAgICAgICAgICAgICAgIGxldCB2YXJBc3MgPSBuZXcgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KHZhck5hbWUsIGlzTmV3RGVjbCk7XG4gICAgICAgICAgICAgICAgdmFyQXNzLmlzR2xvYmFsID0gaXNHbG9iYWxWYXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhckFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmpbXCIjXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCIjXCJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFnXzEuVGFnKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpc3QgdmFsdWVcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wibGlzdFwiXSkpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgbGlzdENvbnRlbnQgPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0Q29udGVudCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wib3JpZ2luc1wiXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIG5hbWVzQXNPYmpzID0gKExpc3Q8b2JqZWN0Pilwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lc0FzT2JqcyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmF3TGlzdC5TZXRJbml0aWFsT3JpZ2luTmFtZXMobmFtZXNBc09ianMuQ2FzdDxzdHJpbmc+KCkuVG9MaXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICByYXdMaXN0LlNldEluaXRpYWxPcmlnaW5OYW1lcyhuYW1lc0FzT2Jqcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBsaXN0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdENvbnRlbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVUb1ZhbCA9IGxpc3RDb250ZW50W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwYXJzZUludChuYW1lVG9WYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5BZGQoaXRlbSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJhd0xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ialtcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkpPYmplY3RUb0Nob2ljZShvYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IGlzIGFsd2F5cyBhIFJ1bnRpbWUuQ29udGFpbmVyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkFycmF5VG9Db250YWluZXIodG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCB8fCB0b2tlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHRva2VuIHRvIHJ1bnRpbWUgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBjb250YWluZXIsIHdpdGhvdXROYW1lID0gZmFsc2UpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRhaW5lci5jb250ZW50KVxuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCBjKTtcbiAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnQgPSBjb250YWluZXIubmFtZWRPbmx5Q29udGVudDtcbiAgICAgICAgbGV0IGNvdW50RmxhZ3MgPSBjb250YWluZXIuY291bnRGbGFncztcbiAgICAgICAgbGV0IGhhc05hbWVQcm9wZXJ0eSA9IGNvbnRhaW5lci5uYW1lICE9IG51bGwgJiYgIXdpdGhvdXROYW1lO1xuICAgICAgICBsZXQgaGFzVGVybWluYXRvciA9IG5hbWVkT25seUNvbnRlbnQgIT0gbnVsbCB8fCBjb3VudEZsYWdzID4gMCB8fCBoYXNOYW1lUHJvcGVydHk7XG4gICAgICAgIGlmIChoYXNUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lZE9ubHlDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBuYW1lZE9ubHlDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVkQ29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBuYW1lZENvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTmFtZVByb3BlcnR5KVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIjblwiLCBjb250YWluZXIubmFtZSk7XG4gICAgICAgIGlmIChoYXNUZXJtaW5hdG9yKVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU51bGwoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIEpBcnJheVRvQ29udGFpbmVyKGpBcnJheSkge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICBjb250YWluZXIuY29udGVudCA9IHRoaXMuSkFycmF5VG9SdW50aW1lT2JqTGlzdChqQXJyYXksIHRydWUpO1xuICAgICAgICBsZXQgdGVybWluYXRpbmdPYmogPSBqQXJyYXlbakFycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGVybWluYXRpbmdPYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGVybWluYXRpbmdPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiI2ZcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY291bnRGbGFncyA9IHBhcnNlSW50KHRlcm1pbmF0aW5nT2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT0gXCIjblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lID0gdGVybWluYXRpbmdPYmpba2V5XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkQ29udGVudEl0ZW0gPSB0aGlzLkpUb2tlblRvUnVudGltZU9iamVjdCh0ZXJtaW5hdGluZ09ialtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIG5hbWVkU3ViQ29udGFpbmVyID0gbmFtZWRDb250ZW50SXRlbSBhcyBDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lZFN1YkNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChuYW1lZENvbnRlbnRJdGVtLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZWRTdWJDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lZFN1YkNvbnRhaW5lci5uYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50LnNldChrZXksIG5hbWVkQ29udGVudEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lZE9ubHlDb250ZW50ID0gbmFtZWRPbmx5Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBzdGF0aWMgSk9iamVjdFRvQ2hvaWNlKGpPYmopIHtcbiAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VfMS5DaG9pY2UoKTtcbiAgICAgICAgY2hvaWNlLnRleHQgPSBqT2JqW1widGV4dFwiXS50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2UuaW5kZXggPSBwYXJzZUludChqT2JqW1wiaW5kZXhcIl0pO1xuICAgICAgICBjaG9pY2Uuc291cmNlUGF0aCA9IGpPYmpbXCJvcmlnaW5hbENob2ljZVBhdGhcIl0udG9TdHJpbmcoKTtcbiAgICAgICAgY2hvaWNlLm9yaWdpbmFsVGhyZWFkSW5kZXggPSBwYXJzZUludChqT2JqW1wib3JpZ2luYWxUaHJlYWRJbmRleFwiXSk7XG4gICAgICAgIGNob2ljZS5wYXRoU3RyaW5nT25DaG9pY2UgPSBqT2JqW1widGFyZ2V0UGF0aFwiXS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVDaG9pY2Uod3JpdGVyLCBjaG9pY2UpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ0ZXh0XCIsIGNob2ljZS50ZXh0KTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpbmRleFwiLCBjaG9pY2UuaW5kZXgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiLCBjaG9pY2Uuc291cmNlUGF0aCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwib3JpZ2luYWxUaHJlYWRJbmRleFwiLCBjaG9pY2Uub3JpZ2luYWxUaHJlYWRJbmRleCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidGFyZ2V0UGF0aFwiLCBjaG9pY2UucGF0aFN0cmluZ09uQ2hvaWNlKTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUlua0xpc3Qod3JpdGVyLCBsaXN0VmFsKSB7XG4gICAgICAgIGxldCByYXdMaXN0ID0gbGlzdFZhbC52YWx1ZTtcbiAgICAgICAgaWYgKHJhd0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmF3TGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdFwiKTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiByYXdMaXN0KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgbGV0IGl0ZW1WYWwgPSB2YWw7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5pdGVtTmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZVN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihpdGVtLm9yaWdpbk5hbWUgPyBpdGVtLm9yaWdpbk5hbWUgOiBcIj9cIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihcIi5cIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKGl0ZW1WYWwpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgaWYgKHJhd0xpc3QuQ291bnQgPT0gMCAmJlxuICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5OYW1lcyAhPSBudWxsICYmXG4gICAgICAgICAgICByYXdMaXN0Lm9yaWdpbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJvcmlnaW5zXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiByYXdMaXN0Lm9yaWdpbk5hbWVzKVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZShuYW1lKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdERlZmluaXRpb25zVG9KVG9rZW4ob3JpZ2luKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmIG9mIG9yaWdpbi5saXN0cykge1xuICAgICAgICAgICAgbGV0IGxpc3REZWZKc29uID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGRlZi5pdGVtcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0RGVmSnNvbltpdGVtLml0ZW1OYW1lXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtkZWYubmFtZV0gPSBsaXN0RGVmSnNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgSlRva2VuVG9MaXN0RGVmaW5pdGlvbnMob2JqKSB7XG4gICAgICAgIC8vIHZhciBkZWZzT2JqID0gKERpY3Rpb25hcnk8c3RyaW5nLCBvYmplY3Q+KW9iajtcbiAgICAgICAgbGV0IGRlZnNPYmogPSBvYmo7XG4gICAgICAgIGxldCBhbGxEZWZzID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBkZWZzT2JqKSB7XG4gICAgICAgICAgICBpZiAoZGVmc09iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgbGlzdERlZkpzb24gPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pa3YuVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3REZWZKc29uID0gZGVmc09ialtrZXldO1xuICAgICAgICAgICAgICAgIC8vIENhc3QgKHN0cmluZywgb2JqZWN0KSB0byAoc3RyaW5nLCBpbnQpIGZvciBpdGVtc1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lVmFsdWVLZXkgaW4gbGlzdERlZkpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZnNPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVWYWx1ZSA9IGxpc3REZWZKc29uW25hbWVWYWx1ZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXQobmFtZVZhbHVlS2V5LCBwYXJzZUludChuYW1lVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVmID0gbmV3IExpc3REZWZpbml0aW9uXzEuTGlzdERlZmluaXRpb24obmFtZSwgaXRlbXMpO1xuICAgICAgICAgICAgICAgIGFsbERlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGlzdERlZmluaXRpb25zT3JpZ2luXzEuTGlzdERlZmluaXRpb25zT3JpZ2luKGFsbERlZnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblNlcmlhbGlzYXRpb24gPSBKc29uU2VyaWFsaXNhdGlvbjtcbkpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzID0gKCgpID0+IHtcbiAgICBsZXQgX2NvbnRyb2xDb21tYW5kTmFtZXMgPSBbXTtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxTdGFydF0gPSBcImV2XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsT3V0cHV0XSA9IFwib3V0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsRW5kXSA9IFwiL2V2XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGVdID0gXCJkdVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWVdID0gXCJwb3BcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uXSA9IFwifnJldFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsXSA9IFwiLT4tPlwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmddID0gXCJzdHJcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZFN0cmluZ10gPSBcIi9zdHJcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vT3BdID0gXCJub3BcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50XSA9IFwiY2hvaWNlQ250XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc10gPSBcInR1cm5cIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2VdID0gXCJ0dXJuc1wiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50XSA9IFwicmVhZGNcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJhbmRvbV0gPSBcInJuZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbV0gPSBcInNybmRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXhdID0gXCJ2aXNpdFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXhdID1cbiAgICAgICAgXCJzZXFcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkXSA9IFwidGhyZWFkXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lXSA9IFwiZG9uZVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kXSA9IFwiZW5kXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludF0gPSBcImxpc3RJbnRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5nZV0gPSBcInJhbmdlXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZG9tXSA9IFwibHJuZFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UT1RBTF9WQUxVRVM7ICsraSkge1xuICAgICAgICBpZiAoX2NvbnRyb2xDb21tYW5kTmFtZXNbaV0gPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyb2wgY29tbWFuZCBub3QgYWNjb3VudGVkIGZvciBpbiBzZXJpYWxpc2F0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnRyb2xDb21tYW5kTmFtZXM7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SnNvblNlcmlhbGlzYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3REZWZpbml0aW9uID0gdm9pZCAwO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNsYXNzIExpc3REZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpdGVtcykge1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMgPSBpdGVtcyB8fCBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RfMS5JbmtMaXN0SXRlbSh0aGlzLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuc2V0KGl0ZW0uc2VyaWFsaXplZCgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cbiAgICBWYWx1ZUZvckl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGludFZhbCA9IHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIGludFZhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBDb250YWluc0l0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgIT0gdGhpcy5uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5oYXMoaXRlbS5pdGVtTmFtZSk7XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbVdpdGhOYW1lKGl0ZW1OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyhpdGVtTmFtZSk7XG4gICAgfVxuICAgIFRyeUdldEl0ZW1XaXRoVmFsdWUodmFsLCBcbiAgICAvKiBvdXQgKi8gaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IHZhbCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgSW5rTGlzdF8xLklua0xpc3RJdGVtKHRoaXMubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGl0ZW0sIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbDtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpdGVtLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFRyeUdldFZhbHVlRm9ySXRlbShpdGVtLCBcbiAgICAvKiBvdXQgKi8gaW50VmFsKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogMCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmdldChpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogMCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3REZWZpbml0aW9uID0gTGlzdERlZmluaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0RGVmaW5pdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdERlZmluaXRpb25zT3JpZ2luID0gdm9pZCAwO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBMaXN0RGVmaW5pdGlvbnNPcmlnaW4ge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RzKSB7XG4gICAgICAgIHRoaXMuX2xpc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBsaXN0IG9mIGxpc3RzKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0cy5zZXQobGlzdC5uYW1lLCBsaXN0KTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgbGlzdC5pdGVtcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShpdGVtLCB2YWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpdGVtLml0ZW1OYW1lIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5zZXQoaXRlbS5pdGVtTmFtZSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChpdGVtLmZ1bGxOYW1lLCBsaXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsaXN0cygpIHtcbiAgICAgICAgbGV0IGxpc3RPZkxpc3RzID0gW107XG4gICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiB0aGlzLl9saXN0cykge1xuICAgICAgICAgICAgbGlzdE9mTGlzdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RPZkxpc3RzO1xuICAgIH1cbiAgICBUcnlMaXN0R2V0RGVmaW5pdGlvbihuYW1lLCBcbiAgICAvKiBvdXQgKi8gZGVmKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZiwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGluaXRpYWxseSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm9vbGVhbiBhbmQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYW4gb3V0LlxuICAgICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuX2xpc3RzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWYsIGV4aXN0czogZmFsc2UgfTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZpbml0aW9uLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgRmluZFNpbmdsZUl0ZW1MaXN0V2l0aE5hbWUobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbnNPcmlnaW4gPSBMaXN0RGVmaW5pdGlvbnNPcmlnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0RGVmaW5pdGlvbnNPcmlnaW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hdGl2ZUZ1bmN0aW9uQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIE5hdGl2ZUZ1bmN0aW9uQ2FsbCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnMgPSAwO1xuICAgICAgICB0aGlzLl9wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1Byb3RvdHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25GdW5jcyA9IG51bGw7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgTmF0aXZlRnVuY3Rpb25DYWxsLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5faXNQcm90b3R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbWV0ZXJzID0gbnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBDYWxsV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIHN0YXRpYyBDYWxsRXhpc3RzV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlRnVuY3Rpb25zLmdldChmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hbWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Byb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKE5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b3R5cGUgPVxuICAgICAgICAgICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9ucy5nZXQodGhpcy5fbmFtZSkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG90eXBlLm51bWJlck9mUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IG51bWJlck9mUGFyYW1ldGVycyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ2FsbChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b3R5cGUuQ2FsbChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5udW1iZXJPZlBhcmFtZXRlcnMgIT0gcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhc0xpc3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKCdBdHRlbXB0aW5nIHRvIHBlcmZvcm0gb3BlcmF0aW9uIG9uIGEgdm9pZCB2YWx1ZS4gRGlkIHlvdSBmb3JnZXQgdG8gXCJyZXR1cm5cIiBhIHZhbHVlIGZyb20gYSBmdW5jdGlvbiB5b3UgY2FsbGVkIGhlcmU/Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFZhbHVlXzEuTGlzdFZhbHVlKVxuICAgICAgICAgICAgICAgIGhhc0xpc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCA9PSAyICYmIGhhc0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2VyY2VkUGFyYW1zID0gdGhpcy5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUocGFyYW1ldGVycyk7XG4gICAgICAgIGxldCBjb2VyY2VkVHlwZSA9IGNvZXJjZWRQYXJhbXNbMF0udmFsdWVUeXBlO1xuICAgICAgICBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBDYWxsVHlwZShwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlKSB7XG4gICAgICAgIGxldCBwYXJhbTEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlWzBdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgbGV0IHZhbFR5cGUgPSBwYXJhbTEudmFsdWVUeXBlO1xuICAgICAgICBsZXQgdmFsMSA9IHBhcmFtMTtcbiAgICAgICAgbGV0IHBhcmFtQ291bnQgPSBwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlLmxlbmd0aDtcbiAgICAgICAgaWYgKHBhcmFtQ291bnQgPT0gMiB8fCBwYXJhbUNvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7XG4gICAgICAgICAgICBsZXQgb3BGb3JUeXBlT2JqID0gdGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KHZhbFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFvcEZvclR5cGVPYmopIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBWYWx1ZV8xLlZhbHVlVHlwZVt2YWxUeXBlXTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBcIiArIHRoaXMubmFtZSArIFwiIG9uIFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbUNvdW50ID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW0yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc09mU2luZ2xlVHlwZVsxXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbDIgPSBwYXJhbTI7XG4gICAgICAgICAgICAgICAgbGV0IG9wRm9yVHlwZSA9IG9wRm9yVHlwZU9iajtcbiAgICAgICAgICAgICAgICBpZiAodmFsMS52YWx1ZSA9PT0gbnVsbCB8fCB2YWwyLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIEJpbmFyeU9wIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VmFsID0gb3BGb3JUeXBlKHZhbDEudmFsdWUsIHZhbDIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wRm9yVHlwZSA9IG9wRm9yVHlwZU9iajtcbiAgICAgICAgICAgICAgICBpZiAodmFsMS52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbCBVbmFyeU9wIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRWYWwgPSBvcEZvclR5cGUodmFsMS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGlzIGRpZmZlcmVudCBmcm9tIHVwc3RyZWFtLiBTaW5jZSBKYXZhU2NyaXB0IHRyZWF0c1xuICAgICAgICAgICAgICAgIC8vIGludGVnZXJzIGFuZCBmbG9hdHMgYXMgdGhlIHNhbWUgbnVtYmVycywgaXQncyBpbXBvc3NpYmxlXG4gICAgICAgICAgICAgICAgLy8gdG8gZm9yY2UgYW4gbnVtYmVyIHRvIGJlIGVpdGhlciBhbiBpbnRlZ2VyIG9yIGEgZmxvYXQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJdCBjYW4gYmUgdXNlZnVsIHRvIGZvcmNlIGEgc3BlY2lmaWMgbnVtYmVyIHR5cGVcbiAgICAgICAgICAgICAgICAvLyAoZXNwZWNpYWxseSBmb3IgZGl2aXNpb25zKSwgc28gdGhlIHJlc3VsdCBvZiBJTlQoKSAmIEZMT0FUKClcbiAgICAgICAgICAgICAgICAvLyBpcyBjb2VyY2VkIHRvIHRoZSB0aGUgcHJvcGVyIHZhbHVlIHR5cGUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgYWxzbyBmb3JjZSBhbGwgb3RoZXIgdW5hcnkgb3BlcmF0aW9uIHRvXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIHR5cGUsIGFsdGhvdWdoIHRoaXMgaXMgb25seVxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZm9yIG51bWJlcnMuIFNlZSBgVmFsdWUuQ3JlYXRlYC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lID09PSBOYXRpdmVGdW5jdGlvbkNhbGwuSW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIFZhbHVlXzEuVmFsdWVUeXBlLkludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gTmF0aXZlRnVuY3Rpb25DYWxsLkZsb2F0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIHBhcmFtMS52YWx1ZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgdG8gTmF0aXZlRnVuY3Rpb25DYWxsOiBcIiArXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc09mU2luZ2xlVHlwZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCh0aGlzLm5hbWUgPT0gXCIrXCIgfHwgdGhpcy5uYW1lID09IFwiLVwiKSAmJlxuICAgICAgICAgICAgcGFyYW1ldGVyc1swXSBpbnN0YW5jZW9mIFZhbHVlXzEuTGlzdFZhbHVlICYmXG4gICAgICAgICAgICBwYXJhbWV0ZXJzWzFdIGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uKHBhcmFtZXRlcnMpO1xuICAgICAgICBsZXQgdjEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzWzBdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgbGV0IHYyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc1sxXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGlmICgodGhpcy5uYW1lID09IFwiJiZcIiB8fCB0aGlzLm5hbWUgPT0gXCJ8fFwiKSAmJlxuICAgICAgICAgICAgKHYxLnZhbHVlVHlwZSAhPSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0IHx8IHYyLnZhbHVlVHlwZSAhPSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBvcCA9IHRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uIG9wXCIpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9wKHYxLmlzVHJ1dGh5ID8gMSA6IDAsIHYyLmlzVHJ1dGh5ID8gMSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkludFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYxLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0ICYmIHYyLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoW3YxLCB2Ml0pO1xuICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbiBub3QgY2FsbCB1c2UgXCIgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgIFwiIG9wZXJhdGlvbiBvbiBcIiArXG4gICAgICAgICAgICBWYWx1ZV8xLlZhbHVlVHlwZVt2MS52YWx1ZVR5cGVdICtcbiAgICAgICAgICAgIFwiIGFuZCBcIiArXG4gICAgICAgICAgICBWYWx1ZV8xLlZhbHVlVHlwZVt2Mi52YWx1ZVR5cGVdKTtcbiAgICB9XG4gICAgQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24obGlzdEludFBhcmFtcykge1xuICAgICAgICBsZXQgbGlzdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGxpc3RJbnRQYXJhbXNbMF0sIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGxpc3RJbnRQYXJhbXNbMV0sIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBsZXQgcmVzdWx0SW5rTGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICBpZiAobGlzdFZhbC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWVcIik7XG4gICAgICAgIGZvciAobGV0IFtsaXN0SXRlbUtleSwgbGlzdEl0ZW1WYWx1ZV0gb2YgbGlzdFZhbC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGxpc3RJdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGxpc3RJdGVtS2V5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7XG4gICAgICAgICAgICBsZXQgaW50T3AgPSB0aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQoVmFsdWVfMS5WYWx1ZVR5cGUuSW50KTtcbiAgICAgICAgICAgIGlmIChpbnRWYWwudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gaW50VmFsLnZhbHVlXCIpO1xuICAgICAgICAgICAgbGV0IHRhcmdldEludCA9IGludE9wKGxpc3RJdGVtVmFsdWUsIGludFZhbC52YWx1ZSk7XG4gICAgICAgICAgICBsZXQgaXRlbU9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGlzdFZhbC52YWx1ZS5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWUub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiBsaXN0VmFsLnZhbHVlLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLm5hbWUgPT0gbGlzdEl0ZW0ub3JpZ2luTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbU9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluY3JlbWVudGVkSXRlbSA9IGl0ZW1PcmlnaW4uVHJ5R2V0SXRlbVdpdGhWYWx1ZSh0YXJnZXRJbnQsIElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50ZWRJdGVtLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SW5rTGlzdC5BZGQoaW5jcmVtZW50ZWRJdGVtLnJlc3VsdCwgdGFyZ2V0SW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJlc3VsdElua0xpc3QpO1xuICAgIH1cbiAgICBDb2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUocGFyYW1ldGVyc0luKSB7XG4gICAgICAgIGxldCB2YWxUeXBlID0gVmFsdWVfMS5WYWx1ZVR5cGUuSW50O1xuICAgICAgICBsZXQgc3BlY2lhbENhc2VMaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHBhcmFtZXRlcnNJbikge1xuICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsLnZhbHVlVHlwZSA+IHZhbFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YWxUeXBlID0gdmFsLnZhbHVlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsQ2FzZUxpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtZXRlcnNPdXQgPSBbXTtcbiAgICAgICAgaWYgKFZhbHVlXzEuVmFsdWVUeXBlW3ZhbFR5cGVdID09IFZhbHVlXzEuVmFsdWVUeXBlW1ZhbHVlXzEuVmFsdWVUeXBlLkxpc3RdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmtPYmplY3RWYWwgb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGlua09iamVjdFZhbCwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT3V0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IHBhcnNlSW50KHZhbC52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxDYXNlTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHNwZWNpYWxDYXNlTGlzdCwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENhc2VMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIHNwZWNpYWxDYXNlTGlzdC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBzcGVjaWFsQ2FzZUxpc3QudmFsdWUub3JpZ2luT2ZNYXhJdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSBsaXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IGxpc3QuVHJ5R2V0SXRlbVdpdGhWYWx1ZShpbnRWYWwsIElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FzdGVkVmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoaXRlbS5yZXN1bHQsIGludFZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT3V0LnB1c2goY2FzdGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ291bGQgbm90IGZpbmQgTGlzdCBpdGVtIHdpdGggdGhlIHZhbHVlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRWYWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gVmFsdWVfMS5WYWx1ZVR5cGVbdmFsLnZhbHVlVHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IG1peCBMaXN0cyBhbmQgXCIgKyBrZXkgKyBcIiB2YWx1ZXMgaW4gdGhpcyBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5rT2JqZWN0VmFsIG9mIHBhcmFtZXRlcnNJbikge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhpbmtPYmplY3RWYWwsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBjYXN0ZWRWYWx1ZSA9IHZhbC5DYXN0KHZhbFR5cGUpO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaChjYXN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNPdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBJZGVudGl0eSh0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBzdGF0aWMgR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUZ1bmN0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBJbnQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwgKHgsIHkpID0+IHggLSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NdWx0aXBseSwgKHgsIHkpID0+IHggKiB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5EaXZpZGUsICh4LCB5KSA9PiBNYXRoLmZsb29yKHggLyB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTW9kLCAoeCwgeSkgPT4geCAlIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTmVnYXRlLCAoeCkgPT4gLXgpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHggPT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4ID4geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzcywgKHgsIHkpID0+ICh4IDwgeSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+ICh4ID49IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiAoeCA8PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoeCAhPSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLk5vdCwgKHgpID0+ICh4ID09IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+ICh4ICE9IDAgJiYgeSAhPSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+ICh4ICE9IDAgfHwgeSAhPSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NYXgsICh4LCB5KSA9PiBNYXRoLm1heCh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTWluLCAoeCwgeSkgPT4gTWF0aC5taW4oeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlBvdywgKHgsIHkpID0+IE1hdGgucG93KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb29yLCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuQ2VpbGluZywgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkludCwgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb2F0LCAoeCkgPT4geCk7XG4gICAgICAgICAgICAvLyBGbG9hdCBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4ICsgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwgKHgsIHkpID0+IHggLSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCAoeCwgeSkgPT4geCAqIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuRGl2aWRlLCAoeCwgeSkgPT4geCAvIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTW9kLCAoeCwgeSkgPT4geCAlIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5OZWdhdGUsICh4KSA9PiAteCk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4ID09IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4ID4geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzLCAoeCwgeSkgPT4gKHggPCB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4ID49IHkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4gKHggPD0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoeCAhPSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuTm90LCAoeCkgPT4gKHggPT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+ICh4ICE9IDAuMCAmJiB5ICE9IDAuMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+ICh4ICE9IDAuMCB8fCB5ICE9IDAuMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NYXgsICh4LCB5KSA9PiBNYXRoLm1heCh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NaW4sICh4LCB5KSA9PiBNYXRoLm1pbih4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Qb3csICh4LCB5KSA9PiBNYXRoLnBvdyh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkZsb29yLCAoeCkgPT4gTWF0aC5mbG9vcih4KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkNlaWxpbmcsICh4KSA9PiBNYXRoLmNlaWwoeCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5JbnQsICh4KSA9PiBNYXRoLmZsb29yKHgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvYXQsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICAvLyBTdHJpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTsgLy8gY29uY2F0XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeCA9PT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKCEoeCA9PT0geSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhcywgKHgsIHkpID0+ICh4LmluY2x1ZGVzKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5IYXNudCwgKHgsIHkpID0+ICh4LmluY2x1ZGVzKHkpID8gMCA6IDEpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geC5Vbmlvbih5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geC5XaXRob3V0KHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSGFzLCAoeCwgeSkgPT4gKHguQ29udGFpbnMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXNudCwgKHgsIHkpID0+ICh4LkNvbnRhaW5zKHkpID8gMCA6IDEpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSW50ZXJzZWN0LCAoeCwgeSkgPT4geC5JbnRlcnNlY3QoeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4LkVxdWFscyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsICh4LCB5KSA9PiAoeC5HcmVhdGVyVGhhbih5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3MsICh4LCB5KSA9PiAoeC5MZXNzVGhhbih5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4LkdyZWF0ZXJUaGFuT3JFcXVhbHMoeSkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4Lkxlc3NUaGFuT3JFcXVhbHMoeSkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICgheC5FcXVhbHMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BbmQsICh4LCB5KSA9PiB4LkNvdW50ID4gMCAmJiB5LkNvdW50ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuT3IsICh4LCB5KSA9PiB4LkNvdW50ID4gMCB8fCB5LkNvdW50ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5Ob3QsICh4KSA9PiAoeC5Db3VudCA9PSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5JbnZlcnQsICh4KSA9PiB4LmludmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkFsbCwgKHgpID0+IHguYWxsKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWluLCAoeCkgPT4geC5NaW5Bc0xpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTGlzdE1heCwgKHgpID0+IHguTWF4QXNMaXN0KCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkNvdW50LCAoeCkgPT4geC5Db3VudCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuVmFsdWVPZkxpc3QsICh4KSA9PiB4Lm1heEl0ZW0uVmFsdWUpO1xuICAgICAgICAgICAgbGV0IGRpdmVydFRhcmdldHNFcXVhbCA9IChkMSwgZDIpID0+IChkMS5FcXVhbHMoZDIpID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IGRpdmVydFRhcmdldHNOb3RFcXVhbCA9IChkMSwgZDIpID0+IGQxLkVxdWFscyhkMikgPyAwIDogMTtcbiAgICAgICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmModGhpcy5FcXVhbCwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0LCBkaXZlcnRUYXJnZXRzRXF1YWwpO1xuICAgICAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLk5vdEVxdWFscywgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0LCBkaXZlcnRUYXJnZXRzTm90RXF1YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZE9wRnVuY0ZvclR5cGUodmFsVHlwZSwgb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzLnNldCh2YWxUeXBlLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCBhcmdzLCB2YWxUeXBlLCBvcCkge1xuICAgICAgICBpZiAodGhpcy5fbmF0aXZlRnVuY3Rpb25zID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTtcbiAgICAgICAgbGV0IG5hdGl2ZUZ1bmMgPSB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5hdGl2ZUZ1bmMpIHtcbiAgICAgICAgICAgIG5hdGl2ZUZ1bmMgPSBuZXcgTmF0aXZlRnVuY3Rpb25DYWxsKG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnVuY3Rpb25zLnNldChuYW1lLCBuYXRpdmVGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBuYXRpdmVGdW5jLkFkZE9wRnVuY0ZvclR5cGUodmFsVHlwZSwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkSW50QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEludFVuYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAxLCBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEZsb2F0QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkRmxvYXRVbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMSwgVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZFN0cmluZ0JpbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuU3RyaW5nLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRMaXN0QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRMaXN0VW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDEsIFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QsIG9wKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnTmF0aXZlIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgfVxufVxuZXhwb3J0cy5OYXRpdmVGdW5jdGlvbkNhbGwgPSBOYXRpdmVGdW5jdGlvbkNhbGw7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQWRkID0gXCIrXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuU3VidHJhY3QgPSBcIi1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5EaXZpZGUgPSBcIi9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NdWx0aXBseSA9IFwiKlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk1vZCA9IFwiJVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5lZ2F0ZSA9IFwiX1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkVxdWFsID0gXCI9PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkdyZWF0ZXIgPSBcIj5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MZXNzID0gXCI8XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuR3JlYXRlclRoYW5PckVxdWFscyA9IFwiPj1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MZXNzVGhhbk9yRXF1YWxzID0gXCI8PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5vdEVxdWFscyA9IFwiIT1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Ob3QgPSBcIiFcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5BbmQgPSBcIiYmXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuT3IgPSBcInx8XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTWluID0gXCJNSU5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NYXggPSBcIk1BWFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLlBvdyA9IFwiUE9XXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRmxvb3IgPSBcIkZMT09SXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQ2VpbGluZyA9IFwiQ0VJTElOR1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkludCA9IFwiSU5UXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRmxvYXQgPSBcIkZMT0FUXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSGFzID0gXCI/XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSGFzbnQgPSBcIiE/XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW50ZXJzZWN0ID0gXCJeXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTGlzdE1pbiA9IFwiTElTVF9NSU5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MaXN0TWF4ID0gXCJMSVNUX01BWFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkFsbCA9IFwiTElTVF9BTExcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db3VudCA9IFwiTElTVF9DT1VOVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLlZhbHVlT2ZMaXN0ID0gXCJMSVNUX1ZBTFVFXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW52ZXJ0ID0gXCJMSVNUX0lOVkVSVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnMgPSBudWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmF0aXZlRnVuY3Rpb25DYWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aHJvd051bGxFeGNlcHRpb24gPSBleHBvcnRzLk51bGxFeGNlcHRpb24gPSB2b2lkIDA7XG4vKipcbiAqIEluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLCBhIFN5c3RlbUV4Y2VwdGlvbiB3b3VsZCBiZSB0aHJvd24gd2hlbiBwYXNzaW5nXG4gKiBudWxsIHRvIG1ldGhvZHMgZXhwZWN0ZWQgYSB2YWxpZCBpbnN0YW5jZS4gSmF2YXNjcmlwdCBoYXMgbm8gc3VjaFxuICogY29uY2VwdCwgYnV0IFR5cGVTY3JpcHQgd2lsbCBub3QgYWxsb3cgYG51bGxgIHRvIGJlIHBhc3NlZCB0byBtZXRob2RzXG4gKiBleHBsaWNpdGVseSByZXF1aXJpbmcgYSB2YWxpZCB0eXBlLlxuICpcbiAqIFdoZW5ldmVyIFR5cGVTY3JpcHQgY29tcGxhaW4gYWJvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYG51bGxgIHZhbHVlLFxuICogY2hlY2sgdGhlIG9mZmVuZGluZyB2YWx1ZSBhbmQgaXQgaXQncyBudWxsLCB0aHJvdyB0aGlzIGV4Y2VwdGlvbiB1c2luZ1xuICogYHRocm93TnVsbEV4Y2VwdGlvbihuYW1lOiBzdHJpbmcpYC5cbiAqL1xuY2xhc3MgTnVsbEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuTnVsbEV4Y2VwdGlvbiA9IE51bGxFeGNlcHRpb247XG4vKipcbiAqIFRocm93IGEgTnVsbEV4Y2VwdGlvbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSBhIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBvZmZlbmRpbmcgdmFsdWUgKG9mdGVuIGl0cyBuYW1lIHdpdGhpbiB0aGUgY29kZSkuXG4gKi9cbmZ1bmN0aW9uIHRocm93TnVsbEV4Y2VwdGlvbihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IE51bGxFeGNlcHRpb24oYCR7bmFtZX0gaXMgbnVsbCBvciB1bmRlZmluZWRgKTtcbn1cbmV4cG9ydHMudGhyb3dOdWxsRXhjZXB0aW9uID0gdGhyb3dOdWxsRXhjZXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVsbEV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5rT2JqZWN0ID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBJbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlYnVnTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGRlYnVnTWV0YWRhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z01ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdNZXRhZGF0YTtcbiAgICB9XG4gICAgc2V0IGRlYnVnTWV0YWRhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVidWdNZXRhZGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb3duRGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnTWV0YWRhdGE7XG4gICAgfVxuICAgIERlYnVnTGluZU51bWJlck9mUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgYSBsaW5lIG51bWJlciBmcm9tIGRlYnVnIG1ldGFkYXRhXG4gICAgICAgIGxldCByb290ID0gdGhpcy5yb290Q29udGVudENvbnRhaW5lcjtcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRDb250ZW50ID0gcm9vdC5Db250ZW50QXRQYXRoKHBhdGgpLm9iajtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRtID0gdGFyZ2V0Q29udGVudC5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG0uc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aCA9IG5ldyBQYXRoXzEuUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcztcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGNoaWxkLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lZENoaWxkID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lZENoaWxkICE9IG51bGwgJiYgbmFtZWRDaGlsZC5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBzLnVuc2hpZnQobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudChuYW1lZENoaWxkLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBzLnVuc2hpZnQobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudChjb250YWluZXIuY29udGVudC5pbmRleE9mKGNoaWxkKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY29udGFpbmVyLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aCA9IG5ldyBQYXRoXzEuUGF0aChjb21wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfVxuICAgIFJlc29sdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBhdGhcIik7XG4gICAgICAgIGlmIChwYXRoLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobmVhcmVzdENvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHRoaXMucGFyZW50ICE9PSBudWxsLCBcIkNhbid0IHJlc29sdmUgcmVsYXRpdmUgcGF0aCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYSBwYXJlbnRcIik7XG4gICAgICAgICAgICAgICAgbmVhcmVzdENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydChuZWFyZXN0Q29udGFpbmVyICE9PSBudWxsLCBcIkV4cGVjdGVkIHBhcmVudCB0byBiZSBhIGNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydChwYXRoLkdldENvbXBvbmVudCgwKS5pc1BhcmVudCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgudGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWFyZXN0Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuZWFyZXN0Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5lYXJlc3RDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50Q29udGFpbmVyID0gdGhpcy5yb290Q29udGVudENvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb250ZW50Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb252ZXJ0UGF0aFRvUmVsYXRpdmUoZ2xvYmFsUGF0aCkge1xuICAgICAgICBsZXQgb3duUGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgbGV0IG1pblBhdGhMZW5ndGggPSBNYXRoLm1pbihnbG9iYWxQYXRoLmxlbmd0aCwgb3duUGF0aC5sZW5ndGgpO1xuICAgICAgICBsZXQgbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5QYXRoTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvd25Db21wID0gb3duUGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBsZXQgb3RoZXJDb21wID0gZ2xvYmFsUGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBpZiAob3duQ29tcC5FcXVhbHMob3RoZXJDb21wKSkge1xuICAgICAgICAgICAgICAgIGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHNoYXJlZCBwYXRoIGNvbXBvbmVudHMsIHNvIGp1c3QgdXNlIGdsb2JhbCBwYXRoXG4gICAgICAgIGlmIChsYXN0U2hhcmVkUGF0aENvbXBJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQYXRoO1xuICAgICAgICBsZXQgbnVtVXB3YXJkc01vdmVzID0gb3duUGF0aC5jb21wb25lbnRDb3VudCAtIDEgLSBsYXN0U2hhcmVkUGF0aENvbXBJbmRleDtcbiAgICAgICAgbGV0IG5ld1BhdGhDb21wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB1cCA9IDA7IHVwIDwgbnVtVXB3YXJkc01vdmVzOyArK3VwKVxuICAgICAgICAgICAgbmV3UGF0aENvbXBzLnB1c2goUGF0aF8xLlBhdGguQ29tcG9uZW50LlRvUGFyZW50KCkpO1xuICAgICAgICBmb3IgKGxldCBkb3duID0gbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggKyAxOyBkb3duIDwgZ2xvYmFsUGF0aC5jb21wb25lbnRDb3VudDsgKytkb3duKVxuICAgICAgICAgICAgbmV3UGF0aENvbXBzLnB1c2goZ2xvYmFsUGF0aC5HZXRDb21wb25lbnQoZG93bikpO1xuICAgICAgICBsZXQgcmVsYXRpdmVQYXRoID0gbmV3IFBhdGhfMS5QYXRoKG5ld1BhdGhDb21wcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGg7XG4gICAgfVxuICAgIENvbXBhY3RQYXRoU3RyaW5nKG90aGVyUGF0aCkge1xuICAgICAgICBsZXQgZ2xvYmFsUGF0aFN0ciA9IG51bGw7XG4gICAgICAgIGxldCByZWxhdGl2ZVBhdGhTdHIgPSBudWxsO1xuICAgICAgICBpZiAob3RoZXJQYXRoLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aFN0ciA9IG90aGVyUGF0aC5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICAgICAgZ2xvYmFsUGF0aFN0ciA9IHRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKG90aGVyUGF0aCkuY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZVBhdGggPSB0aGlzLkNvbnZlcnRQYXRoVG9SZWxhdGl2ZShvdGhlclBhdGgpO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoU3RyID0gcmVsYXRpdmVQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgICAgICBnbG9iYWxQYXRoU3RyID0gb3RoZXJQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aFN0ci5sZW5ndGggPCBnbG9iYWxQYXRoU3RyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGhTdHI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQYXRoU3RyO1xuICAgIH1cbiAgICBnZXQgcm9vdENvbnRlbnRDb250YWluZXIoKSB7XG4gICAgICAgIGxldCBhbmNlc3RvciA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoYW5jZXN0b3IsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTm90IEltcGxlbWVudGVkOiBEb2Vzbid0IHN1cHBvcnQgY29weWluZ1wiKTtcbiAgICB9XG4gICAgLy8gU2V0Q2hpbGQgd29ya3Mgc2xpZ2h0bHkgZGlmZXJlbnRseSBpbiB0aGUganMgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gU2luY2Ugd2UgY2FuJ3QgcGFzcyBhbiBvYmpldHMgcHJvcGVydHkgYnkgcmVmZXJlbmNlLCB3ZSBpbnN0ZWFkIHBhc3NcbiAgICAvLyB0aGUgb2JqZWN0IGFuZCB0aGUgcHJvcGVydHkgc3RyaW5nLlxuICAgIC8vIFRPRE86IFRoaXMgbWV0aG9kIGNhbiBwcm9iYWJseSBiZSByZXdyaXR0ZW4gd2l0aCB0eXBlLXNhZmV0eSBpbiBtaW5kLlxuICAgIFNldENoaWxkKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSlcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAob2JqW3Byb3BdKVxuICAgICAgICAgICAgb2JqW3Byb3BdLnBhcmVudCA9IHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5JbmtPYmplY3QgPSBJbmtPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBSTkcgPSB2b2lkIDA7XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JsaXh0L2YxN2I0N2M2MjUwOGJlNTk5ODdiXG4vLyBJbmsgdXNlcyBhIHNlZWRhYmxlIFBSTkcgb2Ygd2hpY2ggdGhlcmUgaXMgbm9uZSBpbiBuYXRpdmUgamF2YXNjcmlwdC5cbmNsYXNzIFBSTkcge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZCAlIDIxNDc0ODM2NDc7XG4gICAgICAgIGlmICh0aGlzLnNlZWQgPD0gMClcbiAgICAgICAgICAgIHRoaXMuc2VlZCArPSAyMTQ3NDgzNjQ2O1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2VlZCA9ICh0aGlzLnNlZWQgKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KTtcbiAgICB9XG4gICAgbmV4dEZsb2F0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubmV4dCgpIC0gMSkgLyAyMTQ3NDgzNjQ2O1xuICAgIH1cbn1cbmV4cG9ydHMuUFJORyA9IFBSTkc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QUk5HLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoID0gdm9pZCAwO1xuY2xhc3MgUGF0aCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudHNTdHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNTdHJpbmcgPSBjb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFBhdGguQ29tcG9uZW50ICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGhlYWQpO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuY29uY2F0KHRhaWwuX2NvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZSA9ICEhYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuY29uY2F0KGhlYWQpO1xuICAgICAgICAgICAgdGhpcy5faXNSZWxhdGl2ZSA9IHJlbGF0aXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1JlbGF0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSZWxhdGl2ZTtcbiAgICB9XG4gICAgZ2V0IGNvbXBvbmVudENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBoZWFkKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0YWlsKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgLy8gY2FyZWZ1bCwgdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBsZW5ndGgtMSBoZXJlLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBvZlxuICAgICAgICAgICAgLy8gTGlzdC5HZXRSYW5nZSBpcyBhIG51bWJlciBvZiBlbGVtZW50cyB0byBleHRyYWN0LCB3aGVyZWFzZSBBcnJheS5zbGljZSB1c2VzIGFuIGluZGV4XG4gICAgICAgICAgICBsZXQgdGFpbENvbXBzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgxLCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgodGFpbENvbXBzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLnNlbGY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGFzdENvbXBvbmVudCgpIHtcbiAgICAgICAgbGV0IGxhc3RDb21wb25lbnRJZHggPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0Q29tcG9uZW50SWR4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2xhc3RDb21wb25lbnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5zTmFtZWRDb21wb25lbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50c1tpXS5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHNlbGYoKSB7XG4gICAgICAgIGxldCBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICAgcGF0aC5faXNSZWxhdGl2ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBHZXRDb21wb25lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdO1xuICAgIH1cbiAgICBQYXRoQnlBcHBlbmRpbmdQYXRoKHBhdGhUb0FwcGVuZCkge1xuICAgICAgICBsZXQgcCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIGxldCB1cHdhcmRNb3ZlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aFRvQXBwZW5kLl9jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvQXBwZW5kLl9jb21wb25lbnRzW2ldLmlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdXB3YXJkTW92ZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29tcG9uZW50cy5sZW5ndGggLSB1cHdhcmRNb3ZlczsgKytpKSB7XG4gICAgICAgICAgICBwLl9jb21wb25lbnRzLnB1c2godGhpcy5fY29tcG9uZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHVwd2FyZE1vdmVzOyBpIDwgcGF0aFRvQXBwZW5kLl9jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwLl9jb21wb25lbnRzLnB1c2gocGF0aFRvQXBwZW5kLl9jb21wb25lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZ2V0IGNvbXBvbmVudHNTdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzU3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB0aGlzLl9jb21wb25lbnRzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWxhdGl2ZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gXCIuXCIgKyB0aGlzLl9jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzU3RyaW5nO1xuICAgIH1cbiAgICBzZXQgY29tcG9uZW50c1N0cmluZyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gbnVsbCB8fCB0aGlzLl9jb21wb25lbnRzU3RyaW5nID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzU3RyaW5nWzBdID09IFwiLlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1JlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB0aGlzLl9jb21wb25lbnRzU3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcG9uZW50U3RyaW5ncyA9IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKGxldCBzdHIgb2YgY29tcG9uZW50U3RyaW5ncykge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5hbWVkIGNvbXBvbmVudHMgdGhhdCBzdGFydCB3aXRoIGEgbnVtYmVyLCBlZyBcIjQyc29tZXdoZXJlXCIsIGFuZCBpbmRleGVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIHRoZSBub3JtYWwgcGFyc2VJbnQgd29uJ3QgZG8gZm9yIHRoZSBkZXRlY3Rpb24gYmVjYXVzZSBpdCdzIHRvbyByZWxheGVkLlxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3BhcnNlSW50XG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/KFswLTldK3xJbmZpbml0eSkkLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLnB1c2gobmV3IFBhdGguQ29tcG9uZW50KHBhcnNlSW50KHN0cikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgUGF0aC5Db21wb25lbnQoc3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgfVxuICAgIEVxdWFscyhvdGhlclBhdGgpIHtcbiAgICAgICAgaWYgKG90aGVyUGF0aCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJQYXRoLl9jb21wb25lbnRzLmxlbmd0aCAhPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5pc1JlbGF0aXZlICE9IHRoaXMuaXNSZWxhdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBTZXF1ZW5jZUVxdWFsIGhlcmUsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBjb21wb25lbnRzIG1hbnVhbGx5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG90aGVyUGF0aC5fY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGl0J3Mgbm90IHF1aXRlIGNsZWFyIHdoZXRoZXIgdGhpcyB0ZXN0IHNob3VsZCB1c2UgRXF1YWxzIG9yIGEgc2ltcGxlID09IG9wZXJhdG9yLFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95LWxvaHNlL2lua2pzL2lzc3Vlcy8yMlxuICAgICAgICAgICAgaWYgKCFvdGhlclBhdGguX2NvbXBvbmVudHNbaV0uRXF1YWxzKHRoaXMuX2NvbXBvbmVudHNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgUGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KGMpIHtcbiAgICAgICAgbGV0IHAgPSBuZXcgUGF0aCgpO1xuICAgICAgICBwLl9jb21wb25lbnRzLnB1c2guYXBwbHkocC5fY29tcG9uZW50cywgdGhpcy5fY29tcG9uZW50cyk7XG4gICAgICAgIHAuX2NvbXBvbmVudHMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoID0gUGF0aDtcblBhdGgucGFyZW50SWQgPSBcIl5cIjtcbihmdW5jdGlvbiAoUGF0aCkge1xuICAgIGNsYXNzIENvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZGV4T3JOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yTmFtZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gaW5kZXhPck5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXhPck5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzSW5kZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc1BhcmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT0gUGF0aC5wYXJlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgVG9QYXJlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChQYXRoLnBhcmVudElkKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBFcXVhbHMob3RoZXJDb21wKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJDb21wICE9IG51bGwgJiYgb3RoZXJDb21wLmlzSW5kZXggPT0gdGhpcy5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PSBvdGhlckNvbXAuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09IG90aGVyQ29tcC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXRoLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbn0pKFBhdGggPSBleHBvcnRzLlBhdGggfHwgKGV4cG9ydHMuUGF0aCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2ludGVyID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNsYXNzIFBvaW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuY29udGVudFt0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgZ2V0IGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyID09IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5pc051bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5wYXRoLlBhdGhCeUFwcGVuZGluZ0NvbXBvbmVudChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KHRoaXMuaW5kZXgpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnBhdGg7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuIFwiSW5rIFBvaW50ZXIgKG51bGwpXCI7XG4gICAgICAgIHJldHVybiAoXCJJbmsgUG9pbnRlciAtPiBcIiArXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgXCIgLS0gaW5kZXggXCIgK1xuICAgICAgICAgICAgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLCBidXQgaXMgaGVyZSB0byBtYWludGFpbiB0aGVcbiAgICAvLyB2YWx1ZSBzZW1hbnRpY3Mgb2YgUG9pbnRlci5cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIodGhpcy5jb250YWluZXIsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU3RhcnRPZihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludGVyKGNvbnRhaW5lciwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludGVyKG51bGwsIC0xKTtcbiAgICB9XG59XG5leHBvcnRzLlBvaW50ZXIgPSBQb2ludGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVzaFBvcFR5cGUgPSB2b2lkIDA7XG52YXIgUHVzaFBvcFR5cGU7XG4oZnVuY3Rpb24gKFB1c2hQb3BUeXBlKSB7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJUdW5uZWxcIl0gPSAwXSA9IFwiVHVubmVsXCI7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIFB1c2hQb3BUeXBlW1B1c2hQb3BUeXBlW1wiRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWVcIl0gPSAyXSA9IFwiRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWVcIjtcbn0pKFB1c2hQb3BUeXBlID0gZXhwb3J0cy5QdXNoUG9wVHlwZSB8fCAoZXhwb3J0cy5QdXNoUG9wVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QdXNoUG9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWFyY2hSZXN1bHQgPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNsYXNzIFNlYXJjaFJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub2JqID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY29ycmVjdE9iaigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwcm94aW1hdGUgPyBudWxsIDogdGhpcy5vYmo7XG4gICAgfVxuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA/IHRoaXMub2JqIDogbnVsbDtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgbGV0IHNlYXJjaFJlc3VsdCA9IG5ldyBTZWFyY2hSZXN1bHQoKTtcbiAgICAgICAgc2VhcmNoUmVzdWx0Lm9iaiA9IHRoaXMub2JqO1xuICAgICAgICBzZWFyY2hSZXN1bHQuYXBwcm94aW1hdGUgPSB0aGlzLmFwcHJveGltYXRlO1xuICAgICAgICByZXR1cm4gc2VhcmNoUmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VhcmNoUmVzdWx0ID0gU2VhcmNoUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoUmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVKc29uID0gdm9pZCAwO1xuY2xhc3MgU2ltcGxlSnNvbiB7XG4gICAgc3RhdGljIFRleHRUb0RpY3Rpb25hcnkodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUpzb24uUmVhZGVyKHRleHQpLlRvRGljdGlvbmFyeSgpO1xuICAgIH1cbiAgICBzdGF0aWMgVGV4dFRvQXJyYXkodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUpzb24uUmVhZGVyKHRleHQpLlRvQXJyYXkoKTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUpzb24gPSBTaW1wbGVKc29uO1xuKGZ1bmN0aW9uIChTaW1wbGVKc29uKSB7XG4gICAgY2xhc3MgUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE9iamVjdCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgVG9EaWN0aW9uYXJ5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgVG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290T2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFNpbXBsZUpzb24uUmVhZGVyID0gUmVhZGVyO1xuICAgIC8vIEluIEMjLCB0aGlzIGNsYXNzIHdyaXRlcyBqc29uIHRva2VucyBkaXJlY3RseSB0byBhIFN0cmluZ1dyaXRlciBvclxuICAgIC8vIGFub3RoZXIgc3RyZWFtLiBIZXJlLCBhIHRlbXBvcmFyeSBoaWVyYXJjaHkgaXMgY3JlYXRlZCBpbiB0aGUgZm9ybVxuICAgIC8vIG9mIGEgamF2YXNjcmlwdCBvYmplY3QsIHdoaWNoIGlzIHNlcmlhbGlzZWQgaW4gdGhlIGB0b1N0cmluZ2AgbWV0aG9kLlxuICAgIC8vIFNlZSBpbmRpdmlkdWFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgY2xhc3MgV3JpdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBJbiBhZGRpdGlvbiB0byBgX3N0YXRlU3RhY2tgIHByZXNlbnQgaW4gdGhlIG9yaWdpbmFsIGNvZGUsXG4gICAgICAgICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIG9mIFNpbXBsZUpzb24gdXNlIHR3byBvdGhlciBzdGFja3MgYW5kIHR3b1xuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlcyBob2xkaW5nIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAgICAvLyBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkgbmFtZSBiZWluZyBidWlsdFxuICAgICAgICAgICAgLy8gd2l0aCBgV3JpdGVQcm9wZXJ0eU5hbWVTdGFydGAsIGBXcml0ZVByb3BlcnR5TmFtZUlubmVyYCBhbmRcbiAgICAgICAgICAgIC8vIGBXcml0ZVByb3BlcnR5TmFtZUVuZGAuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBzdHJpbmcgdmFsdWUgYmVpbmcgYnVpbHRcbiAgICAgICAgICAgIC8vIHdpdGggYFdyaXRlU3RyaW5nU3RhcnRgLCBgV3JpdGVTdHJpbmdJbm5lcmAgYW5kXG4gICAgICAgICAgICAvLyBgV3JpdGVTdHJpbmdFbmRgLlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrID0gW107XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gYmVpbmcgYnVpbHQgKGVpdGhlciBhbiBhcnJheVxuICAgICAgICAgICAgLy8gb3IgYW4gb2JqZWN0KS4gRm9yIGluc3RhbmNlLCBhdCB0aGUgJz8nIHN0ZXAgZHVyaW5nIHRoZSBoaWFyY2h5XG4gICAgICAgICAgICAvLyBjcmVhdGlvbiwgdGhpcyBoaWVyYXJjaHk6XG4gICAgICAgICAgICAvLyBbMywge2E6IFtiLCA/XX1dIHdpbGwgaGF2ZSB0aGlzIGNvcnJlc3BvbmRpbmcgc3RhY2s6XG4gICAgICAgICAgICAvLyAoYm90dG9tKSBbQXJyYXksIE9iamVjdCwgQXJyYXldICh0b3ApXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkgYmVpbmcgYXNzaWduZWQuIEZvciBpbnN0YW5jZSwgYXRcbiAgICAgICAgICAgIC8vIHRoZSAnPycgc3RlcCBkdXJpbmcgdGhlIGhpYXJjaHkgY3JlYXRpb24sIHRoaXMgaGllcmFyY2h5OlxuICAgICAgICAgICAgLy8gWzMsIHthOiBbYiwge2M6ID99XX1dIHdpbGwgaGF2ZSB0aGlzIGNvcnJlc3BvbmRpbmcgc3RhY2s6XG4gICAgICAgICAgICAvLyAoYm90dG9tKSBbYSwgY10gKHRvcClcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrID0gW107XG4gICAgICAgICAgICAvLyBPYmplY3QgY29udGFpbmluZyB0aGUgZW50aXJlIGhpZWFyY2h5LlxuICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVPYmplY3QoaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgaW5uZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgbmV3IG9iamVjdC5cbiAgICAgICAgV3JpdGVPYmplY3RTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QodHJ1ZSk7XG4gICAgICAgICAgICBsZXQgbmV3T2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyBjcmVhdGVkIGFzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiBvdGhlciBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlOYW1lID0gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbltwcm9wZXJ0eU5hbWVdID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgYXMgdGhlIGNoaWxkIG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB0aGUgcm9vdCBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVPYmplY3RFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBhIHByb3BlcnR5IG5hbWUgLyB2YWx1ZSBwYWlyIHRvIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eShuYW1lLCBpbm5lck9yQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaW5uZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLldyaXRlKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50IGFuZCBGbG9hdCBhcmUgc2VwYXJhdGUgY2FsbHMsIHNpbmNlIHRoZXJlIGJvdGggYXJlXG4gICAgICAgIC8vIG51bWJlcnMgaW4gSmF2YVNjcmlwdCwgYnV0IG5lZWQgdG8gYmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cbiAgICAgICAgV3JpdGVJbnRQcm9wZXJ0eShuYW1lLCBjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVJbnQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUZsb2F0UHJvcGVydHkobmFtZSwgY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICB0aGlzLldyaXRlRmxvYXQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIGEgbmV3IHByb3BlcnR5IG5hbWUsIHdoaWNoIHdpbGwgYmUgdXNlIHRvIGFkZCB0aGVcbiAgICAgICAgLy8gbmV3IG9iamVjdCB3aGVuIGNhbGxpbmcgX2FkZFRvQ3VycmVudE9iamVjdCgpIGZyb20gYSBXcml0ZVxuICAgICAgICAvLyBtZXRob2QuXG4gICAgICAgIFdyaXRlUHJvcGVydHlTdGFydChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5RW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jaGlsZENvdW50ID09PSAxKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBhIG5ldyBwcm9wZXJ0eSBuYW1lLCBleGNlcHQgdGhpcyB0aW1lLCB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAvLyB3aWxsIGJlIGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyBhbGwgdGhlIHN0cmluZ3MgcGFzc2VkIHRvXG4gICAgICAgIC8vIFdyaXRlUHJvcGVydHlOYW1lSW5uZXIuXG4gICAgICAgIFdyaXRlUHJvcGVydHlOYW1lU3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5TmFtZUVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnB1c2godGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIG5ldyBhcnJheS5cbiAgICAgICAgV3JpdGVBcnJheVN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdCh0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgY3JlYXRlZCBhcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5TmFtZSA9IHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb25bcHJvcGVydHlOYW1lXSA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFycmF5IGlzIGNyZWF0ZWQgYXMgdGhlIGNoaWxkIG9mIGFub3RoZXIgYXJyYXkuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdGhlIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzb25PYmplY3QgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVBcnJheUVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSB0byB0aGUgYXBwcm9wcmlhdGUgY29sbGVjdGlvbiAoYXJyYXkgLyBvYmplY3QpLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICAgICAvLyBjb250ZXh0LlxuICAgICAgICBXcml0ZSh2YWx1ZSwgZXNjYXBlID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUludCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIGlzIHVzZWQgYXMgYSBwcmVjYXV0aW9uOlxuICAgICAgICAgICAgLy8gICAgIDEuIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyB3cml0dGVuIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAgIC8vICAgICAgICAod2l0aG91dCBhIGZyYWN0aW9uYWwgcGFydCAtPiAxIGluc3RlYWQgb2YgMS4wKSwgZXZlblxuICAgICAgICAgICAgLy8gICAgICAgIHRob3VnaCBpdCBzaG91bGQgYmUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mXG4gICAgICAgICAgICAvLyAgICAgICAgSlNPTi5zZXJpYWxpemU7XG4gICAgICAgICAgICAvLyAgICAgMi4gdG8gZW5zdXJlIHRoYXQgaWYgYSBmbG9hdGluZyBudW1iZXIgaXMgcGFzc2VkXG4gICAgICAgICAgICAvLyAgICAgICAgYWNjaWRlbnRhbGx5LCBpdCdzIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyBzYXZlZ2FtZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoTWF0aC5mbG9vcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIEpTT04gZG9lc24ndCBzdXBwb3J0IE5hTiBhbmQgSW5maW5pdHksIHRoZXNlIHZhbHVlc1xuICAgICAgICAvLyBhcmUgY29udmVydGVkIGhlcmUuXG4gICAgICAgIFdyaXRlRmxvYXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgzLjRlMzgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KC0zLjRlMzgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDAuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFdyaXRlTnVsbCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgYSBzdHJpbmcgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGluXG4gICAgICAgIC8vIFdyaXRlU3RyaW5nRW5kKCkuIFRoZSBzdHJpbmcgd2lsbCBiZSBhIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRoZVxuICAgICAgICAvLyBzdHJpbmdzIHBhc3NlZCB0byBXcml0ZVN0cmluZ0lubmVyLlxuICAgICAgICBXcml0ZVN0cmluZ1N0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlU3RyaW5nRW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5TdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh0aGlzLl9jdXJyZW50U3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlU3RyaW5nSW5uZXIoc3RyLCBlc2NhcGUgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5TdHJpbmcpO1xuICAgICAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB0cnlpbmcgdG8gd3JpdGUgYSBudWxsIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nICs9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJpYWxpc2UgdGhlIHJvb3Qgb2JqZWN0IGludG8gYSBKU09OIHN0cmluZy5cbiAgICAgICAgVG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNvbk9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb25PYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHN0YXRlIHN0YWNrIHdoZW4gYWRkaW5nIG5ldyBvYmplY3RzIC8gdmFsdWVzLlxuICAgICAgICBTdGFydE5ld09iamVjdChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY2hpbGRDb3VudCA9PT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIGdldHRlcnMgcGVlayBhbGwgdGhlIGRpZmZlcmVudCBzdGFja3MuXG4gICAgICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgY2hpbGRDb3VudCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCAtIDFdLmNoaWxkQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgY3VycmVudENvbGxlY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvblN0YWNrW3RoaXMuX2NvbGxlY3Rpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjdXJyZW50UHJvcGVydHlOYW1lKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2tbdGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBJbmNyZW1lbnRDaGlsZENvdW50KCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGxldCBjdXJyRWwgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY3VyckVsLmNoaWxkQ291bnQrKztcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChjdXJyRWwpO1xuICAgICAgICB9XG4gICAgICAgIEFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQXNzZXJ0IGZhaWxlZCB3aGlsZSB3cml0aW5nIEpTT05cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgZGlkIG5vdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgQyMgY29kZS4gSXQgYWRkc1xuICAgICAgICAvLyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlvbiAodXNlZCBieSBXcml0ZSBtZXRob2RzKS5cbiAgICAgICAgX2FkZFRvQ3VycmVudE9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCghQXJyYXkuaXNBcnJheSh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3RoaXMuY3VycmVudFByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBTaW1wbGVKc29uLldyaXRlciA9IFdyaXRlcjtcbiAgICAoZnVuY3Rpb24gKFdyaXRlcikge1xuICAgICAgICBsZXQgU3RhdGU7XG4gICAgICAgIChmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIk9iamVjdFwiXSA9IDFdID0gXCJPYmplY3RcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiQXJyYXlcIl0gPSAyXSA9IFwiQXJyYXlcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUHJvcGVydHlcIl0gPSAzXSA9IFwiUHJvcGVydHlcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUHJvcGVydHlOYW1lXCJdID0gNF0gPSBcIlByb3BlcnR5TmFtZVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJTdHJpbmdcIl0gPSA1XSA9IFwiU3RyaW5nXCI7XG4gICAgICAgIH0pKFN0YXRlID0gV3JpdGVyLlN0YXRlIHx8IChXcml0ZXIuU3RhdGUgPSB7fSkpO1xuICAgICAgICBjbGFzcyBTdGF0ZUVsZW1lbnQge1xuICAgICAgICAgICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFdyaXRlci5TdGF0ZUVsZW1lbnQgPSBTdGF0ZUVsZW1lbnQ7XG4gICAgfSkoV3JpdGVyID0gU2ltcGxlSnNvbi5Xcml0ZXIgfHwgKFNpbXBsZUpzb24uV3JpdGVyID0ge30pKTtcbn0pKFNpbXBsZUpzb24gPSBleHBvcnRzLlNpbXBsZUpzb24gfHwgKGV4cG9ydHMuU2ltcGxlSnNvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVKc29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGF0ZVBhdGNoID0gdm9pZCAwO1xuY2xhc3MgU3RhdGVQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgdG9Db3B5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFscyA9IG5ldyBNYXAodG9Db3B5Ll9nbG9iYWxzKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMgPSBuZXcgU2V0KHRvQ29weS5fY2hhbmdlZFZhcmlhYmxlcyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IG5ldyBNYXAodG9Db3B5Ll92aXNpdENvdW50cyk7XG4gICAgICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAodG9Db3B5Ll90dXJuSW5kaWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGdsb2JhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxzO1xuICAgIH1cbiAgICBnZXQgY2hhbmdlZFZhcmlhYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXM7XG4gICAgfVxuICAgIGdldCB2aXNpdENvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgIH1cbiAgICBnZXQgdHVybkluZGljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90dXJuSW5kaWNlcztcbiAgICB9XG4gICAgVHJ5R2V0R2xvYmFsKG5hbWUsIC8qIG91dCAqLyB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiB0aGlzLl9nbG9iYWxzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl9nbG9iYWxzLmdldChuYW1lKSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBTZXRHbG9iYWwobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFscy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBBZGRDaGFuZ2VkVmFyaWFibGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlcy5hZGQobmFtZSk7XG4gICAgfVxuICAgIFRyeUdldFZpc2l0Q291bnQoY29udGFpbmVyLCAvKiBvdXQgKi8gY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2l0Q291bnRzLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX3Zpc2l0Q291bnRzLmdldChjb250YWluZXIpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGNvdW50LCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFNldFZpc2l0Q291bnQoY29udGFpbmVyLCBjb3VudCkge1xuICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyLCBjb3VudCk7XG4gICAgfVxuICAgIFNldFR1cm5JbmRleChjb250YWluZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzLnNldChjb250YWluZXIsIGluZGV4KTtcbiAgICB9XG4gICAgVHJ5R2V0VHVybkluZGV4KGNvbnRhaW5lciwgLyogb3V0ICovIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl90dXJuSW5kaWNlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl90dXJuSW5kaWNlcy5nZXQoY29udGFpbmVyKSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpbmRleCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdGVQYXRjaCA9IFN0YXRlUGF0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZVBhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9wd2F0Y2ggPSB2b2lkIDA7XG4vLyBUaGlzIGlzIHNpbXBsZSByZXBsYWNlbWVudCBvZiB0aGUgU3RvcHdhdGNoIGNsYXNzIGZyb20gdGhlIC5ORVQgRnJhbWV3b3JrLlxuLy8gVGhlIG9yaWdpbmFsIGNsYXNzIGNhbiBjb3VudCB0aW1lIHdpdGggbXVjaCBtb3JlIGFjY3VyYWN5IHRoYW4gdGhlIEphdmFzY3JpcHQgdmVyc2lvbi5cbi8vIEl0IG1pZ2h0IGJlIHdvcnRoIGNvbnNpZGVyaW5nIHVzaW5nIGB3aW5kb3cucGVyZm9ybWFuY2VgIGluIHRoZSBicm93c2VyXG4vLyBvciBgcHJvY2Vzcy5ocnRpbWUoKWAgaW4gbm9kZS5cbmNsYXNzIFN0b3B3YXRjaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgRWxhcHNlZE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXJ0VGltZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgfVxuICAgIFN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBTdG9wKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0b3B3YXRjaCA9IFN0b3B3YXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3BXYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnkgPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgU3RvcnlTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RvcnlTdGF0ZVwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBDaG9pY2VQb2ludF8xID0gcmVxdWlyZShcIi4vQ2hvaWNlUG9pbnRcIik7XG5jb25zdCBDaG9pY2VfMSA9IHJlcXVpcmUoXCIuL0Nob2ljZVwiKTtcbmNvbnN0IERpdmVydF8xID0gcmVxdWlyZShcIi4vRGl2ZXJ0XCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBUYWdfMSA9IHJlcXVpcmUoXCIuL1RhZ1wiKTtcbmNvbnN0IFZhcmlhYmxlQXNzaWdubWVudF8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVBc3NpZ25tZW50XCIpO1xuY29uc3QgVmFyaWFibGVSZWZlcmVuY2VfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlUmVmZXJlbmNlXCIpO1xuY29uc3QgTmF0aXZlRnVuY3Rpb25DYWxsXzEgPSByZXF1aXJlKFwiLi9OYXRpdmVGdW5jdGlvbkNhbGxcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBQUk5HXzEgPSByZXF1aXJlKFwiLi9QUk5HXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IExpc3REZWZpbml0aW9uc09yaWdpbl8xID0gcmVxdWlyZShcIi4vTGlzdERlZmluaXRpb25zT3JpZ2luXCIpO1xuY29uc3QgU3RvcFdhdGNoXzEgPSByZXF1aXJlKFwiLi9TdG9wV2F0Y2hcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU2ltcGxlSnNvbl8xID0gcmVxdWlyZShcIi4vU2ltcGxlSnNvblwiKTtcbnZhciBJbmtMaXN0XzIgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5rTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5rTGlzdF8yLklua0xpc3Q7IH0gfSk7XG5pZiAoIU51bWJlci5pc0ludGVnZXIpIHtcbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gaXNJbnRlZ2VyKG5WYWwpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgblZhbCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgaXNGaW5pdGUoblZhbCkgJiZcbiAgICAgICAgICAgIG5WYWwgPiAtOTAwNzE5OTI1NDc0MDk5MiAmJlxuICAgICAgICAgICAgblZhbCA8IDkwMDcxOTkyNTQ3NDA5OTIgJiZcbiAgICAgICAgICAgIE1hdGguZmxvb3IoblZhbCkgPT09IG5WYWwpO1xuICAgIH07XG59XG5jbGFzcyBTdG9yeSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlID0gMTg7XG4gICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzID0gW107XG4gICAgICAgIHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3REZWZpbml0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb2ZpbGVyID0gbnVsbDsgLy8gVE9ETzogUHJvZmlsZXJcbiAgICAgICAgLy8gRGlzY3JpbWluYXRpb24gYmV0d2VlbiBjb25zdHJ1Y3RvcnNcbiAgICAgICAgbGV0IGNvbnRlbnRDb250YWluZXI7XG4gICAgICAgIGxldCBsaXN0cyA9IG51bGw7XG4gICAgICAgIGxldCBqc29uID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGVudENvbnRhaW5lciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbGlzdHMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0gU3RvcnkgKENvbnRhaW5lciBjb250ZW50Q29udGFpbmVyLCBMaXN0PFJ1bnRpbWUuTGlzdERlZmluaXRpb24+IGxpc3RzID0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyID0gY29udGVudENvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIC0tLS0tLVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQganNvblN0cmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBqc29uID0gU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uVGV4dFRvRGljdGlvbmFyeShqc29uU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpzb24gPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tIFN0b3J5IChDb250YWluZXIgY29udGVudENvbnRhaW5lciwgTGlzdDxSdW50aW1lLkxpc3REZWZpbml0aW9uPiBsaXN0cyA9IG51bGwpXG4gICAgICAgIGlmIChsaXN0cyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gbmV3IExpc3REZWZpbml0aW9uc09yaWdpbl8xLkxpc3REZWZpbml0aW9uc09yaWdpbihsaXN0cyk7XG4gICAgICAgIHRoaXMuX2V4dGVybmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gLS0tLS0tXG4gICAgICAgIC8vIC0tLS0tLSBTdG9yeShzdHJpbmcganNvblN0cmluZykgOiB0aGlzKChDb250YWluZXIpbnVsbClcbiAgICAgICAgaWYgKGpzb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByb290T2JqZWN0ID0ganNvbjtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uT2JqID0gcm9vdE9iamVjdFtcImlua1ZlcnNpb25cIl07XG4gICAgICAgICAgICBpZiAodmVyc2lvbk9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluayB2ZXJzaW9uIG51bWJlciBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpO1xuICAgICAgICAgICAgbGV0IGZvcm1hdEZyb21GaWxlID0gcGFyc2VJbnQodmVyc2lvbk9iaik7XG4gICAgICAgICAgICBpZiAoZm9ybWF0RnJvbUZpbGUgPiBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3Rvcnkgd2FzIG5ld2VyIHRoYW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgZW5naW5lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0RnJvbUZpbGUgPCB0aGlzLmlua1ZlcnNpb25NaW5pbXVtQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgaXMgdG9vIG9sZCB0byBiZSBsb2FkZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXRGcm9tRmlsZSAhPSBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IFZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgZG9lc24ndCBtYXRjaCBjdXJyZW50IHZlcnNpb24gb2YgZW5naW5lLiBOb24tY3JpdGljYWwsIGJ1dCByZWNvbW1lbmQgc3luY2hyb25pc2luZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcm9vdFRva2VuID0gcm9vdE9iamVjdFtcInJvb3RcIl07XG4gICAgICAgICAgICBpZiAocm9vdFRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBub2RlIGZvciBpbmsgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgaXQncyBhIHZhbGlkIC5pbmsuanNvbiBmaWxlP1wiKTtcbiAgICAgICAgICAgIGxldCBsaXN0RGVmc09iajtcbiAgICAgICAgICAgIGlmICgobGlzdERlZnNPYmogPSByb290T2JqZWN0W1wibGlzdERlZnNcIl0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub0xpc3REZWZpbml0aW9ucyhsaXN0RGVmc09iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSlRva2VuVG9SdW50aW1lT2JqZWN0KHJvb3RUb2tlbiksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLlJlc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDaG9pY2VzKCkge1xuICAgICAgICBsZXQgY2hvaWNlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcykge1xuICAgICAgICAgICAgaWYgKCFjLmlzSW52aXNpYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGMuaW5kZXggPSBjaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaG9pY2VzLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob2ljZXM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGV4dCgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGV4dCBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFRleHQ7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFncygpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGFncyBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFRhZ3M7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50RXJyb3JzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50V2FybmluZ3M7XG4gICAgfVxuICAgIGdldCBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaGFzRXJyb3I7XG4gICAgfVxuICAgIGdldCBoYXNXYXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXNXYXJuaW5nO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVzU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlO1xuICAgIH1cbiAgICBnZXQgbGlzdERlZmluaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdERlZmluaXRpb25zO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IFByb2ZpbGVyXG4gICAgU3RhcnRQcm9maWxpbmcoKSB7XG4gICAgICAgIC8qICovXG4gICAgfVxuICAgIEVuZFByb2ZpbGluZygpIHtcbiAgICAgICAgLyogKi9cbiAgICB9XG4gICAgLy8gTWVyZ2UgdG9nZXRoZXIgYHB1YmxpYyBzdHJpbmcgVG9Kc29uKClgIGFuZCBgdm9pZCBUb0pzb24oU2ltcGxlSnNvbi5Xcml0ZXIgd3JpdGVyKWAuXG4gICAgLy8gV2lsbCBvbmx5IHJldHVybiBhIHZhbHVlIGlmIHdyaXRlciB3YXMgbm90IHByb3ZpZGVkLlxuICAgIFRvSnNvbih3cml0ZXIpIHtcbiAgICAgICAgbGV0IHNob3VsZFJldHVybiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXdyaXRlcikge1xuICAgICAgICAgICAgc2hvdWxkUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdyaXRlciA9IG5ldyBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5Xcml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua1ZlcnNpb25cIiwgU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInJvb3RcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVSdW50aW1lQ29udGFpbmVyKHcsIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyKSk7XG4gICAgICAgIGlmICh0aGlzLl9saXN0RGVmaW5pdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImxpc3REZWZzXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRlZiBvZiB0aGlzLl9saXN0RGVmaW5pdGlvbnMubGlzdHMpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KGRlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkZWYuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShpdGVtLml0ZW1OYW1lLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoc2hvdWxkUmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5Ub1N0cmluZygpO1xuICAgIH1cbiAgICBSZXNldFN0YXRlKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldFN0YXRlXCIpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTdG9yeVN0YXRlXzEuU3RvcnlTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuT2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlKHRoaXMuVmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLlJlc2V0R2xvYmFscygpO1xuICAgIH1cbiAgICBSZXNldEVycm9ycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0RXJyb3JzKCk7XG4gICAgfVxuICAgIFJlc2V0Q2FsbHN0YWNrKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldENhbGxzdGFja1wiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLkZvcmNlRW5kKCk7XG4gICAgfVxuICAgIFJlc2V0R2xvYmFscygpIHtcbiAgICAgICAgaWYgKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5nZXQoXCJnbG9iYWwgZGVjbFwiKSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsUG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5DaG9vc2VQYXRoKG5ldyBQYXRoXzEuUGF0aChcImdsb2JhbCBkZWNsXCIpLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLkNvbnRpbnVlSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSBvcmlnaW5hbFBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5TbmFwc2hvdERlZmF1bHRHbG9iYWxzKCk7XG4gICAgfVxuICAgIENvbnRpbnVlKCkge1xuICAgICAgICB0aGlzLkNvbnRpbnVlQXN5bmMoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUZXh0O1xuICAgIH1cbiAgICBnZXQgY2FuQ29udGludWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNhbkNvbnRpbnVlO1xuICAgIH1cbiAgICBnZXQgYXN5bmNDb250aW51ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmU7XG4gICAgfVxuICAgIENvbnRpbnVlQXN5bmMobWlsbGlzZWNzTGltaXRBc3luYykge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscylcbiAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuQ29udGludWVJbnRlcm5hbChtaWxsaXNlY3NMaW1pdEFzeW5jKTtcbiAgICB9XG4gICAgQ29udGludWVJbnRlcm5hbChtaWxsaXNlY3NMaW1pdEFzeW5jID0gMCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlByZUNvbnRpbnVlKCk7XG4gICAgICAgIGxldCBpc0FzeW5jVGltZUxpbWl0ZWQgPSBtaWxsaXNlY3NMaW1pdEFzeW5jID4gMDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBpc0FzeW5jVGltZUxpbWl0ZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbid0IGNvbnRpbnVlIC0gc2hvdWxkIGNoZWNrIGNhbkNvbnRpbnVlIGJlZm9yZSBjYWxsaW5nIENvbnRpbnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHVyYXRpb25TdG9wd2F0Y2ggPSBuZXcgU3RvcFdhdGNoXzEuU3RvcHdhdGNoKCk7XG4gICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLlN0YXJ0KCk7XG4gICAgICAgIGxldCBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSA9IHRoaXMuQ29udGludWVTaW5nbGVTdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKGUubWVzc2FnZSwgdW5kZWZpbmVkLCBlLnVzZUVuZExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSAmJlxuICAgICAgICAgICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLkVsYXBzZWRNaWxsaXNlY29uZHMgPiBtaWxsaXNlY3NMaW1pdEFzeW5jKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuY2FuQ29udGludWUpO1xuICAgICAgICBkdXJhdGlvblN0b3B3YXRjaC5TdG9wKCk7XG4gICAgICAgIGlmIChvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lIHx8ICF0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwiVGhyZWFkIGF2YWlsYWJsZSB0byBwb3AsIHRocmVhZHMgc2hvdWxkIGFsd2F5cyBiZSBmbGF0IGJ5IHRoZSBlbmQgb2YgZXZhbHVhdGlvbj9cIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4tPicgdG8gcmV0dXJuIGZyb20gYSB0dW5uZWw/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3AoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnfiByZXR1cm4nP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJyYW4gb3V0IG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJy0+IERPTkUnIG9yICctPiBFTkQnP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50IGZvciB1bmtub3duIHJlYXNvbi4gUGxlYXNlIGRlYnVnIGNvbXBpbGVyIVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpZFNhZmVFeGl0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RDb250aW51ZSgpO1xuICAgIH1cbiAgICBDb250aW51ZVNpbmdsZVN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlU3RlcCgpO1xuICAgICAgICB0aGlzLlN0ZXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5Qb3N0U3RlcCgpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUgJiYgIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuVHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlU25hcHNob3QoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluU3RyaW5nRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50VGFncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuc3RhdGUuY3VycmVudFRhZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2UgPSB0aGlzLkNhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGV4dCwgdGhpcy5zdGF0ZS5jdXJyZW50VGV4dCwgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MubGVuZ3RoLCB0aGlzLnN0YXRlLmN1cnJlbnRUYWdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZSA9PSBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5SZXN0b3JlU3RhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlID09IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRGlzY2FyZFNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5TdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkRpc2NhcmRTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZShwcmV2VGV4dCwgY3VyclRleHQsIHByZXZUYWdDb3VudCwgY3VyclRhZ0NvdW50KSB7XG4gICAgICAgIGlmIChwcmV2VGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwcmV2VGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyclRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY3VyclRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld2xpbmVTdGlsbEV4aXN0cyA9IGN1cnJUZXh0Lmxlbmd0aCA+PSBwcmV2VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICAgIGN1cnJUZXh0LmNoYXJBdChwcmV2VGV4dC5sZW5ndGggLSAxKSA9PSBcIlxcblwiO1xuICAgICAgICBpZiAocHJldlRhZ0NvdW50ID09IGN1cnJUYWdDb3VudCAmJlxuICAgICAgICAgICAgcHJldlRleHQubGVuZ3RoID09IGN1cnJUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgbmV3bGluZVN0aWxsRXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5vQ2hhbmdlO1xuICAgICAgICBpZiAoIW5ld2xpbmVTdGlsbEV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyVGFnQ291bnQgPiBwcmV2VGFnQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lO1xuICAgICAgICBmb3IgKGxldCBpID0gcHJldlRleHQubGVuZ3RoOyBpIDwgY3VyclRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gY3VyclRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgIT0gXCIgXCIgJiYgYyAhPSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2U7XG4gICAgfVxuICAgIENvbnRpbnVlTWF4aW1hbGx5KCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJDb250aW51ZU1heGltYWxseVwiKTtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgQ29udGVudEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgfVxuICAgIEtub3RDb250YWluZXJXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIGxldCBuYW1lZENvbnRhaW5lciA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldChuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVkQ29udGFpbmVyIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVkQ29udGFpbmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgUG9pbnRlckF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIGxldCBwID0gbmV3IFBvaW50ZXJfMS5Qb2ludGVyKCk7XG4gICAgICAgIGxldCBwYXRoTGVuZ3RoVG9Vc2UgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChwYXRoLmxhc3RDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicGF0aC5sYXN0Q29tcG9uZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxhc3RDb21wb25lbnQuaXNJbmRleCkge1xuICAgICAgICAgICAgcGF0aExlbmd0aFRvVXNlID0gcGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgsIHVuZGVmaW5lZCwgcGF0aExlbmd0aFRvVXNlKTtcbiAgICAgICAgICAgIHAuY29udGFpbmVyID0gcmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHAuaW5kZXggPSBwYXRoLmxhc3RDb21wb25lbnQuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgICAgICAgICBwLmNvbnRhaW5lciA9IHJlc3VsdC5jb250YWluZXI7XG4gICAgICAgICAgICBwLmluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5vYmogPT0gbnVsbCB8fFxuICAgICAgICAgICAgKHJlc3VsdC5vYmogPT0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lciAmJiBwYXRoTGVuZ3RoVG9Vc2UgPiAwKSkge1xuICAgICAgICAgICAgdGhpcy5FcnJvcihcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIgK1xuICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgIFwiJywgYW5kIG5vIGFwcHJveGltYXRpb24gb2YgaXQgd2FzIHBvc3NpYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuYXBwcm94aW1hdGUpXG4gICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250ZW50IGF0IHBhdGggJ1wiICtcbiAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICBcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG86ICdcIiArXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9iai5wYXRoICtcbiAgICAgICAgICAgICAgICBcIicuXCIpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgU3RhdGVTbmFwc2hvdCgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5Db3B5QW5kU3RhcnRQYXRjaGluZygpO1xuICAgIH1cbiAgICBSZXN0b3JlU3RhdGVTbmFwc2hvdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLlJlc3RvcmVBZnRlclBhdGNoKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY1NhdmluZykge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERpc2NhcmRTbmFwc2hvdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY1NhdmluZylcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgIH1cbiAgICBDb3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwic3RhcnQgc2F2aW5nIG9uIGEgYmFja2dyb3VuZCB0aHJlYWRcIik7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY1NhdmluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0b3J5IGlzIGFscmVhZHkgaW4gYmFja2dyb3VuZCBzYXZpbmcgbW9kZSwgY2FuJ3QgY2FsbCBDb3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSBhZ2FpbiFcIik7XG4gICAgICAgIGxldCBzdGF0ZVRvU2F2ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCk7XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN0YXRlVG9TYXZlO1xuICAgIH1cbiAgICBCYWNrZ3JvdW5kU2F2ZUNvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hc3luY1NhdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBTdGVwKCkge1xuICAgICAgICBsZXQgc2hvdWxkQWRkVG9TdHJlYW0gPSB0cnVlO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAocG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb250YWluZXIgY29udGFpbmVyVG9FbnRlciA9IHBvaW50ZXIuUmVzb2x2ZSAoKSBhcyBDb250YWluZXI7XG4gICAgICAgIGxldCBjb250YWluZXJUb0VudGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvaW50ZXIuUmVzb2x2ZSgpLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB3aGlsZSAoY29udGFpbmVyVG9FbnRlcikge1xuICAgICAgICAgICAgdGhpcy5WaXNpdENvbnRhaW5lcihjb250YWluZXJUb0VudGVyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIE5vIGNvbnRlbnQ/IHRoZSBtb3N0IHdlIGNhbiBkbyBpcyBzdGVwIHBhc3QgaXRcbiAgICAgICAgICAgIGlmIChjb250YWluZXJUb0VudGVyLmNvbnRlbnQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKGNvbnRhaW5lclRvRW50ZXIpO1xuICAgICAgICAgICAgLy8gY29udGFpbmVyVG9FbnRlciA9IHBvaW50ZXIuUmVzb2x2ZSgpIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lclRvRW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5SZXNvbHZlKCksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IHBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlN0ZXAodGhpcy5zdGF0ZS5jYWxsU3RhY2spO1xuICAgICAgICAvLyBJcyB0aGUgY3VycmVudCBjb250ZW50IG9iamVjdDpcbiAgICAgICAgLy8gIC0gTm9ybWFsIGNvbnRlbnRcbiAgICAgICAgLy8gIC0gT3IgYSBsb2dpYy9mbG93IHN0YXRlbWVudCAtIGlmIHNvLCBkbyBpdFxuICAgICAgICAvLyBTdG9wIGZsb3cgaWYgd2UgaGl0IGEgc3RhY2sgcG9wIHdoZW4gd2UncmUgdW5hYmxlIHRvIHBvcCAoZS5nLiByZXR1cm4vZG9uZSBzdGF0ZW1lbnQgaW4ga25vdFxuICAgICAgICAvLyB0aGF0IHdhcyBkaXZlcnRlZCB0byByYXRoZXIgdGhhbiBjYWxsZWQgYXMgYSBmdW5jdGlvbilcbiAgICAgICAgbGV0IGN1cnJlbnRDb250ZW50T2JqID0gcG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgIGxldCBpc0xvZ2ljT3JGbG93Q29udHJvbCA9IHRoaXMuUGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2woY3VycmVudENvbnRlbnRPYmopO1xuICAgICAgICAvLyBIYXMgZmxvdyBiZWVuIGZvcmNlZCB0byBlbmQgYnkgZmxvdyBjb250cm9sIGFib3ZlP1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2dpY09yRmxvd0NvbnRyb2wpIHtcbiAgICAgICAgICAgIHNob3VsZEFkZFRvU3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hvaWNlIHdpdGggY29uZGl0aW9uP1xuICAgICAgICAvLyB2YXIgY2hvaWNlUG9pbnQgPSBjdXJyZW50Q29udGVudE9iaiBhcyBDaG9pY2VQb2ludDtcbiAgICAgICAgbGV0IGNob2ljZVBvaW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250ZW50T2JqLCBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KTtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgY2hvaWNlID0gdGhpcy5Qcm9jZXNzQ2hvaWNlKGNob2ljZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChjaG9pY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMucHVzaChjaG9pY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRlbnRPYmogPSBudWxsO1xuICAgICAgICAgICAgc2hvdWxkQWRkVG9TdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBubyBjb250ZW50LCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdGhlIFwiY29udGVudFwiIGl0c2VsZiwgYnV0IHdlIHNraXAgb3ZlciBpdC5cbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZW50T2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzaG91bGRBZGRUb1N0cmVhbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRlbnQgdG8gYWRkIHRvIGV2YWx1YXRpb24gc3RhY2sgb3IgdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgaWYgKHNob3VsZEFkZFRvU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBwdXNoaW5nIGEgdmFyaWFibGUgcG9pbnRlciBvbnRvIHRoZSBldmFsdWF0aW9uIHN0YWNrLCBlbnN1cmUgdGhhdCBpdCdzIHNwZWNpZmljXG4gICAgICAgICAgICAvLyB0byBvdXIgY3VycmVudCAocG9zc2libHkgdGVtcG9yYXJ5KSBjb250ZXh0IGluZGV4LiBBbmQgbWFrZSBhIGNvcHkgb2YgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UncmUgbm90IGVkaXRpbmcgdGhlIG9yaWdpbmFsIHJ1bnRpbWUgb2JqZWN0LlxuICAgICAgICAgICAgLy8gdmFyIHZhclBvaW50ZXIgPSBjdXJyZW50Q29udGVudE9iaiBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250ZW50T2JqLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YXJQb2ludGVyICYmIHZhclBvaW50ZXIuY29udGV4dEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBvYmplY3Qgc28gd2UncmUgbm90IG92ZXJ3cml0aW5nIHRoZSBzdG9yeSdzIG93biBkYXRhXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleHRJZHggPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5Db250ZXh0Rm9yVmFyaWFibGVOYW1lZCh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRlbnRPYmogPSBuZXcgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSwgY29udGV4dElkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHByZXNzaW9uIGV2YWx1YXRpb24gY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhjdXJyZW50Q29udGVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdXRwdXQgc3RyZWFtIGNvbnRlbnQgKGkuZS4gbm90IGV4cHJlc3Npb24gZXZhbHVhdGlvbilcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGN1cnJlbnRDb250ZW50T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGNvbnRlbnQgcG9pbnRlciwgZm9sbG93aW5nIGRpdmVydHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuTmV4dENvbnRlbnQoKTtcbiAgICAgICAgLy8gU3RhcnRpbmcgYSB0aHJlYWQgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgdGhlIGluY3JlbWVudCB0byB0aGUgY29udGVudCBwb2ludGVyLFxuICAgICAgICAvLyBzbyB0aGF0IHdoZW4gcmV0dXJuaW5nIGZyb20gdGhlIHRocmVhZCwgaXQgcmV0dXJucyB0byB0aGUgY29udGVudCBhZnRlciB0aGlzIGluc3RydWN0aW9uLlxuICAgICAgICAvLyB2YXIgY29udHJvbENtZCA9IGN1cnJlbnRDb250ZW50T2JqIGFzIDtcbiAgICAgICAgbGV0IGNvbnRyb2xDbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICBpZiAoY29udHJvbENtZCAmJlxuICAgICAgICAgICAgY29udHJvbENtZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoVGhyZWFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmlzaXRDb250YWluZXIoY29udGFpbmVyLCBhdFN0YXJ0KSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmNvdW50aW5nQXRTdGFydE9ubHkgfHwgYXRTdGFydCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci52aXNpdHNTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5JbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlJlY29yZFR1cm5JbmRleFZpc2l0VG9Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKSB7XG4gICAgICAgIGxldCBwcmV2aW91c1BvaW50ZXIgPSB0aGlzLnN0YXRlLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCB8fCBwb2ludGVyLmluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wcmV2Q29udGFpbmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoIXByZXZpb3VzUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIC8vIENvbnRhaW5lciBwcmV2QW5jZXN0b3IgPSBwcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpIGFzIENvbnRhaW5lciA/PyBwcmV2aW91c1BvaW50ZXIuY29udGFpbmVyIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFByZXZpb3VzQW5jZXN0b3IgPSBwcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgbGV0IHByZXZBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChyZXNvbHZlZFByZXZpb3VzQW5jZXN0b3IsIENvbnRhaW5lcl8xLkNvbnRhaW5lcikgfHxcbiAgICAgICAgICAgICAgICBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocHJldmlvdXNQb2ludGVyLmNvbnRhaW5lciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2QW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2Q29udGFpbmVycy5wdXNoKHByZXZBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgLy8gcHJldkFuY2VzdG9yID0gcHJldkFuY2VzdG9yLnBhcmVudCBhcyBDb250YWluZXI7XG4gICAgICAgICAgICAgICAgcHJldkFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHByZXZBbmNlc3Rvci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID0gcG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDb250YWluZXIgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gY3VycmVudENoaWxkT2ZDb250YWluZXIucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q2hpbGRPZkNvbnRhaW5lci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgJiZcbiAgICAgICAgICAgICh0aGlzLl9wcmV2Q29udGFpbmVycy5pbmRleE9mKGN1cnJlbnRDb250YWluZXJBbmNlc3RvcikgPCAwIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lckFuY2VzdG9yLmNvdW50aW5nQXRTdGFydE9ubHkpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgYW5jZXN0b3IgY29udGFpbmVyIGlzIGJlaW5nIGVudGVyZWQgYXQgdGhlIHN0YXJ0LFxuICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgd2hldGhlciB0aGUgY2hpbGQgb2JqZWN0IGlzIHRoZSBmaXJzdC5cbiAgICAgICAgICAgIGxldCBlbnRlcmluZ0F0U3RhcnQgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY29udGVudC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY3VycmVudENoaWxkT2ZDb250YWluZXIgPT0gY3VycmVudENvbnRhaW5lckFuY2VzdG9yLmNvbnRlbnRbMF07XG4gICAgICAgICAgICAvLyBNYXJrIGEgdmlzaXQgdG8gdGhpcyBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuVmlzaXRDb250YWluZXIoY3VycmVudENvbnRhaW5lckFuY2VzdG9yLCBlbnRlcmluZ0F0U3RhcnQpO1xuICAgICAgICAgICAgY3VycmVudENoaWxkT2ZDb250YWluZXIgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3I7XG4gICAgICAgICAgICAvLyBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByb2Nlc3NDaG9pY2UoY2hvaWNlUG9pbnQpIHtcbiAgICAgICAgbGV0IHNob3dDaG9pY2UgPSB0cnVlO1xuICAgICAgICAvLyBEb24ndCBjcmVhdGUgY2hvaWNlIGlmIGNob2ljZSBwb2ludCBkb2Vzbid0IHBhc3MgY29uZGl0aW9uYWxcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc0NvbmRpdGlvbikge1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvblZhbHVlID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5Jc1RydXRoeShjb25kaXRpb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzaG93Q2hvaWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCBjaG9pY2VPbmx5VGV4dCA9IFwiXCI7XG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5oYXNDaG9pY2VPbmx5Q29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIGNob2ljZU9ubHlTdHJWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBsZXQgY2hvaWNlT25seVN0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgY2hvaWNlT25seVRleHQgPSBjaG9pY2VPbmx5U3RyVmFsLnZhbHVlIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc1N0YXJ0Q29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIHN0YXJ0U3RyVmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0U3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBzdGFydFRleHQgPSBzdGFydFN0clZhbC52YWx1ZSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBjaG9pY2UgaWYgcGxheWVyIGhhcyBhbHJlYWR5IHJlYWQgdGhpcyBjb250ZW50XG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5vbmNlT25seSkge1xuICAgICAgICAgICAgbGV0IHZpc2l0Q291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY2hvaWNlUG9pbnQuY2hvaWNlVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh2aXNpdENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHNob3dDaG9pY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBnbyB0aHJvdWdoIHRoZSBmdWxsIHByb2Nlc3Mgb2YgY3JlYXRpbmcgdGhlIGNob2ljZSBhYm92ZSBzb1xuICAgICAgICAvLyB0aGF0IHdlIGNvbnN1bWUgdGhlIGNvbnRlbnQgZm9yIGl0LCBzaW5jZSBvdGhlcndpc2UgaXQnbGxcbiAgICAgICAgLy8gYmUgc2hvd24gb24gdGhlIG91dHB1dCBzdHJlYW0uXG4gICAgICAgIGlmICghc2hvd0Nob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VfMS5DaG9pY2UoKTtcbiAgICAgICAgY2hvaWNlLnRhcmdldFBhdGggPSBjaG9pY2VQb2ludC5wYXRoT25DaG9pY2U7XG4gICAgICAgIGNob2ljZS5zb3VyY2VQYXRoID0gY2hvaWNlUG9pbnQucGF0aC50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2UuaXNJbnZpc2libGVEZWZhdWx0ID0gY2hvaWNlUG9pbnQuaXNJbnZpc2libGVEZWZhdWx0O1xuICAgICAgICBjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suRm9ya1RocmVhZCgpO1xuICAgICAgICBjaG9pY2UudGV4dCA9IChzdGFydFRleHQgKyBjaG9pY2VPbmx5VGV4dCkucmVwbGFjZSgvXlsgXFx0XSt8WyBcXHRdKyQvZywgXCJcIik7XG4gICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgfVxuICAgIElzVHJ1dGh5KG9iaikge1xuICAgICAgICBsZXQgdHJ1dGh5ID0gZmFsc2U7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gb2JqO1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGl2VGFyZ2V0ID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJTaG91bGRuJ3QgdXNlIGEgZGl2ZXJ0IHRhcmdldCAodG8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZUYXJnZXQudGFyZ2V0UGF0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBhcyBhIGNvbmRpdGlvbmFsIHZhbHVlLiBEaWQgeW91IGludGVuZCBhIGZ1bmN0aW9uIGNhbGwgJ2xpa2VUaGlzKCknIG9yIGEgcmVhZCBjb3VudCBjaGVjayAnbGlrZVRoaXMnPyAobm8gYXJyb3dzKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsLmlzVHJ1dGh5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnV0aHk7XG4gICAgfVxuICAgIFBlcmZvcm1Mb2dpY0FuZEZsb3dDb250cm9sKGNvbnRlbnRPYmopIHtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpdmVydFxuICAgICAgICBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIERpdmVydF8xLkRpdmVydCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREaXZlcnQgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQuaXNDb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25WYWx1ZSA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgLy8gRmFsc2UgY29uZGl0aW9uYWw/IENhbmNlbCBkaXZlcnRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuSXNUcnV0aHkoY29uZGl0aW9uVmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0Lmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhck5hbWUgPSBjdXJyZW50RGl2ZXJ0LnZhcmlhYmxlRGl2ZXJ0TmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyQ29udGVudHMgPSB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodmFyTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlRyaWVkIHRvIGRpdmVydCB1c2luZyBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUgdGhhdCBjb3VsZCBub3QgYmUgZm91bmQgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhckNvbnRlbnRzIGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGludENvbnRlbnQgPSB2YXJDb250ZW50cyBhcyBJbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludENvbnRlbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFyQ29udGVudHMsIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJUcmllZCB0byBkaXZlcnQgdG8gYSB0YXJnZXQgZnJvbSBhIHZhcmlhYmxlLCBidXQgdGhlIHZhcmlhYmxlIChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKSBkaWRuJ3QgY29udGFpbiBhIGRpdmVydCB0YXJnZXQsIGl0IFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50Q29udGVudCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgJiYgaW50Q29udGVudC52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gXCJ3YXMgZW1wdHkvbnVsbCAodGhlIHZhbHVlIDApLlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiY29udGFpbmVkICdcIiArIHZhckNvbnRlbnRzICsgXCInLlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhckNvbnRlbnRzLCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IHRoaXMuUG9pbnRlckF0UGF0aCh0YXJnZXQudGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkNhbGxFeHRlcm5hbEZ1bmN0aW9uKGN1cnJlbnREaXZlcnQudGFyZ2V0UGF0aFN0cmluZywgY3VycmVudERpdmVydC5leHRlcm5hbEFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSBjdXJyZW50RGl2ZXJ0LnRhcmdldFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goY3VycmVudERpdmVydC5zdGFja1B1c2hUeXBlLCB1bmRlZmluZWQsIHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsICYmICFjdXJyZW50RGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudERpdmVydCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpdmVydC5kZWJ1Z01ldGFkYXRhLnNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiRGl2ZXJ0IHRhcmdldCBkb2Vzbid0IGV4aXN0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiRGl2ZXJ0IHJlc29sdXRpb24gZmFpbGVkOiBcIiArIGN1cnJlbnREaXZlcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0L2VuZCBhbiBleHByZXNzaW9uIGV2YWx1YXRpb24/IE9yIHByaW50IG91dCB0aGUgcmVzdWx0P1xuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCkge1xuICAgICAgICAgICAgbGV0IGV2YWxDb21tYW5kID0gY29udGVudE9iajtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZhbENvbW1hbmQuY29tbWFuZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPT09IGZhbHNlLCBcIkFscmVhZHkgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gdHJ1ZSwgXCJOb3QgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uIG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbE91dHB1dDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gdHVybmVkIG91dCB0byBiZSBlbXB0eSwgdGhlcmUgbWF5IG5vdCBiZSBhbnl0aGluZyBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb25zIG1heSBldmFsdWF0ZSB0byBWb2lkLCBpbiB3aGljaCBjYXNlIHdlIHNraXAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvdXRwdXQgaW5zdGFuY2VvZiBWb2lkXzEuVm9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgd2UgcmVhbGx5IGFsd2F5cyBibGFua2V0IGNvbnZlcnQgdG8gc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHdvdWxkIGJlIG9rYXkgdG8gaGF2ZSBudW1iZXJzIGluIHRoZSBvdXRwdXQgc3RyZWFtIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvYmxlbSBpcyB3aGVuIGV4cG9ydGluZyB0ZXh0IGZvciB2aWV3aW5nLCBpdCBza2lwcyBvdmVyIG51bWJlcnMgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUob3V0cHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob09wOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRHVwbGljYXRlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sodGhpcy5zdGF0ZS5QZWVrRXZhbHVhdGlvblN0YWNrKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbjpcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsOlxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9wVHlwZSA9IGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgID8gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3BUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3BwZWQgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPSBwb3BwZWQgYXMgRGl2ZXJ0VGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb3BwZWQsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQocG9wcGVkIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQsIFwiRXhwZWN0ZWQgdm9pZCBpZiAtPi0+IGRvZXNuJ3Qgb3ZlcnJpZGUgdGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlICE9IHBvcFR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnNldChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24sIFwiZnVuY3Rpb24gcmV0dXJuIHN0YXRlbWVudCAofiByZXR1cm4pXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuc2V0KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwsIFwidHVubmVsIG9ud2FyZHMgc3RhdGVtZW50ICgtPi0+KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHBlY3RlZCA9IG5hbWVzLmdldCh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBcImVuZCBvZiBmbG93ICgtPiBFTkQgb3IgY2hvaWNlKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yTXNnID0gXCJGb3VuZCBcIiArIG5hbWVzLmdldChwb3BUeXBlKSArIFwiLCB3aGVuIGV4cGVjdGVkIFwiICsgZXhwZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLlBvaW50ZXJBdFBhdGgob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQudGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShldmFsQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gdHJ1ZSwgXCJFeHBlY3RlZCB0byBiZSBpbiBhbiBleHByZXNzaW9uIHdoZW4gZXZhbHVhdGluZyBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRTdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50U3RhY2tGb3JTdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dENvdW50Q29uc3VtZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dENvdW50Q29uc3VtZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21tYW5kID0gb2JqIGFzIENvbnRyb2xDb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdGFja0ZvclN0cmluZy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3VtZSB0aGUgY29udGVudCB0aGF0IHdhcyBwcm9kdWNlZCBmb3IgdGhpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BGcm9tT3V0cHV0U3RyZWFtKG91dHB1dENvdW50Q29uc3VtZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgQyMgdmVyc2lvbiB1c2VzIGEgU3RhY2sgZm9yIGNvbnRlbnRTdGFja0ZvclN0cmluZywgYnV0IHdlJ3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGEgc2ltcGxlIGFycmF5LCBzbyB3ZSBuZWVkIHRvIHJldmVyc2UgaXQgYmVmb3JlIHVzaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdGFja0ZvclN0cmluZyA9IGNvbnRlbnRTdGFja0ZvclN0cmluZy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHN0cmluZyBvdXQgb2YgdGhlIGNvbnRlbnQgd2UgY29sbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRlbnRTdGFja0ZvclN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKGMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRvIGV4cHJlc3Npb24gZXZhbHVhdGlvbiAoZnJvbSBjb250ZW50IG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzYi50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5DaG9pY2VDb3VudDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNob2ljZUNvdW50ID0gdGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGNob2ljZUNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuczpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKHRoaXMuc3RhdGUuY3VycmVudFR1cm5JbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2U6XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJlYWRDb3VudDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmFOb3RlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhTm90ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgcmVhZCBjb3VudCAoJ2tub3RfbmFtZScpIGluc3RlYWQgb2YgYSB0YXJnZXQgKCctPiBrbm90X25hbWUnKT9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJUVVJOU19TSU5DRSAvIFJFQURfQ09VTlQgZXhwZWN0ZWQgYSBkaXZlcnQgdGFyZ2V0IChrbm90LCBzdGl0Y2gsIGxhYmVsIG5hbWUpLCBidXQgc2F3IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhTm90ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZGl2ZXJ0VGFyZ2V0ID0gdGFyZ2V0IGFzIERpdmVydFRhcmdldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGFyZ2V0LCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGNvbnRhaW5lciA9IENvbnRlbnRBdFBhdGggKGRpdmVydFRhcmdldC50YXJnZXRQYXRoKS5jb3JyZWN0T2JqIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLkNvbnRlbnRBdFBhdGgoZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgpLmNvcnJlY3RPYmosIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlaXRoZXJDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbENvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gdGhpcy5zdGF0ZS5UdXJuc1NpbmNlRm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250YWluZXIgZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsQ29tbWFuZC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBsb29rdXAgYXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVydFRhcmdldC50YXJnZXRQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShlaXRoZXJDb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhJbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW5JbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5JbnQgPT0gbnVsbCB8fCBtaW5JbnQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgbWluaW11bSBwYXJhbWV0ZXIgb2YgUkFORE9NKG1pbiwgbWF4KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEludCA9PSBudWxsIHx8IG1pbkludCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtYXhpbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SW50LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1heEludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWluSW50LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tUmFuZ2UgPSBtYXhJbnQudmFsdWUgLSBtaW5JbnQudmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZG9tUmFuZ2UgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJSQU5ET00gd2FzIGNhbGxlZCB3aXRoIG1pbmltdW0gYXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludC52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYW5kIG1heGltdW0gYXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEludC52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIFRoZSBtYXhpbXVtIG11c3QgYmUgbGFyZ2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0U2VlZCA9IHRoaXMuc3RhdGUuc3RvcnlTZWVkICsgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhyZXN1bHRTZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRSYW5kb20gPSByYW5kb20ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hvc2VuVmFsdWUgPSAobmV4dFJhbmRvbSAlIHJhbmRvbVJhbmdlKSArIG1pbkludC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGNob3NlblZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5leHQgcmFuZG9tIG51bWJlciAocmF0aGVyIHRoYW4ga2VlcGluZyB0aGUgUmFuZG9tIG9iamVjdCBhcm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSBuZXh0UmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlZWRSYW5kb206XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWVkID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCA9PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gU0VFRF9SQU5ET01cIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVkLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0b3J5U2VlZCA9IHNlZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZvaWRfMS5Wb2lkKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyKSAtIDE7IC8vIGluZGV4IG5vdCBjb3VudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4OlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2h1ZmZsZUluZGV4ID0gdGhpcy5OZXh0U2VxdWVuY2VTaHVmZmxlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKHNodWZmbGVJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgaW4gbWFpbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgZXhpc3QgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0IG9mIGNyZWF0aW5nIHRoZSB0aHJlYWQsIG9yIGluIHRoZSBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG5vcm1hbCBmbG93IC0gYWxsb3cgc2FmZSBleGl0IHdpdGhvdXQgd2FybmluZ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBmbG93IGluIGN1cnJlbnQgdGhyZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBmbG93IHRvIGVuZCBjb21wbGV0ZWx5XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Gb3JjZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBpbnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0TmFtZVZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3ROYW1lVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiUGFzc2VkIG5vbi1pbnRlZ2VyIHdoZW4gY3JlYXRpbmcgYSBsaXN0IGVsZW1lbnQgZnJvbSBhIG51bWVyaWNhbCB2YWx1ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGdlbmVyYXRlZExpc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3REZWZpbml0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLmxpc3REZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRMaXN0RGVmID0gdGhpcy5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24obGlzdE5hbWVWYWwudmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50VmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJtaW5JbnQudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRJdGVtID0gZm91bmRMaXN0RGVmLnJlc3VsdC5UcnlHZXRJdGVtV2l0aFZhbHVlKGludFZhbC52YWx1ZSwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSXRlbS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRMaXN0VmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoZm91bmRJdGVtLnJlc3VsdCwgaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRmFpbGVkIHRvIGZpbmQgTElTVCBjYWxsZWQgXCIgKyBsaXN0TmFtZVZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZExpc3RWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkTGlzdFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhnZW5lcmF0ZWRMaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlOlxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdGFyZ2V0TGlzdCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBMaXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldExpc3QgPT09IG51bGwgfHwgbWluID09PSBudWxsIHx8IG1heCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgbGlzdCwgbWluaW11bSBhbmQgbWF4aW11bSBmb3IgTElTVF9SQU5HRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldExpc3QudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGFyZ2V0TGlzdC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGFyZ2V0TGlzdC52YWx1ZS5MaXN0V2l0aFN1YlJhbmdlKG1pbi52YWx1ZU9iamVjdCwgbWF4LnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb206IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RWYWwgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgbGlzdCBmb3IgTElTVF9SQU5ET01cIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gbGlzdFZhbC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xpc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QuQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gaW5kZXggZm9yIHRoZSBlbGVtZW50IHRvIHRha2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRTZWVkID0gdGhpcy5zdGF0ZS5zdG9yeVNlZWQgKyB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhyZXN1bHRTZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0UmFuZG9tID0gcmFuZG9tLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0SXRlbUluZGV4ID0gbmV4dFJhbmRvbSAlIGxpc3QuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJpdCBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEMjIGNvZGUsIHNpbmNlIGl0ZXJhdG9ycyBkbyBub3Qgd29yayBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgd2UgaXRlcmF0ZSBsaXN0SXRlbUluZGV4IC0gMSB0aW1lcywgY2FsbGluZyBuZXh0KCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGlzdEl0ZW1JbmRleC10aCB0aW1lIGlzIG1hZGUgb3V0c2lkZSBvZiB0aGUgbG9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0RW51bWVyYXRvciA9IGxpc3QuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGlzdEl0ZW1JbmRleCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RFbnVtZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGxpc3RFbnVtZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21JdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtleTogSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KHZhbHVlWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZTogdmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luIGxpc3QgaXMgc2ltcGx5IHRoZSBvcmlnaW4gb2YgdGhlIG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QocmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0LkFkZChyYW5kb21JdGVtLktleSwgcmFuZG9tSXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tID0gbmV4dFJhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuTGlzdFZhbHVlKG5ld0xpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJ1bmhhbmRsZWQgQ29udHJvbENvbW1hbmQ6IFwiICsgZXZhbENvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlIGFzc2lnbm1lbnRcbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIFZhcmlhYmxlQXNzaWdubWVudF8xLlZhcmlhYmxlQXNzaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHZhckFzcyA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgYXNzaWduZWRWYWwgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5Bc3NpZ24odmFyQXNzLCBhc3NpZ25lZFZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGxldCB2YXJSZWYgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgbGV0IGZvdW5kVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgcmVhZCBjb3VudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhclJlZi5wYXRoRm9yQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB2YXJSZWYuY29udGFpbmVyRm9yQ291bnQ7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkludFZhbHVlKGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kVmFsdWUgPSB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodmFyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5XYXJuaW5nKFwiVmFyaWFibGUgbm90IGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyUmVmLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInLiBVc2luZyBkZWZhdWx0IHZhbHVlIG9mIDAgKGZhbHNlKS4gVGhpcyBjYW4gaGFwcGVuIHdpdGggdGVtcG9yYXJ5IHZhcmlhYmxlcyBpZiB0aGUgZGVjbGFyYXRpb24gaGFzbid0IHlldCBiZWVuIGhpdC4gR2xvYmFscyBhcmUgYWx3YXlzIGdpdmVuIGEgZGVmYXVsdCB2YWx1ZSBvbiBsb2FkIGlmIGEgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2F2ZSBzdGF0ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVmFsdWUgPSBuZXcgVmFsdWVfMS5JbnRWYWx1ZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soZm91bmRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOYXRpdmUgZnVuY3Rpb24gY2FsbFxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgZnVuY1BhcmFtcyA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKGZ1bmMubnVtYmVyT2ZQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmdW5jLkNhbGwoZnVuY1BhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2socmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGNvbnRyb2wgY29udGVudCwgbXVzdCBiZSBvcmRpbmFyeSBjb250ZW50XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ2hvb3NlUGF0aFN0cmluZyhwYXRoLCByZXNldENhbGxzdGFjayA9IHRydWUsIGFyZ3MgPSBbXSkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIENob29zZVBhdGhTdHJpbmcgcmlnaHQgbm93XCIpO1xuICAgICAgICBpZiAocmVzZXRDYWxsc3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuUmVzZXRDYWxsc3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jRGV0YWlsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY0RldGFpbCA9IFwiKFwiICsgY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSArIFwiKSBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Rvcnkgd2FzIHJ1bm5pbmcgYSBmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNEZXRhaWwgK1xuICAgICAgICAgICAgICAgICAgICBcIndoZW4geW91IGNhbGxlZCBDaG9vc2VQYXRoU3RyaW5nKFwiICtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSAtIHRoaXMgaXMgYWxtb3N0IGNlcnRhaW5seSBub3Qgbm90IHdoYXQgeW91IHdhbnQhIEZ1bGwgc3RhY2sgdHJhY2U6IFxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FsbFN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpO1xuICAgICAgICB0aGlzLkNob29zZVBhdGgobmV3IFBhdGhfMS5QYXRoKHBhdGgpKTtcbiAgICB9XG4gICAgSWZBc3luY1dlQ2FudChhY3Rpdml0eVN0cikge1xuICAgICAgICBpZiAodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IFwiICtcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVN0ciArXG4gICAgICAgICAgICAgICAgXCIuIFN0b3J5IGlzIGluIHRoZSBtaWRkbGUgb2YgYSBDb250aW51ZUFzeW5jKCkuIE1ha2UgbW9yZSBDb250aW51ZUFzeW5jKCkgY2FsbHMgb3IgYSBzaW5nbGUgQ29udGludWUoKSBjYWxsIGJlZm9yZWhhbmQuXCIpO1xuICAgIH1cbiAgICBDaG9vc2VQYXRoKHAsIGluY3JlbWVudGluZ1R1cm5JbmRleCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5TZXRDaG9zZW5QYXRoKHAsIGluY3JlbWVudGluZ1R1cm5JbmRleCk7XG4gICAgICAgIC8vIFRha2UgYSBub3RlIG9mIG5ld2x5IHZpc2l0ZWQgY29udGFpbmVycyBmb3IgcmVhZCBjb3VudHMgZXRjXG4gICAgICAgIHRoaXMuVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCk7XG4gICAgfVxuICAgIENob29zZUNob2ljZUluZGV4KGNob2ljZUlkeCkge1xuICAgICAgICBjaG9pY2VJZHggPSBjaG9pY2VJZHg7XG4gICAgICAgIGxldCBjaG9pY2VzID0gdGhpcy5jdXJyZW50Q2hvaWNlcztcbiAgICAgICAgdGhpcy5Bc3NlcnQoY2hvaWNlSWR4ID49IDAgJiYgY2hvaWNlSWR4IDwgY2hvaWNlcy5sZW5ndGgsIFwiY2hvaWNlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IGNob2ljZVRvQ2hvb3NlID0gY2hvaWNlc1tjaG9pY2VJZHhdO1xuICAgICAgICBpZiAoY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlVG9DaG9vc2UudGFyZ2V0UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQgPSBjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb247XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoKTtcbiAgICB9XG4gICAgSGFzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSAhPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRXZhbHVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGFyZ3MgPSBbXSwgcmV0dXJuVGV4dE91dHB1dCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlRnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSB0aGFuIHRoZSBDIyB2ZXJzaW9uLlxuICAgICAgICAvLyBJbiBDIywgeW91IGNhbiBwYXNzIGEgKHNlY29uZCkgcGFyYW1ldGVyIGBvdXQgdGV4dE91dHB1dGAgdG8gZ2V0IHRoZVxuICAgICAgICAvLyB0ZXh0IG91dHB1dHRlZCBieSB0aGUgZnVuY3Rpb24uIFRoaXMgaXMgbm90IHBvc3NpYmxlIGluIGpzLiBJbnN0ZWFkLFxuICAgICAgICAvLyB3ZSBtYWludGFpbiB0aGUgcmVndWxhciBzaWduYXR1cmUgKGZ1bmN0aW9uTmFtZSwgYXJncyksIHBsdXMgYW5cbiAgICAgICAgLy8gb3B0aW9uYWwgdGhpcmQgcGFyYW1ldGVyIHJldHVyblRleHRPdXRwdXQuIElmIHNldCB0byB0cnVlLCB3ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiBib3RoIHRoZSB0ZXh0T3V0cHV0IGFuZCB0aGUgcmV0dXJuZWQgdmFsdWUsIGFzIGFuIG9iamVjdC5cbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiZXZhbHVhdGUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PSBcIlwiIHx8IGZ1bmN0aW9uTmFtZS50cmltKCkgPT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgZW1wdHkgb3Igd2hpdGUgc3BhY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdW5jQ29udGFpbmVyID0gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgaWYgKGZ1bmNDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gZG9lc24ndCBleGlzdDogJ1wiICsgZnVuY3Rpb25OYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXRTdHJlYW1CZWZvcmUgPSBbXTtcbiAgICAgICAgb3V0cHV0U3RyZWFtQmVmb3JlLnB1c2guYXBwbHkob3V0cHV0U3RyZWFtQmVmb3JlLCB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbSk7XG4gICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUuU3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZShmdW5jQ29udGFpbmVyLCBhcmdzKTtcbiAgICAgICAgLy8gRXZhbHVhdGUgdGhlIGZ1bmN0aW9uLCBhbmQgY29sbGVjdCB0aGUgc3RyaW5nIG91dHB1dFxuICAgICAgICBsZXQgc3RyaW5nT3V0cHV0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBzdHJpbmdPdXRwdXQuQXBwZW5kKHRoaXMuQ29udGludWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRPdXRwdXQgPSBzdHJpbmdPdXRwdXQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQob3V0cHV0U3RyZWFtQmVmb3JlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3RhdGUuQ29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVGV4dE91dHB1dCA/IHsgcmV0dXJuZWQ6IHJlc3VsdCwgb3V0cHV0OiB0ZXh0T3V0cHV0IH0gOiByZXN1bHQ7XG4gICAgfVxuICAgIEV2YWx1YXRlRXhwcmVzc2lvbihleHByQ29udGFpbmVyKSB7XG4gICAgICAgIGxldCBzdGFydENhbGxTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IGV4cHJDb250YWluZXI7XG4gICAgICAgIHRoaXMuc3RhdGUuR29Ub1N0YXJ0KCk7XG4gICAgICAgIGxldCBldmFsU3RhY2tIZWlnaHQgPSB0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIHRoaXMuQ29udGludWUoKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGZhbGxlbiBvZmYgdGhlIGVuZCBvZiB0aGUgQ29udGFpbmVyLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhdXRvLXBvcHBlZCwgYnV0IGp1c3QgaW4gY2FzZSB3ZSBkaWRuJ3QgZm9yIHNvbWUgcmVhc29uLFxuICAgICAgICAvLyBtYW51YWxseSBwb3AgdG8gcmVzdG9yZSB0aGUgc3RhdGUgKGluY2x1ZGluZyBjdXJyZW50UGF0aCkuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGggPiBzdGFydENhbGxTdGFja0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kU3RhY2tIZWlnaHQgPSB0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRTdGFja0hlaWdodCA+IGV2YWxTdGFja0hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgbnVtYmVyT2ZBcmd1bWVudHMpIHtcbiAgICAgICAgaWYgKGZ1bmNOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImZ1bmNOYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdW5jID0gdGhpcy5fZXh0ZXJuYWxzLmdldChmdW5jTmFtZSk7XG4gICAgICAgIGxldCBmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgbGV0IGZvdW5kRXh0ZXJuYWwgPSB0eXBlb2YgZnVuYyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgLy8gVHJ5IHRvIHVzZSBmYWxsYmFjayBmdW5jdGlvbj9cbiAgICAgICAgaWYgKCFmb3VuZEV4dGVybmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyID0gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgIT09IG51bGwsIFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kLCBhbmQgZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGNvdWxkIG5vdCBiZSBmb3VuZC5cIik7XG4gICAgICAgICAgICAgICAgLy8gRGl2ZXJ0IGRpcmVjdCBpbnRvIGZhbGxiYWNrIGZ1bmN0aW9uIGFuZCB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24sIHVuZGVmaW5lZCwgdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoZmFsc2UsIFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kIChhbmQgaW5rIGZhbGxiYWNrcyBkaXNhYmxlZCkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBvcCBhcmd1bWVudHNcbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkFyZ3VtZW50czsgKytpKSB7XG4gICAgICAgICAgICAvLyB2YXIgcG9wcGVkT2JqID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFZhbHVlO1xuICAgICAgICAgICAgbGV0IHBvcHBlZE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgbGV0IHZhbHVlT2JqID0gcG9wcGVkT2JqLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgYXJncy5wdXNoKHZhbHVlT2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXZlcnNlIGFyZ3VtZW50cyBmcm9tIHRoZSBvcmRlciB0aGV5IHdlcmUgcG9wcGVkLFxuICAgICAgICAvLyBzbyB0aGV5J3JlIHRoZSByaWdodCB3YXkgcm91bmQgYWdhaW4uXG4gICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICAvLyBSdW4gdGhlIGZ1bmN0aW9uIVxuICAgICAgICBsZXQgZnVuY1Jlc3VsdCA9IGZ1bmMoYXJncyk7XG4gICAgICAgIC8vIENvbnZlcnQgcmV0dXJuIHZhbHVlIChpZiBhbnkpIHRvIHRoZSBhIHR5cGUgdGhhdCB0aGUgaW5rIGVuZ2luZSBjYW4gdXNlXG4gICAgICAgIGxldCByZXR1cm5PYmogPSBudWxsO1xuICAgICAgICBpZiAoZnVuY1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5PYmogPSBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShmdW5jUmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHJldHVybk9iaiAhPT0gbnVsbCwgXCJDb3VsZCBub3QgY3JlYXRlIGluayB2YWx1ZSBmcm9tIHJldHVybmVkIG9iamVjdCBvZiB0eXBlIFwiICtcbiAgICAgICAgICAgICAgICB0eXBlb2YgZnVuY1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5PYmogPSBuZXcgVm9pZF8xLlZvaWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2socmV0dXJuT2JqKTtcbiAgICB9XG4gICAgQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKGZ1bmNOYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImJpbmQgYW4gZXh0ZXJuYWwgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuQXNzZXJ0KCF0aGlzLl9leHRlcm5hbHMuaGFzKGZ1bmNOYW1lKSwgXCJGdW5jdGlvbiAnXCIgKyBmdW5jTmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlwiKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzLnNldChmdW5jTmFtZSwgZnVuYyk7XG4gICAgfVxuICAgIFRyeUNvZXJjZSh2YWx1ZSkge1xuICAgICAgICAvLyBXZSdyZSBza2lwcGluZyB0eXBlIGNvZXJjaXRpb24gaW4gdGhpcyBpbXBsZW1lbnRhdGlvbi4gRmlyc3Qgb2YsIGpzXG4gICAgICAgIC8vIGlzIGxvb3NlbHkgdHlwZWQsIHNvIGl0J3Mgbm90IHRoYXQgaW1wb3J0YW50LiBTZWNvbmRseSwgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gY2xlYW4gd2F5IChBRkFJSykgZm9yIHRoZSB1c2VyIHRvIGRlc2NyaWJlIHdoYXQgdHlwZSBvZiBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIHRoZXkgZXhwZWN0LlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIEJpbmRFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuQXNzZXJ0KGZ1bmMgIT0gbnVsbCwgXCJDYW4ndCBiaW5kIGEgbnVsbCBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydChhcmdzLmxlbmd0aCA+PSBmdW5jLmxlbmd0aCwgXCJFeHRlcm5hbCBmdW5jdGlvbiBleHBlY3RlZCBcIiArIGZ1bmMubGVuZ3RoICsgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgICAgICAgbGV0IGNvZXJjZWRBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29lcmNlZEFyZ3NbaV0gPSB0aGlzLlRyeUNvZXJjZShhcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGNvZXJjZWRBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuYmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwidW5iaW5kIGFuIGV4dGVybmFsIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2V4dGVybmFscy5oYXMoZnVuY05hbWUpLCBcIkZ1bmN0aW9uICdcIiArIGZ1bmNOYW1lICsgXCInIGhhcyBub3QgYmVlbiBib3VuZC5cIik7XG4gICAgICAgIHRoaXMuX2V4dGVybmFscy5kZWxldGUoZnVuY05hbWUpO1xuICAgIH1cbiAgICBWYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKSB7XG4gICAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgICAgbGV0IG8gPSBudWxsO1xuICAgICAgICBsZXQgbWlzc2luZ0V4dGVybmFscyA9IGFyZ3VtZW50c1sxXSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdF8xLklua09iamVjdCkge1xuICAgICAgICAgICAgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gbnVsbCAmJiBvID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyh0aGlzLl9tYWluQ29udGVudENvbnRhaW5lciwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgLy8gTm8gcHJvYmxlbSEgVmFsaWRhdGlvbiBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKG1pc3NpbmdFeHRlcm5hbHMuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJFcnJvcjogTWlzc2luZyBmdW5jdGlvbiBiaW5kaW5nIGZvciBleHRlcm5hbFwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gbWlzc2luZ0V4dGVybmFscy5zaXplID4gMSA/IFwic1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiOiAnXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBBcnJheS5mcm9tKG1pc3NpbmdFeHRlcm5hbHMpLmpvaW4oXCInLCAnXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCInIFwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gdGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgPyBcIiwgYW5kIG5vIGZhbGxiYWNrIGluayBmdW5jdGlvbiBmb3VuZC5cIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIChpbmsgZmFsbGJhY2tzIGRpc2FibGVkKVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbm5lckNvbnRlbnQgb2YgYy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwgfHwgIWNvbnRhaW5lci5oYXNWYWxpZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKGlubmVyQ29udGVudCwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBbLCB2YWx1ZV0gb2YgYy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyhUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIE9iamVjdF8xLklua09iamVjdCksIG1pc3NpbmdFeHRlcm5hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRpdmVydCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvLCBEaXZlcnRfMS5EaXZlcnQpO1xuICAgICAgICAgICAgaWYgKGRpdmVydCAmJiBkaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2V4dGVybmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmFsbGJhY2tGb3VuZCA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmhhcyhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmFsbGJhY2tGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdFeHRlcm5hbHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0V4dGVybmFscy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JzZXJ2ZVZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwib2JzZXJ2ZSBhIG5ldyB2YXJpYWJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHZhcmlhYmxlTmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBvYnNlcnZlIHZhcmlhYmxlICdcIiArXG4gICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lICtcbiAgICAgICAgICAgICAgICBcIicgYmVjYXVzZSBpdCB3YXNuJ3QgZGVjbGFyZWQgaW4gdGhlIGluayBzdG9yeS5cIik7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXModmFyaWFibGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHZhcmlhYmxlTmFtZSkucHVzaChvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5zZXQodmFyaWFibGVOYW1lLCBbb2JzZXJ2ZXJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZlVmFyaWFibGVzKHZhcmlhYmxlTmFtZXMsIG9ic2VydmVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLk9ic2VydmVWYXJpYWJsZSh2YXJpYWJsZU5hbWVzW2ldLCBvYnNlcnZlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlbW92ZVZhcmlhYmxlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHNwZWNpZmljVmFyaWFibGVOYW1lKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcInJlbW92ZSBhIHZhcmlhYmxlIG9ic2VydmVyXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Ygc3BlY2lmaWNWYXJpYWJsZU5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXMoc3BlY2lmaWNWYXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldChzcGVjaWZpY1ZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uob2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmRlbGV0ZShzcGVjaWZpY1ZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmtleXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHZhck5hbWUgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodmFyTmFtZSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZhcmlhYmxlU3RhdGVEaWRDaGFuZ2VFdmVudCh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlT2JqKSB7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVycyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKCEobmV3VmFsdWVPYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGdldCB0aGUgdmFsdWUgb2YgYSB2YXJpYWJsZSB0aGF0IGlzbid0IGEgc3RhbmRhcmQgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhciB2YWwgPSBuZXdWYWx1ZU9iaiBhcyBWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuZXdWYWx1ZU9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih2YXJpYWJsZU5hbWUsIHZhbC52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGdsb2JhbFRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcoXCJcIik7XG4gICAgfVxuICAgIFRhZ3NGb3JDb250ZW50QXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhwYXRoKTtcbiAgICB9XG4gICAgVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gICAgICAgIGxldCBwYXRoID0gbmV3IFBhdGhfMS5QYXRoKHBhdGhTdHJpbmcpO1xuICAgICAgICBsZXQgZmxvd0NvbnRhaW5lciA9IHRoaXMuQ29udGVudEF0UGF0aChwYXRoKS5jb250YWluZXI7XG4gICAgICAgIGlmIChmbG93Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImZsb3dDb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdENvbnRlbnQgPSBmbG93Q29udGFpbmVyLmNvbnRlbnRbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3RDb250ZW50IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIGZsb3dDb250YWluZXIgPSBmaXJzdENvbnRlbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhZ3MgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGZsb3dDb250YWluZXIuY29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIHRhZyA9IGMgYXMgUnVudGltZS5UYWc7XG4gICAgICAgICAgICBsZXQgdGFnID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGMsIFRhZ18xLlRhZyk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh0YWcudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuICAgIEJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIDAsIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuUmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIEJ1aWxkU3RyaW5nT2ZDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBjb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgMCwgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgTmV4dENvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxQb2ludGVySW5jcmVtZW50ID0gdGhpcy5JbmNyZW1lbnRDb250ZW50UG9pbnRlcigpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWxQb2ludGVySW5jcmVtZW50KSB7XG4gICAgICAgICAgICBsZXQgZGlkUG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcENhbGxTdGFjayhQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWb2lkXzEuVm9pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlkUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpO1xuICAgICAgICAgICAgICAgIGRpZFBvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZFBvcCAmJiAhdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLk5leHRDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5jcmVtZW50Q29udGVudFBvaW50ZXIoKSB7XG4gICAgICAgIGxldCBzdWNjZXNzZnVsSW5jcmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIHBvaW50ZXIuaW5kZXgrKztcbiAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwb2ludGVyLmluZGV4ID49IHBvaW50ZXIuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWNjZXNzZnVsSW5jcmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDb250YWluZXIgbmV4dEFuY2VzdG9yID0gcG9pbnRlci5jb250YWluZXIucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGxldCBuZXh0QW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5jb250YWluZXIucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5leHRBbmNlc3RvciBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleEluQW5jZXN0b3IgPSBuZXh0QW5jZXN0b3IuY29udGVudC5pbmRleE9mKHBvaW50ZXIuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleEluQW5jZXN0b3IgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBuZXcgUG9pbnRlcl8xLlBvaW50ZXIobmV4dEFuY2VzdG9yLCBpbmRleEluQW5jZXN0b3IpO1xuICAgICAgICAgICAgcG9pbnRlci5pbmRleCsrO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bEluY3JlbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc3VjY2Vzc2Z1bEluY3JlbWVudClcbiAgICAgICAgICAgIHBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IHBvaW50ZXIuY29weSgpO1xuICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bEluY3JlbWVudDtcbiAgICB9XG4gICAgVHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpIHtcbiAgICAgICAgbGV0IGFsbENob2ljZXMgPSB0aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcztcbiAgICAgICAgbGV0IGludmlzaWJsZUNob2ljZXMgPSBhbGxDaG9pY2VzLmZpbHRlcigoYykgPT4gYy5pc0ludmlzaWJsZURlZmF1bHQpO1xuICAgICAgICBpZiAoaW52aXNpYmxlQ2hvaWNlcy5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgYWxsQ2hvaWNlcy5sZW5ndGggPiBpbnZpc2libGVDaG9pY2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNob2ljZSA9IGludmlzaWJsZUNob2ljZXNbMF07XG4gICAgICAgIGlmIChjaG9pY2UudGFyZ2V0UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2UudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQgPSBjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uO1xuICAgICAgICB0aGlzLkNob29zZVBhdGgoY2hvaWNlLnRhcmdldFBhdGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIE5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpIHtcbiAgICAgICAgLy8gdmFyIG51bUVsZW1lbnRzSW50VmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIEludFZhbHVlO1xuICAgICAgICBsZXQgbnVtRWxlbWVudHNJbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGlmICghKG51bUVsZW1lbnRzSW50VmFsIGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJleHBlY3RlZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gc2VxdWVuY2UgZm9yIHNodWZmbGUgaW5kZXhcIik7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VxQ29udGFpbmVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXI7XG4gICAgICAgIGlmIChzZXFDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwic2VxQ29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgIGlmIChudW1FbGVtZW50c0ludFZhbC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJudW1FbGVtZW50c0ludFZhbC52YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtRWxlbWVudHMgPSBudW1FbGVtZW50c0ludFZhbC52YWx1ZTtcbiAgICAgICAgLy8gdmFyIHNlcUNvdW50VmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIEludFZhbHVlO1xuICAgICAgICBsZXQgc2VxQ291bnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgbGV0IHNlcUNvdW50ID0gc2VxQ291bnRWYWwudmFsdWU7XG4gICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgIGlmIChzZXFDb3VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzZXFDb3VudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9vcEluZGV4ID0gc2VxQ291bnQgLyBudW1FbGVtZW50cztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbkluZGV4ID0gc2VxQ291bnQgJSBudW1FbGVtZW50cztcbiAgICAgICAgbGV0IHNlcVBhdGhTdHIgPSBzZXFDb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgc2VxdWVuY2VIYXNoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzZXFQYXRoU3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgc2VxdWVuY2VIYXNoICs9IHNlcVBhdGhTdHIuY2hhckNvZGVBdChpKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5kb21TZWVkID0gc2VxdWVuY2VIYXNoICsgbG9vcEluZGV4ICsgdGhpcy5zdGF0ZS5zdG9yeVNlZWQ7XG4gICAgICAgIGxldCByYW5kb20gPSBuZXcgUFJOR18xLlBSTkcoTWF0aC5mbG9vcihyYW5kb21TZWVkKSk7XG4gICAgICAgIGxldCB1bnBpY2tlZEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGVtZW50czsgKytpKSB7XG4gICAgICAgICAgICB1bnBpY2tlZEluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVyYXRpb25JbmRleDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY2hvc2VuID0gcmFuZG9tLm5leHQoKSAlIHVucGlja2VkSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hvc2VuSW5kZXggPSB1bnBpY2tlZEluZGljZXNbY2hvc2VuXTtcbiAgICAgICAgICAgIHVucGlja2VkSW5kaWNlcy5zcGxpY2UoY2hvc2VuLCAxKTtcbiAgICAgICAgICAgIGlmIChpID09IGl0ZXJhdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNob3NlbkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIpO1xuICAgIH1cbiAgICBFcnJvcihtZXNzYWdlLCB1c2VFbmRMaW5lTnVtYmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGUgPSBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihtZXNzYWdlKTtcbiAgICAgICAgZS51c2VFbmRMaW5lTnVtYmVyID0gdXNlRW5kTGluZU51bWJlcjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgV2FybmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuQWRkRXJyb3IobWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIEFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZyA9IGZhbHNlLCB1c2VFbmRMaW5lTnVtYmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGRtID0gdGhpcy5jdXJyZW50RGVidWdNZXRhZGF0YTtcbiAgICAgICAgbGV0IGVycm9yVHlwZVN0ciA9IGlzV2FybmluZyA/IFwiV0FSTklOR1wiIDogXCJFUlJPUlwiO1xuICAgICAgICBpZiAoZG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGxpbmVOdW0gPSB1c2VFbmRMaW5lTnVtYmVyID8gZG0uZW5kTGluZU51bWJlciA6IGRtLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIFwiUlVOVElNRSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZVN0ciArXG4gICAgICAgICAgICAgICAgICAgIFwiOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBkbS5maWxlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBsaW5lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bSArXG4gICAgICAgICAgICAgICAgICAgIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIlJVTlRJTUUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBlcnJvclR5cGVTdHIgK1xuICAgICAgICAgICAgICAgICAgICBcIjogKFwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciArXG4gICAgICAgICAgICAgICAgICAgIFwiKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiUlVOVElNRSBcIiArIGVycm9yVHlwZVN0ciArIFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5BZGRFcnJvcihtZXNzYWdlLCBpc1dhcm5pbmcpO1xuICAgICAgICAvLyBJbiBhIGJyb2tlbiBzdGF0ZSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgYW55IG90aGVyIGVycm9ycy5cbiAgICAgICAgaWYgKCFpc1dhcm5pbmcpXG4gICAgICAgICAgICB0aGlzLnN0YXRlLkZvcmNlRW5kKCk7XG4gICAgfVxuICAgIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTdG9yeSBhc3NlcnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgXCIgXCIgKyB0aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VycmVudERlYnVnTWV0YWRhdGEoKSB7XG4gICAgICAgIGxldCBkbTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsICYmIHBvaW50ZXIuUmVzb2x2ZSgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkbSA9IHBvaW50ZXIuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoZG0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHNbaV0uY3VycmVudFBvaW50ZXI7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsICYmIHBvaW50ZXIuUmVzb2x2ZSgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZG0gPSBwb2ludGVyLlJlc29sdmUoKS5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgbGV0IG91dHB1dE9iaiA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgZG0gPSBvdXRwdXRPYmouZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1haW5Db250ZW50Q29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN0b3J5ID0gU3Rvcnk7XG5TdG9yeS5pbmtWZXJzaW9uQ3VycmVudCA9IDE5O1xuKGZ1bmN0aW9uIChTdG9yeSkge1xuICAgIGxldCBPdXRwdXRTdGF0ZUNoYW5nZTtcbiAgICAoZnVuY3Rpb24gKE91dHB1dFN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIE91dHB1dFN0YXRlQ2hhbmdlW091dHB1dFN0YXRlQ2hhbmdlW1wiTm9DaGFuZ2VcIl0gPSAwXSA9IFwiTm9DaGFuZ2VcIjtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJFeHRlbmRlZEJleW9uZE5ld2xpbmVcIl0gPSAxXSA9IFwiRXh0ZW5kZWRCZXlvbmROZXdsaW5lXCI7XG4gICAgICAgIE91dHB1dFN0YXRlQ2hhbmdlW091dHB1dFN0YXRlQ2hhbmdlW1wiTmV3bGluZVJlbW92ZWRcIl0gPSAyXSA9IFwiTmV3bGluZVJlbW92ZWRcIjtcbiAgICB9KShPdXRwdXRTdGF0ZUNoYW5nZSA9IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlIHx8IChTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZSA9IHt9KSk7XG59KShTdG9yeSA9IGV4cG9ydHMuU3RvcnkgfHwgKGV4cG9ydHMuU3RvcnkgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3J5RXhjZXB0aW9uID0gdm9pZCAwO1xuY2xhc3MgU3RvcnlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy51c2VFbmRMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU3RvcnlFeGNlcHRpb25cIjtcbiAgICB9XG59XG5leHBvcnRzLlN0b3J5RXhjZXB0aW9uID0gU3RvcnlFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yeUV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnlTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IENhbGxTdGFja18xID0gcmVxdWlyZShcIi4vQ2FsbFN0YWNrXCIpO1xuY29uc3QgVmFyaWFibGVzU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlc1N0YXRlXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgR2x1ZV8xID0gcmVxdWlyZShcIi4vR2x1ZVwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBDb250cm9sQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29udHJvbENvbW1hbmRcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgUFJOR18xID0gcmVxdWlyZShcIi4vUFJOR1wiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0b3J5XzEgPSByZXF1aXJlKFwiLi9TdG9yeVwiKTtcbmNvbnN0IFN0YXRlUGF0Y2hfMSA9IHJlcXVpcmUoXCIuL1N0YXRlUGF0Y2hcIik7XG5jb25zdCBTaW1wbGVKc29uXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVKc29uXCIpO1xuY2xhc3MgU3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcnkpIHtcbiAgICAgICAgdGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbiA9IDg7XG4gICAgICAgIHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICB0aGlzLmRpZFNhZmVFeGl0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcnkgPSBzdG9yeTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0gW107XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGlvblN0YWNrID0gW107XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjayhzdG9yeSk7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1N0YXRlID0gbmV3IFZhcmlhYmxlc1N0YXRlXzEuVmFyaWFibGVzU3RhdGUodGhpcy5jYWxsU3RhY2ssIHN0b3J5Lmxpc3REZWZpbml0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4ID0gLTE7XG4gICAgICAgIGxldCB0aW1lU2VlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IG5ldyBQUk5HXzEuUFJORyh0aW1lU2VlZCkubmV4dCgpICUgMTAwO1xuICAgICAgICB0aGlzLnByZXZpb3VzUmFuZG9tID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5Hb1RvU3RhcnQoKTtcbiAgICB9XG4gICAgVG9Kc29uKGluZGVudGVkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHdyaXRlciA9IG5ldyBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5Xcml0ZXIoKTtcbiAgICAgICAgdGhpcy5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5Ub1N0cmluZygpO1xuICAgIH1cbiAgICB0b0pzb24oaW5kZW50ZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5Ub0pzb24oaW5kZW50ZWQpO1xuICAgIH1cbiAgICBMb2FkSnNvbihqc29uKSB7XG4gICAgICAgIGxldCBqT2JqZWN0ID0gU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uVGV4dFRvRGljdGlvbmFyeShqc29uKTtcbiAgICAgICAgdGhpcy5Mb2FkSnNvbk9iaihqT2JqZWN0KTtcbiAgICB9XG4gICAgVmlzaXRDb3VudEF0UGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gICAgICAgIGxldCB2aXNpdENvdW50T3V0O1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLnN0b3J5LkNvbnRlbnRBdFBhdGgobmV3IFBhdGhfMS5QYXRoKHBhdGhTdHJpbmcpKS5jb250YWluZXI7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgYXQgcGF0aCBub3QgZm91bmQ6IFwiICsgcGF0aFN0cmluZyk7XG4gICAgICAgICAgICB2aXNpdENvdW50T3V0ID0gdGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKHZpc2l0Q291bnRPdXQuZXhpc3RzKVxuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdENvdW50T3V0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdENvdW50T3V0ID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3Zpc2l0Q291bnRzLCBwYXRoU3RyaW5nLCBudWxsKTtcbiAgICAgICAgaWYgKHZpc2l0Q291bnRPdXQuZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0Q291bnRPdXQucmVzdWx0O1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250YWluZXIudmlzaXRzU2hvdWxkQmVDb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3J5LkVycm9yKFwiUmVhZCBjb3VudCBmb3IgdGFyZ2V0IChcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiIC0gb24gXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kZWJ1Z01ldGFkYXRhICtcbiAgICAgICAgICAgICAgICBcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKGNvdW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudC5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgY291bnQyID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3Zpc2l0Q291bnRzLCBjb250YWluZXJQYXRoU3RyLCBudWxsKTtcbiAgICAgICAgaWYgKGNvdW50Mi5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDIucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBJbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjdXJyQ291bnQgPSB0aGlzLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGN1cnJDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5fcGF0Y2guU2V0VmlzaXRDb3VudChjb250YWluZXIsIGN1cnJDb3VudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgY291bnQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIGNvbnRhaW5lclBhdGhTdHIsIG51bGwpO1xuICAgICAgICBpZiAoY291bnQuZXhpc3RzKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyUGF0aFN0ciwgY291bnQucmVzdWx0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyUGF0aFN0ciwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXRjaC5TZXRUdXJuSW5kZXgoY29udGFpbmVyLCB0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMuc2V0KGNvbnRhaW5lclBhdGhTdHIsIHRoaXMuY3VycmVudFR1cm5JbmRleCk7XG4gICAgfVxuICAgIFR1cm5zU2luY2VGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yeS5FcnJvcihcIlRVUk5TX1NJTkNFKCkgZm9yIHRhcmdldCAoXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lICtcbiAgICAgICAgICAgICAgICBcIiAtIG9uIFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZGVidWdNZXRhZGF0YSArXG4gICAgICAgICAgICAgICAgXCIpIHVua25vd24uIFRoZSBzdG9yeSBtYXkgbmVlZCB0byBiZSBjb21waWxlZCB3aXRoIGNvdW50QWxsVmlzaXRzIGZsYWcgKC1jKS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9wYXRjaC5UcnlHZXRUdXJuSW5kZXgoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIGlmIChpbmRleC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VHVybkluZGV4IC0gaW5kZXgucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGluZGV4MiA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl90dXJuSW5kaWNlcywgY29udGFpbmVyUGF0aFN0ciwgMCk7XG4gICAgICAgIGlmIChpbmRleDIuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VHVybkluZGV4IC0gaW5kZXgyLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FsbHN0YWNrRGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5kZXB0aDtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dFN0cmVhbTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDaG9pY2VzKCkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4gY29udGludWUgZ2VuZXJhdGluZyB0ZXh0IGNvbnRlbnQgcmF0aGVyIHRoYW4gY2hvaWNlcyxcbiAgICAgICAgLy8gdGhlbiB3ZSByZWZsZWN0IHRoZSBjaG9pY2UgbGlzdCBhcyBiZWluZyBlbXB0eSwgc2luY2UgY2hvaWNlc1xuICAgICAgICAvLyBzaG91bGQgYWx3YXlzIGNvbWUgYXQgdGhlIGVuZC5cbiAgICAgICAgaWYgKHRoaXMuY2FuQ29udGludWUpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGdlbmVyYXRlZENob2ljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RXJyb3JzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFdhcm5pbmdzO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVzU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXNTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHZhcmlhYmxlc1N0YXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1N0YXRlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBldmFsdWF0aW9uU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0aW9uU3RhY2s7XG4gICAgfVxuICAgIGdldCB2aXNpdENvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgIH1cbiAgICBnZXQgdHVybkluZGljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90dXJuSW5kaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUdXJuSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHVybkluZGV4O1xuICAgIH1cbiAgICBzZXQgY3VycmVudFR1cm5JbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VHVybkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UGF0aFN0cmluZygpIHtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICBpZiAocG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5wYXRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9pbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRQb2ludGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gdmFsdWUuY29weSgpO1xuICAgIH1cbiAgICBnZXQgcHJldmlvdXNQb2ludGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBzZXQgcHJldmlvdXNQb2ludGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQucHJldmlvdXNQb2ludGVyID0gdmFsdWUuY29weSgpO1xuICAgIH1cbiAgICBnZXQgY2FuQ29udGludWUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jdXJyZW50UG9pbnRlci5pc051bGwgJiYgIXRoaXMuaGFzRXJyb3I7XG4gICAgfVxuICAgIGdldCBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVycm9ycyAhPSBudWxsICYmIHRoaXMuY3VycmVudEVycm9ycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgaGFzV2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFdhcm5pbmdzICE9IG51bGwgJiYgdGhpcy5jdXJyZW50V2FybmluZ3MubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5KSB7XG4gICAgICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IG91dHB1dE9iaiBvZiB0aGlzLl9vdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgdGV4dENvbnRlbnQgPSBvdXRwdXRPYmogYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRDb250ZW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG91dHB1dE9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCh0ZXh0Q29udGVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRleHQgPSB0aGlzLkNsZWFuT3V0cHV0V2hpdGVzcGFjZShzYi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGV4dDtcbiAgICB9XG4gICAgQ2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHN0cikge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0T2ZMaW5lID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGxldCBpc0lubGluZVdoaXRlc3BhY2UgPSBjID09IFwiIFwiIHx8IGMgPT0gXCJcXHRcIjtcbiAgICAgICAgICAgIGlmIChpc0lubGluZVdoaXRlc3BhY2UgJiYgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9PSAtMSlcbiAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGlmICghaXNJbmxpbmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgIT0gXCJcXG5cIiAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ICE9IHN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09IFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgc3RhcnRPZkxpbmUgPSBpICsgMTtcbiAgICAgICAgICAgIGlmICghaXNJbmxpbmVXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUYWdzKCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFncyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgb3V0cHV0T2JqIG9mIHRoaXMuX291dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciB0YWcgPSBvdXRwdXRPYmogYXMgVGFnO1xuICAgICAgICAgICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob3V0cHV0T2JqLCBUYWdfMS5UYWcpO1xuICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhZ3MucHVzaCh0YWcudGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUYWdzO1xuICAgIH1cbiAgICBnZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb247XG4gICAgfVxuICAgIHNldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgR29Ub1N0YXJ0KCkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YodGhpcy5zdG9yeS5tYWluQ29udGVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIENvcHlBbmRTdGFydFBhdGNoaW5nKCkge1xuICAgICAgICBsZXQgY29weSA9IG5ldyBTdG9yeVN0YXRlKHRoaXMuc3RvcnkpO1xuICAgICAgICBjb3B5Ll9wYXRjaCA9IG5ldyBTdGF0ZVBhdGNoXzEuU3RhdGVQYXRjaCh0aGlzLl9wYXRjaCk7XG4gICAgICAgIGNvcHkub3V0cHV0U3RyZWFtLnB1c2guYXBwbHkoY29weS5vdXRwdXRTdHJlYW0sIHRoaXMuX291dHB1dFN0cmVhbSk7XG4gICAgICAgIGNvcHkuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgY29weS5fY3VycmVudENob2ljZXMucHVzaC5hcHBseShjb3B5Ll9jdXJyZW50Q2hvaWNlcywgdGhpcy5fY3VycmVudENob2ljZXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgY29weS5fY3VycmVudEVycm9ycyA9IFtdO1xuICAgICAgICAgICAgY29weS5fY3VycmVudEVycm9ycy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRFcnJvcnMsIHRoaXMuY3VycmVudEVycm9ycyB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzV2FybmluZykge1xuICAgICAgICAgICAgY29weS5fY3VycmVudFdhcm5pbmdzID0gW107XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50V2FybmluZ3MucHVzaC5hcHBseShjb3B5Ll9jdXJyZW50V2FybmluZ3MsIHRoaXMuY3VycmVudFdhcm5pbmdzIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5LmNhbGxTdGFjayA9IG5ldyBDYWxsU3RhY2tfMS5DYWxsU3RhY2sodGhpcy5jYWxsU3RhY2spO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlID0gdGhpcy52YXJpYWJsZXNTdGF0ZTtcbiAgICAgICAgY29weS52YXJpYWJsZXNTdGF0ZS5jYWxsU3RhY2sgPSBjb3B5LmNhbGxTdGFjaztcbiAgICAgICAgY29weS52YXJpYWJsZXNTdGF0ZS5wYXRjaCA9IGNvcHkuX3BhdGNoO1xuICAgICAgICBjb3B5LmV2YWx1YXRpb25TdGFjay5wdXNoLmFwcGx5KGNvcHkuZXZhbHVhdGlvblN0YWNrLCB0aGlzLmV2YWx1YXRpb25TdGFjayk7XG4gICAgICAgIGlmICghdGhpcy5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKVxuICAgICAgICAgICAgY29weS5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLmRpdmVydGVkUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGNvcHkucHJldmlvdXNQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgICAgICBjb3B5Ll92aXNpdENvdW50cyA9IHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgICAgICBjb3B5Ll90dXJuSW5kaWNlcyA9IHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgICAgICBjb3B5LmN1cnJlbnRUdXJuSW5kZXggPSB0aGlzLmN1cnJlbnRUdXJuSW5kZXg7XG4gICAgICAgIGNvcHkuc3RvcnlTZWVkID0gdGhpcy5zdG9yeVNlZWQ7XG4gICAgICAgIGNvcHkucHJldmlvdXNSYW5kb20gPSB0aGlzLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICBjb3B5LmRpZFNhZmVFeGl0ID0gdGhpcy5kaWRTYWZlRXhpdDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIFJlc3RvcmVBZnRlclBhdGNoKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjayA9IHRoaXMuY2FsbFN0YWNrO1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLnBhdGNoID0gdGhpcy5fcGF0Y2g7XG4gICAgfVxuICAgIEFwcGx5QW55UGF0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5BcHBseVBhdGNoKCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9wYXRjaC52aXNpdENvdW50cylcbiAgICAgICAgICAgIHRoaXMuQXBwbHlDb3VudENoYW5nZXMoa2V5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9wYXRjaC50dXJuSW5kaWNlcylcbiAgICAgICAgICAgIHRoaXMuQXBwbHlDb3VudENoYW5nZXMoa2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9wYXRjaCA9IG51bGw7XG4gICAgfVxuICAgIEFwcGx5Q291bnRDaGFuZ2VzKGNvbnRhaW5lciwgbmV3Q291bnQsIGlzVmlzaXQpIHtcbiAgICAgICAgbGV0IGNvdW50cyA9IGlzVmlzaXQgPyB0aGlzLl92aXNpdENvdW50cyA6IHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgICAgICBjb3VudHMuc2V0KGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCksIG5ld0NvdW50KTtcbiAgICB9XG4gICAgV3JpdGVKc29uKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBsZXQgaGFzQ2hvaWNlVGhyZWFkcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBpZiAoYy50aHJlYWRBdEdlbmVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImMudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5vcmlnaW5hbFRocmVhZEluZGV4ID0gYy50aHJlYWRBdEdlbmVyYXRpb24udGhyZWFkSW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suVGhyZWFkV2l0aEluZGV4KGMub3JpZ2luYWxUaHJlYWRJbmRleCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0Nob2ljZVRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hvaWNlVGhyZWFkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjaG9pY2VUaHJlYWRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KGMub3JpZ2luYWxUaHJlYWRJbmRleCk7XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24uV3JpdGVKc29uKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ2hvaWNlVGhyZWFkcykge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBmb2xsb3dpbmcgdHdvIGNhbGxzLCBgV3JpdGVKc29uYCBpcyBjYWxsZWQgaW5zaWRlIGFuIGFycm93XG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZSBgdGhpc2AgaXMgY29ycmVjdGx5IGJvdW5kIGFuZCBwYXNzZWQgZG93blxuICAgICAgICAvLyB0aGUgY2FsbCBoaWVyYXJjaHkuXG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY2FsbHN0YWNrVGhyZWFkc1wiLCAodykgPT4gdGhpcy5jYWxsU3RhY2suV3JpdGVKc29uKHcpKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ2YXJpYWJsZXNTdGF0ZVwiLCAodykgPT4gdGhpcy52YXJpYWJsZXNTdGF0ZS5Xcml0ZUpzb24odykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImV2YWxTdGFja1wiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh3LCB0aGlzLmV2YWx1YXRpb25TdGFjaykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIm91dHB1dFN0cmVhbVwiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh3LCB0aGlzLl9vdXRwdXRTdHJlYW0pKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjdXJyZW50Q2hvaWNlc1wiLCAodykgPT4ge1xuICAgICAgICAgICAgdy5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpXG4gICAgICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUNob2ljZSh3LCBjKTtcbiAgICAgICAgICAgIHcuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJkaXZlcnRlZFBvaW50ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnREaXZlcnRUYXJnZXRcIiwgdGhpcy5kaXZlcnRlZFBvaW50ZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZpc2l0Q291bnRzXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlSW50RGljdGlvbmFyeSh3LCB0aGlzLl92aXNpdENvdW50cykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInR1cm5JbmRpY2VzXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlSW50RGljdGlvbmFyeSh3LCB0aGlzLl90dXJuSW5kaWNlcykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInR1cm5JZHhcIiwgdGhpcy5jdXJyZW50VHVybkluZGV4KTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJzdG9yeVNlZWRcIiwgdGhpcy5zdG9yeVNlZWQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInByZXZpb3VzUmFuZG9tXCIsIHRoaXMucHJldmlvdXNSYW5kb20pO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua1NhdmVWZXJzaW9uXCIsIHRoaXMua0lua1NhdmVTdGF0ZVZlcnNpb24pO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua0Zvcm1hdFZlcnNpb25cIiwgU3RvcnlfMS5TdG9yeS5pbmtWZXJzaW9uQ3VycmVudCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBMb2FkSnNvbk9iaih2YWx1ZSkge1xuICAgICAgICBsZXQgak9iamVjdCA9IHZhbHVlO1xuICAgICAgICBsZXQgalNhdmVWZXJzaW9uID0gak9iamVjdFtcImlua1NhdmVWZXJzaW9uXCJdO1xuICAgICAgICBpZiAoalNhdmVWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiaW5rIHNhdmUgZm9ybWF0IGluY29ycmVjdCwgY2FuJ3QgbG9hZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQoalNhdmVWZXJzaW9uKSA8IHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJJbmsgc2F2ZSBmb3JtYXQgaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gKHNhdyAnXCIgK1xuICAgICAgICAgICAgICAgIGpTYXZlVmVyc2lvbiArXG4gICAgICAgICAgICAgICAgXCInLCBidXQgbWluaW11bSBpcyBcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uICtcbiAgICAgICAgICAgICAgICBcIiksIHNvIGNhbid0IGxvYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlNldEpzb25Ub2tlbihqT2JqZWN0W1wiY2FsbHN0YWNrVGhyZWFkc1wiXSwgdGhpcy5zdG9yeSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUuU2V0SnNvblRva2VuKGpPYmplY3RbXCJ2YXJpYWJsZXNTdGF0ZVwiXSk7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRpb25TdGFjayA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdChqT2JqZWN0W1wiZXZhbFN0YWNrXCJdKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpPYmplY3RbXCJvdXRwdXRTdHJlYW1cIl0pO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgIC8vIGN1cnJlbnRDaG9pY2VzID0gSnNvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0PENob2ljZT4oKEpBcnJheSlqT2JqZWN0IFtcImN1cnJlbnRDaG9pY2VzXCJdKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpBcnJheVRvUnVudGltZU9iakxpc3Qoak9iamVjdFtcImN1cnJlbnRDaG9pY2VzXCJdKTtcbiAgICAgICAgbGV0IGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoID0gak9iamVjdFtcImN1cnJlbnREaXZlcnRUYXJnZXRcIl07XG4gICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0VGFyZ2V0UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aChjdXJyZW50RGl2ZXJ0VGFyZ2V0UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKGRpdmVydFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3RbXCJ2aXNpdENvdW50c1wiXSk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3RbXCJ0dXJuSW5kaWNlc1wiXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFR1cm5JbmRleCA9IHBhcnNlSW50KGpPYmplY3RbXCJ0dXJuSWR4XCJdKTtcbiAgICAgICAgdGhpcy5zdG9yeVNlZWQgPSBwYXJzZUludChqT2JqZWN0W1wic3RvcnlTZWVkXCJdKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1JhbmRvbSA9IHBhcnNlSW50KGpPYmplY3RbXCJwcmV2aW91c1JhbmRvbVwiXSk7XG4gICAgICAgIC8vIHZhciBqQ2hvaWNlVGhyZWFkcyA9IGpPYmplY3RbXCJjaG9pY2VUaHJlYWRzXCJdIGFzIEpPYmplY3Q7XG4gICAgICAgIGxldCBqQ2hvaWNlVGhyZWFkcyA9IGpPYmplY3RbXCJjaG9pY2VUaHJlYWRzXCJdO1xuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRBY3RpdmVUaHJlYWQgPSB0aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgoYy5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZEFjdGl2ZVRocmVhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24gPSBmb3VuZEFjdGl2ZVRocmVhZC5Db3B5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgalNhdmVkQ2hvaWNlVGhyZWFkID0gakNob2ljZVRocmVhZHNbYy5vcmlnaW5hbFRocmVhZEluZGV4LnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgIGMudGhyZWFkQXRHZW5lcmF0aW9uID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjay5UaHJlYWQoalNhdmVkQ2hvaWNlVGhyZWFkLCB0aGlzLnN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNldEVycm9ycygpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IG51bGw7XG4gICAgfVxuICAgIFJlc2V0T3V0cHV0KG9ianMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggPSAwO1xuICAgICAgICBpZiAob2JqcyAhPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5wdXNoLmFwcGx5KHRoaXMuX291dHB1dFN0cmVhbSwgb2Jqcyk7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUHVzaFRvT3V0cHV0U3RyZWFtKG9iaikge1xuICAgICAgICAvLyB2YXIgdGV4dCA9IG9iaiBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBsaXN0VGV4dCA9IHRoaXMuVHJ5U3BsaXR0aW5nSGVhZFRhaWxXaGl0ZXNwYWNlKHRleHQpO1xuICAgICAgICAgICAgaWYgKGxpc3RUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGV4dE9iaiBvZiBsaXN0VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwodGV4dE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKG9iaik7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUG9wRnJvbU91dHB1dFN0cmVhbShjb3VudCkge1xuICAgICAgICB0aGlzLm91dHB1dFN0cmVhbS5zcGxpY2UodGhpcy5vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBUcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2Uoc2luZ2xlKSB7XG4gICAgICAgIGxldCBzdHIgPSBzaW5nbGUudmFsdWU7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwic2luZ2xlLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZWFkRmlyc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGxldCBoZWFkTGFzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBoZWFkRmlyc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICBoZWFkTGFzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSBcIiBcIiB8fCBjID09IFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhaWxMYXN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBsZXQgdGFpbEZpcnN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGFpbExhc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICB0YWlsRmlyc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gXCIgXCIgfHwgYyA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHNwbGl0dGluZyB0byBiZSBkb25lP1xuICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCA9PSAtMSAmJiB0YWlsTGFzdE5ld2xpbmVJZHggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RUZXh0cyA9IFtdO1xuICAgICAgICBsZXQgaW5uZXJTdHJTdGFydCA9IDA7XG4gICAgICAgIGxldCBpbm5lclN0ckVuZCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVhZGluZ1NwYWNlcyA9IG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcoMCwgaGVhZEZpcnN0TmV3bGluZUlkeCkpO1xuICAgICAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKGxlYWRpbmdTcGFjZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIikpO1xuICAgICAgICAgICAgaW5uZXJTdHJTdGFydCA9IGhlYWRMYXN0TmV3bGluZUlkeCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCAhPSAtMSkge1xuICAgICAgICAgICAgaW5uZXJTdHJFbmQgPSB0YWlsRmlyc3ROZXdsaW5lSWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lclN0ckVuZCA+IGlubmVyU3RyU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBpbm5lclN0clRleHQgPSBzdHIuc3Vic3RyaW5nKGlubmVyU3RyU3RhcnQsIGlubmVyU3RyRW5kIC0gaW5uZXJTdHJTdGFydCk7XG4gICAgICAgICAgICBsaXN0VGV4dHMucHVzaChuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShpbm5lclN0clRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ICE9IC0xICYmIHRhaWxGaXJzdE5ld2xpbmVJZHggPiBoZWFkTGFzdE5ld2xpbmVJZHgpIHtcbiAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggPCBzdHIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGxldCBudW1TcGFjZXMgPSBzdHIubGVuZ3RoIC0gdGFpbExhc3ROZXdsaW5lSWR4IC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdHJhaWxpbmdTcGFjZXMgPSBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzdHIuc3Vic3RyaW5nKHRhaWxMYXN0TmV3bGluZUlkeCArIDEsIG51bVNwYWNlcykpO1xuICAgICAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKHRyYWlsaW5nU3BhY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdFRleHRzO1xuICAgIH1cbiAgICBQdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKG9iaikge1xuICAgICAgICBsZXQgZ2x1ZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIEdsdWVfMS5HbHVlKTtcbiAgICAgICAgbGV0IHRleHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgbGV0IGluY2x1ZGVJbk91dHB1dCA9IHRydWU7XG4gICAgICAgIGlmIChnbHVlKSB7XG4gICAgICAgICAgICB0aGlzLlRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgIGluY2x1ZGVJbk91dHB1dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCkge1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uVHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZXQgY3VyckVsID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoY3VyckVsLnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25UcmltSW5kZXggPSBjdXJyRWwuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdsdWVUcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG8gaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kID8gbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGcgPSBvIGluc3RhbmNlb2YgR2x1ZV8xLkdsdWUgPyBvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsdWVUcmltSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGMuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBmdW5jdGlvblRyaW1JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBpZiAoZ2x1ZVRyaW1JbmRleCAhPSAtMSAmJiBmdW5jdGlvblRyaW1JbmRleCAhPSAtMSlcbiAgICAgICAgICAgICAgICB0cmltSW5kZXggPSBNYXRoLm1pbihmdW5jdGlvblRyaW1JbmRleCwgZ2x1ZVRyaW1JbmRleCk7XG4gICAgICAgICAgICBlbHNlIGlmIChnbHVlVHJpbUluZGV4ICE9IC0xKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRleCA9IGdsdWVUcmltSW5kZXg7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHJpbUluZGV4ID0gZnVuY3Rpb25UcmltSW5kZXg7XG4gICAgICAgICAgICBpZiAodHJpbUluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVJbk91dHB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0LmlzTm9uV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2x1ZVRyaW1JbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5SZW1vdmVFeGlzdGluZ0dsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uVHJpbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWxsU3RhY2tFbGVtZW50cyA9IHRoaXMuY2FsbFN0YWNrLmVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNhbGxTdGFja0VsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsID0gY2FsbFN0YWNrRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lIHx8ICF0aGlzLm91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVJbk91dHB1dCkge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnB1c2gob2JqKTtcbiAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmltTmV3bGluZXNGcm9tT3V0cHV0U3RyZWFtKCkge1xuICAgICAgICBsZXQgcmVtb3ZlV2hpdGVzcGFjZUZyb20gPSAtMTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGxldCBjbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgIGxldCB0eHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbWQgIT0gbnVsbCB8fCAodHh0ICE9IG51bGwgJiYgdHh0LmlzTm9uV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4dCAhPSBudWxsICYmIHR4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVXaGl0ZXNwYWNlRnJvbSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB3aGl0ZXNwYWNlXG4gICAgICAgIGlmIChyZW1vdmVXaGl0ZXNwYWNlRnJvbSA+PSAwKSB7XG4gICAgICAgICAgICBpID0gcmVtb3ZlV2hpdGVzcGFjZUZyb207XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLl9vdXRwdXRTdHJlYW1baV0sIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUmVtb3ZlRXhpc3RpbmdHbHVlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgR2x1ZV8xLkdsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIGdldCBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuaXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQuaXNOb25XaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1baV0gaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGluU3RyaW5nRXZhbHVhdGlvbigpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gdmFyIGNtZCA9IHRoaXMuX291dHB1dFN0cmVhbVtpXSBhcyBDb250cm9sQ29tbWFuZDtcbiAgICAgICAgICAgIGxldCBjbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5fb3V0cHV0U3RyZWFtW2ldLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgIGlmIChjbWQgaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kICYmXG4gICAgICAgICAgICAgICAgY21kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFB1c2hFdmFsdWF0aW9uU3RhY2sob2JqKSB7XG4gICAgICAgIC8vIHZhciBsaXN0VmFsdWUgPSBvYmogYXMgTGlzdFZhbHVlO1xuICAgICAgICBsZXQgbGlzdFZhbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBpZiAobGlzdFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgb3JpZ2luIHdoZW4gbGlzdCBpcyBoYXMgc29tZXRoaW5nIHRvIGluZGljYXRlIHRoZSBsaXN0IG9yaWdpblxuICAgICAgICAgICAgbGV0IHJhd0xpc3QgPSBsaXN0VmFsdWUudmFsdWU7XG4gICAgICAgICAgICBpZiAocmF3TGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmF3TGlzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdMaXN0Lm9yaWdpbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd0xpc3Qub3JpZ2lucylcbiAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zID0gW107XG4gICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbiBvZiByYXdMaXN0Lm9yaWdpbk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiU3RvcnlTdGF0ZS5zdG9yeS5saXN0RGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5yZXN1bHQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlN0b3J5U3RhdGUgZGVmLnJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0xpc3Qub3JpZ2lucy5pbmRleE9mKGRlZi5yZXN1bHQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2lucy5wdXNoKGRlZi5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9ialwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2YWx1YXRpb25TdGFjay5wdXNoKG9iaik7XG4gICAgfVxuICAgIFBvcEV2YWx1YXRpb25TdGFjayhudW1iZXJPZk9iamVjdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXJPZk9iamVjdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmV2YWx1YXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEubnVsbElmVW5kZWZpbmVkKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZPYmplY3RzID4gdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5aW5nIHRvIHBvcCB0b28gbWFueSBvYmplY3RzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBvcHBlZCA9IHRoaXMuZXZhbHVhdGlvblN0YWNrLnNwbGljZSh0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggLSBudW1iZXJPZk9iamVjdHMsIG51bWJlck9mT2JqZWN0cyk7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLm51bGxJZlVuZGVmaW5lZChwb3BwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBlZWtFdmFsdWF0aW9uU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRpb25TdGFja1t0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgRm9yY2VFbmQoKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuZGlkU2FmZUV4aXQgPSB0cnVlO1xuICAgIH1cbiAgICBUcmltV2hpdGVzcGFjZUZyb21GdW5jdGlvbkVuZCgpIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pO1xuICAgICAgICBsZXQgZnVuY3Rpb25TdGFydFBvaW50ID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnRcbiAgICAgICAgICAgIC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgIGlmIChmdW5jdGlvblN0YXJ0UG9pbnQgPT0gLTEpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uU3RhcnRQb2ludCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IGZ1bmN0aW9uU3RhcnRQb2ludDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgbGV0IHR4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKHR4dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNtZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0eHQuaXNOZXdsaW5lIHx8IHR4dC5pc0lubGluZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFBvcENhbGxTdGFjayhwb3BUeXBlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pXG4gICAgICAgICAgICB0aGlzLlRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCk7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlBvcChwb3BUeXBlKTtcbiAgICB9XG4gICAgU2V0Q2hvc2VuUGF0aChwYXRoLCBpbmNyZW1lbnRpbmdUdXJuSW5kZXgpIHtcbiAgICAgICAgLy8gQ2hhbmdpbmcgZGlyZWN0aW9uLCBhc3N1bWUgd2UgbmVlZCB0byBjbGVhciBjdXJyZW50IHNldCBvZiBjaG9pY2VzXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBuZXdQb2ludGVyID0gdGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKHBhdGgpO1xuICAgICAgICBpZiAoIW5ld1BvaW50ZXIuaXNOdWxsICYmIG5ld1BvaW50ZXIuaW5kZXggPT0gLTEpXG4gICAgICAgICAgICBuZXdQb2ludGVyLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgICAgIGlmIChpbmNyZW1lbnRpbmdUdXJuSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFR1cm5JbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0YXJ0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoZnVuY0NvbnRhaW5lciwgYXJncykge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSwgdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKGZ1bmNDb250YWluZXIpO1xuICAgICAgICB0aGlzLlBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhhcmdzKTtcbiAgICB9XG4gICAgUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpIHtcbiAgICAgICAgLy8gUGFzcyBhcmd1bWVudHMgb250byB0aGUgZXZhbHVhdGlvbiBzdGFja1xuICAgICAgICBpZiAoYXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgYXJnc1tpXSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYXJnc1tpXSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5rIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgRXZhbHVhdGVGdW5jdGlvbiAvIENob29zZVBhdGhTdHJpbmdXaXRoUGFyYW1ldGVycyAgbXVzdCBiZSBpbnQsIGZsb2F0IG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5QdXNoRXZhbHVhdGlvblN0YWNrKFZhbHVlXzEuVmFsdWUuQ3JlYXRlKGFyZ3NbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBUcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09XG4gICAgICAgICAgICBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgdGhpcy5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENvbXBsZXRlRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlICE9XG4gICAgICAgICAgICBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgZXh0ZXJuYWwgZnVuY3Rpb24gZXZhbHVhdGlvbiB0byBiZSBjb21wbGV0ZS4gU3RhY2sgdHJhY2U6IFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0ID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnRcbiAgICAgICAgICAgIC5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkO1xuICAgICAgICBsZXQgcmV0dXJuZWRPYmogPSBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoID4gb3JpZ2luYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBwb3BwZWRPYmogPSB0aGlzLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgaWYgKHJldHVybmVkT2JqID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybmVkT2JqID0gcG9wcGVkT2JqO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuUG9wQ2FsbFN0YWNrKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSk7XG4gICAgICAgIGlmIChyZXR1cm5lZE9iaikge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkT2JqIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyBTb21lIGtpbmQgb2YgdmFsdWUsIGlmIG5vdCB2b2lkXG4gICAgICAgICAgICAvLyB2YXIgcmV0dXJuVmFsID0gcmV0dXJuZWRPYmogYXMgUnVudGltZS5WYWx1ZTtcbiAgICAgICAgICAgIGxldCByZXR1cm5WYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhyZXR1cm5lZE9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAvLyBEaXZlcnRUYXJnZXRzIGdldCByZXR1cm5lZCBhcyB0aGUgc3RyaW5nIG9mIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIChyYXRoZXIgdGhhbiBhIFBhdGgsIHdoaWNoIGlzbid0IHB1YmxpYylcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWwudmFsdWVPYmplY3QudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyIHR5cGVzIGNhbiBqdXN0IGhhdmUgdGhlaXIgZXhhY3Qgb2JqZWN0IHR5cGU6XG4gICAgICAgICAgICAvLyBpbnQsIGZsb2F0LCBzdHJpbmcuIFZhcmlhYmxlUG9pbnRlcnMgZ2V0IHJldHVybmVkIGFzIHN0cmluZ3MuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsLnZhbHVlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBBZGRFcnJvcihtZXNzYWdlLCBpc1dhcm5pbmcpIHtcbiAgICAgICAgaWYgKCFpc1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50RXJyb3JzID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3V0cHV0U3RyZWFtRGlydHkoKSB7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yeVN0YXRlID0gU3RvcnlTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3J5U3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmluZ0J1aWxkZXIgPSB2b2lkIDA7XG5jbGFzcyBTdHJpbmdCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICAgICAgc3RyID0gdHlwZW9mIHN0ciAhPT0gXCJ1bmRlZmluZWRcIiA/IHN0ci50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHI7XG4gICAgfVxuICAgIGdldCBMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIEFwcGVuZChzdHIpIHtcbiAgICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmcgKz0gc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFwcGVuZExpbmUoc3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGhpcy5BcHBlbmQoc3RyKTtcbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gXCJcXG5cIjtcbiAgICB9XG4gICAgQXBwZW5kRm9ybWF0KGZvcm1hdCwgLi4uYXJncykge1xuICAgICAgICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjEwNDA2L2phdmFzY3JpcHQtZXF1aXZhbGVudC10by1wcmludGYtc3RyaW5nLWZvcm1hdFxuICAgICAgICB0aGlzLnN0cmluZyArPSBmb3JtYXQucmVwbGFjZSgveyhcXGQrKX0vZywgKG1hdGNoLCBudW0pID0+IHR5cGVvZiBhcmdzW251bV0gIT0gXCJ1bmRlZmluZWRcIiA/IGFyZ3NbbnVtXSA6IG1hdGNoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ0J1aWxkZXIgPSBTdHJpbmdCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nQnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFnID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBUYWcgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHRhZ1RleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGFnVGV4dC50b1N0cmluZygpIHx8IFwiXCI7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIjIFwiICsgdGhpcy50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50cnlQYXJzZUZsb2F0ID0gZXhwb3J0cy50cnlQYXJzZUludCA9IGV4cG9ydHMudHJ5R2V0VmFsdWVGcm9tTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24gdHJ5R2V0VmFsdWVGcm9tTWFwKG1hcCwga2V5LCBcbi8qIG91dCAqLyB2YWx1ZSkge1xuICAgIGlmIChtYXAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBsZXQgdmFsID0gbWFwLmdldChrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeUdldFZhbHVlRnJvbU1hcCA9IHRyeUdldFZhbHVlRnJvbU1hcDtcbmZ1bmN0aW9uIHRyeVBhcnNlSW50KHZhbHVlLCBcbi8qIG91dCAqLyBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gICAgbGV0IHZhbCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmYXVsdFZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy50cnlQYXJzZUludCA9IHRyeVBhcnNlSW50O1xuZnVuY3Rpb24gdHJ5UGFyc2VGbG9hdCh2YWx1ZSwgXG4vKiBvdXQgKi8gZGVmYXVsdFZhbHVlID0gMCkge1xuICAgIGxldCB2YWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmYXVsdFZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy50cnlQYXJzZUZsb2F0ID0gdHJ5UGFyc2VGbG9hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyeUdldFJlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNFcXVhdGFibGUgPSBleHBvcnRzLm51bGxJZlVuZGVmaW5lZCA9IGV4cG9ydHMuYXNJTmFtZWRDb250ZW50T3JOdWxsID0gZXhwb3J0cy5hc051bWJlck9yVGhyb3dzID0gZXhwb3J0cy5hc09yVGhyb3dzID0gZXhwb3J0cy5hc09yTnVsbCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGFzT3JOdWxsKG9iaiwgdHlwZSkge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmFzT3JOdWxsID0gYXNPck51bGw7XG5mdW5jdGlvbiBhc09yVGhyb3dzKG9iaiwgdHlwZSkge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqfSBpcyBub3Qgb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc09yVGhyb3dzID0gYXNPclRocm93cztcbmZ1bmN0aW9uIGFzTnVtYmVyT3JUaHJvd3Mob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmp9IGlzIG5vdCBhIG51bWJlcmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNOdW1iZXJPclRocm93cyA9IGFzTnVtYmVyT3JUaHJvd3M7XG4vLyBTbyBoZXJlLCBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLCBjb250ZW50T2JqIGlzIGNhc3RlZCB0byBhbiBJTmFtZWRDb250ZW50XG4vLyBidXQgaGVyZSB3ZSB1c2UganMtc3R5bGUgZHVjayB0eXBpbmc6IGlmIGl0IGltcGxlbWVudHMgdGhlIHNhbWUgcHJvcHMgYXMgdGhlIGludGVyZmFjZSxcbi8vIHdlIHRyZWF0IGl0IGFzIHZhbGlkLlxuZnVuY3Rpb24gYXNJTmFtZWRDb250ZW50T3JOdWxsKG9iaikge1xuICAgIGlmIChvYmouaGFzVmFsaWROYW1lICYmIG9iai5uYW1lKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5hc0lOYW1lZENvbnRlbnRPck51bGwgPSBhc0lOYW1lZENvbnRlbnRPck51bGw7XG5mdW5jdGlvbiBudWxsSWZVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLm51bGxJZlVuZGVmaW5lZCA9IG51bGxJZlVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzRXF1YXRhYmxlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHR5cGUuRXF1YWxzID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnRzLmlzRXF1YXRhYmxlID0gaXNFcXVhdGFibGU7XG5mdW5jdGlvbiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSkge1xuICAgIHJldHVybiBvYmo7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlQXNzZXJ0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVR5cGUgPSBleHBvcnRzLkxpc3RWYWx1ZSA9IGV4cG9ydHMuVmFyaWFibGVQb2ludGVyVmFsdWUgPSBleHBvcnRzLkRpdmVydFRhcmdldFZhbHVlID0gZXhwb3J0cy5TdHJpbmdWYWx1ZSA9IGV4cG9ydHMuRmxvYXRWYWx1ZSA9IGV4cG9ydHMuSW50VmFsdWUgPSBleHBvcnRzLlZhbHVlID0gZXhwb3J0cy5BYnN0cmFjdFZhbHVlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBBYnN0cmFjdFZhbHVlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBzdGF0aWMgQ3JlYXRlKHZhbCwgcHJlZmVycmVkTnVtYmVyVHlwZSkge1xuICAgICAgICAvLyBUaGlzIGNvZGUgZG9lc24ndCBleGlzdCBpbiB1cHN0cmVhbSBhbmQgaXMgc2ltcGx5IGhlcmUgdG8gZW5mb3JjZVxuICAgICAgICAvLyB0aGUgY3JlYXRpb24gb2YgdGhlIHByb3BlciBudW1iZXIgdmFsdWUuXG4gICAgICAgIC8vIElmIGBwcmVmZXJyZWROdW1iZXJUeXBlYCBpcyBub3QgcHJvdmlkZWQgb3IgaWYgdmFsdWUgZG9lc24ndCBtYXRjaFxuICAgICAgICAvLyBgcHJlZmVycmVkTnVtYmVyVHlwZWAsIHRoaXMgY29uZGl0aW9uYWwgZG9lcyBub3RoaW5nLlxuICAgICAgICBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSkge1xuICAgICAgICAgICAgaWYgKHByZWZlcnJlZE51bWJlclR5cGUgPT09IFZhbHVlVHlwZS5JbnQgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSA9PT0gVmFsdWVUeXBlLkZsb2F0ICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEltcGxpY2l0bHkgY29udmVydCBib29scyBpbnRvIGludHNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBsZXQgYiA9ICEhdmFsO1xuICAgICAgICAgICAgdmFsID0gYiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95LWxvaHNlL2lua2pzL2lzc3Vlcy80MjVcbiAgICAgICAgLy8gQ2hhbmdlZCBjb25kaXRpb24gc2VxdWVuY2UsIGJlY2F1c2UgTnVtYmVyKCcnKSBpc1xuICAgICAgICAvLyBwYXJzZWQgdG8gMCwgd2hpY2ggbWFkZSBzZXR0aW5nIHN0cmluZyB0byBlbXB0eVxuICAgICAgICAvLyBpbXBvc3NpYmxlXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFN0cmluZyh2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgUGF0aF8xLlBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGl2ZXJ0VGFyZ2V0VmFsdWUoVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsLCBQYXRoXzEuUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIElua0xpc3RfMS5JbmtMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RWYWx1ZShUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWwsIElua0xpc3RfMS5JbmtMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhBYnN0cmFjdFZhbHVlLkNyZWF0ZSh0aGlzKSwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICB9XG4gICAgQmFkQ2FzdEV4Y2VwdGlvbih0YXJnZXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbid0IGNhc3QgXCIgK1xuICAgICAgICAgICAgdGhpcy52YWx1ZU9iamVjdCArXG4gICAgICAgICAgICBcIiBmcm9tIFwiICtcbiAgICAgICAgICAgIHRoaXMudmFsdWVUeXBlICtcbiAgICAgICAgICAgIFwiIHRvIFwiICtcbiAgICAgICAgICAgIHRhcmdldFR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RWYWx1ZSA9IEFic3RyYWN0VmFsdWU7XG5jbGFzcyBWYWx1ZSBleHRlbmRzIEFic3RyYWN0VmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIH1cbiAgICBnZXQgdmFsdWVPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWUgPSBWYWx1ZTtcbmNsYXNzIEludFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgMCk7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT0gMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5JbnQ7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIgKyB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRWYWx1ZSA9IEludFZhbHVlO1xuY2xhc3MgRmxvYXRWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgc3VwZXIodmFsIHx8IDAuMCk7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT0gMC4wO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkZsb2F0O1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIgKyB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdFZhbHVlID0gRmxvYXRWYWx1ZTtcbmNsYXNzIFN0cmluZ1ZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgXCJcIik7XG4gICAgICAgIHRoaXMuX2lzTmV3bGluZSA9IHRoaXMudmFsdWUgPT0gXCJcXG5cIjtcbiAgICAgICAgdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnNwbGl0KFwiXCIpLmV2ZXJ5KChjKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGMgIT0gXCIgXCIgJiYgYyAhPSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5TdHJpbmc7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgaXNOZXdsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNOZXdsaW5lO1xuICAgIH1cbiAgICBnZXQgaXNJbmxpbmVXaGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlO1xuICAgIH1cbiAgICBnZXQgaXNOb25XaGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNOZXdsaW5lICYmICF0aGlzLmlzSW5saW5lV2hpdGVzcGFjZTtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkSW50ID0gVHJ5R2V0UmVzdWx0XzEudHJ5UGFyc2VJbnQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUocGFyc2VkSW50LnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkRmxvYXQgPSBUcnlHZXRSZXN1bHRfMS50cnlQYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZEZsb2F0LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShwYXJzZWRGbG9hdC5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ1ZhbHVlID0gU3RyaW5nVmFsdWU7XG5jbGFzcyBEaXZlcnRUYXJnZXRWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRQYXRoKSB7XG4gICAgICAgIHN1cGVyKHRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkRpdmVydFRhcmdldDtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGRuJ3QgYmUgY2hlY2tpbmcgdGhlIHRydXRoaW5lc3Mgb2YgYSBkaXZlcnQgdGFyZ2V0XCIpO1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiRGl2ZXJ0VGFyZ2V0VmFsdWUoXCIgKyB0aGlzLnRhcmdldFBhdGggKyBcIilcIjtcbiAgICB9XG59XG5leHBvcnRzLkRpdmVydFRhcmdldFZhbHVlID0gRGl2ZXJ0VGFyZ2V0VmFsdWU7XG5jbGFzcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIHN1cGVyKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmRleCA9IGNvbnRleHRJbmRleDtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRJbmRleDtcbiAgICB9XG4gICAgc2V0IGNvbnRleHRJbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0SW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuVmFyaWFibGVQb2ludGVyO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIHZhcmlhYmxlIHBvaW50ZXJcIik7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJWYXJpYWJsZVBvaW50ZXJWYWx1ZShcIiArIHRoaXMudmFyaWFibGVOYW1lICsgXCIpXCI7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVQb2ludGVyVmFsdWUodGhpcy52YXJpYWJsZU5hbWUsIHRoaXMuY29udGV4dEluZGV4KTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlUG9pbnRlclZhbHVlID0gVmFyaWFibGVQb2ludGVyVmFsdWU7XG5jbGFzcyBMaXN0VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLkNvdW50ID4gMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5MaXN0O1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUoMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShtYXguVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSgwLjApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShtYXguVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLlN0cmluZykge1xuICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMudmFsdWUubWF4SXRlbTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShtYXguS2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlzdE9yU2luZ2xlSXRlbSwgc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIGlmICghbGlzdE9yU2luZ2xlSXRlbSAmJiAhc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0T3JTaW5nbGVJdGVtIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QobGlzdE9yU2luZ2xlSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlzdE9yU2luZ2xlSXRlbSBpbnN0YW5jZW9mIElua0xpc3RfMS5JbmtMaXN0SXRlbSAmJlxuICAgICAgICAgICAgdHlwZW9mIHNpbmdsZVZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KHtcbiAgICAgICAgICAgICAgICBLZXk6IGxpc3RPclNpbmdsZUl0ZW0sXG4gICAgICAgICAgICAgICAgVmFsdWU6IHNpbmdsZVZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIFJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZExpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2xkVmFsdWUsIExpc3RWYWx1ZSk7XG4gICAgICAgIGxldCBuZXdMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG5ld1ZhbHVlLCBMaXN0VmFsdWUpO1xuICAgICAgICBpZiAobmV3TGlzdCAmJiBuZXdMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuZXdMaXN0LnZhbHVlXCIpO1xuICAgICAgICBpZiAob2xkTGlzdCAmJiBvbGRMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvbGRMaXN0LnZhbHVlXCIpO1xuICAgICAgICAvLyBXaGVuIGFzc2lnbmluZyB0aGUgZW1wdHkgbGlzdCwgdHJ5IHRvIHJldGFpbiBhbnkgaW5pdGlhbCBvcmlnaW4gbmFtZXNcbiAgICAgICAgaWYgKG9sZExpc3QgJiYgbmV3TGlzdCAmJiBuZXdMaXN0LnZhbHVlLkNvdW50ID09IDApXG4gICAgICAgICAgICBuZXdMaXN0LnZhbHVlLlNldEluaXRpYWxPcmlnaW5OYW1lcyhvbGRMaXN0LnZhbHVlLm9yaWdpbk5hbWVzKTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RWYWx1ZSA9IExpc3RWYWx1ZTtcbnZhciBWYWx1ZVR5cGU7XG4oZnVuY3Rpb24gKFZhbHVlVHlwZSkge1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJJbnRcIl0gPSAwXSA9IFwiSW50XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkZsb2F0XCJdID0gMV0gPSBcIkZsb2F0XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkxpc3RcIl0gPSAyXSA9IFwiTGlzdFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkRpdmVydFRhcmdldFwiXSA9IDRdID0gXCJEaXZlcnRUYXJnZXRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiVmFyaWFibGVQb2ludGVyXCJdID0gNV0gPSBcIlZhcmlhYmxlUG9pbnRlclwiO1xufSkoVmFsdWVUeXBlID0gZXhwb3J0cy5WYWx1ZVR5cGUgfHwgKGV4cG9ydHMuVmFsdWVUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZUFzc2lnbm1lbnQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFZhcmlhYmxlQXNzaWdubWVudCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmFyaWFibGVOYW1lLCBpc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lID0gdmFyaWFibGVOYW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaXNOZXdEZWNsYXJhdGlvbiA9ICEhaXNOZXdEZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy5pc0dsb2JhbCA9IGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiVmFyQXNzaWduIHRvIFwiICsgdGhpcy52YXJpYWJsZU5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZUFzc2lnbm1lbnQgPSBWYXJpYWJsZUFzc2lnbm1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZUFzc2lnbm1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlUmVmZXJlbmNlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY2xhc3MgVmFyaWFibGVSZWZlcmVuY2UgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lckZvckNvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoRm9yQ291bnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuUmVzb2x2ZVBhdGgodGhpcy5wYXRoRm9yQ291bnQpLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IHBhdGhTdHJpbmdGb3JDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aEZvckNvdW50ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aEZvckNvdW50KTtcbiAgICB9XG4gICAgc2V0IHBhdGhTdHJpbmdGb3JDb3VudCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnBhdGhGb3JDb3VudCA9IG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidmFyKFwiICsgdGhpcy5uYW1lICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGF0aFN0ciA9IHRoaXMucGF0aFN0cmluZ0ZvckNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIFwicmVhZF9jb3VudChcIiArIHBhdGhTdHIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVSZWZlcmVuY2UgPSBWYXJpYWJsZVJlZmVyZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlUmVmZXJlbmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZXNTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBWYXJpYWJsZXNTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbFN0YWNrLCBsaXN0RGVmc09yaWdpbikge1xuICAgICAgICAvLyBUaGUgd2F5IHZhcmlhYmxlQ2hhbmdlZEV2ZW50IGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIE9yaWdpbmFsbHkgaXQgdXNlcyB0aGUgQyMgKz0gb3BlcmF0b3IgdG8gYWRkIGRlbGVnYXRlcywgYnV0IGluIGpzIHdlIG5lZWQgdG8gbWFpbnRhaW5cbiAgICAgICAgLy8gYW4gYWN0dWFsIGNvbGxlY3Rpb24gb2YgZGVsZWdhdGVzIChpZS4gY2FsbGJhY2tzKSB0byByZWdpc3RlciBhIG5ldyBvbmUsIHRoZXJlIGlzIGFcbiAgICAgICAgLy8gc3BlY2lhbCBPYnNlcnZlVmFyaWFibGVDaGFuZ2UgbWV0aG9kIGJlbG93LlxuICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMucGF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FsbFN0YWNrID0gY2FsbFN0YWNrO1xuICAgICAgICB0aGlzLl9saXN0RGVmc09yaWdpbiA9IGxpc3REZWZzT3JpZ2luO1xuICAgICAgICAvLyBpZiBlczYgcHJveGllcyBhcmUgYXZhaWxhYmxlLCB1c2UgdGhlbS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSBwcm94eSBpcyB1c2VkIHRvIGFsbG93IGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgZ2xvYmFsIHZhcmlhYmxlcy5cbiAgICAgICAgICAgIC8vIEl0IGZpcnN0IHRyaWVzIHRvIGFjY2VzcyB0aGUgb2JqZWN0cyBvd24gcHJvcGVydHksIGFuZCBpZiBub25lIGlzXG4gICAgICAgICAgICAvLyBmb3VuZCBpdCBkZWxlZ2F0ZXMgdGhlIGNhbGwgdG8gdGhlICQgbWV0aG9kLCBkZWZpbmVkIGJlbG93XG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0YXJnZXQgPyB0YXJnZXRbbmFtZV0gOiB0YXJnZXQuJChuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuJChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyByZXR1cm5pbmcgYSBmYWxzeSB2YWx1ZSBtYWtlIHRoZSB0cmFwIGZhaWxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gdGhyIHByb3h5IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgY29udGV4dC4gd2Ugc2hvdWxkIHdhcm4gdGhlXG4gICAgICAgICAgICAvLyBkZXYgYnV0IHdyaXR0aW5nIHRvIHRoZSBjb25zb2xlIGZlZWxzIGEgYml0IGludHJ1c2l2ZS5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRVM2IFByb3h5IG5vdCBhdmFpbGFibGUgLSBkaXJlY3QgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbCB2YXJpYWJsZXMgY2FuJ3Qgd29yaywgdXNlICQoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXJpYWJsZUNoYW5nZWRFdmVudCh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzO1xuICAgIH1cbiAgICBzZXQgYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YXJpYWJsZU5hbWUgb2YgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY3VycmVudFZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCh2YXJpYWJsZU5hbWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YWNrO1xuICAgIH1cbiAgICBzZXQgY2FsbFN0YWNrKGNhbGxTdGFjaykge1xuICAgICAgICB0aGlzLl9jYWxsU3RhY2sgPSBjYWxsU3RhY2s7XG4gICAgfVxuICAgIC8vIHRoZSBvcmlnaW5hbCBjb2RlIHVzZXMgYSBtYWdpYyBnZXR0ZXIgYW5kIHNldHRlciBmb3IgZ2xvYmFsIHZhcmlhYmxlcyxcbiAgICAvLyBhbGxvd2luZyB0aGluZ3MgbGlrZSB2YXJpYWJsZVN0YXRlWyd2YXJuYW1lXS4gVGhpcyBpcyBub3QgcXVpdGUgcG9zc2libGVcbiAgICAvLyBpbiBqcyB3aXRob3V0IGEgUHJveHksIHNvIGl0IGlzIHJlcGxhY2VkIHdpdGggdGhpcyAkIGZ1bmN0aW9uLlxuICAgICQodmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgdmFyQ29udGVudHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJDb250ZW50cyA9IHRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckNvbnRlbnRzLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbnRlbnRzLnJlc3VsdC52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJDb250ZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFyQ29udGVudHMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbnRlbnRzLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IGFzc2lnbiB0byBhIHZhcmlhYmxlIChcIiArXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiKSB0aGF0IGhhc24ndCBiZWVuIGRlY2xhcmVkIGluIHRoZSBzdG9yeVwiKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBWYWx1ZV8xLlZhbHVlLkNyZWF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBwYXNzIG51bGwgdG8gVmFyaWFibGVTdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gVmFyaWFibGVTdGF0ZTogXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXBwbHlQYXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5wYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbbmFtZWRWYXJLZXksIG5hbWVkVmFyVmFsdWVdIG9mIHRoaXMucGF0Y2guZ2xvYmFscykge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldChuYW1lZFZhcktleSwgbmFtZWRWYXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiB0aGlzLnBhdGNoLmNoYW5nZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSBudWxsO1xuICAgIH1cbiAgICBTZXRKc29uVG9rZW4oalRva2VuKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGxldCBbdmFyVmFsS2V5LCB2YXJWYWxWYWx1ZV0gb2YgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGV0IGxvYWRlZFRva2VuID0galRva2VuW3ZhclZhbEtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlZFRva2VuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuSW5rT2JqZWN0ID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub1J1bnRpbWVPYmplY3QobG9hZGVkVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbklua09iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRva2VuSW5rT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhclZhbEtleSwgdG9rZW5JbmtPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh2YXJWYWxLZXksIHZhclZhbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXlWYWxLZXksIGtleVZhbFZhbHVlXSBvZiB0aGlzLl9nbG9iYWxWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0ga2V5VmFsS2V5O1xuICAgICAgICAgICAgbGV0IHZhbCA9IGtleVZhbFZhbHVlO1xuICAgICAgICAgICAgaWYgKFZhcmlhYmxlc1N0YXRlLmRvbnRTYXZlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5SdW50aW1lT2JqZWN0c0VxdWFsKHZhbCwgZGVmYXVsdFZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWwpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgUnVudGltZU9iamVjdHNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmIChvYmoxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9iajFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iajIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoxLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgaWYgKGludFZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGludFZhbC52YWx1ZSA9PT0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2JqMiwgVmFsdWVfMS5JbnRWYWx1ZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsb2F0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuRmxvYXRWYWx1ZSk7XG4gICAgICAgIGlmIChmbG9hdFZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0VmFsLnZhbHVlID09PSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvYmoyLCBWYWx1ZV8xLkZsb2F0VmFsdWUpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwxID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdmFsMiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoyLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgaWYgKHZhbDEgIT09IG51bGwgJiYgdmFsMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFR5cGVBc3NlcnRpb25fMS5pc0VxdWF0YWJsZSh2YWwxLnZhbHVlT2JqZWN0KSAmJiBUeXBlQXNzZXJ0aW9uXzEuaXNFcXVhdGFibGUodmFsMi52YWx1ZU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMS52YWx1ZU9iamVjdC5FcXVhbHModmFsMi52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMS52YWx1ZU9iamVjdCA9PT0gdmFsMi52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYXN0Um91Z2hEZWZpbml0ZWx5RXF1YWxzOiBVbnN1cHBvcnRlZCBydW50aW1lIG9iamVjdCB0eXBlOiBcIiArXG4gICAgICAgICAgICBvYmoxLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH1cbiAgICBHZXRWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IHZhclZhbHVlIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICBsZXQgdmFyUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YXJWYWx1ZSwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgIGlmICh2YXJQb2ludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJWYWx1ZSA9IHRoaXMuVmFsdWVBdFZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyVmFsdWU7XG4gICAgfVxuICAgIFRyeUdldERlZmF1bHRWYXJpYWJsZVZhbHVlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHZhbC5leGlzdHMgPyB2YWwucmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSB8fFxuICAgICAgICAgICAgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSkpO1xuICAgIH1cbiAgICBHZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCkge1xuICAgICAgICBsZXQgdmFyVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IDAgfHwgY29udGV4dEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBsZXQgdmFyaWFibGVWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSB0aGlzLnBhdGNoLlRyeUdldEdsb2JhbChuYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlLnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBjb25kaXRpb25hbCBhc3NpZ25tZW50XG4gICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGVWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3REZWZzT3JpZ2luID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFyaWFibGVzU3RhdGUuX2xpc3REZWZzT3JpZ2luXCIpO1xuICAgICAgICAgICAgbGV0IGxpc3RJdGVtVmFsdWUgPSB0aGlzLl9saXN0RGVmc09yaWdpbi5GaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbVZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0SXRlbVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhclZhbHVlID0gdGhpcy5fY2FsbFN0YWNrLkdldFRlbXBvcmFyeVZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZhclZhbHVlO1xuICAgIH1cbiAgICBWYWx1ZUF0VmFyaWFibGVQb2ludGVyKHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuR2V0VmFyaWFibGVXaXRoTmFtZShwb2ludGVyLnZhcmlhYmxlTmFtZSwgcG9pbnRlci5jb250ZXh0SW5kZXgpO1xuICAgIH1cbiAgICBBc3NpZ24odmFyQXNzLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbmFtZSA9IHZhckFzcy52YXJpYWJsZU5hbWU7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRleHRJbmRleCA9IC0xO1xuICAgICAgICBsZXQgc2V0R2xvYmFsID0gZmFsc2U7XG4gICAgICAgIGlmICh2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgc2V0R2xvYmFsID0gdmFyQXNzLmlzR2xvYmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0R2xvYmFsID0gdGhpcy5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgLy8gdmFyIHZhclBvaW50ZXIgPSB2YWx1ZSBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YXJQb2ludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGx5UmVzb2x2ZWRWYXJpYWJsZVBvaW50ZXIgPSB0aGlzLlJlc29sdmVWYXJpYWJsZVBvaW50ZXIodmFyUG9pbnRlcik7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmdWxseVJlc29sdmVkVmFyaWFibGVQb2ludGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nUG9pbnRlciA9IG51bGw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmdQb2ludGVyID0gR2V0UmF3VmFyaWFibGVXaXRoTmFtZSAobmFtZSwgY29udGV4dEluZGV4KSBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1BvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCksIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BvaW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gZXhpc3RpbmdQb2ludGVyLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEluZGV4ID0gZXhpc3RpbmdQb2ludGVyLmNvbnRleHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsID0gY29udGV4dEluZGV4ID09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoZXhpc3RpbmdQb2ludGVyICE9IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRHbG9iYWwpIHtcbiAgICAgICAgICAgIHRoaXMuU2V0R2xvYmFsKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxTdGFjay5TZXRUZW1wb3JhcnlWYXJpYWJsZShuYW1lLCB2YWx1ZSwgdmFyQXNzLmlzTmV3RGVjbGFyYXRpb24sIGNvbnRleHRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU25hcHNob3REZWZhdWx0R2xvYmFscygpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyA9IG5ldyBNYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzKTtcbiAgICB9XG4gICAgUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9sZFZhbHVlLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGxldCBuZXdMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobmV3VmFsdWUsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKG9sZExpc3QudmFsdWUgJiYgbmV3TGlzdC52YWx1ZSAmJiBuZXdMaXN0LnZhbHVlLkNvdW50ID09IDApIHtcbiAgICAgICAgICAgIG5ld0xpc3QudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG9sZExpc3QudmFsdWUub3JpZ2luTmFtZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBhdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsIHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gdGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmICghb2xkVmFsdWUuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLCB2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFZhbHVlXzEuTGlzdFZhbHVlLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZS5yZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ2YXJpYWJsZU5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2guU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBOb3Qgc3VyZSAhPT0gaXMgZXF1aXZhbGVudCB0byAhdmFsdWUuRXF1YWxzKG9sZFZhbHVlKVxuICAgICAgICBpZiAodGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgb2xkVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBvbGRWYWx1ZS5yZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9ic1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRjaC5BZGRDaGFuZ2VkVmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVWYXJpYWJsZVBvaW50ZXIodmFyUG9pbnRlcikge1xuICAgICAgICBsZXQgY29udGV4dEluZGV4ID0gdmFyUG9pbnRlci5jb250ZXh0SW5kZXg7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLkdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgIGxldCB2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8gPSB0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUodmFyUG9pbnRlci52YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIC8vIHZhciBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXIgPSB2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8gYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgIGxldCBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWVPZlZhcmlhYmxlUG9pbnRlZFRvLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHZhclBvaW50ZXIudmFyaWFibGVOYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh2YXJOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodmFyTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFjay5jdXJyZW50RWxlbWVudEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNwZWNpZmljIHRvIHRoZSBqcyB2ZXJzaW9uIG9mIGluay4gSXQgYWxsb3dzIHRvIHJlZ2lzdGVyIGFcbiAgICAgKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB2YXJpYWJsZSBjaGFuZ2VzLiBUaGUgb3JpZ2luYWwgY29kZSB1c2VzXG4gICAgICogYHN0YXRlLnZhcmlhYmxlQ2hhbmdlZEV2ZW50ICs9IGNhbGxiYWNrYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBPYnNlcnZlVmFyaWFibGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlc1N0YXRlID0gVmFyaWFibGVzU3RhdGU7XG5WYXJpYWJsZXNTdGF0ZS5kb250U2F2ZURlZmF1bHRWYWx1ZXMgPSB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVzU3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvaWQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFZvaWQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xufVxuZXhwb3J0cy5Wb2lkID0gVm9pZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvaWQuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iLCIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiXHJcbmltcG9ydCB7VW5pdFRlc3R9IGZyb20gJy4vdW5pdHRlc3QvVW5pdFRlc3QnO1xyXG5pbXBvcnQgeyBKc01hbmFnZXIgLEdhbWVMYXVuY2gsIEZhaXJ5R1VJIH0gZnJvbSAnY3NoYXJwJztcclxuaW1wb3J0IHsgU2NlbmVEZWYgfSBmcm9tICcuL2ZyYW1ld29yay9zY2VuZS9TY2VuZURlZic7XHJcbmltcG9ydCB7IFMgfSBmcm9tICcuL2dsb2JhbC9HYW1lQ29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlcic7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSAnLi9kYXRhL3VpL2NvbW1vbic7XHJcbmltcG9ydCB7IFVJU2VydmVyTGlzdEl0ZW0gfSBmcm9tICcuL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJU2VydmVyTGlzdEl0ZW0nO1xyXG5cclxuXHJcblxyXG5jbGFzcyBHYW1lTWFpbntcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkFwcGxpY2F0aW9uUXVpdCA9ICgpID0+IHRoaXMub25BcHBsaWNhdGlvblF1aXQoKTtcclxuICAgICAgICBKc01hbmFnZXIuSW5zdGFuY2UuSnNPbkRpc3Bvc2UgPSAoKSA9PiB0aGlzLm9uRGlzcG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBzdGFydCgpIHtcclxuICAgICAgICBcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJHYW1lIHN0YXJ0IGluIEpTLi4uLlwiKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBTLlN0b3J5TWFuYWdlci5pbml0aWFsaXplKCk7XHJcblxyXG5cclxuICAgICAgICAgICAgLy/pooTliqDovb1leGNlbOaVsOaNrlxyXG4gICAgICAgICAgICAvL0V4Y2VsTWFuYWdlci5JbnN0YW5jZShFeGNlbE1hbmFnZXIpO1xyXG4gICAgICBcclxuICAgICAgICAgICAgLy/liqDovb3pgJrnlKhGYWlyeUdVSei1hOa6kFxyXG4gICAgICAgICAgICBhd2FpdCBTLlJlc01hbmFnZXIubG9hZEZhaXJ5R1VJUGFja2FnZShjb21tb25VSS5QYWNrYWdlTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAvL2RvIFVuaXQgVGVzdFxyXG4gICAgICAgICAgICBVbml0VGVzdC5kb1Rlc3QoKTtcclxuXHJcbiAgICAgICAgICAgIC8v6L+b5YWl55m75b2V5qih5Z2XXHJcbiAgICAgICAgICAgIGF3YWl0IFMuU2NlbmVNYW5hZ2VyLmxvYWRTY2VuZShTY2VuZURlZi5Mb2dpblNjZW5lKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL0pT5ZCv5Yqo5a6M5oiQ77yM6YCa55+lQyPlsYJcclxuICAgICAgICAgICAgR2FtZUxhdW5jaC5JbnN0YW5jZS5Kc0x1YW5jaEZpbmlzaCgpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGV4dEl0ZW0gPSAoKT0+e1xyXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSAgbmV3IFVJU2VydmVyTGlzdEl0ZW0oKTtcclxuICAgICAgICAgICAgICAgLy8gcG9vbC5wdXNoKGl0ZW0pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAvLyBsZXQgcG9vbCA9IFtdXHJcbiAgICAgICAgICAgIEZhaXJ5R1VJLlVJT2JqZWN0RmFjdG9yeS5TZXRQYWNrYWdlSXRlbUV4dGVuc2lvbihcInVpOi8vbDY0ZHVtazlmZWVnNTRcIixleHRJdGVtKVxyXG4gICAgICAgICAgICBcclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkFwcGxpY2F0aW9uUXVpdCgpOnZvaWQge1xyXG5cclxuICAgICAgICBTLkdhbWVPYmplY3RQb29sLmNsZWFudXAodHJ1ZSk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIkdhbWUgb25BcHBsaWNhdGlvblF1aXQgaW4gSlMuLi4uXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkRpc3Bvc2UoKTp2b2lkIHtcclxuICAgICAgICBcclxuICAgICAgICBMb2dnZXIubG9nKFwiR2FtZSBvbkRpc3Bvc2UgaW4gSlMuLi4uXCIpO1xyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbm5ldyBHYW1lTWFpbigpLnN0YXJ0KCk7XHJcblxyXG4iLCJpbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b25cIjtcclxuZXhwb3J0IGNsYXNzIFNraWxsQ29uZmlnVFJ7XHJcblx0IHB1YmxpYyBfaWQ6bnVtYmVyIDtcclxuXHQgcHVibGljIF9OYW1lOnN0cmluZyA7XHJcblx0IHB1YmxpYyBfRGVzY3JpcHRpb246c3RyaW5nIDtcclxuXHQgcHVibGljIF9Db29sVGltZTpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0Nvc3RTUDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0F0dGFja0Rpc3RhbmNlOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXR0YWNrQW5nbGU6bnVtYmVyIDtcclxuXHQgcHVibGljIF9BdHRhY2tUYXJnZXRUYWdzOkFycmF5PHN0cmluZz4gO1xyXG5cdCBwdWJsaWMgX0ltcGFjdFR5cGU6QXJyYXk8c3RyaW5nPiA7XHJcblx0IHB1YmxpYyBfTmV4dEJhdHRsZXJJZDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0F0a1JhdGlvOm51bWJlciA7XHJcblx0IHB1YmxpYyBfRHVyYXRpb25UaW1lOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXRrSW50ZXJ2YWw6bnVtYmVyIDtcclxuXHQgcHVibGljIF9Ta2lsbFByZWZhYjpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0FuaW1hdGlvbk5hbWU6c3RyaW5nIDtcclxuXHQgcHVibGljIF9IaXRGeFByZWZhYjpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0xldmVsOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXR0YWNrVHlwZTpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX1NlbGVjdG9yVHlwZTpudW1iZXIgO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihfaWQ6bnVtYmVyLCBfTmFtZTpzdHJpbmcsIF9EZXNjcmlwdGlvbjpzdHJpbmcsIF9Db29sVGltZTpudW1iZXIsIF9Db3N0U1A6bnVtYmVyLCBfQXR0YWNrRGlzdGFuY2U6bnVtYmVyLCBfQXR0YWNrQW5nbGU6bnVtYmVyLCBfQXR0YWNrVGFyZ2V0VGFnczpBcnJheTxzdHJpbmc+LCBfSW1wYWN0VHlwZTpBcnJheTxzdHJpbmc+LCBfTmV4dEJhdHRsZXJJZDpudW1iZXIsIF9BdGtSYXRpbzpudW1iZXIsIF9EdXJhdGlvblRpbWU6bnVtYmVyLCBfQXRrSW50ZXJ2YWw6bnVtYmVyLCBfU2tpbGxQcmVmYWI6c3RyaW5nLCBfQW5pbWF0aW9uTmFtZTpzdHJpbmcsIF9IaXRGeFByZWZhYjpzdHJpbmcsIF9MZXZlbDpudW1iZXIsIF9BdHRhY2tUeXBlOm51bWJlciwgX1NlbGVjdG9yVHlwZTpudW1iZXIpe1xyXG5cdFx0dGhpcy5faWQgPSBfaWQ7XHJcblx0XHR0aGlzLl9OYW1lID0gX05hbWU7XHJcblx0XHR0aGlzLl9EZXNjcmlwdGlvbiA9IF9EZXNjcmlwdGlvbjtcclxuXHRcdHRoaXMuX0Nvb2xUaW1lID0gX0Nvb2xUaW1lO1xyXG5cdFx0dGhpcy5fQ29zdFNQID0gX0Nvc3RTUDtcclxuXHRcdHRoaXMuX0F0dGFja0Rpc3RhbmNlID0gX0F0dGFja0Rpc3RhbmNlO1xyXG5cdFx0dGhpcy5fQXR0YWNrQW5nbGUgPSBfQXR0YWNrQW5nbGU7XHJcblx0XHR0aGlzLl9BdHRhY2tUYXJnZXRUYWdzID0gX0F0dGFja1RhcmdldFRhZ3M7XHJcblx0XHR0aGlzLl9JbXBhY3RUeXBlID0gX0ltcGFjdFR5cGU7XHJcblx0XHR0aGlzLl9OZXh0QmF0dGxlcklkID0gX05leHRCYXR0bGVySWQ7XHJcblx0XHR0aGlzLl9BdGtSYXRpbyA9IF9BdGtSYXRpbztcclxuXHRcdHRoaXMuX0R1cmF0aW9uVGltZSA9IF9EdXJhdGlvblRpbWU7XHJcblx0XHR0aGlzLl9BdGtJbnRlcnZhbCA9IF9BdGtJbnRlcnZhbDtcclxuXHRcdHRoaXMuX1NraWxsUHJlZmFiID0gX1NraWxsUHJlZmFiO1xyXG5cdFx0dGhpcy5fQW5pbWF0aW9uTmFtZSA9IF9BbmltYXRpb25OYW1lO1xyXG5cdFx0dGhpcy5fSGl0RnhQcmVmYWIgPSBfSGl0RnhQcmVmYWI7XHJcblx0XHR0aGlzLl9MZXZlbCA9IF9MZXZlbDtcclxuXHRcdHRoaXMuX0F0dGFja1R5cGUgPSBfQXR0YWNrVHlwZTtcclxuXHRcdHRoaXMuX1NlbGVjdG9yVHlwZSA9IF9TZWxlY3RvclR5cGU7XHJcblxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNraWxsQ29uZmlnVEIgZXh0ZW5kcyBTaW5nbGV0b248U2tpbGxDb25maWdUQj57IFxyXG5cdHB1YmxpYyB0cnM6TWFwPG51bWJlciwgU2tpbGxDb25maWdUUj4gPSBuZXcgTWFwPG51bWJlciwgU2tpbGxDb25maWdUUj4oKTtcclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMudHJzLnNldCgxMDAxLCBuZXcgU2tpbGxDb25maWdUUigxMDAxLCBcIumZjem+meWNgeWFq+aOjFwiLCBcIuW4puacieW8uuWKm+aUu+WHu+aKgOiDvVwiLCAxMCwgMTc4LCAxLCAzMCwgW1wiRW5lbXlcIl0sIFtcIkNvc3RTUFwiLCBcIkRhbWFnZVwiXSwgMCwgMiwgMiwgMSwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIFwic2tpbGwxXCIsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCAxLCAxLCAxKSk7XHJcblx0XHR0aGlzLnRycy5zZXQoMTAwMiwgbmV3IFNraWxsQ29uZmlnVFIoMTAwMiwgXCLmmrTpm6jmoqjoirFcIiwgXCLluKbmnInlvLrlipvmlLvlh7vmioDog71cIiwgMTAsIDE3OCwgMSwgMzAsIFtcIkVuZW15XCJdLCBbXCJDb3N0U1BcIiwgXCJEYW1hZ2VcIl0sIDAsIDIsIDIsIDEsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCBcInNraWxsMlwiLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgMSwgMSwgMSkpO1xyXG5cdFx0dGhpcy50cnMuc2V0KDEwMDMsIG5ldyBTa2lsbENvbmZpZ1RSKDEwMDMsIFwi5o6S5bGx5YCS5rW3XCIsIFwi5bim5pyJ5by65Yqb5pS75Ye75oqA6IO9XCIsIDEwLCAxNzgsIDEsIDMwLCBbXCJFbmVteVwiXSwgW1wiQ29zdFNQXCIsIFwiRGFtYWdlXCJdLCAwLCAyLCAyLCAxLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgXCJza2lsbDNcIiwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIDEsIDEsIDEpKTtcclxuXHRcdHRoaXMudHJzLnNldCgxMDA0LCBuZXcgU2tpbGxDb25maWdUUigxMDA0LCBcIuiRteiKseeCueeptOaJi1wiLCBcIuW4puacieW8uuWKm+aUu+WHu+aKgOiDvVwiLCAxMCwgMTc4LCAxLCAzMCwgW1wiRW5lbXlcIl0sIFtcIkNvc3RTUFwiLCBcIkRhbWFnZVwiXSwgMCwgMiwgMiwgMSwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIFwic2tpbGw0XCIsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCAxLCAxLCAxKSk7XHJcblx0IH1cclxufVxyXG5cclxuIiwiaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuL2dlbi9wYlwiO1xyXG5leHBvcnQgY2xhc3MgRGVjb2RlTXNne1xyXG5cdHB1YmxpYyBycGNJZDpudW1iZXI7XHJcblx0cHVibGljIG1zZ09iajphbnk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIE9wY29kZXtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMlJfTG9naW46bnVtYmVyID0gMTAwMDtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19SMkNfTG9naW46bnVtYmVyID0gMTAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdfTG9naW5HYXRlOm51bWJlciA9IDEwMDI7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfRzJDX0xvZ2luR2F0ZTpudW1iZXIgPSAxMDAzO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdTX1Rlc3Q6bnVtYmVyID0gMjAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19HUzJDX1Rlc3Q6bnVtYmVyID0gMjAwMjtcclxuXHJcblx0cHVibGljIHN0YXRpYyBtYXAgPSB7XHJcblx0XHQxMDAwIDoge1wiZGVjb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZW5jb2RlfSxcclxuXHRcdDEwMDEgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5lbmNvZGV9LFxyXG5cdFx0MTAwMiA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHX0xvZ2luR2F0ZS5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLkMyR19Mb2dpbkdhdGUuZW5jb2RlfSxcclxuXHRcdDEwMDMgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLkcyQ19Mb2dpbkdhdGUuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HMkNfTG9naW5HYXRlLmVuY29kZX0sXHJcblxyXG5cdFx0MjAwMSA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmVuY29kZX0sXHJcblx0XHQyMDAyIDoge1wiZGVjb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZW5jb2RlfVxyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGRlY29kZShvcGNvZGU6bnVtYmVyLCBtc2c6VWludDhBcnJheSk6RGVjb2RlTXNnIHtcclxuXHRcdGxldCBtc2dPYmogPSB0aGlzLm1hcFtvcGNvZGVdW1wiZGVjb2RlXCJdKG1zZyk7XHJcblx0XHRsZXQgZGVjb2RlTXNnID0gbmV3IERlY29kZU1zZygpO1xyXG5cdFx0ZGVjb2RlTXNnLnJwY0lkID0gbXNnT2JqLlJwY0lkO1xyXG5cdFx0ZGVjb2RlTXNnLm1zZ09iaiA9IG1zZ09iajtcclxuXHRcdHJldHVybiBkZWNvZGVNc2c7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZW5jb2RlKG9wY29kZTpudW1iZXIsIG1zZzpVaW50OEFycmF5KXtcclxuXHRcdGxldCBidWYgPSB0aGlzLm1hcFtvcGNvZGVdW1wiZW5jb2RlXCJdKG1zZykuZmluaXNoKCk7XHJcblx0XHRyZXR1cm4gYnVmXHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcbiIsIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XHJcblxyXG4vLyBDb21tb24gYWxpYXNlc1xyXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xyXG5cclxudmFyIExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcclxuJHByb3RvYnVmLnV0aWwuTG9uZyA9IExvbmc7XHJcbiRwcm90b2J1Zi5jb25maWd1cmUoKTtcclxuXHJcblxyXG4vLyBFeHBvcnRlZCByb290IG5hbWVzcGFjZVxyXG52YXIgJHJvb3QgPSAkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdIHx8ICgkcHJvdG9idWYucm9vdHNbXCJkZWZhdWx0XCJdID0ge30pO1xyXG5cclxuJHJvb3QubmljZV90cyA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE5hbWVzcGFjZSBuaWNlX3RzLlxyXG4gICAgICogQGV4cG9ydHMgbmljZV90c1xyXG4gICAgICogQG5hbWVzcGFjZVxyXG4gICAgICovXHJcbiAgICB2YXIgbmljZV90cyA9IHt9O1xyXG5cclxuICAgIG5pY2VfdHMuQzJSX0xvZ2luID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJSX0xvZ2luLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW0FjY291bnRdIEMyUl9Mb2dpbiBBY2NvdW50XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW1Bhc3N3b3JkXSBDMlJfTG9naW4gUGFzc3dvcmRcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDMlJfTG9naW4uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMlJfTG9naW4uXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQzJSX0xvZ2luKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyUl9Mb2dpbiBBY2NvdW50LlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gQWNjb3VudFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUuQWNjb3VudCA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyUl9Mb2dpbiBQYXNzd29yZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhc3N3b3JkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLnByb3RvdHlwZS5QYXNzd29yZCA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQzJSX0xvZ2luIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW4gaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMlJfTG9naW4ocHJvcGVydGllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyUl9Mb2dpbiBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJBY2NvdW50XCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAyID0qLzEwKS5zdHJpbmcobWVzc2FnZS5BY2NvdW50KTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBhc3N3b3JkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5QYXNzd29yZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyUl9Mb2dpbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyUl9Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJSX0xvZ2luKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFjY291bnQgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QYXNzd29yZCA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMlJfTG9naW4gbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFjY291bnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWNjb3VudFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BY2NvdW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBY2NvdW50OiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGFzc3dvcmRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuUGFzc3dvcmQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlBhc3N3b3JkOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5DMlJfTG9naW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbigpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkFjY291bnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWNjb3VudCA9IFN0cmluZyhvYmplY3QuQWNjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuUGFzc3dvcmQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGFzc3dvcmQgPSBTdHJpbmcob2JqZWN0LlBhc3N3b3JkKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJSX0xvZ2luIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyUl9Mb2dpbn0gbWVzc2FnZSBDMlJfTG9naW5cclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQWNjb3VudCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuUGFzc3dvcmQgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFjY291bnQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWNjb3VudFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BY2NvdW50ID0gbWVzc2FnZS5BY2NvdW50O1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QYXNzd29yZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQYXNzd29yZFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5QYXNzd29yZCA9IG1lc3NhZ2UuUGFzc3dvcmQ7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDMlJfTG9naW4gdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gQzJSX0xvZ2luO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLlIyQ19Mb2dpbiA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIFIyQ19Mb2dpbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtFcnJvcl0gUjJDX0xvZ2luIEVycm9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIFIyQ19Mb2dpbiBNZXNzYWdlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW0FkZHJlc3NdIFIyQ19Mb2dpbiBBZGRyZXNzXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbS2V5XSBSMkNfTG9naW4gS2V5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbR2F0ZUlkXSBSMkNfTG9naW4gR2F0ZUlkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUjJDX0xvZ2luLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgUjJDX0xvZ2luLlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElSMkNfTG9naW5cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIFIyQ19Mb2dpbihwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gRXJyb3IuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuRXJyb3IgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gTWVzc2FnZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gQWRkcmVzcy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEFkZHJlc3NcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkFkZHJlc3MgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gS2V5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBLZXlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLktleSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSMkNfTG9naW4gR2F0ZUlkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBHYXRlSWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkdhdGVJZCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFIyQ19Mb2dpbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luIGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUjJDX0xvZ2luKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBSMkNfTG9naW4gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5SMkNfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSVIyQ19Mb2dpbn0gbWVzc2FnZSBSMkNfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWRkcmVzcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLktleSk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiR2F0ZUlkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAzLCB3aXJlVHlwZSAwID0qLzI0KS5pbnQ2NChtZXNzYWdlLkdhdGVJZCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTEsIHdpcmVUeXBlIDAgPSovNzI4KS5pbnQzMihtZXNzYWdlLkVycm9yKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUjJDX0xvZ2luIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuUjJDX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW59IG1lc3NhZ2UgUjJDX0xvZ2luIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgUjJDX0xvZ2luIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5SMkNfTG9naW4oKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuUjJDX0xvZ2lufSBSMkNfTG9naW5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIFIyQ19Mb2dpbiBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4udmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5BZGRyZXNzKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBZGRyZXNzOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5KSAmJiAhKG1lc3NhZ2UuS2V5ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiS2V5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkKSAmJiAhKG1lc3NhZ2UuR2F0ZUlkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2F0ZUlkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5SMkNfTG9naW4pXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLlIyQ19Mb2dpbigpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkFkZHJlc3MgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWRkcmVzcyA9IFN0cmluZyhvYmplY3QuQWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuS2V5ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5LZXkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuS2V5KSkudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcGFyc2VJbnQob2JqZWN0LktleSwgMTApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBvYmplY3QuS2V5O1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LktleS5sb3cgPj4+IDAsIG9iamVjdC5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5HYXRlSWQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLkdhdGVJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5HYXRlSWQpKS51bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBwYXJzZUludChvYmplY3QuR2F0ZUlkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG9iamVjdC5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuR2F0ZUlkLmxvdyA+Pj4gMCwgb2JqZWN0LkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBSMkNfTG9naW4gbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiQWRkcmVzc1wiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gbWVzc2FnZS5BZGRyZXNzO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLktleSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuS2V5KSA6IG1lc3NhZ2UuS2V5O1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuS2V5KSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLktleS5sb3cgPj4+IDAsIG1lc3NhZ2UuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLktleTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5HYXRlSWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLkdhdGVJZCkgOiBtZXNzYWdlLkdhdGVJZDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLkdhdGVJZCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5HYXRlSWQubG93ID4+PiAwLCBtZXNzYWdlLkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5HYXRlSWQ7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gbWVzc2FnZS5FcnJvcjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBtZXNzYWdlLk1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBSMkNfTG9naW4gdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gUjJDX0xvZ2luO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLkMyR19Mb2dpbkdhdGUgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBDMkdfTG9naW5HYXRlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0tleV0gQzJHX0xvZ2luR2F0ZSBLZXlcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtHYXRlSWRdIEMyR19Mb2dpbkdhdGUgR2F0ZUlkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJHX0xvZ2luR2F0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyR19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDMkdfTG9naW5HYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyR19Mb2dpbkdhdGUgS2V5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBLZXlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuS2V5ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEMyR19Mb2dpbkdhdGUgR2F0ZUlkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBHYXRlSWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuR2F0ZUlkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgQzJHX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZSBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMkdfTG9naW5HYXRlKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJLZXlcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50NjQobWVzc2FnZS5LZXkpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50NjQobWVzc2FnZS5HYXRlSWQpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkpICYmICEobWVzc2FnZS5LZXkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmhpZ2gpKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJLZXk6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiR2F0ZUlkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQpICYmICEobWVzc2FnZS5HYXRlSWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmhpZ2gpKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJHYXRlSWQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdfTG9naW5HYXRlfSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LktleSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuS2V5ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LktleSkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IHBhcnNlSW50KG9iamVjdC5LZXksIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gb2JqZWN0LktleTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5LZXkubG93ID4+PiAwLCBvYmplY3QuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuR2F0ZUlkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5HYXRlSWQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuR2F0ZUlkKSkudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gcGFyc2VJbnQob2JqZWN0LkdhdGVJZCwgMTApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBvYmplY3QuR2F0ZUlkO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LkdhdGVJZC5sb3cgPj4+IDAsIG9iamVjdC5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gbWVzc2FnZSBDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5LZXkgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLktleSkgOiBtZXNzYWdlLktleTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLktleSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5LZXkubG93ID4+PiAwLCBtZXNzYWdlLktleS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5LZXk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuR2F0ZUlkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5HYXRlSWQpIDogbWVzc2FnZS5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5HYXRlSWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuR2F0ZUlkLmxvdyA+Pj4gMCwgbWVzc2FnZS5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuR2F0ZUlkO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHX0xvZ2luR2F0ZSB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEMyR19Mb2dpbkdhdGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZSA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEcyQ19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAaW50ZXJmYWNlIElHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBHMkNfTG9naW5HYXRlIEVycm9yXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW01lc3NhZ2VdIEcyQ19Mb2dpbkdhdGUgTWVzc2FnZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW1BsYXllcklkXSBHMkNfTG9naW5HYXRlIFBsYXllcklkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRzJDX0xvZ2luR2F0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEcyQ19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBHMkNfTG9naW5HYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgRXJyb3IuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5FcnJvciA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgTWVzc2FnZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5wcm90b3R5cGUuTWVzc2FnZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgUGxheWVySWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IFBsYXllcklkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLlBsYXllcklkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHMkNfTG9naW5HYXRlKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHMkNfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGV9IG1lc3NhZ2UgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIlBsYXllcklkXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuUGxheWVySWQpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkyLCB3aXJlVHlwZSAyID0qLzczOCkuc3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HMkNfTG9naW5HYXRlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IEcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HMkNfTG9naW5HYXRlKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IHJlYWRlci5pbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MjpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IHJlYWRlci5pbnQ2NCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuRXJyb3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkVycm9yOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5NZXNzYWdlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJNZXNzYWdlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGxheWVySWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLlBsYXllcklkKSAmJiAhKG1lc3NhZ2UuUGxheWVySWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuUGxheWVySWQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5QbGF5ZXJJZC5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiUGxheWVySWQ6IGludGVnZXJ8TG9uZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LlBsYXllcklkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5QbGF5ZXJJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5QbGF5ZXJJZCkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSBwYXJzZUludChvYmplY3QuUGxheWVySWQsIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG9iamVjdC5QbGF5ZXJJZDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuUGxheWVySWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuUGxheWVySWQubG93ID4+PiAwLCBvYmplY3QuUGxheWVySWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gbWVzc2FnZSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gbG9uZy50b1N0cmluZygpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbG9uZy50b051bWJlcigpIDogbG9uZztcclxuICAgICAgICAgICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGxheWVySWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGxheWVySWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuUGxheWVySWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuUGxheWVySWQpIDogbWVzc2FnZS5QbGF5ZXJJZDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuUGxheWVySWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuUGxheWVySWQubG93ID4+PiAwLCBtZXNzYWdlLlBsYXllcklkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLlBsYXllcklkO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IG1lc3NhZ2UuRXJyb3I7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gbWVzc2FnZS5NZXNzYWdlO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgRzJDX0xvZ2luR2F0ZSB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEcyQ19Mb2dpbkdhdGU7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG5pY2VfdHMuQzJHU19UZXN0ID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJHU19UZXN0XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3Rlc3RJRF0gQzJHU19UZXN0IHRlc3RJRFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt0ZXN0TmFtZV0gQzJHU19UZXN0IHRlc3ROYW1lXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQzJHU19UZXN0LlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMkdTX1Rlc3RcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEMyR1NfVGVzdChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdTX1Rlc3QgdGVzdElELlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdGVzdElEXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LnByb3RvdHlwZS50ZXN0SUQgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdTX1Rlc3QgdGVzdE5hbWUuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0TmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudGVzdE5hbWUgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyR1NfVGVzdCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0IGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJHU19UZXN0KHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdTX1Rlc3QgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMkdTX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZXN0SURcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS50ZXN0SUQpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0TmFtZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVzdE5hbWVcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDIgPSovMTgpLnN0cmluZyhtZXNzYWdlLnRlc3ROYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHU19UZXN0IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHU19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdElEID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0TmFtZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0SURcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLnRlc3RJRCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdElEOiBpbnRlZ2VyIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3ROYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3ROYW1lXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRlc3ROYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0TmFtZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC50ZXN0SUQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdElEID0gb2JqZWN0LnRlc3RJRCB8IDA7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdE5hbWUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdE5hbWUgPSBTdHJpbmcob2JqZWN0LnRlc3ROYW1lKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHU19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3RcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdElEID0gMDtcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0TmFtZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RJRFwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0SUQgPSBtZXNzYWdlLnRlc3RJRDtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdE5hbWUgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdE5hbWVcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdE5hbWUgPSBtZXNzYWdlLnRlc3ROYW1lO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJHU19UZXN0IHRvIEpTT04uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEMyR1NfVGVzdDtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgbmljZV90cy5HUzJDX1Rlc3QgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAaW50ZXJmYWNlIElHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbRXJyb3JdIEdTMkNfVGVzdCBFcnJvclxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNZXNzYWdlXSBHUzJDX1Rlc3QgTWVzc2FnZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFt0ZXN0UmVzcG9uc2VdIEdTMkNfVGVzdCB0ZXN0UmVzcG9uc2VcclxuICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHUzJDX1Rlc3QuXHJcbiAgICAgICAgICogQGltcGxlbWVudHMgSUdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gR1MyQ19UZXN0KHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllc1trZXlzW2ldXSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCBFcnJvci5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IEVycm9yXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS5FcnJvciA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCBNZXNzYWdlLlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gTWVzc2FnZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5wcm90b3R5cGUuTWVzc2FnZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdTMkNfVGVzdCB0ZXN0UmVzcG9uc2UuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXN0UmVzcG9uc2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLnRlc3RSZXNwb25zZSA9IFwiXCI7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgR1MyQ19UZXN0IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0PX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3QgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHUzJDX1Rlc3QocHJvcGVydGllcyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEdTMkNfVGVzdCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkdTMkNfVGVzdC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JR1MyQ19UZXN0fSBtZXNzYWdlIEdTMkNfVGVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0UmVzcG9uc2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3RSZXNwb25zZVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5MSwgd2lyZVR5cGUgMCA9Ki83MjgpLmludDMyKG1lc3NhZ2UuRXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5Miwgd2lyZVR5cGUgMiA9Ki83MzgpLnN0cmluZyhtZXNzYWdlLk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHUzJDX1Rlc3QgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HUzJDX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSByZWFkZXIuaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgOTI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdFJlc3BvbnNlID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIEdTMkNfVGVzdCBtZXNzYWdlLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB2ZXJpZnlcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RSZXNwb25zZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0UmVzcG9uc2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0UmVzcG9uc2U6IHN0cmluZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuR1MyQ19UZXN0fSBHUzJDX1Rlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuR1MyQ19UZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuRXJyb3IgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSBvYmplY3QuRXJyb3IgfCAwO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0Lk1lc3NhZ2UgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IFN0cmluZyhvYmplY3QuTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdFJlc3BvbnNlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RSZXNwb25zZSA9IFN0cmluZyhvYmplY3QudGVzdFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR1MyQ19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdFJlc3BvbnNlID0gXCJcIjtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdFJlc3BvbnNlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RSZXNwb25zZVwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0UmVzcG9uc2UgPSBtZXNzYWdlLnRlc3RSZXNwb25zZTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSBtZXNzYWdlLkVycm9yO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IG1lc3NhZ2UuTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEdTMkNfVGVzdCB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBHUzJDX1Rlc3Q7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBuaWNlX3RzO1xyXG59KSgpO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSAkcm9vdDtcclxuIiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIGNvbWJhdFVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImNvbWJhdFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiY29tYmF0X2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUl0ZXN0OnN0cmluZyA9IFwidGVzdFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlDYXJkOnN0cmluZyA9IFwiQ2FyZFwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlDb21iYXRQYWdlOnN0cmluZyA9IFwiQ29tYmF0UGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlSb29tOnN0cmluZyA9IFwiUm9vbVwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBjb21tb25VSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJjb21tb25cIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImNvbW1vbl9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJTG9hZGluZ1BhZ2U6c3RyaW5nID0gXCJMb2FkaW5nUGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlVSUd1aWRlV2luOnN0cmluZyA9IFwiVUlHdWlkZVdpblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlVSU5vdGljZVdpbjpzdHJpbmcgPSBcIlVJTm90aWNlV2luXCI7XG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cclxuXHJcbmV4cG9ydCBjbGFzcyBob21lVUlcclxue1xyXG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImhvbWVcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiaG9tZV9mdWkuYnl0ZXNcIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgVUlIb21lUGFnZTpzdHJpbmcgPSBcIkhvbWVQYWdlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJTGV2ZWxQYWdlOnN0cmluZyA9IFwiTGV2ZWxQYWdlXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJU2hvcFBhZ2U6c3RyaW5nID0gXCJTaG9wUGFnZVwiO1xyXG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIGxvZ2luVUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwibG9naW5cIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImxvZ2luX2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlMb2dpblBhZ2U6c3RyaW5nID0gXCJMb2dpblBhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJU2VsU2VydmVyV2luOnN0cmluZyA9IFwiU2VsU2VydmVyV2luXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUFyZWFJdGVtOnN0cmluZyA9IFwiQXJlYUl0ZW1cIjtcbn0iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3Mgc3RvcnlVSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJzdG9yeVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwic3RvcnlfZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVN0b3J5V2luOnN0cmluZyA9IFwiU3RvcnlXaW5cIjtcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSAnLi9SZXNNYW5hZ2VyJztcclxuaW1wb3J0IHsgVW5pdHlFbmdpbmUgfSBmcm9tICdjc2hhcnAnO1xyXG5cclxuXHJcblxyXG4vLyAtLSBHYW1lT2JqZWN057yT5a2Y5rGgXHJcbi8vIC0tIOazqOaEj++8mlxyXG4vLyAtLSAx44CB5omA5pyJ6ZyA6KaB6aKE6K6+6YO95LuO6L+Z6YeM5Yqg6L2977yM5LiN6KaB55u05o6l5YiwUmVzb3VyY2VzTWFuYWdlcuWOu+WKoOi9ve+8jOeUsei/memHjOe7n+S4gOWBmue8k+WtmOeuoeeQhlxyXG4vLyAtLSAy44CB57yT5a2Y5YiG5Li65Lik6YOo5YiG77ya5LuO6LWE5rqQ5bGC5Yqg6L2955qE5Y6f5aeLR2FtZU9iamVjdChBc3NldCnvvIzku45HYW1lT2JqZWN05a6e5L6L5YyW5Ye65p2l55qE5aSa5LiqSW5zdFxyXG5leHBvcnQgY2xhc3MgR2FtZU9iamVjdFBvb2wgZXh0ZW5kcyBTaW5nbGV0b248R2FtZU9iamVjdFBvb2w+e1xyXG5cclxuICAgIHByaXZhdGUgX19jYWNoZVRyYW5zUm9vdCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9fZ29Qb29sID0gbmV3IE1hcCgpO1xyXG4gICAgcHJpdmF0ZSBfX2luc3RDYWNoZTpNYXA8c3RyaW5nLEFycmF5PGFueT4+ID0gbmV3IE1hcDxzdHJpbmcsQXJyYXk8YW55Pj4oKTtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBsZXQgZ28gPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0LkZpbmQoXCJHYW1lT2JqZWN0Q2FjaGVSb290XCIpO1xyXG5cclxuICAgICAgICBpZihnbyA9PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBnbyA9IG5ldyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0KFwiR2FtZU9iamVjdENhY2hlUm9vdFwiKTtcclxuICAgICAgICAgICAgVW5pdHlFbmdpbmUuT2JqZWN0LkRvbnREZXN0cm95T25Mb2FkKGdvKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX19jYWNoZVRyYW5zUm9vdCA9IGdvLnRyYW5zZm9ybTtcclxuICAgIH1cclxuXHJcbiAgICAvLy0tIOajgOa1i+aYr+WQpuW3sue7j+iiq+e8k+WtmFxyXG4gICAgcHVibGljIGNoZWNrSGFzQ2FjaGVkKHBhdGg6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8YW55PiA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKGNhY2hlZEluc3QgIT0gdW5kZWZpbmVkICYmIGNhY2hlZEluc3QubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHBvb2xlZEdvID0gdGhpcy5fX2dvUG9vbC5nZXQocGF0aCk7XHJcbiAgICAgICAgcmV0dXJuIHBvb2xlZEdvICE9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDnvJPlrZjlubblrp7kvovljJZHYW1lT2JqZWN0XHJcbiAgICBwdWJsaWMgY2FjaGVBbmRJbnN0R2FtZU9iamVjdChwYXRoOnN0cmluZywgZ286YW55LCBpbnN0X2NvdW50Om51bWJlciA9IDEpe1xyXG5cclxuICAgICAgICB0aGlzLl9fZ29Qb29sLnNldChwYXRoLCBnbyk7XHJcbiAgICAgICAgaWYoaW5zdF9jb3VudCA+IDApe1xyXG5cclxuICAgICAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8YW55PiA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk6bnVtYmVyID0wOyBpIDwgaW5zdF9jb3VudDsgaSsrKXtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5zdCA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuSW5zdGFudGlhdGUoZ28pIGFzIFVuaXR5RW5naW5lLkdhbWVPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICBpbnN0LnRyYW5zZm9ybS5TZXRQYXJlbnQodGhpcy5fX2NhY2hlVHJhbnNSb290KTtcclxuICAgICAgICAgICAgICAgIGluc3QuU2V0QWN0aXZlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZWRJbnN0LnB1c2goaW5zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLSDlsJ3or5Xku47nvJPlrZjkuK3ojrflj5ZcclxuICAgIHB1YmxpYyB0cnlHZXRGcm9tQ2FjaGUocGF0aDpzdHJpbmcpOmFueXtcclxuXHJcbiAgICAgICAgaWYoIXRoaXMuY2hlY2tIYXNDYWNoZWQocGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgY2FjaGVkSW5zdDpBcnJheTxvYmplY3Q+ICA9IHRoaXMuX19pbnN0Q2FjaGUuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKGNhY2hlZEluc3QgIT0gdW5kZWZpbmVkICYmIGNhY2hlZEluc3QubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IGluc3QgPSBjYWNoZWRJbnN0LnBvcCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb29sZWRHbyA9IHRoaXMuX19nb1Bvb2wuZ2V0KHBhdGgpO1xyXG4gICAgICAgIGlmKHBvb2xlZEdvICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGxldCBpbnN0ID0gVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5JbnN0YW50aWF0ZShwb29sZWRHbyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy/pooTliqDovb3vvJrlj6/mj5DkvpvliJ3lp4vlrp7kvovljJbkuKrmlbBcclxuICAgIHB1YmxpYyBhc3luYyBwcmVMb2FkR2FtZU9iamVjdEFzeW5jKHBhdGg6c3RyaW5nLCBpbnN0X2NvdW50Om51bWJlciwgY2FsbGJhY2s6RnVuY3Rpb24sLi4ucGFyYW1zKXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5jaGVja0hhc0NhY2hlZChwYXRoKSl7XHJcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGdvID0gYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkUHJlZmFiKHBhdGgpO1xyXG4gICAgICAgIGlmKGdvIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlQW5kSW5zdEdhbWVPYmplY3QocGF0aCwgZ28saW5zdF9jb3VudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihjYWxsYmFjayE9bnVsbCl7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOW8guatpeiOt+WPlu+8muW/heimgeaXtuWKoOi9vVxyXG4gICAgcHVibGljIGFzeW5jIGdldEdhbWVPYmplY3RBc3luYyhwYXRoOnN0cmluZywgY2FsbGJhY2s6RnVuY3Rpb24sLi4ucGFyYW1zKXtcclxuXHJcbiAgICAgICAgbGV0IGluc3Q6YW55ID0gdGhpcy50cnlHZXRGcm9tQ2FjaGUocGF0aCk7XHJcbiAgICAgICAgaWYoaW5zdCA9PW51bGwpe1xyXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZUxvYWRHYW1lT2JqZWN0QXN5bmMocGF0aCwgMSwgY2FsbGJhY2ssIHBhcmFtcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpbnN0ID0gdGhpcy50cnlHZXRGcm9tQ2FjaGUocGF0aCk7XHJcbiAgICAgICAgaW5zdC5TZXRBY3RpdmUodHJ1ZSk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLy0tIOWbnuaUtlxyXG4gICAgcHVibGljIHJlY3ljbGVHYW1lT2JqZWN0KHBhdGg6c3RyaW5nLCBpbnN0OmFueSl7XHJcblxyXG4gICAgICAgIGluc3QudHJhbnNmb3JtLlNldFBhcmVudCh0aGlzLl9fY2FjaGVUcmFuc1Jvb3QpO1xyXG4gICAgICAgIGluc3QuU2V0QWN0aXZlKGZhbHNlKTtcclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3QgPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKSB8fCBuZXcgQXJyYXkoKTtcclxuICAgICAgICBjYWNoZWRJbnN0LnB1c2goaW5zdCk7XHJcblxyXG4gICAgICAgIHRoaXMuX19pbnN0Q2FjaGUuc2V0KHBhdGgsIGNhY2hlZEluc3QpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDmuIXnkIbnvJPlrZhcclxuICAgIHB1YmxpYyBjbGVhbnVwKGluY2x1ZGVQb29sZWRHbzpib29sZWFuID0gZmFsc2Upe1xyXG5cclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLmZvckVhY2goKHZhbHVlcywga2V5KT0+e1xyXG5cclxuICAgICAgICAgICAgZm9yKGxldCBpbnN0IG9mIHZhbHVlcyl7XHJcbiAgICAgICAgICAgICAgICBpZihpbnN0ICE9IG51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIFVuaXR5RW5naW5lLkdhbWVPYmplY3QuRGVzdHJveShpbnN0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19pbnN0Q2FjaGUuY2xlYXIoKTsgXHJcblxyXG4gICAgICAgIGlmKGluY2x1ZGVQb29sZWRHbyl7XHJcbiAgICAgICAgICAgIHRoaXMuX19nb1Bvb2wuZm9yRWFjaCgoZ28sIGtleSk9PntcclxuXHJcbiAgICAgICAgICAgICAgICBpZihnbyAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLnJlbGVhc2VBZGRyZXNzR08oZ28pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX19nb1Bvb2wuY2xlYXIoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJcclxuXHJcbmV4cG9ydCBjbGFzcyBNZXNPYmp7XHJcbiAgICBwdWJsaWMgbGlzdGVuZXJzOkFycmF5PEZ1bmN0aW9uPjtcclxuICAgIHB1YmxpYyBvYmo6YW55O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE1lc3NlbmdlcntcclxuXHJcbiAgICBwcml2YXRlIGxpc3RlbmVyTWFwID0gbmV3IE1hcDxudW1iZXIsTWVzT2JqPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihlX3R5cGU6bnVtYmVyLCBlX29iajphbnksIGVfbGlzdG5lcjpGdW5jdGlvbik6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZihtc2dPYmopID09IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgICBtc2dPYmogPSBuZXcgTWVzT2JqKCk7XHJcbiAgICAgICAgICAgIG1zZ09iai5vYmogPSBlX29iajtcclxuICAgICAgICAgICAgbXNnT2JqLmxpc3RlbmVycyA9IG5ldyBBcnJheTxGdW5jdGlvbj4oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXNnT2JqLmxpc3RlbmVycy5wdXNoKGVfbGlzdG5lcik7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuc2V0KGVfdHlwZSwgbXNnT2JqKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0TGlzdGVuZXIoZV90eXBlOm51bWJlcik6TWVzT2Jqe1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBicm9hZGNhc3QoZV90eXBlOm51bWJlciwgLi4ucGFyYW1zOmFueVtdKSA6IHZvaWQge1xyXG5cclxuICAgICAgICBsZXQgbXNnT2JqID0gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0eXBlb2YobXNnT2JqKSAhPSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgZm9yKGxldCBsIG9mIG1zZ09iai5saXN0ZW5lcnMpe1xyXG4gICAgICAgICAgICAgICBsLmFwcGx5KG1zZ09iai5vYmosIHBhcmFtcyk7XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlUeXBlKGVfdHlwZTpudW1iZXIpIDp2b2lkIHtcclxuXHJcbiAgICAgICAgdGhpcy5saXN0ZW5lck1hcC5kZWxldGUoZV90eXBlKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKGVfdHlwZTpudW1iZXIsIGVfbGlzdGVuZXI6RnVuY3Rpb24gKTp2b2lke1xyXG5cclxuICAgICAgICBsZXQgbXNnT2JqID0gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mKG1zZ09iaikgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IGk6bnVtYmVyID0wOyBpPCBtc2dPYmoubGlzdGVuZXJzLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgICAgIGlmKG1zZ09iai5saXN0ZW5lcnNbaV0gPT0gZV9saXN0ZW5lcil7XHJcbiAgICAgICAgICAgICAgICAgICAgbXNnT2JqLmxpc3RlbmVycy5zcGxpY2UoaSwxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXJ1cCgpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuY2xlYXIoKTtcclxuICAgIH1cclxuXHJcbn0iLCJcclxuXHJcblxyXG4vLyBGYWlyeUdVSSDlhYPku7Yg57uR5a6a5ZmoXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5kZXIobmFtZTpzdHJpbmcpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldDphbnksIGtleTpzdHJpbmcgfCBzeW1ib2wpe1xyXG4gICAgICAgIHRhcmdldFtcImJpbmRlcnNcIl0gPSB0YXJnZXRbXCJiaW5kZXJzXCJdIHx8IHt9O1xyXG4gICAgICAgIHRhcmdldFtcImJpbmRlcnNcIl1ba2V5XSA9IG5hbWU7XHJcbiAgICB9XHJcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyAkcHJvbWlzZSB9IGZyb20gJ3B1ZXJ0cyc7XHJcbmltcG9ydCB7TmljZVRTLCBVbml0eUVuZ2luZX0gZnJvbSAnY3NoYXJwJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyL0xvZ2dlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVzTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZXNNYW5hZ2VyPntcclxuXHJcbiAgICBwcml2YXRlIF9wa2dNYXA6TWFwPHN0cmluZyxudW1iZXI+ID0gbmV3IE1hcDxzdHJpbmcsbnVtYmVyPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkRmFpcnlHVUlQYWNrYWdlKHBhY2thZ2VOYW1lOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGtnTWFwLmdldChwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgICAgIGlmKGNvdW50ID09IG51bGwgfHwgY291bnQgPCAxKXtcclxuICAgICAgICAgICAgICAgIC8v5rKh5pyJ57yT5a2Y77yM5Yqg6L29XHJcbiAgICAgICAgICAgICAgICBsZXQgYWRkcmVzcyA9IHBhY2thZ2VOYW1lK1wiX2Z1aS5ieXRlc1wiO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRGYWlyeUdVSVBhY2thZ2UoYWRkcmVzcyxwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGtnTWFwLnNldChwYWNrYWdlTmFtZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5zZXQocGFja2FnZU5hbWUsIGNvdW50KzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBMb2FkIGZhaXJ5R1VJIDoke3BhY2thZ2VOYW1lfSA6ICR7ZXh9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyByZWxlYXNlRmFpcnlHVUlQYWNrYWdlKHBhY2thZ2VOYW1lKXtcclxuXHJcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGtnTWFwLmdldChwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgaWYoY291bnQhPW51bGwgJiYgY291bnQ+MSl7XHJcbiAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5zZXQocGFja2FnZU5hbWUsIGNvdW50LTEpO1xyXG4gICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhgcmVsZWFzZSBmYWd1aSBwYWNrYWdlOiR7cGFja2FnZU5hbWV9YCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5kZWxldGUocGFja2FnZU5hbWUpO1xyXG4gICAgICAgICAgICBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlJlbGVhc2VGR1VJUGFja2FnZShwYWNrYWdlTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTY2VuZShzY2VuZU5hbWU6c3RyaW5nLCBtb2RlID0gVW5pdHlFbmdpbmUuU2NlbmVNYW5hZ2VtZW50LkxvYWRTY2VuZU1vZGUuU2luZ2xlKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRTY2VuZShzY2VuZU5hbWUsIG1vZGUsKHByb2dyZXNzOk51bWJlcik9PntcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJsb2FkIHNjZW5lOiBcIitwcm9ncmVzcylcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgc2Nlbkluc3RhbmNlID0gYXdhaXQgJHByb21pc2UodGFzaylcclxuICAgICAgICAgICAgcmV0dXJuIHNjZW5JbnN0YW5jZVxyXG5cclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBMb2FkIFNjZW5lIDoke3NjZW5lTmFtZX0gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIHVubG9hZFNjZW5lKHNjZW5lSW5zdGFuY2U6VW5pdHlFbmdpbmUuUmVzb3VyY2VNYW5hZ2VtZW50LlJlc291cmNlUHJvdmlkZXJzLlNjZW5lSW5zdGFuY2Upe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2s9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuVW5sb2FkU2NlbmUoc2NlbmVJbnN0YW5jZSlcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBVbmxvYWQgc2NlbmUgIDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1bmxvYWRTY2VuZUJ5TmFtZShzY2VuZU5hbWU6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgTmljZVRTLlJlc291cmNlTWFuYWdlci5VbmxvYWRTY2VuZUJ5TmFtZShzY2VuZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRQcmVmYWIoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRQcmVmYWIoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBwcmVmYWIgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRUZXh0QXNzZXQoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkVGV4dEFzc2V0KGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCB0ZXh0YXNzZXQgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGFzeW5jIGxvYWRUZXh0Qnl0ZXMoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkVGV4dEJ5dGVzKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgYnl0ZXMgPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZFRleHRCeXRlcyA6JHthZGRyZXNzfSA6ICR7ZXh9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFNwcml0ZShhZGRyZXNzOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRTcHJpdGUoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBzcHJpdGUgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZWxlYXNlQWRkcmVzc0dPKGdvOmFueSl7XHJcblxyXG4gICAgICAgIE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuUmVsZWFzZUFkZHJlc3NHTyhnbyk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIFxyXG59IiwiXHJcblxyXG5leHBvcnQgY2xhc3MgU2luZ2xldG9uPFQ+e1xyXG5cclxuICAgIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOmFueSA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBJbnN0YW5jZTxUPiggYzogeyBuZXcoKTogVCB9ICkgOiBUe1xyXG5cclxuICAgICAgICBpZih0aGlzLmluc3RhbmNlID09IG51bGwpe1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IGMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxufSIsImV4cG9ydCBjbGFzcyBBcnJheU1hcDxLLCBWPlxue1xuICAgIHByaXZhdGUgX2FycjpBcnJheTxWPiA9IG5ldyBBcnJheTxWPigpO1xuICAgIHByaXZhdGUgX21hcDpNYXA8SyxWPiA9IG5ldyBNYXA8SyxWPigpO1xuICAgIHB1YmxpYyBhZGQoa2V5OkssdmFsdWU6Vik6VlxuICAgIHtcbiAgICAgICAgdGhpcy5fbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fYXJyLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHVibGljIGdldChrZXk6Syk6VlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlKGtleTpLKTpWXG4gICAge1xuICAgICAgICB2YXIgb2JqPXRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYoIW9iailyZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGluZGV4PXRoaXMuX2Fyci5pbmRleE9mKG9iaik7XG4gICAgICAgIHRoaXMuX2Fyci5zcGxpY2UoaW5kZXgsMSk7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDov5Tlm57mlrDnmoTmlbDnu4Tlrp7kvotcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0QXJyKCk6QXJyYXk8Vj5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcnI7XG4gICAgfVxuXG4gICAgcHVibGljIGRpc3Bvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fYXJyLmxlbmd0aD0wO1xuICAgICAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQXJyYXlNYXAgfSBmcm9tIFwiLi4vY29yZS9BcnJheU1hcFwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tIFwiLi9Db21wb25lbnRcIjtcclxuXHJcbnR5cGUgQ2xhc3M8VD4gPSBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBUO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEFFbnRpdHl7XHJcbiAgICBwdWJsaWMgdXVpZDpudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSBldmVudHNNYXA6TWFwPHN0cmluZyxBcnJheTxGdW5jdGlvbj4+ID0gbmV3IE1hcDxzdHJpbmcsQXJyYXk8RnVuY3Rpb24+PigpO1xyXG4gICAgcHJpdmF0ZSBjb21wb25lbnRzOk1hcDxzdHJpbmcsQ29tcG9uZW50PiA9IG5ldyBNYXA8c3RyaW5nLENvbXBvbmVudD4oKTtcclxuXHJcbiAgICBwdWJsaWMgcGFyZW50OkFFbnRpdHkgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfY2hpbGRyZW46QXJyYXlNYXA8bnVtYmVyLEFFbnRpdHk+ID0gbmV3IEFycmF5TWFwPG51bWJlciwgQUVudGl0eT4oKTtcclxuICAgIHByaXZhdGUgX3R5cGVDaGlsZHJlbjpNYXA8c3RyaW5nLCBBcnJheTxBRW50aXR5Pj4gPSBuZXcgTWFwPHN0cmluZywgQXJyYXk8QUVudGl0eT4+KCk7XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQXdha2UoaW5pdERhdGE6YW55KVxyXG5cclxuXHJcbiAgICBwdWJsaWMgYWRkQ2hpbGQ8VD4oY2hpbGQ6QUVudGl0eSxjOiB7bmV3KCk6VDt9KXtcclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLmFkZChjaGlsZC51dWlkLCBjaGlsZCk7XHJcblxyXG4gICAgICAgIGxldCBjaGlsZHJlbkFyciA9IHRoaXMuX3R5cGVDaGlsZHJlbi5nZXQoYy5uYW1lKTtcclxuICAgICAgICBpZihjaGlsZHJlbkFyciA9PSBudWxsKXtcclxuICAgICAgICAgICAgY2hpbGRyZW5BcnIgPSBuZXcgQXJyYXk8QUVudGl0eT4oKTtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZUNoaWxkcmVuLnNldChjLm5hbWUsIGNoaWxkcmVuQXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hpbGRyZW5BcnIucHVzaChjaGlsZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHJlbW92ZUNoaWxkKGNoaWxkOkFFbnRpdHkpe1xyXG4gICAgICAgIGxldCBlbnRpdHkgPSB0aGlzLl9jaGlsZHJlbi5yZW1vdmUoY2hpbGQudXVpZCk7XHJcbiAgICAgICAgZW50aXR5LmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRyZW4oKTpBcnJheTxBRW50aXR5PntcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW4uZ2V0QXJyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENoaWxkQnlVVUlEKHV1aWQ6bnVtYmVyKTpBRW50aXR5e1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbi5nZXQodXVpZCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXRDaGlsZHJlbkJ5VHlwZTxUIGV4dGVuZHMgQUVudGl0eT4oYzoge25ldygpOlQ7fSk6QXJyYXk8QUVudGl0eT57XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVDaGlsZHJlbi5nZXQoYy5uYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0Q2hpbGRCeVR5cGU8VCBleHRlbmRzIEFFbnRpdHk+KGM6IHtuZXcoKTpUO30pOkFFbnRpdHl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW5CeVR5cGUoYylbMF07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICBhZGRDb21wb25lbnQ8VCBleHRlbmRzIENvbXBvbmVudD4oYzoge25ldygpOlQ7fSkgOlQge1xyXG4gICAgICAgIGxldCBjYyA9IG5ldyBjKCk7XHJcbiAgICAgICAgY2MuZW50aXR5ID0gdGhpcztcclxuXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzW2MubmFtZV0gPSBjYztcclxuICAgICAgICByZXR1cm4gY2M7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldENvbXBvbmVudDxUIGV4dGVuZHMgQ29tcG9uZW50PihjOiB7bmV3KCk6VDt9KSA6IFQge1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzW2MubmFtZV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldE9yQWRkQ29tcG9uZW50PFQgZXh0ZW5kcyBDb21wb25lbnQ+KGM6IHtuZXcoKTpUO30pIDogVCB7XHJcbiAgICAgICAgbGV0IGNvbSA9IHRoaXMuZ2V0Q29tcG9uZW50PFQ+KGMpO1xyXG4gICAgICAgIGlmKGNvbSA9PSBudWxsKXtcclxuICAgICAgICAgICBjb20gPSB0aGlzLmFkZENvbXBvbmVudDxUPihjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbTtcclxuICAgIH1cclxuIFxyXG4gICAgcHVibGljIHB1Ymxpc2g8VD4oZXZlbnQ6VCwgYzoge25ldygpOlQ7fSl7XHJcblxyXG4gICAgICAgIGxldCBhcnJheSA9IHRoaXMuZXZlbnRzTWFwLmdldChjLm5hbWUpO1xyXG4gICAgICAgIGlmKGFycmF5PT1udWxsIHx8IGFycmF5Lmxlbmd0aCA9PSAwKXtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcInRoaXMgZXZlbnQgbm90IHN1YnNjcmliZWQuLi5cIilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8YXJyYXkubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBsZXQgZiA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICBpZihmICE9IG51bGwpIGYoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3Vic2NyaWJlPFQ+KGFjdGlvbjoodDpUKT0+dm9pZCwgYzoge25ldygpOlQ7fSl7XHJcblxyXG4gICAgICAgIGxldCBhcnJheSA9IHRoaXMuZXZlbnRzTWFwLmdldChjLm5hbWUpO1xyXG4gICAgICAgIGlmKGFycmF5ID09IG51bGwpe1xyXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheTxGdW5jdGlvbj4oKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHNNYXAuc2V0KGMubmFtZSxhcnJheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFycmF5LnB1c2goYWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdW5TdWJzY3JpYmU8VD4oYWN0aW9uOih0OlQpPT52b2lkLCBjOiB7bmV3KCk6VDt9KXtcclxuXHJcbiAgICAgICAgbGV0IGFycmF5ID0gdGhpcy5ldmVudHNNYXAuZ2V0KGMubmFtZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGluZGV4ID0gYXJyYXkuaW5kZXhPZihhY3Rpb24sIDApO1xyXG4gICAgICAgIGlmKGluZGV4ID4gLTEpe1xyXG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGRpc3Bvc2UoKXtcclxuXHJcbiAgICAgICAgbGV0IGNoaWxkcmVuPSB0aGlzLmdldENoaWxkcmVuO1xyXG4gICAgICAgIGZvcihsZXQgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgY2hpbGRyZW5baV0uZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5ldmVudHNNYXAuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl90eXBlQ2hpbGRyZW4uY2xlYXIoKTtcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgQUVudGl0eSB9IGZyb20gXCIuL0FFbnRpdHlcIjtcblxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50e1xuXG4gICAgcHVibGljIGVudGl0eTpBRW50aXR5O1xuICAgXG4gICAgcHVibGljIHB1Ymxpc2g8VD4oZXZlbnQ6VCwgYzoge25ldygpOlQ7fSl7XG5cbiAgICAgICAgdGhpcy5lbnRpdHkucHVibGlzaChldmVudCwgYyk7XG4gICAgfVxuXG4gICAgcHVibGljIHN1YnNjcmliZTxUPihhY3Rpb246KHQ6VCk9PnZvaWQsIGM6IHtuZXcoKTpUO30pe1xuXG4gICAgICAgIHRoaXMuZW50aXR5LnN1YnNjcmliZTxUPihhY3Rpb24sIGMpO1xuICAgIH1cblxuICAgIHB1YmxpYyB1blN1YnNjcmliZTxUPihhY3Rpb246KHQ6VCk9PnZvaWQsIGM6IHtuZXcoKTpUO30pe1xuXG4gICAgICAgdGhpcy5lbnRpdHkudW5TdWJzY3JpYmU8VD4oYWN0aW9uLCBjKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IEFFbnRpdHkgfSBmcm9tIFwiLi9BRW50aXR5XCI7XG5cblxuZXhwb3J0IGNsYXNzIEVudGl0eUZhY3RvcnkgZXh0ZW5kcyBTaW5nbGV0b248RW50aXR5RmFjdG9yeT57XG4gICAgcHJpdmF0ZSBhdXRvSUQ6bnVtYmVyID0gMDtcblxuICAgIHB1YmxpYyBjcmVhdGU8VCBleHRlbmRzIEFFbnRpdHk+ICggYzoge25ldygpOlQ7fSkgOiBUIHtcbiAgICAgICAgbGV0IGNjID0gbmV3IGMoKTtcbiAgICAgICAgY2MudXVpZCA9ICsrdGhpcy5hdXRvSUQ7XG5cbiAgICAgICAgY2Mub25Bd2FrZShudWxsKTtcbiAgICAgICAgcmV0dXJuIGNjO1xuICAgIH1cblxuICAgIHB1YmxpYyBjcmVhdGVXaXRoRGF0YTxUIGV4dGVuZHMgQUVudGl0eT4gKGluaXREYXRhOmFueSwgYzoge25ldygpOlQ7fSkgOiBUIHtcbiAgICAgICAgbGV0IGNjID0gbmV3IGMoKTtcbiAgICAgICAgY2MudXVpZCA9ICsrdGhpcy5hdXRvSUQ7XG4gICAgICAgIGNjLm9uQXdha2UoaW5pdERhdGEpO1xuICAgICAgICByZXR1cm4gY2M7XG4gICAgfVxuXG5cblxufSIsImltcG9ydCB7IFN0b3J5IH0gZnJvbSBcImlua2pzL2VuZ2luZS9TdG9yeVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcblxuZXhwb3J0IGNsYXNzIElua1N0YXRlSW5zcGVjdG9ye1xuXG4gICAgcHVibGljIEJpbmRJbmtNZXRob2RzKGlua1N0b3J5OlN0b3J5KTp2b2lke1xuICAgICAgICBcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiL6YeH55So5q2k5pa55byPXG4gICAgICAgIHRoaXMuYmluZElua01ldGhvZE9uY2UoaW5rU3RvcnksXCJHZXRDaGFyYWN0ZXJOYW1lXCIsdGhpcy5nZXRDaGFyYWN0ZXJOYW1lKTtcbiAgICAgICAgLy8z5Y+C5pWw5Lul5LiK6YeH55So5q2k5pa55byPIFxuICAgICAgICB0aGlzLmJpbmRJbmtNZXRob2RPbmNlR2VuZXJhbChpbmtTdG9yeSxcIkdldENoYXJhY3Rlck5hbWVCeU11dGlQYXJhbXNcIix0aGlzLmdldENoYXJhY3Rlck5hbWVNdXRpUGFyYW1zKTtcbiAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENoYXJhY3Rlck5hbWUoKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIkp1c3RpbiBUZXN0IFB1ZXJ0c1wiO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Q2hhcmFjdGVyTmFtZU11dGlQYXJhbXMocDE6bnVtYmVyLHAyOm51bWJlcixwMzpudW1iZXIpOnN0cmluZ3tcbiAgICAgICAgcmV0dXJuIFwiSnVzdGluIE11dGkgUGFyYW1zXCI7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGJpbmRJbmtNZXRob2RPbmNlKGlua1N0b3J5OlN0b3J5LGZ1bmNOYW1lOnN0cmluZyxmdW5jOlN0b3J5LkV4dGVybmFsRnVuY3Rpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgZnVuYyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cbiAgICBwcml2YXRlIGJpbmRJbmtNZXRob2RPbmNlR2VuZXJhbChpbmtTdG9yeTpTdG9yeSwgZnVuY05hbWU6c3RyaW5nLGZ1bmM6U3RvcnkuRXh0ZXJuYWxGdW5jdGlvbil7XG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlua1N0b3J5LkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChmdW5jTmFtZSwgZnVuYyk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIHVuYmluZElua01ldGhvZChpbmtTdG9yeTpTdG9yeSxmdW5jTmFtZTpzdHJpbmcpe1xuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuVW5iaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxufSIsImltcG9ydCB7IFN0b3J5IH0gZnJvbSBcImlua2pzL2VuZ2luZS9TdG9yeVwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IElua1N0YXRlSW5zcGVjdG9yIH0gZnJvbSBcIi4vSW5rU3RhdGVJbnNwZWN0b3JcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBJbmtXcml0ZXJ7XG5cbiAgICBwdWJsaWMgc3RhdGljIERFQlVHX1NUT1JZX0lEOnN0cmluZyA9IFwiREVCVUdfU1RPUllcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfUFJFRklYOnN0cmluZyA9IFwiPj4+XCI7XG4gICAgcHVibGljIHN0YXRpYyBDT01NQU5EX0RFTElNSVRFUjpzdHJpbmcgPSBcIjpcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfQVJHX0RFTElNSVRFUjpzdHJpbmcgPSAnLCc7XG5cbiAgICBwcml2YXRlIF9jdXJyZW50U3Rvcnk6U3Rvcnk7XG4gICAgcHJpdmF0ZSBfYWxsSW5rQ29tbWFuZHM6TWFwPHN0cmluZyxGdW5jdGlvbj4gPSBuZXcgTWFwPHN0cmluZyxGdW5jdGlvbj4oKTtcblxuXG4gICAgY29uc3RydWN0b3Ioc3RvcnlKc29uOnN0cmluZyl7XG4gICAgICAgIHRoaXMuc2V0dXBJbmtDb21tYW5kcygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0cm95KHN0b3J5SnNvbik7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkKCk6dm9pZHtcbiAgICAgICAgbGV0IHN0b3J5U3RhdGU6c3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYoc3RvcnlTdGF0ZSE9bnVsbCAmJiBzdG9yeVN0YXRlIT1cIlwiKXtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS5Mb2FkSnNvbihzdG9yeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU3Ryb3koanNvbjpzdHJpbmcpe1xuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkgPSBuZXcgU3RvcnkoanNvbik7XG5cbiAgICAgICBcbiAgICB9XG5cbiAgICBwdWJsaWMgYmVnaW5TdG9yeShrbm90TmFtZTpzdHJpbmcpe1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBMb2dnZXIud2FybihcIlRyeWluZyB0byBBZHZhbmNlU3RvcnkgaW4gSW5rV3JpdGVyIHdoZW4gbm8gc3RvcnkgaGFzIGJlZW4gY3JlYXRlZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5DaG9vc2VQYXRoU3RyaW5nKGtub3ROYW1lLCB0cnVlKTtcblxuICAgICAgICAgbGV0IGlua1N0YXRlOklua1N0YXRlSW5zcGVjdG9yID0gbmV3IElua1N0YXRlSW5zcGVjdG9yKCk7XG4gICAgICAgICBpbmtTdGF0ZS5CaW5kSW5rTWV0aG9kcyh0aGlzLl9jdXJyZW50U3RvcnkpO1xuXG4gICAgICAgIHRoaXMuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdpdmVSZXdhcmQoKTpib29sZWFue1xuICAgICAgICBMb2dnZXIubG9nKFwiZ2l2ZSByZXdhcmQuLi5cIik7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cElua0NvbW1hbmRzKCk6dm9pZHtcbiAgICAgICAgdGhpcy5fYWxsSW5rQ29tbWFuZHMuc2V0KFwiR0lWRV9SRVdBUkRcIix0aGlzLmdpdmVSZXdhcmQpXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVDb21tYW5kKGNvbW1hbmQ6c3RyaW5nLCBhcmdzOnN0cmluZ1tdKTpib29sZWFue1xuICAgICAgICBpZih0aGlzLl9hbGxJbmtDb21tYW5kcy5oYXMoY29tbWFuZCkpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FsbElua0NvbW1hbmRzLmdldChjb21tYW5kKShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZXJyb3IoXCJDb3VsZCBub3QgZmluZCBJbmtDb21tYW5kIHdpdGggbmFtZTpcIitjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUNvbW1hbmROYW1lKHRleHQ6c3RyaW5nKTpzdHJpbmd7XG4gICAgICAgIGxldCBudW06bnVtYmVyID0gdGV4dC5pbmRleE9mKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCk7XG4gICAgICAgIGxldCBudW0yOm51bWJlciA9IHRleHQuaW5kZXhPZihJbmtXcml0ZXIuQ09NTUFORF9ERUxJTUlURVIpO1xuICAgICAgICBpZihudW0yID09IC0xKXtcbiAgICAgICAgICAgIG51bTIgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW5ndGg6bnVtYmVyID0gbnVtMiAtIChudW0gKyBJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyKG51bSArIElua1dyaXRlci5DT01NQU5EX1BSRUZJWC5sZW5ndGgsIGxlbmd0aCkudHJpbSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBwYXJzZUNvbW1hbmRBcmdzKHRleHQ6c3RyaW5nKTpzdHJpbmdbXXtcbiAgICAgICAgbGV0IG51bTpudW1iZXIgPSB0ZXh0LmluZGV4T2YoSW5rV3JpdGVyLkNPTU1BTkRfREVMSU1JVEVSKTtcbiAgICAgICAgaWYobnVtID09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlciA9IHRleHQubGVuZ3RoIC0gKG51bSArIDEpO1xuICAgICAgICBsZXQgbGlzdDpzdHJpbmdbXSA9IHRleHQuc3Vic3RyKG51bSsxLCBsZW5ndGgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0oKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdChJbmtXcml0ZXIuQ09NTUFORF9BUkdfREVMSU1JVEVSKTtcbiAgICAgICAgZm9yIChsZXQgaTpudW1iZXI9MDsgaTxsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gbGlzdFtpXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGV4dHJhY3RTcGVha2VyKGxpbmU6c3RyaW5nKTpbc3RyaW5nLHN0cmluZ117XG4gICAgICAgIGlmKGxpbmUuc3RhcnRzV2l0aChJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpKXtcbiAgICAgICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFycmF5OnN0cmluZ1tdID0gbGluZS5zcGxpdCgnOicsMik7XG4gICAgICAgIGlmKGFycmF5Lmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgbGV0IHNwZWFrSUQ6c3RyaW5nID0gYXJyYXlbMF0udHJpbSgpO1xuICAgICAgICAgICAgbGV0IHNwZWFrQ29udGVudDpzdHJpbmcgPSBhcnJheVsxXS50cmltKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbc3BlYWtJRCwgc3BlYWtDb250ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgIH1cblxuICAgIHB1YmxpYyBzYXZlQ3VycmVudFN0b3J5KCk6dm9pZHtcbiAgICAgICAgbGV0IGN1cnJTdGF0ZSA9IHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS50b0pzb24oKTtcbiAgICAgICAgLy9UT0RP772T772B772W772FXG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNvbnRpbnVlKCk6Ym9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdG9yeS5jYW5Db250aW51ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWR2YW5jZVN0b3J5KCk6dm9pZHtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJUcnlpbmcgdG8gQWR2YW5jZVN0b3J5IGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWVuIGNyZWF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9jdXJyZW50U3RvcnkuY2FuQ29udGludWUpe1xuICAgICAgICAgICAgbGV0IHRleHQ6c3RyaW5nID0gdGhpcy5fY3VycmVudFN0b3J5LkNvbnRpbnVlKCkudHJpbSgpO1xuICAgICAgICAgICAgaWYodGV4dCA9PSBcIlwiKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgc3BlYWtJRDpzdHJpbmc7XG4gICAgICAgICAgICBsZXQgc3BlYWtDb250ZW50OnN0cmluZztcblxuICAgICAgICAgICAgW3NwZWFrSUQsIHNwZWFrQ29udGVudF0gPSB0aGlzLmV4dHJhY3RTcGVha2VyKHRleHQpO1xuXG4gICAgICAgICAgICBsZXQgY29tbWFuZE5hbWU6c3RyaW5nID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBhcmdzOnN0cmluZ1tdID0gbnVsbDtcbiAgICAgICAgICAgIGlmKHNwZWFrQ29udGVudC5zdGFydHNXaXRoKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCkpe1xuICAgICAgICAgICAgICAgIGNvbW1hbmROYW1lID0gdGhpcy5wYXJzZUNvbW1hbmROYW1lKHNwZWFrQ29udGVudCk7XG4gICAgICAgICAgICAgICAgYXJncyA9IHRoaXMucGFyc2VDb21tYW5kQXJncyhzcGVha0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmKGNvbW1hbmROYW1lICE9IG51bGwgJiYgY29tbWFuZE5hbWUgIT1cIlwiKXtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5oYW5kbGVDb21tYW5kKGNvbW1hbmROYW1lLCBhcmdzKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy9PbkNvbnRlbnRSZWFkeVxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikuYnJvYWRjYXN0Q29udGVudFJlYWR5KFxuICAgICAgICAgICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgICAgICAgICBzcGVha0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHNwZWFrSUQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50VGFncyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlcy5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgIC8vT25DaG9pY2VzUHJlc2VudGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdENob2ljZXNQcmVzZW50ZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LmN1cnJlbnRDaG9pY2VzXG4gICAgICAgICAgICApO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIC8vT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdFN0b3J5RmluaXNoZWQoXG4gICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRURcbiAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3RDaG9pY2UoY2hvaWNlSW5kZXg6bnVtYmVyKTp2b2lke1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBMb2dnZXIud2FybihcIlRyeWluZyB0byBDaG9vc2VDaG9pY2UgaW4gSW5rV3JpdGVyIHdoZW4gbm8gc3RvcnkgaGFzIGJlZ3VuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5DaG9vc2VDaG9pY2VJbmRleChjaG9pY2VJbmRleCk7XG4gICAgICAgIHRoaXMuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcpOmFueXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdG9yeS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKHZhcmlhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcsIHZhbHVlOmFueSl7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS52YXJpYWJsZXNTdGF0ZS4kKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDaG9pY2UgfSBmcm9tIFwiaW5ranMvZW5naW5lL0Nob2ljZVwiO1xuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gXCIuLi9jb21tb24vUmVzTWFuYWdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IElua1dyaXRlciB9IGZyb20gXCIuL0lua1dyaXRlclwiO1xuXG5leHBvcnQgY2xhc3MgU3RvcnlNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFN0b3J5TWFuYWdlcj57XG5cbiAgICBwcml2YXRlIF9pbmtXcml0ZXI6SW5rV3JpdGVyO1xuICAgIHByaXZhdGUgc3RvcnlBZGRyZXNzOnN0cmluZyA9IFwiU3RvcnkvVGVzdFN0b3J5Lmpzb25cIjtcblxuICAgIHB1YmxpYyBnZXQgaW5rV3JpdGVyKCk6SW5rV3JpdGVye1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoKXtcblxuICAgICAgICBpZih0aGlzLl9pbmtXcml0ZXIgPT0gbnVsbCl7XG5cbiAgICAgICAgICAgIHZhciBqc29uID0gIChhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRUZXh0QXNzZXQodGhpcy5zdG9yeUFkZHJlc3MpKS50ZXh0O1xuICAgICAgICAgICAgdGhpcy5faW5rV3JpdGVyID0gbmV3IElua1dyaXRlcihqc29uKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIGJlZ2luU3Rvcnkoa25vdE5hbWU6c3RyaW5nKTp2b2lke1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuYmVnaW5TdG9yeShrbm90TmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNvbnRpbnVlKCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmtXcml0ZXIuY2FuQ29udGludWU7XG4gICAgfVxuXG4gICAgcHVibGljIGFkdmFuY2VTdG9yeSgpe1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuYWR2YW5jZVN0b3J5KCk7XG4gICAgfVxuXG4gICAgcHVibGljIHNlbGVjdENob2ljZShjaG9pY2U6Q2hvaWNlKTp2b2lke1xuICAgICAgICB0aGlzLl9pbmtXcml0ZXIuc2VsZWN0Q2hvaWNlKGNob2ljZS5pbmRleCk7XG4gICAgfVxuXG4gICAgcHVibGljIGxvYWRDdXJyZW50KCk6dm9pZHtcbiAgICAgICAgaWYodGhpcy5faW5rV3JpdGVyIT1udWxsKSB0aGlzLl9pbmtXcml0ZXIubG9hZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nKTphbnl7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmtXcml0ZXIuZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZywgdmFsdWU6YW55KXtcbiAgICAgICAgdGhpcy5pbmtXcml0ZXIuc2V0VmFyaWFibGUodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IE1lc3NlbmdlciB9IGZyb20gXCIuLi9jb21tb24vTWVzc2VuZ2VyXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuXG5leHBvcnQgY2xhc3MgU3RvcnlNZXNzYWdlTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxTdG9yeU1lc3NhZ2VNYW5hZ2VyPntcblxuICAgIHB1YmxpYyBzdGF0aWMgT05DT05URU5UUkVBRFk6bnVtYmVyID0gMTAwMTtcbiAgICBwdWJsaWMgc3RhdGljIE9OQ0hPSUNFU1BSRVNFTlRFRDpudW1iZXIgPSAxMDAyO1xuICAgIHB1YmxpYyBzdGF0aWMgT05TVE9SWUZJTklTSEVEOm51bWJlciA9IDEwMDM7XG5cbiAgICBwcml2YXRlIHN0b3J5TWVzc2FnZTpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XG5cblxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihtc2dDb2RlOm51bWJlcixvYmo6YW55LCBsaXN0ZW5lcjpGdW5jdGlvbil7XG5cbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYWRkTGlzdGVuZXIobXNnQ29kZSwgb2JqLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLCBsaXN0ZW5lcjpGdW5jdGlvbil7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG1zZ0NvZGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXJCeUNvZGUobXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5yZW1vdmVMaXN0ZW5lckJ5VHlwZShtc2dDb2RlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXJ1cCgpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5jbGVhcnVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdENvbnRlbnRSZWFkeShcbiAgICAgICAgbXNnQ29kZTpudW1iZXIsXG4gICAgICAgIHNwZWFrZXJDb250ZW50OnN0cmluZyxcbiAgICAgICAgc3BlYWtlcklkOnN0cmluZyxcbiAgICAgICAgY3VycmVudFRhZ3M6c3RyaW5nW10sXG4gICAgICAgIGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdXG4gICAgICAgIClcbiAgICB7XG5cbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYnJvYWRjYXN0KG1zZ0NvZGUsIHNwZWFrZXJDb250ZW50LHNwZWFrZXJJZCxjdXJyZW50VGFncyxjdXJyZW50Q2hvaWNlcyk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdENob2ljZXNQcmVzZW50ZWQoXG4gICAgICAgIG1lc2dDb2RlOm51bWJlcixcbiAgICAgICAgY3VycmVudENob2ljZXM6Q2hvaWNlW11cbiAgICApe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5icm9hZGNhc3QobWVzZ0NvZGUsY3VycmVudENob2ljZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RTdG9yeUZpbmlzaGVkKG1lc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmJyb2FkY2FzdChtZXNnQ29kZSk7ICAgXG4gICAgfVxufSIsImltcG9ydCB7IFVuaXR5RW5naW5lIH0gZnJvbSAnY3NoYXJwJztcbmltcG9ydCB7IEdhbWVDb25maWcgfSBmcm9tICcuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZyc7XG5lbnVtIExvZ1R5cGUge1xuXHRFcnJvciA9IDAsXG5cdEFzc2VydCA9IDEsXG5cdFdhcm5pbmcgPSAyLFxuXHRMb2cgPSAzLFxuXHRFeGNlcHRpb24gPSA0XG59XG5cbmV4cG9ydCBjbGFzcyBMb2dnZXJ7XG4gICAgcHJpdmF0ZSAgc3RhdGljICB1bml0eV9sb2dfdGFyZ2V0ID0gbnVsbDtcblxuICAgIHN0YXRpYyBnZXRQcmludFN0YWNrKHR5cGU6IExvZ1R5cGUsIHNob3dTdGFjayA6IGJvb2xlYW4sIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcgJiYgTG9nZ2VyLkxPR19PQkpFQ1RfVE9fSlNPTikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gZWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgYXJncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKHNob3dTdGFjayB8fCBVbml0eUVuZ2luZS5BcHBsaWNhdGlvbi5pc0VkaXRvcikge1xuICAgICAgICAgICAgdmFyIHN0YWNrcyA9IG5ldyBFcnJvcigpLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgc3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBpZiAoIUxvZ2dlci51bml0eV9sb2dfdGFyZ2V0KSB7XG4gICAgICAgICAgICBMb2dnZXIudW5pdHlfbG9nX3RhcmdldCA9IG5ldyBVbml0eUVuZ2luZS5PYmplY3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cblxuICAgIFxuXG5cdHN0YXRpYyBsb2coLi4uYXJncyk6IHZvaWR7XG4gICAgICAgIGlmKCFHYW1lQ29uZmlnLmRlYnVnKSByZXR1cm47XG5cbiAgICAgICAgbGV0IG1zZyA9IExvZ2dlci5nZXRQcmludFN0YWNrKExvZ1R5cGUuTG9nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIE91dHB1dHMgYSB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIExvZ2dlci5cblx0ICogQHBhcmFtIG1lc3NhZ2UgIGxpc3Qgb2YgSmF2YVNjcmlwdCBvYmplY3RzIHRvIG91dHB1dC4gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgZWFjaCBvZiB0aGVzZSBvYmplY3RzIGFyZSBhcHBlbmRlZCB0b2dldGhlciBpbiB0aGUgb3JkZXIgbGlzdGVkIGFuZCBvdXRwdXQuXG5cdCAqL1xuXHRzdGF0aWMgd2FybiguLi5hcmdzKTogdm9pZHtcbiAgICAgICAgaWYoIUdhbWVDb25maWcuZGVidWcpIHJldHVybjtcblxuICAgICAgICBsZXQgbXNnID0gTG9nZ2VyLmdldFByaW50U3RhY2soTG9nVHlwZS5XYXJuaW5nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBPdXRwdXRzIGFuIGVycm9yIG1lc3NhZ2UgdG8gdGhlIExvZ2dlci5cblx0ICogQHBhcmFtIG1lc3NhZ2UgQSBsaXN0IG9mIEphdmFTY3JpcHQgb2JqZWN0cyB0byBvdXRwdXQuIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIGVhY2ggb2YgdGhlc2Ugb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG9nZXRoZXIgaW4gdGhlIG9yZGVyIGxpc3RlZCBhbmQgb3V0cHV0LlxuXHQgKi9cblx0c3RhdGljIGVycm9yKC4uLmFyZ3MpOiB2b2lke1xuICAgICAgICBpZighR2FtZUNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtc2cgPSBMb2dnZXIuZ2V0UHJpbnRTdGFjayhMb2dUeXBlLkVycm9yLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgIH1cblxuXHQvKiogT3V0cHV0cyBhIHN0YWNrIHRyYWNlIHRvIHRoZSBMb2dnZXIuXG5cdCAqIEBwYXJhbSBtZXNzYWdlIEEgbGlzdCBvZiBKYXZhU2NyaXB0IG9iamVjdHMgdG8gb3V0cHV0LiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiBlYWNoIG9mIHRoZXNlIG9iamVjdHMgYXJlIGFwcGVuZGVkIHRvZ2V0aGVyIGluIHRoZSBvcmRlciBsaXN0ZWQgYW5kIG91dHB1dC5cblx0Ki9cblx0c3RhdGljIHRyYWNlKC4uLmFyZ3MpOiB2b2lke1xuICAgICAgICBpZighR2FtZUNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgbGV0IG1zZyA9IExvZ2dlci5nZXRQcmludFN0YWNrKExvZ1R5cGUuTG9nLCB0cnVlLCBhcmdzKTtcbiAgICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICB9XG5cblx0LyoqIExvZyBKYXZhU2NyaXB0IE9iamVjdHMgYXMgSlNPTiBmb3JtYXQgKi9cblx0c3RhdGljIExPR19PQkpFQ1RfVE9fSlNPTiguLi5hcmdzKTogYm9vbGVhbntcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IE5ldEVycm9yQ29kZSB9IGZyb20gXCIuL05ldEVycm9yQ29kZVwiO1xyXG5pbXBvcnQgeyBOaWNlVFMgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VQYXJzZXIgfSBmcm9tIFwiLi9NZXNzYWdlUGFyc2VyXCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE1zZ1BhY2t7XHJcbiAgICBwdWJsaWMgc2VuZFRpbWU6bnVtYmVyO1xyXG4gICAgcHVibGljIGNhbGxiYWNrOkZ1bmN0aW9uO1xyXG4gICAgcHVibGljIHJldHJ5VGltZXM6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBieXRlczpVaW50OEFycmF5O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR2FtZVNlc3Npb24gZXh0ZW5kcyBTaW5nbGV0b248R2FtZVNlc3Npb24+e1xyXG5cclxuICAgIHB1YmxpYyBpZDpudW1iZXIgPSAwOyAgLy9zZXNzaW9uIElEXHJcbiAgICBwcml2YXRlIHJlU2VuZEludGVydmFsOm51bWJlciA9IDEwMDAwOyAvLzEw56eS6YeN5Y+R5LiA5qyhXHJcbiAgICBwcml2YXRlIHRpbWVvdXRJbnRlcnZhbDpudW1iZXIgPSA1MDAwOyAvLzXnp5Lmo4Dmn6XkuIDmrKHmmK/lkKbotoXml7ZcclxuICAgIHByaXZhdGUgbWF4UmVTZW5kVGltZXM6bnVtYmVyID0gNTsgLy/mnIDlpKfph43lj5HmrKHmlbBcclxuICAgIHByaXZhdGUgdGltZW91dElpbWVyOmFueTtcclxuXHJcbiAgICBwcml2YXRlIF9ycGNJZDpudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSBjaGFubmVsOmFueTtcclxuICAgIHByaXZhdGUgcmVxdWVzdENhbGxiYWNrOk1hcDxudW1iZXIsTXNnUGFjaz4gPSBuZXcgTWFwPG51bWJlcixNc2dQYWNrPigpO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6TWFwPG51bWJlcixGdW5jdGlvbj4gPSBuZXcgTWFwPG51bWJlcixGdW5jdGlvbj4oKTtcclxuXHJcbiAgICAvL+i/lOWbnueahOacjeWKoeWZqElELCDnsbvlnotcclxuICAgIHByaXZhdGUgX3NlcnZlcklkOm51bWJlciA9IC0xO1xyXG4gICAgcHJpdmF0ZSBfc2VydmVyVHlwZTpudW1iZXIgPSAxO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHJwY0lkKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiArK3RoaXMuX3JwY0lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vYWRkcmVzcy0+IGlwOnBvcnRcclxuICAgIHB1YmxpYyBjb25uZWN0Q2hhbm5lbChhZGRyZXNzOnN0cmluZywgY29ubkNhYmFjazphbnkpe1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSBOaWNlVFMuVFNlcnZpY2UuSW5zdGFuY2UuR2V0Q2hhbm5lbCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5lcnJvckNhbGxiYWNrID0gKGNoYW5uZWw6YW55LCBjb2RlOm51bWJlcik9PntcclxuICAgICAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dE1zZygpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy50aW1lb3V0SW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25uQ2FiYWNrKGNoYW5uZWwsIGNvZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLnJlYWRDYWxsYmFjayA9IChidWZmZXI6VWludDhBcnJheSk9PntcclxuICAgICAgICAgICAgdGhpcy5vblJlY2VpdmUoYnVmZmVyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwuQ29ubmVjdChhZGRyZXNzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy/mjqXmlLbmnI3liqHlmajpgJrnn6VcclxuICAgIHB1YmxpYyBsaXN0ZW4ob3Bjb2RlOm51bWJlcixjYWxsYmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KG9wY29kZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5Y+R6YCBcHJvdG91Ymbmtojmga9cclxuICAgIC8v5raI5oGv77yaIHJwY19pZFs0XSAtIG9wY29kZVsyXSAtIHNlcnZlcl9pZFsyXSAtIHNlcnZlcl90eXBlWzFdIC0gXHJcbiAgICBwdWJsaWMgc2VuZChvcGNvZGU6bnVtYmVyLHJwY2lkOm51bWJlciwgbWVzc2FnZTpVaW50OEFycmF5LCBjYWxsQmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/lsIHoo4Xmtojmga/vvJpcclxuICAgICAgICBsZXQgcnBjQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZUludChycGNpZCk7IC8vNFxyXG4gICAgICAgIGxldCBvcGNvZGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlU2hvcnQob3Bjb2RlKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcmlkQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZVNob3J0KHRoaXMuX3NlcnZlcklkKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcnR5cGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlQnl0ZSh0aGlzLl9zZXJ2ZXJUeXBlKTsgLy8xXHJcblxyXG5cclxuICAgICAgICBsZXQgc2VuZEFycmF5OlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0ICsgMiArIDIgKyAxICttZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChycGNCdWYpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQob3Bjb2RlQnVmLCAgICA0KTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KHNlcnZlcmlkQnVmLCAgNCArIDIpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQoc2VydmVydHlwZUJ1ZiwgNCArIDIgKyAyKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KG1lc3NhZ2UsICAgICAgIDQgKyAyICsgMiArIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNhbGxCYWNrICE9IG51bGwpe1xyXG4gICAgICAgICAgICBsZXQgbXNnUGFjazpNc2dQYWNrID0gbmV3IE1zZ1BhY2soKTtcclxuICAgICAgICAgICAgbXNnUGFjay5zZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBtc2dQYWNrLmNhbGxiYWNrID0gY2FsbEJhY2s7XHJcbiAgICAgICAgICAgIG1zZ1BhY2suYnl0ZXMgPSBzZW5kQXJyYXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5zZXQocnBjaWQsIG1zZ1BhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IobGV0IGkgaW4gc2VuZEFycmF5KXtcclxuICAgICAgICAvLyAgICAgTG9nZ2VyLmxvZyhcIlRTIC0tIHNlbmQgYXJyYXk6IFwiK2kpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvL0xvZ2dlci5sb2coXCJzZW5kIGFycmF5OiBcIitzZW5kQXJyYXkpO1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5TZW5kKHNlbmRBcnJheSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZVNlbmQoYnl0ZXM6VWludDhBcnJheSl7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsLlNlbmQoYnl0ZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblJlY2VpdmUoYnVmZmVyOlVpbnQ4QXJyYXkpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCBtc2dCdWYgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG5cclxuICAgICAgICBsZXQgcnBjaWQgPSBNZXNzYWdlUGFyc2VyLmRlY29kZUludChtc2dCdWYuc3ViYXJyYXkoMCw0KSk7XHJcbiAgICAgICAgbGV0IG9wY29kZSA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlU2hvcnQobXNnQnVmLnN1YmFycmF5KDQsNikpO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJpZCA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlU2hvcnQobXNnQnVmLnN1YmFycmF5KDYsOCkpO1xyXG4gICAgICAgIGxldCBzZXJ2ZXJ0eXBlID0gTWVzc2FnZVBhcnNlci5kZWNvZGVCeXRlKG1zZ0J1Zi5zdWJhcnJheSg4LDkpKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VydmVySWQgPSBzZXJ2ZXJpZDtcclxuICAgICAgICB0aGlzLl9zZXJ2ZXJUeXBlID0gc2VydmVydHlwZTtcclxuXHJcbiAgICAgICAgbGV0IG1zZ0J5dGVzOlVpbnQ4QXJyYXkgPSBtc2dCdWYuc3ViYXJyYXkoOSk7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IGRlY29kZU1zZyA9ICBPcGNvZGUuZGVjb2RlKG9wY29kZSwgbXNnQnl0ZXMpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGlmKHJwY2lkPT11bmRlZmluZWQgfHwgIXRoaXMucmVxdWVzdENhbGxiYWNrLmhhcyhycGNpZCkpe1xyXG4gICAgICAgICAgICAgICAgLy/mo4Dmn6XmmK/lkKbmmK/mnI3liqHlmajkuIvlj5HnmoTmtojmga9cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMubGlzdGVuZXJzLmhhcyhvcGNvZGUpKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdGVuID0gdGhpcy5saXN0ZW5lcnMuZ2V0KG9wY29kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuKGRlY29kZU1zZy5tc2dPYmopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbGV0IG1zZ1BhY2s6TXNnUGFjayA9IHRoaXMucmVxdWVzdENhbGxiYWNrLmdldChycGNpZCk7XHJcbiAgICAgICAgICAgICAgICBtc2dQYWNrLmNhbGxiYWNrKGRlY29kZU1zZy5tc2dPYmopOyAgXHJcbiAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLmRlbGV0ZShycGNpZCk7XHJcbiAgICBcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChlKXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKFwicGFyc2UgbXNnIGVycm9yLCBvcGNvZGU6XCIrb3Bjb2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGVja1RpbWVvdXRNc2coKXtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLmZvckVhY2goKHZhbHVlLCBrZXkpID0+e1xyXG5cclxuICAgICAgICAgICAgaWYodmFsdWUucmV0cnlUaW1lcyA+PSB0aGlzLm1heFJlU2VuZFRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvL+i2hei/h+acgOWkp+mHjeWPkeasoeaVsO+8jOS4ouW8g1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhgTWVzc2FnZSByZXNlbmQgdG9vIG1vcmUsIG9wY29kZToke2tleX0sIGxhc3RzZW5kOiR7dmFsdWUuc2VuZFRpbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5kZWxldGUoa2V5KTsgXHJcbiAgICAgICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKChjdXJyVGltZSAtIHZhbHVlLnNlbmRUaW1lKSA+PSB0aGlzLnJlU2VuZEludGVydmFsKXtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5yZXRyeVRpbWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2VuZFRpbWUgPSBjdXJyVGltZTtcclxuICAgICAgICAgICAgICAgICAgICAvL+mHjeWPkea2iOaBr1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVTZW5kKHZhbHVlLmJ5dGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKGByZXNlbmQgbWVzc2FnZTosIG9wY29kZToke2tleX0sIHJldHJ5IHRpbWVzOiR7dmFsdWUucmV0cnlUaW1lc31gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZGlzY29ubmVjdCgpOnZvaWR7XHJcblxyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lb3V0SWltZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwuRGlzcG9zZSgpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgTmljZVRTIH0gZnJvbSBcImNzaGFycFwiO1xuaW1wb3J0IHsgJHByb21pc2UgfSBmcm9tIFwicHVlcnRzXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcblxuZXhwb3J0IGNsYXNzIEh0dHBNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPEh0dHBNYW5hZ2VyPntcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgXG4gICAgYXN5bmMgZ2V0KHVybDpzdHJpbmcpe1xuXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuSHR0cE1hbmFnZXIuR2V0KHVybClcbiAgICAgICAgICAgIGxldCB0eHQgPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcbiAgICAgICAgICAgIHJldHVybiB0eHQ7XG4gICAgICAgIH1jYXRjaChleCl7XG5cbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgR2V0IGVycm9yIDoke3VybH0gOiAke2V4fWApXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBwb3N0KHVybDpzdHJpbmcsIGZvcm06c3RyaW5nKXtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgdGFzaz0gTmljZVRTLkh0dHBNYW5hZ2VyLlBvc3QodXJsLCBmb3JtKVxuICAgICAgICAgICAgbGV0IHR4dCA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xuICAgICAgICAgICAgcmV0dXJuIHR4dDtcblxuICAgICAgICB9Y2F0Y2goZXgpe1xuXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYFBvc3QgZXJyb3IgOiR7dXJsfSA6ICR7ZXh9YClcblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIlxuZXhwb3J0IGNsYXNzIE1lc3NhZ2VQYXJzZXJ7XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlSW50KG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXI6VWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgICAgICBidWZmZXJbMF0gPSBuID4+PiAyNDtcbiAgICAgICAgYnVmZmVyWzFdID0gbiA+Pj4gMTY7XG4gICAgICAgIGJ1ZmZlclsyXSA9IG4gPj4+IDg7XG4gICAgICAgIGJ1ZmZlclszXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUludChidWZmZXI6VWludDhBcnJheSk6bnVtYmVye1xuICAgICAgICBcbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF0gPDwgMjQgfCBidWZmZXJbMV0gPDwgMTYgfCBidWZmZXJbMl0gPDwgOCB8IGJ1ZmZlclszXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlU2hvcnQobjpudW1iZXIpOlVpbnQ4QXJyYXl7XG5cbiAgICAgICAgbGV0IGJ1ZmZlciA6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gODtcbiAgICAgICAgYnVmZmVyWzFdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZGVjb2RlU2hvcnQoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXSA8PCA4IHwgYnVmZmVyWzFdO1xuXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cblxuXG4gICAgcHVibGljIHN0YXRpYyBlbmNvZGVCeXRlKG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXIgOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICAgICAgYnVmZmVyWzBdID0gbiAmIDB4ZmY7XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZUJ5dGUoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcblxuICAgICAgICBsZXQgbiA9IGJ1ZmZlclswXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuXG59IiwiXG5cbiBleHBvcnQgY2xhc3MgTmV0RXJyb3JDb2RlXG4ge1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ublN1Y2M6bnVtYmVyID0gMTAwMDAwO1xuXG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Db25uZWN0R2F0ZUtleUVycm9yOm51bWJlciA9IDEwMDAwNjtcblxuICAgICBwdWJsaWMgc3RhdGljICBFUlJfUGVlckRpc2Nvbm5lY3Q6bnVtYmVyICAgPSAxMDIwMDg7XG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Tb2NrZXRDYW50U2VuZDpudW1iZXIgICA9IDEwMjAwOTtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldEVycm9yOm51bWJlciAgICAgID0gMTAyMDEwO1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q29ubkVycm9yOm51bWJlciAgPSAxMDIwMTE7XG5cblxuICAgICBcblxuIH0iLCJcbmltcG9ydCB7IE9wY29kZSB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL09wY29kZVwiO1xuaW1wb3J0IHsgR2FtZUNvbmZpZyB9IGZyb20gXCIuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuL0dhbWVTZXNzaW9uXCI7XG5pbXBvcnQgeyBOZXRFcnJvckNvZGUgfSBmcm9tIFwiLi9OZXRFcnJvckNvZGVcIjtcblxuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbk1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2Vzc2lvbk1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBzZXNzaW9uUmVhbTpHYW1lU2Vzc2lvbjtcbiAgICBwcml2YXRlIHNlc3Npb25HYXRlOkdhbWVTZXNzaW9uO1xuXG5cbiAgICBwdWJsaWMgZ2V0IHJlYWxtUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblJlYW0ucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnYXRlUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkdhdGUucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNvbm5lY3RSZWFsbVNlcnZlcigpOlByb21pc2U8Ym9vbGVhbj4ge1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8Ym9vbGVhbj4ocmVzb3ZlID0+e1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbSA9IEdhbWVTZXNzaW9uLkluc3RhbmNlKEdhbWVTZXNzaW9uKS5jb25uZWN0Q2hhbm5lbChcbiAgICAgICAgICAgICAgICBHYW1lQ29uZmlnLnJlYWxtU2VydmVySVArXCI6XCIrR2FtZUNvbmZpZy5yZWFsbVNlcnZlclBvcnQsXG4gICAgICAgICAgICAgICAgKGNoYW5uZWw6YW55LGNvZGU6bnVtYmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZihjb2RlID09IE5ldEVycm9yQ29kZS5FUlJfU29ja2V0Q29ublN1Y2Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5pZCA9IGNoYW5uZWwuSWQ7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZShmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihcImxvZ2luIHJlYW1zZXJ2ZXIgZXJyLCBjb2RlOiBcIitjb2RlICsgXCIsaWQ6XCIrY2hhbm5lbC5JZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG4gICAgXG4gICAgcHVibGljIGRpc2Nvbm5lY3RSZWFsbVNlcnZlcigpe1xuICAgICAgICB0aGlzLnNlc3Npb25SZWFtLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbSA9IG51bGw7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgYXN5bmMgc2VuZFJlYWxtTXNnKG9wY29kZTpudW1iZXIsbXNnOmFueSk6UHJvbWlzZTxhbnk+e1xuICAgICAgICBcbiAgICAgICAgbGV0IHJwY0lEID0gdGhpcy5zZXNzaW9uUmVhbS5ycGNJZFxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGFueT4oKHJlc292ZSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgYnVmID0gT3Bjb2RlLmVuY29kZShvcGNvZGUsIG1zZylcblxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5zZW5kKG9wY29kZSwgcnBjSUQsIGJ1ZiwgKHJlc3BvbnNlOmFueSk9PntcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc292ZShyZXNwb25zZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cblxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0R2F0ZVNlcnZlcihhZGRyZXNzOnN0cmluZyk6UHJvbWlzZTxib29sZWFuPntcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGJvb2xlYW4+KHJlc292ZSA9PntcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUgPSBHYW1lU2Vzc2lvbi5JbnN0YW5jZShHYW1lU2Vzc2lvbikuY29ubmVjdENoYW5uZWwoXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAoY2hhbm5lbDphbnksY29kZTpudW1iZXIpPT57XG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJsb2dpbiBHYXRlIFNlcnZlcjogXCIrY29kZSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvZGUgPT0gTmV0RXJyb3JDb2RlLkVSUl9Tb2NrZXRDb25uU3VjYyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlLmlkID0gY2hhbm5lbC5JZDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUodHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUoZmFsc2UpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5lcnJvcihcImdhdGUgc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cblxuICAgIHB1YmxpYyBkaXNjb25uZWN0R2F0ZVNlcnZlcigpe1xuICAgICAgICB0aGlzLnNlc3Npb25HYXRlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRHYXRlTXNnKG9wY29kZTpudW1iZXIsIG1zZzphbnkpOlByb21pc2U8YW55PntcblxuICAgICAgICBsZXQgcnBjSUQgPSB0aGlzLnNlc3Npb25HYXRlLnJwY0lkXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8YW55PigocmVzb3ZlKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBidWYgPSBPcGNvZGUuZW5jb2RlKG9wY29kZSwgbXNnKVxuXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlLnNlbmQob3Bjb2RlLCBycGNJRCwgYnVmLCAocmVzcG9uc2U6YW55KT0+e1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb3ZlKHJlc3BvbnNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuXG4gICAgfVxufSAgIFxuIiwiaW1wb3J0IHsgZW1pdCB9IGZyb20gXCJwdWVydHNcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xuaW1wb3J0IHsgUmVkSGludHNNZXNzYWdlTWFuYWdlciB9IGZyb20gXCIuL1JlZEhpbnRzTWVzc2FnZU1hbmFnZXJcIjtcblxuZXhwb3J0IGVudW0gZW51bVJlZEhpbnRzIHtcbiAgICAvKiog5qCH6K6w5L2NICovXG4gICAgbm9uZSA9IDAsXG4gICAgLyoqIOiBiuWkqSAqL1xuICAgIGNoYXQgPSAxLFxuICAgIC8qKiDogYrlpKnkuJbnlYzpopHpgZMgKi9cbiAgICBjaGF0X3dvcmxkID0gMixcbiAgICAvKiog6IGK5aSp5YWs5Lya6aKR6YGTICovXG4gICAgY2hhdF9mYW1pbHkgPSAzLFxuICAgIC8qKiDogYrlpKnns7vnu5/popHpgZMgKi9cbiAgICBjaGF0X3N5c3RlbSA9IDQsXG59XG5cblxuZXhwb3J0IGNsYXNzIFJlZEhpbnRzTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZWRIaW50c01hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBfZGF0YTogQXJyYXk8bnVtYmVyPjsvL+iusOW9leavj+S4que6oueCueeahOaVsOWAvFxuICAgIHByaXZhdGUgX3BhcmVudEluZGV4OiBBcnJheTxudW1iZXI+Oy8v6K6w5b2V54i257qn57Si5byVXG4gICAgcHJpdmF0ZSBfY2hpbGROdW06IEFycmF5PG51bWJlcj47Ly/orrDlvZXlrZDpobnmlbDph49cbiAgICBwcml2YXRlIF9jaGlsZEluZGV4OiBBcnJheTxudW1iZXI+Oy8v6K6w5b2V5a2Q6aG55Zyo54i257qn5Lit55qE5o6S5bqP57Si5byVXG5cbiAgICAvKipcbiAgICAgKiDnuqLngrnlgLzmlLnlj5hcbiAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgUkVEX0hJTlRfVkFMVUVfQ0hBTkdFRDogc3RyaW5nID0gXCJSRURfSElOVF9WQUxVRV9DSEFOR0VEXCI7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXQoKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBbMF07Ly/nrKzkuIDkvY3ml6DmhI/kuYlcbiAgICAgICAgdGhpcy5fcGFyZW50SW5kZXggPSBbMF07XG4gICAgICAgIHRoaXMuX2NoaWxkTnVtID0gWzBdO1xuICAgICAgICB0aGlzLl9jaGlsZEluZGV4ID0gWzBdO1xuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLeiusOW9leeItuWtkOWFs+ezuy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIC8v6IGK5aSpXG4gICAgICAgIHRoaXMuc2V0UGFyZW50KGVudW1SZWRIaW50cy5jaGF0X3dvcmxkLCBlbnVtUmVkSGludHMuY2hhdCk7XG4gICAgICAgIHRoaXMuc2V0UGFyZW50KGVudW1SZWRIaW50cy5jaGF0X2ZhbWlseSwgZW51bVJlZEhpbnRzLmNoYXQpO1xuICAgICAgICB0aGlzLnNldFBhcmVudChlbnVtUmVkSGludHMuY2hhdF9zeXN0ZW0sIGVudW1SZWRIaW50cy5jaGF0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiDorr7nva7nuqLngrnnmoTlvIDlkK/lkozlhbPpl61cbiAgICAqL1xuICAgcHVibGljIHNldFJlZEhpbnRPcGVuT3JDbG9zZShyZWQ6IG51bWJlciwgaXNPcGVuOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLl9jaGlsZE51bVtyZWRdID4gMCkge1xuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcIue6oueCueaVsOaNruiuvue9rumUmeivr++8muS4jeiDveebtOaOpeWvuemrmOe6p+eahOe6oueCueaVsOaNruaTjeS9nFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvU2V0UmVkSGludE9wZW5PckNsb3NlKHJlZCwgaXNPcGVuID8gMSA6IDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICog6K6w5b2V54i25a2Q5YWz57O777ya5a2QLS0t54i2XG4gICAgKi9cbiAgICBwcml2YXRlIHNldFBhcmVudChjaGlsZDogbnVtYmVyLCBwYXJlbnQ6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50SW5kZXhbcGFyZW50XSA9PSBjaGlsZCkge1xuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcIuWFs+ezu+WPjeS6hlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50SW5kZXhbY2hpbGRdKSB7XG4gICAgICAgICAgICBMb2dnZXIubG9nKFwi6YeN5aSN6K6+572uXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhcmVudEluZGV4W2NoaWxkXSA9IHBhcmVudDtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMuX2NoaWxkTnVtW3BhcmVudF0pKSB7IHRoaXMuX2NoaWxkTnVtW3BhcmVudF0gPSAwIH1cbiAgICAgICAgdGhpcy5fY2hpbGROdW1bcGFyZW50XSsrOy8v5a2Q6aG55pWw6YeP5aKe5YqgXG4gICAgICAgIHRoaXMuX2NoaWxkSW5kZXhbY2hpbGRdID0gdGhpcy5fY2hpbGROdW1bcGFyZW50XTsvL+WtkOmhueeahOe0ouW8lSDku44x5byA5aeLXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkb1NldFJlZEhpbnRPcGVuT3JDbG9zZShyZWQ6IG51bWJlciwgdmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fZGF0YVtyZWRdICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhW3JlZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBfcGFyZW50OiBudW1iZXIgPSB0aGlzLl9wYXJlbnRJbmRleFtyZWRdXG4gICAgICAgICAgICBpZiAoX3BhcmVudCkge1xuICAgICAgICAgICAgICAgIC8v5aaC5p6c5pyJ54i257qn77yM5pu05paw54i257qnXG4gICAgICAgICAgICAgICAgbGV0IGluZGV4OiBudW1iZXIgPSB0aGlzLl9jaGlsZEluZGV4W3JlZF07Ly/ojrflj5blnKjniLbnuqfkuK3nmoTntKLlvJVcbiAgICAgICAgICAgICAgICB0aGlzLmRvU2V0UmVkSGludE9wZW5PckNsb3NlKF9wYXJlbnQsIHZhbHVlID4gMCA/IHRoaXMuX2RhdGFbX3BhcmVudF0gfCB0aGlzLmFkZFYoaW5kZXgpIDogdGhpcy5fZGF0YVtfcGFyZW50XSAmIHRoaXMuc3ViVihpbmRleCkpOy8v6K6+572u54i257qn55qE5YC8XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8v5Y+R5pS55Y+Y5LqL5Lu2OuWFqOWxgOS6i+S7tlxuICAgICAgICAgICAgLy9lbWl0KFJlZEhpbnRzTWFuYWdlci5SRURfSElOVF9WQUxVRV9DSEFOR0VELCByZWQpO1xuICAgICAgICAgICAgLy/nuqLngrnkuovku7bvvIzlsYDpg6jkuovku7ZcbiAgICAgICAgICAgIFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNZXNzYWdlTWFuYWdlcikuYnJvYWRjYXN0KHJlZCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgYWRkVihpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIDEgPDwgKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIHByaXZhdGUgc3ViVihpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIH50aGlzLmFkZFYoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiDmn6XnnIvnuqLngrnmmK/lkKblvIDlkK9cbiAgICAqL1xuICAgIHB1YmxpYyBjaGVja1JlZElzT3BlbihyZWQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVtyZWRdID4gMDtcbiAgICB9XG5cblxufSIsImltcG9ydCB7IE1lc3NlbmdlciB9IGZyb20gXCIuLi9jb21tb24vTWVzc2VuZ2VyXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuXG5cblxuZXhwb3J0IGNsYXNzIFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248UmVkSGludHNNZXNzYWdlTWFuYWdlcj57XG5cbiAgICBwcml2YXRlIHJlZGhpbnRzTWVzc2FnZTpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XG5cblxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihtc2dDb2RlOm51bWJlcixvYmo6YW55LCBsaXN0ZW5lcjpGdW5jdGlvbil7XG5cbiAgICAgICAgdGhpcy5yZWRoaW50c01lc3NhZ2UuYWRkTGlzdGVuZXIobXNnQ29kZSwgb2JqLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLCBsaXN0ZW5lcjpGdW5jdGlvbil7XG4gICAgICAgIHRoaXMucmVkaGludHNNZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG1zZ0NvZGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXJCeUNvZGUobXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnJlZGhpbnRzTWVzc2FnZS5yZW1vdmVMaXN0ZW5lckJ5VHlwZShtc2dDb2RlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXJ1cCgpe1xuICAgICAgICB0aGlzLnJlZGhpbnRzTWVzc2FnZS5jbGVhcnVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdChtc2dDb2RlOm51bWJlcixwYXJhbXM6YW55KXtcblxuXG4gICAgICAgIHRoaXMucmVkaGludHNNZXNzYWdlLmJyb2FkY2FzdChtc2dDb2RlLCBwYXJhbXMpXG4gICAgfVxuICAgIFxuXG59IiwiaW1wb3J0IHsgVW5pdHlFbmdpbmUgfSBmcm9tIFwiY3NoYXJwXCI7XG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlU2NlbmV7XG5cbiAgICBwcml2YXRlIHByZWxvYWRQcmVmYWI6TWFwPHN0cmluZyxudW1iZXI+O1xuICAgIHByaXZhdGUgc2NlbmVJbnN0YW5jZTpVbml0eUVuZ2luZS5SZXNvdXJjZU1hbmFnZW1lbnQuUmVzb3VyY2VQcm92aWRlcnMuU2NlbmVJbnN0YW5jZVxuXG4gICAgcHVibGljIGZpbmlzaENvdW50ID0gMDtcbiAgICBwdWJsaWMgdG90YWxDb3VudCA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIgPSBuZXcgTWFwPHN0cmluZyxudW1iZXI+KCk7XG4gICAgICAgIHRoaXMuZmluaXNoQ291bnQgPSAwO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRQcmVsb2FkUHJlZmFiKGFkZHJlc3M6c3RyaW5nLCBpbnN0Q291bnQpe1xuICAgICAgICBpZighdGhpcy5wcmVsb2FkUHJlZmFiLmhhcyhhZGRyZXNzKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLnNldChhZGRyZXNzLCBpbnN0Q291bnQpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLnNldChhZGRyZXNzLCB0aGlzLnByZWxvYWRQcmVmYWIuZ2V0KGFkZHJlc3MpICsgaW5zdENvdW50KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0U2NlbmVJbnN0YW5jZShzY2VuZUluc3RhbmNlOlVuaXR5RW5naW5lLlJlc291cmNlTWFuYWdlbWVudC5SZXNvdXJjZVByb3ZpZGVycy5TY2VuZUluc3RhbmNlKXtcbiAgICAgICAgdGhpcy5zY2VuZUluc3RhbmNlID0gc2NlbmVJbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25FbnRlcigpO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkNvbXBsZXRlKCk7XG4gICAgcHVibGljIGFic3RyYWN0IG9uTGVhdmUoKTtcblxuICAgIHB1YmxpYyBhc3luYyBsb2FkQXNzZXRzQXN5bmMoKXtcblxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSB0aGlzLnByZWxvYWRQcmVmYWIuc2l6ZTtcblxuICAgICAgICBsZXQgcHJlbWlzZXMgPSBbXTtcblxuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIGxldCBwcmVtaXNlID0gUy5HYW1lT2JqZWN0UG9vbC5wcmVMb2FkR2FtZU9iamVjdEFzeW5jKGtleSwgdmFsdWUsKCk9PntcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmlzaENvdW50Kys7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcHJlbWlzZXMucHVzaChwcmVtaXNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJlbWlzZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkRlc3Ryb3koKXtcbiBcbiAgICAgICAgLy/muIXnkIbotYTmupDnvJPlrZhcbiAgICAgICAgUy5HYW1lT2JqZWN0UG9vbC5jbGVhbnVwKHRydWUpO1xuXG4gICAgICAgIC8v5Y246L295Zy65pmvXG4gICAgICAgIFMuUmVzTWFuYWdlci51bmxvYWRTY2VuZSh0aGlzLnNjZW5lSW5zdGFuY2UpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLmNsZWFyKCk7XG4gICAgfVxufSIsImV4cG9ydCAgY2xhc3MgU2NlbmVEZWZ7XG5cbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmdTY2VuZTpzdHJpbmcgPSBcIkxvYWRpbmdTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgTGF1bmNoU2NlbmU6c3RyaW5nID0gXCJMYXVuY2hTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgSG9tZVNjZW5lOnN0cmluZyA9IFwiSG9tZVNjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBMb2dpblNjZW5lOnN0cmluZyA9IFwiTG9naW5TY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUHZlU2NlbmU6c3RyaW5nID0gXCJQdmVTY2VuZVwiO1xufVxuIiwiaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4vQmFzZVNjZW5lXCI7XHJcbmltcG9ydCB7IFB2ZVNjZW5lIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL3B2ZS9zY2VuZS9QdmVTY2VuZVwiO1xyXG5pbXBvcnQgeyBIb21lU2NlbmUgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvaG9tZS9zY2VuZS9Ib21lU2NlbmVcIjtcclxuaW1wb3J0IHsgTG9naW5TY2VuZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi9zY2VuZS9Mb2dpblNjZW5lXCI7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSBcIi4vU2NlbmVEZWZcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lRmFjdG9yeXtcclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVTY2VuZShzY2VuZU5hbWU6c3RyaW5nKTpCYXNlU2NlbmV7XHJcblxyXG4gICAgICAgIGxldCBzY2VuZTpCYXNlU2NlbmUgPSBudWxsO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHNjZW5lTmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuTG9naW5TY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IExvZ2luU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjZW5lRGVmLkhvbWVTY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IEhvbWVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuUHZlU2NlbmU6XHJcbiAgICAgICAgICAgICAgICBzY2VuZSA9IG5ldyBQdmVTY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc2NlbmU7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvZXZlbnQvVUlNZXNzYWdlXCI7XG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuL0Jhc2VTY2VuZVwiO1xuaW1wb3J0IHsgU2NlbmVGYWN0b3J5IH0gZnJvbSBcIi4vU2NlbmVGYWN0b3J5XCI7XG5cblxuXG5cbmV4cG9ydCBjbGFzcyBTY2VuZU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2NlbmVNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgY3VycmVudFNjZW5lOkJhc2VTY2VuZSA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2NlbmUoc2NlbmU6c3RyaW5nKXtcbiAgICAgICAgXG4gICAgICAgIHRyeXtcblxuICAgICAgICAgICAgLy/miZPlvIBMb2FkaW5n55WM6Z2iXG4gICAgICAgICAgICBTLlVJTWFuYWdlci5vcGVuTG9hZGluZyhjb21tb25VSS5QYWNrYWdlTmFtZSwgY29tbW9uVUkuVUlMb2FkaW5nUGFnZSk7XG5cbiAgICAgICAgICAgIC8v5riF55CG5pen5Zy65pmvXG4gICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL+W8gOWni+WKoOi9veWcuuaZr1xuICAgICAgICAgICAgbGV0IHNjZW5lSW5zdGFuY2UgPSBhd2FpdCBTLlJlc01hbmFnZXIubG9hZFNjZW5lKHNjZW5lKTtcblxuICAgICAgICAgICAgLy/lvIDlp4vliqDovb3ov5vlhaXlnLrmma/nmoTotYTmupBcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lID0gIFNjZW5lRmFjdG9yeS5jcmVhdGVTY2VuZShzY2VuZSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5zZXRTY2VuZUluc3RhbmNlKHNjZW5lSW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25FbnRlcigpO1xuXG4gICAgICAgICAgICAvL+iuvue9ruW9k+WJjeWcuuaZr+WKoOi9vei/m+W6plRpbWVyXG4gICAgICAgICAgICBsZXQgcHJvZ3Jlc3NJbnRlcnZhbCA9IHNldEludGVydmFsKCgpPT57XG5cbiAgICAgICAgICAgICAgICBsZXQgcHJvZ3Jlc3MgPSB0aGlzLmN1cnJlbnRTY2VuZS5maW5pc2hDb3VudC90aGlzLmN1cnJlbnRTY2VuZS50b3RhbENvdW50O1xuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJwcm9ncmVzczpcIitwcm9ncmVzcyArIFwiID0gXCIrdGhpcy5jdXJyZW50U2NlbmUuZmluaXNoQ291bnQgKyBcIiA9IFwiK3RoaXMuY3VycmVudFNjZW5lLnRvdGFsQ291bnQpO1xuXG4gICAgICAgICAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIuYnJvYWRjYXN0KFxuICAgICAgICAgICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyoxMDApO1xuXG4gICAgICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgICAgICAvL+WKoOi9vei1hOa6kFxuICAgICAgICAgICAgYXdhaXQgdGhpcy5jdXJyZW50U2NlbmUubG9hZEFzc2V0c0FzeW5jKCk7XG5cbiAgICAgICAgICAgIC8v5Yqg6L295a6M5oiQXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHByb2dyZXNzSW50ZXJ2YWwpXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkNvbXBsZXRlKClcbiAgICAgICAgICAgIFMuVUlNYW5hZ2VyLmNsb3NlTG9hZGluZyhjb21tb25VSS5VSUxvYWRpbmdQYWdlKTtcblxuICAgICAgICB9Y2F0Y2goZXgpe1xuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcImxvYWQgc2NlbmUgZXhjZXA6XCIrZXgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuXG5cbiAgICBcbn0iLCJcclxuXHJcblxyXG5leHBvcnQgZW51bSBVSVR5cGVEZWZ7XHJcbiAgICBVbmtvd24gPSAwLFxyXG4gICAgUGFnZSA9IDEsXHJcbiAgICBXaW5kb3c9MixcclxuICAgIFdpZGdldCA9IDMsXHJcbiAgICBMb2FkaW5nID00XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxheWVyRGVme1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQmFja2dyb3VuZDpudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBQYWdlOm51bWJlciA9IDEwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIE5vcm1hbFdpbmRvdzpudW1iZXIgPSAyMDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBUb3BXaW5kb3c6bnVtYmVyID0gMzAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgV2lkZ2V0Om51bWJlciA9IDQwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmc6bnVtYmVyID0gNTAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgVW5rb3duOm51bWJlciA9IDk5OTk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyAgZ2V0RGVmYXVsdExheWVyKHR5cGU6VUlUeXBlRGVmKTpudW1iZXJ7XHJcblxyXG4gICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuTG9hZGluZzogcmV0dXJuIHRoaXMuTG9hZGluZztcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuV2lkZ2V0OiByZXR1cm4gdGhpcy5XaWRnZXQ7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLldpbmRvdzogcmV0dXJuIHRoaXMuTm9ybWFsV2luZG93O1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5QYWdlOiByZXR1cm4gdGhpcy5QYWdlO1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5Vbmtvd246IHJldHVybiB0aGlzLlVua293bjtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuVW5rb3duOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlDb21EZWZze1xyXG4gICAgcHVibGljIHN0YXRpYyBCYWNrQnRuID0gXCJiYWNrX2J0blwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBXaW5kb3dDbG9zZUJ0biA9IFwid2luX2Nsb3NlX2J0blwiO1xyXG59XHJcblxyXG5cclxuXHJcbiIsIlxyXG5pbXBvcnQgeyBVSUxvZ2luUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSUxvZ2luUGFnZVwiO1xyXG5pbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSUhvbWVQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlIb21lUGFnZVwiO1xyXG5pbXBvcnQgeyBVSUxvYWRpbmcgfSBmcm9tIFwiLi9VSUxpYi9VSUxvYWRpbmdcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IGhvbWVVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2hvbWVcIjtcclxuaW1wb3J0IHsgVUlNc2dCb3ggfSBmcm9tIFwiLi9VSUxpYi9VSU1zZ0JveFwiO1xyXG5pbXBvcnQgeyBVSVNlbFNlcnZlcldpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlbFNlcnZlcldpblwiO1xyXG5pbXBvcnQgeyBVSVNob3BQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlTaG9wUGFnZVwiO1xyXG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcclxuaW1wb3J0IHsgVUlTdG9yeVdpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9zdG9yeS9VSVN0b3J5V2luXCI7XHJcbmltcG9ydCB7IGNvbWJhdFVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tYmF0XCI7XHJcbmltcG9ydCB7IFVJR3VpZGVXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvZ3VpZGUvVUlHdWlkZVdpblwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuXHJcblxyXG5jb25zdCBDUyA9IHJlcXVpcmUoJ2NzaGFycCcpO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUZhY3Rvcnl7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB1aUNhY2hlOk1hcDxzdHJpbmcsVUlQYW5lbD4gPSBuZXcgTWFwPHN0cmluZyxVSVBhbmVsPigpO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlVUkocGtnOnN0cmluZywgbmFtZTpzdHJpbmcpe1xyXG4gICAgICAgIExvZ2dlci5sb2coYGNyZWF0ZSBVSTogJHtwa2d9OiR7bmFtZX1gKVxyXG4gICAgICAgIGxldCBjb21wID0gQ1MuRmFpcnlHVUkuVUlQYWNrYWdlLkNyZWF0ZU9iamVjdChwa2csIG5hbWUpLmFzQ29tXHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHVpOlVJUGFuZWwgPSB0aGlzLnVpQ2FjaGUuZ2V0KG5hbWUpO1xyXG5cclxuICAgICAgICBpZighdWkpe1xyXG5cclxuICAgICAgICAgICAgc3dpdGNoKHBrZyl7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBjb21tb25VSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbW1vblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vblVJLlVJVUlOb3RpY2VXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSU1zZ0JveCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlMb2FkaW5nUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlVSUd1aWRlV2luOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlHdWlkZVdpbigpXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuUGFja2FnZU5hbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9sb2dpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuVUlMb2dpblBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSUxvZ2luUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgbG9naW5VSS5VSVNlbFNlcnZlcldpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU2VsU2VydmVyV2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2UgY29tYmF0VUkuUGFja2FnZU5hbWU6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5VSUhvbWVQYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlIb21lUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaG9tZVVJLlVJU2hvcFBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVNob3BQYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgICAgICAgIGNhc2Ugc3RvcnlVSS5QYWNrYWdlTmFtZTpcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIHN0b3J5VUkuVUlTdG9yeVdpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU3RvcnlXaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51aUNhY2hlLnNldChuYW1lLCB1aSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHVpIT1udWxsKXtcclxuICAgICAgICAgICAgdWkuZnVpID0gY29tcDtcclxuICAgICAgICAgICAgdWkubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgICAgIHVpLnBrZ05hbWUgPSBwa2c7XHJcblxyXG4gICAgICAgICAgICAvL+e7keWumkZhaXJ5R1VJ5o6n5Lu2XHJcbiAgICAgICAgICAgIHVpLmJpbmRBbGwodWkpO1xyXG4gICAgICAgICAgICB1aS5hd2FrZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYG5vdCBjcmVhdGUgdWk6ICR7cGtnfS0ke25hbWV9YCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4uL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlUeXBlRGVmIH0gZnJvbSBcIi4uL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2dhbWUvZXZlbnQvVUlNZXNzYWdlXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzICBVSUxvYWRpbmcgZXh0ZW5kcyBVSVBhbmVse1xyXG5cclxuXHJcbiAgICBAYmluZGVyKFwibG9hZGluZ19wcmVncmVzc1wiKVxyXG4gICAgcHVibGljIHByb2dyZXNzTG9hZGluZzogRmFpcnlHVUkuR1Byb2dyZXNzQmFyO1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTogdm9pZCB7XHJcbiAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5Mb2FkaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblNob3coYXJnOmFueSk6dm9pZHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52YWx1ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmlzaWJsZSA9IHRydWU7XHJcblxyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAocHJvZ3Jlc3M6bnVtYmVyKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcuVHdlZW5WYWx1ZShwcm9ncmVzcywgMC4xKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIucmVtb3ZlTGlzdGVuZXJCeUNvZGUoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0NFTkVfUFJPR1JFU1NcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi9VSVdpbmRvd1wiO1xyXG5cclxuLy8g6YCa55So5by556qXXHJcbmV4cG9ydCBjbGFzcyBVSU1zZ0JveEFyZ3tcclxuICAgIHB1YmxpYyB0aXRsZTpzdHJpbmcgPSBcIlwiO1xyXG4gICAgcHVibGljIGNvbnRlbnQ6c3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBidG5UZXh0OnN0cmluZyA9IFwiXCI7Ly9cIuehruWumnzlj5bmtoh85YWz6ZetXCJcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSU1zZ0JveCBleHRlbmRzIFVJV2luZG93e1xyXG5cclxuICAgIHByaXZhdGUgbV9hcmc6VUlNc2dCb3hBcmc7XHJcblxyXG4gICAgQGJpbmRlcihcIm1zZ1R4dFwiKVxyXG4gICAgcHJpdmF0ZSBtX3R4dDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwib2tCdG5cIilcclxuICAgIHByaXZhdGUgbV9va0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImNhbmNlbEJ0blwiKVxyXG4gICAgcHJpdmF0ZSBtX2NhbmNlbEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iaW5kQWxsKHRoaXMpXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uU2hvdyhhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgIFxyXG4gICAgfVxyXG5cclxufSIsIlxyXG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tICcuLi9jb21tb24vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgVUlMb2FkaW5nIH0gZnJvbSAnLi9VSUxpYi9VSUxvYWRpbmcnO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gJy4vVUlXaW5kb3cnO1xyXG5pbXBvcnQgeyBVSVdpZGdlIH0gZnJvbSAnLi9VSVdpZGdlJztcclxuaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gJy4vVUlQYW5lbCc7XHJcbmltcG9ydCB7IFVJRmFjdG9yeSB9IGZyb20gJy4vVUlGYWN0b3J5JztcclxuaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSAnLi4vLi4vZGF0YS91aS9ob21lJztcclxuaW1wb3J0IHsgUyB9IGZyb20gJy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vbG9nZ2VyL0xvZ2dlcic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJUGFnZVRyYWNre1xyXG4gICAgcHVibGljIHBrZzpzdHJpbmc7XHJcbiAgICBwdWJsaWMgbmFtZTpzdHJpbmc7XHJcbiAgICBwdWJsaWMgYXJnOmFueTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248VUlNYW5hZ2VyPntcclxuXHJcbiAgICBwcml2YXRlICBtX3BhZ2VUcmFja1N0YWNrOkFycmF5PFVJUGFnZVRyYWNrPjtcclxuICAgIHByaXZhdGUgbV9jdXJyZW50UGFnZTpVSVBhZ2VUcmFjaztcclxuXHJcbiAgICBwcml2YXRlIG1fbGlzdExvYWRlZFBhbmVsOkFycmF5PFVJUGFuZWw+O1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjayA9IG5ldyBBcnJheTxVSVBhZ2VUcmFjaz4oKTtcclxuICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsID0gbmV3IEFycmF5PFVJUGFuZWw+KCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZGlzdHJveUFsbExvYWRlZFBhbmVsKCk6dm9pZHtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aC0xOyBpPj0wOyBpLS0pe1xyXG4gICAgICAgICAgICBsZXQgcGFuZWwgPSB0aGlzLm1fbGlzdExvYWRlZFBhbmVsW2ldO1xyXG5cclxuICAgICAgICAgICAgaWYocGFuZWwuaXNPcGVuKXtcclxuICAgICAgICAgICAgICAgIHBhbmVsLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy/ljbjovb3otYTmupBcclxuICAgICAgICAgICAgUy5SZXNNYW5hZ2VyLnJlbGVhc2VGYWlyeUdVSVBhY2thZ2UocGFuZWwucGtnTmFtZSk7XHJcbiAgICAgICAgICAgIHBhbmVsLmRpc3Bvc2UoKTsgIFxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFuKCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5kaXN0cm95QWxsTG9hZGVkUGFuZWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBvcGVuKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcbiAgIFxyXG4gICAgICAgIGxldCB1aTphbnkgPSB0aGlzLmdldFVJKG5hbWUpO1xyXG5cclxuICAgICAgICBpZih1aSA9PSBudWxsKXtcclxuICAgICAgICAgICAgLy/liqDovb0gcGFja2FnZVxyXG4gICAgICAgICAgICBhd2FpdCBTLlJlc01hbmFnZXIubG9hZEZhaXJ5R1VJUGFja2FnZShwa2cpO1xyXG4gICAgICAgICAgICB1aSA9IFVJRmFjdG9yeS5jcmVhdGVVSShwa2csIG5hbWUpO1xyXG4gICAgICAgICAgICB0aGlzLm1fbGlzdExvYWRlZFBhbmVsLnB1c2godWkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodWkgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8vICMjIyAgdWkgYXMgYW55IOiwg+eUqOengeacieaWueazlVxyXG4gICAgICAgICAgICAodWkgYXMgYW55KS5faW50ZXJuYWxPcGVuKGFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXRVSShuYW1lOnN0cmluZyk6VUlQYW5lbHtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBwYW5lbCBvZiB0aGlzLm1fbGlzdExvYWRlZFBhbmVsKSB7XHJcbiAgICAgICAgICAgIGlmKHBhbmVsLm5hbWUgPT0gbmFtZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhcImZpbmQgcGFuZWwgaW4gY2FjaGU6IFwiK25hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBwYW5lbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvL+aJk+W8gOWcuuaZr+mhtemdoizmraTpobXpnaLkuI3orqHlhaXpobXpnaLmoIgs5peg6L+U5Zue5LiK5LiA6Z2i5oyJ6ZKuXHJcbiAgICBwdWJsaWMgb3BlblBhZ2VJblNjZW5lKHBrZzpzdHJpbmcsIHBhZ2U6c3RyaW5nLCBhcmc6YW55KXtcclxuICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHBrZywgcGFnZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSUxvYWRpbmdcclxuICAgIC8v5omT5byATG9hZGluZ+eVjOmdolxyXG4gICAgcHVibGljIG9wZW5Mb2FkaW5nKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcblxyXG4gICAgICAgIHRoaXMub3BlblBhZ2VJblNjZW5lKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICB9XHJcbiAgICAvL+WFs+mXrUxvYWRpbmfnlYzpnaJcclxuICAgIHB1YmxpYyBjbG9zZUxvYWRpbmcobmFtZTpzdHJpbmcsIGFyZz86YW55KTp2b2lke1xyXG4gICAgICAgIGxldCB1aTpVSUxvYWRpbmcgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJTG9hZGluZztcclxuICAgICAgICBpZih1aSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdWkuY2xvc2UoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVBhZ2VcclxuICAgIHByaXZhdGUgb3BlblBhZ2VXb3JrZXIocGtnOnN0cmluZywgcGFnZTpzdHJpbmcsIGFyZzphbnkpe1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZSA9IG5ldyBVSVBhZ2VUcmFjaygpO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5wa2cgPSBwa2c7XHJcbiAgICAgICAgdGhpcy5tX2N1cnJlbnRQYWdlLm5hbWUgPSBwYWdlO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5hcmcgPSBhcmc7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzdHJveUFsbExvYWRlZFBhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMub3Blbihwa2csIHBhZ2UsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/miZPlvIDpobXpnaIsIOS8muWFs+mXreS4iuS4gOS4qumhtemdouS4iueahOaJgOacieeql+WPoyxXaWRpZ2V0562JXHJcbiAgICBwdWJsaWMgb3BlblBhZ2UocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZz86YW55KXtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2N1cnJlbnRQYWdlICE9IHVuZGVmaW5lZCAmJiB0aGlzLm1fY3VycmVudFBhZ2UubmFtZSE9bmFtZSl7XHJcbiAgICAgICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5wdXNoKHRoaXMubV9jdXJyZW50UGFnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHBrZywgbmFtZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+i/lOWbnuS4iuS4gOS4qumhtemdolxyXG4gICAgcHVibGljIGdvQmFja1BhZ2UoKTp2b2lke1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fcGFnZVRyYWNrU3RhY2subGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGxldCB0cmFjayA9IHRoaXMubV9wYWdlVHJhY2tTdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcih0cmFjay5wa2cgLHRyYWNrLm5hbWUsIHRyYWNrLmFyZyk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMuZW50ZXJNYWluUGFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIC8v5Zue5Yiw5Li75Z+OXHJcbiAgICBwdWJsaWMgZW50ZXJNYWluUGFnZSgpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMub3BlblBhZ2VJblNjZW5lKGhvbWVVSS5QYWNrYWdlTmFtZSAsaG9tZVVJLlVJSG9tZVBhZ2UsbnVsbClcclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpbmRvd1xyXG4gICAgLy/miZPlvIDnqpflj6NcclxuICAgIHB1YmxpYyBhc3luYyBvcGVuV2luZG93KHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc6YW55KXtcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2luZG93ID0gYXdhaXQgdGhpcy5vcGVuKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5YWz6Zet56qX5Y+jXHJcbiAgICBwdWJsaWMgY2xvc2VXaW5kb3cobmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaW5kb3cgPSB0aGlzLmdldFVJKG5hbWUpIGFzIFVJV2luZG93O1xyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICB1aS5jbG9zZShhcmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1VSVdpZGdldFxyXG4gICAgLy/miZPlvIBXaWRpZ2V0XHJcbiAgICBwdWJsaWMgYXN5bmMgb3BlbldpZGdldChwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpZGdlID0gYXdhaXQgdGhpcy5vcGVuKHBrZywgbmFtZSwgYXJnKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdeWFs+mXrVdpZGlnZXRcclxuICAgIHB1YmxpYyBjbG9zZVdpZGdldChuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpZGdlID0gdGhpcy5nZXRVSShuYW1lKSBhcyBVSVdpZGdlO1xyXG4gICAgICAgIGlmKHVpIT1udWxsKXtcclxuICAgICAgICAgICAgdWkuY2xvc2UoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFuZWwgfSBmcm9tIFwiLi9VSVBhbmVsXCI7XHJcbmltcG9ydCB7IFVJVHlwZURlZiwgVUlDb21EZWZzIH0gZnJvbSBcIi4vVUlEZWZpbmVcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUGFnZSBleHRlbmRzIFVJUGFuZWx7XHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLlBhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtX2J0bkdvQmFjazpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2J0bkdvQmFjayA9IHRoaXMuZnVpLkdldENoaWxkKFVJQ29tRGVmcy5CYWNrQnRuKTtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2J0bkdvQmFjayE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5tX2J0bkdvQmFjay5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkJ0bkdvQmFjaygpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xyXG5cclxuICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgIFxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25CdG5Hb0JhY2soKXtcclxuICAgICAgICBTLlVJTWFuYWdlci5nb0JhY2tQYWdlKCk7XHJcbiAgICB9XHJcblxyXG59ICIsImltcG9ydCB7IFVJVHlwZURlZiwgVUlMYXllckRlZiB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUGFuZWwge1xyXG5cclxuICAgIHB1YmxpYyBmdWk6YW55OyAgLy9GYWlyeUdVSSDlr7nosaFcclxuXHJcbiAgICBwdWJsaWMgcGtnTmFtZTpzdHJpbmc7XHJcblxyXG5cclxuICAgIHByaXZhdGUgX25hbWU6c3RyaW5nO1xyXG4gICAgcHVibGljIHNldCBuYW1lKHY6c3RyaW5nKXtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdjtcclxuICAgIH1cclxuICAgIHB1YmxpYyBnZXQgbmFtZSgpOnN0cmluZ3tcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLlVua293bjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHJpdmF0ZSBtX2xheWVyOlVJTGF5ZXJEZWYgPSBVSUxheWVyRGVmLlVua293bjtcclxuICAgIHB1YmxpYyBnZXQgbGF5ZXIoKSA6IFVJTGF5ZXJEZWYge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1fbGF5ZXI7IFxyXG4gICAgfVxyXG4gICAgcHVibGljIHNldCBsYXllcih2IDogVUlMYXllckRlZikge1xyXG4gICAgICAgIHRoaXMubV9sYXllciA9IHY7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyAgZ2V0IGlzT3BlbigpIDogYm9vbGVhbntcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVpLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQXdha2UoKTp2b2lkO1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uU2hvdyh2bzphbnkpOnZvaWQ7XHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25DbG9zZShhcmc6YW55KTp2b2lkO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgb25VcGRhdGUoKTp2b2lke31cclxuXHJcbiAgICBwdWJsaWMgYXdha2UoKTp2b2lke1xyXG4gICAgICAgIHRoaXMub25Bd2FrZSgpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvL+e7keWumkZhaXJ5R1VJ5YWD5Lu2XHJcbiAgICBwdWJsaWMgYmluZEFsbCh0YXJnZXQ6YW55KTp2b2lke1xyXG4gICAgICAgIGZvcihsZXQgayBpbiB0YXJnZXRbXCJiaW5kZXJzXCJdKXtcclxuICAgICAgICAgICAgbGV0IGZndWlOYW1lID0gdGhpc1tcImJpbmRlcnNcIl1ba107XHJcbiAgICAgICAgICAgIHRoaXNba10gPSB0aGlzLmZ1aS5HZXRDaGlsZChmZ3VpTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cGRhdGUoKTp2b2lke1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIOatpOengeacieaWueazleWcqFVJIE1hbmFnZXLkuK3osIPnlKgg77yM54m55q6K6LCD55So44CCXHJcbiAgICAgKiBAcGFyYW0gYXJnIFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIF9pbnRlcm5hbE9wZW4oYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmxheWVyID0gVUlMYXllckRlZi5nZXREZWZhdWx0TGF5ZXIodGhpcy51aVR5cGUpO1xyXG4gICAgICAgIEZhaXJ5R1VJLkdSb290Lmluc3QuQWRkQ2hpbGQodGhpcy5mdWkpO1xyXG5cclxuICAgICAgICB0aGlzLm9uU2hvdyhhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbG9zZShhcmc6YW55ID0gbnVsbCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5vbkNsb3NlKGFyZyk7XHJcbiAgICAgICAgRmFpcnlHVUkuR1Jvb3QuaW5zdC5SZW1vdmVDaGlsZCh0aGlzLmZ1aSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkaXNwb3NlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLmZ1aS5EaXNwb3NlKCk7XHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYsIFVJQ29tRGVmcyB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyAgVUlXaW5kb3cgZXh0ZW5kcyBVSVBhbmVse1xyXG4gICBcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuV2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbV9idG5DbG9zZTpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm1fYnRuQ2xvc2UgPSB0aGlzLmZ1aS5HZXRDaGlsZChVSUNvbURlZnMuV2luZG93Q2xvc2VCdG4pO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KGFyZzphbnkpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMuZnVpLnggPSBGYWlyeUdVSS5HUm9vdC5pbnN0LndpZHRoLzIgLSB0aGlzLmZ1aS53aWR0aC8yO1xyXG4gICAgICAgIHRoaXMuZnVpLnkgPSBGYWlyeUdVSS5HUm9vdC5pbnN0LmhlaWdodC8yIC0gdGhpcy5mdWkuaGVpZ2h0LzI7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9idG5DbG9zZSE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5tX2J0bkNsb3NlLm9uQ2xpY2suQWRkKHRoaXMub25CdG5DbG9zZSk7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fYnRuQ2xvc2UhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5DbG9zZS5vbkNsaWNrLlJlbW92ZSh0aGlzLm9uQnRuQ2xvc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQnRuQ2xvc2UoKXtcclxuICAgICAgICB0aGlzLmNsb3NlKDApO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFRpbWVVdGlse1xyXG5cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmVmaXhJbnRlZ2VyKG51bSwgbGVuZ3RoKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIHJldHVybiAgKEFycmF5KGxlbmd0aCkuam9pbignMCcpICsgbnVtKS5zbGljZSgtbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDA6MDA6MDBcIuagvOW8j1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRUaW1lU3RyaW5nMSh0aW1lSW50IDogbnVtYmVyKTpzdHJpbmcge1xyXG5cclxuICAgICAgICBpZih0aW1lSW50IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMDowMDowMFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgbGV0IGhvdXI6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50IC8gKDYwICogNjApKTtcclxuICAgICAgICAgICAgbGV0IGhvdXJzdHIgPSB0aGlzLnByZWZpeEludGVnZXIoaG91ciwgMik7XHJcblxyXG4gICAgICAgICAgICBsZXQgbWlubnV0ZTpudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVJbnQvIDYwKSAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihtaW5udXRlLCAyKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzZWNvbmQ6bnVtYmVyID0gdGltZUludCAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgc2Vjb25kc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihzZWNvbmQsMik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN0cn06JHttaW51dGVzdHJ9OiR7c2Vjb25kc3RyfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8v5bCG5LiA5Liq5pe26Ze05pWw6L2s5o2i5oiQXCIwMDowMFwi5qC85byPXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpbWVTdHJpbmcodGltZUludDpudW1iZXIpOnN0cmluZ3tcclxuXHJcbiAgICAgICAgaWYodGltZUludCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMDA6MDA6MDBcIjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbGV0IGhvdXI6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50IC8gKDYwICogNjApKTtcclxuICAgICAgICAgICAgbGV0IGhvdXJzdHIgPSB0aGlzLnByZWZpeEludGVnZXIoaG91ciwgMik7XHJcblxyXG4gICAgICAgICAgICBsZXQgbWlubnV0ZTpudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVJbnQvIDYwKSAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihtaW5udXRlLCAyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBgJHtob3Vyc3RyfToke21pbnV0ZXN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDBcIuWIhuagvOW8j1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRUaW1lTWludXRlU3RyaW5nKHRpbWVJbnQ6bnVtYmVyKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIGlmKHRpbWVJbnQgPD0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjAwOjAwOjAwXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBtaW5udXRlOm51bWJlciA9IE1hdGguZmxvb3IodGltZUludC8gNjApICUgNjA7XHJcbiAgICAgICAgICAgIGxldCBtaW51dGVzdHI6c3RyaW5nID0gdGhpcy5wcmVmaXhJbnRlZ2VyKG1pbm51dGUsIDIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAke21pbnV0ZXN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDDigJznp5LmoLzlvI9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGltZVNlY29uZFN0cmluZyh0aW1lSW50Om51bWJlcik6c3RyaW5ne1xyXG5cclxuICAgICAgICBpZih0aW1lSW50IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMDowMDowMFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBsZXQgc2Vjb25kOm51bWJlciA9IHRpbWVJbnQgJSA2MDtcclxuICAgICAgICAgICAgbGV0IHNlY29uZHN0cjpzdHJpbmcgPSB0aGlzLnByZWZpeEludGVnZXIoc2Vjb25kLDIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAke3NlY29uZHN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+iOt+WPluacrOaciDHlj7fmmK/mmJ/mnJ/lh6BcclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0V2Vla09mTW9udGhGaXJzdERheSh0aW1lOm51bWJlcik6bnVtYmVye1xyXG5cclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/liKTmlq3mmK/lkKbkuLrpl7DlubRcclxuICAgIHB1YmxpYyBzdGF0aWMgaXNMZWFwWWVhcih5ZWFyOm51bWJlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoICh5ZWFyICUgNCA9PSAwICYmIHllYXIgJSAxMDAgIT0gMCkgfHwgKHllYXIgJSA0MDAgPT0gMCkgKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvL+avj+S4quaciOWvueW6lOeahOWkqeaVsFxyXG4gICAgc3RhdGljICBtb250aHM6QXJyYXk8bnVtYmVyPiA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcclxuICAgIHByaXZhdGUgc3RhdGljIGdldE1vbnRoRGF5c18oeWVhcjpudW1iZXIsIG1vbnRoOm51bWJlcik6bnVtYmVye1xyXG4gICAgICAgIGlmKG1vbnRoID09IDIpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzTGVhcFllYXIoeWVhcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjk7XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhzW21vbnRoXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRNb250aERheXModGltZTpudW1iZXIpOm51bWJlciB7XHJcblxyXG4gICAgICAgIGxldCB0ID0gbmV3IERhdGUodGltZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoRGF5c18odC5nZXRGdWxsWWVhcigpLCB0LmdldE1vbnRoKCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHNsZWVwKG1zOm51bWJlcil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PntcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnJyk7XHJcbiAgICAgICAgICAgIH0sIG1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB0ZXN0KCk6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IHQxOnN0cmluZyA9IHRoaXMuZ2V0VGltZVN0cmluZzEoNTAwMCk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyh0MSk7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGxldCB0MjpzdHJpbmcgPSB0aGlzLmdldFRpbWVTdHJpbmcoNTAwMCk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyh0Mik7XHJcblxyXG4gICAgICAgIGxldCB0MzpzdHJpbmcgPSB0aGlzLmdldFRpbWVNaW51dGVTdHJpbmcoNTAwMCk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyh0Myk7XHJcblxyXG4gICAgICAgIGxldCB0NDpzdHJpbmcgPSB0aGlzLmdldFRpbWVTZWNvbmRTdHJpbmcoNTAwMCk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyh0NCk7XHJcblxyXG4gICAgICAgIGxldCB0aW1lOm51bWJlciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICBsZXQgdDU6bnVtYmVyID0gdGhpcy5nZXRXZWVrT2ZNb250aEZpcnN0RGF5KHRpbWUpO1xyXG4gICAgICAgIExvZ2dlci5sb2coXCJnZXRXZWVrT2ZNb250aEZpcnN0RGF5OiBcIit0NSArIFwiICx0aW1lOlwiK3RpbWUpO1xyXG5cclxuICAgICAgICBsZXQgdDY6bnVtYmVyID0gdGhpcy5nZXRNb250aERheXModGltZSk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcImdldE1vbnRoRGF5czogXCIrdDYpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL2dlbi9wYlwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTG9naW5BUEl7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBiZW5jaG1hcmtUZXN0KCl7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvcihsZXQgaT0xOyBpPDI7aSsrKXtcclxuICAgICAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJHU19UZXN0LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBtc2cudGVzdElEID0gaTtcclxuICAgICAgICAgICAgbXNnLnRlc3ROYW1lID0gXCJiZW5jaG1hcmsgdGVzdFwiO1xyXG5cclxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgUy5TZXNzaW9uTWFuYWdlci5zZW5kR2F0ZU1zZyhcclxuICAgICAgICAgICAgICAgIE9wY29kZS5NU0dfQzJHU19UZXN0LFxyXG4gICAgICAgICAgICAgICAgbXNnXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgbGV0IHRlc3QgID0gIHJlc3BvbnNlIGFzIG5pY2VfdHMuR1MyQ19UZXN0O1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKFwiY29kZTogXCIrdGVzdC5FcnJvciArXCIsbXNnOlwiK3Rlc3QuTWVzc2FnZSArXCIscmVzOlwiK3Rlc3QudGVzdFJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9naW5SZWFsbVNlcnZlcihhY2NvdW50OnN0cmluZywgcGFzc3dvcmQ6c3RyaW5nKTpQcm9taXNlPG5pY2VfdHMuUjJDX0xvZ2luPntcclxuXHJcbiAgICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyUl9Mb2dpbi5jcmVhdGUoKTtcclxuICAgICAgICAgbXNnLkFjY291bnQgPSBhY2NvdW50O1xyXG4gICAgICAgICBtc2cuUGFzc3dvcmQgPSBwYXNzd29yZDtcclxuXHJcbiAgICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuc2VuZFJlYWxtTXNnKFxyXG4gICAgICAgICAgICBPcGNvZGUuTVNHX0MyUl9Mb2dpbixcclxuICAgICAgICAgICAgbXNnXHJcbiAgICAgICAgKVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UgYXMgbmljZV90cy5SMkNfTG9naW47XHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGxvZ2luR2F0ZVNlcnZlcihnYXRlSWQsIGdhdGVLZXkpOlByb21pc2U8bmljZV90cy5HMkNfTG9naW5HYXRlPntcclxuXHJcbiAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS5jcmVhdGUoKTtcclxuICAgICAgICBtc2cuR2F0ZUlkID0gZ2F0ZUlkO1xyXG4gICAgICAgIG1zZy5LZXkgPSBnYXRlS2V5O1xyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgIE9wY29kZS5NU0dfQzJHX0xvZ2luR2F0ZSxcclxuICAgICAgICAgICAgbXNnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlIGFzIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFFbnRpdHkgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2VudGl0eS9BRW50aXR5XCI7XG5cbmV4cG9ydCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBBRW50aXR5IHtcblxuICAgIHB1YmxpYyBvbkF3YWtlKGluaXREYXRhOiBhbnkpIHtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIGxldmVsOm51bWJlcjtcbiAgICBwdWJsaWMgaHA6bnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDE7XG4gICAgICAgIHRoaXMuaHAgPSAxMDA7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IEVudGl0eUZhY3RvcnkgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2VudGl0eS9FbnRpdHlGYWN0b3J5XCI7XG5pbXBvcnQgeyBQbGF5ZXIgfSBmcm9tIFwiLi9QbGF5ZXJcIjtcblxuXG5leHBvcnQgY2xhc3MgUGxheWVyTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxQbGF5ZXJNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgcGxheWVyOlBsYXllcjtcbiAgICBcbiAgICBwdWJsaWMgZ2V0UGxheWVyKHJlQ3JlYXRlOmJvb2xlYW49ZmFsc2UpOlBsYXllcntcbiAgICAgICAgaWYgKHJlQ3JlYXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnBsYXllcj1udWxsO1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIgPSBFbnRpdHlGYWN0b3J5Lkluc3RhbmNlKEVudGl0eUZhY3RvcnkpLmNyZWF0ZShQbGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYodGhpcy5wbGF5ZXI9PSBudWxsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucGxheWVyID0gRW50aXR5RmFjdG9yeS5JbnN0YW5jZShFbnRpdHlGYWN0b3J5KS5jcmVhdGUoUGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucGxheWVyO1xuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvZW50aXR5L0NvbXBvbmVudFwiO1xuXG5cbmV4cG9ydCBjbGFzcyBCYWdDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnR7XG5cbiAgICBwdWJsaWMgbmFtZTpzdHJpbmcgPSBcImhlbGxvXCI7XG4gICAgcHVibGljIHNpemU6bnVtYmVyID0gMTAwO1xufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvZW50aXR5L0NvbXBvbmVudFwiO1xuXG5cbmV4cG9ydCBjbGFzcyBQbGF5ZXJJbmZvQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50e1xuXG4gICAgcHVibGljIG5pY2tOYW1lOnN0cmluZyA9IFwiSnVzdGluXCI7XG4gICAgcHVibGljIG1vbmV5Om51bWJlciA9IDEwMDAwMDE7XG59IiwiXG5cblxuZXhwb3J0IGNsYXNzIFVJTWVzc2FnZXtcblxuXG4gICAgcHVibGljIHN0YXRpYyBNU0dfU0VMRUNUX1NFUlZFUjpudW1iZXIgID0gMTAwMDtcbiAgICBwdWJsaWMgc3RhdGljIE1TR19TQ0VORV9QUk9HUkVTUzpudW1iZXIgPSAxMDAxO1xuICAgIFxuXG5cbn0iLCJpbXBvcnQgeyBNZXNzZW5nZXIgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvblwiO1xuXG5cbmV4cG9ydCBjbGFzcyBVSU1lc3NhZ2VNYW5nZXIgZXh0ZW5kcyBTaW5nbGV0b248VUlNZXNzYWdlTWFuZ2VyPntcblxuICAgIHByaXZhdGUgdWlNZXNzYWdlOk1lc3NlbmdlciA9IG5ldyBNZXNzZW5nZXIoKTtcblxuXG4gICAgcHVibGljIGFkZExpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLG9iajphbnksIGxpc3RlbmVyOkZ1bmN0aW9uKXtcblxuICAgICAgICB0aGlzLnVpTWVzc2FnZS5hZGRMaXN0ZW5lcihtc2dDb2RlLCBvYmosIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsIGxpc3RlbmVyOkZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobXNnQ29kZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5Q29kZShtc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMudWlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyQnlUeXBlKG1zZ0NvZGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhcnVwKCl7XG4gICAgICAgIHRoaXMudWlNZXNzYWdlLmNsZWFydXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0KG1zZ0NvZGU6bnVtYmVyLHBhcmFtczphbnkpe1xuXG5cbiAgICAgICAgdGhpcy51aU1lc3NhZ2UuYnJvYWRjYXN0KG1zZ0NvZGUsIHBhcmFtcylcbiAgICB9XG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlXaW5kb3dcIjtcblxuZXhwb3J0IGNsYXNzIFVJR3VpZGVXaW4gZXh0ZW5kcyBVSVdpbmRvd3tcblxuICAgIEBiaW5kZXIoXCJmb2N1c1wiKVxuICAgIHByaXZhdGUgbV9mb2N1czpGYWlyeUdVSS5HR3JhcGg7XG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgICAgICB0aGlzLm1fZm9jdXMuYWxwaGEgPSAwLjJcblxuICAgICAgICB0aGlzLm1fZm9jdXMuU2V0WFkoNTIwLDU1MClcblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vblNob3codm8pO1xuXG4gICAgICBcbiAgICB9XG5cblxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcblxuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvaG9tZVwiO1xyXG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcbmltcG9ydCB7IFZvSG9tZSB9IGZyb20gXCIuLi92by9Wb0hvbWVcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSG9tZVNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG5cclxuICAgICAgICBsZXQgdm86Vm9Ib21lID0gbmV3IFZvSG9tZSgpO1xyXG4gICAgICAgIHZvLm5hbWUgPSBcIkp1c3RpblwiO1xyXG4gICAgICAgIHZvLmhwID0gMTIwMDtcclxuICAgICAgICB2by5tcCA9IDMzMDA7XHJcbiAgICAgICAgdm8ubW9uZXkgPSA2NjY7XHJcblxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5QYWdlSW5TY2VuZShcclxuICAgICAgICAgICAgaG9tZVVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICBob21lVUkuVUlIb21lUGFnZSxcclxuICAgICAgICAgICAgdm8pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVBhZ2VcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgY29tbW9uVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9jb21tb25cIjtcclxuaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvaG9tZVwiO1xyXG5pbXBvcnQgeyBWb0hvbWUgfSBmcm9tIFwiLi4vdm8vVm9Ib21lXCI7XHJcbmltcG9ydCB7IExvZ2luQVBJIH0gZnJvbSBcIi4uLy4uLy4uL2FwaS9Mb2dpbkFQSVwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3BiL2dlbi9wYlwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlIb21lUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiY2hhdEJ0blwiKVxyXG4gICAgcHVibGljIG1fY2hhdEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImJhZ0J0blwiKVxyXG4gICAgcHVibGljIG1fYmFnQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwic2hvcEJ0blwiKVxyXG4gICAgcHVibGljIG1fc2hvcEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImxldmVsQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9sZXZlbEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJuYW1lVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9uYW1lTGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJocFR4dFwiKVxyXG4gICAgcHVibGljIG1faHBMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm1wVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9tcExibDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwibW9uZXlUeHRcIilcclxuICAgIHB1YmxpYyBtX21vbmV5TGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX2NoYXRCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbmNoYXRCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fYmFnQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25iYWdCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fc2hvcEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvcEJ0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubV9sZXZlbEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9ubGV2ZWxCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHB1YmxpYyBvblNob3codm86Vm9Ib21lKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcblxyXG4gICAgICAgIHRoaXMubV9uYW1lTGJsLnRleHQgPSB2by5uYW1lO1xyXG4gICAgICAgIHRoaXMubV9tcExibC50ZXh0ID0gdm8ubXAudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLm1faHBMYmwudGV4dCA9IHZvLmhwLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tX21vbmV5TGJsLnRleHQgPSB2by5tb25leS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBTLkdhbWVTZXNzaW9uLmxpc3RlbihPcGNvZGUuTVNHX0dTMkNfVGVzdCxmdW5jdGlvbihtc2c6bmljZV90cy5HUzJDX1Rlc3Qpe1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKFwi5pS25Yiw5pyN5Yqh5Zmo5LiL5Y+R55qE5raI5oGv44CC44CC44CC44CCXCIrbXNnLnRlc3RSZXNwb25zZSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25jaGF0QnRuKCl7XHJcblxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgIGNvbW1vblVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICBjb21tb25VSS5VSVVJTm90aWNlV2luLFxyXG4gICAgICAgICAgICBudWxsKTtcclxuICAgICAgICBMb2dnZXIubG9nKFwib24gY2hhdC4uLlwiKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbmJhZ0J0bigpe1xyXG4gICAgICAgIExvZ2dlci5sb2coXCJvbiBiYWcgLi5cIik7XHJcblxyXG4gICAgICAgIC8vYmVuY2htYXJrIHRlc3RcclxuICAgICAgICBMb2dpbkFQSS5iZW5jaG1hcmtUZXN0KCk7XHJcblxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uc2hvcEJ0bigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5QYWdlKFxyXG4gICAgICAgICAgICBob21lVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGhvbWVVSS5VSVNob3BQYWdlKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbmxldmVsQnRuKCl7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIm9uIGxldmVsLi4uXCIpO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgVUlTaG9wUGFnZSBleHRlbmRzIFVJUGFnZXtcblxuXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XG5cbiAgICB9XG5cbiAgICBcbiAgICBwdWJsaWMgb25TaG93KHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcblxuICAgICAgICBcbiAgICB9XG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgfVxuXG59IiwiXG5cbmV4cG9ydCBjbGFzcyBWb0hvbWV7XG5cbiAgICBwdWJsaWMgbmFtZTpzdHJpbmc7XG4gICAgcHVibGljIGhwOm51bWJlcjtcbiAgICBwdWJsaWMgbXA6bnVtYmVyO1xuICAgIHB1YmxpYyBtb25leTpudW1iZXI7XG5cbn0iLCJcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xyXG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dpblNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Db21wbGV0ZSgpIHtcclxuICAgICAgICBcclxuICAgICAgICBTLlVJTWFuYWdlci5vcGVuUGFnZUluU2NlbmUoXHJcbiAgICAgICAgICAgIGxvZ2luVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGxvZ2luVUkuVUlMb2dpblBhZ2UsXHJcbiAgICAgICAgICAgIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gIFxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUksIFVuaXR5RW5naW5lIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBMb2dpbkFQSSB9IGZyb20gXCIuLi8uLi8uLi9hcGkvTG9naW5BUElcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IFZvU2VydmVyLCBWb1NlcnZlckl0ZW0gfSBmcm9tIFwiLi4vdm8vVm9TZXJ2ZXJcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWZcIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxvZ2luUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiYWNjb3VudFwiKVxyXG4gICAgcHVibGljIG1fYWNjb3VudDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG4gICAgQGJpbmRlcihcInBhc3N3b3JkXCIpXHJcbiAgICBwdWJsaWMgbV9wYXNzd29yZDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG5cclxuICAgIEBiaW5kZXIoXCJzZWxzZXJ2ZXJCdG5cIilcclxuICAgIHB1YmxpYyBtX3NlbHNlcnZlckJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJsb2dpbkJ0blwiKVxyXG4gICAgcHVibGljIG1fbG9naW5CdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBAYmluZGVyKFwic3RvcnlCdG5cIilcclxuICAgIHB1YmxpYyBtX3N0b3J5QnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcIm5ld0d1aWRlQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9uZXdHdWlkZUJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJob2xkXCIpXHJcbiAgICBwdWJsaWMgbV9ob2xkZXI6RmFpcnlHVUkuR0dyYXBoO1xyXG5cclxuICAgIHByaXZhdGUgZ2F0ZUlkOmFueTtcclxuICAgIHByaXZhdGUgZ2F0ZUtleTpudW1iZXJ8TG9uZztcclxuICAgIHByaXZhdGUgX2VmZmVjdEdvOmFueSA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG9uQXdha2UoKXtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2dpbkNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubV9zdG9yeUJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICBTLlVJTWFuYWdlci5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICAgICAgc3RvcnlVSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgICAgICBzdG9yeVVJLlVJU3RvcnlXaW4sXHJcbiAgICAgICAgICAgICAgICBudWxsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX25ld0d1aWRlQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgICAgICBjb21tb25VSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbW1vblVJLlVJVUlHdWlkZVdpbixcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TZWxTZXJ2ZXJXaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbGV0IGNvbm5lY3RlZCA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gdGhpcy5tX2xvZ2luQnRuLmVuYWJsZWQgPSBjb25uZWN0ZWQ7XHJcbiAgICAgICAgLy8gTG9nZ2VyLmxvZyhcImNvbm5lY3QgcmVhbSBzZXJ2ZXI6IFwiK2Nvbm5lY3RlZClcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHByaXZhdGUgb25TZWxlY3RTZXJ2ZXIoc2VydmVySXRlbTpWb1NlcnZlckl0ZW0pe1xyXG5cclxuICAgICAgICBMb2dnZXIubG9nKFwiIHNlcnZlciBzZWxlY3RlZDogXCIrc2VydmVySXRlbS5zZXJ2ZXJOYW1lKVxyXG4gICAgICAgIHRoaXMubV9zZWxzZXJ2ZXJCdG4udGV4dCA9IHNlcnZlckl0ZW0uc2VydmVyTmFtZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIG9uU2hvdyh2bzphbnkpe1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcblxyXG4gICAgICAgIC8v5Yqg6L2954m55pWIXHJcbiAgICAgICAgdGhpcy5fZWZmZWN0R28gPSBhd2FpdCBTLlJlc01hbmFnZXIubG9hZFByZWZhYihcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfcGV0X3JhbmtfeWVsbG93X3Rlc3QucHJlZmFiXCIpXHJcbiAgICAgICAgbGV0IGluc3QgPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKHRoaXMuX2VmZmVjdEdvKSBhcyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0O1xyXG4gICAgICAgIGxldCB3cmFwcGVyID0gbmV3IEZhaXJ5R1VJLkdvV3JhcHBlcihpbnN0KTtcclxuICAgICAgICB0aGlzLm1faG9sZGVyLlNldE5hdGl2ZU9iamVjdCh3cmFwcGVyKTtcclxuXHJcblxyXG4gICAgICAgICAvL+ebkeWQrOmAieacjea2iOaBr1xyXG4gICAgICAgICBTLlVJTWVzc2FnZU1hbmdlci5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICAgICAvL+WNuOi9vemTgeaViFxyXG4gICAgICAgIFMuUmVzTWFuYWdlci5yZWxlYXNlQWRkcmVzc0dPKHRoaXMuX2VmZmVjdEdvKTtcclxuXHJcbiAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIucmVtb3ZlTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0VMRUNUX1NFUlZFUixcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlclxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvcGVuU2VsU2VydmVyV2luKCl7XHJcblxyXG4gICAgICAgIC8vIOa1i+ivleaVsOaNrlxyXG4gICAgICAgIGxldCB2b1NlcnZlcjpWb1NlcnZlciA9IG5ldyBWb1NlcnZlcigpO1xyXG4gICAgICAgIGZvcihsZXQgaT0xOyBpPDEwOyBpKyspe1xyXG4gICAgICAgICAgICB2b1NlcnZlci5hcmVhTWFwLnNldChpLFwi5YiG5Yy6XCIraSk7XHJcbiAgICAgICAgICAgIHZvU2VydmVyLnNlcnZlck1hcC5zZXQoaSwgbmV3IEFycmF5PFZvU2VydmVySXRlbT4oKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGo9MTsgajwyMDA7IGorKyl7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHZvU2VydmVySXRlbTpWb1NlcnZlckl0ZW0gPSBuZXcgVm9TZXJ2ZXJJdGVtKCk7XHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uYXJlYUlkID0gaTtcclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5zZXJ2ZXJJZCA9IGo7XHJcblxyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLnNlcnZlck5hbWUgPSBcIua1i+ivleacjeWKoeWZqFwiK2krXCI6XCIrajtcclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5zZXJ2ZXJTdGF0dXMgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqMysxKTtcclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHZvU2VydmVyLnNlcnZlck1hcC5nZXQoaSkucHVzaCh2b1NlcnZlckl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBTLlVJTWFuYWdlci5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICBsb2dpblVJLlBhY2thZ2VOYW1lLCBcclxuICAgICAgICAgICAgbG9naW5VSS5VSVNlbFNlcnZlcldpbixcclxuICAgICAgICAgICAgdm9TZXJ2ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgYXN5bmMgb25Mb2dpbkNsaWNrKCl7XHJcblxyXG4gICAgICAgIGxldCBhY2NvdW50ID0gdGhpcy5tX2FjY291bnQudGV4dDtcclxuICAgICAgICBsZXQgcGFzc3dvcmQgPSB0aGlzLm1fcGFzc3dvcmQudGV4dDtcclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhgYWNjb3VudDoke2FjY291bnR9IC0gcGFzc3dvcmQ6ICR7cGFzc3dvcmR9YCk7XHJcblxyXG4gICAgICAgIFMuU2NlbmVNYW5hZ2VyLmxvYWRTY2VuZShTY2VuZURlZi5Ib21lU2NlbmUpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gaWYoYWNjb3VudCAhPSBcIlwiICYmIHBhc3N3b3JkICE9IFwiXCIpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAvLyAgICAgbGV0IG1zZyA9IGF3YWl0IExvZ2luQVBJLmxvZ2luUmVhbG1TZXJ2ZXIoYWNjb3VudCwgcGFzc3dvcmQpXHJcbiAgICAgICAgLy8gICAgIHRoaXMuZ2F0ZUlkID0gbXNnLkdhdGVJZDtcclxuICAgICAgICAvLyAgICAgdGhpcy5nYXRlS2V5ID0gbXNnLktleTtcclxuICAgICAgICAvLyAgICAgTG9nZ2VyLmxvZyhcImxvZ2luIHJlYW0gc3VjYywgZ2F0ZSBhZGRyOlwiK21zZy5BZGRyZXNzICsgXCIsa2V5OlwiK21zZy5LZXkpO1xyXG5cclxuICAgICAgICAvLyAgICAgUy5TZXNzaW9uTWFuYWdlci5kaXNjb25uZWN0UmVhbG1TZXJ2ZXIoKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgLy8gICAgIC8v55m75b2V572R5YWz5pyNXHJcbiAgICAgICAgLy8gICAgIGxldCBjb25uZWN0ZWQgPSBhd2FpdCBTLlNlc3Npb25NYW5hZ2VyLmNvbm5lY3RHYXRlU2VydmVyKG1zZy5BZGRyZXNzKTtcclxuICAgICAgICAvLyAgICAgaWYoY29ubmVjdGVkKXtcclxuICAgICAgICAvLyAgICAgICAgIExvZ2dlci5sb2coXCJjb25uZWN0IGdhdGUgc3VjY1wiKVxyXG5cclxuICAgICAgICAvLyAgICAgICAgIGxldCBtc2cgPSBhd2FpdCBMb2dpbkFQSS5sb2dpbkdhdGVTZXJ2ZXIoIHRoaXMuZ2F0ZUlkLCB0aGlzLmdhdGVLZXkpXHJcblxyXG4gICAgICAgIC8vICAgICAgICAgbGV0IHBsYXllcklEID0gbXNnLlBsYXllcklkO1xyXG4gICAgICAgIC8vICAgICAgICAgTG9nZ2VyLmxvZyhcImxvZ2luIGdhdGUgcmVzcG9uc2UuLlwiICtwbGF5ZXJJRCk7XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgUy5TY2VuZU1hbmFnZXIubG9hZFNjZW5lKFNjZW5lRGVmLkhvbWVTY2VuZSk7XHJcblxyXG4gICAgICAgIC8vICAgICB9ZWxzZXtcclxuICAgICAgICAvLyAgICAgTG9nZ2VyLmxvZyhcImNvbm5lY3QgZ2F0ZSBlcnIgXCIpXHJcbiAgICAgICAgLy8gICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8vICB9XHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJV2luZG93XCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBWb1NlcnZlciwgVm9TZXJ2ZXJJdGVtIH0gZnJvbSBcIi4uL3ZvL1ZvU2VydmVyXCI7XHJcbmltcG9ydCB7IFVJU2VydmVyTGlzdEl0ZW0gfSBmcm9tIFwiLi9VSVNlcnZlckxpc3RJdGVtXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSVNlbFNlcnZlcldpbiBleHRlbmRzIFVJV2luZG93e1xyXG5cclxuICAgIEBiaW5kZXIoXCJhcmVhTGlzdFwiKVxyXG4gICAgcHJpdmF0ZSBhcmVhTGlzdDpGYWlyeUdVSS5HTGlzdDtcclxuICAgIEBiaW5kZXIoXCJzZXJ2ZXJMaXN0XCIpXHJcbiAgICBwcml2YXRlIHNlcnZlckxpc3Q6RmFpcnlHVUkuR0xpc3Q7XHJcbiAgICBAYmluZGVyKFwiYmFja0J0blwiKVxyXG4gICAgcHJpdmF0ZSBiYWNrQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwib2tCdG5cIilcclxuICAgIHByaXZhdGUgb2tCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJ0aXRsZVwiKVxyXG4gICAgcHJpdmF0ZSB0aXRsZTpGYWlyeUdVSS5HTGFiZWw7XHJcblxyXG4gICAgcHJpdmF0ZSAgY2xpY2tBcmVhSW5kZXg6bnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgIGNsaWNrU2VydmVySW5kZXg6bnVtYmVyID0gMDtcclxuICAgIHByaXZhdGUgdm9TZXJ2ZXI6Vm9TZXJ2ZXI7XHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5iYWNrQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5va0J0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuYXJlYUxpc3Qub25DbGlja0l0ZW0uQWRkKChldmVudDpGYWlyeUdVSS5FdmVudENvbnRleHQpPT57XHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tBcmVhSW5kZXggPSB0aGlzLmFyZWFMaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB0aGlzLnNlcnZlckxpc3QubnVtSXRlbXMgPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyTGlzdC5SZWZyZXNoVmlydHVhbExpc3QoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xyXG5cclxuICAgICAgICAgICAgdGhpcy5jbGlja1NlcnZlckluZGV4ID0gdGhpcy5zZXJ2ZXJMaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRpdGxlLnRleHQgPSBcIuW3sumAieaLqeacjeWKoeWZqO+8mlwiK3RoaXMuY2xpY2tTZXJ2ZXJJbmRleDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgbGV0IHBvb2wgPSBbXTtcclxuICAgICAgIFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIG9uU2VsZWN0U2VydmVyKCl7XHJcblxyXG4gICAgICAgIGxldCBzZWxJdGVtOlZvU2VydmVySXRlbSA9IHRoaXMudm9TZXJ2ZXIuc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpW3RoaXMuY2xpY2tTZXJ2ZXJJbmRleF07XHJcblxyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmJyb2FkY2FzdChcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICBzZWxJdGVtXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KHZvOlZvU2VydmVyKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcbiAgICAgICAgdGhpcy52b1NlcnZlciA9IHZvO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFMaXN0LlNldFZpcnR1YWwoKTtcclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckFyZWFMaXN0SXRlbShpbmRleCwgb2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXJlYUxpc3QubnVtSXRlbXMgPSB2by5hcmVhTWFwLnNpemU7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5TZXRWaXJ0dWFsKCk7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpVSVNlcnZlckxpc3RJdGVtKT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4LCBvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm51bUl0ZW1zID0gdm8uc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlckFyZWFMaXN0SXRlbShpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KXtcclxuXHJcbiAgICAgICAgbGV0IGFyZWFCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcclxuICAgICAgICBhcmVhQnRuLnRleHQgPSB0aGlzLnZvU2VydmVyLmFyZWFNYXAuZ2V0KGluZGV4KzEpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4Om51bWJlciwgaXRlbTpVSVNlcnZlckxpc3RJdGVtKXtcclxuXHJcbiAgICAgICAgaWYoaXRlbSBpbnN0YW5jZW9mIFVJU2VydmVyTGlzdEl0ZW0pe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIjExMTExMTExMTExMTExMTExMTExMTFcIilcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCIzMzMzMzMzMzMzMzMzMzMzMzNcIilcclxuICAgICAgICB9XHJcbiAgICAgICAgaXRlbS5pdGVtTGFiZWwgPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKVtpbmRleF0uc2VydmVyTmFtZTtcclxuICAgICAgICAvL3NlcnZlckJ0bi5pY29uID0gRmFpcnlHVUkuVUlQYWNrYWdlLlxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XG5cbi8qKlxuICogXG4gKiAg5q2k5aSE5LmL5omA5Lul6KaB5byV55SoIFVJU2VydmVyTGlzdEl0ZW0g5a+56LGh77yM5piv5Zug5Li6IFY45LyaR0PmjonmraTlr7nosaHvvIwg5L2G5pivYyPnq6/noa7ku43nhLblrZjlnKjmraREZWxlZ2F0ZVxuICogIOazqOaEj++8muimgeWwhuWuj++8miBGQUlSWUdVSV9QVUVSVFMg5omT5byA5omN6IO95pyJ5pWI6YeK5pS+5byV55SoXG4gKiBcbiAqL1xubGV0IF9fY2FjaGVMaXN0SXRlbU1hcDpNYXA8bnVtYmVyLGFueT4gPSBuZXcgTWFwKCk7XG5sZXQgX19pZCA9IDA7XG5leHBvcnQgIGNsYXNzIFVJU2VydmVyTGlzdEl0ZW0gZXh0ZW5kcyBGYWlyeUdVSS5HQnV0dG9ue1xuXG4gICAgcHJpdmF0ZSBpdGVtaWQ6bnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG5cbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpc1tcIl9fb25EaXNwb3NlXCJdID0gKCkgPT4geyB0aGlzLm9uRGlzcG9zZSgpOyB9O1xuXG4gICAgICAgIF9faWQgKys7XG5cbiAgICAgICAgdGhpcy5pdGVtaWQgPSBfX2lkO1xuICAgICAgICBfX2NhY2hlTGlzdEl0ZW1NYXAuc2V0KHRoaXMuaXRlbWlkLCB0aGlzKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uRGlzcG9zZSgpe1xuICAgICAgICBfX2NhY2hlTGlzdEl0ZW1NYXAuZGVsZXRlKHRoaXMuaXRlbWlkKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGl0ZW1MYWJlbCh0eHQ6c3RyaW5nKXtcbiAgICAgICAgdGhpcy50ZXh0ID0gdHh0O1xuICAgIH1cblxufSAiLCJcblxuXG5leHBvcnQgY2xhc3MgVm9TZXJ2ZXJJdGVte1xuXG4gICAgcHVibGljIGFyZWFJZDpudW1iZXI7XG4gICAgcHVibGljIHNlcnZlcklkOm51bWJlcjtcbiAgICBwdWJsaWMgc2VydmVyTmFtZTpzdHJpbmc7XG4gICAgcHVibGljIHNlcnZlclN0YXR1czpudW1iZXI7XG59XG5cbmV4cG9ydCAgY2xhc3MgVm9TZXJ2ZXJ7XG5cbiAgICBwdWJsaWMgc2VydmVyTWFwOiBNYXA8bnVtYmVyLCBBcnJheTxWb1NlcnZlckl0ZW0+PiA9IG5ldyBNYXA8bnVtYmVyLCBBcnJheTxWb1NlcnZlckl0ZW0+PigpO1xuICAgIHB1YmxpYyBhcmVhTWFwOk1hcDxudW1iZXIsc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KCk7XG59IiwiaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmVcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUHZlU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkVudGVyKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ29tcGxldGUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25MZWF2ZSgpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xuaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xuaW1wb3J0IHsgU3RvcnlNZXNzYWdlTWFuYWdlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvaW5rL1N0b3J5TWVzc2FnZU1hbmFnZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlclwiO1xuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJV2luZG93XCI7XG5pbXBvcnQgeyBTfSBmcm9tIFwiLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcblxuZXhwb3J0IGNsYXNzIFVJU3RvcnlXaW4gZXh0ZW5kcyBVSVdpbmRvd3tcblxuICAgIEBiaW5kZXIoXCJzcGVha2VyVHh0XCIpXG4gICAgcHJpdmF0ZSBtX3NwZWFrZXJUeHQ6RmFpcnlHVUkuR1JpY2hUZXh0RmllbGQ7XG4gICAgQGJpbmRlcihcImJ0bkxpc3RcIilcbiAgICBwcml2YXRlIG1fYnRuTGlzdDpGYWlyeUdVSS5HTGlzdDtcblxuICAgIHByaXZhdGUgc2hvdWxkQ29udGluZVN0b3J5OmJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIG9wdGlvbnNNYXA6TWFwPG51bWJlcixzdHJpbmc+ID0gbmV3IE1hcDxudW1iZXIsc3RyaW5nPigpO1xuICAgIHByaXZhdGUgYWxsQ2hvaWNlczpDaG9pY2VbXTtcblxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xuXG4gICAgICAgIHRoaXMubV9idG5MaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KT0+e1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJCdG5MaXN0KGluZGV4LCBvYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tX2J0bkxpc3Qub25DbGlja0l0ZW0uQWRkKChldmVudDpGYWlyeUdVSS5FdmVudENvbnRleHQpPT57XG4gICAgICAgICAgICAgbGV0IGNsaWNrSWQ6bnVtYmVyID0gdGhpcy5tX2J0bkxpc3QuR2V0Q2hpbGRJbmRleChldmVudC5kYXRhKTtcbiAgICAgICAgICAgIGlmKHRoaXMuc2hvdWxkQ29udGluZVN0b3J5KXtcbiAgICAgICAgICAgICAgICBTLlN0b3J5TWFuYWdlci5hZHZhbmNlU3RvcnkoKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hcC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIFMuU3RvcnlNYW5hZ2VyLnNlbGVjdENob2ljZSh0aGlzLmFsbENob2ljZXNbY2xpY2tJZF0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vblNob3codm8pO1xuXG4gICAgICAgIFMuU3RvcnlNZXNzYWdlTWFuYWdlci5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DT05URU5UUkVBRFksXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PbkNvbnRlbnRSZWFkeVxuICAgICAgICApO1xuICAgICAgICBTLlN0b3J5TWVzc2FnZU1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ0hPSUNFU1BSRVNFTlRFRCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLk9uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICApO1xuICAgICAgICBTLlN0b3J5TWVzc2FnZU1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OU1RPUllGSU5JU0hFRCxcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB0aGlzLk9uU3RvcnlGaW5pc2hlZFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5vcHRpb25zTWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2hvdWxkQ29udGluZVN0b3J5ID0gZmFsc2U7XG5cbiAgICAgICAgUy5TdG9yeU1hbmFnZXIuYmVnaW5TdG9yeShcInN0b3J5MlwiKTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgT25Db250ZW50UmVhZHkoXG4gICAgICAgIHNwZWFrZXJDb250ZW50OnN0cmluZyxcbiAgICAgICAgc3BlYWtlcklkOnN0cmluZyxcbiAgICAgICAgY3VycmVudFRhZ3M6c3RyaW5nW10sXG4gICAgICAgIGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdKVxuICAgIHtcbiAgICAgICAgdGhpcy5tX3NwZWFrZXJUeHQudGV4dCA9IHNwZWFrZXJDb250ZW50O1xuXG4gICAgICAgIGlmKFMuU3RvcnlNYW5hZ2VyLmNhbkNvbnRpbnVlKXtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29udGluZVN0b3J5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5tX2J0bkxpc3QubnVtSXRlbXMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoY3VycmVudENob2ljZXMubGVuZ3RoPjApe1xuICAgICAgICAgICAgdGhpcy5hbGxDaG9pY2VzID0gY3VycmVudENob2ljZXM7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBsZXQgbGVuID0gY3VycmVudENob2ljZXMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yKGxldCBpPTA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFwLnNldChpLCBjdXJyZW50Q2hvaWNlc1tpXS50ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tX2J0bkxpc3QubnVtSXRlbXMgPSBsZW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlbmRlckJ0bkxpc3QoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCl7XG4gICAgICAgIGxldCBjb250aW51ZUJ0bjpGYWlyeUdVSS5HQnV0dG9uID0gb2JqLmFzQnV0dG9uO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5vcHRpb25zTWFwLnNpemU+MCl7XG4gICAgICAgICAgICBjb250aW51ZUJ0bi50ZXh0ID0gdGhpcy5vcHRpb25zTWFwLmdldChpbmRleCk7XG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb250aW51ZUJ0bi50ZXh0ID0gXCLngrnlh7vnu6fnu61cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgT25DaG9pY2VzUHJlc2VudGVkKGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdKXtcbiAgICAgIFxuICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IGZhbHNlO1xuICAgICAgICBMb2dnZXIubG9nKFwiLi4uLk9uQ2hvaWNlc1ByZXNlbnRlZC4uLi4uLlwiKVxuICAgIH1cblxuICAgIHByaXZhdGUgT25TdG9yeUZpbmlzaGVkKCk6dm9pZHtcblxuICAgICAgICBMb2dnZXIubG9nKFwiU3RvcnkgRmluaXNoZWRcIilcblxuICAgICAgICBTLlVJTWFuYWdlci5jbG9zZVdpbmRvdyhzdG9yeVVJLlVJU3RvcnlXaW4sbnVsbCk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XG5cbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNPTlRFTlRSRUFEWSxcbiAgICAgICAgICAgIHRoaXMuT25Db250ZW50UmVhZHlcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICB0aGlzLk9uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICApO1xuICAgICAgICBTLlN0b3J5TWVzc2FnZU1hbmFnZXIucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OU1RPUllGSU5JU0hFRCxcbiAgICAgICAgICAgIHRoaXMuT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICk7XG4gICAgfVxufSIsImltcG9ydCB7IEdhbWVPYmplY3RQb29sIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9jb21tb24vR2FtZU9iamVjdFBvb2xcIjtcclxuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvY29tbW9uL1Jlc01hbmFnZXJcIjtcclxuaW1wb3J0IHsgU3RvcnlNYW5hZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9pbmsvU3RvcnlNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL2luay9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IEdhbWVTZXNzaW9uIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9uZXQvR2FtZVNlc3Npb25cIjtcclxuaW1wb3J0IHsgSHR0cE1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL25ldC9IdHRwTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTZXNzaW9uTWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvbmV0L1Nlc3Npb25NYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFNjZW5lTWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVJTWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZU1hbmdlciB9IGZyb20gXCIuLi9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcclxuXHJcbmV4cG9ydCAgY2xhc3MgR2FtZUNvbmZpZ3tcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGRlYnVnOmJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhbG1TZXJ2ZXJJUDpzdHJpbmcgPSBcIjEyNy4wLjAuMVwiOyBcclxuICAgIHB1YmxpYyBzdGF0aWMgcmVhbG1TZXJ2ZXJQb3J0Om51bWJlciA9IDkwMDE7XHJcblxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgU3tcclxuICAgIHB1YmxpYyBzdGF0aWMgVUlNYW5hZ2VyID0gVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJTWVzc2FnZU1hbmdlciA9IFVJTWVzc2FnZU1hbmdlci5JbnN0YW5jZShVSU1lc3NhZ2VNYW5nZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBTY2VuZU1hbmFnZXIgPSBTY2VuZU1hbmFnZXIuSW5zdGFuY2UoU2NlbmVNYW5hZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgR2FtZU9iamVjdFBvb2wgPSBHYW1lT2JqZWN0UG9vbC5JbnN0YW5jZShHYW1lT2JqZWN0UG9vbCk7XHJcbiAgICBwdWJsaWMgc3RhdGljIFJlc01hbmFnZXIgPSBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBTdG9yeU1hbmFnZXIgPSBTdG9yeU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNYW5hZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU2Vzc2lvbk1hbmFnZXIgPSBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIEdhbWVTZXNzaW9uID0gR2FtZVNlc3Npb24uSW5zdGFuY2UoR2FtZVNlc3Npb24pO1xyXG4gICAgcHVibGljIHN0YXRpYyBTdG9yeU1lc3NhZ2VNYW5hZ2VyID0gU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgSHR0cE1hbmFnZXIgPSBIdHRwTWFuYWdlci5JbnN0YW5jZShIdHRwTWFuYWdlcik7XHJcbn1cclxuIiwiXHJcblxyXG5pbXBvcnQge1NpbmdsZXRvbn0gZnJvbSAnLi4vZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b24nO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlcic7XHJcblxyXG5leHBvcnQgY2xhc3MgU2luZ2xldG9uVGVzdCBleHRlbmRzIFNpbmdsZXRvbjxTaW5nbGV0b25UZXN0PntcclxuXHJcbiAgICBwcml2YXRlIG51bTpudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlNpbmdsZXRvblRlc3QgY2FsbCBjb25zdHJ1Y3RvclwiKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKCkgOiB2b2lkIHtcclxuXHJcbiAgICAgICAgdGhpcy5udW0gKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdGVzdCgpIDogbnVtYmVye1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5udW07XHJcblxyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7VGltZVV0aWx9IGZyb20gJy4uL2ZyYW1ld29yay91dGlsL1RpbWVVdGlsJztcclxuaW1wb3J0IHtTaW5nbGV0b25UZXN0fSBmcm9tICcuL1NpbmdsZXRvblRlc3QnO1xyXG5pbXBvcnQge01lc3Nlbmdlcn0gZnJvbSAnLi4vZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXInO1xyXG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSAnLi4vZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyJztcclxuaW1wb3J0IHsgU2tpbGxDb25maWdUQiwgU2tpbGxDb25maWdUUiB9IGZyb20gJy4uL2RhdGEvZXhjZWwvU2tpbGxDb25maWcnO1xyXG5pbXBvcnQgeyBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyIH0gZnJvbSAnLi4vZnJhbWV3b3JrL3JlZGhpbnRzL1JlZEhpbnRzTWVzc2FnZU1hbmFnZXInO1xyXG5pbXBvcnQgeyBlbnVtUmVkSGludHMsIFJlZEhpbnRzTWFuYWdlciB9IGZyb20gJy4uL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01hbmFnZXInO1xyXG5pbXBvcnQgeyBTdG9yeSB9IGZyb20gJ2lua2pzJztcclxuaW1wb3J0IHsgbmljZV90cyB9IGZyb20gJy4uL2RhdGEvcGIvZ2VuL3BiJztcclxuaW1wb3J0IHsgUyB9IGZyb20gJy4uL2dsb2JhbC9HYW1lQ29uZmlnJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXInO1xyXG5pbXBvcnQgeyBQbGF5ZXJNYW5hZ2VyIH0gZnJvbSAnLi4vZ2FtZS9lbnRpdHkvUGxheWVyTWFuYWdlcic7XHJcbmltcG9ydCB7IEJhZ0NvbXBvbmVudCB9IGZyb20gJy4uL2dhbWUvZW50aXR5L2NvbXBvbmVudC9CYWdDb21wb25lbnQnO1xyXG5pbXBvcnQgeyBQbGF5ZXJJbmZvQ29tcG9uZW50IH0gZnJvbSAnLi4vZ2FtZS9lbnRpdHkvY29tcG9uZW50L1BsYXllckluZm9Db21wb25lbnQnO1xyXG5pbXBvcnQgeyBUZXN0QywgVGVzdFAgfSBmcm9tICdjc2hhcnAnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVbml0VGVzdHtcclxuICAgIHB1YmxpYyBzdGF0aWMgdGVzdFZhcjpudW1iZXIgPSAxMDAwMDtcclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBkb1Rlc3QoKXtcclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlRpbWVVdGlsID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIFRpbWVVdGlsLnRlc3QoKTtcclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlNpbmdsZXRvbiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBTaW5nbGV0b25UZXN0Lkluc3RhbmNlKFNpbmdsZXRvblRlc3QpO1xyXG4gICAgICAgIExvZ2dlci5sb2coXCI9PT1cIik7XHJcbiAgICAgICAgbGV0IHQxOiBTaW5nbGV0b25UZXN0ID0gU2luZ2xldG9uVGVzdC5JbnN0YW5jZShTaW5nbGV0b25UZXN0KTtcclxuICAgICAgICBsZXQgdDI6IFNpbmdsZXRvblRlc3QgPSBTaW5nbGV0b25UZXN0Lkluc3RhbmNlKFNpbmdsZXRvblRlc3QpO1xyXG5cclxuICAgICAgICBMb2dnZXIubG9nKHQxLnRlc3QoKSArIFwiIDogXCIgKyB0Mi50ZXN0KCkpO1xyXG4gICAgICAgIHQxLmFkZCgpO1xyXG4gICAgICAgIExvZ2dlci5sb2codDEudGVzdCgpICsgXCIgOiBcIiArIHQyLnRlc3QoKSk7XHJcbiAgICAgICAgdDIuYWRkKCk7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyh0MS50ZXN0KCkgKyBcIiA6IFwiICsgdDIudGVzdCgpKTtcclxuXHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coXCJNZXNzYWdlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgbGV0IG1lc3NlbmdlcjpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XHJcbiAgICAgICAgbGV0IGxpc3RlbjpGdW5jdGlvbiA9IGZ1bmN0aW9uKGE6bnVtYmVyLCBiOnN0cmluZyl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coYGxpc3RlbiBjYWxsOiAke2F9ICwgJHtifWApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsaXN0ZW4yOkZ1bmN0aW9uID0gZnVuY3Rpb24oYTpudW1iZXIsIGI6c3RyaW5nKXtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhgbGlzdGVuIGNhbGwyOiAke2F9ICwgJHtifWApXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgIEVWRU5UX0NPREU6bnVtYmVyID0gMTAwO1xyXG4gICAgICAgIG1lc3Nlbmdlci5hZGRMaXN0ZW5lcihFVkVOVF9DT0RFLHRoaXMsIGxpc3Rlbik7XHJcbiAgICAgICAgbWVzc2VuZ2VyLmFkZExpc3RlbmVyKEVWRU5UX0NPREUsdGhpcywgbGlzdGVuMik7XHJcbiAgICAgICAgbWVzc2VuZ2VyLmJyb2FkY2FzdChFVkVOVF9DT0RFLCA5OTksXCIgSGVsbG9cIik7XHJcblxyXG4gICAgICAgIG1lc3Nlbmdlci5yZW1vdmVMaXN0ZW5lcihFVkVOVF9DT0RFLGxpc3Rlbik7XHJcbiAgICAgICAgbWVzc2VuZ2VyLmJyb2FkY2FzdChFVkVOVF9DT0RFLCA5OTksXCIgSGVsbG9cIik7XHJcblxyXG4gICAgICAgIG1lc3Nlbmdlci5jbGVhcnVwKCk7XHJcbiAgICAgICAgbWVzc2VuZ2VyLmJyb2FkY2FzdChFVkVOVF9DT0RFLCA5OTksXCIgSGVsbG9cIik7XHJcblxyXG5cclxuICAgICAgICBMb2dnZXIubG9nKFwiVGltZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJpbnRlciB2YWwuLlwiKVxyXG4gICAgICAgIH0sMTAwMCk7XHJcbiAgICAgICAgbGV0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpPT57XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH0sNTAwMCk7IFxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlJlc291cmNlTWFuYWdlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAvLyBsZXQgcHJlZmFiID0gYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkUHJlZmFiKFwiTW9kZWxzLzEwMDEvQ2hhcmFjdGVyLnByZWZhYlwiKSA7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9Mb2dnZXIubG9nKHByZWZhYik7XHJcblxyXG4gICAgICAgIC8vbGV0IGluc3QgPSBDUy5Vbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKHByZWZhYik7XHJcbiAgICAgICAgLy9pbnN0Lm5hbWUgPSBcIlRlc3QgQ2hcIjtcclxuXHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coXCLlvJXnlKjnsbvlnosgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgbGV0IHRlc3RNYXA6TWFwPHN0cmluZyxBcnJheTxudW1iZXI+PiA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0ZXN0TWFwLnNldChcImtleTFcIiAsbmV3IEFycmF5KCkpO1xyXG5cclxuICAgICAgICBsZXQgYXJyMTpBcnJheTxudW1iZXI+ID0gdGVzdE1hcC5nZXQoXCJrZXkxXCIpO1xyXG4gICAgICAgIGFycjEucHVzaCgxMik7XHJcbiAgICAgICAgYXJyMS5wdXNoKDMzMyk7XHJcblxyXG4gICAgICAgIGxldCBhcnIyOkFycmF5PG51bWJlcj4gPSB0ZXN0TWFwLmdldChcImtleTFcIik7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhhcnIyKTtcclxuXHJcblxyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJGYXJpeUdVSSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICAvLyAgbGV0IHBhZ2U6VUlfTG9naW5QYWdlID0gbmV3IFVJX0xvZ2luUGFnZSgpO1xyXG4gICAgICAgIC8vICBDUy5GYWlyeUdVSS5HUm9vdC5pbnN0LkFkZENoaWxkKHBhZ2UuX3VpKTtcclxuICAgICAgICAvLyAgTG9nZ2VyLmxvZyhwYWdlLl91aSk7XHJcblxyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJNb2R1bGVNYW5hZ2VyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICAvLyBNb2R1bGVNYW5hZ2VyLkluc3RhbmNlKE1vZHVsZU1hbmFnZXIpLmNyZWF0ZU1vZHVsZShNb2R1bGVEZWYuTG9naW5Nb2R1bGUsXCJjcmVhdGUgbG9naW5cIik7XHJcblxyXG4gICAgICAgIC8vIE1vZHVsZU1hbmFnZXIuSW5zdGFuY2UoTW9kdWxlTWFuYWdlcikuc2VuZE1lc3NhZ2UoTW9kdWxlRGVmLkxvZ2luTW9kdWxlLCBcInRlc3QxXCIsMjIzMyk7XHJcbiAgICAgICAgLy8gTW9kdWxlTWFuYWdlci5JbnN0YW5jZShNb2R1bGVNYW5hZ2VyKS5zZW5kTWVzc2FnZShNb2R1bGVEZWYuSG9tZU1vZHVsZSwgXCJ0ZXN0MlwiLDIyMzMpO1xyXG4gICAgICAgIC8vIExvZ2dlci5sb2coXCJ0aGVuIGNyZWF0ZSBIb21lXCIpO1xyXG4gICAgICAgIC8vIE1vZHVsZU1hbmFnZXIuSW5zdGFuY2UoTW9kdWxlTWFuYWdlcikuY3JlYXRlTW9kdWxlKE1vZHVsZURlZi5Ib21lTW9kdWxlLFwiY3JlYXRlIGxvZ2luXCIpO1xyXG4gICAgXHJcbiAgICAgICAgXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlVJTWFuYWdlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICBMb2dnZXIubG9nKFwiZXhjZWwgZGF0YSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBsZXQgc2tpbGxNYXAgPSBTa2lsbENvbmZpZ1RCLkluc3RhbmNlKFNraWxsQ29uZmlnVEIpLnRycztcclxuICAgICAgICBsZXQgc2tpbGx0cjpTa2lsbENvbmZpZ1RSID0gc2tpbGxNYXAuZ2V0KDEwMDMpO1xyXG4gICAgICAgIExvZ2dlci5sb2coYCR7c2tpbGx0ci5fTmFtZX0gOiAke3NraWxsdHIuX0F0dGFja1R5cGV9YClcclxuICAgICAgICBsZXQgaW1wYWN0dHlwZSA9IHNraWxsdHIuX0ltcGFjdFR5cGU7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhpbXBhY3R0eXBlKTtcclxuXHJcblxyXG5cclxuICAgICAgICBMb2dnZXIubG9nKFwiUHJvdG9idWYgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IGMyckxvZ2luID0ge1xyXG4gICAgICAgICAgICAgICAgXCJBY2NvdW50XCIgOiBcInRlc3RcIixcclxuICAgICAgICAgICAgICAgIFwiUGFzc3dvcmRcIiA6IFwiMTIzNFwiXHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAgICAgLy/pqozor4FcclxuICAgICAgICAgICAgbGV0IHYxID0gbmljZV90cy5DMlJfTG9naW4udmVyaWZ5KGMyckxvZ2luKTtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhcInZlcmlmeSBwYjogXCIrIHYxKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyUl9Mb2dpbi5jcmVhdGUoYzJyTG9naW4pXHJcbiAgICAgICAgICAgIG1zZy5BY2NvdW50ID0gXCJ0ZXN0MVwiXHJcbiAgICAgICAgICAgIG1zZy5QYXNzd29yZCA9IFwiMTEyMlwiXHJcbiAgICAgICAgICAgIExvZ2dlci5sb2cobXNnKVxyXG5cclxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5pY2VfdHMuQzJSX0xvZ2luLmVuY29kZShtc2cpLmZpbmlzaCgpXHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coYnVmKVxyXG5cclxuICAgICAgICAgICAgbGV0IGRlX2J1ZiA9IG5pY2VfdHMuQzJSX0xvZ2luLmRlY29kZShidWYpXHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coZGVfYnVmLkFjY291bnQpXHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coZGVfYnVmLlBhc3N3b3JkKVxyXG5cclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhleCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIlVpbnRBcnJheSA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgbGV0ICBvcGNvZGVfYXJyID0gbmV3IFVpbnQ4QXJyYXkoWzI1NywyNV0pO1xyXG4gICAgICAgIExvZ2dlci5sb2cob3Bjb2RlX2Fyci5zdWJhcnJheSgwLDEpKTtcclxuICAgICAgICBMb2dnZXIubG9nKG9wY29kZV9hcnIubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgbGV0IG9wY29kZV9hcnIyID0gbmV3IFVpbnQ4QXJyYXkoWzMzXSk7XHJcblxyXG4gICAgICAgIC8v5ZCI5bm2IFVpbnQ4QXJyYXlcclxuICAgICAgICBsZXQgbWVyZ2VfYXJyID0gbmV3IFVpbnQ4QXJyYXkob3Bjb2RlX2Fyci5sZW5ndGggKyBvcGNvZGVfYXJyMi5sZW5ndGgpO1xyXG4gICAgICAgIG1lcmdlX2Fyci5zZXQob3Bjb2RlX2FycjIpO1xyXG4gICAgICAgIG1lcmdlX2Fyci5zZXQob3Bjb2RlX2Fyciwgb3Bjb2RlX2FycjIubGVuZ3RoKTtcclxuICAgICAgICBMb2dnZXIubG9nKG1lcmdlX2Fyci5sZW5ndGgpO1xyXG4gICAgIFxyXG4gICAgICAgIGxldCBuOm51bWJlciA9IDU2Nzg7XHJcbiAgICAgICAgbGV0IGJ1ZmZlcjpVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XHJcblxyXG4gICAgICAgIC8vIDw8IOW3puenuyAgPj4g5Y+z56e7ICA+Pj4g5peg56ym5Y+35Y+z56e7XHJcbiAgICAgICAgLy9u6L2sdWludDhBcnJheVxyXG4gICAgICAgIGJ1ZmZlclswXSA9IG4gPj4+IDI0O1xyXG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gPj4+IDE2O1xyXG4gICAgICAgIGJ1ZmZlclsyXSA9IG4gPj4+IDg7XHJcbiAgICAgICAgYnVmZmVyWzNdID0gbiAmIDB4ZmY7XHJcblxyXG5cclxuICAgICAgICAvL3VuaXQ4QXJyYXnovaxuXHJcbiAgICAgICAgbiA9IGJ1ZmZlclswXSA8PCAyNCB8IGJ1ZmZlclsxXSA8PCAxNiB8IGJ1ZmZlclsyXSA8PCA4IHwgYnVmZmVyWzNdO1xyXG4gICAgICAgIExvZ2dlci5sb2cobik7XHJcblxyXG5cclxuICAgICAgICBuID0gMzAwO1xyXG4gICAgICAgIGxldCBidWZmZXIxOlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyKTtcclxuICAgICAgICBidWZmZXIxWzBdID0gbiA+Pj4gODtcclxuICAgICAgICBidWZmZXIxWzFdID0gbiAmIDB4ZmY7XHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coYnVmZmVyMSk7XHJcbiAgICAgICAgbiA9IGJ1ZmZlcjFbMF08PDggfCBidWZmZXIxWzFdO1xyXG4gICAgICAgIExvZ2dlci5sb2cobik7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgIExvZ2dlci5sb2coXCJzbGVlcCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBhd2FpdCBUaW1lVXRpbC5zbGVlcCgxMDAwKTtcclxuICAgICAgICBMb2dnZXIubG9nKFwic2xlZXAgLi5lbmRcIik7XHJcblxyXG5cclxuICAgICAgICAvLyBMb2dnZXIubG9nKFwiZmxhdGJ1ZmZlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICAvLyB0cnl7XHJcbiAgICAgICAgLy8gICAgIGxldCBieXRlczpBcnJheUJ1ZmZlciA9IGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFRleHRCeXRlcyhcIkNvbmZpZy9mYi91bml0Y29uZmlnLmJ5dGVzXCIpXHJcbiAgICAgICAgLy8gICAgIGxldCB1bml0Qnl0ZSA9IG5ldyBmbGF0YnVmZmVycy5CeXRlQnVmZmVyKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XHJcbiAgICAgICAgLy8gICAgIExvZ2dlci5sb2codW5pdEJ5dGUpO1xyXG4gICAgICAgIC8vICAgICBsZXQgdW5pdGNvbmZpZzpmYi51bml0Y29uZmlnVEIgPSBmYi51bml0Y29uZmlnVEIuZ2V0Um9vdEFzdW5pdGNvbmZpZ1RCKHVuaXRCeXRlKVxyXG4gICAgICAgIC8vICAgICBMb2dnZXIubG9nKHVuaXRjb25maWcudW5pdGNvbmZpZ1RSU0xlbmd0aCgpKTtcclxuICAgICAgICAgICAgXHJcbiAgICBcclxuICAgICAgICAvLyAgICAgZm9yKGxldCBpPTA7IGk8dW5pdGNvbmZpZy51bml0Y29uZmlnVFJTTGVuZ3RoKCk7IGkrKyl7XHJcbiAgICAgICAgLy8gICAgICAgICBsZXQgYSA9ICB1bml0Y29uZmlnLnVuaXRjb25maWdUUlMoaSk7XHJcbiAgICAgICAgLy8gICAgICAgICBMb2dnZXIubG9nKGEuTmFtZSgpKTtcclxuICAgICAgICAvLyAgICAgfVxyXG5cclxuICAgICAgICAvLyB9Y2F0Y2goZXgpe1xyXG4gICAgICAgIC8vICAgICBMb2dnZXIuZXJyb3IoZXgpO1xyXG4gICAgICAgIC8vIH1cclxuXHJcblxyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCLmtYvor5XnuqLngrnns7vnu58gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgICAgICBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKFwicmVkIGhpbnRzIGNoYXQuLi5cIik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNZXNzYWdlTWFuYWdlcikuYWRkTGlzdGVuZXIoXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdF9mYW1pbHksXHJcbiAgICAgICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKFwicmVkIGhpbnRzIGNoYXRfZmFtaWx5Li4uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRfc3lzdGVtLFxyXG4gICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhcInJlZCBoaW50cyBjaGF0Li4uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgUmVkSGludHNNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWFuYWdlcikuc2V0UmVkSGludE9wZW5PckNsb3NlKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRfZmFtaWx5LCB0cnVlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGxldCByX2NoYXQgPSBSZWRIaW50c01hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNYW5hZ2VyKS5jaGVja1JlZElzT3BlbihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0XHJcbiAgICAgICAgICAgICkgO1xyXG4gICAgICAgICAgICBsZXQgcl9jaGF0X2ZhbWlseSA9IFJlZEhpbnRzTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01hbmFnZXIpLmNoZWNrUmVkSXNPcGVuKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRfZmFtaWx5XHJcbiAgICAgICAgICAgICkgO1xyXG4gICAgICAgICAgICBsZXQgcl9jaGF0X3N5c3RlbSA9IFJlZEhpbnRzTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01hbmFnZXIpLmNoZWNrUmVkSXNPcGVuKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRfc3lzdGVtXHJcbiAgICAgICAgICAgICkgO1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKHJfY2hhdCwgcl9jaGF0X2ZhbWlseSwgcl9jaGF0X3N5c3RlbSlcclxuXHJcbiAgICAgICAgfWNhdGNoKGVycm9yKXtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhlcnJvcilcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJJbmsgU3RvcnkgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG5cclxuICAgICAgICAgICAgdmFyIGpzb24gPSBhd2FpdCAoYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkVGV4dEFzc2V0KFwiU3RvcnkvVGVzdFN0b3J5Lmpzb25cIikpLnRleHQ7XHJcbiAgICAgICAgICAgIGxldCBzdG9yeSA9IG5ldyBTdG9yeShqc29uKTtcclxuICAgICAgICAgICAgc3RvcnkuQ2hvb3NlUGF0aFN0cmluZyhcInN0b3J5MVwiLCB0cnVlKTtcclxuICAgICAgICAgICAgc3RvcnkuQmluZEV4dGVybmFsRnVuY3Rpb24oXCJHZXRDaGFyYWN0ZXJOYW1lXCIsKCk9PntcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIkp1c3RpbiBUZXN0XCI7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIHN0b3J5LkJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChcIkdldENoYXJhY3Rlck5hbWVCeU11dGlQYXJhbXNcIiwoYXJnczpbXSk9PntcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coYXJncy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiVFRUVFwiO1xyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhzdG9yeS5Db250aW51ZSgpKTtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhzdG9yeS5Db250aW51ZSgpKTtcclxuICAgICAgICAgICAgTG9nZ2VyLmxvZyhzdG9yeS5Db250aW51ZSgpKTtcclxuICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKGVycm9yKVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIExvZ2dlci5sb2coXCJIdHRwTWFuYWdlcj09PT09PT09PT09PT09PT09PT09PT09PT1cIilcclxuXHJcbiAgICAgICAgbGV0IHR4dCA9IGF3YWl0IFMuSHR0cE1hbmFnZXIuZ2V0KFwiaHR0cHM6Ly93d3cuYmFpZHUuY29tL1wiKTtcclxuICAgICAgICBMb2dnZXIubG9nKHR4dCk7XHJcblxyXG4gICAgICAgIFxyXG4gICAgICAgICAvL0xvZ2dlci5sb2coXCJlbnRpdHk9PT09PT09PT09PT09PT09PT09PT09PT09XCIpXHJcblxyXG4gICAgICAgICBsZXQgcGxheWVyID0gUGxheWVyTWFuYWdlci5JbnN0YW5jZShQbGF5ZXJNYW5hZ2VyKS5nZXRQbGF5ZXIoKTtcclxuICAgICAgICAgbGV0IGJhZ0MgPSAgcGxheWVyLmFkZENvbXBvbmVudDxCYWdDb21wb25lbnQ+KEJhZ0NvbXBvbmVudCk7XHJcbiAgICAgICAgIC8vTG9nZ2VyLmxvZyhiYWdDLm5hbWUpO1xyXG4gXHJcbiAgICAgICAgIGxldCBpbmZvQyA9IHBsYXllci5hZGRDb21wb25lbnQ8UGxheWVySW5mb0NvbXBvbmVudD4oUGxheWVySW5mb0NvbXBvbmVudCk7XHJcbiAgICAgICAgIC8vTG9nZ2VyLmxvZyhpbmZvQy5uaWNrTmFtZSk7XHJcbiBcclxuICAgICAgICAgLy/mtYvor5Xkuovku7ZcclxuICAgICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50KCk7XHJcbiAgICAgICAgIGV2ZW50Lm5hbWUgPSBcImhlbGxvRXZlbnRcIlxyXG4gXHJcbiAgICAgICAgIC8vTGFtYmRhIOihqOi+vuW8j+iuoumYhVxyXG4gICAgICAgICBiYWdDLnN1YnNjcmliZTxFdmVudD4oXHJcbiAgICAgICAgICAgICAoZSk9PntcclxuICAgICAgICAgICAgICAgICAvL0xvZ2dlci5sb2coXCJFdmVudCB0cmlnZ2VyOlwiK2UubmFtZSlcclxuICAgICAgICAgICAgIH0sIEV2ZW50KVxyXG4gICAgICAgICBcclxuICAgICAgICAgbGV0IHRyaWdnZXIyID0gKGU6RXZlbnQpPT57XHJcbiAgICAgICAgICAgICAvL0xvZ2dlci5sb2coXCJFdmVudCB0cmlnZ2VyMjpcIitlLm5hbWUpXHJcbiAgICAgICAgIH1cclxuIFxyXG4gICAgICAgICAvL+iuoumYhVxyXG4gICAgICAgICBiYWdDLnN1YnNjcmliZTxFdmVudD4odHJpZ2dlcjIsIEV2ZW50KVxyXG4gICAgICAgICAvL+WPlua2iOiuoumYhVxyXG4gICAgICAgICBiYWdDLnVuU3Vic2NyaWJlPEV2ZW50Pih0cmlnZ2VyMiwgRXZlbnQpO1xyXG4gXHJcbiAgICAgICAgIGJhZ0MucHVibGlzaDxFdmVudD4oZXZlbnQsIEV2ZW50KTtcclxuXHJcblxyXG4gICAgICAgIC8vdGVzdCBkZWxlZ2F0ZVxyXG4gICAgICAgIFRlc3RDLlNldFBhY2thZ2VJdGVtRXh0ZW5zaW9uKG5ldyBUVGVzdEMoKSlcclxuXHJcbiAgICAgICAgc2V0SW50ZXJ2YWwoKCk9PntcclxuXHJcbiAgICAgICAgICAgIGxldCBwID0gVGVzdEMuZ2V0T2JqKCk7XHJcblxyXG4gICAgICAgICAgICBpZihwIGluc3RhbmNlb2YgVFRlc3RDKXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYWFhYWFhYWFhYWFhYWFhYVwiKVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiYmJiYmJiYmJiYmJiYmJiYmJiYmJcIilcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9LDEwMDApXHJcbiBcclxuICAgIH1cclxuXHJcblxyXG59XHJcblxyXG5jbGFzcyBUVGVzdEMgZXh0ZW5kcyBUZXN0UHtcclxuXHJcbiAgICBwdWJsaWMgdGVzdCgpe1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaGVsbG8gdGVzdCBkZWxlZ2F0ZVwiKVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBFdmVudHtcclxuICAgIGlkOm51bWJlcjtcclxuICAgIG5hbWU6c3RyaW5nO1xyXG59XHJcblxyXG5cclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3NoYXJwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInB1ZXJ0c1wiKTsiXSwic291cmNlUm9vdCI6IiJ9