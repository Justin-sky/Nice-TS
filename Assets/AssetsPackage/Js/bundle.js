/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/GameMain.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/inkjs/dist/ink-es2015.js":
/*!***********************************************!*\
  !*** ./node_modules/inkjs/dist/ink-es2015.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,e){ true?e(exports):undefined}(this,(function(t){"use strict";class e{constructor(){if(this._components=[],this._componentsString=null,this._isRelative=!1,"string"==typeof arguments[0]){let t=arguments[0];this.componentsString=t}else if(arguments[0]instanceof e.Component&&arguments[1]instanceof e){let t=arguments[0],e=arguments[1];this._components.push(t),this._components=this._components.concat(e._components)}else if(arguments[0]instanceof Array){let t=arguments[0],e=!!arguments[1];this._components=this._components.concat(t),this._isRelative=e}}get isRelative(){return this._isRelative}get componentCount(){return this._components.length}get head(){return this._components.length>0?this._components[0]:null}get tail(){if(this._components.length>=2){let t=this._components.slice(1,this._components.length);return new e(t)}return e.self}get length(){return this._components.length}get lastComponent(){let t=this._components.length-1;return t>=0?this._components[t]:null}get containsNamedComponent(){for(let t=0,e=this._components.length;t<e;t++)if(!this._components[t].isIndex)return!0;return!1}static get self(){let t=new e;return t._isRelative=!0,t}GetComponent(t){return this._components[t]}PathByAppendingPath(t){let n=new e,i=0;for(let e=0;e<t._components.length&&t._components[e].isParent;++e)i++;for(let t=0;t<this._components.length-i;++t)n._components.push(this._components[t]);for(let e=i;e<t._components.length;++e)n._components.push(t._components[e]);return n}get componentsString(){return null==this._componentsString&&(this._componentsString=this._components.join("."),this.isRelative&&(this._componentsString="."+this._componentsString)),this._componentsString}set componentsString(t){if(this._components.length=0,this._componentsString=t,null==this._componentsString||""==this._componentsString)return;"."==this._componentsString[0]&&(this._isRelative=!0,this._componentsString=this._componentsString.substring(1));let n=this._componentsString.split(".");for(let t of n)/^(\-|\+)?([0-9]+|Infinity)$/.test(t)?this._components.push(new e.Component(parseInt(t))):this._components.push(new e.Component(t))}toString(){return this.componentsString}Equals(t){if(null==t)return!1;if(t._components.length!=this._components.length)return!1;if(t.isRelative!=this.isRelative)return!1;for(let e=0,n=t._components.length;e<n;e++)if(!t._components[e].Equals(this._components[e]))return!1;return!0}PathByAppendingComponent(t){let n=new e;return n._components.push.apply(n._components,this._components),n._components.push(t),n}}var n,i,r;function a(t,e){return t instanceof e?h(t):null}function s(t,e){if(t instanceof e)return h(t);throw new Error(`${t} is not of type ${e}`)}function l(t){return t.hasValidName&&t.name?t:null}function o(t){return void 0===t?null:t}function u(t){return"object"==typeof t&&"function"==typeof t.Equals}function h(t,e){return t}e.parentId="^",function(t){class e{constructor(t){this.index=-1,this.name=null,"string"==typeof t?this.name=t:this.index=t}get isIndex(){return this.index>=0}get isParent(){return this.name==t.parentId}static ToParent(){return new e(t.parentId)}toString(){return this.isIndex?this.index.toString():this.name}Equals(t){return null!=t&&t.isIndex==this.isIndex&&(this.isIndex?this.index==t.index:this.name==t.name)}}t.Component=e}(e||(e={})),function(t){function e(t,e){if(!t)throw void 0!==e&&console.warn(e),console.trace&&console.trace(),new Error("")}t.AssertType=function(t,n,i){e(t instanceof n,i)},t.Assert=e}(n||(n={}));class c extends Error{}function d(t){throw new c(t+" is null or undefined")}class p{constructor(){this.parent=null,this._debugMetadata=null,this._path=null}get debugMetadata(){return null===this._debugMetadata&&this.parent?this.parent.debugMetadata:this._debugMetadata}set debugMetadata(t){this._debugMetadata=t}get ownDebugMetadata(){return this._debugMetadata}DebugLineNumberOfPath(t){if(null===t)return null;let e=this.rootContentContainer;if(e){let n=e.ContentAtPath(t).obj;if(n){let t=n.debugMetadata;if(null!==t)return t.startLineNumber}}return null}get path(){if(null==this._path)if(null==this.parent)this._path=new e;else{let t=[],n=this,i=a(n.parent,N);for(;null!==i;){let r=l(n);null!=r&&r.hasValidName?t.unshift(new e.Component(r.name)):t.unshift(new e.Component(i.content.indexOf(n))),n=i,i=a(i.parent,N)}this._path=new e(t)}return this._path}ResolvePath(t){if(null===t)return d("path");if(t.isRelative){let e=a(this,N);return null===e&&(n.Assert(null!==this.parent,"Can't resolve relative path because we don't have a parent"),e=a(this.parent,N),n.Assert(null!==e,"Expected parent to be a container"),n.Assert(t.GetComponent(0).isParent),t=t.tail),null===e?d("nearestContainer"):e.ContentAtPath(t)}{let e=this.rootContentContainer;return null===e?d("contentContainer"):e.ContentAtPath(t)}}ConvertPathToRelative(t){let n=this.path,i=Math.min(t.length,n.length),r=-1;for(let e=0;e<i;++e){let i=n.GetComponent(e),a=t.GetComponent(e);if(!i.Equals(a))break;r=e}if(-1==r)return t;let a=n.componentCount-1-r,s=[];for(let t=0;t<a;++t)s.push(e.Component.ToParent());for(let e=r+1;e<t.componentCount;++e)s.push(t.GetComponent(e));return new e(s,!0)}CompactPathString(t){let e=null,n=null;if(t.isRelative)n=t.componentsString,e=this.path.PathByAppendingPath(t).componentsString;else{n=this.ConvertPathToRelative(t).componentsString,e=t.componentsString}return n.length<e.length?n:e}get rootContentContainer(){let t=this;for(;t.parent;)t=t.parent;return a(t,N)}Copy(){throw Error("Not Implemented: Doesn't support copying")}SetChild(t,e,n){t[e]&&(t[e]=null),t[e]=n,t[e]&&(t[e].parent=this)}}class m{constructor(t){t=void 0!==t?t.toString():"",this.string=t}get Length(){return this.string.length}Append(t){null!==t&&(this.string+=t)}AppendLine(t){void 0!==t&&this.Append(t),this.string+="\n"}AppendFormat(t,...e){this.string+=t.replace(/{(\d+)}/g,(t,n)=>void 0!==e[n]?e[n]:t)}toString(){return this.string}}class f{constructor(){if(this.originName=null,this.itemName=null,void 0!==arguments[1]){let t=arguments[0],e=arguments[1];this.originName=t,this.itemName=e}else if(arguments[0]){let t=arguments[0].toString().split(".");this.originName=t[0],this.itemName=t[1]}}static get Null(){return new f(null,null)}get isNull(){return null==this.originName&&null==this.itemName}get fullName(){return(null!==this.originName?this.originName:"?")+"."+this.itemName}toString(){return this.fullName}Equals(t){if(t instanceof f){let e=t;return e.itemName==this.itemName&&e.originName==this.originName}return!1}copy(){return new f(this.originName,this.itemName)}serialized(){return JSON.stringify({originName:this.originName,itemName:this.itemName})}static fromSerializedKey(t){let e=JSON.parse(t);if(!f.isLikeInkListItem(e))return f.Null;let n=e;return new f(n.originName,n.itemName)}static isLikeInkListItem(t){return"object"==typeof t&&(!(!t.hasOwnProperty("originName")||!t.hasOwnProperty("itemName"))&&(("string"==typeof t.originName||null===typeof t.originName)&&("string"==typeof t.itemName||null===typeof t.itemName)))}}class g extends Map{constructor(){if(super(arguments[0]instanceof g?arguments[0]:[]),this.origins=null,this._originNames=[],arguments[0]instanceof g){let t=arguments[0];t._originNames&&(this._originNames=t._originNames.slice())}else if("string"==typeof arguments[0]){let t=arguments[0],e=arguments[1];this.SetInitialOriginName(t);let n=e.listDefinitions.TryListGetDefinition(t,null);if(!n.exists)throw new Error("InkList origin could not be found in story when constructing new list: "+t);this.origins=[n.result]}else if("object"==typeof arguments[0]&&arguments[0].hasOwnProperty("Key")&&arguments[0].hasOwnProperty("Value")){let t=arguments[0];this.Add(t.Key,t.Value)}}AddItem(t){if(t instanceof f){let e=t;if(null==e.originName)return void this.AddItem(e.itemName);if(null===this.origins)return d("this.origins");for(let t of this.origins)if(t.name==e.originName){let n=t.TryGetValueForItem(e,0);if(n.exists)return void this.Add(e,n.result);throw new Error("Could not add the item "+e+" to this list because it doesn't exist in the original list definition in ink.")}throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.")}{let e=t,n=null;if(null===this.origins)return d("this.origins");for(let t of this.origins){if(null===e)return d("itemName");if(t.ContainsItemWithName(e)){if(null!=n)throw new Error("Could not add the item "+e+" to this list because it could come from either "+t.name+" or "+n.name);n=t}}if(null==n)throw new Error("Could not add the item "+e+" to this list because it isn't known to any list definitions previously associated with this list.");let i=new f(n.name,e),r=n.ValueForItem(i);this.Add(i,r)}}ContainsItemNamed(t){for(let[e]of this){if(f.fromSerializedKey(e).itemName==t)return!0}return!1}ContainsKey(t){return this.has(t.serialized())}Add(t,e){let n=t.serialized();if(this.has(n))throw new Error("The Map already contains an entry for "+t);this.set(n,e)}Remove(t){return this.delete(t.serialized())}get Count(){return this.size}get originOfMaxItem(){if(null==this.origins)return null;let t=this.maxItem.Key.originName,e=null;return this.origins.every(n=>n.name!=t||(e=n,!1)),e}get originNames(){if(this.Count>0){null==this._originNames&&this.Count>0?this._originNames=[]:(this._originNames||(this._originNames=[]),this._originNames.length=0);for(let[t]of this){let e=f.fromSerializedKey(t);if(null===e.originName)return d("item.originName");this._originNames.push(e.originName)}}return this._originNames}SetInitialOriginName(t){this._originNames=[t]}SetInitialOriginNames(t){this._originNames=null==t?null:t.slice()}get maxItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n>t.Value)&&(t={Key:i,Value:n})}return t}get minItem(){let t={Key:f.Null,Value:0};for(let[e,n]of this){let i=f.fromSerializedKey(e);(t.Key.isNull||n<t.Value)&&(t={Key:i,Value:n})}return t}get inverse(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);this.ContainsKey(e)||t.Add(e,i)}return t}get all(){let t=new g;if(null!=this.origins)for(let e of this.origins)for(let[n,i]of e.items){let e=f.fromSerializedKey(n);t.set(e.serialized(),i)}return t}Union(t){let e=new g(this);for(let[n,i]of t)e.set(n,i);return e}Intersect(t){let e=new g;for(let[n,i]of this)t.has(n)&&e.set(n,i);return e}Without(t){let e=new g(this);for(let[n]of t)e.delete(n);return e}Contains(t){for(let[e]of t)if(!this.has(e))return!1;return!0}GreaterThan(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>t.maxItem.Value)}GreaterThanOrEquals(t){return 0!=this.Count&&(0==t.Count||this.minItem.Value>=t.minItem.Value&&this.maxItem.Value>=t.maxItem.Value)}LessThan(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<t.minItem.Value)}LessThanOrEquals(t){return 0!=t.Count&&(0==this.Count||this.maxItem.Value<=t.maxItem.Value&&this.minItem.Value<=t.minItem.Value)}MaxAsList(){return this.Count>0?new g(this.maxItem):new g}MinAsList(){return this.Count>0?new g(this.minItem):new g}ListWithSubRange(t,e){if(0==this.Count)return new g;let n=this.orderedItems,i=0,r=Number.MAX_SAFE_INTEGER;Number.isInteger(t)?i=t:t instanceof g&&t.Count>0&&(i=t.minItem.Value),Number.isInteger(e)?r=e:t instanceof g&&t.Count>0&&(r=e.maxItem.Value);let a=new g;a.SetInitialOriginNames(this.originNames);for(let t of n)t.Value>=i&&t.Value<=r&&a.Add(t.Key,t.Value);return a}Equals(t){if(t instanceof g==!1)return!1;if(t.Count!=this.Count)return!1;for(let[e]of this)if(!t.has(e))return!1;return!0}get orderedItems(){let t=new Array;for(let[e,n]of this){let i=f.fromSerializedKey(e);t.push({Key:i,Value:n})}return t.sort((t,e)=>null===t.Key.originName?d("x.Key.originName"):null===e.Key.originName?d("y.Key.originName"):t.Value==e.Value?t.Key.originName.localeCompare(e.Key.originName):t.Value<e.Value?-1:t.Value>e.Value?1:0),t}toString(){let t=this.orderedItems,e=new m;for(let n=0;n<t.length;n++){n>0&&e.Append(", ");let i=t[n].Key;if(null===i.itemName)return d("item.itemName");e.Append(i.itemName)}return e.toString()}valueOf(){return NaN}}class S extends Error{constructor(t){super(t),this.useEndLineNumber=!1,this.message=t,this.name="StoryException"}}function y(t,e,n){if(null===t)return{result:n,exists:!1};let i=t.get(e);return void 0===i?{result:n,exists:!1}:{result:i,exists:!0}}class C extends p{static Create(t,n){if(n){if(n===i.Int&&Number.isInteger(Number(t)))return new b(Number(t));if(n===i.Float&&!isNaN(t))return new _(Number(t))}if("boolean"==typeof t){t=!!t?1:0}return"string"==typeof t?new T(String(t)):Number.isInteger(Number(t))?new b(Number(t)):isNaN(t)?t instanceof e?new P(s(t,e)):t instanceof g?new O(s(t,g)):null:new _(Number(t))}Copy(){return s(C.Create(this),p)}BadCastException(t){return new S("Can't cast "+this.valueObject+" from "+this.valueType+" to "+t)}}class v extends C{constructor(t){super(),this.value=t}get valueObject(){return this.value}toString(){return null===this.value?d("Value.value"):this.value.toString()}}class b extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Int}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Float)return new _(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class _ extends v{constructor(t){super(t||0)}get isTruthy(){return 0!=this.value}get valueType(){return i.Float}Cast(t){if(null===this.value)return d("Value.value");if(t==this.valueType)return this;if(t==i.Int)return new b(this.value);if(t==i.String)return new T(""+this.value);throw this.BadCastException(t)}}class T extends v{constructor(t){if(super(t||""),this._isNewline="\n"==this.value,this._isInlineWhitespace=!0,null===this.value)return d("Value.value");this.value.length>0&&this.value.split("").every(t=>" "==t||"\t"==t||(this._isInlineWhitespace=!1,!1))}get valueType(){return i.String}get isTruthy(){return null===this.value?d("Value.value"):this.value.length>0}get isNewline(){return this._isNewline}get isInlineWhitespace(){return this._isInlineWhitespace}get isNonWhitespace(){return!this.isNewline&&!this.isInlineWhitespace}Cast(t){if(t==this.valueType)return this;if(t==i.Int){let e=function(t,e=0){let n=parseInt(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new b(e.result);throw this.BadCastException(t)}if(t==i.Float){let e=function(t,e=0){let n=parseFloat(t);return Number.isNaN(n)?{result:e,exists:!1}:{result:n,exists:!0}}(this.value);if(e.exists)return new _(e.result);throw this.BadCastException(t)}throw this.BadCastException(t)}}class P extends v{constructor(t){super(t)}get valueType(){return i.DivertTarget}get targetPath(){return null===this.value?d("Value.value"):this.value}set targetPath(t){this.value=t}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a divert target")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"DivertTargetValue("+this.targetPath+")"}}class w extends v{constructor(t,e=-1){super(t),this._contextIndex=e}get contextIndex(){return this._contextIndex}set contextIndex(t){this._contextIndex=t}get variableName(){return null===this.value?d("Value.value"):this.value}set variableName(t){this.value=t}get valueType(){return i.VariablePointer}get isTruthy(){throw new Error("Shouldn't be checking the truthiness of a variable pointer")}Cast(t){if(t==this.valueType)return this;throw this.BadCastException(t)}toString(){return"VariablePointerValue("+this.variableName+")"}Copy(){return new w(this.variableName,this.contextIndex)}}class O extends v{get isTruthy(){return null===this.value?d("this.value"):this.value.Count>0}get valueType(){return i.List}Cast(t){if(null===this.value)return d("Value.value");if(t==i.Int){let t=this.value.maxItem;return t.Key.isNull?new b(0):new b(t.Value)}if(t==i.Float){let t=this.value.maxItem;return t.Key.isNull?new _(0):new _(t.Value)}if(t==i.String){let t=this.value.maxItem;return t.Key.isNull?new T(""):new T(t.Key.toString())}if(t==this.valueType)return this;throw this.BadCastException(t)}constructor(t,e){super(null),t||e?t instanceof g?this.value=new g(t):t instanceof f&&"number"==typeof e&&(this.value=new g({Key:t,Value:e})):this.value=new g}static RetainListOriginsForAssignment(t,e){let n=a(t,O),i=a(e,O);return i&&null===i.value?d("newList.value"):n&&null===n.value?d("oldList.value"):void(n&&i&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames))}}!function(t){t[t.Int=0]="Int",t[t.Float=1]="Float",t[t.List=2]="List",t[t.String=3]="String",t[t.DivertTarget=4]="DivertTarget",t[t.VariablePointer=5]="VariablePointer"}(i||(i={}));class E{constructor(){this.obj=null,this.approximate=!1}get correctObj(){return this.approximate?null:this.obj}get container(){return this.obj instanceof N?this.obj:null}copy(){let t=new E;return t.obj=this.obj,t.approximate=this.approximate,t}}class N extends p{constructor(){super(...arguments),this.name="",this._content=[],this.namedContent=new Map,this.visitsShouldBeCounted=!1,this.turnIndexShouldBeCounted=!1,this.countingAtStartOnly=!1,this._pathToFirstLeafContent=null}get hasValidName(){return null!=this.name&&this.name.length>0}get content(){return this._content}set content(t){this.AddContent(t)}get namedOnlyContent(){let t=new Map;for(let[e,n]of this.namedContent){let i=s(n,p);t.set(e,i)}for(let e of this.content){let n=l(e);null!=n&&n.hasValidName&&t.delete(n.name)}return 0==t.size&&(t=null),t}set namedOnlyContent(t){let e=this.namedOnlyContent;if(null!=e)for(let[t]of e)this.namedContent.delete(t);if(null!=t)for(let[,e]of t){let t=l(e);null!=t&&this.AddToNamedContentOnly(t)}}get countFlags(){let t=0;return this.visitsShouldBeCounted&&(t|=N.CountFlags.Visits),this.turnIndexShouldBeCounted&&(t|=N.CountFlags.Turns),this.countingAtStartOnly&&(t|=N.CountFlags.CountStartOnly),t==N.CountFlags.CountStartOnly&&(t=0),t}set countFlags(t){let e=t;(e&N.CountFlags.Visits)>0&&(this.visitsShouldBeCounted=!0),(e&N.CountFlags.Turns)>0&&(this.turnIndexShouldBeCounted=!0),(e&N.CountFlags.CountStartOnly)>0&&(this.countingAtStartOnly=!0)}get pathToFirstLeafContent(){return null==this._pathToFirstLeafContent&&(this._pathToFirstLeafContent=this.path.PathByAppendingPath(this.internalPathToFirstLeafContent)),this._pathToFirstLeafContent}get internalPathToFirstLeafContent(){let t=[],n=this;for(;n instanceof N;)n.content.length>0&&(t.push(new e.Component(0)),n=n.content[0]);return new e(t)}AddContent(t){if(t instanceof Array){let e=t;for(let t of e)this.AddContent(t)}else{let e=t;if(this._content.push(e),e.parent)throw new Error("content is already in "+e.parent);e.parent=this,this.TryAddNamedContent(e)}}TryAddNamedContent(t){let e=l(t);null!=e&&e.hasValidName&&this.AddToNamedContentOnly(e)}AddToNamedContentOnly(t){n.AssertType(t,p,"Can only add Runtime.Objects to a Runtime.Container"),s(t,p).parent=this,this.namedContent.set(t.name,t)}ContentAtPath(t,e=0,n=-1){-1==n&&(n=t.length);let i=new E;i.approximate=!1;let r=this,s=this;for(let l=e;l<n;++l){let e=t.GetComponent(l);if(null==r){i.approximate=!0;break}let n=r.ContentWithPathComponent(e);if(null==n){i.approximate=!0;break}s=n,r=a(n,N)}return i.obj=s,i}InsertContent(t,e){if(this.content[e]=t,t.parent)throw new Error("content is already in "+t.parent);t.parent=this,this.TryAddNamedContent(t)}AddContentsOfContainer(t){this.content=this.content.concat(t.content);for(let e of t.content)e.parent=this,this.TryAddNamedContent(e)}ContentWithPathComponent(t){if(t.isIndex)return t.index>=0&&t.index<this.content.length?this.content[t.index]:null;if(t.isParent)return this.parent;{if(null===t.name)return d("component.name");let e=y(this.namedContent,t.name,null);return e.exists?s(e.result,p):null}}BuildStringOfHierarchy(){let t;if(0==arguments.length)return t=new m,this.BuildStringOfHierarchy(t,0,null),t.toString();t=arguments[0];let e=arguments[1],i=arguments[2];function r(){for(let n=0;n<4*e;++n)t.Append(" ")}r(),t.Append("["),this.hasValidName&&t.AppendFormat(" ({0})",this.name),this==i&&t.Append("  <---"),t.AppendLine(),e++;for(let n=0;n<this.content.length;++n){let a=this.content[n];if(a instanceof N){a.BuildStringOfHierarchy(t,e,i)}else r(),a instanceof T?(t.Append('"'),t.Append(a.toString().replace("\n","\\n")),t.Append('"')):t.Append(a.toString());n!=this.content.length-1&&t.Append(","),a instanceof N||a!=i||t.Append("  <---"),t.AppendLine()}let a=new Map;for(let[t,e]of this.namedContent)this.content.indexOf(s(e,p))>=0||a.set(t,e);if(a.size>0){r(),t.AppendLine("-- named: --");for(let[,r]of a){n.AssertType(r,N,"Can only print out named Containers"),r.BuildStringOfHierarchy(t,e,i),t.AppendLine()}}e--,r(),t.Append("]")}}!function(t){let e;!function(t){t[t.Visits=1]="Visits",t[t.Turns=2]="Turns",t[t.CountStartOnly=4]="CountStartOnly"}(e=t.CountFlags||(t.CountFlags={}))}(N||(N={}));class x extends p{toString(){return"Glue"}}class A extends p{constructor(t=A.CommandType.NotSet){super(),this._commandType=t}get commandType(){return this._commandType}Copy(){return new A(this.commandType)}static EvalStart(){return new A(A.CommandType.EvalStart)}static EvalOutput(){return new A(A.CommandType.EvalOutput)}static EvalEnd(){return new A(A.CommandType.EvalEnd)}static Duplicate(){return new A(A.CommandType.Duplicate)}static PopEvaluatedValue(){return new A(A.CommandType.PopEvaluatedValue)}static PopFunction(){return new A(A.CommandType.PopFunction)}static PopTunnel(){return new A(A.CommandType.PopTunnel)}static BeginString(){return new A(A.CommandType.BeginString)}static EndString(){return new A(A.CommandType.EndString)}static NoOp(){return new A(A.CommandType.NoOp)}static ChoiceCount(){return new A(A.CommandType.ChoiceCount)}static Turns(){return new A(A.CommandType.Turns)}static TurnsSince(){return new A(A.CommandType.TurnsSince)}static ReadCount(){return new A(A.CommandType.ReadCount)}static Random(){return new A(A.CommandType.Random)}static SeedRandom(){return new A(A.CommandType.SeedRandom)}static VisitIndex(){return new A(A.CommandType.VisitIndex)}static SequenceShuffleIndex(){return new A(A.CommandType.SequenceShuffleIndex)}static StartThread(){return new A(A.CommandType.StartThread)}static Done(){return new A(A.CommandType.Done)}static End(){return new A(A.CommandType.End)}static ListFromInt(){return new A(A.CommandType.ListFromInt)}static ListRange(){return new A(A.CommandType.ListRange)}static ListRandom(){return new A(A.CommandType.ListRandom)}toString(){return this.commandType.toString()}}!function(t){let e;!function(t){t[t.NotSet=-1]="NotSet",t[t.EvalStart=0]="EvalStart",t[t.EvalOutput=1]="EvalOutput",t[t.EvalEnd=2]="EvalEnd",t[t.Duplicate=3]="Duplicate",t[t.PopEvaluatedValue=4]="PopEvaluatedValue",t[t.PopFunction=5]="PopFunction",t[t.PopTunnel=6]="PopTunnel",t[t.BeginString=7]="BeginString",t[t.EndString=8]="EndString",t[t.NoOp=9]="NoOp",t[t.ChoiceCount=10]="ChoiceCount",t[t.Turns=11]="Turns",t[t.TurnsSince=12]="TurnsSince",t[t.Random=13]="Random",t[t.SeedRandom=14]="SeedRandom",t[t.VisitIndex=15]="VisitIndex",t[t.SequenceShuffleIndex=16]="SequenceShuffleIndex",t[t.StartThread=17]="StartThread",t[t.Done=18]="Done",t[t.End=19]="End",t[t.ListFromInt=20]="ListFromInt",t[t.ListRange=21]="ListRange",t[t.ListRandom=22]="ListRandom",t[t.ReadCount=23]="ReadCount",t[t.TOTAL_VALUES=24]="TOTAL_VALUES"}(e=t.CommandType||(t.CommandType={}))}(A||(A={})),function(t){t[t.Tunnel=0]="Tunnel",t[t.Function=1]="Function",t[t.FunctionEvaluationFromGame=2]="FunctionEvaluationFromGame"}(r||(r={}));class I{constructor(){this.container=null,this.index=-1,2===arguments.length&&(this.container=arguments[0],this.index=arguments[1])}Resolve(){return this.index<0?this.container:null==this.container?null:0==this.container.content.length?this.container:this.index>=this.container.content.length?null:this.container.content[this.index]}get isNull(){return null==this.container}get path(){return this.isNull?null:this.index>=0?this.container.path.PathByAppendingComponent(new e.Component(this.index)):this.container.path}toString(){return this.container?"Ink Pointer -> "+this.container.path.toString()+" -- index "+this.index:"Ink Pointer (null)"}copy(){return new I(this.container,this.index)}static StartOf(t){return new I(t,0)}static get Null(){return new I(null,-1)}}class k extends p{constructor(t){super(),this._targetPath=null,this._targetPointer=I.Null,this.variableDivertName=null,this.pushesToStack=!1,this.stackPushType=0,this.isExternal=!1,this.externalArgs=0,this.isConditional=!1,this.pushesToStack=!1,void 0!==t&&(this.pushesToStack=!0,this.stackPushType=t)}get targetPath(){if(null!=this._targetPath&&this._targetPath.isRelative){let t=this.targetPointer.Resolve();t&&(this._targetPath=t.path)}return this._targetPath}set targetPath(t){this._targetPath=t,this._targetPointer=I.Null}get targetPointer(){if(this._targetPointer.isNull){let t=this.ResolvePath(this._targetPath).obj;if(null===this._targetPath)return d("this._targetPath");if(null===this._targetPath.lastComponent)return d("this._targetPath.lastComponent");if(this._targetPath.lastComponent.isIndex){if(null===t)return d("targetObj");this._targetPointer.container=t.parent instanceof N?t.parent:null,this._targetPointer.index=this._targetPath.lastComponent.index}else this._targetPointer=I.StartOf(t instanceof N?t:null)}return this._targetPointer.copy()}get targetPathString(){return null==this.targetPath?null:this.CompactPathString(this.targetPath)}set targetPathString(t){this.targetPath=null==t?null:new e(t)}get hasVariableTarget(){return null!=this.variableDivertName}Equals(t){let e=t;return e instanceof k&&this.hasVariableTarget==e.hasVariableTarget&&(this.hasVariableTarget?this.variableDivertName==e.variableDivertName:null===this.targetPath?d("this.targetPath"):this.targetPath.Equals(e.targetPath))}toString(){if(this.hasVariableTarget)return"Divert(variable: "+this.variableDivertName+")";if(null==this.targetPath)return"Divert(null)";{let t=new m,e=this.targetPath.toString();return t.Append("Divert"),this.isConditional&&t.Append("?"),this.pushesToStack&&(this.stackPushType==r.Function?t.Append(" function"):t.Append(" tunnel")),t.Append(" -> "),t.Append(this.targetPathString),t.Append(" ("),t.Append(e),t.Append(")"),t.toString()}}}class W extends p{constructor(t=!0){super(),this._pathOnChoice=null,this.hasCondition=!1,this.hasStartContent=!1,this.hasChoiceOnlyContent=!1,this.isInvisibleDefault=!1,this.onceOnly=!0,this.onceOnly=t}get pathOnChoice(){if(null!=this._pathOnChoice&&this._pathOnChoice.isRelative){let t=this.choiceTarget;t&&(this._pathOnChoice=t.path)}return this._pathOnChoice}set pathOnChoice(t){this._pathOnChoice=t}get choiceTarget(){return null===this._pathOnChoice?d("ChoicePoint._pathOnChoice"):this.ResolvePath(this._pathOnChoice).container}get pathStringOnChoice(){return null===this.pathOnChoice?d("ChoicePoint.pathOnChoice"):this.CompactPathString(this.pathOnChoice)}set pathStringOnChoice(t){this.pathOnChoice=new e(t)}get flags(){let t=0;return this.hasCondition&&(t|=1),this.hasStartContent&&(t|=2),this.hasChoiceOnlyContent&&(t|=4),this.isInvisibleDefault&&(t|=8),this.onceOnly&&(t|=16),t}set flags(t){this.hasCondition=(1&t)>0,this.hasStartContent=(2&t)>0,this.hasChoiceOnlyContent=(4&t)>0,this.isInvisibleDefault=(8&t)>0,this.onceOnly=(16&t)>0}toString(){if(null===this.pathOnChoice)return d("ChoicePoint.pathOnChoice");return"Choice: -> "+this.pathOnChoice.toString()}}class F extends p{constructor(t=null){super(),this.pathForCount=null,this.name=t}get containerForCount(){return null===this.pathForCount?null:this.ResolvePath(this.pathForCount).container}get pathStringForCount(){return null===this.pathForCount?null:this.CompactPathString(this.pathForCount)}set pathStringForCount(t){this.pathForCount=null===t?null:new e(t)}toString(){if(null!=this.name)return"var("+this.name+")";return"read_count("+this.pathStringForCount+")"}}class V extends p{constructor(t,e){super(),this.variableName=t||null,this.isNewDeclaration=!!e,this.isGlobal=!1}toString(){return"VarAssign to "+this.variableName}}class L extends p{}class R extends p{constructor(){if(super(),this._name=null,this._numberOfParameters=0,this._prototype=null,this._isPrototype=!1,this._operationFuncs=null,0===arguments.length)R.GenerateNativeFunctionsIfNecessary();else if(1===arguments.length){let t=arguments[0];R.GenerateNativeFunctionsIfNecessary(),this.name=t}else if(2===arguments.length){let t=arguments[0],e=arguments[1];this._isPrototype=!0,this.name=t,this.numberOfParameters=e}}static CallWithName(t){return new R(t)}static CallExistsWithName(t){return this.GenerateNativeFunctionsIfNecessary(),this._nativeFunctions.get(t)}get name(){return null===this._name?d("NativeFunctionCall._name"):this._name}set name(t){this._name=t,this._isPrototype||(null===R._nativeFunctions?d("NativeFunctionCall._nativeFunctions"):this._prototype=R._nativeFunctions.get(this._name)||null)}get numberOfParameters(){return this._prototype?this._prototype.numberOfParameters:this._numberOfParameters}set numberOfParameters(t){this._numberOfParameters=t}Call(t){if(this._prototype)return this._prototype.Call(t);if(this.numberOfParameters!=t.length)throw new Error("Unexpected number of parameters");let e=!1;for(let n of t){if(n instanceof L)throw new S('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');n instanceof O&&(e=!0)}if(2==t.length&&e)return this.CallBinaryListOperation(t);let n=this.CoerceValuesToSingleType(t),r=n[0].valueType;return r==i.Int||r==i.Float||r==i.String||r==i.DivertTarget||r==i.List?this.CallType(n):null}CallType(t){let e=s(t[0],v),n=e.valueType,r=e,a=t.length;if(2==a||1==a){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(n);if(!l){const t=i[n];throw new S("Cannot perform operation "+this.name+" on "+t)}if(2==a){let e=s(t[1],v),n=l;if(null===r.value||null===e.value)return d("NativeFunctionCall.Call BinaryOp values");let i=n(r.value,e.value);return v.Create(i)}{let t=l;if(null===r.value)return d("NativeFunctionCall.Call UnaryOp value");let n=t(r.value);return this.name===R.Int?v.Create(n,i.Int):this.name===R.Float?v.Create(n,i.Float):v.Create(n,e.valueType)}}throw new Error("Unexpected number of parameters to NativeFunctionCall: "+t.length)}CallBinaryListOperation(t){if(("+"==this.name||"-"==this.name)&&t[0]instanceof O&&t[1]instanceof b)return this.CallListIncrementOperation(t);let e=s(t[0],v),n=s(t[1],v);if(!("&&"!=this.name&&"||"!=this.name||e.valueType==i.List&&n.valueType==i.List)){if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let t=this._operationFuncs.get(i.Int);if(null===t)return d("NativeFunctionCall.CallBinaryListOperation op");let r=t(e.isTruthy?1:0,n.isTruthy?1:0);return new b(r)}if(e.valueType==i.List&&n.valueType==i.List)return this.CallType([e,n]);throw new S("Can not call use "+this.name+" operation on "+i[e.valueType]+" and "+i[n.valueType])}CallListIncrementOperation(t){let e=s(t[0],O),n=s(t[1],b),r=new g;if(null===e.value)return d("NativeFunctionCall.CallListIncrementOperation listVal.value");for(let[t,a]of e.value){let s=f.fromSerializedKey(t);if(null===this._operationFuncs)return d("NativeFunctionCall._operationFuncs");let l=this._operationFuncs.get(i.Int);if(null===n.value)return d("NativeFunctionCall.CallListIncrementOperation intVal.value");let o=l(a,n.value),u=null;if(null===e.value.origins)return d("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");for(let t of e.value.origins)if(t.name==s.originName){u=t;break}if(null!=u){let t=u.TryGetItemWithValue(o,f.Null);t.exists&&r.Add(t.result,o)}}return new O(r)}CoerceValuesToSingleType(t){let e=i.Int,n=null;for(let r of t){let t=s(r,v);t.valueType>e&&(e=t.valueType),t.valueType==i.List&&(n=a(t,O))}let r=[];if(i[e]==i[i.List])for(let e of t){let t=s(e,v);if(t.valueType==i.List)r.push(t);else{if(t.valueType!=i.Int){const e=i[t.valueType];throw new S("Cannot mix Lists and "+e+" values in this operation")}{let e=parseInt(t.valueObject);if(n=s(n,O),null===n.value)return d("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");let i=n.value.originOfMaxItem;if(null===i)return d("NativeFunctionCall.CoerceValuesToSingleType list");let a=i.TryGetItemWithValue(e,f.Null);if(!a.exists)throw new S("Could not find List item with the value "+e+" in "+i.name);{let t=new O(a.result,e);r.push(t)}}}}else for(let n of t){let t=s(n,v).Cast(e);r.push(t)}return r}static Identity(t){return t}static GenerateNativeFunctionsIfNecessary(){if(null==this._nativeFunctions){this._nativeFunctions=new Map,this.AddIntBinaryOp(this.Add,(t,e)=>t+e),this.AddIntBinaryOp(this.Subtract,(t,e)=>t-e),this.AddIntBinaryOp(this.Multiply,(t,e)=>t*e),this.AddIntBinaryOp(this.Divide,(t,e)=>Math.floor(t/e)),this.AddIntBinaryOp(this.Mod,(t,e)=>t%e),this.AddIntUnaryOp(this.Negate,t=>-t),this.AddIntBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddIntBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddIntBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddIntBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddIntBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddIntBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddIntUnaryOp(this.Not,t=>0==t?1:0),this.AddIntBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddIntBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddIntBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddIntBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddIntBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddIntUnaryOp(this.Floor,R.Identity),this.AddIntUnaryOp(this.Ceiling,R.Identity),this.AddIntUnaryOp(this.Int,R.Identity),this.AddIntUnaryOp(this.Float,t=>t),this.AddFloatBinaryOp(this.Add,(t,e)=>t+e),this.AddFloatBinaryOp(this.Subtract,(t,e)=>t-e),this.AddFloatBinaryOp(this.Multiply,(t,e)=>t*e),this.AddFloatBinaryOp(this.Divide,(t,e)=>t/e),this.AddFloatBinaryOp(this.Mod,(t,e)=>t%e),this.AddFloatUnaryOp(this.Negate,t=>-t),this.AddFloatBinaryOp(this.Equal,(t,e)=>t==e?1:0),this.AddFloatBinaryOp(this.Greater,(t,e)=>t>e?1:0),this.AddFloatBinaryOp(this.Less,(t,e)=>t<e?1:0),this.AddFloatBinaryOp(this.GreaterThanOrEquals,(t,e)=>t>=e?1:0),this.AddFloatBinaryOp(this.LessThanOrEquals,(t,e)=>t<=e?1:0),this.AddFloatBinaryOp(this.NotEquals,(t,e)=>t!=e?1:0),this.AddFloatUnaryOp(this.Not,t=>0==t?1:0),this.AddFloatBinaryOp(this.And,(t,e)=>0!=t&&0!=e?1:0),this.AddFloatBinaryOp(this.Or,(t,e)=>0!=t||0!=e?1:0),this.AddFloatBinaryOp(this.Max,(t,e)=>Math.max(t,e)),this.AddFloatBinaryOp(this.Min,(t,e)=>Math.min(t,e)),this.AddFloatBinaryOp(this.Pow,(t,e)=>Math.pow(t,e)),this.AddFloatUnaryOp(this.Floor,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Ceiling,t=>Math.ceil(t)),this.AddFloatUnaryOp(this.Int,t=>Math.floor(t)),this.AddFloatUnaryOp(this.Float,R.Identity),this.AddStringBinaryOp(this.Add,(t,e)=>t+e),this.AddStringBinaryOp(this.Equal,(t,e)=>t===e?1:0),this.AddStringBinaryOp(this.NotEquals,(t,e)=>t!==e?1:0),this.AddStringBinaryOp(this.Has,(t,e)=>t.includes(e)?1:0),this.AddStringBinaryOp(this.Hasnt,(t,e)=>t.includes(e)?0:1),this.AddListBinaryOp(this.Add,(t,e)=>t.Union(e)),this.AddListBinaryOp(this.Subtract,(t,e)=>t.Without(e)),this.AddListBinaryOp(this.Has,(t,e)=>t.Contains(e)?1:0),this.AddListBinaryOp(this.Hasnt,(t,e)=>t.Contains(e)?0:1),this.AddListBinaryOp(this.Intersect,(t,e)=>t.Intersect(e)),this.AddListBinaryOp(this.Equal,(t,e)=>t.Equals(e)?1:0),this.AddListBinaryOp(this.Greater,(t,e)=>t.GreaterThan(e)?1:0),this.AddListBinaryOp(this.Less,(t,e)=>t.LessThan(e)?1:0),this.AddListBinaryOp(this.GreaterThanOrEquals,(t,e)=>t.GreaterThanOrEquals(e)?1:0),this.AddListBinaryOp(this.LessThanOrEquals,(t,e)=>t.LessThanOrEquals(e)?1:0),this.AddListBinaryOp(this.NotEquals,(t,e)=>t.Equals(e)?0:1),this.AddListBinaryOp(this.And,(t,e)=>t.Count>0&&e.Count>0?1:0),this.AddListBinaryOp(this.Or,(t,e)=>t.Count>0||e.Count>0?1:0),this.AddListUnaryOp(this.Not,t=>0==t.Count?1:0),this.AddListUnaryOp(this.Invert,t=>t.inverse),this.AddListUnaryOp(this.All,t=>t.all),this.AddListUnaryOp(this.ListMin,t=>t.MinAsList()),this.AddListUnaryOp(this.ListMax,t=>t.MaxAsList()),this.AddListUnaryOp(this.Count,t=>t.Count),this.AddListUnaryOp(this.ValueOfList,t=>t.maxItem.Value);let t=(t,e)=>t.Equals(e)?1:0,e=(t,e)=>t.Equals(e)?0:1;this.AddOpToNativeFunc(this.Equal,2,i.DivertTarget,t),this.AddOpToNativeFunc(this.NotEquals,2,i.DivertTarget,e)}}AddOpFuncForType(t,e){null==this._operationFuncs&&(this._operationFuncs=new Map),this._operationFuncs.set(t,e)}static AddOpToNativeFunc(t,e,n,i){if(null===this._nativeFunctions)return d("NativeFunctionCall._nativeFunctions");let r=this._nativeFunctions.get(t);r||(r=new R(t,e),this._nativeFunctions.set(t,r)),r.AddOpFuncForType(n,i)}static AddIntBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Int,e)}static AddIntUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Int,e)}static AddFloatBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.Float,e)}static AddFloatUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.Float,e)}static AddStringBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.String,e)}static AddListBinaryOp(t,e){this.AddOpToNativeFunc(t,2,i.List,e)}static AddListUnaryOp(t,e){this.AddOpToNativeFunc(t,1,i.List,e)}toString(){return'Native "'+this.name+'"'}}R.Add="+",R.Subtract="-",R.Divide="/",R.Multiply="*",R.Mod="%",R.Negate="_",R.Equal="==",R.Greater=">",R.Less="<",R.GreaterThanOrEquals=">=",R.LessThanOrEquals="<=",R.NotEquals="!=",R.Not="!",R.And="&&",R.Or="||",R.Min="MIN",R.Max="MAX",R.Pow="POW",R.Floor="FLOOR",R.Ceiling="CEILING",R.Int="INT",R.Float="FLOAT",R.Has="?",R.Hasnt="!?",R.Intersect="^",R.ListMin="LIST_MIN",R.ListMax="LIST_MAX",R.All="LIST_ALL",R.Count="LIST_COUNT",R.ValueOfList="LIST_VALUE",R.Invert="LIST_INVERT",R._nativeFunctions=null;class j extends p{constructor(t){super(),this.text=t.toString()||""}toString(){return"# "+this.text}}class D extends p{constructor(){super(...arguments),this.text="",this.index=0,this.threadAtGeneration=null,this.sourcePath="",this.targetPath=null,this.isInvisibleDefault=!1,this.originalThreadIndex=0}get pathStringOnChoice(){return null===this.targetPath?d("Choice.targetPath"):this.targetPath.toString()}set pathStringOnChoice(t){this.targetPath=new e(t)}}class G{constructor(t,e){this._name=t||"",this._items=null,this._itemNameToValues=e||new Map}get name(){return this._name}get items(){if(null==this._items){this._items=new Map;for(let[t,e]of this._itemNameToValues){let n=new f(this.name,t);this._items.set(n.serialized(),e)}}return this._items}ValueForItem(t){if(!t.itemName)return 0;let e=this._itemNameToValues.get(t.itemName);return void 0!==e?e:0}ContainsItem(t){return!!t.itemName&&(t.originName==this.name&&this._itemNameToValues.has(t.itemName))}ContainsItemWithName(t){return this._itemNameToValues.has(t)}TryGetItemWithValue(t,e){for(let[e,n]of this._itemNameToValues)if(n==t)return{result:new f(this.name,e),exists:!0};return{result:f.Null,exists:!1}}TryGetValueForItem(t,e){if(!t.itemName)return{result:0,exists:!1};let n=this._itemNameToValues.get(t.itemName);return n?{result:n,exists:!0}:{result:0,exists:!1}}}class B{constructor(t){this._lists=new Map,this._allUnambiguousListValueCache=new Map;for(let e of t){this._lists.set(e.name,e);for(let[t,n]of e.items){let e=f.fromSerializedKey(t),i=new O(e,n);if(!e.itemName)throw new Error("item.itemName is null or undefined.");this._allUnambiguousListValueCache.set(e.itemName,i),this._allUnambiguousListValueCache.set(e.fullName,i)}}}get lists(){let t=[];for(let[,e]of this._lists)t.push(e);return t}TryListGetDefinition(t,e){if(null===t)return{result:e,exists:!1};let n=this._lists.get(t);return n?{result:n,exists:!0}:{result:e,exists:!1}}FindSingleItemListWithName(t){if(null===t)return d("name");let e=this._allUnambiguousListValueCache.get(t);return void 0!==e?e:null}}class M{static JArrayToRuntimeObjList(t,e=!1){let n=t.length;e&&n--;let i=[];for(let e=0;e<n;e++){let n=t[e],r=this.JTokenToRuntimeObject(n);if(null===r)return d("runtimeObj");i.push(r)}return i}static WriteDictionaryRuntimeObjs(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WritePropertyStart(n),this.WriteRuntimeObject(t,i),t.WritePropertyEnd();t.WriteObjectEnd()}static WriteListRuntimeObjs(t,e){t.WriteArrayStart();for(let n of e)this.WriteRuntimeObject(t,n);t.WriteArrayEnd()}static WriteIntDictionary(t,e){t.WriteObjectStart();for(let[n,i]of e)t.WriteIntProperty(n,i);t.WriteObjectEnd()}static WriteRuntimeObject(t,e){let n=a(e,N);if(n)return void this.WriteRuntimeContainer(t,n);let i=a(e,k);if(i){let e,n="->";return i.isExternal?n="x()":i.pushesToStack&&(i.stackPushType==r.Function?n="f()":i.stackPushType==r.Tunnel&&(n="->t->")),e=i.hasVariableTarget?i.variableDivertName:i.targetPathString,t.WriteObjectStart(),t.WriteProperty(n,e),i.hasVariableTarget&&t.WriteProperty("var",!0),i.isConditional&&t.WriteProperty("c",!0),i.externalArgs>0&&t.WriteIntProperty("exArgs",i.externalArgs),void t.WriteObjectEnd()}let s=a(e,W);if(s)return t.WriteObjectStart(),t.WriteProperty("*",s.pathStringOnChoice),t.WriteIntProperty("flg",s.flags),void t.WriteObjectEnd();let l=a(e,b);if(l)return void t.WriteInt(l.value);let o=a(e,_);if(o)return void t.WriteFloat(o.value);let u=a(e,T);if(u)return void(u.isNewline?t.Write("\n",!1):(t.WriteStringStart(),t.WriteStringInner("^"),t.WriteStringInner(u.value),t.WriteStringEnd()));let h=a(e,O);if(h)return void this.WriteInkList(t,h);let c=a(e,P);if(c)return t.WriteObjectStart(),null===c.value?d("divTargetVal.value"):(t.WriteProperty("^->",c.value.componentsString),void t.WriteObjectEnd());let p=a(e,w);if(p)return t.WriteObjectStart(),t.WriteProperty("^var",p.value),t.WriteIntProperty("ci",p.contextIndex),void t.WriteObjectEnd();if(a(e,x))return void t.Write("<>");let m=a(e,A);if(m)return void t.Write(M._controlCommandNames[m.commandType]);let f=a(e,R);if(f){let e=f.name;return"^"==e&&(e="L^"),void t.Write(e)}let g=a(e,F);if(g){t.WriteObjectStart();let e=g.pathStringForCount;return null!=e?t.WriteProperty("CNT?",e):t.WriteProperty("VAR?",g.name),void t.WriteObjectEnd()}let S=a(e,V);if(S){t.WriteObjectStart();let e=S.isGlobal?"VAR=":"temp=";return t.WriteProperty(e,S.variableName),S.isNewDeclaration||t.WriteProperty("re",!0),void t.WriteObjectEnd()}if(a(e,L))return void t.Write("void");let y=a(e,j);if(y)return t.WriteObjectStart(),t.WriteProperty("#",y.text),void t.WriteObjectEnd();let C=a(e,D);if(!C)throw new Error("Failed to convert runtime object to Json token: "+e);this.WriteChoice(t,C)}static JObjectToDictionaryRuntimeObjs(t){let e=new Map;for(let n in t)if(t.hasOwnProperty(n)){let i=this.JTokenToRuntimeObject(t[n]);if(null===i)return d("inkObject");e.set(n,i)}return e}static JObjectToIntDictionary(t){let e=new Map;for(let n in t)t.hasOwnProperty(n)&&e.set(n,parseInt(t[n]));return e}static JTokenToRuntimeObject(t){if("number"==typeof t&&!isNaN(t))return v.Create(t);if("string"==typeof t){let e=t.toString(),n=e[0];if("^"==n)return new T(e.substring(1));if("\n"==n&&1==e.length)return new T("\n");if("<>"==e)return new x;for(let t=0;t<M._controlCommandNames.length;++t){if(e==M._controlCommandNames[t])return new A(t)}if("L^"==e&&(e="^"),R.CallExistsWithName(e))return R.CallWithName(e);if("->->"==e)return A.PopTunnel();if("~ret"==e)return A.PopFunction();if("void"==e)return new L}if("object"==typeof t&&!Array.isArray(t)){let n,i=t;if(i["^->"])return n=i["^->"],new P(new e(n.toString()));if(i["^var"]){n=i["^var"];let t=new w(n.toString());return"ci"in i&&(n=i.ci,t.contextIndex=parseInt(n)),t}let a=!1,s=!1,l=r.Function,o=!1;if((n=i["->"])?a=!0:(n=i["f()"])?(a=!0,s=!0,l=r.Function):(n=i["->t->"])?(a=!0,s=!0,l=r.Tunnel):(n=i["x()"])&&(a=!0,o=!0,s=!1,l=r.Function),a){let t=new k;t.pushesToStack=s,t.stackPushType=l,t.isExternal=o;let e=n.toString();return(n=i.var)?t.variableDivertName=e:t.targetPathString=e,t.isConditional=!!i.c,o&&(n=i.exArgs)&&(t.externalArgs=parseInt(n)),t}if(n=i["*"]){let t=new W;return t.pathStringOnChoice=n.toString(),(n=i.flg)&&(t.flags=parseInt(n)),t}if(n=i["VAR?"])return new F(n.toString());if(n=i["CNT?"]){let t=new F;return t.pathStringForCount=n.toString(),t}let u=!1,h=!1;if((n=i["VAR="])?(u=!0,h=!0):(n=i["temp="])&&(u=!0,h=!1),u){let t=n.toString(),e=!i.re,r=new V(t,e);return r.isGlobal=h,r}if(void 0!==i["#"])return n=i["#"],new j(n.toString());if(n=i.list){let t=n,e=new g;if(n=i.origins){let t=n;e.SetInitialOriginNames(t)}for(let n in t)if(t.hasOwnProperty(n)){let i=t[n],r=new f(n),a=parseInt(i);e.Add(r,a)}return new O(e)}if(null!=i.originalChoicePath)return this.JObjectToChoice(i)}if(Array.isArray(t))return this.JArrayToContainer(t);if(null==t)return null;throw new Error("Failed to convert token to runtime object: "+JSON.stringify(t))}static WriteRuntimeContainer(t,e,n=!1){if(t.WriteArrayStart(),null===e)return d("container");for(let n of e.content)this.WriteRuntimeObject(t,n);let i=e.namedOnlyContent,r=e.countFlags,s=null!=e.name&&!n,l=null!=i||r>0||s;if(l&&t.WriteObjectStart(),null!=i)for(let[e,n]of i){let i=e,r=a(n,N);t.WritePropertyStart(i),this.WriteRuntimeContainer(t,r,!0),t.WritePropertyEnd()}s&&t.WriteProperty("#n",e.name),l?t.WriteObjectEnd():t.WriteNull(),t.WriteArrayEnd()}static JArrayToContainer(t){let e=new N;e.content=this.JArrayToRuntimeObjList(t,!0);let n=t[t.length-1];if(null!=n){let t=new Map;for(let i in n)if("#f"==i)e.countFlags=parseInt(n[i]);else if("#n"==i)e.name=n[i].toString();else{let e=this.JTokenToRuntimeObject(n[i]),r=a(e,N);r&&(r.name=i),t.set(i,e)}e.namedOnlyContent=t}return e}static JObjectToChoice(t){let e=new D;return e.text=t.text.toString(),e.index=parseInt(t.index),e.sourcePath=t.originalChoicePath.toString(),e.originalThreadIndex=parseInt(t.originalThreadIndex),e.pathStringOnChoice=t.targetPath.toString(),e}static WriteChoice(t,e){t.WriteObjectStart(),t.WriteProperty("text",e.text),t.WriteIntProperty("index",e.index),t.WriteProperty("originalChoicePath",e.sourcePath),t.WriteIntProperty("originalThreadIndex",e.originalThreadIndex),t.WriteProperty("targetPath",e.pathStringOnChoice),t.WriteObjectEnd()}static WriteInkList(t,e){let n=e.value;if(null===n)return d("rawList");t.WriteObjectStart(),t.WritePropertyStart("list"),t.WriteObjectStart();for(let[e,i]of n){let n=f.fromSerializedKey(e),r=i;if(null===n.itemName)return d("item.itemName");t.WritePropertyNameStart(),t.WritePropertyNameInner(n.originName?n.originName:"?"),t.WritePropertyNameInner("."),t.WritePropertyNameInner(n.itemName),t.WritePropertyNameEnd(),t.Write(r),t.WritePropertyEnd()}if(t.WriteObjectEnd(),t.WritePropertyEnd(),0==n.Count&&null!=n.originNames&&n.originNames.length>0){t.WritePropertyStart("origins"),t.WriteArrayStart();for(let e of n.originNames)t.Write(e);t.WriteArrayEnd(),t.WritePropertyEnd()}t.WriteObjectEnd()}static ListDefinitionsToJToken(t){let e={};for(let n of t.lists){let t={};for(let[e,i]of n.items){let n=f.fromSerializedKey(e);if(null===n.itemName)return d("item.itemName");t[n.itemName]=i}e[n.name]=t}return e}static JTokenToListDefinitions(t){let e=t,n=[];for(let t in e)if(e.hasOwnProperty(t)){let i=t.toString(),r=e[t],a=new Map;for(let n in r)if(e.hasOwnProperty(t)){let t=r[n];a.set(n,parseInt(t))}let s=new G(i,a);n.push(s)}return new B(n)}}M._controlCommandNames=(()=>{let t=[];t[A.CommandType.EvalStart]="ev",t[A.CommandType.EvalOutput]="out",t[A.CommandType.EvalEnd]="/ev",t[A.CommandType.Duplicate]="du",t[A.CommandType.PopEvaluatedValue]="pop",t[A.CommandType.PopFunction]="~ret",t[A.CommandType.PopTunnel]="->->",t[A.CommandType.BeginString]="str",t[A.CommandType.EndString]="/str",t[A.CommandType.NoOp]="nop",t[A.CommandType.ChoiceCount]="choiceCnt",t[A.CommandType.Turns]="turn",t[A.CommandType.TurnsSince]="turns",t[A.CommandType.ReadCount]="readc",t[A.CommandType.Random]="rnd",t[A.CommandType.SeedRandom]="srnd",t[A.CommandType.VisitIndex]="visit",t[A.CommandType.SequenceShuffleIndex]="seq",t[A.CommandType.StartThread]="thread",t[A.CommandType.Done]="done",t[A.CommandType.End]="end",t[A.CommandType.ListFromInt]="listInt",t[A.CommandType.ListRange]="range",t[A.CommandType.ListRandom]="lrnd";for(let e=0;e<A.CommandType.TOTAL_VALUES;++e)if(null==t[e])throw new Error("Control command not accounted for in serialisation");return t})();class q{constructor(){if(this._threadCounter=0,this._startOfRoot=I.Null,arguments[0]instanceof X){let t=arguments[0];this._startOfRoot=I.StartOf(t.rootContentContainer),this.Reset()}else{let t=arguments[0];this._threads=[];for(let e of t._threads)this._threads.push(e.Copy());this._threadCounter=t._threadCounter,this._startOfRoot=t._startOfRoot}}get elements(){return this.callStack}get depth(){return this.elements.length}get currentElement(){let t=this._threads[this._threads.length-1].callstack;return t[t.length-1]}get currentElementIndex(){return this.callStack.length-1}get currentThread(){return this._threads[this._threads.length-1]}set currentThread(t){n.Assert(1==this._threads.length,"Shouldn't be directly setting the current thread when we have a stack of them"),this._threads.length=0,this._threads.push(t)}get canPop(){return this.callStack.length>1}Reset(){this._threads=[],this._threads.push(new q.Thread),this._threads[0].callstack.push(new q.Element(r.Tunnel,this._startOfRoot))}SetJsonToken(t,e){this._threads.length=0;let n=t.threads;for(let t of n){let n=t,i=new q.Thread(n,e);this._threads.push(i)}this._threadCounter=parseInt(t.threadCounter),this._startOfRoot=I.StartOf(e.rootContentContainer)}WriteJson(t){t.WriteObject(t=>{t.WritePropertyStart("threads"),t.WriteArrayStart();for(let e of this._threads)e.WriteJson(t);t.WriteArrayEnd(),t.WritePropertyEnd(),t.WritePropertyStart("threadCounter"),t.WriteInt(this._threadCounter),t.WritePropertyEnd()})}PushThread(){let t=this.currentThread.Copy();this._threadCounter++,t.threadIndex=this._threadCounter,this._threads.push(t)}ForkThread(){let t=this.currentThread.Copy();return this._threadCounter++,t.threadIndex=this._threadCounter,t}PopThread(){if(!this.canPopThread)throw new Error("Can't pop thread");this._threads.splice(this._threads.indexOf(this.currentThread),1)}get canPopThread(){return this._threads.length>1&&!this.elementIsEvaluateFromGame}get elementIsEvaluateFromGame(){return this.currentElement.type==r.FunctionEvaluationFromGame}Push(t,e=0,n=0){let i=new q.Element(t,this.currentElement.currentPointer,!1);i.evaluationStackHeightWhenPushed=e,i.functionStartInOutputStream=n,this.callStack.push(i)}CanPop(t=null){return!!this.canPop&&(null==t||this.currentElement.type==t)}Pop(t=null){if(!this.CanPop(t))throw new Error("Mismatched push/pop in Callstack");this.callStack.pop()}GetTemporaryVariableWithName(t,e=-1){-1==e&&(e=this.currentElementIndex+1);let n=y(this.callStack[e-1].temporaryVariables,t,null);return n.exists?n.result:null}SetTemporaryVariable(t,e,n,i=-1){-1==i&&(i=this.currentElementIndex+1);let r=this.callStack[i-1];if(!n&&!r.temporaryVariables.get(t))throw new S("Could not find temporary variable to set: "+t);let a=y(r.temporaryVariables,t,null);a.exists&&O.RetainListOriginsForAssignment(a.result,e),r.temporaryVariables.set(t,e)}ContextForVariableNamed(t){return this.currentElement.temporaryVariables.get(t)?this.currentElementIndex+1:0}ThreadWithIndex(t){let e=this._threads.filter(e=>{if(e.threadIndex==t)return e});return e.length>0?e[0]:null}get callStack(){return this.currentThread.callstack}get callStackTrace(){let t=new m;for(let e=0;e<this._threads.length;e++){let n=this._threads[e],i=e==this._threads.length-1;t.AppendFormat("=== THREAD {0}/{1} {2}===\n",e+1,this._threads.length,i?"(current) ":"");for(let e=0;e<n.callstack.length;e++){n.callstack[e].type==r.Function?t.Append("  [FUNCTION] "):t.Append("  [TUNNEL] ");let i=n.callstack[e].currentPointer;if(!i.isNull){if(t.Append("<SOMEWHERE IN "),null===i.container)return d("pointer.container");t.Append(i.container.path.toString()),t.AppendLine(">")}}}return t.toString()}}!function(t){class n{constructor(t,e,n=!1){this.evaluationStackHeightWhenPushed=0,this.functionStartInOutputStream=0,this.currentPointer=e.copy(),this.inExpressionEvaluation=n,this.temporaryVariables=new Map,this.type=t}Copy(){let t=new n(this.type,this.currentPointer,this.inExpressionEvaluation);return t.temporaryVariables=new Map(this.temporaryVariables),t.evaluationStackHeightWhenPushed=this.evaluationStackHeightWhenPushed,t.functionStartInOutputStream=this.functionStartInOutputStream,t}}t.Element=n;class i{constructor(){if(this.threadIndex=0,this.previousPointer=I.Null,this.callstack=[],arguments[0]&&arguments[1]){let t=arguments[0],i=arguments[1];this.threadIndex=parseInt(t.threadIndex);let r=t.callstack;for(let t of r){let r,a=t,s=parseInt(a.type),l=I.Null,o=a.cPath;if(void 0!==o){r=o.toString();let t=i.ContentAtPath(new e(r));if(l.container=t.container,l.index=parseInt(a.idx),null==t.obj)throw new Error("When loading state, internal story location couldn't be found: "+r+". Has the story changed since this save data was created?");if(t.approximate){if(null===l.container)return d("pointer.container");i.Warning("When loading state, exact internal story location couldn't be found: '"+r+"', so it was approximated to '"+l.container.path.toString()+"' to recover. Has the story changed since this save data was created?")}}let u=!!a.exp,h=new n(s,l,u),c=a.temp;void 0!==c?h.temporaryVariables=M.JObjectToDictionaryRuntimeObjs(c):h.temporaryVariables.clear(),this.callstack.push(h)}let a=t.previousContentObject;if(void 0!==a){let t=new e(a.toString());this.previousPointer=i.PointerAtPath(t)}}}Copy(){let t=new i;t.threadIndex=this.threadIndex;for(let e of this.callstack)t.callstack.push(e.Copy());return t.previousPointer=this.previousPointer.copy(),t}WriteJson(t){t.WriteObjectStart(),t.WritePropertyStart("callstack"),t.WriteArrayStart();for(let e of this.callstack){if(t.WriteObjectStart(),!e.currentPointer.isNull){if(null===e.currentPointer.container)return d("el.currentPointer.container");t.WriteProperty("cPath",e.currentPointer.container.path.componentsString),t.WriteIntProperty("idx",e.currentPointer.index)}t.WriteProperty("exp",e.inExpressionEvaluation),t.WriteIntProperty("type",e.type),e.temporaryVariables.size>0&&(t.WritePropertyStart("temp"),M.WriteDictionaryRuntimeObjs(t,e.temporaryVariables),t.WritePropertyEnd()),t.WriteObjectEnd()}if(t.WriteArrayEnd(),t.WritePropertyEnd(),t.WriteIntProperty("threadIndex",this.threadIndex),!this.previousPointer.isNull){let e=this.previousPointer.Resolve();if(null===e)return d("this.previousPointer.Resolve()");t.WriteProperty("previousContentObject",e.path.toString())}t.WriteObjectEnd()}}t.Thread=i}(q||(q={}));class J{constructor(t,e){this.variableChangedEventCallbacks=[],this.patch=null,this._batchObservingVariableChanges=!1,this._defaultGlobalVariables=new Map,this._changedVariablesForBatchObs=new Set,this._globalVariables=new Map,this._callStack=t,this._listDefsOrigin=e;try{return new Proxy(this,{get:(t,e)=>e in t?t[e]:t.$(e),set:(t,e,n)=>(e in t?t[e]=n:t.$(e,n),!0)})}catch(t){}}variableChangedEvent(t,e){for(let n of this.variableChangedEventCallbacks)n(t,e)}get batchObservingVariableChanges(){return this._batchObservingVariableChanges}set batchObservingVariableChanges(t){if(this._batchObservingVariableChanges=t,t)this._changedVariablesForBatchObs=new Set;else if(null!=this._changedVariablesForBatchObs){for(let t of this._changedVariablesForBatchObs){let e=this._globalVariables.get(t);e?this.variableChangedEvent(t,e):d("currentValue")}this._changedVariablesForBatchObs=null}}get callStack(){return this._callStack}set callStack(t){this._callStack=t}$(t,e){if(void 0===e){let e=null;return null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists)?e.result.valueObject:(e=this._globalVariables.get(t),void 0===e&&(e=this._defaultGlobalVariables.get(t)),void 0!==e?e.valueObject:null)}{if(void 0===this._defaultGlobalVariables.get(t))throw new S("Cannot assign to a variable ("+t+") that hasn't been declared in the story");let n=v.Create(e);if(null==n)throw new S(null==e?"Cannot pass null to VariableState":"Invalid value passed to VariableState: "+e.toString());this.SetGlobal(t,n)}}ApplyPatch(){if(null===this.patch)return d("this.patch");for(let[t,e]of this.patch.globals)this._globalVariables.set(t,e);if(null!==this._changedVariablesForBatchObs)for(let t of this.patch.changedVariables)this._changedVariablesForBatchObs.add(t);this.patch=null}SetJsonToken(t){this._globalVariables.clear();for(let[e,n]of this._defaultGlobalVariables){let i=t[e];if(void 0!==i){let t=M.JTokenToRuntimeObject(i);if(null===t)return d("tokenInkObject");this._globalVariables.set(e,t)}else this._globalVariables.set(e,n)}}WriteJson(t){t.WriteObjectStart();for(let[e,n]of this._globalVariables){let i=e,r=n;if(J.dontSaveDefaultValues&&this._defaultGlobalVariables.has(i)){let t=this._defaultGlobalVariables.get(i);if(this.RuntimeObjectsEqual(r,t))continue}t.WritePropertyStart(i),M.WriteRuntimeObject(t,r),t.WritePropertyEnd()}t.WriteObjectEnd()}RuntimeObjectsEqual(t,e){if(null===t)return d("obj1");if(null===e)return d("obj2");if(t.constructor!==e.constructor)return!1;let n=a(t,b);if(null!==n)return n.value===s(e,b).value;let i=a(t,_);if(null!==i)return i.value===s(e,_).value;let r=a(t,v),l=a(e,v);if(null!==r&&null!==l)return u(r.valueObject)&&u(l.valueObject)?r.valueObject.Equals(l.valueObject):r.valueObject===l.valueObject;throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: "+t.constructor.name)}GetVariableWithName(t,e=-1){let n=this.GetRawVariableWithName(t,e),i=a(n,w);return null!==i&&(n=this.ValueAtVariablePointer(i)),n}TryGetDefaultVariableValue(t){let e=y(this._defaultGlobalVariables,t,null);return e.exists?e.result:null}GlobalVariableExistsWithName(t){return this._globalVariables.has(t)||null!==this._defaultGlobalVariables&&this._defaultGlobalVariables.has(t)}GetRawVariableWithName(t,e){let n=null;if(0==e||-1==e){let e=null;if(null!==this.patch&&(e=this.patch.TryGetGlobal(t,null),e.exists))return e.result;if(e=y(this._globalVariables,t,null),e.exists)return e.result;if(null!==this._defaultGlobalVariables&&(e=y(this._defaultGlobalVariables,t,null),e.exists))return e.result;if(null===this._listDefsOrigin)return d("VariablesState._listDefsOrigin");let n=this._listDefsOrigin.FindSingleItemListWithName(t);if(n)return n}return n=this._callStack.GetTemporaryVariableWithName(t,e),n}ValueAtVariablePointer(t){return this.GetVariableWithName(t.variableName,t.contextIndex)}Assign(t,e){let n=t.variableName;if(null===n)return d("name");let i=-1,r=!1;if(r=t.isNewDeclaration?t.isGlobal:this.GlobalVariableExistsWithName(n),t.isNewDeclaration){let t=a(e,w);if(null!==t){e=this.ResolveVariablePointer(t)}}else{let t=null;do{t=a(this.GetRawVariableWithName(n,i),w),null!=t&&(n=t.variableName,i=t.contextIndex,r=0==i)}while(null!=t)}r?this.SetGlobal(n,e):this._callStack.SetTemporaryVariable(n,e,t.isNewDeclaration,i)}SnapshotDefaultGlobals(){this._defaultGlobalVariables=new Map(this._globalVariables)}RetainListOriginsForAssignment(t,e){let n=s(t,O),i=s(e,O);n.value&&i.value&&0==i.value.Count&&i.value.SetInitialOriginNames(n.value.originNames)}SetGlobal(t,e){let n=null;if(null===this.patch&&(n=y(this._globalVariables,t,null)),null!==this.patch&&(n=this.patch.TryGetGlobal(t,null),n.exists||(n=y(this._globalVariables,t,null))),O.RetainListOriginsForAssignment(n.result,e),null===t)return d("variableName");if(null!==this.patch?this.patch.SetGlobal(t,e):this._globalVariables.set(t,e),null!==this.variableChangedEvent&&null!==n&&e!==n.result)if(this.batchObservingVariableChanges){if(null===this._changedVariablesForBatchObs)return d("this._changedVariablesForBatchObs");null!==this.patch?this.patch.AddChangedVariable(t):null!==this._changedVariablesForBatchObs&&this._changedVariablesForBatchObs.add(t)}else this.variableChangedEvent(t,e)}ResolveVariablePointer(t){let e=t.contextIndex;-1==e&&(e=this.GetContextIndexOfVariableNamed(t.variableName));let n=a(this.GetRawVariableWithName(t.variableName,e),w);return null!=n?n:new w(t.variableName,e)}GetContextIndexOfVariableNamed(t){return this.GlobalVariableExistsWithName(t)?0:this._callStack.currentElementIndex}ObserveVariableChange(t){this.variableChangedEventCallbacks.push(t)}}J.dontSaveDefaultValues=!0;class K{constructor(t){this.seed=t%2147483647,this.seed<=0&&(this.seed+=2147483646)}next(){return this.seed=16807*this.seed%2147483647}nextFloat(){return(this.next()-1)/2147483646}}class U{constructor(){if(this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map,1===arguments.length&&null!==arguments[0]){let t=arguments[0];this._globals=new Map(t._globals),this._changedVariables=new Set(t._changedVariables),this._visitCounts=new Map(t._visitCounts),this._turnIndices=new Map(t._turnIndices)}else this._globals=new Map,this._changedVariables=new Set,this._visitCounts=new Map,this._turnIndices=new Map}get globals(){return this._globals}get changedVariables(){return this._changedVariables}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}TryGetGlobal(t,e){return null!==t&&this._globals.has(t)?{result:this._globals.get(t),exists:!0}:{result:e,exists:!1}}SetGlobal(t,e){this._globals.set(t,e)}AddChangedVariable(t){return this._changedVariables.add(t)}TryGetVisitCount(t,e){return this._visitCounts.has(t)?{result:this._visitCounts.get(t),exists:!0}:{result:e,exists:!1}}SetVisitCount(t,e){this._visitCounts.set(t,e)}SetTurnIndex(t,e){this._turnIndices.set(t,e)}TryGetTurnIndex(t,e){return this._turnIndices.has(t)?{result:this._turnIndices.get(t),exists:!0}:{result:e,exists:!1}}}class z{static TextToDictionary(t){return new z.Reader(t).ToDictionary()}static TextToArray(t){return new z.Reader(t).ToArray()}}!function(t){t.Reader=class{constructor(t){this._rootObject=JSON.parse(t)}ToDictionary(){return this._rootObject}ToArray(){return this._rootObject}};class e{constructor(){this._currentPropertyName=null,this._currentString=null,this._stateStack=[],this._collectionStack=[],this._propertyNameStack=[],this._jsonObject=null}WriteObject(t){this.WriteObjectStart(),t(this),this.WriteObjectEnd()}WriteObjectStart(){this.StartNewObject(!0);let e={};if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Object))}WriteObjectEnd(){this.Assert(this.state===t.Writer.State.Object),this._collectionStack.pop(),this._stateStack.pop()}WriteProperty(t,e){if(this.WritePropertyStart(t),arguments[1]instanceof Function){(0,arguments[1])(this)}else{let t=arguments[1];this.Write(t)}this.WritePropertyEnd()}WriteIntProperty(t,e){this.WritePropertyStart(t),this.WriteInt(e),this.WritePropertyEnd()}WriteFloatProperty(t,e){this.WritePropertyStart(t),this.WriteFloat(e),this.WritePropertyEnd()}WritePropertyStart(e){this.Assert(this.state===t.Writer.State.Object),this._propertyNameStack.push(e),this.IncrementChildCount(),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property))}WritePropertyEnd(){this.Assert(this.state===t.Writer.State.Property),this.Assert(1===this.childCount),this._stateStack.pop()}WritePropertyNameStart(){this.Assert(this.state===t.Writer.State.Object),this.IncrementChildCount(),this._currentPropertyName="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Property)),this._stateStack.push(new t.Writer.StateElement(t.Writer.State.PropertyName))}WritePropertyNameEnd(){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._propertyNameStack.push(this._currentPropertyName),this._currentPropertyName=null,this._stateStack.pop()}WritePropertyNameInner(e){this.Assert(this.state===t.Writer.State.PropertyName),this.Assert(null!==this._currentPropertyName),this._currentPropertyName+=e}WriteArrayStart(){this.StartNewObject(!0);let e=[];if(this.state===t.Writer.State.Property){this.Assert(null!==this.currentCollection),this.Assert(null!==this.currentPropertyName);let t=this._propertyNameStack.pop();this.currentCollection[t]=e,this._collectionStack.push(e)}else this.state===t.Writer.State.Array?(this.Assert(null!==this.currentCollection),this.currentCollection.push(e),this._collectionStack.push(e)):(this.Assert(this.state===t.Writer.State.None),this._jsonObject=e,this._collectionStack.push(e));this._stateStack.push(new t.Writer.StateElement(t.Writer.State.Array))}WriteArrayEnd(){this.Assert(this.state===t.Writer.State.Array),this._collectionStack.pop(),this._stateStack.pop()}Write(t,e=!0){null!==t?(this.StartNewObject(!1),this._addToCurrentObject(t)):console.error("Warning: trying to write a null string")}WriteInt(t){null!==t&&(this.StartNewObject(!1),this._addToCurrentObject(Math.floor(t)))}WriteFloat(t){null!==t&&(this.StartNewObject(!1),t==Number.POSITIVE_INFINITY?this._addToCurrentObject(34e37):t==Number.NEGATIVE_INFINITY?this._addToCurrentObject(-34e37):isNaN(t)?this._addToCurrentObject(0):this._addToCurrentObject(t))}WriteNull(){this.StartNewObject(!1),this._addToCurrentObject(null)}WriteStringStart(){this.StartNewObject(!1),this._currentString="",this._stateStack.push(new t.Writer.StateElement(t.Writer.State.String))}WriteStringEnd(){this.Assert(this.state==t.Writer.State.String),this._stateStack.pop(),this._addToCurrentObject(this._currentString),this._currentString=null}WriteStringInner(e,n=!0){this.Assert(this.state===t.Writer.State.String),null!==e?this._currentString+=e:console.error("Warning: trying to write a null string")}ToString(){return null===this._jsonObject?"":JSON.stringify(this._jsonObject)}StartNewObject(e){e?this.Assert(this.state===t.Writer.State.None||this.state===t.Writer.State.Property||this.state===t.Writer.State.Array):this.Assert(this.state===t.Writer.State.Property||this.state===t.Writer.State.Array),this.state===t.Writer.State.Property&&this.Assert(0===this.childCount),this.state!==t.Writer.State.Array&&this.state!==t.Writer.State.Property||this.IncrementChildCount()}get state(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].type:t.Writer.State.None}get childCount(){return this._stateStack.length>0?this._stateStack[this._stateStack.length-1].childCount:0}get currentCollection(){return this._collectionStack.length>0?this._collectionStack[this._collectionStack.length-1]:null}get currentPropertyName(){return this._propertyNameStack.length>0?this._propertyNameStack[this._propertyNameStack.length-1]:null}IncrementChildCount(){this.Assert(this._stateStack.length>0);let t=this._stateStack.pop();t.childCount++,this._stateStack.push(t)}Assert(t){if(!t)throw Error("Assert failed while writing JSON")}_addToCurrentObject(e){this.Assert(null!==this.currentCollection),this.state===t.Writer.State.Array?(this.Assert(Array.isArray(this.currentCollection)),this.currentCollection.push(e)):this.state===t.Writer.State.Property&&(this.Assert(!Array.isArray(this.currentCollection)),this.Assert(null!==this.currentPropertyName),this.currentCollection[this.currentPropertyName]=e,this._propertyNameStack.pop())}}t.Writer=e,function(e){let n;!function(t){t[t.None=0]="None",t[t.Object=1]="Object",t[t.Array=2]="Array",t[t.Property=3]="Property",t[t.PropertyName=4]="PropertyName",t[t.String=5]="String"}(n=e.State||(e.State={}));e.StateElement=class{constructor(e){this.type=t.Writer.State.None,this.childCount=0,this.type=e}}}(e=t.Writer||(t.Writer={}))}(z||(z={}));class H{constructor(t){this.kInkSaveStateVersion=8,this.kMinCompatibleLoadVersion=8,this._currentErrors=null,this._currentWarnings=null,this.divertedPointer=I.Null,this._currentTurnIndex=0,this.storySeed=0,this.previousRandom=0,this.didSafeExit=!1,this._currentText=null,this._currentTags=null,this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0,this._patch=null,this.story=t,this._outputStream=[],this.OutputStreamDirty(),this._evaluationStack=[],this.callStack=new q(t),this._variablesState=new J(this.callStack,t.listDefinitions),this._visitCounts=new Map,this._turnIndices=new Map,this.currentTurnIndex=-1;let e=(new Date).getTime();this.storySeed=new K(e).next()%100,this.previousRandom=0,this._currentChoices=[],this.GoToStart()}ToJson(t=!1){let e=new z.Writer;return this.WriteJson(e),e.ToString()}toJson(t=!1){return this.ToJson(t)}LoadJson(t){let e=z.TextToDictionary(t);this.LoadJsonObj(e)}VisitCountAtPathString(t){let n;if(null!==this._patch){let i=this.story.ContentAtPath(new e(t)).container;if(null===i)throw new Error("Content at path not found: "+t);if(n=this._patch.TryGetVisitCount(i,0),n.exists)return n.result}return n=y(this._visitCounts,t,null),n.exists?n.result:0}VisitCountForContainer(t){if(null===t)return d("container");if(!t.visitsShouldBeCounted)return this.story.Error("Read count for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),0;if(null!==this._patch){let e=this._patch.TryGetVisitCount(t,0);if(e.exists)return e.result}let e=t.path.toString(),n=y(this._visitCounts,e,null);return n.exists?n.result:0}IncrementVisitCountForContainer(t){if(null!==this._patch){let e=this.VisitCountForContainer(t);return e++,void this._patch.SetVisitCount(t,e)}let e=t.path.toString(),n=y(this._visitCounts,e,null);n.exists?this._visitCounts.set(e,n.result+1):this._visitCounts.set(e,1)}RecordTurnIndexVisitToContainer(t){if(null!==this._patch)return void this._patch.SetTurnIndex(t,this.currentTurnIndex);let e=t.path.toString();this._turnIndices.set(e,this.currentTurnIndex)}TurnsSinceForContainer(t){if(t.turnIndexShouldBeCounted||this.story.Error("TURNS_SINCE() for target ("+t.name+" - on "+t.debugMetadata+") unknown. The story may need to be compiled with countAllVisits flag (-c)."),null!==this._patch){let e=this._patch.TryGetTurnIndex(t,0);if(e.exists)return this.currentTurnIndex-e.result}let e=t.path.toString(),n=y(this._turnIndices,e,0);return n.exists?this.currentTurnIndex-n.result:-1}get callstackDepth(){return this.callStack.depth}get outputStream(){return this._outputStream}get currentChoices(){return this.canContinue?[]:this._currentChoices}get generatedChoices(){return this._currentChoices}get currentErrors(){return this._currentErrors}get currentWarnings(){return this._currentWarnings}get variablesState(){return this._variablesState}set variablesState(t){this._variablesState=t}get evaluationStack(){return this._evaluationStack}get visitCounts(){return this._visitCounts}get turnIndices(){return this._turnIndices}get currentTurnIndex(){return this._currentTurnIndex}set currentTurnIndex(t){this._currentTurnIndex=t}get currentPathString(){let t=this.currentPointer;return t.isNull?null:null===t.path?d("pointer.path"):t.path.toString()}get currentPointer(){return this.callStack.currentElement.currentPointer.copy()}set currentPointer(t){this.callStack.currentElement.currentPointer=t.copy()}get previousPointer(){return this.callStack.currentThread.previousPointer.copy()}set previousPointer(t){this.callStack.currentThread.previousPointer=t.copy()}get canContinue(){return!this.currentPointer.isNull&&!this.hasError}get hasError(){return null!=this.currentErrors&&this.currentErrors.length>0}get hasWarning(){return null!=this.currentWarnings&&this.currentWarnings.length>0}get currentText(){if(this._outputStreamTextDirty){let t=new m;for(let e of this._outputStream){let n=a(e,T);null!==n&&t.Append(n.value)}this._currentText=this.CleanOutputWhitespace(t.toString()),this._outputStreamTextDirty=!1}return this._currentText}CleanOutputWhitespace(t){let e=new m,n=-1,i=0;for(let r=0;r<t.length;r++){let a=t.charAt(r),s=" "==a||"\t"==a;s&&-1==n&&(n=r),s||("\n"!=a&&n>0&&n!=i&&e.Append(" "),n=-1),"\n"==a&&(i=r+1),s||e.Append(a)}return e.toString()}get currentTags(){if(this._outputStreamTagsDirty){this._currentTags=[];for(let t of this._outputStream){let e=a(t,j);null!==e&&this._currentTags.push(e.text)}this._outputStreamTagsDirty=!1}return this._currentTags}get inExpressionEvaluation(){return this.callStack.currentElement.inExpressionEvaluation}set inExpressionEvaluation(t){this.callStack.currentElement.inExpressionEvaluation=t}GoToStart(){this.callStack.currentElement.currentPointer=I.StartOf(this.story.mainContentContainer)}CopyAndStartPatching(){let t=new H(this.story);return t._patch=new U(this._patch),t.outputStream.push.apply(t.outputStream,this._outputStream),t.OutputStreamDirty(),t._currentChoices.push.apply(t._currentChoices,this._currentChoices),this.hasError&&(t._currentErrors=[],t._currentErrors.push.apply(t._currentErrors,this.currentErrors||[])),this.hasWarning&&(t._currentWarnings=[],t._currentWarnings.push.apply(t._currentWarnings,this.currentWarnings||[])),t.callStack=new q(this.callStack),t.variablesState=this.variablesState,t.variablesState.callStack=t.callStack,t.variablesState.patch=t._patch,t.evaluationStack.push.apply(t.evaluationStack,this.evaluationStack),this.divertedPointer.isNull||(t.divertedPointer=this.divertedPointer.copy()),t.previousPointer=this.previousPointer.copy(),t._visitCounts=this._visitCounts,t._turnIndices=this._turnIndices,t.currentTurnIndex=this.currentTurnIndex,t.storySeed=this.storySeed,t.previousRandom=this.previousRandom,t.didSafeExit=this.didSafeExit,t}RestoreAfterPatch(){this.variablesState.callStack=this.callStack,this.variablesState.patch=this._patch}ApplyAnyPatch(){if(null!==this._patch){this.variablesState.ApplyPatch();for(let[t,e]of this._patch.visitCounts)this.ApplyCountChanges(t,e,!0);for(let[t,e]of this._patch.turnIndices)this.ApplyCountChanges(t,e,!1);this._patch=null}}ApplyCountChanges(t,e,n){(n?this._visitCounts:this._turnIndices).set(t.path.toString(),e)}WriteJson(t){t.WriteObjectStart();let e=!1;for(let n of this._currentChoices){if(null===n.threadAtGeneration)return d("c.threadAtGeneration");n.originalThreadIndex=n.threadAtGeneration.threadIndex,null===this.callStack.ThreadWithIndex(n.originalThreadIndex)&&(e||(e=!0,t.WritePropertyStart("choiceThreads"),t.WriteObjectStart()),t.WritePropertyStart(n.originalThreadIndex),n.threadAtGeneration.WriteJson(t),t.WritePropertyEnd())}if(e&&(t.WriteObjectEnd(),t.WritePropertyEnd()),t.WriteProperty("callstackThreads",t=>this.callStack.WriteJson(t)),t.WriteProperty("variablesState",t=>this.variablesState.WriteJson(t)),t.WriteProperty("evalStack",t=>M.WriteListRuntimeObjs(t,this.evaluationStack)),t.WriteProperty("outputStream",t=>M.WriteListRuntimeObjs(t,this._outputStream)),t.WriteProperty("currentChoices",t=>{t.WriteArrayStart();for(let e of this._currentChoices)M.WriteChoice(t,e);t.WriteArrayEnd()}),!this.divertedPointer.isNull){if(null===this.divertedPointer.path)return d("divertedPointer");t.WriteProperty("currentDivertTarget",this.divertedPointer.path.componentsString)}t.WriteProperty("visitCounts",t=>M.WriteIntDictionary(t,this._visitCounts)),t.WriteProperty("turnIndices",t=>M.WriteIntDictionary(t,this._turnIndices)),t.WriteIntProperty("turnIdx",this.currentTurnIndex),t.WriteIntProperty("storySeed",this.storySeed),t.WriteIntProperty("previousRandom",this.previousRandom),t.WriteIntProperty("inkSaveVersion",this.kInkSaveStateVersion),t.WriteIntProperty("inkFormatVersion",X.inkVersionCurrent),t.WriteObjectEnd()}LoadJsonObj(t){let n=t,i=n.inkSaveVersion;if(null==i)throw new S("ink save format incorrect, can't load.");if(parseInt(i)<this.kMinCompatibleLoadVersion)throw new S("Ink save format isn't compatible with the current version (saw '"+i+"', but minimum is "+this.kMinCompatibleLoadVersion+"), so can't load.");this.callStack.SetJsonToken(n.callstackThreads,this.story),this.variablesState.SetJsonToken(n.variablesState),this._evaluationStack=M.JArrayToRuntimeObjList(n.evalStack),this._outputStream=M.JArrayToRuntimeObjList(n.outputStream),this.OutputStreamDirty(),this._currentChoices=M.JArrayToRuntimeObjList(n.currentChoices);let r=n.currentDivertTarget;if(null!=r){let t=new e(r.toString());this.divertedPointer=this.story.PointerAtPath(t)}this._visitCounts=M.JObjectToIntDictionary(n.visitCounts),this._turnIndices=M.JObjectToIntDictionary(n.turnIndices),this.currentTurnIndex=parseInt(n.turnIdx),this.storySeed=parseInt(n.storySeed),this.previousRandom=parseInt(n.previousRandom);let a=n.choiceThreads;for(let t of this._currentChoices){let e=this.callStack.ThreadWithIndex(t.originalThreadIndex);if(null!=e)t.threadAtGeneration=e.Copy();else{let e=a[t.originalThreadIndex.toString()];t.threadAtGeneration=new q.Thread(e,this.story)}}}ResetErrors(){this._currentErrors=null,this._currentWarnings=null}ResetOutput(t=null){this._outputStream.length=0,null!==t&&this._outputStream.push.apply(this._outputStream,t),this.OutputStreamDirty()}PushToOutputStream(t){let e=a(t,T);if(null!==e){let t=this.TrySplittingHeadTailWhitespace(e);if(null!==t){for(let e of t)this.PushToOutputStreamIndividual(e);return void this.OutputStreamDirty()}}this.PushToOutputStreamIndividual(t),this.OutputStreamDirty()}PopFromOutputStream(t){this.outputStream.splice(this.outputStream.length-t,t),this.OutputStreamDirty()}TrySplittingHeadTailWhitespace(t){let e=t.value;if(null===e)return d("single.value");let n=-1,i=-1;for(let t=0;t<e.length;++t){let r=e[t];if("\n"!=r){if(" "==r||"\t"==r)continue;break}-1==n&&(n=t),i=t}let r=-1,a=-1;for(let t=0;t<e.length;++t){let n=e[t];if("\n"!=n){if(" "==n||"\t"==n)continue;break}-1==r&&(r=t),a=t}if(-1==n&&-1==r)return null;let s=[],l=0,o=e.length;if(-1!=n){if(n>0){let t=new T(e.substring(0,n));s.push(t)}s.push(new T("\n")),l=i+1}if(-1!=r&&(o=a),o>l){let t=e.substring(l,o-l);s.push(new T(t))}if(-1!=r&&a>i&&(s.push(new T("\n")),r<e.length-1)){let t=e.length-r-1,n=new T(e.substring(r+1,t));s.push(n)}return s}PushToOutputStreamIndividual(t){let e=a(t,x),n=a(t,T),i=!0;if(e)this.TrimNewlinesFromOutputStream(),i=!0;else if(n){let t=-1,e=this.callStack.currentElement;e.type==r.Function&&(t=e.functionStartInOutputStream);let a=-1;for(let e=this._outputStream.length-1;e>=0;e--){let n=this._outputStream[e],i=n instanceof A?n:null;if(null!=(n instanceof x?n:null)){a=e;break}if(null!=i&&i.commandType==A.CommandType.BeginString){e>=t&&(t=-1);break}}let s=-1;if(s=-1!=a&&-1!=t?Math.min(t,a):-1!=a?a:t,-1!=s){if(n.isNewline)i=!1;else if(n.isNonWhitespace&&(a>-1&&this.RemoveExistingGlue(),t>-1)){let t=this.callStack.elements;for(let e=t.length-1;e>=0;e--){let n=t[e];if(n.type!=r.Function)break;n.functionStartInOutputStream=-1}}}else n.isNewline&&(!this.outputStreamEndsInNewline&&this.outputStreamContainsContent||(i=!1))}if(i){if(null===t)return d("obj");this._outputStream.push(t),this.OutputStreamDirty()}}TrimNewlinesFromOutputStream(){let t=-1,e=this._outputStream.length-1;for(;e>=0;){let n=this._outputStream[e],i=a(n,A),r=a(n,T);if(null!=i||null!=r&&r.isNonWhitespace)break;null!=r&&r.isNewline&&(t=e),e--}if(t>=0)for(e=t;e<this._outputStream.length;){a(this._outputStream[e],T)?this._outputStream.splice(e,1):e++}this.OutputStreamDirty()}RemoveExistingGlue(){for(let t=this._outputStream.length-1;t>=0;t--){let e=this._outputStream[t];if(e instanceof x)this._outputStream.splice(t,1);else if(e instanceof A)break}this.OutputStreamDirty()}get outputStreamEndsInNewline(){if(this._outputStream.length>0)for(let t=this._outputStream.length-1;t>=0;t--){if(this._outputStream[t]instanceof A)break;let e=this._outputStream[t];if(e instanceof T){if(e.isNewline)return!0;if(e.isNonWhitespace)break}}return!1}get outputStreamContainsContent(){for(let t=0;t<this._outputStream.length;t++)if(this._outputStream[t]instanceof T)return!0;return!1}get inStringEvaluation(){for(let t=this._outputStream.length-1;t>=0;t--){let e=a(this._outputStream[t],A);if(e instanceof A&&e.commandType==A.CommandType.BeginString)return!0}return!1}PushEvaluationStack(t){let e=a(t,O);if(e){let t=e.value;if(null===t)return d("rawList");if(null!=t.originNames){t.origins||(t.origins=[]),t.origins.length=0;for(let e of t.originNames){if(null===this.story.listDefinitions)return d("StoryState.story.listDefinitions");let n=this.story.listDefinitions.TryListGetDefinition(e,null);if(null===n.result)return d("StoryState def.result");t.origins.indexOf(n.result)<0&&t.origins.push(n.result)}}}if(null===t)return d("obj");this.evaluationStack.push(t)}PopEvaluationStack(t){if(void 0===t){return o(this.evaluationStack.pop())}if(t>this.evaluationStack.length)throw new Error("trying to pop too many objects");return o(this.evaluationStack.splice(this.evaluationStack.length-t,t))}PeekEvaluationStack(){return this.evaluationStack[this.evaluationStack.length-1]}ForceEnd(){this.callStack.Reset(),this._currentChoices.length=0,this.currentPointer=I.Null,this.previousPointer=I.Null,this.didSafeExit=!0}TrimWhitespaceFromFunctionEnd(){n.Assert(this.callStack.currentElement.type==r.Function);let t=this.callStack.currentElement.functionStartInOutputStream;-1==t&&(t=0);for(let e=this._outputStream.length-1;e>=t;e--){let t=this._outputStream[e],n=a(t,T),i=a(t,A);if(null!=n){if(i)break;if(!n.isNewline&&!n.isInlineWhitespace)break;this._outputStream.splice(e,1),this.OutputStreamDirty()}}}PopCallStack(t=null){this.callStack.currentElement.type==r.Function&&this.TrimWhitespaceFromFunctionEnd(),this.callStack.Pop(t)}SetChosenPath(t,e){this._currentChoices.length=0;let n=this.story.PointerAtPath(t);n.isNull||-1!=n.index||(n.index=0),this.currentPointer=n,e&&this.currentTurnIndex++}StartFunctionEvaluationFromGame(t,e){this.callStack.Push(r.FunctionEvaluationFromGame,this.evaluationStack.length),this.callStack.currentElement.currentPointer=I.StartOf(t),this.PassArgumentsToEvaluationStack(e)}PassArgumentsToEvaluationStack(t){if(null!=t)for(let e=0;e<t.length;e++){if("number"!=typeof t[e]&&"string"!=typeof t[e])throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");this.PushEvaluationStack(v.Create(t[e]))}}TryExitFunctionEvaluationFromGame(){return this.callStack.currentElement.type==r.FunctionEvaluationFromGame&&(this.currentPointer=I.Null,this.didSafeExit=!0,!0)}CompleteFunctionEvaluationFromGame(){if(this.callStack.currentElement.type!=r.FunctionEvaluationFromGame)throw new S("Expected external function evaluation to be complete. Stack trace: "+this.callStack.callStackTrace);let t=this.callStack.currentElement.evaluationStackHeightWhenPushed,e=null;for(;this.evaluationStack.length>t;){let t=this.PopEvaluationStack();null===e&&(e=t)}if(this.PopCallStack(r.FunctionEvaluationFromGame),e){if(e instanceof L)return null;let t=s(e,v);return t.valueType==i.DivertTarget?t.valueObject.toString():t.valueObject}return null}AddError(t,e){e?(null==this._currentWarnings&&(this._currentWarnings=[]),this._currentWarnings.push(t)):(null==this._currentErrors&&(this._currentErrors=[]),this._currentErrors.push(t))}OutputStreamDirty(){this._outputStreamTextDirty=!0,this._outputStreamTagsDirty=!0}}class ${constructor(){this.startTime=void 0}get ElapsedMilliseconds(){return void 0===this.startTime?0:(new Date).getTime()-this.startTime}Start(){this.startTime=(new Date).getTime()}Stop(){this.startTime=void 0}}Number.isInteger||(Number.isInteger=function(t){return"number"==typeof t&&isFinite(t)&&t>-9007199254740992&&t<9007199254740992&&Math.floor(t)===t});class X extends p{constructor(){let t;super(),this.inkVersionMinimumCompatible=18,this._prevContainers=[],this.allowExternalFunctionFallbacks=!1,this._listDefinitions=null,this._variableObservers=null,this._hasValidatedExternals=!1,this._temporaryEvaluationContainer=null,this._asyncContinueActive=!1,this._stateSnapshotAtLastNewline=null,this._recursiveContinueCount=0,this._asyncSaving=!1,this._profiler=null;let e=null,n=null;if(arguments[0]instanceof N)t=arguments[0],void 0!==arguments[1]&&(e=arguments[1]),this._mainContentContainer=t;else if("string"==typeof arguments[0]){let t=arguments[0];n=z.TextToDictionary(t)}else n=arguments[0];if(null!=e&&(this._listDefinitions=new B(e)),this._externals=new Map,null!==n){let t=n,e=t.inkVersion;if(null==e)throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");let i=parseInt(e);if(i>X.inkVersionCurrent)throw new Error("Version of ink used to build story was newer than the current version of the engine");if(i<this.inkVersionMinimumCompatible)throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");i!=X.inkVersionCurrent&&console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");let r,a=t.root;if(null==a)throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");(r=t.listDefs)&&(this._listDefinitions=M.JTokenToListDefinitions(r)),this._mainContentContainer=s(M.JTokenToRuntimeObject(a),N),this.ResetState()}}get currentChoices(){let t=[];if(null===this._state)return d("this._state");for(let e of this._state.currentChoices)e.isInvisibleDefault||(e.index=t.length,t.push(e));return t}get currentText(){return this.IfAsyncWeCant("call currentText since it's a work in progress"),this.state.currentText}get currentTags(){return this.IfAsyncWeCant("call currentTags since it's a work in progress"),this.state.currentTags}get currentErrors(){return this.state.currentErrors}get currentWarnings(){return this.state.currentWarnings}get hasError(){return this.state.hasError}get hasWarning(){return this.state.hasWarning}get variablesState(){return this.state.variablesState}get listDefinitions(){return this._listDefinitions}get state(){return this._state}StartProfiling(){}EndProfiling(){}ToJson(t){let e=!1;if(t||(e=!0,t=new z.Writer),t.WriteObjectStart(),t.WriteIntProperty("inkVersion",X.inkVersionCurrent),t.WriteProperty("root",t=>M.WriteRuntimeContainer(t,this._mainContentContainer)),null!=this._listDefinitions){t.WritePropertyStart("listDefs"),t.WriteObjectStart();for(let e of this._listDefinitions.lists){t.WritePropertyStart(e.name),t.WriteObjectStart();for(let[n,i]of e.items){let e=f.fromSerializedKey(n),r=i;t.WriteIntProperty(e.itemName,r)}t.WriteObjectEnd(),t.WritePropertyEnd()}t.WriteObjectEnd(),t.WritePropertyEnd()}if(t.WriteObjectEnd(),e)return t.ToString()}ResetState(){this.IfAsyncWeCant("ResetState"),this._state=new H(this),this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this)),this.ResetGlobals()}ResetErrors(){if(null===this._state)return d("this._state");this._state.ResetErrors()}ResetCallstack(){if(this.IfAsyncWeCant("ResetCallstack"),null===this._state)return d("this._state");this._state.ForceEnd()}ResetGlobals(){if(this._mainContentContainer.namedContent.get("global decl")){let t=this.state.currentPointer.copy();this.ChoosePath(new e("global decl"),!1),this.ContinueInternal(),this.state.currentPointer=t}this.state.variablesState.SnapshotDefaultGlobals()}Continue(){return this.ContinueAsync(0),this.currentText}get canContinue(){return this.state.canContinue}get asyncContinueComplete(){return!this._asyncContinueActive}ContinueAsync(t){this._hasValidatedExternals||this.ValidateExternalBindings(),this.ContinueInternal(t)}ContinueInternal(t=0){null!=this._profiler&&this._profiler.PreContinue();let e=t>0;if(this._recursiveContinueCount++,!this._asyncContinueActive){if(this._asyncContinueActive=e,!this.canContinue)throw new S("Can't continue - should check canContinue before calling Continue");this._state.didSafeExit=!1,this._state.ResetOutput(),1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!0)}let n=new $;n.Start();let i=!1;do{try{i=this.ContinueSingleStep()}catch(t){if(!(t instanceof S))throw t;this.AddError(t.message,void 0,t.useEndLineNumber);break}if(i)break;if(this._asyncContinueActive&&n.ElapsedMilliseconds>t)break}while(this.canContinue);n.Stop(),!i&&this.canContinue||(null!==this._stateSnapshotAtLastNewline&&this.RestoreStateSnapshot(),this.canContinue||(this.state.callStack.canPopThread&&this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?"),0!=this.state.generatedChoices.length||this.state.didSafeExit||null!=this._temporaryEvaluationContainer||(this.state.callStack.CanPop(r.Tunnel)?this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?"):this.state.callStack.CanPop(r.Function)?this.AddError("unexpectedly reached end of content. Do you need a '~ return'?"):this.state.callStack.canPop?this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!"):this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?"))),this.state.didSafeExit=!1,1==this._recursiveContinueCount&&(this._state.variablesState.batchObservingVariableChanges=!1),this._asyncContinueActive=!1),this._recursiveContinueCount--,null!=this._profiler&&this._profiler.PostContinue()}ContinueSingleStep(){if(null!=this._profiler&&this._profiler.PreStep(),this.Step(),null!=this._profiler&&this._profiler.PostStep(),this.canContinue||this.state.callStack.elementIsEvaluateFromGame||this.TryFollowDefaultInvisibleChoice(),null!=this._profiler&&this._profiler.PreSnapshot(),!this.state.inStringEvaluation){if(null!==this._stateSnapshotAtLastNewline){if(null===this._stateSnapshotAtLastNewline.currentTags)return d("this._stateAtLastNewline.currentTags");if(null===this.state.currentTags)return d("this.state.currentTags");let t=this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText,this.state.currentText,this._stateSnapshotAtLastNewline.currentTags.length,this.state.currentTags.length);if(t==X.OutputStateChange.ExtendedBeyondNewline)return this.RestoreStateSnapshot(),!0;t==X.OutputStateChange.NewlineRemoved&&this.DiscardSnapshot()}this.state.outputStreamEndsInNewline&&(this.canContinue?null==this._stateSnapshotAtLastNewline&&this.StateSnapshot():this.DiscardSnapshot())}return null!=this._profiler&&this._profiler.PostSnapshot(),!1}CalculateNewlineOutputStateChange(t,e,n,i){if(null===t)return d("prevText");if(null===e)return d("currText");let r=e.length>=t.length&&"\n"==e.charAt(t.length-1);if(n==i&&t.length==e.length&&r)return X.OutputStateChange.NoChange;if(!r)return X.OutputStateChange.NewlineRemoved;if(i>n)return X.OutputStateChange.ExtendedBeyondNewline;for(let n=t.length;n<e.length;n++){let t=e.charAt(n);if(" "!=t&&"\t"!=t)return X.OutputStateChange.ExtendedBeyondNewline}return X.OutputStateChange.NoChange}ContinueMaximally(){this.IfAsyncWeCant("ContinueMaximally");let t=new m;for(;this.canContinue;)t.Append(this.Continue());return t.toString()}ContentAtPath(t){return this.mainContentContainer.ContentAtPath(t)}KnotContainerWithName(t){let e=this.mainContentContainer.namedContent.get(t);return e instanceof N?e:null}PointerAtPath(t){if(0==t.length)return I.Null;let e=new I,n=t.length,i=null;return null===t.lastComponent?d("path.lastComponent"):(t.lastComponent.isIndex?(n=t.length-1,i=this.mainContentContainer.ContentAtPath(t,void 0,n),e.container=i.container,e.index=t.lastComponent.index):(i=this.mainContentContainer.ContentAtPath(t),e.container=i.container,e.index=-1),null==i.obj||i.obj==this.mainContentContainer&&n>0?this.Error("Failed to find content at path '"+t+"', and no approximation of it was possible."):i.approximate&&this.Warning("Failed to find content at path '"+t+"', so it was approximated to: '"+i.obj.path+"'."),e)}StateSnapshot(){this._stateSnapshotAtLastNewline=this._state,this._state=this._state.CopyAndStartPatching()}RestoreStateSnapshot(){null===this._stateSnapshotAtLastNewline&&d("_stateSnapshotAtLastNewline"),this._stateSnapshotAtLastNewline.RestoreAfterPatch(),this._state=this._stateSnapshotAtLastNewline,this._stateSnapshotAtLastNewline=null,this._asyncSaving||this._state.ApplyAnyPatch()}DiscardSnapshot(){this._asyncSaving||this._state.ApplyAnyPatch(),this._stateSnapshotAtLastNewline=null}CopyStateForBackgroundThreadSave(){if(this.IfAsyncWeCant("start saving on a background thread"),this._asyncSaving)throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");let t=this._state;return this._state=this._state.CopyAndStartPatching(),this._asyncSaving=!0,t}BackgroundSaveComplete(){null===this._stateSnapshotAtLastNewline&&this._state.ApplyAnyPatch(),this._asyncSaving=!1}Step(){let t=!0,e=this.state.currentPointer.copy();if(e.isNull)return;let n=a(e.Resolve(),N);for(;n&&(this.VisitContainer(n,!0),0!=n.content.length);)e=I.StartOf(n),n=a(e.Resolve(),N);this.state.currentPointer=e.copy(),null!=this._profiler&&this._profiler.Step(this.state.callStack);let i=e.Resolve(),r=this.PerformLogicAndFlowControl(i);if(this.state.currentPointer.isNull)return;r&&(t=!1);let s=a(i,W);if(s){let e=this.ProcessChoice(s);e&&this.state.generatedChoices.push(e),i=null,t=!1}if(i instanceof N&&(t=!1),t){let t=a(i,w);if(t&&-1==t.contextIndex){let e=this.state.callStack.ContextForVariableNamed(t.variableName);i=new w(t.variableName,e)}this.state.inExpressionEvaluation?this.state.PushEvaluationStack(i):this.state.PushToOutputStream(i)}this.NextContent();let l=a(i,A);l&&l.commandType==A.CommandType.StartThread&&this.state.callStack.PushThread()}VisitContainer(t,e){t.countingAtStartOnly&&!e||(t.visitsShouldBeCounted&&this.state.IncrementVisitCountForContainer(t),t.turnIndexShouldBeCounted&&this.state.RecordTurnIndexVisitToContainer(t))}VisitChangedContainersDueToDivert(){let t=this.state.previousPointer.copy(),e=this.state.currentPointer.copy();if(e.isNull||-1==e.index)return;if(this._prevContainers.length=0,!t.isNull){let e=a(t.Resolve(),N)||a(t.container,N);for(;e;)this._prevContainers.push(e),e=a(e.parent,N)}let n=e.Resolve();if(null==n)return;let i=a(n.parent,N);for(;i&&(this._prevContainers.indexOf(i)<0||i.countingAtStartOnly);){let t=i.content.length>0&&n==i.content[0];this.VisitContainer(i,t),n=i,i=a(i.parent,N)}}ProcessChoice(t){let e=!0;if(t.hasCondition){let t=this.state.PopEvaluationStack();this.IsTruthy(t)||(e=!1)}let n="",i="";if(t.hasChoiceOnlyContent){i=s(this.state.PopEvaluationStack(),T).value||""}if(t.hasStartContent){n=s(this.state.PopEvaluationStack(),T).value||""}if(t.onceOnly){this.state.VisitCountForContainer(t.choiceTarget)>0&&(e=!1)}if(!e)return null;let r=new D;return r.targetPath=t.pathOnChoice,r.sourcePath=t.path.toString(),r.isInvisibleDefault=t.isInvisibleDefault,r.threadAtGeneration=this.state.callStack.ForkThread(),r.text=(n+i).replace(/^[ \t]+|[ \t]+$/g,""),r}IsTruthy(t){if(t instanceof v){let e=t;if(e instanceof P){let t=e;return this.Error("Shouldn't use a divert target (to "+t.targetPath+") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)"),!1}return e.isTruthy}return!1}PerformLogicAndFlowControl(t){if(null==t)return!1;if(t instanceof k){let e=t;if(e.isConditional){let t=this.state.PopEvaluationStack();if(!this.IsTruthy(t))return!0}if(e.hasVariableTarget){let t=e.variableDivertName,n=this.state.variablesState.GetVariableWithName(t);if(null==n)this.Error("Tried to divert using a target from a variable that could not be found ("+t+")");else if(!(n instanceof P)){let e=a(n,b),i="Tried to divert to a target from a variable, but the variable ("+t+") didn't contain a divert target, it ";e instanceof b&&0==e.value?i+="was empty/null (the value 0).":i+="contained '"+n+"'.",this.Error(i)}let i=s(n,P);this.state.divertedPointer=this.PointerAtPath(i.targetPath)}else{if(e.isExternal)return this.CallExternalFunction(e.targetPathString,e.externalArgs),!0;this.state.divertedPointer=e.targetPointer.copy()}return e.pushesToStack&&this.state.callStack.Push(e.stackPushType,void 0,this.state.outputStream.length),this.state.divertedPointer.isNull&&!e.isExternal&&(e&&e.debugMetadata&&null!=e.debugMetadata.sourceName?this.Error("Divert target doesn't exist: "+e.debugMetadata.sourceName):this.Error("Divert resolution failed: "+e)),!0}if(t instanceof A){let e=t;switch(e.commandType){case A.CommandType.EvalStart:this.Assert(!1===this.state.inExpressionEvaluation,"Already in expression evaluation?"),this.state.inExpressionEvaluation=!0;break;case A.CommandType.EvalEnd:this.Assert(!0===this.state.inExpressionEvaluation,"Not in expression evaluation mode"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EvalOutput:if(this.state.evaluationStack.length>0){let t=this.state.PopEvaluationStack();if(!(t instanceof L)){let e=new T(t.toString());this.state.PushToOutputStream(e)}}break;case A.CommandType.NoOp:break;case A.CommandType.Duplicate:this.state.PushEvaluationStack(this.state.PeekEvaluationStack());break;case A.CommandType.PopEvaluatedValue:this.state.PopEvaluationStack();break;case A.CommandType.PopFunction:case A.CommandType.PopTunnel:let t=e.commandType==A.CommandType.PopFunction?r.Function:r.Tunnel,n=null;if(t==r.Tunnel){let t=this.state.PopEvaluationStack();n=a(t,P),null===n&&this.Assert(t instanceof L,"Expected void if ->-> doesn't override target")}if(this.state.TryExitFunctionEvaluationFromGame())break;if(this.state.callStack.currentElement.type==t&&this.state.callStack.canPop)this.state.PopCallStack(),n&&(this.state.divertedPointer=this.PointerAtPath(n.targetPath));else{let e=new Map;e.set(r.Function,"function return statement (~ return)"),e.set(r.Tunnel,"tunnel onwards statement (->->)");let n=e.get(this.state.callStack.currentElement.type);this.state.callStack.canPop||(n="end of flow (-> END or choice)");let i="Found "+e.get(t)+", when expected "+n;this.Error(i)}break;case A.CommandType.BeginString:this.state.PushToOutputStream(e),this.Assert(!0===this.state.inExpressionEvaluation,"Expected to be in an expression when evaluating a string"),this.state.inExpressionEvaluation=!1;break;case A.CommandType.EndString:let i=[],l=0;for(let t=this.state.outputStream.length-1;t>=0;--t){let e=this.state.outputStream[t];l++;let n=a(e,A);if(n&&n.commandType==A.CommandType.BeginString)break;e instanceof T&&i.push(e)}this.state.PopFromOutputStream(l),i=i.reverse();let o=new m;for(let t of i)o.Append(t.toString());this.state.inExpressionEvaluation=!0,this.state.PushEvaluationStack(new T(o.toString()));break;case A.CommandType.ChoiceCount:let u=this.state.generatedChoices.length;this.state.PushEvaluationStack(new b(u));break;case A.CommandType.Turns:this.state.PushEvaluationStack(new b(this.state.currentTurnIndex+1));break;case A.CommandType.TurnsSince:case A.CommandType.ReadCount:let h=this.state.PopEvaluationStack();if(!(h instanceof P)){let t="";h instanceof b&&(t=". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?"),this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw "+h+t);break}let c,p=s(h,P),y=a(this.ContentAtPath(p.targetPath).correctObj,N);null!=y?c=e.commandType==A.CommandType.TurnsSince?this.state.TurnsSinceForContainer(y):this.state.VisitCountForContainer(y):(c=e.commandType==A.CommandType.TurnsSince?-1:0,this.Warning("Failed to find container for "+e.toString()+" lookup at "+p.targetPath.toString())),this.state.PushEvaluationStack(new b(c));break;case A.CommandType.Random:{let t=a(this.state.PopEvaluationStack(),b),e=a(this.state.PopEvaluationStack(),b);if(null==e||e instanceof b==!1)return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");if(null==t||e instanceof b==!1)return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");if(null===t.value)return d("maxInt.value");if(null===e.value)return d("minInt.value");let n=t.value-e.value+1;n<=0&&this.Error("RANDOM was called with minimum as "+e.value+" and maximum as "+t.value+". The maximum must be larger");let i=this.state.storySeed+this.state.previousRandom,r=new K(i).next(),s=r%n+e.value;this.state.PushEvaluationStack(new b(s)),this.state.previousRandom=r;break}case A.CommandType.SeedRandom:let C=a(this.state.PopEvaluationStack(),b);if(null==C||C instanceof b==!1)return this.Error("Invalid value passed to SEED_RANDOM");if(null===C.value)return d("minInt.value");this.state.storySeed=C.value,this.state.previousRandom=0,this.state.PushEvaluationStack(new L);break;case A.CommandType.VisitIndex:let _=this.state.VisitCountForContainer(this.state.currentPointer.container)-1;this.state.PushEvaluationStack(new b(_));break;case A.CommandType.SequenceShuffleIndex:let w=this.NextSequenceShuffleIndex();this.state.PushEvaluationStack(new b(w));break;case A.CommandType.StartThread:break;case A.CommandType.Done:this.state.callStack.canPopThread?this.state.callStack.PopThread():(this.state.didSafeExit=!0,this.state.currentPointer=I.Null);break;case A.CommandType.End:this.state.ForceEnd();break;case A.CommandType.ListFromInt:let E=a(this.state.PopEvaluationStack(),b),x=s(this.state.PopEvaluationStack(),T);if(null===E)throw new S("Passed non-integer when creating a list element from a numerical value.");let k=null;if(null===this.listDefinitions)return d("this.listDefinitions");let W=this.listDefinitions.TryListGetDefinition(x.value,null);if(!W.exists)throw new S("Failed to find LIST called "+x.value);{if(null===E.value)return d("minInt.value");let t=W.result.TryGetItemWithValue(E.value,f.Null);t.exists&&(k=new O(t.result,E.value))}null==k&&(k=new O),this.state.PushEvaluationStack(k);break;case A.CommandType.ListRange:let F=a(this.state.PopEvaluationStack(),v),V=a(this.state.PopEvaluationStack(),v),R=a(this.state.PopEvaluationStack(),O);if(null===R||null===V||null===F)throw new S("Expected list, minimum and maximum for LIST_RANGE");if(null===R.value)return d("targetList.value");let j=R.value.ListWithSubRange(V.valueObject,F.valueObject);this.state.PushEvaluationStack(new O(j));break;case A.CommandType.ListRandom:{let t=this.state.PopEvaluationStack();if(null===t)throw new S("Expected list for LIST_RANDOM");let e=t.value,n=null;if(null===e)throw d("list");if(0==e.Count)n=new g;else{let t=this.state.storySeed+this.state.previousRandom,i=new K(t).next(),r=i%e.Count,a=e.entries();for(let t=0;t<=r-1;t++)a.next();let s=a.next().value,l={Key:f.fromSerializedKey(s[0]),Value:s[1]};if(null===l.Key.originName)return d("randomItem.Key.originName");n=new g(l.Key.originName,this),n.Add(l.Key,l.Value),this.state.previousRandom=i}this.state.PushEvaluationStack(new O(n));break}default:this.Error("unhandled ControlCommand: "+e)}return!0}if(t instanceof V){let e=t,n=this.state.PopEvaluationStack();return this.state.variablesState.Assign(e,n),!0}if(t instanceof F){let e=t,n=null;if(null!=e.pathForCount){let t=e.containerForCount,i=this.state.VisitCountForContainer(t);n=new b(i)}else n=this.state.variablesState.GetVariableWithName(e.name),null==n&&(this.Warning("Variable not found: '"+e.name+"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state."),n=new b(0));return this.state.PushEvaluationStack(n),!0}if(t instanceof R){let e=t,n=this.state.PopEvaluationStack(e.numberOfParameters),i=e.Call(n);return this.state.PushEvaluationStack(i),!0}return!1}ChoosePathString(t,n=!0,i=[]){if(this.IfAsyncWeCant("call ChoosePathString right now"),n)this.ResetCallstack();else if(this.state.callStack.currentElement.type==r.Function){let e="",n=this.state.callStack.currentElement.currentPointer.container;throw null!=n&&(e="("+n.path.toString()+") "),new Error("Story was running a function "+e+"when you called ChoosePathString("+t+") - this is almost certainly not not what you want! Full stack trace: \n"+this.state.callStack.callStackTrace)}this.state.PassArgumentsToEvaluationStack(i),this.ChoosePath(new e(t))}IfAsyncWeCant(t){if(this._asyncContinueActive)throw new Error("Can't "+t+". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.")}ChoosePath(t,e=!0){this.state.SetChosenPath(t,e),this.VisitChangedContainersDueToDivert()}ChooseChoiceIndex(t){t=t;let e=this.currentChoices;this.Assert(t>=0&&t<e.length,"choice out of range");let n=e[t];return null===n.threadAtGeneration?d("choiceToChoose.threadAtGeneration"):null===n.targetPath?d("choiceToChoose.targetPath"):(this.state.callStack.currentThread=n.threadAtGeneration,void this.ChoosePath(n.targetPath))}HasFunction(t){try{return null!=this.KnotContainerWithName(t)}catch(t){return!1}}EvaluateFunction(t,e=[],n=!1){if(this.IfAsyncWeCant("evaluate a function"),null==t)throw new Error("Function is null");if(""==t||""==t.trim())throw new Error("Function is empty or white space.");let i=this.KnotContainerWithName(t);if(null==i)throw new Error("Function doesn't exist: '"+t+"'");let r=[];r.push.apply(r,this.state.outputStream),this._state.ResetOutput(),this.state.StartFunctionEvaluationFromGame(i,e);let a=new m;for(;this.canContinue;)a.Append(this.Continue());let s=a.toString();this._state.ResetOutput(r);let l=this.state.CompleteFunctionEvaluationFromGame();return n?{returned:l,output:s}:l}EvaluateExpression(t){let e=this.state.callStack.elements.length;this.state.callStack.Push(r.Tunnel),this._temporaryEvaluationContainer=t,this.state.GoToStart();let n=this.state.evaluationStack.length;return this.Continue(),this._temporaryEvaluationContainer=null,this.state.callStack.elements.length>e&&this.state.PopCallStack(),this.state.evaluationStack.length>n?this.state.PopEvaluationStack():null}CallExternalFunction(t,e){if(null===t)return d("funcName");let n=this._externals.get(t),i=null;if(!(void 0!==n)){if(this.allowExternalFunctionFallbacks)return i=this.KnotContainerWithName(t),this.Assert(null!==i,"Trying to call EXTERNAL function '"+t+"' which has not been bound, and fallback ink function could not be found."),this.state.callStack.Push(r.Function,void 0,this.state.outputStream.length),void(this.state.divertedPointer=I.StartOf(i));this.Assert(!1,"Trying to call EXTERNAL function '"+t+"' which has not been bound (and ink fallbacks disabled).")}let a=[];for(let t=0;t<e;++t){let t=s(this.state.PopEvaluationStack(),v).valueObject;a.push(t)}a.reverse();let l=n(a),o=null;null!=l?(o=v.Create(l),this.Assert(null!==o,"Could not create ink value from returned object of type "+typeof l)):o=new L,this.state.PushEvaluationStack(o)}BindExternalFunctionGeneral(t,e){this.IfAsyncWeCant("bind an external function"),this.Assert(!this._externals.has(t),"Function '"+t+"' has already been bound."),this._externals.set(t,e)}TryCoerce(t){return t}BindExternalFunction(t,e){this.Assert(null!=e,"Can't bind a null function"),this.BindExternalFunctionGeneral(t,t=>{this.Assert(t.length>=e.length,"External function expected "+e.length+" arguments");let n=[];for(let e=0,i=t.length;e<i;e++)n[e]=this.TryCoerce(t[e]);return e.apply(null,n)})}UnbindExternalFunction(t){this.IfAsyncWeCant("unbind an external a function"),this.Assert(this._externals.has(t),"Function '"+t+"' has not been bound."),this._externals.delete(t)}ValidateExternalBindings(){let t=null,e=null,n=arguments[1]||new Set;if(arguments[0]instanceof N&&(t=arguments[0]),arguments[0]instanceof p&&(e=arguments[0]),null===t&&null===e)if(this.ValidateExternalBindings(this._mainContentContainer,n),this._hasValidatedExternals=!0,0==n.size)this._hasValidatedExternals=!0;else{let t="Error: Missing function binding for external";t+=n.size>1?"s":"",t+=": '",t+=Array.from(n).join("', '"),t+="' ",t+=this.allowExternalFunctionFallbacks?", and no fallback ink function found.":" (ink fallbacks disabled)",this.Error(t)}else if(null!=t){for(let e of t.content){let t=e;null!=t&&t.hasValidName||this.ValidateExternalBindings(e,n)}for(let[,e]of t.namedContent)this.ValidateExternalBindings(a(e,p),n)}else if(null!=e){let t=a(e,k);if(t&&t.isExternal){let e=t.targetPathString;if(null===e)return d("name");if(!this._externals.has(e))if(this.allowExternalFunctionFallbacks){this.mainContentContainer.namedContent.has(e)||n.add(e)}else n.add(e)}}}ObserveVariable(t,e){if(this.IfAsyncWeCant("observe a new variable"),null===this._variableObservers&&(this._variableObservers=new Map),!this.state.variablesState.GlobalVariableExistsWithName(t))throw new S("Cannot observe variable '"+t+"' because it wasn't declared in the ink story.");this._variableObservers.has(t)?this._variableObservers.get(t).push(e):this._variableObservers.set(t,[e])}ObserveVariables(t,e){for(let n=0,i=t.length;n<i;n++)this.ObserveVariable(t[n],e[n])}RemoveVariableObserver(t,e){if(this.IfAsyncWeCant("remove a variable observer"),null!==this._variableObservers)if(void 0!==e){if(this._variableObservers.has(e)){let n=this._variableObservers.get(e);null!==t?n.splice(n.indexOf(t),1):this._variableObservers.delete(e)}}else if(null!==t){let e=this._variableObservers.keys();for(let n of e){let e=this._variableObservers.get(n);e.splice(e.indexOf(t),1)}}}VariableStateDidChangeEvent(t,e){if(null===this._variableObservers)return;let n=this._variableObservers.get(t);if(void 0!==n){if(!(e instanceof v))throw new Error("Tried to get the value of a variable that isn't a standard type");let i=s(e,v);for(let e of n)e(t,i.valueObject)}}get globalTags(){return this.TagsAtStartOfFlowContainerWithPathString("")}TagsForContentAtPath(t){return this.TagsAtStartOfFlowContainerWithPathString(t)}TagsAtStartOfFlowContainerWithPathString(t){let n=new e(t),i=this.ContentAtPath(n).container;if(null===i)return d("flowContainer");for(;;){let t=i.content[0];if(!(t instanceof N))break;i=t}let r=null;for(let t of i.content){let e=a(t,j);if(!e)break;null==r&&(r=[]),r.push(e.text)}return r}BuildStringOfHierarchy(){let t=new m;return this.mainContentContainer.BuildStringOfHierarchy(t,0,this.state.currentPointer.Resolve()),t.toString()}BuildStringOfContainer(t){let e=new m;return t.BuildStringOfHierarchy(e,0,this.state.currentPointer.Resolve()),e.toString()}NextContent(){if(this.state.previousPointer=this.state.currentPointer.copy(),!this.state.divertedPointer.isNull&&(this.state.currentPointer=this.state.divertedPointer.copy(),this.state.divertedPointer=I.Null,this.VisitChangedContainersDueToDivert(),!this.state.currentPointer.isNull))return;if(!this.IncrementContentPointer()){let t=!1;this.state.callStack.CanPop(r.Function)?(this.state.PopCallStack(r.Function),this.state.inExpressionEvaluation&&this.state.PushEvaluationStack(new L),t=!0):this.state.callStack.canPopThread?(this.state.callStack.PopThread(),t=!0):this.state.TryExitFunctionEvaluationFromGame(),t&&!this.state.currentPointer.isNull&&this.NextContent()}}IncrementContentPointer(){let t=!0,e=this.state.callStack.currentElement.currentPointer.copy();if(e.index++,null===e.container)return d("pointer.container");for(;e.index>=e.container.content.length;){t=!1;let n=a(e.container.parent,N);if(n instanceof N==!1)break;let i=n.content.indexOf(e.container);if(-1==i)break;if(e=new I(n,i),e.index++,t=!0,null===e.container)return d("pointer.container")}return t||(e=I.Null),this.state.callStack.currentElement.currentPointer=e.copy(),t}TryFollowDefaultInvisibleChoice(){let t=this._state.currentChoices,e=t.filter(t=>t.isInvisibleDefault);if(0==e.length||t.length>e.length)return!1;let n=e[0];return null===n.targetPath?d("choice.targetPath"):null===n.threadAtGeneration?d("choice.threadAtGeneration"):(this.state.callStack.currentThread=n.threadAtGeneration,this.ChoosePath(n.targetPath,!1),!0)}NextSequenceShuffleIndex(){let t=a(this.state.PopEvaluationStack(),b);if(!(t instanceof b))return this.Error("expected number of elements in sequence for shuffle index"),0;let e=this.state.currentPointer.container;if(null===e)return d("seqContainer");if(null===t.value)return d("numElementsIntVal.value");let n=t.value,i=s(this.state.PopEvaluationStack(),b).value;if(null===i)return d("seqCount");let r=i/n,l=i%n,o=e.path.toString(),u=0;for(let t=0,e=o.length;t<e;t++)u+=o.charCodeAt(t)||0;let h=u+r+this.state.storySeed,c=new K(Math.floor(h)),p=[];for(let t=0;t<n;++t)p.push(t);for(let t=0;t<=l;++t){let e=c.next()%p.length,n=p[e];if(p.splice(e,1),t==l)return n}throw new Error("Should never reach here")}Error(t,e=!1){let n=new S(t);throw n.useEndLineNumber=e,n}Warning(t){this.AddError(t,!0)}AddError(t,e=!1,n=!1){let i=this.currentDebugMetadata,r=e?"WARNING":"ERROR";if(null!=i){let e=n?i.endLineNumber:i.startLineNumber;t="RUNTIME "+r+": '"+i.fileName+"' line "+e+": "+t}else t=this.state.currentPointer.isNull?"RUNTIME "+r+": "+t:"RUNTIME "+r+": ("+this.state.currentPointer+"): "+t;this.state.AddError(t,e),e||this.state.ForceEnd()}Assert(t,e=null){if(0==t)throw null==e&&(e="Story assert"),new Error(e+" "+this.currentDebugMetadata)}get currentDebugMetadata(){let t,e=this.state.currentPointer;if(!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let n=this.state.callStack.elements.length-1;n>=0;--n)if(e=this.state.callStack.elements[n].currentPointer,!e.isNull&&null!==e.Resolve()&&(t=e.Resolve().debugMetadata,null!==t))return t;for(let e=this.state.outputStream.length-1;e>=0;--e){if(t=this.state.outputStream[e].debugMetadata,null!==t)return t}return null}get mainContentContainer(){return this._temporaryEvaluationContainer?this._temporaryEvaluationContainer:this._mainContentContainer}}X.inkVersionCurrent=19,function(t){let e;!function(t){t[t.NoChange=0]="NoChange",t[t.ExtendedBeyondNewline=1]="ExtendedBeyondNewline",t[t.NewlineRemoved=2]="NewlineRemoved"}(e=t.OutputStateChange||(t.OutputStateChange={}))}(X||(X={})),t.InkList=g,t.Story=X,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=ink-es2015.js.map


/***/ }),

/***/ "./node_modules/inkjs/engine/CallStack.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/CallStack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStack = void 0;
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class CallStack {
    constructor() {
        this._threadCounter = 0;
        this._startOfRoot = Pointer_1.Pointer.Null;
        if (arguments[0] instanceof Story_1.Story) {
            let storyContext = arguments[0];
            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
            this.Reset();
        }
        else {
            let toCopy = arguments[0];
            this._threads = [];
            for (let otherThread of toCopy._threads) {
                this._threads.push(otherThread.Copy());
            }
            this._threadCounter = toCopy._threadCounter;
            this._startOfRoot = toCopy._startOfRoot;
        }
    }
    get elements() {
        return this.callStack;
    }
    get depth() {
        return this.elements.length;
    }
    get currentElement() {
        let thread = this._threads[this._threads.length - 1];
        let cs = thread.callstack;
        return cs[cs.length - 1];
    }
    get currentElementIndex() {
        return this.callStack.length - 1;
    }
    get currentThread() {
        return this._threads[this._threads.length - 1];
    }
    set currentThread(value) {
        Debug_1.Debug.Assert(this._threads.length == 1, "Shouldn't be directly setting the current thread when we have a stack of them");
        this._threads.length = 0;
        this._threads.push(value);
    }
    get canPop() {
        return this.callStack.length > 1;
    }
    Reset() {
        this._threads = [];
        this._threads.push(new CallStack.Thread());
        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));
    }
    SetJsonToken(jObject, storyContext) {
        this._threads.length = 0;
        // TODO: (List<object>) jObject ["threads"];
        let jThreads = jObject["threads"];
        for (let jThreadTok of jThreads) {
            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;
            let jThreadObj = jThreadTok;
            let thread = new CallStack.Thread(jThreadObj, storyContext);
            this._threads.push(thread);
        }
        // TODO: (int)jObject ["threadCounter"];
        this._threadCounter = parseInt(jObject["threadCounter"]);
        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
    }
    WriteJson(w) {
        w.WriteObject((writer) => {
            writer.WritePropertyStart("threads");
            writer.WriteArrayStart();
            for (let thread of this._threads) {
                thread.WriteJson(writer);
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WritePropertyStart("threadCounter");
            writer.WriteInt(this._threadCounter);
            writer.WritePropertyEnd();
        });
    }
    PushThread() {
        let newThread = this.currentThread.Copy();
        this._threadCounter++;
        newThread.threadIndex = this._threadCounter;
        this._threads.push(newThread);
    }
    ForkThread() {
        let forkedThread = this.currentThread.Copy();
        this._threadCounter++;
        forkedThread.threadIndex = this._threadCounter;
        return forkedThread;
    }
    PopThread() {
        if (this.canPopThread) {
            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()
        }
        else {
            throw new Error("Can't pop thread");
        }
    }
    get canPopThread() {
        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;
    }
    get elementIsEvaluateFromGame() {
        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;
    }
    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {
        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);
        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;
        element.functionStartInOutputStream = outputStreamLengthWithPushed;
        this.callStack.push(element);
    }
    CanPop(type = null) {
        if (!this.canPop)
            return false;
        if (type == null)
            return true;
        return this.currentElement.type == type;
    }
    Pop(type = null) {
        if (this.CanPop(type)) {
            this.callStack.pop();
            return;
        }
        else {
            throw new Error("Mismatched push/pop in Callstack");
        }
    }
    GetTemporaryVariableWithName(name, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        let varValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (varValue.exists) {
            return varValue.result;
        }
        else {
            return null;
        }
    }
    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        if (!declareNew && !contextElement.temporaryVariables.get(name)) {
            throw new StoryException_1.StoryException("Could not find temporary variable to set: " + name);
        }
        let oldValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (oldValue.exists)
            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        contextElement.temporaryVariables.set(name, value);
    }
    ContextForVariableNamed(name) {
        if (this.currentElement.temporaryVariables.get(name)) {
            return this.currentElementIndex + 1;
        }
        else {
            return 0;
        }
    }
    ThreadWithIndex(index) {
        let filtered = this._threads.filter((t) => {
            if (t.threadIndex == index)
                return t;
        });
        return filtered.length > 0 ? filtered[0] : null;
    }
    get callStack() {
        return this.currentThread.callstack;
    }
    get callStackTrace() {
        let sb = new StringBuilder_1.StringBuilder();
        for (let t = 0; t < this._threads.length; t++) {
            let thread = this._threads[t];
            let isCurrent = t == this._threads.length - 1;
            sb.AppendFormat("=== THREAD {0}/{1} {2}===\n", t + 1, this._threads.length, isCurrent ? "(current) " : "");
            for (let i = 0; i < thread.callstack.length; i++) {
                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)
                    sb.Append("  [FUNCTION] ");
                else
                    sb.Append("  [TUNNEL] ");
                let pointer = thread.callstack[i].currentPointer;
                if (!pointer.isNull) {
                    sb.Append("<SOMEWHERE IN ");
                    if (pointer.container === null) {
                        return NullException_1.throwNullException("pointer.container");
                    }
                    sb.Append(pointer.container.path.toString());
                    sb.AppendLine(">");
                }
            }
        }
        return sb.toString();
    }
}
exports.CallStack = CallStack;
(function (CallStack) {
    class Element {
        constructor(type, pointer, inExpressionEvaluation = false) {
            this.evaluationStackHeightWhenPushed = 0;
            this.functionStartInOutputStream = 0;
            this.currentPointer = pointer.copy();
            this.inExpressionEvaluation = inExpressionEvaluation;
            this.temporaryVariables = new Map();
            this.type = type;
        }
        Copy() {
            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);
            copy.temporaryVariables = new Map(this.temporaryVariables);
            copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;
            copy.functionStartInOutputStream = this.functionStartInOutputStream;
            return copy;
        }
    }
    CallStack.Element = Element;
    class Thread {
        constructor() {
            this.threadIndex = 0;
            this.previousPointer = Pointer_1.Pointer.Null;
            this.callstack = [];
            if (arguments[0] && arguments[1]) {
                let jThreadObj = arguments[0];
                let storyContext = arguments[1];
                // TODO: (int) jThreadObj['threadIndex'] can raise;
                this.threadIndex = parseInt(jThreadObj["threadIndex"]);
                let jThreadCallstack = jThreadObj["callstack"];
                for (let jElTok of jThreadCallstack) {
                    let jElementObj = jElTok;
                    // TODO: (int) jElementObj['type'] can raise;
                    let pushPopType = parseInt(jElementObj["type"]);
                    let pointer = Pointer_1.Pointer.Null;
                    let currentContainerPathStr;
                    // TODO: jElementObj.TryGetValue ("cPath", out currentContainerPathStrToken);
                    let currentContainerPathStrToken = jElementObj["cPath"];
                    if (typeof currentContainerPathStrToken !== "undefined") {
                        currentContainerPathStr = currentContainerPathStrToken.toString();
                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));
                        pointer.container = threadPointerResult.container;
                        pointer.index = parseInt(jElementObj["idx"]);
                        if (threadPointerResult.obj == null)
                            throw new Error("When loading state, internal story location couldn't be found: " +
                                currentContainerPathStr +
                                ". Has the story changed since this save data was created?");
                        else if (threadPointerResult.approximate) {
                            if (pointer.container === null) {
                                return NullException_1.throwNullException("pointer.container");
                            }
                            storyContext.Warning("When loading state, exact internal story location couldn't be found: '" +
                                currentContainerPathStr +
                                "', so it was approximated to '" +
                                pointer.container.path.toString() +
                                "' to recover. Has the story changed since this save data was created?");
                        }
                    }
                    let inExpressionEvaluation = !!jElementObj["exp"];
                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);
                    let temps = jElementObj["temp"];
                    if (typeof temps !== "undefined") {
                        el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);
                    }
                    else {
                        el.temporaryVariables.clear();
                    }
                    this.callstack.push(el);
                }
                let prevContentObjPath = jThreadObj["previousContentObject"];
                if (typeof prevContentObjPath !== "undefined") {
                    let prevPath = new Path_1.Path(prevContentObjPath.toString());
                    this.previousPointer = storyContext.PointerAtPath(prevPath);
                }
            }
        }
        Copy() {
            let copy = new Thread();
            copy.threadIndex = this.threadIndex;
            for (let e of this.callstack) {
                copy.callstack.push(e.Copy());
            }
            copy.previousPointer = this.previousPointer.copy();
            return copy;
        }
        WriteJson(writer) {
            writer.WriteObjectStart();
            writer.WritePropertyStart("callstack");
            writer.WriteArrayStart();
            for (let el of this.callstack) {
                writer.WriteObjectStart();
                if (!el.currentPointer.isNull) {
                    if (el.currentPointer.container === null) {
                        return NullException_1.throwNullException("el.currentPointer.container");
                    }
                    writer.WriteProperty("cPath", el.currentPointer.container.path.componentsString);
                    writer.WriteIntProperty("idx", el.currentPointer.index);
                }
                writer.WriteProperty("exp", el.inExpressionEvaluation);
                writer.WriteIntProperty("type", el.type);
                if (el.temporaryVariables.size > 0) {
                    writer.WritePropertyStart("temp");
                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);
                    writer.WritePropertyEnd();
                }
                writer.WriteObjectEnd();
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WriteIntProperty("threadIndex", this.threadIndex);
            if (!this.previousPointer.isNull) {
                let resolvedPointer = this.previousPointer.Resolve();
                if (resolvedPointer === null) {
                    return NullException_1.throwNullException("this.previousPointer.Resolve()");
                }
                writer.WriteProperty("previousContentObject", resolvedPointer.path.toString());
            }
            writer.WriteObjectEnd();
        }
    }
    CallStack.Thread = Thread;
})(CallStack = exports.CallStack || (exports.CallStack = {}));
//# sourceMappingURL=CallStack.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Choice.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Choice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Choice = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Choice extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.text = "";
        this.index = 0;
        this.threadAtGeneration = null;
        this.sourcePath = "";
        this.targetPath = null;
        this.isInvisibleDefault = false;
        this.originalThreadIndex = 0;
    }
    get pathStringOnChoice() {
        if (this.targetPath === null)
            return NullException_1.throwNullException("Choice.targetPath");
        return this.targetPath.toString();
    }
    set pathStringOnChoice(value) {
        this.targetPath = new Path_1.Path(value);
    }
}
exports.Choice = Choice;
//# sourceMappingURL=Choice.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ChoicePoint.js":
/*!**************************************************!*\
  !*** ./node_modules/inkjs/engine/ChoicePoint.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoicePoint = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ChoicePoint extends Object_1.InkObject {
    constructor(onceOnly = true) {
        super();
        this._pathOnChoice = null;
        this.hasCondition = false;
        this.hasStartContent = false;
        this.hasChoiceOnlyContent = false;
        this.isInvisibleDefault = false;
        this.onceOnly = true;
        this.onceOnly = onceOnly;
    }
    get pathOnChoice() {
        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {
            let choiceTargetObj = this.choiceTarget;
            if (choiceTargetObj) {
                this._pathOnChoice = choiceTargetObj.path;
            }
        }
        return this._pathOnChoice;
    }
    set pathOnChoice(value) {
        this._pathOnChoice = value;
    }
    get choiceTarget() {
        if (this._pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint._pathOnChoice");
        return this.ResolvePath(this._pathOnChoice).container;
    }
    get pathStringOnChoice() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        return this.CompactPathString(this.pathOnChoice);
    }
    set pathStringOnChoice(value) {
        this.pathOnChoice = new Path_1.Path(value);
    }
    get flags() {
        let flags = 0;
        if (this.hasCondition)
            flags |= 1;
        if (this.hasStartContent)
            flags |= 2;
        if (this.hasChoiceOnlyContent)
            flags |= 4;
        if (this.isInvisibleDefault)
            flags |= 8;
        if (this.onceOnly)
            flags |= 16;
        return flags;
    }
    set flags(value) {
        this.hasCondition = (value & 1) > 0;
        this.hasStartContent = (value & 2) > 0;
        this.hasChoiceOnlyContent = (value & 4) > 0;
        this.isInvisibleDefault = (value & 8) > 0;
        this.onceOnly = (value & 16) > 0;
    }
    toString() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);
        let targetLineNum = null;
        let targetString = this.pathOnChoice.toString();
        if (targetLineNum != null) {
            targetString = " line " + targetLineNum + "(" + targetString + ")";
        }
        return "Choice: -> " + targetString;
    }
}
exports.ChoicePoint = ChoicePoint;
//# sourceMappingURL=ChoicePoint.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Container.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/Container.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const SearchResult_1 = __webpack_require__(/*! ./SearchResult */ "./node_modules/inkjs/engine/SearchResult.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
class Container extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.name = "";
        this._content = [];
        this.namedContent = new Map();
        this.visitsShouldBeCounted = false;
        this.turnIndexShouldBeCounted = false;
        this.countingAtStartOnly = false;
        this._pathToFirstLeafContent = null;
    }
    get hasValidName() {
        return this.name != null && this.name.length > 0;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this.AddContent(value);
    }
    get namedOnlyContent() {
        let namedOnlyContentDict = new Map();
        for (let [key, value] of this.namedContent) {
            let inkObject = TypeAssertion_1.asOrThrows(value, Object_1.InkObject);
            namedOnlyContentDict.set(key, inkObject);
        }
        for (let c of this.content) {
            let named = TypeAssertion_1.asINamedContentOrNull(c);
            if (named != null && named.hasValidName) {
                namedOnlyContentDict.delete(named.name);
            }
        }
        if (namedOnlyContentDict.size == 0)
            namedOnlyContentDict = null;
        return namedOnlyContentDict;
    }
    set namedOnlyContent(value) {
        let existingNamedOnly = this.namedOnlyContent;
        if (existingNamedOnly != null) {
            for (let [key] of existingNamedOnly) {
                this.namedContent.delete(key);
            }
        }
        if (value == null)
            return;
        for (let [, val] of value) {
            let named = TypeAssertion_1.asINamedContentOrNull(val);
            if (named != null)
                this.AddToNamedContentOnly(named);
        }
    }
    get countFlags() {
        let flags = 0;
        if (this.visitsShouldBeCounted)
            flags |= Container.CountFlags.Visits;
        if (this.turnIndexShouldBeCounted)
            flags |= Container.CountFlags.Turns;
        if (this.countingAtStartOnly)
            flags |= Container.CountFlags.CountStartOnly;
        if (flags == Container.CountFlags.CountStartOnly) {
            flags = 0;
        }
        return flags;
    }
    set countFlags(value) {
        let flag = value;
        if ((flag & Container.CountFlags.Visits) > 0)
            this.visitsShouldBeCounted = true;
        if ((flag & Container.CountFlags.Turns) > 0)
            this.turnIndexShouldBeCounted = true;
        if ((flag & Container.CountFlags.CountStartOnly) > 0)
            this.countingAtStartOnly = true;
    }
    get pathToFirstLeafContent() {
        if (this._pathToFirstLeafContent == null)
            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);
        return this._pathToFirstLeafContent;
    }
    get internalPathToFirstLeafContent() {
        let components = [];
        let container = this;
        while (container instanceof Container) {
            if (container.content.length > 0) {
                components.push(new Path_1.Path.Component(0));
                container = container.content[0];
            }
        }
        return new Path_1.Path(components);
    }
    AddContent(contentObjOrList) {
        if (contentObjOrList instanceof Array) {
            let contentList = contentObjOrList;
            for (let c of contentList) {
                this.AddContent(c);
            }
        }
        else {
            let contentObj = contentObjOrList;
            this._content.push(contentObj);
            if (contentObj.parent) {
                throw new Error("content is already in " + contentObj.parent);
            }
            contentObj.parent = this;
            this.TryAddNamedContent(contentObj);
        }
    }
    TryAddNamedContent(contentObj) {
        let namedContentObj = TypeAssertion_1.asINamedContentOrNull(contentObj);
        if (namedContentObj != null && namedContentObj.hasValidName) {
            this.AddToNamedContentOnly(namedContentObj);
        }
    }
    AddToNamedContentOnly(namedContentObj) {
        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, "Can only add Runtime.Objects to a Runtime.Container");
        let runtimeObj = TypeAssertion_1.asOrThrows(namedContentObj, Object_1.InkObject);
        runtimeObj.parent = this;
        this.namedContent.set(namedContentObj.name, namedContentObj);
    }
    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {
        if (partialPathLength == -1)
            partialPathLength = path.length;
        let result = new SearchResult_1.SearchResult();
        result.approximate = false;
        let currentContainer = this;
        let currentObj = this;
        for (let i = partialPathStart; i < partialPathLength; ++i) {
            let comp = path.GetComponent(i);
            if (currentContainer == null) {
                result.approximate = true;
                break;
            }
            let foundObj = currentContainer.ContentWithPathComponent(comp);
            if (foundObj == null) {
                result.approximate = true;
                break;
            }
            currentObj = foundObj;
            currentContainer = TypeAssertion_1.asOrNull(foundObj, Container);
        }
        result.obj = currentObj;
        return result;
    }
    InsertContent(contentObj, index) {
        this.content[index] = contentObj;
        if (contentObj.parent) {
            throw new Error("content is already in " + contentObj.parent);
        }
        contentObj.parent = this;
        this.TryAddNamedContent(contentObj);
    }
    AddContentsOfContainer(otherContainer) {
        this.content = this.content.concat(otherContainer.content);
        for (let obj of otherContainer.content) {
            obj.parent = this;
            this.TryAddNamedContent(obj);
        }
    }
    ContentWithPathComponent(component) {
        if (component.isIndex) {
            if (component.index >= 0 && component.index < this.content.length) {
                return this.content[component.index];
            }
            else {
                return null;
            }
        }
        else if (component.isParent) {
            return this.parent;
        }
        else {
            if (component.name === null) {
                return NullException_1.throwNullException("component.name");
            }
            let foundContent = TryGetResult_1.tryGetValueFromMap(this.namedContent, component.name, null);
            if (foundContent.exists) {
                return TypeAssertion_1.asOrThrows(foundContent.result, Object_1.InkObject);
            }
            else {
                return null;
            }
        }
    }
    BuildStringOfHierarchy() {
        let sb;
        if (arguments.length == 0) {
            sb = new StringBuilder_1.StringBuilder();
            this.BuildStringOfHierarchy(sb, 0, null);
            return sb.toString();
        }
        sb = arguments[0];
        let indentation = arguments[1];
        let pointedObj = arguments[2];
        function appendIndentation() {
            const spacesPerIndent = 4; // Truly const in the original code
            for (let i = 0; i < spacesPerIndent * indentation; ++i) {
                sb.Append(" ");
            }
        }
        appendIndentation();
        sb.Append("[");
        if (this.hasValidName) {
            sb.AppendFormat(" ({0})", this.name);
        }
        if (this == pointedObj) {
            sb.Append("  <---");
        }
        sb.AppendLine();
        indentation++;
        for (let i = 0; i < this.content.length; ++i) {
            let obj = this.content[i];
            if (obj instanceof Container) {
                let container = obj;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
            }
            else {
                appendIndentation();
                if (obj instanceof Value_1.StringValue) {
                    sb.Append('"');
                    sb.Append(obj.toString().replace("\n", "\\n"));
                    sb.Append('"');
                }
                else {
                    sb.Append(obj.toString());
                }
            }
            if (i != this.content.length - 1) {
                sb.Append(",");
            }
            if (!(obj instanceof Container) && obj == pointedObj) {
                sb.Append("  <---");
            }
            sb.AppendLine();
        }
        let onlyNamed = new Map();
        for (let [key, value] of this.namedContent) {
            if (this.content.indexOf(TypeAssertion_1.asOrThrows(value, Object_1.InkObject)) >= 0) {
                continue;
            }
            else {
                onlyNamed.set(key, value);
            }
        }
        if (onlyNamed.size > 0) {
            appendIndentation();
            sb.AppendLine("-- named: --");
            for (let [, value] of onlyNamed) {
                Debug_1.Debug.AssertType(value, Container, "Can only print out named Containers");
                let container = value;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
                sb.AppendLine();
            }
        }
        indentation--;
        appendIndentation();
        sb.Append("]");
    }
}
exports.Container = Container;
(function (Container) {
    let CountFlags;
    (function (CountFlags) {
        CountFlags[CountFlags["Visits"] = 1] = "Visits";
        CountFlags[CountFlags["Turns"] = 2] = "Turns";
        CountFlags[CountFlags["CountStartOnly"] = 4] = "CountStartOnly";
    })(CountFlags = Container.CountFlags || (Container.CountFlags = {}));
})(Container = exports.Container || (exports.Container = {}));
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ControlCommand.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ControlCommand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlCommand = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class ControlCommand extends Object_1.InkObject {
    constructor(commandType = ControlCommand.CommandType.NotSet) {
        super();
        this._commandType = commandType;
    }
    get commandType() {
        return this._commandType;
    }
    Copy() {
        return new ControlCommand(this.commandType);
    }
    static EvalStart() {
        return new ControlCommand(ControlCommand.CommandType.EvalStart);
    }
    static EvalOutput() {
        return new ControlCommand(ControlCommand.CommandType.EvalOutput);
    }
    static EvalEnd() {
        return new ControlCommand(ControlCommand.CommandType.EvalEnd);
    }
    static Duplicate() {
        return new ControlCommand(ControlCommand.CommandType.Duplicate);
    }
    static PopEvaluatedValue() {
        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);
    }
    static PopFunction() {
        return new ControlCommand(ControlCommand.CommandType.PopFunction);
    }
    static PopTunnel() {
        return new ControlCommand(ControlCommand.CommandType.PopTunnel);
    }
    static BeginString() {
        return new ControlCommand(ControlCommand.CommandType.BeginString);
    }
    static EndString() {
        return new ControlCommand(ControlCommand.CommandType.EndString);
    }
    static NoOp() {
        return new ControlCommand(ControlCommand.CommandType.NoOp);
    }
    static ChoiceCount() {
        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);
    }
    static Turns() {
        return new ControlCommand(ControlCommand.CommandType.Turns);
    }
    static TurnsSince() {
        return new ControlCommand(ControlCommand.CommandType.TurnsSince);
    }
    static ReadCount() {
        return new ControlCommand(ControlCommand.CommandType.ReadCount);
    }
    static Random() {
        return new ControlCommand(ControlCommand.CommandType.Random);
    }
    static SeedRandom() {
        return new ControlCommand(ControlCommand.CommandType.SeedRandom);
    }
    static VisitIndex() {
        return new ControlCommand(ControlCommand.CommandType.VisitIndex);
    }
    static SequenceShuffleIndex() {
        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);
    }
    static StartThread() {
        return new ControlCommand(ControlCommand.CommandType.StartThread);
    }
    static Done() {
        return new ControlCommand(ControlCommand.CommandType.Done);
    }
    static End() {
        return new ControlCommand(ControlCommand.CommandType.End);
    }
    static ListFromInt() {
        return new ControlCommand(ControlCommand.CommandType.ListFromInt);
    }
    static ListRange() {
        return new ControlCommand(ControlCommand.CommandType.ListRange);
    }
    static ListRandom() {
        return new ControlCommand(ControlCommand.CommandType.ListRandom);
    }
    toString() {
        return this.commandType.toString();
    }
}
exports.ControlCommand = ControlCommand;
(function (ControlCommand) {
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["NotSet"] = -1] = "NotSet";
        CommandType[CommandType["EvalStart"] = 0] = "EvalStart";
        CommandType[CommandType["EvalOutput"] = 1] = "EvalOutput";
        CommandType[CommandType["EvalEnd"] = 2] = "EvalEnd";
        CommandType[CommandType["Duplicate"] = 3] = "Duplicate";
        CommandType[CommandType["PopEvaluatedValue"] = 4] = "PopEvaluatedValue";
        CommandType[CommandType["PopFunction"] = 5] = "PopFunction";
        CommandType[CommandType["PopTunnel"] = 6] = "PopTunnel";
        CommandType[CommandType["BeginString"] = 7] = "BeginString";
        CommandType[CommandType["EndString"] = 8] = "EndString";
        CommandType[CommandType["NoOp"] = 9] = "NoOp";
        CommandType[CommandType["ChoiceCount"] = 10] = "ChoiceCount";
        CommandType[CommandType["Turns"] = 11] = "Turns";
        CommandType[CommandType["TurnsSince"] = 12] = "TurnsSince";
        CommandType[CommandType["Random"] = 13] = "Random";
        CommandType[CommandType["SeedRandom"] = 14] = "SeedRandom";
        CommandType[CommandType["VisitIndex"] = 15] = "VisitIndex";
        CommandType[CommandType["SequenceShuffleIndex"] = 16] = "SequenceShuffleIndex";
        CommandType[CommandType["StartThread"] = 17] = "StartThread";
        CommandType[CommandType["Done"] = 18] = "Done";
        CommandType[CommandType["End"] = 19] = "End";
        CommandType[CommandType["ListFromInt"] = 20] = "ListFromInt";
        CommandType[CommandType["ListRange"] = 21] = "ListRange";
        CommandType[CommandType["ListRandom"] = 22] = "ListRandom";
        CommandType[CommandType["ReadCount"] = 23] = "ReadCount";
        CommandType[CommandType["TOTAL_VALUES"] = 24] = "TOTAL_VALUES";
    })(CommandType = ControlCommand.CommandType || (ControlCommand.CommandType = {}));
})(ControlCommand = exports.ControlCommand || (exports.ControlCommand = {}));
//# sourceMappingURL=ControlCommand.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Debug.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Debug.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Debug = void 0;
var Debug;
(function (Debug) {
    function AssertType(variable, type, message) {
        Assert(variable instanceof type, message);
    }
    Debug.AssertType = AssertType;
    function Assert(condition, message) {
        if (!condition) {
            if (typeof message !== "undefined") {
                console.warn(message);
            }
            if (console.trace) {
                console.trace();
            }
            throw new Error("");
        }
    }
    Debug.Assert = Assert;
})(Debug = exports.Debug || (exports.Debug = {}));
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Divert.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Divert.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Divert = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class Divert extends Object_1.InkObject {
    constructor(stackPushType) {
        super();
        this._targetPath = null;
        this._targetPointer = Pointer_1.Pointer.Null;
        this.variableDivertName = null;
        this.pushesToStack = false;
        this.stackPushType = 0;
        this.isExternal = false;
        this.externalArgs = 0;
        this.isConditional = false;
        this.pushesToStack = false;
        if (typeof stackPushType !== "undefined") {
            this.pushesToStack = true;
            this.stackPushType = stackPushType;
        }
    }
    get targetPath() {
        if (this._targetPath != null && this._targetPath.isRelative) {
            let targetObj = this.targetPointer.Resolve();
            if (targetObj) {
                this._targetPath = targetObj.path;
            }
        }
        return this._targetPath;
    }
    set targetPath(value) {
        this._targetPath = value;
        this._targetPointer = Pointer_1.Pointer.Null;
    }
    get targetPointer() {
        if (this._targetPointer.isNull) {
            let targetObj = this.ResolvePath(this._targetPath).obj;
            if (this._targetPath === null)
                return NullException_1.throwNullException("this._targetPath");
            if (this._targetPath.lastComponent === null)
                return NullException_1.throwNullException("this._targetPath.lastComponent");
            if (this._targetPath.lastComponent.isIndex) {
                if (targetObj === null)
                    return NullException_1.throwNullException("targetObj");
                this._targetPointer.container =
                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;
                this._targetPointer.index = this._targetPath.lastComponent.index;
            }
            else {
                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);
            }
        }
        return this._targetPointer.copy();
    }
    get targetPathString() {
        if (this.targetPath == null)
            return null;
        return this.CompactPathString(this.targetPath);
    }
    set targetPathString(value) {
        if (value == null) {
            this.targetPath = null;
        }
        else {
            this.targetPath = new Path_1.Path(value);
        }
    }
    get hasVariableTarget() {
        return this.variableDivertName != null;
    }
    Equals(obj) {
        let otherDivert = obj;
        if (otherDivert instanceof Divert) {
            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {
                if (this.hasVariableTarget) {
                    return this.variableDivertName == otherDivert.variableDivertName;
                }
                else {
                    if (this.targetPath === null)
                        return NullException_1.throwNullException("this.targetPath");
                    return this.targetPath.Equals(otherDivert.targetPath);
                }
            }
        }
        return false;
    }
    toString() {
        if (this.hasVariableTarget) {
            return "Divert(variable: " + this.variableDivertName + ")";
        }
        else if (this.targetPath == null) {
            return "Divert(null)";
        }
        else {
            let sb = new StringBuilder_1.StringBuilder();
            let targetStr = this.targetPath.toString();
            // int? targetLineNum = DebugLineNumberOfPath (targetPath);
            let targetLineNum = null;
            if (targetLineNum != null) {
                targetStr = "line " + targetLineNum;
            }
            sb.Append("Divert");
            if (this.isConditional)
                sb.Append("?");
            if (this.pushesToStack) {
                if (this.stackPushType == PushPop_1.PushPopType.Function) {
                    sb.Append(" function");
                }
                else {
                    sb.Append(" tunnel");
                }
            }
            sb.Append(" -> ");
            sb.Append(this.targetPathString);
            sb.Append(" (");
            sb.Append(targetStr);
            sb.Append(")");
            return sb.toString();
        }
    }
}
exports.Divert = Divert;
//# sourceMappingURL=Divert.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Glue.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Glue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Glue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Glue extends Object_1.InkObject {
    toString() {
        return "Glue";
    }
}
exports.Glue = Glue;
//# sourceMappingURL=Glue.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/InkList.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/InkList.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkList = exports.InkListItem = void 0;
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
class InkListItem {
    constructor() {
        // InkListItem is a struct
        this.originName = null;
        this.itemName = null;
        if (typeof arguments[1] !== "undefined") {
            let originName = arguments[0];
            let itemName = arguments[1];
            this.originName = originName;
            this.itemName = itemName;
        }
        else if (arguments[0]) {
            let fullName = arguments[0];
            let nameParts = fullName.toString().split(".");
            this.originName = nameParts[0];
            this.itemName = nameParts[1];
        }
    }
    static get Null() {
        return new InkListItem(null, null);
    }
    get isNull() {
        return this.originName == null && this.itemName == null;
    }
    get fullName() {
        return ((this.originName !== null ? this.originName : "?") + "." + this.itemName);
    }
    toString() {
        return this.fullName;
    }
    Equals(obj) {
        if (obj instanceof InkListItem) {
            let otherItem = obj;
            return (otherItem.itemName == this.itemName &&
                otherItem.originName == this.originName);
        }
        return false;
    }
    // These methods did not exist in the original C# code. Their purpose is to
    // make `InkListItem` mimics the value-type semantics of the original
    // struct. Please refer to the end of this file, for a more in-depth
    // explanation.
    /**
     * Returns a shallow clone of the current instance.
     */
    copy() {
        return new InkListItem(this.originName, this.itemName);
    }
    /**
     * Returns a `SerializedInkListItem` representing the current
     * instance. The result is intended to be used as a key inside a Map.
     */
    serialized() {
        // We are simply using a JSON representation as a value-typed key.
        return JSON.stringify({
            originName: this.originName,
            itemName: this.itemName,
        });
    }
    /**
     * Reconstructs a `InkListItem` from the given SerializedInkListItem.
     */
    static fromSerializedKey(key) {
        let obj = JSON.parse(key);
        if (!InkListItem.isLikeInkListItem(obj))
            return InkListItem.Null;
        let inkListItem = obj;
        return new InkListItem(inkListItem.originName, inkListItem.itemName);
    }
    /**
     * Determines whether the given item is sufficiently `InkListItem`-like
     * to be used as a template when reconstructing the InkListItem.
     */
    static isLikeInkListItem(item) {
        if (typeof item !== "object")
            return false;
        if (!item.hasOwnProperty("originName") || !item.hasOwnProperty("itemName"))
            return false;
        if (typeof item.originName !== "string" && typeof item.originName !== null)
            return false;
        if (typeof item.itemName !== "string" && typeof item.itemName !== null)
            return false;
        return true;
    }
}
exports.InkListItem = InkListItem;
class InkList extends Map {
    constructor() {
        // Trying to be smart here, this emulates the constructor inheritance found
        // in the original code, but only if otherList is an InkList. IIFE FTW.
        super((() => {
            if (arguments[0] instanceof InkList) {
                return arguments[0];
            }
            else {
                return [];
            }
        })());
        this.origins = null;
        this._originNames = [];
        if (arguments[0] instanceof InkList) {
            let otherList = arguments[0];
            if (otherList._originNames) {
                this._originNames = otherList._originNames.slice();
            }
        }
        else if (typeof arguments[0] === "string") {
            let singleOriginListName = arguments[0];
            let originStory = arguments[1]; /* as Story */
            this.SetInitialOriginName(singleOriginListName);
            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);
            if (def.exists) {
                this.origins = [def.result];
            }
            else {
                throw new Error("InkList origin could not be found in story when constructing new list: " +
                    singleOriginListName);
            }
        }
        else if (typeof arguments[0] === "object" &&
            arguments[0].hasOwnProperty("Key") &&
            arguments[0].hasOwnProperty("Value")) {
            let singleElement = arguments[0];
            this.Add(singleElement.Key, singleElement.Value);
        }
    }
    AddItem(itemOrItemName) {
        if (itemOrItemName instanceof InkListItem) {
            let item = itemOrItemName;
            if (item.originName == null) {
                this.AddItem(item.itemName);
                return;
            }
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (origin.name == item.originName) {
                    let intVal = origin.TryGetValueForItem(item, 0);
                    if (intVal.exists) {
                        this.Add(item, intVal.result);
                        return;
                    }
                    else {
                        throw new Error("Could not add the item " +
                            item +
                            " to this list because it doesn't exist in the original list definition in ink.");
                    }
                }
            }
            throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.");
        }
        else {
            let itemName = itemOrItemName;
            let foundListDef = null;
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (itemName === null)
                    return NullException_1.throwNullException("itemName");
                if (origin.ContainsItemWithName(itemName)) {
                    if (foundListDef != null) {
                        throw new Error("Could not add the item " +
                            itemName +
                            " to this list because it could come from either " +
                            origin.name +
                            " or " +
                            foundListDef.name);
                    }
                    else {
                        foundListDef = origin;
                    }
                }
            }
            if (foundListDef == null)
                throw new Error("Could not add the item " +
                    itemName +
                    " to this list because it isn't known to any list definitions previously associated with this list.");
            let item = new InkListItem(foundListDef.name, itemName);
            let itemVal = foundListDef.ValueForItem(item);
            this.Add(item, itemVal);
        }
    }
    ContainsItemNamed(itemName) {
        for (let [key] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (item.itemName == itemName)
                return true;
        }
        return false;
    }
    ContainsKey(key) {
        return this.has(key.serialized());
    }
    Add(key, value) {
        let serializedKey = key.serialized();
        if (this.has(serializedKey)) {
            // Throw an exception to match the C# behavior.
            throw new Error(`The Map already contains an entry for ${key}`);
        }
        this.set(serializedKey, value);
    }
    Remove(key) {
        return this.delete(key.serialized());
    }
    get Count() {
        return this.size;
    }
    get originOfMaxItem() {
        if (this.origins == null)
            return null;
        let maxOriginName = this.maxItem.Key.originName;
        let result = null;
        this.origins.every((origin) => {
            if (origin.name == maxOriginName) {
                result = origin;
                return false;
            }
            else
                return true;
        });
        return result;
    }
    get originNames() {
        if (this.Count > 0) {
            if (this._originNames == null && this.Count > 0)
                this._originNames = [];
            else {
                if (!this._originNames)
                    this._originNames = [];
                this._originNames.length = 0;
            }
            for (let [key] of this) {
                let item = InkListItem.fromSerializedKey(key);
                if (item.originName === null)
                    return NullException_1.throwNullException("item.originName");
                this._originNames.push(item.originName);
            }
        }
        return this._originNames;
    }
    SetInitialOriginName(initialOriginName) {
        this._originNames = [initialOriginName];
    }
    SetInitialOriginNames(initialOriginNames) {
        if (initialOriginNames == null)
            this._originNames = null;
        else
            this._originNames = initialOriginNames.slice(); // store a copy
    }
    get maxItem() {
        let max = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (max.Key.isNull || value > max.Value)
                max = { Key: item, Value: value };
        }
        return max;
    }
    get minItem() {
        let min = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (min.Key.isNull || value < min.Value) {
                min = { Key: item, Value: value };
            }
        }
        return min;
    }
    get inverse() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    if (!this.ContainsKey(item))
                        list.Add(item, value);
                }
            }
        }
        return list;
    }
    get all() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    list.set(item.serialized(), value);
                }
            }
        }
        return list;
    }
    Union(otherList) {
        let union = new InkList(this);
        for (let [key, value] of otherList) {
            union.set(key, value);
        }
        return union;
    }
    Intersect(otherList) {
        let intersection = new InkList();
        for (let [key, value] of this) {
            if (otherList.has(key))
                intersection.set(key, value);
        }
        return intersection;
    }
    Without(listToRemove) {
        let result = new InkList(this);
        for (let [key] of listToRemove) {
            result.delete(key);
        }
        return result;
    }
    Contains(otherList) {
        for (let [key] of otherList) {
            if (!this.has(key))
                return false;
        }
        return true;
    }
    GreaterThan(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return this.minItem.Value > otherList.maxItem.Value;
    }
    GreaterThanOrEquals(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return (this.minItem.Value >= otherList.minItem.Value &&
            this.maxItem.Value >= otherList.maxItem.Value);
    }
    LessThan(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return this.maxItem.Value < otherList.minItem.Value;
    }
    LessThanOrEquals(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return (this.maxItem.Value <= otherList.maxItem.Value &&
            this.minItem.Value <= otherList.minItem.Value);
    }
    MaxAsList() {
        if (this.Count > 0)
            return new InkList(this.maxItem);
        else
            return new InkList();
    }
    MinAsList() {
        if (this.Count > 0)
            return new InkList(this.minItem);
        else
            return new InkList();
    }
    ListWithSubRange(minBound, maxBound) {
        if (this.Count == 0)
            return new InkList();
        let ordered = this.orderedItems;
        let minValue = 0;
        let maxValue = Number.MAX_SAFE_INTEGER;
        if (Number.isInteger(minBound)) {
            minValue = minBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                minValue = minBound.minItem.Value;
        }
        if (Number.isInteger(maxBound)) {
            maxValue = maxBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                maxValue = maxBound.maxItem.Value;
        }
        let subList = new InkList();
        subList.SetInitialOriginNames(this.originNames);
        for (let item of ordered) {
            if (item.Value >= minValue && item.Value <= maxValue) {
                subList.Add(item.Key, item.Value);
            }
        }
        return subList;
    }
    Equals(otherInkList) {
        if (otherInkList instanceof InkList === false)
            return false;
        if (otherInkList.Count != this.Count)
            return false;
        for (let [key] of this) {
            if (!otherInkList.has(key))
                return false;
        }
        return true;
    }
    // GetHashCode not implemented
    get orderedItems() {
        // List<KeyValuePair<InkListItem, int>>
        let ordered = new Array();
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            ordered.push({ Key: item, Value: value });
        }
        ordered.sort((x, y) => {
            if (x.Key.originName === null) {
                return NullException_1.throwNullException("x.Key.originName");
            }
            if (y.Key.originName === null) {
                return NullException_1.throwNullException("y.Key.originName");
            }
            if (x.Value == y.Value) {
                return x.Key.originName.localeCompare(y.Key.originName);
            }
            else {
                // TODO: refactor this bit into a numberCompareTo method?
                if (x.Value < y.Value)
                    return -1;
                return x.Value > y.Value ? 1 : 0;
            }
        });
        return ordered;
    }
    toString() {
        let ordered = this.orderedItems;
        let sb = new StringBuilder_1.StringBuilder();
        for (let i = 0; i < ordered.length; i++) {
            if (i > 0)
                sb.Append(", ");
            let item = ordered[i].Key;
            if (item.itemName === null)
                return NullException_1.throwNullException("item.itemName");
            sb.Append(item.itemName);
        }
        return sb.toString();
    }
    // casting a InkList to a Number, for somereason, actually gives a number.
    // This messes up the type detection when creating a Value from a InkList.
    // Returning NaN here prevents that.
    valueOf() {
        return NaN;
    }
}
exports.InkList = InkList;
//# sourceMappingURL=InkList.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/JsonSerialisation.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/JsonSerialisation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerialisation = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const ListDefinition_1 = __webpack_require__(/*! ./ListDefinition */ "./node_modules/inkjs/engine/ListDefinition.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class JsonSerialisation {
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException("runtimeObj");
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static WriteDictionaryRuntimeObjs(writer, dictionary) {
        writer.WriteObjectStart();
        for (let [key, value] of dictionary) {
            writer.WritePropertyStart(key);
            this.WriteRuntimeObject(writer, value);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static WriteListRuntimeObjs(writer, list) {
        writer.WriteArrayStart();
        for (let value of list) {
            this.WriteRuntimeObject(writer, value);
        }
        writer.WriteArrayEnd();
    }
    static WriteIntDictionary(writer, dict) {
        writer.WriteObjectStart();
        for (let [key, value] of dict) {
            writer.WriteIntProperty(key, value);
        }
        writer.WriteObjectEnd();
    }
    static WriteRuntimeObject(writer, obj) {
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            this.WriteRuntimeContainer(writer, container);
            return;
        }
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = "->";
            if (divert.isExternal) {
                divTypeKey = "x()";
            }
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function) {
                    divTypeKey = "f()";
                }
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {
                    divTypeKey = "->t->";
                }
            }
            let targetStr;
            if (divert.hasVariableTarget) {
                targetStr = divert.variableDivertName;
            }
            else {
                targetStr = divert.targetPathString;
            }
            writer.WriteObjectStart();
            writer.WriteProperty(divTypeKey, targetStr);
            if (divert.hasVariableTarget) {
                writer.WriteProperty("var", true);
            }
            if (divert.isConditional) {
                writer.WriteProperty("c", true);
            }
            if (divert.externalArgs > 0) {
                writer.WriteIntProperty("exArgs", divert.externalArgs);
            }
            writer.WriteObjectEnd();
            return;
        }
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            writer.WriteObjectStart();
            writer.WriteProperty("*", choicePoint.pathStringOnChoice);
            writer.WriteIntProperty("flg", choicePoint.flags);
            writer.WriteObjectEnd();
            return;
        }
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal) {
            writer.WriteInt(intVal.value);
            return;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal) {
            writer.WriteFloat(floatVal.value);
            return;
        }
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline) {
                writer.Write("\n", false);
            }
            else {
                writer.WriteStringStart();
                writer.WriteStringInner("^");
                writer.WriteStringInner(strVal.value);
                writer.WriteStringEnd();
            }
            return;
        }
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            this.WriteInkList(writer, listVal);
            return;
        }
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            writer.WriteObjectStart();
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException("divTargetVal.value");
            }
            writer.WriteProperty("^->", divTargetVal.value.componentsString);
            writer.WriteObjectEnd();
            return;
        }
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            writer.WriteObjectStart();
            writer.WriteProperty("^var", varPtrVal.value);
            writer.WriteIntProperty("ci", varPtrVal.contextIndex);
            writer.WriteObjectEnd();
            return;
        }
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue) {
            writer.Write("<>");
            return;
        }
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);
            return;
        }
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == "^")
                name = "L^";
            writer.Write(name);
            return;
        }
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            writer.WriteObjectStart();
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                writer.WriteProperty("CNT?", readCountPath);
            }
            else {
                writer.WriteProperty("VAR?", varRef.name);
            }
            writer.WriteObjectEnd();
            return;
        }
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            writer.WriteObjectStart();
            let key = varAss.isGlobal ? "VAR=" : "temp=";
            writer.WriteProperty(key, varAss.variableName);
            // Reassignment?
            if (!varAss.isNewDeclaration)
                writer.WriteProperty("re", true);
            writer.WriteObjectEnd();
            return;
        }
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj) {
            writer.Write("void");
            return;
        }
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            writer.WriteObjectStart();
            writer.WriteProperty("#", tag.text);
            writer.WriteObjectEnd();
            return;
        }
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice) {
            this.WriteChoice(writer, choice);
            return;
        }
        throw new Error("Failed to convert runtime object to Json token: " + obj);
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException("inkObject");
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === "number" && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === "string") {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == "^")
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == "\n" && str.length == 1)
                return new Value_1.StringValue("\n");
            // Glue
            if (str == "<>")
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == "L^")
                str = "^";
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == "->->")
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == "~ret")
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == "void")
                return new Void_1.Void();
        }
        if (typeof token === "object" && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj["^->"]) {
                propValue = obj["^->"];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj["^var"]) {
                propValue = obj["^var"];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ("ci" in obj) {
                    propValue = obj["ci"];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if ((propValue = obj["->"])) {
                isDivert = true;
            }
            else if ((propValue = obj["f()"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if ((propValue = obj["->t->"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if ((propValue = obj["x()"])) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if ((propValue = obj["var"]))
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj["c"];
                if (external) {
                    if ((propValue = obj["exArgs"]))
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if ((propValue = obj["*"])) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if ((propValue = obj["flg"]))
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if ((propValue = obj["VAR?"])) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if ((propValue = obj["CNT?"])) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if ((propValue = obj["VAR="])) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if ((propValue = obj["temp="])) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj["re"];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj["#"] !== undefined) {
                propValue = obj["#"];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if ((propValue = obj["list"])) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if ((propValue = obj["origins"])) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj["originalChoicePath"] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error("Failed to convert token to runtime object: " + JSON.stringify(token));
    }
    static WriteRuntimeContainer(writer, container, withoutName = false) {
        writer.WriteArrayStart();
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        for (let c of container.content)
            this.WriteRuntimeObject(writer, c);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        let hasNameProperty = container.name != null && !withoutName;
        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;
        if (hasTerminator) {
            writer.WriteObjectStart();
        }
        if (namedOnlyContent != null) {
            for (let [key, value] of namedOnlyContent) {
                let name = key;
                let namedContainer = TypeAssertion_1.asOrNull(value, Container_1.Container);
                writer.WritePropertyStart(name);
                this.WriteRuntimeContainer(writer, namedContainer, true);
                writer.WritePropertyEnd();
            }
        }
        if (hasNameProperty)
            writer.WriteProperty("#n", container.name);
        if (hasTerminator)
            writer.WriteObjectEnd();
        else
            writer.WriteNull();
        writer.WriteArrayEnd();
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == "#f") {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == "#n") {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj["text"].toString();
        choice.index = parseInt(jObj["index"]);
        choice.sourcePath = jObj["originalChoicePath"].toString();
        choice.originalThreadIndex = parseInt(jObj["originalThreadIndex"]);
        choice.pathStringOnChoice = jObj["targetPath"].toString();
        return choice;
    }
    static WriteChoice(writer, choice) {
        writer.WriteObjectStart();
        writer.WriteProperty("text", choice.text);
        writer.WriteIntProperty("index", choice.index);
        writer.WriteProperty("originalChoicePath", choice.sourcePath);
        writer.WriteIntProperty("originalThreadIndex", choice.originalThreadIndex);
        writer.WriteProperty("targetPath", choice.pathStringOnChoice);
        writer.WriteObjectEnd();
    }
    static WriteInkList(writer, listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException("rawList");
        }
        writer.WriteObjectStart();
        writer.WritePropertyStart("list");
        writer.WriteObjectStart();
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            let itemVal = val;
            if (item.itemName === null) {
                return NullException_1.throwNullException("item.itemName");
            }
            writer.WritePropertyNameStart();
            writer.WritePropertyNameInner(item.originName ? item.originName : "?");
            writer.WritePropertyNameInner(".");
            writer.WritePropertyNameInner(item.itemName);
            writer.WritePropertyNameEnd();
            writer.Write(itemVal);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        writer.WritePropertyEnd();
        if (rawList.Count == 0 &&
            rawList.originNames != null &&
            rawList.originNames.length > 0) {
            writer.WritePropertyStart("origins");
            writer.WriteArrayStart();
            for (let name of rawList.originNames)
                writer.Write(name);
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException("item.itemName");
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
exports.JsonSerialisation = JsonSerialisation;
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = "ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = "out";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = "/ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = "du";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = "pop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = "~ret";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = "->->";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = "str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = "/str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = "nop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = "choiceCnt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = "turn";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = "turns";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = "readc";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = "rnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = "srnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = "visit";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =
        "seq";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = "thread";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = "done";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = "end";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = "listInt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = "range";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = "lrnd";
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error("Control command not accounted for in serialisation");
    }
    return _controlCommandNames;
})();
//# sourceMappingURL=JsonSerialisation.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinition.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinition = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
class ListDefinition {
    constructor(name, items) {
        this._name = name || "";
        this._items = null;
        this._itemNameToValues = items || new Map();
    }
    get name() {
        return this._name;
    }
    get items() {
        if (this._items == null) {
            this._items = new Map();
            for (let [key, value] of this._itemNameToValues) {
                let item = new InkList_1.InkListItem(this.name, key);
                this._items.set(item.serialized(), value);
            }
        }
        return this._items;
    }
    ValueForItem(item) {
        if (!item.itemName)
            return 0;
        let intVal = this._itemNameToValues.get(item.itemName);
        if (typeof intVal !== "undefined")
            return intVal;
        else
            return 0;
    }
    ContainsItem(item) {
        if (!item.itemName)
            return false;
        if (item.originName != this.name)
            return false;
        return this._itemNameToValues.has(item.itemName);
    }
    ContainsItemWithName(itemName) {
        return this._itemNameToValues.has(itemName);
    }
    TryGetItemWithValue(val, 
    /* out */ item) {
        for (let [key, value] of this._itemNameToValues) {
            if (value == val) {
                item = new InkList_1.InkListItem(this.name, key);
                return { result: item, exists: true };
            }
        }
        item = InkList_1.InkListItem.Null;
        return { result: item, exists: false };
    }
    TryGetValueForItem(item, 
    /* out */ intVal) {
        if (!item.itemName)
            return { result: 0, exists: false };
        let value = this._itemNameToValues.get(item.itemName);
        if (!value)
            return { result: 0, exists: false };
        return { result: value, exists: true };
    }
}
exports.ListDefinition = ListDefinition;
//# sourceMappingURL=ListDefinition.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js":
/*!************************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinitionsOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinitionsOrigin = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ListDefinitionsOrigin {
    constructor(lists) {
        this._lists = new Map();
        this._allUnambiguousListValueCache = new Map();
        for (let list of lists) {
            this._lists.set(list.name, list);
            for (let [key, val] of list.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                let listValue = new Value_1.ListValue(item, val);
                if (!item.itemName) {
                    throw new Error("item.itemName is null or undefined.");
                }
                this._allUnambiguousListValueCache.set(item.itemName, listValue);
                this._allUnambiguousListValueCache.set(item.fullName, listValue);
            }
        }
    }
    get lists() {
        let listOfLists = [];
        for (let [, value] of this._lists) {
            listOfLists.push(value);
        }
        return listOfLists;
    }
    TryListGetDefinition(name, 
    /* out */ def) {
        if (name === null) {
            return { result: def, exists: false };
        }
        // initially, this function returns a boolean and the second parameter is an out.
        let definition = this._lists.get(name);
        if (!definition)
            return { result: def, exists: false };
        return { result: definition, exists: true };
    }
    FindSingleItemListWithName(name) {
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let val = this._allUnambiguousListValueCache.get(name);
        if (typeof val !== "undefined") {
            return val;
        }
        return null;
    }
}
exports.ListDefinitionsOrigin = ListDefinitionsOrigin;
//# sourceMappingURL=ListDefinitionsOrigin.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NativeFunctionCall.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/NativeFunctionCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeFunctionCall = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class NativeFunctionCall extends Object_1.InkObject {
    constructor() {
        super();
        this._name = null;
        this._numberOfParameters = 0;
        this._prototype = null;
        this._isPrototype = false;
        this._operationFuncs = null;
        if (arguments.length === 0) {
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
        }
        else if (arguments.length === 1) {
            let name = arguments[0];
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
            this.name = name;
        }
        else if (arguments.length === 2) {
            let name = arguments[0];
            let numberOfParameters = arguments[1];
            this._isPrototype = true;
            this.name = name;
            this.numberOfParameters = numberOfParameters;
        }
    }
    static CallWithName(functionName) {
        return new NativeFunctionCall(functionName);
    }
    static CallExistsWithName(functionName) {
        this.GenerateNativeFunctionsIfNecessary();
        return this._nativeFunctions.get(functionName);
    }
    get name() {
        if (this._name === null)
            return NullException_1.throwNullException("NativeFunctionCall._name");
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._isPrototype) {
            if (NativeFunctionCall._nativeFunctions === null)
                NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
            else
                this._prototype =
                    NativeFunctionCall._nativeFunctions.get(this._name) || null;
        }
    }
    get numberOfParameters() {
        if (this._prototype) {
            return this._prototype.numberOfParameters;
        }
        else {
            return this._numberOfParameters;
        }
    }
    set numberOfParameters(value) {
        this._numberOfParameters = value;
    }
    Call(parameters) {
        if (this._prototype) {
            return this._prototype.Call(parameters);
        }
        if (this.numberOfParameters != parameters.length) {
            throw new Error("Unexpected number of parameters");
        }
        let hasList = false;
        for (let p of parameters) {
            if (p instanceof Void_1.Void)
                throw new StoryException_1.StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');
            if (p instanceof Value_1.ListValue)
                hasList = true;
        }
        if (parameters.length == 2 && hasList) {
            return this.CallBinaryListOperation(parameters);
        }
        let coercedParams = this.CoerceValuesToSingleType(parameters);
        let coercedType = coercedParams[0].valueType;
        if (coercedType == Value_1.ValueType.Int) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.Float) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.String) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.DivertTarget) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.List) {
            return this.CallType(coercedParams);
        }
        return null;
    }
    CallType(parametersOfSingleType) {
        let param1 = TypeAssertion_1.asOrThrows(parametersOfSingleType[0], Value_1.Value);
        let valType = param1.valueType;
        let val1 = param1;
        let paramCount = parametersOfSingleType.length;
        if (paramCount == 2 || paramCount == 1) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let opForTypeObj = this._operationFuncs.get(valType);
            if (!opForTypeObj) {
                const key = Value_1.ValueType[valType];
                throw new StoryException_1.StoryException("Cannot perform operation " + this.name + " on " + key);
            }
            if (paramCount == 2) {
                let param2 = TypeAssertion_1.asOrThrows(parametersOfSingleType[1], Value_1.Value);
                let val2 = param2;
                let opForType = opForTypeObj;
                if (val1.value === null || val2.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call BinaryOp values");
                let resultVal = opForType(val1.value, val2.value);
                return Value_1.Value.Create(resultVal);
            }
            else {
                let opForType = opForTypeObj;
                if (val1.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call UnaryOp value");
                let resultVal = opForType(val1.value);
                // This code is different from upstream. Since JavaScript treats
                // integers and floats as the same numbers, it's impossible
                // to force an number to be either an integer or a float.
                //
                // It can be useful to force a specific number type
                // (especially for divisions), so the result of INT() & FLOAT()
                // is coerced to the the proper value type.
                //
                // Note that we also force all other unary operation to
                // return the same value type, although this is only
                // meaningful for numbers. See `Value.Create`.
                if (this.name === NativeFunctionCall.Int) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);
                }
                else if (this.name === NativeFunctionCall.Float) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);
                }
                else {
                    return Value_1.Value.Create(resultVal, param1.valueType);
                }
            }
        }
        else {
            throw new Error("Unexpected number of parameters to NativeFunctionCall: " +
                parametersOfSingleType.length);
        }
    }
    CallBinaryListOperation(parameters) {
        if ((this.name == "+" || this.name == "-") &&
            parameters[0] instanceof Value_1.ListValue &&
            parameters[1] instanceof Value_1.IntValue)
            return this.CallListIncrementOperation(parameters);
        let v1 = TypeAssertion_1.asOrThrows(parameters[0], Value_1.Value);
        let v2 = TypeAssertion_1.asOrThrows(parameters[1], Value_1.Value);
        if ((this.name == "&&" || this.name == "||") &&
            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let op = this._operationFuncs.get(Value_1.ValueType.Int);
            if (op === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallBinaryListOperation op");
            let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);
            return new Value_1.IntValue(result);
        }
        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)
            return this.CallType([v1, v2]);
        throw new StoryException_1.StoryException("Can not call use " +
            this.name +
            " operation on " +
            Value_1.ValueType[v1.valueType] +
            " and " +
            Value_1.ValueType[v2.valueType]);
    }
    CallListIncrementOperation(listIntParams) {
        let listVal = TypeAssertion_1.asOrThrows(listIntParams[0], Value_1.ListValue);
        let intVal = TypeAssertion_1.asOrThrows(listIntParams[1], Value_1.IntValue);
        let resultInkList = new InkList_1.InkList();
        if (listVal.value === null)
            return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");
        for (let [listItemKey, listItemValue] of listVal.value) {
            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);
            if (intVal.value === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");
            let targetInt = intOp(listItemValue, intVal.value);
            let itemOrigin = null;
            if (listVal.value.origins === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");
            for (let origin of listVal.value.origins) {
                if (origin.name == listItem.originName) {
                    itemOrigin = origin;
                    break;
                }
            }
            if (itemOrigin != null) {
                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);
                if (incrementedItem.exists)
                    resultInkList.Add(incrementedItem.result, targetInt);
            }
        }
        return new Value_1.ListValue(resultInkList);
    }
    CoerceValuesToSingleType(parametersIn) {
        let valType = Value_1.ValueType.Int;
        let specialCaseList = null;
        for (let obj of parametersIn) {
            let val = TypeAssertion_1.asOrThrows(obj, Value_1.Value);
            if (val.valueType > valType) {
                valType = val.valueType;
            }
            if (val.valueType == Value_1.ValueType.List) {
                specialCaseList = TypeAssertion_1.asOrNull(val, Value_1.ListValue);
            }
        }
        let parametersOut = [];
        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                if (val.valueType == Value_1.ValueType.List) {
                    parametersOut.push(val);
                }
                else if (val.valueType == Value_1.ValueType.Int) {
                    let intVal = parseInt(val.valueObject);
                    specialCaseList = TypeAssertion_1.asOrThrows(specialCaseList, Value_1.ListValue);
                    if (specialCaseList.value === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");
                    let list = specialCaseList.value.originOfMaxItem;
                    if (list === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");
                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);
                    if (item.exists) {
                        let castedValue = new Value_1.ListValue(item.result, intVal);
                        parametersOut.push(castedValue);
                    }
                    else
                        throw new StoryException_1.StoryException("Could not find List item with the value " +
                            intVal +
                            " in " +
                            list.name);
                }
                else {
                    const key = Value_1.ValueType[val.valueType];
                    throw new StoryException_1.StoryException("Cannot mix Lists and " + key + " values in this operation");
                }
            }
        }
        else {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                let castedValue = val.Cast(valType);
                parametersOut.push(castedValue);
            }
        }
        return parametersOut;
    }
    static Identity(t) {
        return t;
    }
    static GenerateNativeFunctionsIfNecessary() {
        if (this._nativeFunctions == null) {
            this._nativeFunctions = new Map();
            // Int operations
            this.AddIntBinaryOp(this.Add, (x, y) => x + y);
            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));
            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);
            this.AddIntUnaryOp(this.Negate, (x) => -x);
            this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));
            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));
            this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Float, (x) => x);
            // Float operations
            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);
            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);
            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);
            this.AddFloatUnaryOp(this.Negate, (x) => -x);
            this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);
            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));
            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);
            // String operations
            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat
            this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));
            this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));
            this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));
            this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));
            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));
            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));
            this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));
            this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));
            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));
            this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);
            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);
            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));
            this.AddListUnaryOp(this.Invert, (x) => x.inverse);
            this.AddListUnaryOp(this.All, (x) => x.all);
            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());
            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());
            this.AddListUnaryOp(this.Count, (x) => x.Count);
            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);
            let divertTargetsEqual = (d1, d2) => (d1.Equals(d2) ? 1 : 0);
            let divertTargetsNotEqual = (d1, d2) => d1.Equals(d2) ? 0 : 1;
            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);
            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);
        }
    }
    AddOpFuncForType(valType, op) {
        if (this._operationFuncs == null) {
            this._operationFuncs = new Map();
        }
        this._operationFuncs.set(valType, op);
    }
    static AddOpToNativeFunc(name, args, valType, op) {
        if (this._nativeFunctions === null)
            return NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
        let nativeFunc = this._nativeFunctions.get(name);
        if (!nativeFunc) {
            nativeFunc = new NativeFunctionCall(name, args);
            this._nativeFunctions.set(name, nativeFunc);
        }
        nativeFunc.AddOpFuncForType(valType, op);
    }
    static AddIntBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);
    }
    static AddIntUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);
    }
    static AddFloatBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);
    }
    static AddFloatUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);
    }
    static AddStringBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);
    }
    static AddListBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);
    }
    static AddListUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);
    }
    toString() {
        return 'Native "' + this.name + '"';
    }
}
exports.NativeFunctionCall = NativeFunctionCall;
NativeFunctionCall.Add = "+";
NativeFunctionCall.Subtract = "-";
NativeFunctionCall.Divide = "/";
NativeFunctionCall.Multiply = "*";
NativeFunctionCall.Mod = "%";
NativeFunctionCall.Negate = "_";
NativeFunctionCall.Equal = "==";
NativeFunctionCall.Greater = ">";
NativeFunctionCall.Less = "<";
NativeFunctionCall.GreaterThanOrEquals = ">=";
NativeFunctionCall.LessThanOrEquals = "<=";
NativeFunctionCall.NotEquals = "!=";
NativeFunctionCall.Not = "!";
NativeFunctionCall.And = "&&";
NativeFunctionCall.Or = "||";
NativeFunctionCall.Min = "MIN";
NativeFunctionCall.Max = "MAX";
NativeFunctionCall.Pow = "POW";
NativeFunctionCall.Floor = "FLOOR";
NativeFunctionCall.Ceiling = "CEILING";
NativeFunctionCall.Int = "INT";
NativeFunctionCall.Float = "FLOAT";
NativeFunctionCall.Has = "?";
NativeFunctionCall.Hasnt = "!?";
NativeFunctionCall.Intersect = "^";
NativeFunctionCall.ListMin = "LIST_MIN";
NativeFunctionCall.ListMax = "LIST_MAX";
NativeFunctionCall.All = "LIST_ALL";
NativeFunctionCall.Count = "LIST_COUNT";
NativeFunctionCall.ValueOfList = "LIST_VALUE";
NativeFunctionCall.Invert = "LIST_INVERT";
NativeFunctionCall._nativeFunctions = null;
//# sourceMappingURL=NativeFunctionCall.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NullException.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/NullException.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.throwNullException = exports.NullException = void 0;
/**
 * In the original C# code, a SystemException would be thrown when passing
 * null to methods expected a valid instance. Javascript has no such
 * concept, but TypeScript will not allow `null` to be passed to methods
 * explicitely requiring a valid type.
 *
 * Whenever TypeScript complain about the possibility of a `null` value,
 * check the offending value and it it's null, throw this exception using
 * `throwNullException(name: string)`.
 */
class NullException extends Error {
}
exports.NullException = NullException;
/**
 * Throw a NullException.
 *
 * @param name a short description of the offending value (often its name within the code).
 */
function throwNullException(name) {
    throw new NullException(`${name} is null or undefined`);
}
exports.throwNullException = throwNullException;
//# sourceMappingURL=NullException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Object.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Object.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkObject = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class InkObject {
    constructor() {
        this.parent = null;
        this._debugMetadata = null;
        this._path = null;
    }
    get debugMetadata() {
        if (this._debugMetadata === null) {
            if (this.parent) {
                return this.parent.debugMetadata;
            }
        }
        return this._debugMetadata;
    }
    set debugMetadata(value) {
        this._debugMetadata = value;
    }
    get ownDebugMetadata() {
        return this._debugMetadata;
    }
    DebugLineNumberOfPath(path) {
        if (path === null)
            return null;
        // Try to get a line number from debug metadata
        let root = this.rootContentContainer;
        if (root) {
            let targetContent = root.ContentAtPath(path).obj;
            if (targetContent) {
                let dm = targetContent.debugMetadata;
                if (dm !== null) {
                    return dm.startLineNumber;
                }
            }
        }
        return null;
    }
    get path() {
        if (this._path == null) {
            if (this.parent == null) {
                this._path = new Path_1.Path();
            }
            else {
                let comps = [];
                let child = this;
                let container = TypeAssertion_1.asOrNull(child.parent, Container_1.Container);
                while (container !== null) {
                    let namedChild = TypeAssertion_1.asINamedContentOrNull(child);
                    if (namedChild != null && namedChild.hasValidName) {
                        comps.unshift(new Path_1.Path.Component(namedChild.name));
                    }
                    else {
                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));
                    }
                    child = container;
                    container = TypeAssertion_1.asOrNull(container.parent, Container_1.Container);
                }
                this._path = new Path_1.Path(comps);
            }
        }
        return this._path;
    }
    ResolvePath(path) {
        if (path === null)
            return NullException_1.throwNullException("path");
        if (path.isRelative) {
            let nearestContainer = TypeAssertion_1.asOrNull(this, Container_1.Container);
            if (nearestContainer === null) {
                Debug_1.Debug.Assert(this.parent !== null, "Can't resolve relative path because we don't have a parent");
                nearestContainer = TypeAssertion_1.asOrNull(this.parent, Container_1.Container);
                Debug_1.Debug.Assert(nearestContainer !== null, "Expected parent to be a container");
                Debug_1.Debug.Assert(path.GetComponent(0).isParent);
                path = path.tail;
            }
            if (nearestContainer === null) {
                return NullException_1.throwNullException("nearestContainer");
            }
            return nearestContainer.ContentAtPath(path);
        }
        else {
            let contentContainer = this.rootContentContainer;
            if (contentContainer === null) {
                return NullException_1.throwNullException("contentContainer");
            }
            return contentContainer.ContentAtPath(path);
        }
    }
    ConvertPathToRelative(globalPath) {
        let ownPath = this.path;
        let minPathLength = Math.min(globalPath.length, ownPath.length);
        let lastSharedPathCompIndex = -1;
        for (let i = 0; i < minPathLength; ++i) {
            let ownComp = ownPath.GetComponent(i);
            let otherComp = globalPath.GetComponent(i);
            if (ownComp.Equals(otherComp)) {
                lastSharedPathCompIndex = i;
            }
            else {
                break;
            }
        }
        // No shared path components, so just use global path
        if (lastSharedPathCompIndex == -1)
            return globalPath;
        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;
        let newPathComps = [];
        for (let up = 0; up < numUpwardsMoves; ++up)
            newPathComps.push(Path_1.Path.Component.ToParent());
        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)
            newPathComps.push(globalPath.GetComponent(down));
        let relativePath = new Path_1.Path(newPathComps, true);
        return relativePath;
    }
    CompactPathString(otherPath) {
        let globalPathStr = null;
        let relativePathStr = null;
        if (otherPath.isRelative) {
            relativePathStr = otherPath.componentsString;
            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;
        }
        else {
            let relativePath = this.ConvertPathToRelative(otherPath);
            relativePathStr = relativePath.componentsString;
            globalPathStr = otherPath.componentsString;
        }
        if (relativePathStr.length < globalPathStr.length)
            return relativePathStr;
        else
            return globalPathStr;
    }
    get rootContentContainer() {
        let ancestor = this;
        while (ancestor.parent) {
            ancestor = ancestor.parent;
        }
        return TypeAssertion_1.asOrNull(ancestor, Container_1.Container);
    }
    Copy() {
        throw Error("Not Implemented: Doesn't support copying");
    }
    // SetChild works slightly diferently in the js implementation.
    // Since we can't pass an objets property by reference, we instead pass
    // the object and the property string.
    // TODO: This method can probably be rewritten with type-safety in mind.
    SetChild(obj, prop, value) {
        if (obj[prop])
            obj[prop] = null;
        obj[prop] = value;
        if (obj[prop])
            obj[prop].parent = this;
    }
}
exports.InkObject = InkObject;
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PRNG.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/PRNG.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PRNG = void 0;
// Taken from https://gist.github.com/blixt/f17b47c62508be59987b
// Ink uses a seedable PRNG of which there is none in native javascript.
class PRNG {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0)
            this.seed += 2147483646;
    }
    next() {
        return (this.seed = (this.seed * 16807) % 2147483647);
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}
exports.PRNG = PRNG;
//# sourceMappingURL=PRNG.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Path.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
class Path {
    constructor() {
        this._components = [];
        this._componentsString = null;
        this._isRelative = false;
        if (typeof arguments[0] == "string") {
            let componentsString = arguments[0];
            this.componentsString = componentsString;
        }
        else if (arguments[0] instanceof Path.Component &&
            arguments[1] instanceof Path) {
            let head = arguments[0];
            let tail = arguments[1];
            this._components.push(head);
            this._components = this._components.concat(tail._components);
        }
        else if (arguments[0] instanceof Array) {
            let head = arguments[0];
            let relative = !!arguments[1];
            this._components = this._components.concat(head);
            this._isRelative = relative;
        }
    }
    get isRelative() {
        return this._isRelative;
    }
    get componentCount() {
        return this._components.length;
    }
    get head() {
        if (this._components.length > 0) {
            return this._components[0];
        }
        else {
            return null;
        }
    }
    get tail() {
        if (this._components.length >= 2) {
            // careful, the original code uses length-1 here. This is because the second argument of
            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index
            let tailComps = this._components.slice(1, this._components.length);
            return new Path(tailComps);
        }
        else {
            return Path.self;
        }
    }
    get length() {
        return this._components.length;
    }
    get lastComponent() {
        let lastComponentIdx = this._components.length - 1;
        if (lastComponentIdx >= 0) {
            return this._components[lastComponentIdx];
        }
        else {
            return null;
        }
    }
    get containsNamedComponent() {
        for (let i = 0, l = this._components.length; i < l; i++) {
            if (!this._components[i].isIndex) {
                return true;
            }
        }
        return false;
    }
    static get self() {
        let path = new Path();
        path._isRelative = true;
        return path;
    }
    GetComponent(index) {
        return this._components[index];
    }
    PathByAppendingPath(pathToAppend) {
        let p = new Path();
        let upwardMoves = 0;
        for (let i = 0; i < pathToAppend._components.length; ++i) {
            if (pathToAppend._components[i].isParent) {
                upwardMoves++;
            }
            else {
                break;
            }
        }
        for (let i = 0; i < this._components.length - upwardMoves; ++i) {
            p._components.push(this._components[i]);
        }
        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {
            p._components.push(pathToAppend._components[i]);
        }
        return p;
    }
    get componentsString() {
        if (this._componentsString == null) {
            this._componentsString = this._components.join(".");
            if (this.isRelative)
                this._componentsString = "." + this._componentsString;
        }
        return this._componentsString;
    }
    set componentsString(value) {
        this._components.length = 0;
        this._componentsString = value;
        if (this._componentsString == null || this._componentsString == "")
            return;
        if (this._componentsString[0] == ".") {
            this._isRelative = true;
            this._componentsString = this._componentsString.substring(1);
        }
        let componentStrings = this._componentsString.split(".");
        for (let str of componentStrings) {
            // we need to distinguish between named components that start with a number, eg "42somewhere", and indexed components
            // the normal parseInt won't do for the detection because it's too relaxed.
            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
            if (/^(\-|\+)?([0-9]+|Infinity)$/.test(str)) {
                this._components.push(new Path.Component(parseInt(str)));
            }
            else {
                this._components.push(new Path.Component(str));
            }
        }
    }
    toString() {
        return this.componentsString;
    }
    Equals(otherPath) {
        if (otherPath == null)
            return false;
        if (otherPath._components.length != this._components.length)
            return false;
        if (otherPath.isRelative != this.isRelative)
            return false;
        // the original code uses SequenceEqual here, so we need to iterate over the components manually.
        for (let i = 0, l = otherPath._components.length; i < l; i++) {
            // it's not quite clear whether this test should use Equals or a simple == operator,
            // see https://github.com/y-lohse/inkjs/issues/22
            if (!otherPath._components[i].Equals(this._components[i]))
                return false;
        }
        return true;
    }
    PathByAppendingComponent(c) {
        let p = new Path();
        p._components.push.apply(p._components, this._components);
        p._components.push(c);
        return p;
    }
}
exports.Path = Path;
Path.parentId = "^";
(function (Path) {
    class Component {
        constructor(indexOrName) {
            this.index = -1;
            this.name = null;
            if (typeof indexOrName == "string") {
                this.name = indexOrName;
            }
            else {
                this.index = indexOrName;
            }
        }
        get isIndex() {
            return this.index >= 0;
        }
        get isParent() {
            return this.name == Path.parentId;
        }
        static ToParent() {
            return new Component(Path.parentId);
        }
        toString() {
            if (this.isIndex) {
                return this.index.toString();
            }
            else {
                return this.name;
            }
        }
        Equals(otherComp) {
            if (otherComp != null && otherComp.isIndex == this.isIndex) {
                if (this.isIndex) {
                    return this.index == otherComp.index;
                }
                else {
                    return this.name == otherComp.name;
                }
            }
            return false;
        }
    }
    Path.Component = Component;
})(Path = exports.Path || (exports.Path = {}));
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Pointer.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/Pointer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class Pointer {
    constructor() {
        this.container = null;
        this.index = -1;
        if (arguments.length === 2) {
            this.container = arguments[0];
            this.index = arguments[1];
        }
    }
    Resolve() {
        if (this.index < 0)
            return this.container;
        if (this.container == null)
            return null;
        if (this.container.content.length == 0)
            return this.container;
        if (this.index >= this.container.content.length)
            return null;
        return this.container.content[this.index];
    }
    get isNull() {
        return this.container == null;
    }
    get path() {
        if (this.isNull)
            return null;
        if (this.index >= 0)
            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));
        else
            return this.container.path;
    }
    toString() {
        if (!this.container)
            return "Ink Pointer (null)";
        return ("Ink Pointer -> " +
            this.container.path.toString() +
            " -- index " +
            this.index);
    }
    // This method does not exist in the original C# code, but is here to maintain the
    // value semantics of Pointer.
    copy() {
        return new Pointer(this.container, this.index);
    }
    static StartOf(container) {
        return new Pointer(container, 0);
    }
    static get Null() {
        return new Pointer(null, -1);
    }
}
exports.Pointer = Pointer;
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PushPop.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/PushPop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPopType = void 0;
var PushPopType;
(function (PushPopType) {
    PushPopType[PushPopType["Tunnel"] = 0] = "Tunnel";
    PushPopType[PushPopType["Function"] = 1] = "Function";
    PushPopType[PushPopType["FunctionEvaluationFromGame"] = 2] = "FunctionEvaluationFromGame";
})(PushPopType = exports.PushPopType || (exports.PushPopType = {}));
//# sourceMappingURL=PushPop.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SearchResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/SearchResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
class SearchResult {
    constructor() {
        this.obj = null;
        this.approximate = false;
    }
    get correctObj() {
        return this.approximate ? null : this.obj;
    }
    get container() {
        return this.obj instanceof Container_1.Container ? this.obj : null;
    }
    copy() {
        let searchResult = new SearchResult();
        searchResult.obj = this.obj;
        searchResult.approximate = this.approximate;
        return searchResult;
    }
}
exports.SearchResult = SearchResult;
//# sourceMappingURL=SearchResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SimpleJson.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/SimpleJson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleJson = void 0;
class SimpleJson {
    static TextToDictionary(text) {
        return new SimpleJson.Reader(text).ToDictionary();
    }
    static TextToArray(text) {
        return new SimpleJson.Reader(text).ToArray();
    }
}
exports.SimpleJson = SimpleJson;
(function (SimpleJson) {
    class Reader {
        constructor(text) {
            this._rootObject = JSON.parse(text);
        }
        ToDictionary() {
            return this._rootObject;
        }
        ToArray() {
            return this._rootObject;
        }
    }
    SimpleJson.Reader = Reader;
    // In C#, this class writes json tokens directly to a StringWriter or
    // another stream. Here, a temporary hierarchy is created in the form
    // of a javascript object, which is serialised in the `toString` method.
    // See individual methods and properties for more information.
    class Writer {
        constructor() {
            // In addition to `_stateStack` present in the original code,
            // this implementation of SimpleJson use two other stacks and two
            // temporary variables holding the current context.
            // Used to keep track of the current property name being built
            // with `WritePropertyNameStart`, `WritePropertyNameInner` and
            // `WritePropertyNameEnd`.
            this._currentPropertyName = null;
            // Used to keep track of the current string value being built
            // with `WriteStringStart`, `WriteStringInner` and
            // `WriteStringEnd`.
            this._currentString = null;
            this._stateStack = [];
            // Keep track of the current collection being built (either an array
            // or an object). For instance, at the '?' step during the hiarchy
            // creation, this hierarchy:
            // [3, {a: [b, ?]}] will have this corresponding stack:
            // (bottom) [Array, Object, Array] (top)
            this._collectionStack = [];
            // Keep track of the current property being assigned. For instance, at
            // the '?' step during the hiarchy creation, this hierarchy:
            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:
            // (bottom) [a, c] (top)
            this._propertyNameStack = [];
            // Object containing the entire hiearchy.
            this._jsonObject = null;
        }
        WriteObject(inner) {
            this.WriteObjectStart();
            inner(this);
            this.WriteObjectEnd();
        }
        // Add a new object.
        WriteObjectStart() {
            this.StartNewObject(true);
            let newObject = {};
            if (this.state === SimpleJson.Writer.State.Property) {
                // This object is created as the value of a property,
                // inside an other object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This object is created as the child of an array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This object is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));
        }
        WriteObjectEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Write a property name / value pair to the current object.
        WriteProperty(name, innerOrContent) {
            this.WritePropertyStart(name);
            if (arguments[1] instanceof Function) {
                let inner = arguments[1];
                inner(this);
            }
            else {
                let content = arguments[1];
                this.Write(content);
            }
            this.WritePropertyEnd();
        }
        // Int and Float are separate calls, since there both are
        // numbers in JavaScript, but need to be handled differently.
        WriteIntProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteInt(content);
            this.WritePropertyEnd();
        }
        WriteFloatProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteFloat(content);
            this.WritePropertyEnd();
        }
        // Prepare a new property name, which will be use to add the
        // new object when calling _addToCurrentObject() from a Write
        // method.
        WritePropertyStart(name) {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._propertyNameStack.push(name);
            this.IncrementChildCount();
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
        }
        WritePropertyEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Property);
            this.Assert(this.childCount === 1);
            this._stateStack.pop();
        }
        // Prepare a new property name, except this time, the property name
        // will be created by concatenating all the strings passed to
        // WritePropertyNameInner.
        WritePropertyNameStart() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this.IncrementChildCount();
            this._currentPropertyName = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));
        }
        WritePropertyNameEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._propertyNameStack.push(this._currentPropertyName);
            this._currentPropertyName = null;
            this._stateStack.pop();
        }
        WritePropertyNameInner(str) {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._currentPropertyName += str;
        }
        // Add a new array.
        WriteArrayStart() {
            this.StartNewObject(true);
            let newObject = [];
            if (this.state === SimpleJson.Writer.State.Property) {
                // This array is created as the value of a property,
                // inside an object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This array is created as the child of another array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This array is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));
        }
        WriteArrayEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Array);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Add the value to the appropriate collection (array / object), given the current
        // context.
        Write(value, escape = true) {
            if (value === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this.StartNewObject(false);
            this._addToCurrentObject(value);
        }
        WriteInt(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            // Math.floor is used as a precaution:
            //     1. to ensure that the value is written as an integer
            //        (without a fractional part -> 1 instead of 1.0), even
            //        though it should be the default behaviour of
            //        JSON.serialize;
            //     2. to ensure that if a floating number is passed
            //        accidentally, it's converted to an integer.
            //
            // This guarantees savegame compatibility with the reference
            // implementation.
            this._addToCurrentObject(Math.floor(value));
        }
        // Since JSON doesn't support NaN and Infinity, these values
        // are converted here.
        WriteFloat(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            if (value == Number.POSITIVE_INFINITY) {
                this._addToCurrentObject(3.4e38);
            }
            else if (value == Number.NEGATIVE_INFINITY) {
                this._addToCurrentObject(-3.4e38);
            }
            else if (isNaN(value)) {
                this._addToCurrentObject(0.0);
            }
            else {
                this._addToCurrentObject(value);
            }
        }
        WriteNull() {
            this.StartNewObject(false);
            this._addToCurrentObject(null);
        }
        // Prepare a string before adding it to the current collection in
        // WriteStringEnd(). The string will be a concatenation of all the
        // strings passed to WriteStringInner.
        WriteStringStart() {
            this.StartNewObject(false);
            this._currentString = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));
        }
        WriteStringEnd() {
            this.Assert(this.state == SimpleJson.Writer.State.String);
            this._stateStack.pop();
            this._addToCurrentObject(this._currentString);
            this._currentString = null;
        }
        WriteStringInner(str, escape = true) {
            this.Assert(this.state === SimpleJson.Writer.State.String);
            if (str === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this._currentString += str;
        }
        // Serialise the root object into a JSON string.
        ToString() {
            if (this._jsonObject === null) {
                return "";
            }
            return JSON.stringify(this._jsonObject);
        }
        // Prepare the state stack when adding new objects / values.
        StartNewObject(container) {
            if (container) {
                this.Assert(this.state === SimpleJson.Writer.State.None ||
                    this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            else {
                this.Assert(this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(this.childCount === 0);
            }
            if (this.state === SimpleJson.Writer.State.Array ||
                this.state === SimpleJson.Writer.State.Property) {
                this.IncrementChildCount();
            }
        }
        // These getters peek all the different stacks.
        get state() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].type;
            }
            else {
                return SimpleJson.Writer.State.None;
            }
        }
        get childCount() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].childCount;
            }
            else {
                return 0;
            }
        }
        get currentCollection() {
            if (this._collectionStack.length > 0) {
                return this._collectionStack[this._collectionStack.length - 1];
            }
            else {
                return null;
            }
        }
        get currentPropertyName() {
            if (this._propertyNameStack.length > 0) {
                return this._propertyNameStack[this._propertyNameStack.length - 1];
            }
            else {
                return null;
            }
        }
        IncrementChildCount() {
            this.Assert(this._stateStack.length > 0);
            let currEl = this._stateStack.pop();
            currEl.childCount++;
            this._stateStack.push(currEl);
        }
        Assert(condition) {
            if (!condition)
                throw Error("Assert failed while writing JSON");
        }
        // This method did not exist in the original C# code. It adds
        // the given value to the current collection (used by Write methods).
        _addToCurrentObject(value) {
            this.Assert(this.currentCollection !== null);
            if (this.state === SimpleJson.Writer.State.Array) {
                this.Assert(Array.isArray(this.currentCollection));
                this.currentCollection.push(value);
            }
            else if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(!Array.isArray(this.currentCollection));
                this.Assert(this.currentPropertyName !== null);
                this.currentCollection[this.currentPropertyName] = value;
                this._propertyNameStack.pop();
            }
        }
    }
    SimpleJson.Writer = Writer;
    (function (Writer) {
        let State;
        (function (State) {
            State[State["None"] = 0] = "None";
            State[State["Object"] = 1] = "Object";
            State[State["Array"] = 2] = "Array";
            State[State["Property"] = 3] = "Property";
            State[State["PropertyName"] = 4] = "PropertyName";
            State[State["String"] = 5] = "String";
        })(State = Writer.State || (Writer.State = {}));
        class StateElement {
            constructor(type) {
                this.type = SimpleJson.Writer.State.None;
                this.childCount = 0;
                this.type = type;
            }
        }
        Writer.StateElement = StateElement;
    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));
})(SimpleJson = exports.SimpleJson || (exports.SimpleJson = {}));
//# sourceMappingURL=SimpleJson.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StatePatch.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StatePatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePatch = void 0;
class StatePatch {
    constructor() {
        this._changedVariables = new Set();
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        if (arguments.length === 1 && arguments[0] !== null) {
            let toCopy = arguments[0];
            this._globals = new Map(toCopy._globals);
            this._changedVariables = new Set(toCopy._changedVariables);
            this._visitCounts = new Map(toCopy._visitCounts);
            this._turnIndices = new Map(toCopy._turnIndices);
        }
        else {
            this._globals = new Map();
            this._changedVariables = new Set();
            this._visitCounts = new Map();
            this._turnIndices = new Map();
        }
    }
    get globals() {
        return this._globals;
    }
    get changedVariables() {
        return this._changedVariables;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    TryGetGlobal(name, /* out */ value) {
        if (name !== null && this._globals.has(name)) {
            return { result: this._globals.get(name), exists: true };
        }
        return { result: value, exists: false };
    }
    SetGlobal(name, value) {
        this._globals.set(name, value);
    }
    AddChangedVariable(name) {
        return this._changedVariables.add(name);
    }
    TryGetVisitCount(container, /* out */ count) {
        if (this._visitCounts.has(container)) {
            return { result: this._visitCounts.get(container), exists: true };
        }
        return { result: count, exists: false };
    }
    SetVisitCount(container, count) {
        this._visitCounts.set(container, count);
    }
    SetTurnIndex(container, index) {
        this._turnIndices.set(container, index);
    }
    TryGetTurnIndex(container, /* out */ index) {
        if (this._turnIndices.has(container)) {
            return { result: this._turnIndices.get(container), exists: true };
        }
        return { result: index, exists: false };
    }
}
exports.StatePatch = StatePatch;
//# sourceMappingURL=StatePatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StopWatch.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/StopWatch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopwatch = void 0;
// This is simple replacement of the Stopwatch class from the .NET Framework.
// The original class can count time with much more accuracy than the Javascript version.
// It might be worth considering using `window.performance` in the browser
// or `process.hrtime()` in node.
class Stopwatch {
    constructor() {
        this.startTime = undefined;
    }
    get ElapsedMilliseconds() {
        if (typeof this.startTime === "undefined") {
            return 0;
        }
        return new Date().getTime() - this.startTime;
    }
    Start() {
        this.startTime = new Date().getTime();
    }
    Stop() {
        this.startTime = undefined;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=StopWatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Story.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Story.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Story = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const StoryState_1 = __webpack_require__(/*! ./StoryState */ "./node_modules/inkjs/engine/StoryState.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const StopWatch_1 = __webpack_require__(/*! ./StopWatch */ "./node_modules/inkjs/engine/StopWatch.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
var InkList_2 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
Object.defineProperty(exports, "InkList", { enumerable: true, get: function () { return InkList_2.InkList; } });
if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return (typeof nVal === "number" &&
            isFinite(nVal) &&
            nVal > -9007199254740992 &&
            nVal < 9007199254740992 &&
            Math.floor(nVal) === nVal);
    };
}
class Story extends Object_1.InkObject {
    constructor() {
        super();
        this.inkVersionMinimumCompatible = 18;
        this._prevContainers = [];
        this.allowExternalFunctionFallbacks = false;
        this._listDefinitions = null;
        this._variableObservers = null;
        this._hasValidatedExternals = false;
        this._temporaryEvaluationContainer = null;
        this._asyncContinueActive = false;
        this._stateSnapshotAtLastNewline = null;
        this._recursiveContinueCount = 0;
        this._asyncSaving = false;
        this._profiler = null; // TODO: Profiler
        // Discrimination between constructors
        let contentContainer;
        let lists = null;
        let json = null;
        if (arguments[0] instanceof Container_1.Container) {
            contentContainer = arguments[0];
            if (typeof arguments[1] !== "undefined") {
                lists = arguments[1];
            }
            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
            this._mainContentContainer = contentContainer;
            // ------
        }
        else {
            if (typeof arguments[0] === "string") {
                let jsonString = arguments[0];
                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);
            }
            else {
                json = arguments[0];
            }
        }
        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
        if (lists != null)
            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);
        this._externals = new Map();
        // ------
        // ------ Story(string jsonString) : this((Container)null)
        if (json !== null) {
            let rootObject = json;
            let versionObj = rootObject["inkVersion"];
            if (versionObj == null)
                throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");
            let formatFromFile = parseInt(versionObj);
            if (formatFromFile > Story.inkVersionCurrent) {
                throw new Error("Version of ink used to build story was newer than the current version of the engine");
            }
            else if (formatFromFile < this.inkVersionMinimumCompatible) {
                throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");
            }
            else if (formatFromFile != Story.inkVersionCurrent) {
                console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");
            }
            let rootToken = rootObject["root"];
            if (rootToken == null)
                throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");
            let listDefsObj;
            if ((listDefsObj = rootObject["listDefs"])) {
                this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);
            }
            this._mainContentContainer = TypeAssertion_1.asOrThrows(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);
            this.ResetState();
        }
        // ------
    }
    get currentChoices() {
        let choices = [];
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        for (let c of this._state.currentChoices) {
            if (!c.isInvisibleDefault) {
                c.index = choices.length;
                choices.push(c);
            }
        }
        return choices;
    }
    get currentText() {
        this.IfAsyncWeCant("call currentText since it's a work in progress");
        return this.state.currentText;
    }
    get currentTags() {
        this.IfAsyncWeCant("call currentTags since it's a work in progress");
        return this.state.currentTags;
    }
    get currentErrors() {
        return this.state.currentErrors;
    }
    get currentWarnings() {
        return this.state.currentWarnings;
    }
    get hasError() {
        return this.state.hasError;
    }
    get hasWarning() {
        return this.state.hasWarning;
    }
    get variablesState() {
        return this.state.variablesState;
    }
    get listDefinitions() {
        return this._listDefinitions;
    }
    get state() {
        return this._state;
    }
    // TODO: Implement Profiler
    StartProfiling() {
        /* */
    }
    EndProfiling() {
        /* */
    }
    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.
    // Will only return a value if writer was not provided.
    ToJson(writer) {
        let shouldReturn = false;
        if (!writer) {
            shouldReturn = true;
            writer = new SimpleJson_1.SimpleJson.Writer();
        }
        writer.WriteObjectStart();
        writer.WriteIntProperty("inkVersion", Story.inkVersionCurrent);
        writer.WriteProperty("root", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));
        if (this._listDefinitions != null) {
            writer.WritePropertyStart("listDefs");
            writer.WriteObjectStart();
            for (let def of this._listDefinitions.lists) {
                writer.WritePropertyStart(def.name);
                writer.WriteObjectStart();
                for (let [key, value] of def.items) {
                    let item = InkList_1.InkListItem.fromSerializedKey(key);
                    let val = value;
                    writer.WriteIntProperty(item.itemName, val);
                }
                writer.WriteObjectEnd();
                writer.WritePropertyEnd();
            }
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        if (shouldReturn)
            return writer.ToString();
    }
    ResetState() {
        this.IfAsyncWeCant("ResetState");
        this._state = new StoryState_1.StoryState(this);
        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));
        this.ResetGlobals();
    }
    ResetErrors() {
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ResetErrors();
    }
    ResetCallstack() {
        this.IfAsyncWeCant("ResetCallstack");
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ForceEnd();
    }
    ResetGlobals() {
        if (this._mainContentContainer.namedContent.get("global decl")) {
            let originalPointer = this.state.currentPointer.copy();
            this.ChoosePath(new Path_1.Path("global decl"), false);
            this.ContinueInternal();
            this.state.currentPointer = originalPointer;
        }
        this.state.variablesState.SnapshotDefaultGlobals();
    }
    Continue() {
        this.ContinueAsync(0);
        return this.currentText;
    }
    get canContinue() {
        return this.state.canContinue;
    }
    get asyncContinueComplete() {
        return !this._asyncContinueActive;
    }
    ContinueAsync(millisecsLimitAsync) {
        if (!this._hasValidatedExternals)
            this.ValidateExternalBindings();
        this.ContinueInternal(millisecsLimitAsync);
    }
    ContinueInternal(millisecsLimitAsync = 0) {
        if (this._profiler != null)
            this._profiler.PreContinue();
        let isAsyncTimeLimited = millisecsLimitAsync > 0;
        this._recursiveContinueCount++;
        if (!this._asyncContinueActive) {
            this._asyncContinueActive = isAsyncTimeLimited;
            if (!this.canContinue) {
                throw new StoryException_1.StoryException("Can't continue - should check canContinue before calling Continue");
            }
            this._state.didSafeExit = false;
            this._state.ResetOutput();
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = true;
        }
        let durationStopwatch = new StopWatch_1.Stopwatch();
        durationStopwatch.Start();
        let outputStreamEndsInNewline = false;
        do {
            try {
                outputStreamEndsInNewline = this.ContinueSingleStep();
            }
            catch (e) {
                if (!(e instanceof StoryException_1.StoryException))
                    throw e;
                this.AddError(e.message, undefined, e.useEndLineNumber);
                break;
            }
            if (outputStreamEndsInNewline)
                break;
            if (this._asyncContinueActive &&
                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {
                break;
            }
        } while (this.canContinue);
        durationStopwatch.Stop();
        if (outputStreamEndsInNewline || !this.canContinue) {
            if (this._stateSnapshotAtLastNewline !== null) {
                this.RestoreStateSnapshot();
            }
            if (!this.canContinue) {
                if (this.state.callStack.canPopThread)
                    this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");
                if (this.state.generatedChoices.length == 0 &&
                    !this.state.didSafeExit &&
                    this._temporaryEvaluationContainer == null) {
                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))
                        this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))
                        this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");
                    else if (!this.state.callStack.canPop)
                        this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");
                    else
                        this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!");
                }
            }
            this.state.didSafeExit = false;
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = false;
            this._asyncContinueActive = false;
        }
        this._recursiveContinueCount--;
        if (this._profiler != null)
            this._profiler.PostContinue();
    }
    ContinueSingleStep() {
        if (this._profiler != null)
            this._profiler.PreStep();
        this.Step();
        if (this._profiler != null)
            this._profiler.PostStep();
        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {
            this.TryFollowDefaultInvisibleChoice();
        }
        if (this._profiler != null)
            this._profiler.PreSnapshot();
        if (!this.state.inStringEvaluation) {
            if (this._stateSnapshotAtLastNewline !== null) {
                if (this._stateSnapshotAtLastNewline.currentTags === null) {
                    return NullException_1.throwNullException("this._stateAtLastNewline.currentTags");
                }
                if (this.state.currentTags === null) {
                    return NullException_1.throwNullException("this.state.currentTags");
                }
                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);
                if (change == Story.OutputStateChange.ExtendedBeyondNewline) {
                    this.RestoreStateSnapshot();
                    return true;
                }
                else if (change == Story.OutputStateChange.NewlineRemoved) {
                    this.DiscardSnapshot();
                }
            }
            if (this.state.outputStreamEndsInNewline) {
                if (this.canContinue) {
                    if (this._stateSnapshotAtLastNewline == null)
                        this.StateSnapshot();
                }
                else {
                    this.DiscardSnapshot();
                }
            }
        }
        if (this._profiler != null)
            this._profiler.PostSnapshot();
        return false;
    }
    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {
        if (prevText === null) {
            return NullException_1.throwNullException("prevText");
        }
        if (currText === null) {
            return NullException_1.throwNullException("currText");
        }
        let newlineStillExists = currText.length >= prevText.length &&
            currText.charAt(prevText.length - 1) == "\n";
        if (prevTagCount == currTagCount &&
            prevText.length == currText.length &&
            newlineStillExists)
            return Story.OutputStateChange.NoChange;
        if (!newlineStillExists) {
            return Story.OutputStateChange.NewlineRemoved;
        }
        if (currTagCount > prevTagCount)
            return Story.OutputStateChange.ExtendedBeyondNewline;
        for (let i = prevText.length; i < currText.length; i++) {
            let c = currText.charAt(i);
            if (c != " " && c != "\t") {
                return Story.OutputStateChange.ExtendedBeyondNewline;
            }
        }
        return Story.OutputStateChange.NoChange;
    }
    ContinueMaximally() {
        this.IfAsyncWeCant("ContinueMaximally");
        let sb = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            sb.Append(this.Continue());
        }
        return sb.toString();
    }
    ContentAtPath(path) {
        return this.mainContentContainer.ContentAtPath(path);
    }
    KnotContainerWithName(name) {
        let namedContainer = this.mainContentContainer.namedContent.get(name);
        if (namedContainer instanceof Container_1.Container)
            return namedContainer;
        else
            return null;
    }
    PointerAtPath(path) {
        if (path.length == 0)
            return Pointer_1.Pointer.Null;
        let p = new Pointer_1.Pointer();
        let pathLengthToUse = path.length;
        let result = null;
        if (path.lastComponent === null) {
            return NullException_1.throwNullException("path.lastComponent");
        }
        if (path.lastComponent.isIndex) {
            pathLengthToUse = path.length - 1;
            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);
            p.container = result.container;
            p.index = path.lastComponent.index;
        }
        else {
            result = this.mainContentContainer.ContentAtPath(path);
            p.container = result.container;
            p.index = -1;
        }
        if (result.obj == null ||
            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {
            this.Error("Failed to find content at path '" +
                path +
                "', and no approximation of it was possible.");
        }
        else if (result.approximate)
            this.Warning("Failed to find content at path '" +
                path +
                "', so it was approximated to: '" +
                result.obj.path +
                "'.");
        return p;
    }
    StateSnapshot() {
        this._stateSnapshotAtLastNewline = this._state;
        this._state = this._state.CopyAndStartPatching();
    }
    RestoreStateSnapshot() {
        if (this._stateSnapshotAtLastNewline === null) {
            NullException_1.throwNullException("_stateSnapshotAtLastNewline");
        }
        this._stateSnapshotAtLastNewline.RestoreAfterPatch();
        this._state = this._stateSnapshotAtLastNewline;
        this._stateSnapshotAtLastNewline = null;
        if (!this._asyncSaving) {
            this._state.ApplyAnyPatch();
        }
    }
    DiscardSnapshot() {
        if (!this._asyncSaving)
            this._state.ApplyAnyPatch();
        this._stateSnapshotAtLastNewline = null;
    }
    CopyStateForBackgroundThreadSave() {
        this.IfAsyncWeCant("start saving on a background thread");
        if (this._asyncSaving)
            throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");
        let stateToSave = this._state;
        this._state = this._state.CopyAndStartPatching();
        this._asyncSaving = true;
        return stateToSave;
    }
    BackgroundSaveComplete() {
        if (this._stateSnapshotAtLastNewline === null) {
            this._state.ApplyAnyPatch();
        }
        this._asyncSaving = false;
    }
    Step() {
        let shouldAddToStream = true;
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull) {
            return;
        }
        // Container containerToEnter = pointer.Resolve () as Container;
        let containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        while (containerToEnter) {
            this.VisitContainer(containerToEnter, true);
            // No content? the most we can do is step past it
            if (containerToEnter.content.length == 0) {
                break;
            }
            pointer = Pointer_1.Pointer.StartOf(containerToEnter);
            // containerToEnter = pointer.Resolve() as Container;
            containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        }
        this.state.currentPointer = pointer.copy();
        if (this._profiler != null)
            this._profiler.Step(this.state.callStack);
        // Is the current content object:
        //  - Normal content
        //  - Or a logic/flow statement - if so, do it
        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot
        // that was diverted to rather than called as a function)
        let currentContentObj = pointer.Resolve();
        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);
        // Has flow been forced to end by flow control above?
        if (this.state.currentPointer.isNull) {
            return;
        }
        if (isLogicOrFlowControl) {
            shouldAddToStream = false;
        }
        // Choice with condition?
        // var choicePoint = currentContentObj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(currentContentObj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let choice = this.ProcessChoice(choicePoint);
            if (choice) {
                this.state.generatedChoices.push(choice);
            }
            currentContentObj = null;
            shouldAddToStream = false;
        }
        // If the container has no content, then it will be
        // the "content" itself, but we skip over it.
        if (currentContentObj instanceof Container_1.Container) {
            shouldAddToStream = false;
        }
        // Content to add to evaluation stack or the output stream
        if (shouldAddToStream) {
            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific
            // to our current (possibly temporary) context index. And make a copy of the pointer
            // so that we're not editing the original runtime object.
            // var varPointer = currentContentObj as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(currentContentObj, Value_1.VariablePointerValue);
            if (varPointer && varPointer.contextIndex == -1) {
                // Create new object so we're not overwriting the story's own data
                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);
                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);
            }
            // Expression evaluation content
            if (this.state.inExpressionEvaluation) {
                this.state.PushEvaluationStack(currentContentObj);
            }
            // Output stream content (i.e. not expression evaluation)
            else {
                this.state.PushToOutputStream(currentContentObj);
            }
        }
        // Increment the content pointer, following diverts if necessary
        this.NextContent();
        // Starting a thread should be done after the increment to the content pointer,
        // so that when returning from the thread, it returns to the content after this instruction.
        // var controlCmd = currentContentObj as ;
        let controlCmd = TypeAssertion_1.asOrNull(currentContentObj, ControlCommand_1.ControlCommand);
        if (controlCmd &&
            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {
            this.state.callStack.PushThread();
        }
    }
    VisitContainer(container, atStart) {
        if (!container.countingAtStartOnly || atStart) {
            if (container.visitsShouldBeCounted)
                this.state.IncrementVisitCountForContainer(container);
            if (container.turnIndexShouldBeCounted)
                this.state.RecordTurnIndexVisitToContainer(container);
        }
    }
    VisitChangedContainersDueToDivert() {
        let previousPointer = this.state.previousPointer.copy();
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull || pointer.index == -1)
            return;
        this._prevContainers.length = 0;
        if (!previousPointer.isNull) {
            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;
            let resolvedPreviousAncestor = previousPointer.Resolve();
            let prevAncestor = TypeAssertion_1.asOrNull(resolvedPreviousAncestor, Container_1.Container) ||
                TypeAssertion_1.asOrNull(previousPointer.container, Container_1.Container);
            while (prevAncestor) {
                this._prevContainers.push(prevAncestor);
                // prevAncestor = prevAncestor.parent as Container;
                prevAncestor = TypeAssertion_1.asOrNull(prevAncestor.parent, Container_1.Container);
            }
        }
        let currentChildOfContainer = pointer.Resolve();
        if (currentChildOfContainer == null)
            return;
        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;
        let currentContainerAncestor = TypeAssertion_1.asOrNull(currentChildOfContainer.parent, Container_1.Container);
        while (currentContainerAncestor &&
            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||
                currentContainerAncestor.countingAtStartOnly)) {
            // Check whether this ancestor container is being entered at the start,
            // by checking whether the child object is the first.
            let enteringAtStart = currentContainerAncestor.content.length > 0 &&
                currentChildOfContainer == currentContainerAncestor.content[0];
            // Mark a visit to this container
            this.VisitContainer(currentContainerAncestor, enteringAtStart);
            currentChildOfContainer = currentContainerAncestor;
            // currentContainerAncestor = currentContainerAncestor.parent as Container;
            currentContainerAncestor = TypeAssertion_1.asOrNull(currentContainerAncestor.parent, Container_1.Container);
        }
    }
    ProcessChoice(choicePoint) {
        let showChoice = true;
        // Don't create choice if choice point doesn't pass conditional
        if (choicePoint.hasCondition) {
            let conditionValue = this.state.PopEvaluationStack();
            if (!this.IsTruthy(conditionValue)) {
                showChoice = false;
            }
        }
        let startText = "";
        let choiceOnlyText = "";
        if (choicePoint.hasChoiceOnlyContent) {
            // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;
            let choiceOnlyStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            choiceOnlyText = choiceOnlyStrVal.value || "";
        }
        if (choicePoint.hasStartContent) {
            // var startStrVal = state.PopEvaluationStack () as StringValue;
            let startStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            startText = startStrVal.value || "";
        }
        // Don't create choice if player has already read this content
        if (choicePoint.onceOnly) {
            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);
            if (visitCount > 0) {
                showChoice = false;
            }
        }
        // We go through the full process of creating the choice above so
        // that we consume the content for it, since otherwise it'll
        // be shown on the output stream.
        if (!showChoice) {
            return null;
        }
        let choice = new Choice_1.Choice();
        choice.targetPath = choicePoint.pathOnChoice;
        choice.sourcePath = choicePoint.path.toString();
        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;
        choice.threadAtGeneration = this.state.callStack.ForkThread();
        choice.text = (startText + choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g, "");
        return choice;
    }
    IsTruthy(obj) {
        let truthy = false;
        if (obj instanceof Value_1.Value) {
            let val = obj;
            if (val instanceof Value_1.DivertTargetValue) {
                let divTarget = val;
                this.Error("Shouldn't use a divert target (to " +
                    divTarget.targetPath +
                    ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
                return false;
            }
            return val.isTruthy;
        }
        return truthy;
    }
    PerformLogicAndFlowControl(contentObj) {
        if (contentObj == null) {
            return false;
        }
        // Divert
        if (contentObj instanceof Divert_1.Divert) {
            let currentDivert = contentObj;
            if (currentDivert.isConditional) {
                let conditionValue = this.state.PopEvaluationStack();
                // False conditional? Cancel divert
                if (!this.IsTruthy(conditionValue))
                    return true;
            }
            if (currentDivert.hasVariableTarget) {
                let varName = currentDivert.variableDivertName;
                let varContents = this.state.variablesState.GetVariableWithName(varName);
                if (varContents == null) {
                    this.Error("Tried to divert using a target from a variable that could not be found (" +
                        varName +
                        ")");
                }
                else if (!(varContents instanceof Value_1.DivertTargetValue)) {
                    // var intContent = varContents as IntValue;
                    let intContent = TypeAssertion_1.asOrNull(varContents, Value_1.IntValue);
                    let errorMessage = "Tried to divert to a target from a variable, but the variable (" +
                        varName +
                        ") didn't contain a divert target, it ";
                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {
                        errorMessage += "was empty/null (the value 0).";
                    }
                    else {
                        errorMessage += "contained '" + varContents + "'.";
                    }
                    this.Error(errorMessage);
                }
                let target = TypeAssertion_1.asOrThrows(varContents, Value_1.DivertTargetValue);
                this.state.divertedPointer = this.PointerAtPath(target.targetPath);
            }
            else if (currentDivert.isExternal) {
                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);
                return true;
            }
            else {
                this.state.divertedPointer = currentDivert.targetPointer.copy();
            }
            if (currentDivert.pushesToStack) {
                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);
            }
            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {
                if (currentDivert &&
                    currentDivert.debugMetadata &&
                    currentDivert.debugMetadata.sourceName != null) {
                    this.Error("Divert target doesn't exist: " +
                        currentDivert.debugMetadata.sourceName);
                }
                else {
                    this.Error("Divert resolution failed: " + currentDivert);
                }
            }
            return true;
        }
        // Start/end an expression evaluation? Or print out the result?
        else if (contentObj instanceof ControlCommand_1.ControlCommand) {
            let evalCommand = contentObj;
            switch (evalCommand.commandType) {
                case ControlCommand_1.ControlCommand.CommandType.EvalStart:
                    this.Assert(this.state.inExpressionEvaluation === false, "Already in expression evaluation?");
                    this.state.inExpressionEvaluation = true;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:
                    this.Assert(this.state.inExpressionEvaluation === true, "Not in expression evaluation mode");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:
                    // If the expression turned out to be empty, there may not be anything on the stack
                    if (this.state.evaluationStack.length > 0) {
                        let output = this.state.PopEvaluationStack();
                        // Functions may evaluate to Void, in which case we skip output
                        if (!(output instanceof Void_1.Void)) {
                            // TODO: Should we really always blanket convert to string?
                            // It would be okay to have numbers in the output stream the
                            // only problem is when exporting text for viewing, it skips over numbers etc.
                            let text = new Value_1.StringValue(output.toString());
                            this.state.PushToOutputStream(text);
                        }
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.NoOp:
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Duplicate:
                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:
                    this.state.PopEvaluationStack();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopFunction:
                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:
                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction
                        ? PushPop_1.PushPopType.Function
                        : PushPop_1.PushPopType.Tunnel;
                    let overrideTunnelReturnTarget = null;
                    if (popType == PushPop_1.PushPopType.Tunnel) {
                        let popped = this.state.PopEvaluationStack();
                        // overrideTunnelReturnTarget = popped as DivertTargetValue;
                        overrideTunnelReturnTarget = TypeAssertion_1.asOrNull(popped, Value_1.DivertTargetValue);
                        if (overrideTunnelReturnTarget === null) {
                            this.Assert(popped instanceof Void_1.Void, "Expected void if ->-> doesn't override target");
                        }
                    }
                    if (this.state.TryExitFunctionEvaluationFromGame()) {
                        break;
                    }
                    else if (this.state.callStack.currentElement.type != popType ||
                        !this.state.callStack.canPop) {
                        let names = new Map();
                        names.set(PushPop_1.PushPopType.Function, "function return statement (~ return)");
                        names.set(PushPop_1.PushPopType.Tunnel, "tunnel onwards statement (->->)");
                        let expected = names.get(this.state.callStack.currentElement.type);
                        if (!this.state.callStack.canPop) {
                            expected = "end of flow (-> END or choice)";
                        }
                        let errorMsg = "Found " + names.get(popType) + ", when expected " + expected;
                        this.Error(errorMsg);
                    }
                    else {
                        this.state.PopCallStack();
                        if (overrideTunnelReturnTarget)
                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.BeginString:
                    this.state.PushToOutputStream(evalCommand);
                    this.Assert(this.state.inExpressionEvaluation === true, "Expected to be in an expression when evaluating a string");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EndString:
                    let contentStackForString = [];
                    let outputCountConsumed = 0;
                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
                        let obj = this.state.outputStream[i];
                        outputCountConsumed++;
                        // var command = obj as ControlCommand;
                        let command = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
                        if (command &&
                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                            break;
                        }
                        if (obj instanceof Value_1.StringValue) {
                            contentStackForString.push(obj);
                        }
                    }
                    // Consume the content that was produced for this string
                    this.state.PopFromOutputStream(outputCountConsumed);
                    // The C# version uses a Stack for contentStackForString, but we're
                    // using a simple array, so we need to reverse it before using it
                    contentStackForString = contentStackForString.reverse();
                    // Build string out of the content we collected
                    let sb = new StringBuilder_1.StringBuilder();
                    for (let c of contentStackForString) {
                        sb.Append(c.toString());
                    }
                    // Return to expression evaluation (from content mode)
                    this.state.inExpressionEvaluation = true;
                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:
                    let choiceCount = this.state.generatedChoices.length;
                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Turns:
                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:
                case ControlCommand_1.ControlCommand.CommandType.ReadCount:
                    let target = this.state.PopEvaluationStack();
                    if (!(target instanceof Value_1.DivertTargetValue)) {
                        let extraNote = "";
                        if (target instanceof Value_1.IntValue)
                            extraNote =
                                ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
                        this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw " +
                            target +
                            extraNote);
                        break;
                    }
                    // var divertTarget = target as DivertTargetValue;
                    let divertTarget = TypeAssertion_1.asOrThrows(target, Value_1.DivertTargetValue);
                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;
                    let container = TypeAssertion_1.asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);
                    let eitherCount;
                    if (container != null) {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = this.state.TurnsSinceForContainer(container);
                        else
                            eitherCount = this.state.VisitCountForContainer(container);
                    }
                    else {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = -1;
                        else
                            eitherCount = 0;
                        this.Warning("Failed to find container for " +
                            evalCommand.toString() +
                            " lookup at " +
                            divertTarget.targetPath.toString());
                    }
                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Random: {
                    let maxInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    let minInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (minInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");
                    if (maxInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (maxInt.value === null) {
                        return NullException_1.throwNullException("maxInt.value");
                    }
                    if (minInt.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    let randomRange = maxInt.value - minInt.value + 1;
                    if (randomRange <= 0)
                        this.Error("RANDOM was called with minimum as " +
                            minInt.value +
                            " and maximum as " +
                            maxInt.value +
                            ". The maximum must be larger");
                    let resultSeed = this.state.storySeed + this.state.previousRandom;
                    let random = new PRNG_1.PRNG(resultSeed);
                    let nextRandom = random.next();
                    let chosenValue = (nextRandom % randomRange) + minInt.value;
                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));
                    // Next random number (rather than keeping the Random object around)
                    this.state.previousRandom = nextRandom;
                    break;
                }
                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:
                    let seed = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (seed == null || seed instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value passed to SEED_RANDOM");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (seed.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    this.state.storySeed = seed.value;
                    this.state.previousRandom = 0;
                    this.state.PushEvaluationStack(new Void_1.Void());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:
                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count
                    this.state.PushEvaluationStack(new Value_1.IntValue(count));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:
                    let shuffleIndex = this.NextSequenceShuffleIndex();
                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.StartThread:
                    // Handled in main step function
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Done:
                    // We may exist in the context of the initial
                    // act of creating the thread, or in the context of
                    // evaluating the content.
                    if (this.state.callStack.canPopThread) {
                        this.state.callStack.PopThread();
                    }
                    // In normal flow - allow safe exit without warning
                    else {
                        this.state.didSafeExit = true;
                        // Stop flow in current thread
                        this.state.currentPointer = Pointer_1.Pointer.Null;
                    }
                    break;
                // Force flow to end completely
                case ControlCommand_1.ControlCommand.CommandType.End:
                    this.state.ForceEnd();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:
                    // var intVal = state.PopEvaluationStack () as IntValue;
                    let intVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    // var listNameVal = state.PopEvaluationStack () as StringValue;
                    let listNameVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
                    if (intVal === null) {
                        throw new StoryException_1.StoryException("Passed non-integer when creating a list element from a numerical value.");
                    }
                    let generatedListValue = null;
                    if (this.listDefinitions === null) {
                        return NullException_1.throwNullException("this.listDefinitions");
                    }
                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);
                    if (foundListDef.exists) {
                        // Originally a primitive type, but here, can be null.
                        // TODO: Replace by default value?
                        if (intVal.value === null) {
                            return NullException_1.throwNullException("minInt.value");
                        }
                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);
                        if (foundItem.exists) {
                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);
                        }
                    }
                    else {
                        throw new StoryException_1.StoryException("Failed to find LIST called " + listNameVal.value);
                    }
                    if (generatedListValue == null)
                        generatedListValue = new Value_1.ListValue();
                    this.state.PushEvaluationStack(generatedListValue);
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRange:
                    let max = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    let min = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    // var targetList = state.PopEvaluationStack () as ListValue;
                    let targetList = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.ListValue);
                    if (targetList === null || min === null || max === null)
                        throw new StoryException_1.StoryException("Expected list, minimum and maximum for LIST_RANGE");
                    if (targetList.value === null) {
                        return NullException_1.throwNullException("targetList.value");
                    }
                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);
                    this.state.PushEvaluationStack(new Value_1.ListValue(result));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {
                    let listVal = this.state.PopEvaluationStack();
                    if (listVal === null)
                        throw new StoryException_1.StoryException("Expected list for LIST_RANDOM");
                    let list = listVal.value;
                    let newList = null;
                    if (list === null) {
                        throw NullException_1.throwNullException("list");
                    }
                    if (list.Count == 0) {
                        newList = new InkList_1.InkList();
                    }
                    else {
                        // Generate a random index for the element to take
                        let resultSeed = this.state.storySeed + this.state.previousRandom;
                        let random = new PRNG_1.PRNG(resultSeed);
                        let nextRandom = random.next();
                        let listItemIndex = nextRandom % list.Count;
                        // This bit is a little different from the original
                        // C# code, since iterators do not work in the same way.
                        // First, we iterate listItemIndex - 1 times, calling next().
                        // The listItemIndex-th time is made outside of the loop,
                        // in order to retrieve the value.
                        let listEnumerator = list.entries();
                        for (let i = 0; i <= listItemIndex - 1; i++) {
                            listEnumerator.next();
                        }
                        let value = listEnumerator.next().value;
                        let randomItem = {
                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),
                            Value: value[1],
                        };
                        // Origin list is simply the origin of the one element
                        if (randomItem.Key.originName === null) {
                            return NullException_1.throwNullException("randomItem.Key.originName");
                        }
                        newList = new InkList_1.InkList(randomItem.Key.originName, this);
                        newList.Add(randomItem.Key, randomItem.Value);
                        this.state.previousRandom = nextRandom;
                    }
                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));
                    break;
                }
                default:
                    this.Error("unhandled ControlCommand: " + evalCommand);
                    break;
            }
            return true;
        }
        // Variable assignment
        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {
            let varAss = contentObj;
            let assignedVal = this.state.PopEvaluationStack();
            this.state.variablesState.Assign(varAss, assignedVal);
            return true;
        }
        // Variable reference
        else if (contentObj instanceof VariableReference_1.VariableReference) {
            let varRef = contentObj;
            let foundValue = null;
            // Explicit read count value
            if (varRef.pathForCount != null) {
                let container = varRef.containerForCount;
                let count = this.state.VisitCountForContainer(container);
                foundValue = new Value_1.IntValue(count);
            }
            // Normal variable reference
            else {
                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);
                if (foundValue == null) {
                    this.Warning("Variable not found: '" +
                        varRef.name +
                        "'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.");
                    foundValue = new Value_1.IntValue(0);
                }
            }
            this.state.PushEvaluationStack(foundValue);
            return true;
        }
        // Native function call
        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {
            let func = contentObj;
            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);
            let result = func.Call(funcParams);
            this.state.PushEvaluationStack(result);
            return true;
        }
        // No control content, must be ordinary content
        return false;
    }
    ChoosePathString(path, resetCallstack = true, args = []) {
        this.IfAsyncWeCant("call ChoosePathString right now");
        if (resetCallstack) {
            this.ResetCallstack();
        }
        else {
            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {
                let funcDetail = "";
                let container = this.state.callStack.currentElement.currentPointer
                    .container;
                if (container != null) {
                    funcDetail = "(" + container.path.toString() + ") ";
                }
                throw new Error("Story was running a function " +
                    funcDetail +
                    "when you called ChoosePathString(" +
                    path +
                    ") - this is almost certainly not not what you want! Full stack trace: \n" +
                    this.state.callStack.callStackTrace);
            }
        }
        this.state.PassArgumentsToEvaluationStack(args);
        this.ChoosePath(new Path_1.Path(path));
    }
    IfAsyncWeCant(activityStr) {
        if (this._asyncContinueActive)
            throw new Error("Can't " +
                activityStr +
                ". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.");
    }
    ChoosePath(p, incrementingTurnIndex = true) {
        this.state.SetChosenPath(p, incrementingTurnIndex);
        // Take a note of newly visited containers for read counts etc
        this.VisitChangedContainersDueToDivert();
    }
    ChooseChoiceIndex(choiceIdx) {
        choiceIdx = choiceIdx;
        let choices = this.currentChoices;
        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, "choice out of range");
        let choiceToChoose = choices[choiceIdx];
        if (choiceToChoose.threadAtGeneration === null) {
            return NullException_1.throwNullException("choiceToChoose.threadAtGeneration");
        }
        if (choiceToChoose.targetPath === null) {
            return NullException_1.throwNullException("choiceToChoose.targetPath");
        }
        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;
        this.ChoosePath(choiceToChoose.targetPath);
    }
    HasFunction(functionName) {
        try {
            return this.KnotContainerWithName(functionName) != null;
        }
        catch (e) {
            return false;
        }
    }
    EvaluateFunction(functionName, args = [], returnTextOutput = false) {
        // EvaluateFunction behaves slightly differently than the C# version.
        // In C#, you can pass a (second) parameter `out textOutput` to get the
        // text outputted by the function. This is not possible in js. Instead,
        // we maintain the regular signature (functionName, args), plus an
        // optional third parameter returnTextOutput. If set to true, we will
        // return both the textOutput and the returned value, as an object.
        this.IfAsyncWeCant("evaluate a function");
        if (functionName == null) {
            throw new Error("Function is null");
        }
        else if (functionName == "" || functionName.trim() == "") {
            throw new Error("Function is empty or white space.");
        }
        let funcContainer = this.KnotContainerWithName(functionName);
        if (funcContainer == null) {
            throw new Error("Function doesn't exist: '" + functionName + "'");
        }
        let outputStreamBefore = [];
        outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);
        this._state.ResetOutput();
        this.state.StartFunctionEvaluationFromGame(funcContainer, args);
        // Evaluate the function, and collect the string output
        let stringOutput = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            stringOutput.Append(this.Continue());
        }
        let textOutput = stringOutput.toString();
        this._state.ResetOutput(outputStreamBefore);
        let result = this.state.CompleteFunctionEvaluationFromGame();
        return returnTextOutput ? { returned: result, output: textOutput } : result;
    }
    EvaluateExpression(exprContainer) {
        let startCallStackHeight = this.state.callStack.elements.length;
        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);
        this._temporaryEvaluationContainer = exprContainer;
        this.state.GoToStart();
        let evalStackHeight = this.state.evaluationStack.length;
        this.Continue();
        this._temporaryEvaluationContainer = null;
        // Should have fallen off the end of the Container, which should
        // have auto-popped, but just in case we didn't for some reason,
        // manually pop to restore the state (including currentPath).
        if (this.state.callStack.elements.length > startCallStackHeight) {
            this.state.PopCallStack();
        }
        let endStackHeight = this.state.evaluationStack.length;
        if (endStackHeight > evalStackHeight) {
            return this.state.PopEvaluationStack();
        }
        else {
            return null;
        }
    }
    CallExternalFunction(funcName, numberOfArguments) {
        if (funcName === null) {
            return NullException_1.throwNullException("funcName");
        }
        let func = this._externals.get(funcName);
        let fallbackFunctionContainer = null;
        let foundExternal = typeof func !== "undefined";
        // Try to use fallback function?
        if (!foundExternal) {
            if (this.allowExternalFunctionFallbacks) {
                fallbackFunctionContainer = this.KnotContainerWithName(funcName);
                this.Assert(fallbackFunctionContainer !== null, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound, and fallback ink function could not be found.");
                // Divert direct into fallback function and we're done
                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);
                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);
                return;
            }
            else {
                this.Assert(false, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound (and ink fallbacks disabled).");
            }
        }
        // Pop arguments
        let args = [];
        for (let i = 0; i < numberOfArguments; ++i) {
            // var poppedObj = state.PopEvaluationStack () as Value;
            let poppedObj = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.Value);
            let valueObj = poppedObj.valueObject;
            args.push(valueObj);
        }
        // Reverse arguments from the order they were popped,
        // so they're the right way round again.
        args.reverse();
        // Run the function!
        let funcResult = func(args);
        // Convert return value (if any) to the a type that the ink engine can use
        let returnObj = null;
        if (funcResult != null) {
            returnObj = Value_1.Value.Create(funcResult);
            this.Assert(returnObj !== null, "Could not create ink value from returned object of type " +
                typeof funcResult);
        }
        else {
            returnObj = new Void_1.Void();
        }
        this.state.PushEvaluationStack(returnObj);
    }
    BindExternalFunctionGeneral(funcName, func) {
        this.IfAsyncWeCant("bind an external function");
        this.Assert(!this._externals.has(funcName), "Function '" + funcName + "' has already been bound.");
        this._externals.set(funcName, func);
    }
    TryCoerce(value) {
        // We're skipping type coercition in this implementation. First of, js
        // is loosely typed, so it's not that important. Secondly, there is no
        // clean way (AFAIK) for the user to describe what type of parameters
        // they expect.
        return value;
    }
    BindExternalFunction(funcName, func) {
        this.Assert(func != null, "Can't bind a null function");
        this.BindExternalFunctionGeneral(funcName, (args) => {
            this.Assert(args.length >= func.length, "External function expected " + func.length + " arguments");
            let coercedArgs = [];
            for (let i = 0, l = args.length; i < l; i++) {
                coercedArgs[i] = this.TryCoerce(args[i]);
            }
            return func.apply(null, coercedArgs);
        });
    }
    UnbindExternalFunction(funcName) {
        this.IfAsyncWeCant("unbind an external a function");
        this.Assert(this._externals.has(funcName), "Function '" + funcName + "' has not been bound.");
        this._externals.delete(funcName);
    }
    ValidateExternalBindings() {
        let c = null;
        let o = null;
        let missingExternals = arguments[1] || new Set();
        if (arguments[0] instanceof Container_1.Container) {
            c = arguments[0];
        }
        if (arguments[0] instanceof Object_1.InkObject) {
            o = arguments[0];
        }
        if (c === null && o === null) {
            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);
            this._hasValidatedExternals = true;
            // No problem! Validation complete
            if (missingExternals.size == 0) {
                this._hasValidatedExternals = true;
            }
            else {
                let message = "Error: Missing function binding for external";
                message += missingExternals.size > 1 ? "s" : "";
                message += ": '";
                message += Array.from(missingExternals).join("', '");
                message += "' ";
                message += this.allowExternalFunctionFallbacks
                    ? ", and no fallback ink function found."
                    : " (ink fallbacks disabled)";
                this.Error(message);
            }
        }
        else if (c != null) {
            for (let innerContent of c.content) {
                let container = innerContent;
                if (container == null || !container.hasValidName)
                    this.ValidateExternalBindings(innerContent, missingExternals);
            }
            for (let [, value] of c.namedContent) {
                this.ValidateExternalBindings(TypeAssertion_1.asOrNull(value, Object_1.InkObject), missingExternals);
            }
        }
        else if (o != null) {
            let divert = TypeAssertion_1.asOrNull(o, Divert_1.Divert);
            if (divert && divert.isExternal) {
                let name = divert.targetPathString;
                if (name === null) {
                    return NullException_1.throwNullException("name");
                }
                if (!this._externals.has(name)) {
                    if (this.allowExternalFunctionFallbacks) {
                        let fallbackFound = this.mainContentContainer.namedContent.has(name);
                        if (!fallbackFound) {
                            missingExternals.add(name);
                        }
                    }
                    else {
                        missingExternals.add(name);
                    }
                }
            }
        }
    }
    ObserveVariable(variableName, observer) {
        this.IfAsyncWeCant("observe a new variable");
        if (this._variableObservers === null)
            this._variableObservers = new Map();
        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))
            throw new StoryException_1.StoryException("Cannot observe variable '" +
                variableName +
                "' because it wasn't declared in the ink story.");
        if (this._variableObservers.has(variableName)) {
            this._variableObservers.get(variableName).push(observer);
        }
        else {
            this._variableObservers.set(variableName, [observer]);
        }
    }
    ObserveVariables(variableNames, observers) {
        for (let i = 0, l = variableNames.length; i < l; i++) {
            this.ObserveVariable(variableNames[i], observers[i]);
        }
    }
    RemoveVariableObserver(observer, specificVariableName) {
        this.IfAsyncWeCant("remove a variable observer");
        if (this._variableObservers === null)
            return;
        if (typeof specificVariableName !== "undefined") {
            if (this._variableObservers.has(specificVariableName)) {
                let observers = this._variableObservers.get(specificVariableName);
                if (observer !== null) {
                    observers.splice(observers.indexOf(observer), 1);
                }
                else {
                    this._variableObservers.delete(specificVariableName);
                }
            }
        }
        else if (observer !== null) {
            let keys = this._variableObservers.keys();
            for (let varName of keys) {
                let observers = this._variableObservers.get(varName);
                observers.splice(observers.indexOf(observer), 1);
            }
        }
    }
    VariableStateDidChangeEvent(variableName, newValueObj) {
        if (this._variableObservers === null)
            return;
        let observers = this._variableObservers.get(variableName);
        if (typeof observers !== "undefined") {
            if (!(newValueObj instanceof Value_1.Value)) {
                throw new Error("Tried to get the value of a variable that isn't a standard type");
            }
            // var val = newValueObj as Value;
            let val = TypeAssertion_1.asOrThrows(newValueObj, Value_1.Value);
            for (let observer of observers) {
                observer(variableName, val.valueObject);
            }
        }
    }
    get globalTags() {
        return this.TagsAtStartOfFlowContainerWithPathString("");
    }
    TagsForContentAtPath(path) {
        return this.TagsAtStartOfFlowContainerWithPathString(path);
    }
    TagsAtStartOfFlowContainerWithPathString(pathString) {
        let path = new Path_1.Path(pathString);
        let flowContainer = this.ContentAtPath(path).container;
        if (flowContainer === null) {
            return NullException_1.throwNullException("flowContainer");
        }
        while (true) {
            let firstContent = flowContainer.content[0];
            if (firstContent instanceof Container_1.Container)
                flowContainer = firstContent;
            else
                break;
        }
        let tags = null;
        for (let c of flowContainer.content) {
            // var tag = c as Runtime.Tag;
            let tag = TypeAssertion_1.asOrNull(c, Tag_1.Tag);
            if (tag) {
                if (tags == null)
                    tags = [];
                tags.push(tag.text);
            }
            else
                break;
        }
        return tags;
    }
    BuildStringOfHierarchy() {
        let sb = new StringBuilder_1.StringBuilder();
        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    BuildStringOfContainer(container) {
        let sb = new StringBuilder_1.StringBuilder();
        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    NextContent() {
        this.state.previousPointer = this.state.currentPointer.copy();
        if (!this.state.divertedPointer.isNull) {
            this.state.currentPointer = this.state.divertedPointer.copy();
            this.state.divertedPointer = Pointer_1.Pointer.Null;
            this.VisitChangedContainersDueToDivert();
            if (!this.state.currentPointer.isNull) {
                return;
            }
        }
        let successfulPointerIncrement = this.IncrementContentPointer();
        if (!successfulPointerIncrement) {
            let didPop = false;
            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {
                this.state.PopCallStack(PushPop_1.PushPopType.Function);
                if (this.state.inExpressionEvaluation) {
                    this.state.PushEvaluationStack(new Void_1.Void());
                }
                didPop = true;
            }
            else if (this.state.callStack.canPopThread) {
                this.state.callStack.PopThread();
                didPop = true;
            }
            else {
                this.state.TryExitFunctionEvaluationFromGame();
            }
            if (didPop && !this.state.currentPointer.isNull) {
                this.NextContent();
            }
        }
    }
    IncrementContentPointer() {
        let successfulIncrement = true;
        let pointer = this.state.callStack.currentElement.currentPointer.copy();
        pointer.index++;
        if (pointer.container === null) {
            return NullException_1.throwNullException("pointer.container");
        }
        while (pointer.index >= pointer.container.content.length) {
            successfulIncrement = false;
            // Container nextAncestor = pointer.container.parent as Container;
            let nextAncestor = TypeAssertion_1.asOrNull(pointer.container.parent, Container_1.Container);
            if (nextAncestor instanceof Container_1.Container === false) {
                break;
            }
            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);
            if (indexInAncestor == -1) {
                break;
            }
            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);
            pointer.index++;
            successfulIncrement = true;
            if (pointer.container === null) {
                return NullException_1.throwNullException("pointer.container");
            }
        }
        if (!successfulIncrement)
            pointer = Pointer_1.Pointer.Null;
        this.state.callStack.currentElement.currentPointer = pointer.copy();
        return successfulIncrement;
    }
    TryFollowDefaultInvisibleChoice() {
        let allChoices = this._state.currentChoices;
        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);
        if (invisibleChoices.length == 0 ||
            allChoices.length > invisibleChoices.length)
            return false;
        let choice = invisibleChoices[0];
        if (choice.targetPath === null) {
            return NullException_1.throwNullException("choice.targetPath");
        }
        if (choice.threadAtGeneration === null) {
            return NullException_1.throwNullException("choice.threadAtGeneration");
        }
        this.state.callStack.currentThread = choice.threadAtGeneration;
        this.ChoosePath(choice.targetPath, false);
        return true;
    }
    NextSequenceShuffleIndex() {
        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;
        let numElementsIntVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
        if (!(numElementsIntVal instanceof Value_1.IntValue)) {
            this.Error("expected number of elements in sequence for shuffle index");
            return 0;
        }
        let seqContainer = this.state.currentPointer.container;
        if (seqContainer === null) {
            return NullException_1.throwNullException("seqContainer");
        }
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (numElementsIntVal.value === null) {
            return NullException_1.throwNullException("numElementsIntVal.value");
        }
        let numElements = numElementsIntVal.value;
        // var seqCountVal = state.PopEvaluationStack () as IntValue;
        let seqCountVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.IntValue);
        let seqCount = seqCountVal.value;
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (seqCount === null) {
            return NullException_1.throwNullException("seqCount");
        }
        let loopIndex = seqCount / numElements;
        let iterationIndex = seqCount % numElements;
        let seqPathStr = seqContainer.path.toString();
        let sequenceHash = 0;
        for (let i = 0, l = seqPathStr.length; i < l; i++) {
            sequenceHash += seqPathStr.charCodeAt(i) || 0;
        }
        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;
        let random = new PRNG_1.PRNG(Math.floor(randomSeed));
        let unpickedIndices = [];
        for (let i = 0; i < numElements; ++i) {
            unpickedIndices.push(i);
        }
        for (let i = 0; i <= iterationIndex; ++i) {
            let chosen = random.next() % unpickedIndices.length;
            let chosenIndex = unpickedIndices[chosen];
            unpickedIndices.splice(chosen, 1);
            if (i == iterationIndex) {
                return chosenIndex;
            }
        }
        throw new Error("Should never reach here");
    }
    Error(message, useEndLineNumber = false) {
        let e = new StoryException_1.StoryException(message);
        e.useEndLineNumber = useEndLineNumber;
        throw e;
    }
    Warning(message) {
        this.AddError(message, true);
    }
    AddError(message, isWarning = false, useEndLineNumber = false) {
        let dm = this.currentDebugMetadata;
        let errorTypeStr = isWarning ? "WARNING" : "ERROR";
        if (dm != null) {
            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": '" +
                    dm.fileName +
                    "' line " +
                    lineNum +
                    ": " +
                    message;
        }
        else if (!this.state.currentPointer.isNull) {
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": (" +
                    this.state.currentPointer +
                    "): " +
                    message;
        }
        else {
            message = "RUNTIME " + errorTypeStr + ": " + message;
        }
        this.state.AddError(message, isWarning);
        // In a broken state don't need to know about any other errors.
        if (!isWarning)
            this.state.ForceEnd();
    }
    Assert(condition, message = null) {
        if (condition == false) {
            if (message == null) {
                message = "Story assert";
            }
            throw new Error(message + " " + this.currentDebugMetadata);
        }
    }
    get currentDebugMetadata() {
        let dm;
        let pointer = this.state.currentPointer;
        if (!pointer.isNull && pointer.Resolve() !== null) {
            dm = pointer.Resolve().debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {
            pointer = this.state.callStack.elements[i].currentPointer;
            if (!pointer.isNull && pointer.Resolve() !== null) {
                dm = pointer.Resolve().debugMetadata;
                if (dm !== null) {
                    return dm;
                }
            }
        }
        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
            let outputObj = this.state.outputStream[i];
            dm = outputObj.debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        return null;
    }
    get mainContentContainer() {
        if (this._temporaryEvaluationContainer) {
            return this._temporaryEvaluationContainer;
        }
        else {
            return this._mainContentContainer;
        }
    }
}
exports.Story = Story;
Story.inkVersionCurrent = 19;
(function (Story) {
    let OutputStateChange;
    (function (OutputStateChange) {
        OutputStateChange[OutputStateChange["NoChange"] = 0] = "NoChange";
        OutputStateChange[OutputStateChange["ExtendedBeyondNewline"] = 1] = "ExtendedBeyondNewline";
        OutputStateChange[OutputStateChange["NewlineRemoved"] = 2] = "NewlineRemoved";
    })(OutputStateChange = Story.OutputStateChange || (Story.OutputStateChange = {}));
})(Story = exports.Story || (exports.Story = {}));
//# sourceMappingURL=Story.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryException.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryException.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryException = void 0;
class StoryException extends Error {
    constructor(message) {
        super(message);
        this.useEndLineNumber = false;
        this.message = message;
        this.name = "StoryException";
    }
}
exports.StoryException = StoryException;
//# sourceMappingURL=StoryException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryState.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryState.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryState = void 0;
const CallStack_1 = __webpack_require__(/*! ./CallStack */ "./node_modules/inkjs/engine/CallStack.js");
const VariablesState_1 = __webpack_require__(/*! ./VariablesState */ "./node_modules/inkjs/engine/VariablesState.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StatePatch_1 = __webpack_require__(/*! ./StatePatch */ "./node_modules/inkjs/engine/StatePatch.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this._patch = null;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this.currentTurnIndex = -1;
        let timeSeed = new Date().getTime();
        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        let writer = new SimpleJson_1.SimpleJson.Writer();
        this.WriteJson(writer);
        return writer.ToString();
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);
        this.LoadJsonObj(jObject);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut;
        if (this._patch !== null) {
            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;
            if (container === null)
                throw new Error("Content at path not found: " + pathString);
            visitCountOut = this._patch.TryGetVisitCount(container, 0);
            if (visitCountOut.exists)
                return visitCountOut.result;
        }
        visitCountOut = TryGetResult_1.tryGetValueFromMap(this._visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    VisitCountForContainer(container) {
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        if (!container.visitsShouldBeCounted) {
            this.story.Error("Read count for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
            return 0;
        }
        if (this._patch !== null) {
            let count = this._patch.TryGetVisitCount(container, 0);
            if (count.exists) {
                return count.result;
            }
        }
        let containerPathStr = container.path.toString();
        let count2 = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count2.exists) {
            return count2.result;
        }
        return 0;
    }
    IncrementVisitCountForContainer(container) {
        if (this._patch !== null) {
            let currCount = this.VisitCountForContainer(container);
            currCount++;
            this._patch.SetVisitCount(container, currCount);
            return;
        }
        let containerPathStr = container.path.toString();
        let count = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count.exists) {
            this._visitCounts.set(containerPathStr, count.result + 1);
        }
        else {
            this._visitCounts.set(containerPathStr, 1);
        }
    }
    RecordTurnIndexVisitToContainer(container) {
        if (this._patch !== null) {
            this._patch.SetTurnIndex(container, this.currentTurnIndex);
            return;
        }
        let containerPathStr = container.path.toString();
        this._turnIndices.set(containerPathStr, this.currentTurnIndex);
    }
    TurnsSinceForContainer(container) {
        if (!container.turnIndexShouldBeCounted) {
            this.story.Error("TURNS_SINCE() for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
        }
        if (this._patch !== null) {
            let index = this._patch.TryGetTurnIndex(container, 0);
            if (index.exists) {
                return this.currentTurnIndex - index.result;
            }
        }
        let containerPathStr = container.path.toString();
        let index2 = TryGetResult_1.tryGetValueFromMap(this._turnIndices, containerPathStr, 0);
        if (index2.exists) {
            return this.currentTurnIndex - index2.result;
        }
        else {
            return -1;
        }
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    set variablesState(value) {
        this._variablesState = value;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    set currentTurnIndex(value) {
        this._currentTurnIndex = value;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException("pointer.path");
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = c == " " || c == "\t";
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != "\n" &&
                    currentWhitespaceStart > 0 &&
                    currentWhitespaceStart != startOfLine) {
                    sb.Append(" ");
                }
                currentWhitespaceStart = -1;
            }
            if (c == "\n")
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    CopyAndStartPatching() {
        let copy = new StoryState(this.story);
        copy._patch = new StatePatch_1.StatePatch(this._patch);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        copy.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy.variablesState = this.variablesState;
        copy.variablesState.callStack = copy.callStack;
        copy.variablesState.patch = copy._patch;
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = this._visitCounts;
        copy._turnIndices = this._turnIndices;
        copy.currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    RestoreAfterPatch() {
        this.variablesState.callStack = this.callStack;
        this.variablesState.patch = this._patch;
    }
    ApplyAnyPatch() {
        if (this._patch === null)
            return;
        this.variablesState.ApplyPatch();
        for (let [key, value] of this._patch.visitCounts)
            this.ApplyCountChanges(key, value, true);
        for (let [key, value] of this._patch.turnIndices)
            this.ApplyCountChanges(key, value, false);
        this._patch = null;
    }
    ApplyCountChanges(container, newCount, isVisit) {
        let counts = isVisit ? this._visitCounts : this._turnIndices;
        counts.set(container.path.toString(), newCount);
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        let hasChoiceThreads = false;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException("c.threadAtGeneration");
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {
                if (!hasChoiceThreads) {
                    hasChoiceThreads = true;
                    writer.WritePropertyStart("choiceThreads");
                    writer.WriteObjectStart();
                }
                writer.WritePropertyStart(c.originalThreadIndex);
                c.threadAtGeneration.WriteJson(writer);
                writer.WritePropertyEnd();
            }
        }
        if (hasChoiceThreads) {
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        // In the following two calls, `WriteJson` is called inside an arrow
        // function to make sure `this` is correctly bound and passed down
        // the call hierarchy.
        writer.WriteProperty("callstackThreads", (w) => this.callStack.WriteJson(w));
        writer.WriteProperty("variablesState", (w) => this.variablesState.WriteJson(w));
        writer.WriteProperty("evalStack", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));
        writer.WriteProperty("outputStream", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream));
        writer.WriteProperty("currentChoices", (w) => {
            w.WriteArrayStart();
            for (let c of this._currentChoices)
                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);
            w.WriteArrayEnd();
        });
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException("divertedPointer");
            }
            writer.WriteProperty("currentDivertTarget", this.divertedPointer.path.componentsString);
        }
        writer.WriteProperty("visitCounts", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));
        writer.WriteProperty("turnIndices", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));
        writer.WriteIntProperty("turnIdx", this.currentTurnIndex);
        writer.WriteIntProperty("storySeed", this.storySeed);
        writer.WriteIntProperty("previousRandom", this.previousRandom);
        writer.WriteIntProperty("inkSaveVersion", this.kInkSaveStateVersion);
        writer.WriteIntProperty("inkFormatVersion", Story_1.Story.inkVersionCurrent);
        writer.WriteObjectEnd();
    }
    LoadJsonObj(value) {
        let jObject = value;
        let jSaveVersion = jObject["inkSaveVersion"];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" +
                jSaveVersion +
                "', but minimum is " +
                this.kMinCompatibleLoadVersion +
                "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject["callstackThreads"], this.story);
        this.variablesState.SetJsonToken(jObject["variablesState"]);
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);
        let currentDivertTargetPath = jObject["currentDivertTarget"];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);
        this.currentTurnIndex = parseInt(jObject["turnIdx"]);
        this.storySeed = parseInt(jObject["storySeed"]);
        this.previousRandom = parseInt(jObject["previousRandom"]);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject["choiceThreads"];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException("single.value");
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue("\n"));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue("\n"));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = str.length - tailLastNewlineIdx - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;
                let g = o instanceof Glue_1.Glue ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null &&
                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException("obj");
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand &&
                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException("rawList");
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException("StoryState.story.listDefinitions");
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException("StoryState def.result");
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException("obj");
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === "undefined") {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error("trying to pop too many objects");
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement
            .functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex) {
            this.currentTurnIndex++;
        }
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === "number" || typeof args[i] === "string")) {
                    throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type ==
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type !=
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException("Expected external function evaluation to be complete. Stack trace: " +
                this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement
            .evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StringBuilder.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/StringBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StringBuilder = void 0;
class StringBuilder {
    constructor(str) {
        str = typeof str !== "undefined" ? str.toString() : "";
        this.string = str;
    }
    get Length() {
        return this.string.length;
    }
    Append(str) {
        if (str !== null) {
            this.string += str;
        }
    }
    AppendLine(str) {
        if (typeof str !== "undefined")
            this.Append(str);
        this.string += "\n";
    }
    AppendFormat(format, ...args) {
        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format
        this.string += format.replace(/{(\d+)}/g, (match, num) => typeof args[num] != "undefined" ? args[num] : match);
    }
    toString() {
        return this.string;
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Tag.js":
/*!******************************************!*\
  !*** ./node_modules/inkjs/engine/Tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Tag extends Object_1.InkObject {
    constructor(tagText) {
        super();
        this.text = tagText.toString() || "";
    }
    toString() {
        return "# " + this.text;
    }
}
exports.Tag = Tag;
//# sourceMappingURL=Tag.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TryGetResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/TryGetResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseFloat = exports.tryParseInt = exports.tryGetValueFromMap = void 0;
function tryGetValueFromMap(map, key, 
/* out */ value) {
    if (map === null) {
        return { result: value, exists: false };
    }
    let val = map.get(key);
    if (typeof val === "undefined") {
        return { result: value, exists: false };
    }
    else {
        return { result: val, exists: true };
    }
}
exports.tryGetValueFromMap = tryGetValueFromMap;
function tryParseInt(value, 
/* out */ defaultValue = 0) {
    let val = parseInt(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseInt = tryParseInt;
function tryParseFloat(value, 
/* out */ defaultValue = 0) {
    let val = parseFloat(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseFloat = tryParseFloat;
//# sourceMappingURL=TryGetResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TypeAssertion.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/TypeAssertion.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isEquatable = exports.nullIfUndefined = exports.asINamedContentOrNull = exports.asNumberOrThrows = exports.asOrThrows = exports.asOrNull = void 0;
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === "number") {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === "undefined") {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function isEquatable(type) {
    return typeof type === "object" && typeof type.Equals === "function";
}
exports.isEquatable = isEquatable;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Value.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Value.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = exports.ListValue = exports.VariablePointerValue = exports.DivertTargetValue = exports.StringValue = exports.FloatValue = exports.IntValue = exports.Value = exports.AbstractValue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class AbstractValue extends Object_1.InkObject {
    static Create(val, preferredNumberType) {
        // This code doesn't exist in upstream and is simply here to enforce
        // the creation of the proper number value.
        // If `preferredNumberType` is not provided or if value doesn't match
        // `preferredNumberType`, this conditional does nothing.
        if (preferredNumberType) {
            if (preferredNumberType === ValueType.Int &&
                Number.isInteger(Number(val))) {
                return new IntValue(Number(val));
            }
            else if (preferredNumberType === ValueType.Float &&
                !isNaN(val)) {
                return new FloatValue(Number(val));
            }
        }
        // Implicitly convert bools into ints
        if (typeof val === "boolean") {
            let b = !!val;
            val = b ? 1 : 0;
        }
        // https://github.com/y-lohse/inkjs/issues/425
        // Changed condition sequence, because Number('') is
        // parsed to 0, which made setting string to empty
        // impossible
        if (typeof val === "string") {
            return new StringValue(String(val));
        }
        else if (Number.isInteger(Number(val))) {
            return new IntValue(Number(val));
        }
        else if (!isNaN(val)) {
            return new FloatValue(Number(val));
        }
        else if (val instanceof Path_1.Path) {
            return new DivertTargetValue(TypeAssertion_1.asOrThrows(val, Path_1.Path));
        }
        else if (val instanceof InkList_1.InkList) {
            return new ListValue(TypeAssertion_1.asOrThrows(val, InkList_1.InkList));
        }
        return null;
    }
    Copy() {
        return TypeAssertion_1.asOrThrows(AbstractValue.Create(this), Object_1.InkObject);
    }
    BadCastException(targetType) {
        return new StoryException_1.StoryException("Can't cast " +
            this.valueObject +
            " from " +
            this.valueType +
            " to " +
            targetType);
    }
}
exports.AbstractValue = AbstractValue;
class Value extends AbstractValue {
    constructor(val) {
        super();
        this.value = val;
    }
    get valueObject() {
        return this.value;
    }
    toString() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.toString();
    }
}
exports.Value = Value;
class IntValue extends Value {
    constructor(val) {
        super(val || 0);
    }
    get isTruthy() {
        return this.value != 0;
    }
    get valueType() {
        return ValueType.Int;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Float) {
            return new FloatValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.IntValue = IntValue;
class FloatValue extends Value {
    constructor(val) {
        super(val || 0.0);
    }
    get isTruthy() {
        return this.value != 0.0;
    }
    get valueType() {
        return ValueType.Float;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            return new IntValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.FloatValue = FloatValue;
class StringValue extends Value {
    constructor(val) {
        super(val || "");
        this._isNewline = this.value == "\n";
        this._isInlineWhitespace = true;
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (this.value.length > 0) {
            this.value.split("").every((c) => {
                if (c != " " && c != "\t") {
                    this._isInlineWhitespace = false;
                    return false;
                }
                return true;
            });
        }
    }
    get valueType() {
        return ValueType.String;
    }
    get isTruthy() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.length > 0;
    }
    get isNewline() {
        return this._isNewline;
    }
    get isInlineWhitespace() {
        return this._isInlineWhitespace;
    }
    get isNonWhitespace() {
        return !this.isNewline && !this.isInlineWhitespace;
    }
    Cast(newType) {
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            let parsedInt = TryGetResult_1.tryParseInt(this.value);
            if (parsedInt.exists) {
                return new IntValue(parsedInt.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        if (newType == ValueType.Float) {
            let parsedFloat = TryGetResult_1.tryParseFloat(this.value);
            if (parsedFloat.exists) {
                return new FloatValue(parsedFloat.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        throw this.BadCastException(newType);
    }
}
exports.StringValue = StringValue;
class DivertTargetValue extends Value {
    constructor(targetPath) {
        super(targetPath);
    }
    get valueType() {
        return ValueType.DivertTarget;
    }
    get targetPath() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set targetPath(value) {
        this.value = value;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a divert target");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "DivertTargetValue(" + this.targetPath + ")";
    }
}
exports.DivertTargetValue = DivertTargetValue;
class VariablePointerValue extends Value {
    constructor(variableName, contextIndex = -1) {
        super(variableName);
        this._contextIndex = contextIndex;
    }
    get contextIndex() {
        return this._contextIndex;
    }
    set contextIndex(value) {
        this._contextIndex = value;
    }
    get variableName() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set variableName(value) {
        this.value = value;
    }
    get valueType() {
        return ValueType.VariablePointer;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a variable pointer");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "VariablePointerValue(" + this.variableName + ")";
    }
    Copy() {
        return new VariablePointerValue(this.variableName, this.contextIndex);
    }
}
exports.VariablePointerValue = VariablePointerValue;
class ListValue extends Value {
    get isTruthy() {
        if (this.value === null) {
            return NullException_1.throwNullException("this.value");
        }
        return this.value.Count > 0;
    }
    get valueType() {
        return ValueType.List;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == ValueType.Int) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new IntValue(0);
            else
                return new IntValue(max.Value);
        }
        else if (newType == ValueType.Float) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new FloatValue(0.0);
            else
                return new FloatValue(max.Value);
        }
        else if (newType == ValueType.String) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new StringValue("");
            else {
                return new StringValue(max.Key.toString());
            }
        }
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    constructor(listOrSingleItem, singleValue) {
        super(null);
        if (!listOrSingleItem && !singleValue) {
            this.value = new InkList_1.InkList();
        }
        else if (listOrSingleItem instanceof InkList_1.InkList) {
            this.value = new InkList_1.InkList(listOrSingleItem);
        }
        else if (listOrSingleItem instanceof InkList_1.InkListItem &&
            typeof singleValue === "number") {
            this.value = new InkList_1.InkList({
                Key: listOrSingleItem,
                Value: singleValue,
            });
        }
    }
    static RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrNull(oldValue, ListValue);
        let newList = TypeAssertion_1.asOrNull(newValue, ListValue);
        if (newList && newList.value === null)
            return NullException_1.throwNullException("newList.value");
        if (oldList && oldList.value === null)
            return NullException_1.throwNullException("oldList.value");
        // When assigning the empty list, try to retain any initial origin names
        if (oldList && newList && newList.value.Count == 0)
            newList.value.SetInitialOriginNames(oldList.value.originNames);
    }
}
exports.ListValue = ListValue;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 0] = "Int";
    ValueType[ValueType["Float"] = 1] = "Float";
    ValueType[ValueType["List"] = 2] = "List";
    ValueType[ValueType["String"] = 3] = "String";
    ValueType[ValueType["DivertTarget"] = 4] = "DivertTarget";
    ValueType[ValueType["VariablePointer"] = 5] = "VariablePointer";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=Value.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableAssignment.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableAssignment.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableAssignment = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class VariableAssignment extends Object_1.InkObject {
    constructor(variableName, isNewDeclaration) {
        super();
        this.variableName = variableName || null;
        this.isNewDeclaration = !!isNewDeclaration;
        this.isGlobal = false;
    }
    toString() {
        return "VarAssign to " + this.variableName;
    }
}
exports.VariableAssignment = VariableAssignment;
//# sourceMappingURL=VariableAssignment.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableReference.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableReference.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReference = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class VariableReference extends Object_1.InkObject {
    constructor(name = null) {
        super();
        this.pathForCount = null;
        this.name = name;
    }
    get containerForCount() {
        if (this.pathForCount === null)
            return null;
        return this.ResolvePath(this.pathForCount).container;
    }
    get pathStringForCount() {
        if (this.pathForCount === null)
            return null;
        return this.CompactPathString(this.pathForCount);
    }
    set pathStringForCount(value) {
        if (value === null)
            this.pathForCount = null;
        else
            this.pathForCount = new Path_1.Path(value);
    }
    toString() {
        if (this.name != null) {
            return "var(" + this.name + ")";
        }
        else {
            let pathStr = this.pathStringForCount;
            return "read_count(" + pathStr + ")";
        }
    }
}
exports.VariableReference = VariableReference;
//# sourceMappingURL=VariableReference.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariablesState.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/VariablesState.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesState = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class VariablesState {
    constructor(callStack, listDefsOrigin) {
        // The way variableChangedEvent is a bit different than the reference implementation.
        // Originally it uses the C# += operator to add delegates, but in js we need to maintain
        // an actual collection of delegates (ie. callbacks) to register a new one, there is a
        // special ObserveVariableChange method below.
        this.variableChangedEventCallbacks = [];
        this.patch = null;
        this._batchObservingVariableChanges = false;
        this._defaultGlobalVariables = new Map();
        this._changedVariablesForBatchObs = new Set();
        this._globalVariables = new Map();
        this._callStack = callStack;
        this._listDefsOrigin = listDefsOrigin;
        // if es6 proxies are available, use them.
        try {
            // the proxy is used to allow direct manipulation of global variables.
            // It first tries to access the objects own property, and if none is
            // found it delegates the call to the $ method, defined below
            let p = new Proxy(this, {
                get(target, name) {
                    return name in target ? target[name] : target.$(name);
                },
                set(target, name, value) {
                    if (name in target)
                        target[name] = value;
                    else
                        target.$(name, value);
                    return true; // returning a falsy value make the trap fail
                },
            });
            return p;
        }
        catch (e) {
            // thr proxy object is not available in this context. we should warn the
            // dev but writting to the console feels a bit intrusive.
            // console.log("ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.");
        }
    }
    variableChangedEvent(variableName, newValue) {
        for (let callback of this.variableChangedEventCallbacks) {
            callback(variableName, newValue);
        }
    }
    get batchObservingVariableChanges() {
        return this._batchObservingVariableChanges;
    }
    set batchObservingVariableChanges(value) {
        this._batchObservingVariableChanges = value;
        if (value) {
            this._changedVariablesForBatchObs = new Set();
        }
        else {
            if (this._changedVariablesForBatchObs != null) {
                for (let variableName of this._changedVariablesForBatchObs) {
                    let currentValue = this._globalVariables.get(variableName);
                    if (!currentValue) {
                        NullException_1.throwNullException("currentValue");
                    }
                    else {
                        this.variableChangedEvent(variableName, currentValue);
                    }
                }
                this._changedVariablesForBatchObs = null;
            }
        }
    }
    get callStack() {
        return this._callStack;
    }
    set callStack(callStack) {
        this._callStack = callStack;
    }
    // the original code uses a magic getter and setter for global variables,
    // allowing things like variableState['varname]. This is not quite possible
    // in js without a Proxy, so it is replaced with this $ function.
    $(variableName, value) {
        if (typeof value === "undefined") {
            let varContents = null;
            if (this.patch !== null) {
                varContents = this.patch.TryGetGlobal(variableName, null);
                if (varContents.exists)
                    return varContents.result.valueObject;
            }
            varContents = this._globalVariables.get(variableName);
            if (typeof varContents === "undefined") {
                varContents = this._defaultGlobalVariables.get(variableName);
            }
            if (typeof varContents !== "undefined")
                return varContents.valueObject;
            else
                return null;
        }
        else {
            if (typeof this._defaultGlobalVariables.get(variableName) === "undefined")
                throw new StoryException_1.StoryException("Cannot assign to a variable (" +
                    variableName +
                    ") that hasn't been declared in the story");
            let val = Value_1.Value.Create(value);
            if (val == null) {
                if (value == null) {
                    throw new StoryException_1.StoryException("Cannot pass null to VariableState");
                }
                else {
                    throw new StoryException_1.StoryException("Invalid value passed to VariableState: " + value.toString());
                }
            }
            this.SetGlobal(variableName, val);
        }
    }
    ApplyPatch() {
        if (this.patch === null) {
            return NullException_1.throwNullException("this.patch");
        }
        for (let [namedVarKey, namedVarValue] of this.patch.globals) {
            this._globalVariables.set(namedVarKey, namedVarValue);
        }
        if (this._changedVariablesForBatchObs !== null) {
            for (let name of this.patch.changedVariables) {
                this._changedVariablesForBatchObs.add(name);
            }
        }
        this.patch = null;
    }
    SetJsonToken(jToken) {
        this._globalVariables.clear();
        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {
            let loadedToken = jToken[varValKey];
            if (typeof loadedToken !== "undefined") {
                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);
                if (tokenInkObject === null) {
                    return NullException_1.throwNullException("tokenInkObject");
                }
                this._globalVariables.set(varValKey, tokenInkObject);
            }
            else {
                this._globalVariables.set(varValKey, varValValue);
            }
        }
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        for (let [keyValKey, keyValValue] of this._globalVariables) {
            let name = keyValKey;
            let val = keyValValue;
            if (VariablesState.dontSaveDefaultValues) {
                if (this._defaultGlobalVariables.has(name)) {
                    let defaultVal = this._defaultGlobalVariables.get(name);
                    if (this.RuntimeObjectsEqual(val, defaultVal))
                        continue;
                }
            }
            writer.WritePropertyStart(name);
            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    RuntimeObjectsEqual(obj1, obj2) {
        if (obj1 === null) {
            return NullException_1.throwNullException("obj1");
        }
        if (obj2 === null) {
            return NullException_1.throwNullException("obj2");
        }
        if (obj1.constructor !== obj2.constructor)
            return false;
        let intVal = TypeAssertion_1.asOrNull(obj1, Value_1.IntValue);
        if (intVal !== null) {
            return intVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.IntValue).value;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj1, Value_1.FloatValue);
        if (floatVal !== null) {
            return floatVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.FloatValue).value;
        }
        let val1 = TypeAssertion_1.asOrNull(obj1, Value_1.Value);
        let val2 = TypeAssertion_1.asOrNull(obj2, Value_1.Value);
        if (val1 !== null && val2 !== null) {
            if (TypeAssertion_1.isEquatable(val1.valueObject) && TypeAssertion_1.isEquatable(val2.valueObject)) {
                return val1.valueObject.Equals(val2.valueObject);
            }
            else {
                return val1.valueObject === val2.valueObject;
            }
        }
        throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: " +
            obj1.constructor.name);
    }
    GetVariableWithName(name, contextIndex = -1) {
        let varValue = this.GetRawVariableWithName(name, contextIndex);
        // var varPointer = varValue as VariablePointerValue;
        let varPointer = TypeAssertion_1.asOrNull(varValue, Value_1.VariablePointerValue);
        if (varPointer !== null) {
            varValue = this.ValueAtVariablePointer(varPointer);
        }
        return varValue;
    }
    TryGetDefaultVariableValue(name) {
        let val = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
        return val.exists ? val.result : null;
    }
    GlobalVariableExistsWithName(name) {
        return (this._globalVariables.has(name) ||
            (this._defaultGlobalVariables !== null &&
                this._defaultGlobalVariables.has(name)));
    }
    GetRawVariableWithName(name, contextIndex) {
        let varValue = null;
        if (contextIndex == 0 || contextIndex == -1) {
            let variableValue = null;
            if (this.patch !== null) {
                variableValue = this.patch.TryGetGlobal(name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            // this is a conditional assignment
            variableValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, name, null);
            if (variableValue.exists)
                return variableValue.result;
            if (this._defaultGlobalVariables !== null) {
                variableValue = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            if (this._listDefsOrigin === null)
                return NullException_1.throwNullException("VariablesState._listDefsOrigin");
            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);
            if (listItemValue)
                return listItemValue;
        }
        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);
        return varValue;
    }
    ValueAtVariablePointer(pointer) {
        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);
    }
    Assign(varAss, value) {
        let name = varAss.variableName;
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let contextIndex = -1;
        let setGlobal = false;
        if (varAss.isNewDeclaration) {
            setGlobal = varAss.isGlobal;
        }
        else {
            setGlobal = this.GlobalVariableExistsWithName(name);
        }
        if (varAss.isNewDeclaration) {
            // var varPointer = value as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(value, Value_1.VariablePointerValue);
            if (varPointer !== null) {
                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);
                value = fullyResolvedVariablePointer;
            }
        }
        else {
            let existingPointer = null;
            do {
                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;
                existingPointer = TypeAssertion_1.asOrNull(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);
                if (existingPointer != null) {
                    name = existingPointer.variableName;
                    contextIndex = existingPointer.contextIndex;
                    setGlobal = contextIndex == 0;
                }
            } while (existingPointer != null);
        }
        if (setGlobal) {
            this.SetGlobal(name, value);
        }
        else {
            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);
        }
    }
    SnapshotDefaultGlobals() {
        this._defaultGlobalVariables = new Map(this._globalVariables);
    }
    RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrThrows(oldValue, Value_1.ListValue);
        let newList = TypeAssertion_1.asOrThrows(newValue, Value_1.ListValue);
        if (oldList.value && newList.value && newList.value.Count == 0) {
            newList.value.SetInitialOriginNames(oldList.value.originNames);
        }
    }
    SetGlobal(variableName, value) {
        let oldValue = null;
        if (this.patch === null) {
            oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
        }
        if (this.patch !== null) {
            oldValue = this.patch.TryGetGlobal(variableName, null);
            if (!oldValue.exists) {
                oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
            }
        }
        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        if (variableName === null) {
            return NullException_1.throwNullException("variableName");
        }
        if (this.patch !== null) {
            this.patch.SetGlobal(variableName, value);
        }
        else {
            this._globalVariables.set(variableName, value);
        }
        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)
        if (this.variableChangedEvent !== null &&
            oldValue !== null &&
            value !== oldValue.result) {
            if (this.batchObservingVariableChanges) {
                if (this._changedVariablesForBatchObs === null) {
                    return NullException_1.throwNullException("this._changedVariablesForBatchObs");
                }
                if (this.patch !== null) {
                    this.patch.AddChangedVariable(variableName);
                }
                else if (this._changedVariablesForBatchObs !== null) {
                    this._changedVariablesForBatchObs.add(variableName);
                }
            }
            else {
                this.variableChangedEvent(variableName, value);
            }
        }
    }
    ResolveVariablePointer(varPointer) {
        let contextIndex = varPointer.contextIndex;
        if (contextIndex == -1)
            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);
        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);
        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;
        let doubleRedirectionPointer = TypeAssertion_1.asOrNull(valueOfVariablePointedTo, Value_1.VariablePointerValue);
        if (doubleRedirectionPointer != null) {
            return doubleRedirectionPointer;
        }
        else {
            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);
        }
    }
    GetContextIndexOfVariableNamed(varName) {
        if (this.GlobalVariableExistsWithName(varName))
            return 0;
        return this._callStack.currentElementIndex;
    }
    /**
     * This function is specific to the js version of ink. It allows to register a
     * callback that will be called when a variable changes. The original code uses
     * `state.variableChangedEvent += callback` instead.
     *
     * @param {function} callback
     */
    ObserveVariableChange(callback) {
        this.variableChangedEventCallbacks.push(callback);
    }
}
exports.VariablesState = VariablesState;
VariablesState.dontSaveDefaultValues = true;
//# sourceMappingURL=VariablesState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Void.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Void.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Void extends Object_1.InkObject {
}
exports.Void = Void;
//# sourceMappingURL=Void.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/GameMain.ts":
/*!*************************!*\
  !*** ./src/GameMain.ts ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UnitTest_1 = __webpack_require__(/*! ./unittest/UnitTest */ "./src/unittest/UnitTest.ts");
const GameObjectPool_1 = __webpack_require__(/*! ./framework/common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
const UIManager_1 = __webpack_require__(/*! ./framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const ResManager_1 = __webpack_require__(/*! ./framework/common/ResManager */ "./src/framework/common/ResManager.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
const SceneDef_1 = __webpack_require__(/*! ./framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
const SceneManager_1 = __webpack_require__(/*! ./framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
const StoryManager_1 = __webpack_require__(/*! ./framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
class GameMain {
    constructor() {
        csharp_1.JsManager.Instance.JsOnApplicationQuit = () => this.onApplicationQuit();
        csharp_1.JsManager.Instance.JsOnDispose = () => this.onDispose();
    }
    async start() {
        try {
            console.log("Game start in JS....");
            //启动单例
            GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool);
            UIManager_1.UIManager.Instance(UIManager_1.UIManager);
            ResManager_1.ResManager.Instance(ResManager_1.ResManager);
            StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).initialize();
            //预加载excel数据
            //ExcelManager.Instance(ExcelManager);
            //do Unit Test
            UnitTest_1.UnitTest.doTest();
            //进入登录模块
            await SceneManager_1.SceneManager.Instance(SceneManager_1.SceneManager).loadScene(SceneDef_1.SceneDef.LoginScene);
            //JS启动完成，通知C#层
            csharp_1.GameLaunch.Instance.JsLuanchFinish();
        }
        catch (ex) {
            console.error(ex);
        }
    }
    onApplicationQuit() {
        GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).cleanup(true);
        console.log("Game onApplicationQuit in JS....");
    }
    onDispose() {
        console.log("Game onDispose in JS....");
    }
}
new GameMain().start();


/***/ }),

/***/ "./src/data/excel/SkillConfig.ts":
/*!***************************************!*\
  !*** ./src/data/excel/SkillConfig.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SkillConfigTB = exports.SkillConfigTR = void 0;
const Singleton_1 = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class SkillConfigTR {
    constructor(_id, _Name, _Description, _CoolTime, _CostSP, _AttackDistance, _AttackAngle, _AttackTargetTags, _ImpactType, _NextBattlerId, _AtkRatio, _DurationTime, _AtkInterval, _SkillPrefab, _AnimationName, _HitFxPrefab, _Level, _AttackType, _SelectorType) {
        this._id = _id;
        this._Name = _Name;
        this._Description = _Description;
        this._CoolTime = _CoolTime;
        this._CostSP = _CostSP;
        this._AttackDistance = _AttackDistance;
        this._AttackAngle = _AttackAngle;
        this._AttackTargetTags = _AttackTargetTags;
        this._ImpactType = _ImpactType;
        this._NextBattlerId = _NextBattlerId;
        this._AtkRatio = _AtkRatio;
        this._DurationTime = _DurationTime;
        this._AtkInterval = _AtkInterval;
        this._SkillPrefab = _SkillPrefab;
        this._AnimationName = _AnimationName;
        this._HitFxPrefab = _HitFxPrefab;
        this._Level = _Level;
        this._AttackType = _AttackType;
        this._SelectorType = _SelectorType;
    }
}
exports.SkillConfigTR = SkillConfigTR;
class SkillConfigTB extends Singleton_1.Singleton {
    constructor() {
        super();
        this.trs = new Map();
        this.trs.set(1001, new SkillConfigTR(1001, "降龙十八掌", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill1", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1002, new SkillConfigTR(1002, "暴雨梨花", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill2", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1003, new SkillConfigTR(1003, "排山倒海", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill3", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
        this.trs.set(1004, new SkillConfigTR(1004, "葵花点穴手", "带有强力攻击技能", 10, 178, 1, 30, ["Enemy"], ["CostSP", "Damage"], 0, 2, 2, 1, "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", "skill4", "Effect/Prefab/UI/ef_ui_TaskFinish.prefab", 1, 1, 1));
    }
}
exports.SkillConfigTB = SkillConfigTB;


/***/ }),

/***/ "./src/data/pb/Opcode.ts":
/*!*******************************!*\
  !*** ./src/data/pb/Opcode.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Opcode = exports.DecodeMsg = void 0;
const pb_1 = __webpack_require__(/*! ./gen/pb */ "./src/data/pb/gen/pb.js");
class DecodeMsg {
}
exports.DecodeMsg = DecodeMsg;
class Opcode {
    static decode(opcode, msg) {
        let msgObj = this.map[opcode]["decode"](msg);
        let decodeMsg = new DecodeMsg();
        decodeMsg.rpcId = msgObj.RpcId;
        decodeMsg.msgObj = msgObj;
        return decodeMsg;
    }
    static encode(opcode, msg) {
        let buf = this.map[opcode]["encode"](msg).finish();
        return buf;
    }
}
exports.Opcode = Opcode;
Opcode.MSG_C2R_Login = 1000;
Opcode.MSG_R2C_Login = 1001;
Opcode.MSG_C2G_LoginGate = 1002;
Opcode.MSG_G2C_LoginGate = 1003;
Opcode.MSG_C2GS_Test = 2001;
Opcode.MSG_GS2C_Test = 2002;
Opcode.map = {
    1000: { "decode": pb_1.nice_ts.C2R_Login.decode, "encode": pb_1.nice_ts.C2R_Login.encode },
    1001: { "decode": pb_1.nice_ts.R2C_Login.decode, "encode": pb_1.nice_ts.R2C_Login.encode },
    1002: { "decode": pb_1.nice_ts.C2G_LoginGate.decode, "encode": pb_1.nice_ts.C2G_LoginGate.encode },
    1003: { "decode": pb_1.nice_ts.G2C_LoginGate.decode, "encode": pb_1.nice_ts.G2C_LoginGate.encode },
    2001: { "decode": pb_1.nice_ts.C2GS_Test.decode, "encode": pb_1.nice_ts.C2GS_Test.encode },
    2002: { "decode": pb_1.nice_ts.GS2C_Test.decode, "encode": pb_1.nice_ts.GS2C_Test.encode }
};


/***/ }),

/***/ "./src/data/pb/gen/pb.js":
/*!*******************************!*\
  !*** ./src/data/pb/gen/pb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
$protobuf.util.Long = Long;
$protobuf.configure();


// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.nice_ts = (function() {

    /**
     * Namespace nice_ts.
     * @exports nice_ts
     * @namespace
     */
    var nice_ts = {};

    nice_ts.C2R_Login = (function() {

        /**
         * Properties of a C2R_Login.
         * @memberof nice_ts
         * @interface IC2R_Login
         * @property {string|null} [Account] C2R_Login Account
         * @property {string|null} [Password] C2R_Login Password
         */

        /**
         * Constructs a new C2R_Login.
         * @memberof nice_ts
         * @classdesc Represents a C2R_Login.
         * @implements IC2R_Login
         * @constructor
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         */
        function C2R_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2R_Login Account.
         * @member {string} Account
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Account = "";

        /**
         * C2R_Login Password.
         * @member {string} Password
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Password = "";

        /**
         * Creates a new C2R_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         * @returns {nice_ts.C2R_Login} C2R_Login instance
         */
        C2R_Login.create = function create(properties) {
            return new C2R_Login(properties);
        };

        /**
         * Encodes the specified C2R_Login message. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && Object.hasOwnProperty.call(message, "Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && Object.hasOwnProperty.call(message, "Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified C2R_Login message, length delimited. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2R_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2R_Login message.
         * @function verify
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2R_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        /**
         * Creates a C2R_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2R_Login} C2R_Login
         */
        C2R_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2R_Login)
                return object;
            var message = new $root.nice_ts.C2R_Login();
            if (object.Account != null)
                message.Account = String(object.Account);
            if (object.Password != null)
                message.Password = String(object.Password);
            return message;
        };

        /**
         * Creates a plain object from a C2R_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.C2R_Login} message C2R_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2R_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Account = "";
                object.Password = "";
            }
            if (message.Account != null && message.hasOwnProperty("Account"))
                object.Account = message.Account;
            if (message.Password != null && message.hasOwnProperty("Password"))
                object.Password = message.Password;
            return object;
        };

        /**
         * Converts this C2R_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.C2R_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2R_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2R_Login;
    })();

    nice_ts.R2C_Login = (function() {

        /**
         * Properties of a R2C_Login.
         * @memberof nice_ts
         * @interface IR2C_Login
         * @property {number|null} [Error] R2C_Login Error
         * @property {string|null} [Message] R2C_Login Message
         * @property {string|null} [Address] R2C_Login Address
         * @property {number|Long|null} [Key] R2C_Login Key
         * @property {number|Long|null} [GateId] R2C_Login GateId
         */

        /**
         * Constructs a new R2C_Login.
         * @memberof nice_ts
         * @classdesc Represents a R2C_Login.
         * @implements IR2C_Login
         * @constructor
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         */
        function R2C_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * R2C_Login Error.
         * @member {number} Error
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Error = 0;

        /**
         * R2C_Login Message.
         * @member {string} Message
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Message = "";

        /**
         * R2C_Login Address.
         * @member {string} Address
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Address = "";

        /**
         * R2C_Login Key.
         * @member {number|Long} Key
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * R2C_Login GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new R2C_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         * @returns {nice_ts.R2C_Login} R2C_Login instance
         */
        R2C_Login.create = function create(properties) {
            return new R2C_Login(properties);
        };

        /**
         * Encodes the specified R2C_Login message. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Address != null && Object.hasOwnProperty.call(message, "Address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Address);
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GateId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified R2C_Login message, length delimited. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.R2C_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.Address = reader.string();
                    break;
                case 2:
                    message.Key = reader.int64();
                    break;
                case 3:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a R2C_Login message.
         * @function verify
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        R2C_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.Address != null && message.hasOwnProperty("Address"))
                if (!$util.isString(message.Address))
                    return "Address: string expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a R2C_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.R2C_Login} R2C_Login
         */
        R2C_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.R2C_Login)
                return object;
            var message = new $root.nice_ts.R2C_Login();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.Address != null)
                message.Address = String(object.Address);
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a R2C_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.R2C_Login} message R2C_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        R2C_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.Address != null && message.hasOwnProperty("Address"))
                object.Address = message.Address;
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this R2C_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.R2C_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        R2C_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return R2C_Login;
    })();

    nice_ts.C2G_LoginGate = (function() {

        /**
         * Properties of a C2G_LoginGate.
         * @memberof nice_ts
         * @interface IC2G_LoginGate
         * @property {number|Long|null} [Key] C2G_LoginGate Key
         * @property {number|Long|null} [GateId] C2G_LoginGate GateId
         */

        /**
         * Constructs a new C2G_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a C2G_LoginGate.
         * @implements IC2G_LoginGate
         * @constructor
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         */
        function C2G_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2G_LoginGate Key.
         * @member {number|Long} Key
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2G_LoginGate GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2G_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate instance
         */
        C2G_LoginGate.create = function create(properties) {
            return new C2G_LoginGate(properties);
        };

        /**
         * Encodes the specified C2G_LoginGate message. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.GateId);
            return writer;
        };

        /**
         * Encodes the specified C2G_LoginGate message, length delimited. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2G_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Key = reader.int64();
                    break;
                case 2:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2G_LoginGate message.
         * @function verify
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2G_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2G_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         */
        C2G_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2G_LoginGate)
                return object;
            var message = new $root.nice_ts.C2G_LoginGate();
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2G_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.C2G_LoginGate} message C2G_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2G_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
            }
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            return object;
        };

        /**
         * Converts this C2G_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2G_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2G_LoginGate;
    })();

    nice_ts.G2C_LoginGate = (function() {

        /**
         * Properties of a G2C_LoginGate.
         * @memberof nice_ts
         * @interface IG2C_LoginGate
         * @property {number|null} [Error] G2C_LoginGate Error
         * @property {string|null} [Message] G2C_LoginGate Message
         * @property {number|Long|null} [PlayerId] G2C_LoginGate PlayerId
         */

        /**
         * Constructs a new G2C_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a G2C_LoginGate.
         * @implements IG2C_LoginGate
         * @constructor
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         */
        function G2C_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2C_LoginGate Error.
         * @member {number} Error
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Error = 0;

        /**
         * G2C_LoginGate Message.
         * @member {string} Message
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Message = "";

        /**
         * G2C_LoginGate PlayerId.
         * @member {number|Long} PlayerId
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.PlayerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new G2C_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate instance
         */
        G2C_LoginGate.create = function create(properties) {
            return new G2C_LoginGate(properties);
        };

        /**
         * Encodes the specified G2C_LoginGate message. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerId != null && Object.hasOwnProperty.call(message, "PlayerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PlayerId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified G2C_LoginGate message, length delimited. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.G2C_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.PlayerId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2C_LoginGate message.
         * @function verify
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2C_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (!$util.isInteger(message.PlayerId) && !(message.PlayerId && $util.isInteger(message.PlayerId.low) && $util.isInteger(message.PlayerId.high)))
                    return "PlayerId: integer|Long expected";
            return null;
        };

        /**
         * Creates a G2C_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         */
        G2C_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.G2C_LoginGate)
                return object;
            var message = new $root.nice_ts.G2C_LoginGate();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.PlayerId != null)
                if ($util.Long)
                    (message.PlayerId = $util.Long.fromValue(object.PlayerId)).unsigned = false;
                else if (typeof object.PlayerId === "string")
                    message.PlayerId = parseInt(object.PlayerId, 10);
                else if (typeof object.PlayerId === "number")
                    message.PlayerId = object.PlayerId;
                else if (typeof object.PlayerId === "object")
                    message.PlayerId = new $util.LongBits(object.PlayerId.low >>> 0, object.PlayerId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a G2C_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.G2C_LoginGate} message G2C_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        G2C_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.PlayerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PlayerId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (typeof message.PlayerId === "number")
                    object.PlayerId = options.longs === String ? String(message.PlayerId) : message.PlayerId;
                else
                    object.PlayerId = options.longs === String ? $util.Long.prototype.toString.call(message.PlayerId) : options.longs === Number ? new $util.LongBits(message.PlayerId.low >>> 0, message.PlayerId.high >>> 0).toNumber() : message.PlayerId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this G2C_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        G2C_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return G2C_LoginGate;
    })();

    nice_ts.C2GS_Test = (function() {

        /**
         * Properties of a C2GS_Test.
         * @memberof nice_ts
         * @interface IC2GS_Test
         * @property {number|null} [testID] C2GS_Test testID
         * @property {string|null} [testName] C2GS_Test testName
         */

        /**
         * Constructs a new C2GS_Test.
         * @memberof nice_ts
         * @classdesc Represents a C2GS_Test.
         * @implements IC2GS_Test
         * @constructor
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         */
        function C2GS_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2GS_Test testID.
         * @member {number} testID
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testID = 0;

        /**
         * C2GS_Test testName.
         * @member {string} testName
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testName = "";

        /**
         * Creates a new C2GS_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         * @returns {nice_ts.C2GS_Test} C2GS_Test instance
         */
        C2GS_Test.create = function create(properties) {
            return new C2GS_Test(properties);
        };

        /**
         * Encodes the specified C2GS_Test message. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testID != null && Object.hasOwnProperty.call(message, "testID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.testID);
            if (message.testName != null && Object.hasOwnProperty.call(message, "testName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testName);
            return writer;
        };

        /**
         * Encodes the specified C2GS_Test message, length delimited. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2GS_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.testID = reader.int32();
                    break;
                case 2:
                    message.testName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2GS_Test message.
         * @function verify
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2GS_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.testID != null && message.hasOwnProperty("testID"))
                if (!$util.isInteger(message.testID))
                    return "testID: integer expected";
            if (message.testName != null && message.hasOwnProperty("testName"))
                if (!$util.isString(message.testName))
                    return "testName: string expected";
            return null;
        };

        /**
         * Creates a C2GS_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         */
        C2GS_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2GS_Test)
                return object;
            var message = new $root.nice_ts.C2GS_Test();
            if (object.testID != null)
                message.testID = object.testID | 0;
            if (object.testName != null)
                message.testName = String(object.testName);
            return message;
        };

        /**
         * Creates a plain object from a C2GS_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.C2GS_Test} message C2GS_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2GS_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testID = 0;
                object.testName = "";
            }
            if (message.testID != null && message.hasOwnProperty("testID"))
                object.testID = message.testID;
            if (message.testName != null && message.hasOwnProperty("testName"))
                object.testName = message.testName;
            return object;
        };

        /**
         * Converts this C2GS_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.C2GS_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2GS_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2GS_Test;
    })();

    nice_ts.GS2C_Test = (function() {

        /**
         * Properties of a GS2C_Test.
         * @memberof nice_ts
         * @interface IGS2C_Test
         * @property {number|null} [Error] GS2C_Test Error
         * @property {string|null} [Message] GS2C_Test Message
         * @property {string|null} [testResponse] GS2C_Test testResponse
         */

        /**
         * Constructs a new GS2C_Test.
         * @memberof nice_ts
         * @classdesc Represents a GS2C_Test.
         * @implements IGS2C_Test
         * @constructor
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         */
        function GS2C_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GS2C_Test Error.
         * @member {number} Error
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Error = 0;

        /**
         * GS2C_Test Message.
         * @member {string} Message
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Message = "";

        /**
         * GS2C_Test testResponse.
         * @member {string} testResponse
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.testResponse = "";

        /**
         * Creates a new GS2C_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         * @returns {nice_ts.GS2C_Test} GS2C_Test instance
         */
        GS2C_Test.create = function create(properties) {
            return new GS2C_Test(properties);
        };

        /**
         * Encodes the specified GS2C_Test message. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testResponse != null && Object.hasOwnProperty.call(message, "testResponse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.testResponse);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified GS2C_Test message, length delimited. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.GS2C_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.testResponse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GS2C_Test message.
         * @function verify
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GS2C_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                if (!$util.isString(message.testResponse))
                    return "testResponse: string expected";
            return null;
        };

        /**
         * Creates a GS2C_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         */
        GS2C_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.GS2C_Test)
                return object;
            var message = new $root.nice_ts.GS2C_Test();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.testResponse != null)
                message.testResponse = String(object.testResponse);
            return message;
        };

        /**
         * Creates a plain object from a GS2C_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.GS2C_Test} message GS2C_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GS2C_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testResponse = "";
                object.Error = 0;
                object.Message = "";
            }
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                object.testResponse = message.testResponse;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this GS2C_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.GS2C_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GS2C_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GS2C_Test;
    })();

    return nice_ts;
})();

module.exports = $root;


/***/ }),

/***/ "./src/data/ui/common.ts":
/*!*******************************!*\
  !*** ./src/data/ui/common.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonUI = void 0;
class commonUI {
}
exports.commonUI = commonUI;
commonUI.PackageName = "common";
commonUI.PackageBytes = "common_fui.bytes";
commonUI.UILoadingPage = "LoadingPage";
commonUI.UIUINoticeWin = "UINoticeWin";


/***/ }),

/***/ "./src/data/ui/home.ts":
/*!*****************************!*\
  !*** ./src/data/ui/home.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.homeUI = void 0;
class homeUI {
}
exports.homeUI = homeUI;
homeUI.PackageName = "home";
homeUI.PackageBytes = "home_fui.bytes";
homeUI.UIHomePage = "HomePage";
homeUI.UILevelPage = "LevelPage";
homeUI.UIShopPage = "ShopPage";


/***/ }),

/***/ "./src/data/ui/login.ts":
/*!******************************!*\
  !*** ./src/data/ui/login.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.loginUI = void 0;
class loginUI {
}
exports.loginUI = loginUI;
loginUI.PackageName = "login";
loginUI.PackageBytes = "login_fui.bytes";
loginUI.UILoginPage = "LoginPage";
loginUI.UISelServerWin = "SelServerWin";
loginUI.UIAreaItem = "AreaItem";


/***/ }),

/***/ "./src/data/ui/story.ts":
/*!******************************!*\
  !*** ./src/data/ui/story.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.storyUI = void 0;
class storyUI {
}
exports.storyUI = storyUI;
storyUI.PackageName = "story";
storyUI.PackageBytes = "story_fui.bytes";
storyUI.UIStoryWin = "StoryWin";


/***/ }),

/***/ "./src/framework/common/GameObjectPool.ts":
/*!************************************************!*\
  !*** ./src/framework/common/GameObjectPool.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameObjectPool = void 0;
const Singleton_1 = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
const ResManager_1 = __webpack_require__(/*! ./ResManager */ "./src/framework/common/ResManager.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
// -- GameObject缓存池
// -- 注意：
// -- 1、所有需要预设都从这里加载，不要直接到ResourcesManager去加载，由这里统一做缓存管理
// -- 2、缓存分为两部分：从资源层加载的原始GameObject(Asset)，从GameObject实例化出来的多个Inst
class GameObjectPool extends Singleton_1.Singleton {
    constructor() {
        super();
        this.__cacheTransRoot = null;
        this.__goPool = new Map();
        this.__instCache = new Map();
        let go = csharp_1.UnityEngine.GameObject.Find("GameObjectCacheRoot");
        if (go == undefined) {
            go = new csharp_1.UnityEngine.GameObject("GameObjectCacheRoot");
            csharp_1.UnityEngine.Object.DontDestroyOnLoad(go);
        }
        this.__cacheTransRoot = go.transform;
    }
    //-- 检测是否已经被缓存
    checkHasCached(path) {
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            return true;
        }
        let pooledGo = this.__goPool.get(path);
        return pooledGo != undefined;
    }
    //-- 缓存并实例化GameObject
    cacheAndInstGameObject(path, go, inst_count = 1) {
        this.__goPool.set(path, go);
        if (inst_count > 0) {
            let cachedInst = this.__instCache.get(path);
            for (let i = 0; i < inst_count; i++) {
                let inst = csharp_1.UnityEngine.GameObject.Instantiate(go);
                inst.transform.SetParent(this.__cacheTransRoot);
                inst.SetActive(false);
                cachedInst.push(inst);
            }
        }
    }
    //-- 尝试从缓存中获取
    tryGetFromCache(path) {
        if (!this.checkHasCached(path)) {
            return null;
        }
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            let inst = cachedInst.pop();
            return inst;
        }
        let pooledGo = this.__goPool.get(path);
        if (pooledGo != undefined) {
            let inst = csharp_1.UnityEngine.GameObject.Instantiate(pooledGo);
            return inst;
        }
        return null;
    }
    //预加载：可提供初始实例化个数
    async preLoadGameObjectAsync(path, inst_count, callback, ...params) {
        if (this.checkHasCached(path)) {
            if (callback != null) {
                callback(params);
            }
            return;
        }
        let go = await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadPrefab(path);
        if (go != undefined) {
            this.cacheAndInstGameObject(path, go, inst_count);
        }
        if (callback != null) {
            callback(params);
        }
    }
    //-- 异步获取：必要时加载
    async getGameObjectAsync(path, callback, ...params) {
        let inst = this.tryGetFromCache(path);
        if (inst == null) {
            await this.preLoadGameObjectAsync(path, 1, callback, params);
        }
        inst = this.tryGetFromCache(path);
        inst.SetActive(true);
    }
    //-- 回收
    recycleGameObject(path, inst) {
        inst.transform.SetParent(this.__cacheTransRoot);
        inst.SetActive(false);
        let cachedInst = this.__instCache.get(path) || new Array();
        cachedInst.push(inst);
        this.__instCache.set(path, cachedInst);
    }
    //-- 清理缓存
    cleanup(includePooledGo = false) {
        this.__instCache.forEach((values, key) => {
            for (let inst of values) {
                if (inst != null) {
                    csharp_1.UnityEngine.GameObject.Destroy(inst);
                }
            }
        });
        this.__instCache.clear();
        if (includePooledGo) {
            this.__goPool.forEach((go, key) => {
                if (go != null) {
                    ResManager_1.ResManager.Instance(ResManager_1.ResManager).releaseAddressGO(go);
                }
            });
            this.__goPool.clear();
        }
    }
}
exports.GameObjectPool = GameObjectPool;


/***/ }),

/***/ "./src/framework/common/Messenger.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Messenger.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Messenger = exports.MesObj = void 0;
class MesObj {
}
exports.MesObj = MesObj;
class Messenger {
    constructor() {
        this.listenerMap = new Map();
    }
    addListener(e_type, e_obj, e_listner) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) == "undefined") {
            msgObj = new MesObj();
            msgObj.obj = e_obj;
            msgObj.listeners = new Array();
        }
        msgObj.listeners.push(e_listner);
        this.listenerMap.set(e_type, msgObj);
    }
    getListener(e_type) {
        return this.listenerMap.get(e_type);
    }
    broadcast(e_type, ...params) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let l of msgObj.listeners) {
                l.apply(msgObj.obj, params);
            }
        }
    }
    removeListenerByType(e_type) {
        this.listenerMap.delete(e_type);
    }
    removeListener(e_type, e_listener) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let i = 0; i < msgObj.listeners.length; i++) {
                if (msgObj.listeners[i] == e_listener) {
                    msgObj.listeners.splice(i, 1);
                }
            }
        }
    }
    clearup() {
        this.listenerMap.clear();
    }
}
exports.Messenger = Messenger;


/***/ }),

/***/ "./src/framework/common/NiceDecorator.ts":
/*!***********************************************!*\
  !*** ./src/framework/common/NiceDecorator.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.binder = void 0;
// FairyGUI 元件 绑定器
function binder(name) {
    return function (target, key) {
        target["binders"] = target["binders"] || {};
        target["binders"][key] = name;
    };
}
exports.binder = binder;


/***/ }),

/***/ "./src/framework/common/ResManager.ts":
/*!********************************************!*\
  !*** ./src/framework/common/ResManager.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ResManager = void 0;
const Singleton_1 = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
const puerts_1 = __webpack_require__(/*! puerts */ "puerts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class ResManager extends Singleton_1.Singleton {
    constructor() {
        super();
    }
    async loadScene(sceneName) {
        try {
            let single = csharp_1.UnityEngine.SceneManagement.LoadSceneMode.Single;
            let task = csharp_1.NiceTS.ResourceManager.LoadScene(sceneName, single, (progress) => {
                console.log("load scene: " + progress);
            });
            let scenInstance = await puerts_1.$promise(task);
            return scenInstance;
        }
        catch (ex) {
            console.error(`Load Scene :${sceneName} : ${ex}`);
            return null;
        }
    }
    async unloadScene(sceneInstance) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.UnloadScene(sceneInstance);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Unload scene  : ${ex}`);
            return null;
        }
    }
    async loadPrefab(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadPrefab(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load prefab :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextAsset(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadTextAsset(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load textasset :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextBytes(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadTextBytes(address);
            let bytes = await puerts_1.$promise(task);
            return bytes;
        }
        catch (ex) {
            console.error(`LoadTextBytes :${address} : ${ex}`);
        }
    }
    async loadSprite(address) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadSprite(address);
            let go = await puerts_1.$promise(task);
            return go;
        }
        catch (ex) {
            console.error(`Load sprite :${address} : ${ex}`);
            return null;
        }
    }
    async loadFairyGUIPackage(address, packageName, callback) {
        try {
            let task = csharp_1.NiceTS.ResourceManager.LoadFairyGUIPackage(address, packageName);
            await puerts_1.$promise(task);
            if (callback)
                callback();
        }
        catch (ex) {
            console.error(`Load fairyGUI :${address} : ${ex}`);
        }
    }
    releaseAddressGO(go) {
        csharp_1.NiceTS.ResourceManager.ReleaseAddressGO(go);
    }
    releaseFairyGUIPackage(packageName) {
        csharp_1.NiceTS.ResourceManager.ReleaseFGUIPackage(packageName);
    }
}
exports.ResManager = ResManager;


/***/ }),

/***/ "./src/framework/common/Singleton.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Singleton.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Singleton = void 0;
class Singleton {
    static Instance(c) {
        if (this.instance == null) {
            this.instance = new c();
        }
        return this.instance;
    }
}
exports.Singleton = Singleton;
Singleton.instance = null;


/***/ }),

/***/ "./src/framework/ink/InkStateInspector.ts":
/*!************************************************!*\
  !*** ./src/framework/ink/InkStateInspector.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkStateInspector = void 0;
class InkStateInspector {
    BindInkMethods(inkStory) {
        //3参数以下采用此方式
        this.bindInkMethodOnce(inkStory, "GetCharacterName", this.getCharacterName);
        //3参数以上采用此方式 
        this.bindInkMethodOnceGeneral(inkStory, "GetCharacterNameByMutiParams", this.getCharacterNameMutiParams);
    }
    getCharacterName() {
        return "Justin Test Puerts";
    }
    getCharacterNameMutiParams(p1, p2, p3) {
        return "Justin Muti Params";
    }
    bindInkMethodOnce(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunction(funcName, func);
        }
        catch (err) {
            console.warn(err);
        }
    }
    bindInkMethodOnceGeneral(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunctionGeneral(funcName, func);
        }
        catch (err) {
            console.warn(err);
        }
    }
    unbindInkMethod(inkStory, funcName) {
        try {
            inkStory.UnbindExternalFunction(funcName);
        }
        catch (err) {
            console.warn(err);
        }
    }
}
exports.InkStateInspector = InkStateInspector;


/***/ }),

/***/ "./src/framework/ink/InkWriter.ts":
/*!****************************************!*\
  !*** ./src/framework/ink/InkWriter.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkWriter = void 0;
const Story_1 = __webpack_require__(/*! inkjs/engine/Story */ "./node_modules/inkjs/engine/Story.js");
const InkStateInspector_1 = __webpack_require__(/*! ./InkStateInspector */ "./src/framework/ink/InkStateInspector.ts");
const StoryMessageManager_1 = __webpack_require__(/*! ./StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
class InkWriter {
    constructor(storyJson) {
        this._allInkCommands = new Map();
        this.setupInkCommands();
        this.createStroy(storyJson);
        this.load();
    }
    load() {
        let storyState = "";
        if (storyState != null && storyState != "") {
            this._currentStory.state.LoadJson(storyState);
        }
    }
    createStroy(json) {
        this._currentStory = new Story_1.Story(json);
    }
    beginStory(knotName) {
        if (this._currentStory == null) {
            console.warn("Trying to AdvanceStory in InkWriter when no story has been created");
            return;
        }
        this._currentStory.ChoosePathString(knotName, true);
        let inkState = new InkStateInspector_1.InkStateInspector();
        inkState.BindInkMethods(this._currentStory);
        this.advanceStory();
    }
    giveReward() {
        console.log("give reward...");
        return true;
    }
    setupInkCommands() {
        this._allInkCommands.set("GIVE_REWARD", this.giveReward);
    }
    handleCommand(command, args) {
        if (this._allInkCommands.has(command)) {
            return this._allInkCommands.get(command)(args);
        }
        console.error("Could not find InkCommand with name:" + command);
        return true;
    }
    parseCommandName(text) {
        let num = text.indexOf(InkWriter.COMMAND_PREFIX);
        let num2 = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num2 == -1) {
            num2 = text.length;
        }
        let length = num2 - (num + InkWriter.COMMAND_PREFIX.length);
        return text.substr(num + InkWriter.COMMAND_PREFIX.length, length).trim();
    }
    parseCommandArgs(text) {
        let num = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num == -1) {
            return [];
        }
        let length = text.length - (num + 1);
        let list = text.substr(num + 1, length).
            trim().
            split(InkWriter.COMMAND_ARG_DELIMITER);
        for (let i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
        }
        return list;
    }
    extractSpeaker(line) {
        if (line.startsWith(InkWriter.COMMAND_PREFIX)) {
            return ["0", line.trim()];
        }
        let array = line.split(':', 2);
        if (array.length > 1) {
            let speakID = array[0].trim();
            let speakContent = array[1].trim();
            return [speakID, speakContent];
        }
        return ["0", line.trim()];
    }
    saveCurrentStory() {
        let currState = this._currentStory.state.toJson();
        //TODOｓａｖｅ
    }
    canContinue() {
        return this._currentStory.canContinue;
    }
    advanceStory() {
        if (this._currentStory == null) {
            console.warn("Trying to AdvanceStory in InkWriter when no story has been created");
        }
        else if (this._currentStory.canContinue) {
            let text = this._currentStory.Continue().trim();
            if (text == "") {
                this.advanceStory();
                return;
            }
            let speakID;
            let speakContent;
            [speakID, speakContent] = this.extractSpeaker(text);
            let commandName = null;
            let args = null;
            if (speakContent.startsWith(InkWriter.COMMAND_PREFIX)) {
                commandName = this.parseCommandName(speakContent);
                args = this.parseCommandArgs(speakContent);
                if (commandName != null && commandName != "") {
                    if (this.handleCommand(commandName, args)) {
                        this.advanceStory();
                    }
                }
            }
            else {
                //OnContentReady
                StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastContentReady(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, speakContent, speakID, this._currentStory.currentTags, this._currentStory.currentChoices);
            }
        }
        else if (this._currentStory.currentChoices.length > 0) {
            //OnChoicesPresented
            StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastChoicesPresented(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this._currentStory.currentChoices);
        }
        else {
            //OnStoryFinished
            StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).broadcastStoryFinished(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED);
        }
    }
    selectChoice(choiceIndex) {
        if (this._currentStory == null) {
            console.warn("Trying to ChooseChoice in InkWriter when no story has begun");
            return;
        }
        this._currentStory.ChooseChoiceIndex(choiceIndex);
        this.advanceStory();
    }
    getVariable(variableName) {
        return this._currentStory.variablesState.GetVariableWithName(variableName);
    }
    setVariable(variableName, value) {
        this._currentStory.variablesState.$(variableName, value);
    }
}
exports.InkWriter = InkWriter;
InkWriter.DEBUG_STORY_ID = "DEBUG_STORY";
InkWriter.COMMAND_PREFIX = ">>>";
InkWriter.COMMAND_DELIMITER = ":";
InkWriter.COMMAND_ARG_DELIMITER = ',';


/***/ }),

/***/ "./src/framework/ink/StoryManager.ts":
/*!*******************************************!*\
  !*** ./src/framework/ink/StoryManager.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryManager = void 0;
const ResManager_1 = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const InkWriter_1 = __webpack_require__(/*! ./InkWriter */ "./src/framework/ink/InkWriter.ts");
class StoryManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.storyAddress = "Story/TestStory.json";
    }
    get inkWriter() {
        return this._inkWriter;
    }
    async initialize() {
        if (this._inkWriter == null) {
            var json = (await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadTextAsset(this.storyAddress)).text;
            this._inkWriter = new InkWriter_1.InkWriter(json);
        }
    }
    beginStory(knotName) {
        this._inkWriter.beginStory(knotName);
    }
    canContinue() {
        return this._inkWriter.canContinue;
    }
    advanceStory() {
        this._inkWriter.advanceStory();
    }
    selectChoice(choice) {
        this._inkWriter.selectChoice(choice.index);
    }
    loadCurrent() {
        if (this._inkWriter != null)
            this._inkWriter.load();
    }
    getVariable(variableName) {
        return this._inkWriter.getVariable(variableName);
    }
    setVariable(variableName, value) {
        this.inkWriter.setVariable(variableName, value);
    }
}
exports.StoryManager = StoryManager;


/***/ }),

/***/ "./src/framework/ink/StoryMessageManager.ts":
/*!**************************************************!*\
  !*** ./src/framework/ink/StoryMessageManager.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryMessageManager = void 0;
const Messenger_1 = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
class StoryMessageManager extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.storyMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.storyMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.storyMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.storyMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.storyMessage.clearup();
    }
    broadcastContentReady(msgCode, speakerContent, speakerId, currentTags, currentChoices) {
        this.storyMessage.broadcast(msgCode, speakerContent, speakerId, currentTags, currentChoices);
    }
    broadcastChoicesPresented(mesgCode, currentChoices) {
        this.storyMessage.broadcast(mesgCode, currentChoices);
    }
    broadcastStoryFinished(mesgCode) {
        this.storyMessage.broadcast(mesgCode);
    }
}
exports.StoryMessageManager = StoryMessageManager;
StoryMessageManager.ONCONTENTREADY = 1001;
StoryMessageManager.ONCHOICESPRESENTED = 1002;
StoryMessageManager.ONSTORYFINISHED = 1003;


/***/ }),

/***/ "./src/framework/net/GameSession.ts":
/*!******************************************!*\
  !*** ./src/framework/net/GameSession.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameSession = exports.MsgPack = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const Opcode_1 = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
const NetErrorCode_1 = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
const MessageParser_1 = __webpack_require__(/*! ./MessageParser */ "./src/framework/net/MessageParser.ts");
class MsgPack {
    constructor() {
        this.retryTimes = 0;
    }
}
exports.MsgPack = MsgPack;
class GameSession extends Singleton_1.Singleton {
    constructor() {
        super();
        this.id = 0; //session ID
        this.reSendInterval = 10000; //10秒重发一次
        this.timeoutInterval = 5000; //5秒检查一次是否超时
        this.maxReSendTimes = 5; //最大重发次数
        this._rpcId = 1;
        this.requestCallback = new Map();
        this.listeners = new Map();
        //返回的服务器ID, 类型
        this._serverId = -1;
        this._serverType = 1;
    }
    get rpcId() {
        return ++this._rpcId;
    }
    //address-> ip:port
    connectChannel(address, connCaback) {
        this.channel = csharp_1.NiceTS.TService.Instance.GetChannel();
        this.channel.errorCallback = (channel, code) => {
            if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
                this.timeoutIimer = setInterval(() => {
                    this.checkTimeoutMsg();
                }, this.timeoutInterval);
            }
            connCaback(channel, code);
        };
        this.channel.readCallback = (buffer) => {
            this.onReceive(buffer);
        };
        this.channel.Connect(address);
        return this;
    }
    //接收服务器通知
    listen(opcode, callback) {
        this.listeners.set(opcode, callback);
    }
    //发送protoubf消息
    //消息： rpc_id[4] - opcode[2] - server_id[2] - server_type[1] - 
    send(opcode, rpcid, message, callBack) {
        //封装消息：
        let rpcBuf = MessageParser_1.MessageParser.encodeInt(rpcid); //4
        let opcodeBuf = MessageParser_1.MessageParser.encodeShort(opcode); //2
        let serveridBuf = MessageParser_1.MessageParser.encodeShort(this._serverId); //2
        let servertypeBuf = MessageParser_1.MessageParser.encodeByte(this._serverType); //1
        let sendArray = new Uint8Array(4 + 2 + 2 + 1 + message.length);
        sendArray.set(rpcBuf);
        sendArray.set(opcodeBuf, 4);
        sendArray.set(serveridBuf, 4 + 2);
        sendArray.set(servertypeBuf, 4 + 2 + 2);
        sendArray.set(message, 4 + 2 + 2 + 1);
        if (callBack != null) {
            let msgPack = new MsgPack();
            msgPack.sendTime = new Date().getTime();
            msgPack.callback = callBack;
            msgPack.bytes = sendArray;
            this.requestCallback.set(rpcid, msgPack);
        }
        // for(let i in sendArray){
        //     console.log("TS -- send array: "+i);
        // }
        //Console.log("send array: "+sendArray);
        this.channel.Send(sendArray);
    }
    reSend(bytes) {
        this.channel.Send(bytes);
    }
    onReceive(buffer) {
        let msgBuf = new Uint8Array(buffer);
        let rpcid = MessageParser_1.MessageParser.decodeInt(msgBuf.subarray(0, 4));
        let opcode = MessageParser_1.MessageParser.decodeShort(msgBuf.subarray(4, 6));
        let serverid = MessageParser_1.MessageParser.decodeShort(msgBuf.subarray(6, 8));
        let servertype = MessageParser_1.MessageParser.decodeByte(msgBuf.subarray(8, 9));
        this._serverId = serverid;
        this._serverType = servertype;
        let msgBytes = msgBuf.subarray(9);
        try {
            let decodeMsg = Opcode_1.Opcode.decode(opcode, msgBytes);
            if (rpcid == undefined || !this.requestCallback.has(rpcid)) {
                //检查是否是服务器下发的消息
                if (this.listeners.has(opcode)) {
                    let listen = this.listeners.get(opcode);
                    listen(decodeMsg.msgObj);
                }
            }
            else {
                let msgPack = this.requestCallback.get(rpcid);
                msgPack.callback(decodeMsg.msgObj);
                this.requestCallback.delete(rpcid);
            }
        }
        catch (e) {
            console.error("parse msg error, opcode:" + opcode);
        }
    }
    checkTimeoutMsg() {
        let currTime = new Date().getTime();
        this.requestCallback.forEach((value, key) => {
            if (value.retryTimes >= this.maxReSendTimes) {
                //超过最大重发次数，丢弃
                console.log(`Message resend too more, opcode:${key}, lastsend:${value.sendTime}`);
                this.requestCallback.delete(key);
            }
            else {
                if ((currTime - value.sendTime) >= this.reSendInterval) {
                    value.retryTimes++;
                    value.sendTime = currTime;
                    //重发消息
                    this.reSend(value.bytes);
                    console.log(`resend message:, opcode:${key}, retry times:${value.retryTimes}`);
                }
            }
        });
    }
    disconnect() {
        clearInterval(this.timeoutIimer);
        this.channel.Dispose();
    }
}
exports.GameSession = GameSession;


/***/ }),

/***/ "./src/framework/net/MessageParser.ts":
/*!********************************************!*\
  !*** ./src/framework/net/MessageParser.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageParser = void 0;
class MessageParser {
    static encodeInt(n) {
        let buffer = new Uint8Array(4);
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        return buffer;
    }
    static decodeInt(buffer) {
        let n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        return n;
    }
    static encodeShort(n) {
        let buffer = new Uint8Array(2);
        buffer[0] = n >>> 8;
        buffer[1] = n & 0xff;
        return buffer;
    }
    static decodeShort(buffer) {
        let n = buffer[0] << 8 | buffer[1];
        return n;
    }
    static encodeByte(n) {
        let buffer = new Uint8Array(1);
        buffer[0] = n & 0xff;
        return buffer;
    }
    static decodeByte(buffer) {
        let n = buffer[0];
        return n;
    }
}
exports.MessageParser = MessageParser;


/***/ }),

/***/ "./src/framework/net/NetErrorCode.ts":
/*!*******************************************!*\
  !*** ./src/framework/net/NetErrorCode.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NetErrorCode = void 0;
class NetErrorCode {
}
exports.NetErrorCode = NetErrorCode;
NetErrorCode.ERR_SocketConnSucc = 100000;
NetErrorCode.ERR_ConnectGateKeyError = 100006;
NetErrorCode.ERR_PeerDisconnect = 102008;
NetErrorCode.ERR_SocketCantSend = 102009;
NetErrorCode.ERR_SocketError = 102010;
NetErrorCode.ERR_SocketConnError = 102011;


/***/ }),

/***/ "./src/framework/net/SessionManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/net/SessionManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionManager = void 0;
const Opcode_1 = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
const GameConfig_1 = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const GameSession_1 = __webpack_require__(/*! ./GameSession */ "./src/framework/net/GameSession.ts");
const NetErrorCode_1 = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
class SessionManager extends Singleton_1.Singleton {
    get realmRpcID() {
        return this.sessionReam.rpcId;
    }
    get gateRpcID() {
        return this.sessionGate.rpcId;
    }
    async connectRealmServer() {
        let promise = new Promise(resove => {
            this.sessionReam = GameSession_1.GameSession.Instance(GameSession_1.GameSession).connectChannel(GameConfig_1.GameConfig.realmServerIP + ":" + GameConfig_1.GameConfig.realmServerPort, (channel, code) => {
                if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
                    this.sessionReam.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    console.error("login reamserver err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectRealmServer() {
        this.sessionReam.disconnect();
        this.sessionReam = null;
    }
    async sendRealmMsg(opcode, msg) {
        let rpcID = this.sessionReam.rpcId;
        let promise = new Promise((resove) => {
            let buf = Opcode_1.Opcode.encode(opcode, msg);
            this.sessionReam.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
    async connectGateServer(address) {
        let promise = new Promise(resove => {
            this.sessionGate = GameSession_1.GameSession.Instance(GameSession_1.GameSession).connectChannel(address, (channel, code) => {
                console.log("login Gate Server: " + code);
                if (code == NetErrorCode_1.NetErrorCode.ERR_SocketConnSucc) {
                    this.sessionGate.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    console.error("gate server err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectGateServer() {
        this.sessionGate.disconnect();
        this.sessionGate = null;
    }
    async sendGateMsg(opcode, msg) {
        let rpcID = this.sessionGate.rpcId;
        let promise = new Promise((resove) => {
            let buf = Opcode_1.Opcode.encode(opcode, msg);
            this.sessionGate.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
}
exports.SessionManager = SessionManager;


/***/ }),

/***/ "./src/framework/redhints/RedHintsManager.ts":
/*!***************************************************!*\
  !*** ./src/framework/redhints/RedHintsManager.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RedHintsManager = exports.enumRedHints = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const RedHintsMessageManager_1 = __webpack_require__(/*! ./RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");
var enumRedHints;
(function (enumRedHints) {
    /** 标记位 */
    enumRedHints[enumRedHints["none"] = 0] = "none";
    /** 聊天 */
    enumRedHints[enumRedHints["chat"] = 1] = "chat";
    /** 聊天世界频道 */
    enumRedHints[enumRedHints["chat_world"] = 2] = "chat_world";
    /** 聊天公会频道 */
    enumRedHints[enumRedHints["chat_family"] = 3] = "chat_family";
    /** 聊天系统频道 */
    enumRedHints[enumRedHints["chat_system"] = 4] = "chat_system";
})(enumRedHints = exports.enumRedHints || (exports.enumRedHints = {}));
class RedHintsManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.init();
    }
    init() {
        this._data = [0]; //第一位无意义
        this._parentIndex = [0];
        this._childNum = [0];
        this._childIndex = [0];
        //------------------------记录父子关系-----------------------
        //聊天
        this.setParent(enumRedHints.chat_world, enumRedHints.chat);
        this.setParent(enumRedHints.chat_family, enumRedHints.chat);
        this.setParent(enumRedHints.chat_system, enumRedHints.chat);
    }
    /**
     * 设置红点的开启和关闭
    */
    setRedHintOpenOrClose(red, isOpen) {
        if (this._childNum[red] > 0) {
            console.log("红点数据设置错误：不能直接对高级的红点数据操作");
            return;
        }
        this.doSetRedHintOpenOrClose(red, isOpen ? 1 : 0);
    }
    /**
     * 记录父子关系：子---父
    */
    setParent(child, parent) {
        if (this._parentIndex[parent] == child) {
            console.log("关系反了");
            return;
        }
        if (this._parentIndex[child]) {
            console.log("重复设置");
            return;
        }
        this._parentIndex[child] = parent;
        if (isNaN(this._childNum[parent])) {
            this._childNum[parent] = 0;
        }
        this._childNum[parent]++; //子项数量增加
        this._childIndex[child] = this._childNum[parent]; //子项的索引 从1开始
    }
    doSetRedHintOpenOrClose(red, value) {
        if (this._data[red] != value) {
            this._data[red] = value;
            let _parent = this._parentIndex[red];
            if (_parent) {
                //如果有父级，更新父级
                let index = this._childIndex[red]; //获取在父级中的索引
                this.doSetRedHintOpenOrClose(_parent, value > 0 ? this._data[_parent] | this.addV(index) : this._data[_parent] & this.subV(index)); //设置父级的值
            }
            //发改变事件:全局事件
            //emit(RedHintsManager.RED_HINT_VALUE_CHANGED, red);
            //红点事件，局部事件
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).broadcast(red, value);
        }
    }
    addV(index) {
        return 1 << (index - 1);
    }
    subV(index) {
        return ~this.addV(index);
    }
    /**
     * 查看红点是否开启
    */
    checkRedIsOpen(red) {
        return this._data[red] > 0;
    }
}
exports.RedHintsManager = RedHintsManager;
/**
 * 红点值改变
*/
RedHintsManager.RED_HINT_VALUE_CHANGED = "RED_HINT_VALUE_CHANGED";


/***/ }),

/***/ "./src/framework/redhints/RedHintsMessageManager.ts":
/*!**********************************************************!*\
  !*** ./src/framework/redhints/RedHintsMessageManager.ts ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.RedHintsMessageManager = void 0;
const Messenger_1 = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
class RedHintsMessageManager extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.redhintsMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.redhintsMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.redhintsMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.redhintsMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.redhintsMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.redhintsMessage.broadcast(msgCode, params);
    }
}
exports.RedHintsMessageManager = RedHintsMessageManager;


/***/ }),

/***/ "./src/framework/scene/BaseScene.ts":
/*!******************************************!*\
  !*** ./src/framework/scene/BaseScene.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseScene = void 0;
const GameObjectPool_1 = __webpack_require__(/*! ../common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
const ResManager_1 = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
class BaseScene {
    constructor() {
        this.finishCount = 0;
        this.totalCount = 0;
        this.preloadFairyGUIPackage = new Map();
        this.preloadPrefab = new Map();
        this.finishCount = 0;
    }
    addPreloadFairyGUIPackage(address, packageName) {
        this.preloadFairyGUIPackage.set(address, packageName);
    }
    addPreloadPrefab(address, instCount) {
        this.preloadPrefab.set(address, instCount);
    }
    setSceneInstance(sceneInstance) {
        this.sceneInstance = sceneInstance;
    }
    async loadAssetsAsync() {
        let fguiPkgCount = this.preloadFairyGUIPackage.size;
        let prefabCount = this.preloadPrefab.size;
        this.totalCount = fguiPkgCount + prefabCount;
        let premises = [];
        this.preloadFairyGUIPackage.forEach((value, key) => {
            let premise = ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadFairyGUIPackage(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        this.preloadPrefab.forEach((value, key) => {
            let premise = GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).preLoadGameObjectAsync(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        await Promise.all(premises);
    }
    onDestroy() {
        this.preloadFairyGUIPackage.forEach((value, key) => {
            console.log("destroy scene: " + key);
            ResManager_1.ResManager.Instance(ResManager_1.ResManager).releaseFairyGUIPackage(value);
        });
        //清理资源缓存
        GameObjectPool_1.GameObjectPool.Instance(GameObjectPool_1.GameObjectPool).cleanup(true);
        //卸载场景
        ResManager_1.ResManager.Instance(ResManager_1.ResManager).unloadScene(this.sceneInstance);
        this.preloadFairyGUIPackage.clear();
        this.preloadPrefab.clear();
    }
}
exports.BaseScene = BaseScene;


/***/ }),

/***/ "./src/framework/scene/SceneDef.ts":
/*!*****************************************!*\
  !*** ./src/framework/scene/SceneDef.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneDef = void 0;
class SceneDef {
}
exports.SceneDef = SceneDef;
SceneDef.LoadingScene = "LoadingScene";
SceneDef.LaunchScene = "LaunchScene";
SceneDef.HomeScene = "HomeScene";
SceneDef.LoginScene = "LoginScene";
SceneDef.PveScene = "PveScene";


/***/ }),

/***/ "./src/framework/scene/SceneFactory.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneFactory.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneFactory = void 0;
const PveScene_1 = __webpack_require__(/*! ../../game/module/pve/scene/PveScene */ "./src/game/module/pve/scene/PveScene.ts");
const HomeScene_1 = __webpack_require__(/*! ../../game/module/home/scene/HomeScene */ "./src/game/module/home/scene/HomeScene.ts");
const LoginScene_1 = __webpack_require__(/*! ../../game/module/login/scene/LoginScene */ "./src/game/module/login/scene/LoginScene.ts");
const SceneDef_1 = __webpack_require__(/*! ./SceneDef */ "./src/framework/scene/SceneDef.ts");
class SceneFactory {
    static createScene(sceneName) {
        let scene = null;
        switch (sceneName) {
            case SceneDef_1.SceneDef.LoginScene:
                scene = new LoginScene_1.LoginScene();
                break;
            case SceneDef_1.SceneDef.HomeScene:
                scene = new HomeScene_1.HomeScene();
                break;
            case SceneDef_1.SceneDef.PveScene:
                scene = new PveScene_1.PveScene();
                break;
        }
        return scene;
    }
}
exports.SceneFactory = SceneFactory;


/***/ }),

/***/ "./src/framework/scene/SceneManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneManager.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneManager = void 0;
const common_1 = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
const UIMessage_1 = __webpack_require__(/*! ../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const ResManager_1 = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const UIManager_1 = __webpack_require__(/*! ../ui/UIManager */ "./src/framework/ui/UIManager.ts");
const SceneFactory_1 = __webpack_require__(/*! ./SceneFactory */ "./src/framework/scene/SceneFactory.ts");
class SceneManager extends Singleton_1.Singleton {
    constructor() {
        super();
    }
    async loadScene(scene) {
        try {
            //打开Loading界面
            UIManager_1.UIManager.Instance(UIManager_1.UIManager).openLoading(common_1.commonUI.PackageName, common_1.commonUI.UILoadingPage);
            //清理旧场景
            if (this.currentScene) {
                this.currentScene.onLeave();
                this.currentScene.onDestroy();
            }
            //开始加载场景
            let sceneInstance = await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadScene(scene);
            //开始加载进入场景的资源
            this.currentScene = SceneFactory_1.SceneFactory.createScene(scene);
            this.currentScene.setSceneInstance(sceneInstance);
            this.currentScene.onEnter();
            //设置当前场景加载进度Timer
            let progressInterval = setInterval(() => {
                let progress = this.currentScene.finishCount / this.currentScene.totalCount;
                console.log("progress:" + progress + " = " + this.currentScene.finishCount + " = " + this.currentScene.totalCount);
                UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).broadcast(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS, progress * 100);
            }, 100);
            //加载资源
            await this.currentScene.loadAssetsAsync();
            //加载完成
            clearInterval(progressInterval);
            this.currentScene.onComplete();
            UIManager_1.UIManager.Instance(UIManager_1.UIManager).closeLoading(common_1.commonUI.UILoadingPage);
        }
        catch (ex) {
            console.log("load scene excep:" + ex);
        }
    }
}
exports.SceneManager = SceneManager;


/***/ }),

/***/ "./src/framework/ui/UIDefine.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIDefine.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIComDefs = exports.UILayerDef = exports.UITypeDef = void 0;
var UITypeDef;
(function (UITypeDef) {
    UITypeDef[UITypeDef["Unkown"] = 0] = "Unkown";
    UITypeDef[UITypeDef["Page"] = 1] = "Page";
    UITypeDef[UITypeDef["Window"] = 2] = "Window";
    UITypeDef[UITypeDef["Widget"] = 3] = "Widget";
    UITypeDef[UITypeDef["Loading"] = 4] = "Loading";
})(UITypeDef = exports.UITypeDef || (exports.UITypeDef = {}));
class UILayerDef {
    static getDefaultLayer(type) {
        switch (type) {
            case UITypeDef.Loading: return this.Loading;
            case UITypeDef.Widget: return this.Widget;
            case UITypeDef.Window: return this.NormalWindow;
            case UITypeDef.Page: return this.Page;
            case UITypeDef.Unkown: return this.Unkown;
            default: return this.Unkown;
        }
    }
}
exports.UILayerDef = UILayerDef;
UILayerDef.Background = 0;
UILayerDef.Page = 1000;
UILayerDef.NormalWindow = 2000;
UILayerDef.TopWindow = 3000;
UILayerDef.Widget = 4000;
UILayerDef.Loading = 5000;
UILayerDef.Unkown = 9999;
class UIComDefs {
}
exports.UIComDefs = UIComDefs;
UIComDefs.BackBtn = "back_btn";
UIComDefs.WindowCloseBtn = "win_close_btn";


/***/ }),

/***/ "./src/framework/ui/UIFactory.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIFactory.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIFactory = void 0;
const UILoginPage_1 = __webpack_require__(/*! ../../game/module/login/ui/UILoginPage */ "./src/game/module/login/ui/UILoginPage.ts");
const UIHomePage_1 = __webpack_require__(/*! ../../game/module/home/ui/UIHomePage */ "./src/game/module/home/ui/UIHomePage.ts");
const UILoading_1 = __webpack_require__(/*! ./UILib/UILoading */ "./src/framework/ui/UILib/UILoading.ts");
const login_1 = __webpack_require__(/*! ../../data/ui/login */ "./src/data/ui/login.ts");
const common_1 = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
const home_1 = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
const UIMsgBox_1 = __webpack_require__(/*! ./UILib/UIMsgBox */ "./src/framework/ui/UILib/UIMsgBox.ts");
const UISelServerWin_1 = __webpack_require__(/*! ../../game/module/login/ui/UISelServerWin */ "./src/game/module/login/ui/UISelServerWin.ts");
const UIShopPage_1 = __webpack_require__(/*! ../../game/module/home/ui/UIShopPage */ "./src/game/module/home/ui/UIShopPage.ts");
const story_1 = __webpack_require__(/*! ../../data/ui/story */ "./src/data/ui/story.ts");
const UIStoryWin_1 = __webpack_require__(/*! ../../game/module/story/UIStoryWin */ "./src/game/module/story/UIStoryWin.ts");
const CS = __webpack_require__(/*! csharp */ "csharp");
class UIFactory {
    static createUI(pkg, name) {
        console.log(`create UI: ${pkg}:${name}`);
        let comp = CS.FairyGUI.UIPackage.CreateObject(pkg, name).asCom;
        let ui = this.uiCache.get(name);
        if (!ui) {
            switch (name) {
                //common
                case common_1.commonUI.UIUINoticeWin:
                    ui = new UIMsgBox_1.UIMsgBox();
                    break;
                case common_1.commonUI.UILoadingPage:
                    ui = new UILoading_1.UILoading();
                    break;
                //login
                case login_1.loginUI.UILoginPage:
                    ui = new UILoginPage_1.UILoginPage();
                    break;
                case login_1.loginUI.UISelServerWin:
                    ui = new UISelServerWin_1.UISelServerWin();
                    break;
                //home
                case home_1.homeUI.UIHomePage:
                    ui = new UIHomePage_1.UIHomePage();
                    break;
                case home_1.homeUI.UIShopPage:
                    ui = new UIShopPage_1.UIShopPage();
                    break;
                //story
                case story_1.storyUI.UIStoryWin:
                    ui = new UIStoryWin_1.UIStoryWin();
                    break;
            }
            this.uiCache.set(name, ui);
        }
        if (ui != null) {
            ui.fui = comp;
            ui.name = name;
            //绑定FairyGUI控件
            ui.bindAll(ui);
            ui.awake();
        }
        else {
            console.error(`not create ui: ${pkg}-${name}`);
        }
        return ui;
    }
}
exports.UIFactory = UIFactory;
UIFactory.uiCache = new Map();


/***/ }),

/***/ "./src/framework/ui/UILib/UILoading.ts":
/*!*********************************************!*\
  !*** ./src/framework/ui/UILib/UILoading.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UILoading = void 0;
const UIPanel_1 = __webpack_require__(/*! ../UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ../UIDefine */ "./src/framework/ui/UIDefine.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
class UILoading extends UIPanel_1.UIPanel {
    onAwake() {
    }
    get uiType() {
        return UIDefine_1.UITypeDef.Loading;
    }
    onOpen(arg) {
        super.onOpen(arg);
        this.progressLoading.value = 0;
        this.progressLoading.visible = true;
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).addListener(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS, this, (progress) => {
            this.progressLoading.TweenValue(progress, 0.1);
        });
    }
    onClose(arg) {
        super.onClose(arg);
        this.progressLoading.visible = false;
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).removeListenerByCode(UIMessage_1.UIMessage.MSG_SCENE_PROGRESS);
    }
}
__decorate([
    NiceDecorator_1.binder("loading_pregress")
], UILoading.prototype, "progressLoading", void 0);
exports.UILoading = UILoading;


/***/ }),

/***/ "./src/framework/ui/UILib/UIMsgBox.ts":
/*!********************************************!*\
  !*** ./src/framework/ui/UILib/UIMsgBox.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMsgBox = exports.UIMsgBoxArg = void 0;
const NiceDecorator_1 = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIWindow_1 = __webpack_require__(/*! ../UIWindow */ "./src/framework/ui/UIWindow.ts");
// 通用弹窗
class UIMsgBoxArg {
    constructor() {
        this.title = "";
        this.content = "";
        this.btnText = ""; //"确定|取消|关闭"
    }
}
exports.UIMsgBoxArg = UIMsgBoxArg;
class UIMsgBox extends UIWindow_1.UIWindow {
    onAwake() {
        super.onAwake();
        this.bindAll(this);
    }
    onOpen(arg) {
        super.onOpen(arg);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    NiceDecorator_1.binder("msgTxt")
], UIMsgBox.prototype, "m_txt", void 0);
__decorate([
    NiceDecorator_1.binder("okBtn")
], UIMsgBox.prototype, "m_okBtn", void 0);
__decorate([
    NiceDecorator_1.binder("cancelBtn")
], UIMsgBox.prototype, "m_cancelBtn", void 0);
exports.UIMsgBox = UIMsgBox;


/***/ }),

/***/ "./src/framework/ui/UIManager.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIManager.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIManager = exports.UIPageTrack = void 0;
const Singleton_1 = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
const UIFactory_1 = __webpack_require__(/*! ./UIFactory */ "./src/framework/ui/UIFactory.ts");
const home_1 = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
class UIPageTrack {
}
exports.UIPageTrack = UIPageTrack;
class UIManager extends Singleton_1.Singleton {
    constructor() {
        super();
        this.m_pageTrackStack = new Array();
        this.m_listLoadedPanel = new Array();
    }
    closeAllLoadedPanel() {
        for (let i = this.m_listLoadedPanel.length - 1; i >= 0; i--) {
            let panel = this.m_listLoadedPanel[i];
            if (panel.isOpen) {
                panel.close();
            }
            panel.dispose();
        }
        this.m_listLoadedPanel.length = 0;
    }
    clean() {
        this.closeAllLoadedPanel();
        this.m_pageTrackStack.length = 0;
        this.m_listLoadedPanel.length = 0;
    }
    open(pkg, name, arg) {
        let ui = this.getUI(name);
        if (ui == null) {
            ui = UIFactory_1.UIFactory.createUI(pkg, name);
            this.m_listLoadedPanel.push(ui);
        }
        if (ui != null) {
            ui.open(arg);
        }
        return ui;
    }
    getUI(name) {
        for (const panel of this.m_listLoadedPanel) {
            if (panel.name == name) {
                console.log("find panel in cache: " + name);
                return panel;
            }
        }
        return null;
    }
    //打开场景页面,此页面不计入页面栈,无返回上一面按钮
    openPageInScene(pkg, page, arg) {
        this.openPageWorker(pkg, page, arg);
    }
    //==========================================================UILoading
    //打开Loading界面
    openLoading(pkg, name, arg) {
        this.openPageInScene(pkg, name, arg);
    }
    //关闭Loading界面
    closeLoading(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================Page
    openPageWorker(pkg, page, arg) {
        this.m_currentPage = new UIPageTrack();
        this.m_currentPage.pkg = pkg;
        this.m_currentPage.name = page;
        this.m_currentPage.arg = arg;
        this.closeAllLoadedPanel();
        this.open(pkg, page, arg);
    }
    //打开页面, 会关闭上一个页面上的所有窗口,Widiget等
    openPage(pkg, name, arg) {
        if (this.m_currentPage != undefined && this.m_currentPage.name != name) {
            this.m_pageTrackStack.push(this.m_currentPage);
        }
        this.openPageWorker(pkg, name, arg);
    }
    //返回上一个页面
    goBackPage() {
        if (this.m_pageTrackStack.length > 0) {
            let track = this.m_pageTrackStack.pop();
            this.openPageWorker(track.pkg, track.name, track.arg);
        }
        else {
            this.enterMainPage();
        }
    }
    //回到主城
    enterMainPage() {
        this.m_pageTrackStack.length = 0;
        this.openPageInScene(home_1.homeUI.PackageName, home_1.homeUI.UIHomePage, null);
    }
    //==========================================================UIWindow
    //打开窗口
    openWindow(pkg, name, arg) {
        let ui = this.open(pkg, name, arg);
        return ui;
    }
    //关闭窗口
    closeWindow(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================UIWidget
    //打开Widiget
    openWidget(pkg, name, arg) {
        let ui = this.open(pkg, name, arg);
        return ui;
    }
    //u关闭Widiget
    closeWidget(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
}
exports.UIManager = UIManager;


/***/ }),

/***/ "./src/framework/ui/UIPage.ts":
/*!************************************!*\
  !*** ./src/framework/ui/UIPage.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIPage = void 0;
const UIPanel_1 = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const UIManager_1 = __webpack_require__(/*! ./UIManager */ "./src/framework/ui/UIManager.ts");
class UIPage extends UIPanel_1.UIPanel {
    get uiType() {
        return UIDefine_1.UITypeDef.Page;
    }
    onAwake() {
        this.m_btnGoBack = this.fui.GetChild(UIDefine_1.UIComDefs.BackBtn);
        if (this.m_btnGoBack != undefined) {
            this.m_btnGoBack.onClick.Add(() => {
                this.onBtnGoBack();
            });
        }
    }
    onOpen(vo) {
        super.onOpen(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onBtnGoBack() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).goBackPage();
    }
}
exports.UIPage = UIPage;


/***/ }),

/***/ "./src/framework/ui/UIPanel.ts":
/*!*************************************!*\
  !*** ./src/framework/ui/UIPanel.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIPanel = void 0;
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class UIPanel {
    constructor() {
        this.m_layer = UIDefine_1.UILayerDef.Unkown;
    }
    set name(v) {
        this._name = v;
    }
    get name() {
        return this._name;
    }
    get uiType() {
        return UIDefine_1.UITypeDef.Unkown;
    }
    get layer() {
        return this.m_layer;
    }
    set layer(v) {
        this.m_layer = v;
    }
    get isOpen() {
        return this.fui.visible;
    }
    onUpdate() { }
    onOpen(vo) {
        this.layer = UIDefine_1.UILayerDef.getDefaultLayer(this.uiType);
    }
    onClose(arg) { }
    awake() {
        this.onAwake();
    }
    //绑定FairyGUI元件
    bindAll(target) {
        for (let k in target["binders"]) {
            let fguiName = this["binders"][k];
            this[k] = this.fui.GetChild(fguiName);
        }
    }
    update() {
        this.onUpdate();
    }
    open(arg) {
        this.onOpen(arg);
        csharp_1.FairyGUI.GRoot.inst.AddChild(this.fui);
    }
    close(arg = null) {
        this.onClose(arg);
        csharp_1.FairyGUI.GRoot.inst.RemoveChild(this.fui);
    }
    dispose() {
        this.fui.Dispose();
    }
}
exports.UIPanel = UIPanel;


/***/ }),

/***/ "./src/framework/ui/UIWindow.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIWindow.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIWindow = void 0;
const UIPanel_1 = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
const UIDefine_1 = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
const csharp_1 = __webpack_require__(/*! csharp */ "csharp");
class UIWindow extends UIPanel_1.UIPanel {
    get uiType() {
        return UIDefine_1.UITypeDef.Window;
    }
    onAwake() {
        this.m_btnClose = this.fui.GetChild(UIDefine_1.UIComDefs.WindowCloseBtn);
    }
    onOpen(arg) {
        super.onOpen(arg);
        this.fui.x = csharp_1.FairyGUI.GRoot.inst.width / 2 - this.fui.width / 2;
        this.fui.y = csharp_1.FairyGUI.GRoot.inst.height / 2 - this.fui.height / 2;
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Add(this.onBtnClose);
        }
    }
    onClose(arg) {
        super.onClose(arg);
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Remove(this.onBtnClose);
        }
    }
    onBtnClose() {
        this.close(0);
    }
}
exports.UIWindow = UIWindow;


/***/ }),

/***/ "./src/framework/util/TimeUtil.ts":
/*!****************************************!*\
  !*** ./src/framework/util/TimeUtil.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUtil = void 0;
class TimeUtil {
    static prefixInteger(num, length) {
        return (Array(length).join('0') + num).slice(-length);
    }
    //将一个时间数转换成"00:00:00"格式
    static getTimeString1(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${hourstr}:${minutestr}:${secondstr}`;
        }
    }
    //将一个时间数转换成"00:00"格式
    static getTimeString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let hour = Math.floor(timeInt / (60 * 60));
            let hourstr = this.prefixInteger(hour, 2);
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${hourstr}:${minutestr}`;
        }
    }
    //将一个时间数转换成"00"分格式
    static getTimeMinuteString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let minnute = Math.floor(timeInt / 60) % 60;
            let minutestr = this.prefixInteger(minnute, 2);
            return `${minutestr}`;
        }
    }
    //将一个时间数转换成"00“秒格式
    static getTimeSecondString(timeInt) {
        if (timeInt <= 0) {
            return "00:00:00";
        }
        else {
            let second = timeInt % 60;
            let secondstr = this.prefixInteger(second, 2);
            return `${secondstr}`;
        }
    }
    //获取本月1号是星期几
    static getWeekOfMonthFirstDay(time) {
        let date = new Date(time);
        date.setDate(1);
        return date.getDay();
    }
    //判断是否为闰年
    static isLeapYear(year) {
        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {
            return true;
        }
        return false;
    }
    static getMonthDays_(year, month) {
        if (month == 2) {
            if (this.isLeapYear(year))
                return 29;
            else {
                return 28;
            }
        }
        else {
            return this.months[month];
        }
    }
    static getMonthDays(time) {
        let t = new Date(time);
        return this.getMonthDays_(t.getFullYear(), t.getMonth());
    }
    static async sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve('');
            }, ms);
        });
    }
    static test() {
        let t1 = this.getTimeString1(5000);
        console.log(t1);
        let t2 = this.getTimeString(5000);
        console.log(t2);
        let t3 = this.getTimeMinuteString(5000);
        console.log(t3);
        let t4 = this.getTimeSecondString(5000);
        console.log(t4);
        let time = new Date().getTime();
        let t5 = this.getWeekOfMonthFirstDay(time);
        console.log("getWeekOfMonthFirstDay: " + t5 + " ,time:" + time);
        let t6 = this.getMonthDays(time);
        console.log("getMonthDays: " + t6);
    }
}
exports.TimeUtil = TimeUtil;
//每个月对应的天数
TimeUtil.months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];


/***/ }),

/***/ "./src/game/api/LoginAPI.ts":
/*!**********************************!*\
  !*** ./src/game/api/LoginAPI.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginAPI = void 0;
const pb_1 = __webpack_require__(/*! ../../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
const Opcode_1 = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
const SessionManager_1 = __webpack_require__(/*! ../../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
class LoginAPI {
    static async benchmarkTest() {
        for (let i = 1; i < 2; i++) {
            let msg = pb_1.nice_ts.C2GS_Test.create();
            msg.testID = i;
            msg.testName = "benchmark test";
            let response = await SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendGateMsg(Opcode_1.Opcode.MSG_C2GS_Test, msg);
            let test = response;
            console.log("code: " + test.Error + ",msg:" + test.Message + ",res:" + test.testResponse);
        }
    }
    static async loginRealmServer(account, password) {
        let msg = pb_1.nice_ts.C2R_Login.create();
        msg.Account = account;
        msg.Password = password;
        let response = await SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendRealmMsg(Opcode_1.Opcode.MSG_C2R_Login, msg);
        return response;
    }
    static async loginGateServer(gateId, gateKey) {
        let msg = pb_1.nice_ts.C2G_LoginGate.create();
        msg.GateId = gateId;
        msg.Key = gateKey;
        let response = await SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).sendGateMsg(Opcode_1.Opcode.MSG_C2G_LoginGate, msg);
        return response;
    }
}
exports.LoginAPI = LoginAPI;


/***/ }),

/***/ "./src/game/event/UIMessage.ts":
/*!*************************************!*\
  !*** ./src/game/event/UIMessage.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMessage = void 0;
class UIMessage {
}
exports.UIMessage = UIMessage;
UIMessage.MSG_SELECT_SERVER = 1000;
UIMessage.MSG_SCENE_PROGRESS = 1001;


/***/ }),

/***/ "./src/game/event/UIMessageManager.ts":
/*!********************************************!*\
  !*** ./src/game/event/UIMessageManager.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIMessageManger = void 0;
const Messenger_1 = __webpack_require__(/*! ../../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
const Singleton_1 = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class UIMessageManger extends Singleton_1.Singleton {
    constructor() {
        super(...arguments);
        this.uiMessage = new Messenger_1.Messenger();
    }
    addListener(msgCode, obj, listener) {
        this.uiMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.uiMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.uiMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.uiMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.uiMessage.broadcast(msgCode, params);
    }
}
exports.UIMessageManger = UIMessageManger;


/***/ }),

/***/ "./src/game/module/home/scene/HomeScene.ts":
/*!*************************************************!*\
  !*** ./src/game/module/home/scene/HomeScene.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.HomeScene = void 0;
const home_1 = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const VoHome_1 = __webpack_require__(/*! ../vo/VoHome */ "./src/game/module/home/vo/VoHome.ts");
class HomeScene extends BaseScene_1.BaseScene {
    constructor() {
        super();
    }
    onEnter() {
        this.addPreloadFairyGUIPackage(home_1.homeUI.PackageBytes, home_1.homeUI.PackageName);
    }
    onComplete() {
        let vo = new VoHome_1.VoHome();
        vo.name = "Justin";
        vo.hp = 1200;
        vo.mp = 3300;
        vo.money = 666;
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPageInScene(home_1.homeUI.PackageName, home_1.homeUI.UIHomePage, vo);
    }
    onLeave() {
    }
}
exports.HomeScene = HomeScene;


/***/ }),

/***/ "./src/game/module/home/ui/UIHomePage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIHomePage.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIHomePage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const common_1 = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
const home_1 = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
const LoginAPI_1 = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
const GameSession_1 = __webpack_require__(/*! ../../../../framework/net/GameSession */ "./src/framework/net/GameSession.ts");
const Opcode_1 = __webpack_require__(/*! ../../../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
class UIHomePage extends UIPage_1.UIPage {
    onAwake() {
        super.onAwake();
        this.m_chatBtn.onClick.Add(() => {
            this.onchatBtn();
        });
        this.m_bagBtn.onClick.Add(() => {
            this.onbagBtn();
        });
        this.m_shopBtn.onClick.Add(() => {
            this.onshopBtn();
        });
        this.m_levelBtn.onClick.Add(() => {
            this.onlevelBtn();
        });
    }
    onOpen(vo) {
        super.onOpen(vo);
        this.m_nameLbl.text = vo.name;
        this.m_mpLbl.text = vo.mp.toString();
        this.m_hpLbl.text = vo.hp.toString();
        this.m_moneyLbl.text = vo.money.toString();
        GameSession_1.GameSession.Instance(GameSession_1.GameSession).listen(Opcode_1.Opcode.MSG_GS2C_Test, function (msg) {
            console.log("收到服务器下发的消息。。。。" + msg.testResponse);
        });
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onchatBtn() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(common_1.commonUI.PackageName, common_1.commonUI.UIUINoticeWin, null);
        console.log("on chat...");
    }
    onbagBtn() {
        console.log("on bag ..");
        //benchmark test
        LoginAPI_1.LoginAPI.benchmarkTest();
    }
    onshopBtn() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPage(home_1.homeUI.PackageName, home_1.homeUI.UIShopPage);
    }
    onlevelBtn() {
        console.log("on level...");
    }
}
__decorate([
    NiceDecorator_1.binder("chatBtn")
], UIHomePage.prototype, "m_chatBtn", void 0);
__decorate([
    NiceDecorator_1.binder("bagBtn")
], UIHomePage.prototype, "m_bagBtn", void 0);
__decorate([
    NiceDecorator_1.binder("shopBtn")
], UIHomePage.prototype, "m_shopBtn", void 0);
__decorate([
    NiceDecorator_1.binder("levelBtn")
], UIHomePage.prototype, "m_levelBtn", void 0);
__decorate([
    NiceDecorator_1.binder("nameTxt")
], UIHomePage.prototype, "m_nameLbl", void 0);
__decorate([
    NiceDecorator_1.binder("hpTxt")
], UIHomePage.prototype, "m_hpLbl", void 0);
__decorate([
    NiceDecorator_1.binder("mpTxt")
], UIHomePage.prototype, "m_mpLbl", void 0);
__decorate([
    NiceDecorator_1.binder("moneyTxt")
], UIHomePage.prototype, "m_moneyLbl", void 0);
exports.UIHomePage = UIHomePage;


/***/ }),

/***/ "./src/game/module/home/ui/UIShopPage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIShopPage.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UIShopPage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
class UIShopPage extends UIPage_1.UIPage {
    onAwake() {
        super.onAwake();
    }
    onOpen(vo) {
        super.onOpen(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
exports.UIShopPage = UIShopPage;


/***/ }),

/***/ "./src/game/module/home/vo/VoHome.ts":
/*!*******************************************!*\
  !*** ./src/game/module/home/vo/VoHome.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VoHome = void 0;
class VoHome {
}
exports.VoHome = VoHome;


/***/ }),

/***/ "./src/game/module/login/scene/LoginScene.ts":
/*!***************************************************!*\
  !*** ./src/game/module/login/scene/LoginScene.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.LoginScene = void 0;
const login_1 = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
const story_1 = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
class LoginScene extends BaseScene_1.BaseScene {
    onEnter() {
        //添加预加载资源
        this.addPreloadFairyGUIPackage(login_1.loginUI.PackageBytes, login_1.loginUI.PackageName);
        //测试Story
        this.addPreloadFairyGUIPackage(story_1.storyUI.PackageBytes, story_1.storyUI.PackageName);
    }
    onComplete() {
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openPageInScene(login_1.loginUI.PackageName, login_1.loginUI.UILoginPage, null);
    }
    onLeave() {
    }
}
exports.LoginScene = LoginScene;


/***/ }),

/***/ "./src/game/module/login/ui/UILoginPage.ts":
/*!*************************************************!*\
  !*** ./src/game/module/login/ui/UILoginPage.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UILoginPage = void 0;
const UIPage_1 = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const SessionManager_1 = __webpack_require__(/*! ../../../../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
const LoginAPI_1 = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
const UIManager_1 = __webpack_require__(/*! ../../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const login_1 = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
const VoServer_1 = __webpack_require__(/*! ../vo/VoServer */ "./src/game/module/login/vo/VoServer.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
const SceneManager_1 = __webpack_require__(/*! ../../../../framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
const SceneDef_1 = __webpack_require__(/*! ../../../../framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
const story_1 = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
class UILoginPage extends UIPage_1.UIPage {
    async onAwake() {
        super.onAwake();
        this.m_loginBtn.onClick.Add(() => {
            this.onLoginClick();
        });
        this.m_storyBtn.onClick.Add(() => {
            UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(story_1.storyUI.PackageName, story_1.storyUI.UIStoryWin, null);
        });
        this.m_selserverBtn.onClick.Add(() => {
            this.openSelServerWin();
        });
        let connected = await SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).connectRealmServer();
        this.m_loginBtn.enabled = connected;
        console.log("connect ream server: " + connected);
    }
    onSelectServer(serverItem) {
        console.log(" server selected: " + serverItem.serverName);
        this.m_selserverBtn.text = serverItem.serverName;
    }
    onOpen(vo) {
        super.onOpen(vo);
        //监听选服消息
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).addListener(UIMessage_1.UIMessage.MSG_SELECT_SERVER, this, this.onSelectServer);
    }
    onClose(arg) {
        super.onClose(arg);
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).removeListener(UIMessage_1.UIMessage.MSG_SELECT_SERVER, this.onSelectServer);
    }
    openSelServerWin() {
        // 测试数据
        let voServer = new VoServer_1.VoServer();
        for (let i = 1; i < 10; i++) {
            voServer.areaMap.set(i, "分区" + i);
            voServer.serverMap.set(i, new Array());
            for (let j = 1; j < 20; j++) {
                let voServerItem = new VoServer_1.VoServerItem();
                voServerItem.areaId = i;
                voServerItem.serverId = j;
                voServerItem.serverName = "测试服务器" + i + ":" + j;
                voServerItem.serverStatus = Math.floor(Math.random() * 3 + 1);
                voServer.serverMap.get(i).push(voServerItem);
            }
        }
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).openWindow(login_1.loginUI.PackageName, login_1.loginUI.UISelServerWin, voServer);
    }
    async onLoginClick() {
        let account = this.m_account.text;
        let password = this.m_password.text;
        console.log(`account:${account} - password: ${password}`);
        if (account != "" && password != "") {
            let msg = await LoginAPI_1.LoginAPI.loginRealmServer(account, password);
            this.gateId = msg.GateId;
            this.gateKey = msg.Key;
            console.log("login ream succ, gate addr:" + msg.Address + ",key:" + msg.Key);
            SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).disconnectRealmServer();
            //登录网关服
            let connected = await SessionManager_1.SessionManager.Instance(SessionManager_1.SessionManager).connectGateServer(msg.Address);
            if (connected) {
                console.log("connect gate succ");
                let msg = await LoginAPI_1.LoginAPI.loginGateServer(this.gateId, this.gateKey);
                let playerID = msg.PlayerId;
                console.log("login gate response.." + playerID);
                SceneManager_1.SceneManager.Instance(SceneManager_1.SceneManager).loadScene(SceneDef_1.SceneDef.HomeScene);
            }
            else {
                console.log("connect gate err ");
            }
        }
    }
}
__decorate([
    NiceDecorator_1.binder("account")
], UILoginPage.prototype, "m_account", void 0);
__decorate([
    NiceDecorator_1.binder("password")
], UILoginPage.prototype, "m_password", void 0);
__decorate([
    NiceDecorator_1.binder("selserverBtn")
], UILoginPage.prototype, "m_selserverBtn", void 0);
__decorate([
    NiceDecorator_1.binder("loginBtn")
], UILoginPage.prototype, "m_loginBtn", void 0);
__decorate([
    NiceDecorator_1.binder("storyBtn")
], UILoginPage.prototype, "m_storyBtn", void 0);
exports.UILoginPage = UILoginPage;


/***/ }),

/***/ "./src/game/module/login/ui/UISelServerWin.ts":
/*!****************************************************!*\
  !*** ./src/game/module/login/ui/UISelServerWin.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UISelServerWin = void 0;
const NiceDecorator_1 = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const UIWindow_1 = __webpack_require__(/*! ../../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
const UIMessage_1 = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
const UIMessageManager_1 = __webpack_require__(/*! ../../../event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");
class UISelServerWin extends UIWindow_1.UIWindow {
    constructor() {
        super(...arguments);
        this.clickAreaIndex = 0;
        this.clickServerIndex = 0;
    }
    onAwake() {
        super.onAwake();
        this.backBtn.onClick.Add(() => {
            this.close();
        });
        this.okBtn.onClick.Add(() => {
            this.onSelectServer();
        });
        this.areaList.onClickItem.Add((event) => {
            this.clickAreaIndex = this.areaList.GetChildIndex(event.data);
            this.serverList.numItems = this.voServer.serverMap.get(this.clickAreaIndex + 1).length;
            this.serverList.RefreshVirtualList();
        });
        this.serverList.onClickItem.Add((event) => {
            this.clickServerIndex = this.serverList.GetChildIndex(event.data);
            this.title.text = "已选择服务器：" + this.clickServerIndex;
        });
    }
    onSelectServer() {
        let selItem = this.voServer.serverMap.get(this.clickAreaIndex + 1)[this.clickServerIndex];
        UIMessageManager_1.UIMessageManger.Instance(UIMessageManager_1.UIMessageManger).broadcast(UIMessage_1.UIMessage.MSG_SELECT_SERVER, selItem);
        this.close();
    }
    onOpen(vo) {
        super.onOpen(vo);
        this.voServer = vo;
        this.areaList.SetVirtual();
        this.areaList.itemRenderer = (index, obj) => {
            this.renderAreaListItem(index, obj);
        };
        this.areaList.numItems = vo.areaMap.size;
        this.serverList.SetVirtual();
        this.serverList.itemRenderer = (index, obj) => {
            this.renderServerListItem(index, obj);
        };
        this.serverList.numItems = vo.serverMap.get(this.clickAreaIndex + 1).length;
    }
    renderAreaListItem(index, obj) {
        let areaBtn = obj.asButton;
        areaBtn.text = this.voServer.areaMap.get(index + 1);
    }
    renderServerListItem(index, obj) {
        let serverBtn = obj.asButton;
        serverBtn.text = this.voServer.serverMap.get(this.clickAreaIndex + 1)[index].serverName;
        //serverBtn.icon = FairyGUI.UIPackage.
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    NiceDecorator_1.binder("areaList")
], UISelServerWin.prototype, "areaList", void 0);
__decorate([
    NiceDecorator_1.binder("serverList")
], UISelServerWin.prototype, "serverList", void 0);
__decorate([
    NiceDecorator_1.binder("backBtn")
], UISelServerWin.prototype, "backBtn", void 0);
__decorate([
    NiceDecorator_1.binder("okBtn")
], UISelServerWin.prototype, "okBtn", void 0);
__decorate([
    NiceDecorator_1.binder("title")
], UISelServerWin.prototype, "title", void 0);
exports.UISelServerWin = UISelServerWin;


/***/ }),

/***/ "./src/game/module/login/vo/VoServer.ts":
/*!**********************************************!*\
  !*** ./src/game/module/login/vo/VoServer.ts ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VoServer = exports.VoServerItem = void 0;
class VoServerItem {
}
exports.VoServerItem = VoServerItem;
class VoServer {
    constructor() {
        this.serverMap = new Map();
        this.areaMap = new Map();
    }
}
exports.VoServer = VoServer;


/***/ }),

/***/ "./src/game/module/pve/scene/PveScene.ts":
/*!***********************************************!*\
  !*** ./src/game/module/pve/scene/PveScene.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PveScene = void 0;
const BaseScene_1 = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
class PveScene extends BaseScene_1.BaseScene {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
    }
    onLeave() {
    }
}
exports.PveScene = PveScene;


/***/ }),

/***/ "./src/game/module/story/UIStoryWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/story/UIStoryWin.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UIStoryWin = void 0;
const story_1 = __webpack_require__(/*! ../../../data/ui/story */ "./src/data/ui/story.ts");
const NiceDecorator_1 = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
const StoryManager_1 = __webpack_require__(/*! ../../../framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
const StoryMessageManager_1 = __webpack_require__(/*! ../../../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
const UIManager_1 = __webpack_require__(/*! ../../../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
const UIWindow_1 = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
class UIStoryWin extends UIWindow_1.UIWindow {
    constructor() {
        super(...arguments);
        this.shouldContineStory = false;
        this.optionsMap = new Map();
    }
    onAwake() {
        super.onAwake();
        this.m_btnList.itemRenderer = (index, obj) => {
            this.renderBtnList(index, obj);
        };
        this.m_btnList.onClickItem.Add((event) => {
            let clickId = this.m_btnList.GetChildIndex(event.data);
            if (this.shouldContineStory) {
                StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).advanceStory();
            }
            else {
                this.optionsMap.clear();
                StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).selectChoice(this.allChoices[clickId]);
            }
        });
    }
    onOpen(vo) {
        super.onOpen(vo);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, this, this.OnContentReady);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this, this.OnChoicesPresented);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).addListener(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED, this, this.OnStoryFinished);
        this.optionsMap.clear();
        this.shouldContineStory = false;
        StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).beginStory("story2");
    }
    OnContentReady(speakerContent, speakerId, currentTags, currentChoices) {
        this.m_speakerTxt.text = speakerContent;
        if (StoryManager_1.StoryManager.Instance(StoryManager_1.StoryManager).canContinue) {
            this.shouldContineStory = true;
            this.m_btnList.numItems = 1;
        }
        if (currentChoices.length > 0) {
            this.allChoices = currentChoices;
            this.shouldContineStory = false;
            let len = currentChoices.length;
            for (let i = 0; i < len; i++) {
                this.optionsMap.set(i, currentChoices[i].text);
            }
            this.m_btnList.numItems = len;
        }
    }
    renderBtnList(index, obj) {
        let continueBtn = obj.asButton;
        if (this.optionsMap.size > 0) {
            continueBtn.text = this.optionsMap.get(index);
        }
        else {
            continueBtn.text = "点击继续";
        }
    }
    OnChoicesPresented(currentChoices) {
        this.shouldContineStory = false;
        console.log("....OnChoicesPresented......");
    }
    OnStoryFinished() {
        console.log("Story Finished");
        UIManager_1.UIManager.Instance(UIManager_1.UIManager).closeWindow(story_1.storyUI.UIStoryWin, null);
    }
    onClose(arg) {
        super.onClose(arg);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONCONTENTREADY, this.OnContentReady);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONCHOICESPRESENTED, this.OnChoicesPresented);
        StoryMessageManager_1.StoryMessageManager.Instance(StoryMessageManager_1.StoryMessageManager).removeListener(StoryMessageManager_1.StoryMessageManager.ONSTORYFINISHED, this.OnStoryFinished);
    }
}
__decorate([
    NiceDecorator_1.binder("speakerTxt")
], UIStoryWin.prototype, "m_speakerTxt", void 0);
__decorate([
    NiceDecorator_1.binder("btnList")
], UIStoryWin.prototype, "m_btnList", void 0);
exports.UIStoryWin = UIStoryWin;


/***/ }),

/***/ "./src/global/GameConfig.ts":
/*!**********************************!*\
  !*** ./src/global/GameConfig.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.GameConfig = void 0;
class GameConfig {
}
exports.GameConfig = GameConfig;
GameConfig.debug = true;
GameConfig.realmServerIP = "127.0.0.1";
GameConfig.realmServerPort = 9001;


/***/ }),

/***/ "./src/unittest/SingletonTest.ts":
/*!***************************************!*\
  !*** ./src/unittest/SingletonTest.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SingletonTest = void 0;
const Singleton_1 = __webpack_require__(/*! ../framework/common/Singleton */ "./src/framework/common/Singleton.ts");
class SingletonTest extends Singleton_1.Singleton {
    constructor() {
        super();
        this.num = 0;
        console.log("SingletonTest call constructor");
    }
    add() {
        this.num += 1;
    }
    test() {
        return this.num;
    }
}
exports.SingletonTest = SingletonTest;


/***/ }),

/***/ "./src/unittest/UnitTest.ts":
/*!**********************************!*\
  !*** ./src/unittest/UnitTest.ts ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.UnitTest = void 0;
const TimeUtil_1 = __webpack_require__(/*! ../framework/util/TimeUtil */ "./src/framework/util/TimeUtil.ts");
const SingletonTest_1 = __webpack_require__(/*! ./SingletonTest */ "./src/unittest/SingletonTest.ts");
const Messenger_1 = __webpack_require__(/*! ../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
const ResManager_1 = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
const SkillConfig_1 = __webpack_require__(/*! ../data/excel/SkillConfig */ "./src/data/excel/SkillConfig.ts");
const RedHintsMessageManager_1 = __webpack_require__(/*! ../framework/redhints/RedHintsMessageManager */ "./src/framework/redhints/RedHintsMessageManager.ts");
const RedHintsManager_1 = __webpack_require__(/*! ../framework/redhints/RedHintsManager */ "./src/framework/redhints/RedHintsManager.ts");
const inkjs_1 = __webpack_require__(/*! inkjs */ "./node_modules/inkjs/dist/ink-es2015.js");
const pb_1 = __webpack_require__(/*! ../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
class UnitTest {
    static async doTest() {
        console.log("TimeUtil =============================");
        TimeUtil_1.TimeUtil.test();
        console.log("Singleton =============================");
        SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        console.log("===");
        let t1 = SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        let t2 = SingletonTest_1.SingletonTest.Instance(SingletonTest_1.SingletonTest);
        console.log(t1.test() + " : " + t2.test());
        t1.add();
        console.log(t1.test() + " : " + t2.test());
        t2.add();
        console.log(t1.test() + " : " + t2.test());
        console.log("Messager =============================");
        let messenger = new Messenger_1.Messenger();
        let listen = function (a, b) {
            console.log(`listen call: ${a} , ${b}`);
        };
        let listen2 = function (a, b) {
            console.log(`listen call2: ${a} , ${b}`);
        };
        let EVENT_CODE = 100;
        messenger.addListener(EVENT_CODE, this, listen);
        messenger.addListener(EVENT_CODE, this, listen2);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.removeListener(EVENT_CODE, listen);
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        messenger.clearup();
        messenger.broadcast(EVENT_CODE, 999, " Hello");
        console.log("Timer =============================");
        let interval = setInterval(() => {
            console.log("inter val..");
        }, 1000);
        let timeout = setTimeout(() => {
            clearInterval(interval);
        }, 5000);
        console.log("ResourceManager =============================");
        // let prefab = await ResManager.Instance(ResManager).loadPrefab("Models/1001/Character.prefab") ;
        //console.log(prefab);
        //let inst = CS.UnityEngine.GameObject.Instantiate(prefab);
        //inst.name = "Test Ch";
        console.log("引用类型 =============================");
        let testMap = new Map();
        testMap.set("key1", new Array());
        let arr1 = testMap.get("key1");
        arr1.push(12);
        arr1.push(333);
        let arr2 = testMap.get("key1");
        console.log(arr2);
        // Logger.log("FariyGUI =============================");
        //  let page:UI_LoginPage = new UI_LoginPage();
        //  CS.FairyGUI.GRoot.inst.AddChild(page._ui);
        //  Logger.log(page._ui);
        // Logger.log("ModuleManager =============================");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.LoginModule,"create login");
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.LoginModule, "test1",2233);
        // ModuleManager.Instance(ModuleManager).sendMessage(ModuleDef.HomeModule, "test2",2233);
        // Logger.log("then create Home");
        // ModuleManager.Instance(ModuleManager).createModule(ModuleDef.HomeModule,"create login");
        console.log("UIManager =============================");
        console.log("excel data =============================");
        let skillMap = SkillConfig_1.SkillConfigTB.Instance(SkillConfig_1.SkillConfigTB).trs;
        let skilltr = skillMap.get(1003);
        console.log(`${skilltr._Name} : ${skilltr._AttackType}`);
        let impacttype = skilltr._ImpactType;
        console.log(impacttype);
        console.log("Protobuf =============================");
        try {
            let c2rLogin = {
                "Account": "test",
                "Password": "1234"
            };
            //验证
            let v1 = pb_1.nice_ts.C2R_Login.verify(c2rLogin);
            console.log("verify pb: " + v1);
            let msg = pb_1.nice_ts.C2R_Login.create(c2rLogin);
            msg.Account = "test1";
            msg.Password = "1122";
            console.log(msg);
            let buf = pb_1.nice_ts.C2R_Login.encode(msg).finish();
            console.log(buf);
            let de_buf = pb_1.nice_ts.C2R_Login.decode(buf);
            console.log(de_buf.Account);
            console.log(de_buf.Password);
        }
        catch (ex) {
            console.log(ex);
        }
        console.log("UintArray =============================");
        let opcode_arr = new Uint8Array([257, 25]);
        console.log(opcode_arr.subarray(0, 1));
        console.log(opcode_arr.length);
        let opcode_arr2 = new Uint8Array([33]);
        //合并 Uint8Array
        let merge_arr = new Uint8Array(opcode_arr.length + opcode_arr2.length);
        merge_arr.set(opcode_arr2);
        merge_arr.set(opcode_arr, opcode_arr2.length);
        console.log(merge_arr.length);
        let n = 5678;
        let buffer = new Uint8Array(4);
        // << 左移  >> 右移  >>> 无符号右移
        //n转uint8Array
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        //unit8Array转n
        n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        console.log(n);
        n = 300;
        let buffer1 = new Uint8Array(2);
        buffer1[0] = n >>> 8;
        buffer1[1] = n & 0xff;
        console.log(buffer1);
        n = buffer1[0] << 8 | buffer1[1];
        console.log(n);
        console.log("sleep =============================");
        await TimeUtil_1.TimeUtil.sleep(1000);
        console.log("sleep ..end");
        // console.log("flatbuffer =============================");
        // try{
        //     let bytes:ArrayBuffer = await ResManager.Instance(ResManager).loadTextBytes("Config/fb/unitconfig.bytes")
        //     let unitByte = new flatbuffers.ByteBuffer(new Uint8Array(bytes));
        //     console.log(unitByte);
        //     let unitconfig:fb.unitconfigTB = fb.unitconfigTB.getRootAsunitconfigTB(unitByte)
        //     console.log(unitconfig.unitconfigTRSLength());
        //     for(let i=0; i<unitconfig.unitconfigTRSLength(); i++){
        //         let a =  unitconfig.unitconfigTRS(i);
        //         console.log(a.Name());
        //     }
        // }catch(ex){
        //     console.error(ex);
        // }
        try {
            console.log("测试红点系统 =============================");
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat, this, function () {
                console.log("red hints chat...");
            });
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat_family, this, function () {
                console.log("red hints chat_family...");
            });
            RedHintsMessageManager_1.RedHintsMessageManager.Instance(RedHintsMessageManager_1.RedHintsMessageManager).addListener(RedHintsManager_1.enumRedHints.chat_system, this, function () {
                console.log("red hints chat...");
            });
            RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).setRedHintOpenOrClose(RedHintsManager_1.enumRedHints.chat_family, true);
            let r_chat = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat);
            let r_chat_family = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat_family);
            let r_chat_system = RedHintsManager_1.RedHintsManager.Instance(RedHintsManager_1.RedHintsManager).checkRedIsOpen(RedHintsManager_1.enumRedHints.chat_system);
            console.log(r_chat, r_chat_family, r_chat_system);
        }
        catch (error) {
            console.log(error);
        }
        try {
            console.log("Ink Story =============================");
            var json = await (await ResManager_1.ResManager.Instance(ResManager_1.ResManager).loadTextAsset("Story/TestStory.json")).text;
            let story = new inkjs_1.Story(json);
            story.ChoosePathString("story1", true);
            story.BindExternalFunction("GetCharacterName", () => {
                return "Justin Test";
            });
            story.BindExternalFunctionGeneral("GetCharacterNameByMutiParams", (args) => {
                console.log(args.length);
                return "TTTT";
            });
            console.log(story.Continue());
            console.log(story.Continue());
            console.log(story.Continue());
        }
        catch (error) {
            console.log(error);
        }
    }
}
exports.UnitTest = UnitTest;
UnitTest.testVar = 10000;


/***/ }),

/***/ "csharp":
/*!*************************!*\
  !*** external "csharp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("csharp");

/***/ }),

/***/ "puerts":
/*!*************************!*\
  !*** external "puerts" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("puerts");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9kaXN0L2luay1lczIwMTUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DYWxsU3RhY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9DaG9pY2VQb2ludC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0NvbnRyb2xDb21tYW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvRGVidWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9EaXZlcnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9HbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvSW5rTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0pzb25TZXJpYWxpc2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTGlzdERlZmluaXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9MaXN0RGVmaW5pdGlvbnNPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OYXRpdmVGdW5jdGlvbkNhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9OdWxsRXhjZXB0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUFJORy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Qb2ludGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUHVzaFBvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NlYXJjaFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1NpbXBsZUpzb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdGF0ZVBhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcFdhdGNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdG9yeUV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3J5U3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdHJpbmdCdWlsZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVGFnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHJ5R2V0UmVzdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVHlwZUFzc2VydGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhbHVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVBc3NpZ25tZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVSZWZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9WYXJpYWJsZXNTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZvaWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xvbmcvc3JjL2xvbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yZWFkZXJfYnVmZmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9yb290cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMvc2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvR2FtZU1haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvZXhjZWwvU2tpbGxDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvcGIvT3Bjb2RlLnRzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3BiL2dlbi9wYi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9jb21tb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvaG9tZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9sb2dpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9zdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9HYW1lT2JqZWN0UG9vbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtTdGF0ZUluc3BlY3Rvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtXcml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvU3RvcnlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL1N0b3J5TWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvR2FtZVNlc3Npb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvTWVzc2FnZVBhcnNlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL25ldC9OZXRFcnJvckNvZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvU2Vzc2lvbk1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01lc3NhZ2VNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWYudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSURlZmluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJRmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTG9hZGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTXNnQm94LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYW5lbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJV2luZG93LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdXRpbC9UaW1lVXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9hcGkvTG9naW5BUEkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvZXZlbnQvVUlNZXNzYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvc2NlbmUvSG9tZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3VpL1VJSG9tZVBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlTaG9wUGFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS92by9Wb0hvbWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3NjZW5lL0xvZ2luU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJTG9naW5QYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlbFNlcnZlcldpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vdm8vVm9TZXJ2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL3B2ZS9zY2VuZS9QdmVTY2VuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvc3RvcnkvVUlTdG9yeVdpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2xvYmFsL0dhbWVDb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VuaXR0ZXN0L1NpbmdsZXRvblRlc3QudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3VuaXR0ZXN0L1VuaXRUZXN0LnRzIiwid2VicGFjazovLy9leHRlcm5hbCBcImNzaGFycFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcInB1ZXJ0c1wiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRmE7QUFDYjs7QUFFQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxVQUFVO0FBQ1YsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNB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QUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSwwQ0FBMEM7QUFDdkQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5VWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFR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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBLHlDQUF5QyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDbkQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx1QkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsMkJBQTJCLG1DQUFtQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxJQUFJO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQy9jYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNkRBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMsZUFBZSxtQkFBTyxDQUFDLG1EQUFRO0FBQy9CLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQyxpRUFBZTtBQUM3Qyw0QkFBNEIsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDekQsNkJBQTZCLG1CQUFPLENBQUMsK0VBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLCtFQUFzQjtBQUMzRCxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGlEQUFPO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsZ0NBQWdDLG1CQUFPLENBQUMscUZBQXlCO0FBQ2pFLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQW1EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBOEQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNkM7Ozs7Ozs7Ozs7OztBQzdrQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDaEVhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEOzs7Ozs7Ozs7Ozs7QUNyRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHlCQUF5QixtQkFBTyxDQUFDLHVFQUFrQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkMsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pELHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxLQUFLLEVBQUU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0Q0FBNEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQXVEO0FBQzVELENBQUMsNkRBQTZEO0FBQzlELHNDOzs7Ozs7Ozs7Ozs7QUM5V2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0JBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUNBQXVDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxPQUFPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxRQUFRO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx5QkFBeUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOzs7Ozs7Ozs7Ozs7QUM3MEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7Ozs7Ozs7Ozs7OztBQzlCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsdURBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQjs7Ozs7Ozs7Ozs7O0FDZGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esd0M7Ozs7Ozs7Ozs7OztBQ3ZDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJLGtCQUFrQixLQUFLO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDdERhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRCxpQzs7Ozs7Ozs7Ozs7O0FDL1VhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Qzs7Ozs7Ozs7Ozs7O0FDaEJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsbURBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7Ozs7Ozs7Ozs7OztBQ3RDYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELDRCQUE0QixtQkFBTyxDQUFDLDZFQUFxQjtBQUN6RCx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsdUJBQXVCLG1CQUFPLENBQUMsbUVBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsOENBQThDO0FBQy9FLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0IsOENBQThDO0FBQy9FLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FB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a0JBQWtCLEVBQUMsR0FBRSxFQUFFO2dCQUM5QyxPQUFPLGFBQWEsQ0FBQztZQUN6QixDQUFDLENBQUM7WUFDRixLQUFLLENBQUMsMkJBQTJCLENBQUMsOEJBQThCLEVBQUMsQ0FBQyxJQUFPLEVBQUMsRUFBRTtnQkFDeEUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3pCLE9BQU8sTUFBTSxDQUFDO1lBQ2xCLENBQUMsQ0FBQztZQUVGLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDOUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztZQUM5QixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQ2pDO1FBQUEsT0FBTSxLQUFLLEVBQUM7WUFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztTQUNyQjtJQUdMLENBQUM7O0FBL1FMLDRCQW1SQztBQWxSaUIsZ0JBQU8sR0FBVSxLQUFLLENBQUM7Ozs7Ozs7Ozs7OztBQ1p6QyxtQzs7Ozs7Ozs7Ozs7QUNBQSxtQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9HYW1lTWFpbi50c1wiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGFzUHJvbWlzZTtcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayB1dGlsLmFzUHJvbWlzZX0uXHJcbiAqIEB0eXBlZGVmIGFzUHJvbWlzZUNhbGxiYWNrXHJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55XHJcbiAqIEBwYXJhbSB7Li4uKn0gcGFyYW1zIEFkZGl0aW9uYWwgYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBwcm9taXNlIGZyb20gYSBub2RlLXN0eWxlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge2FzUHJvbWlzZUNhbGxiYWNrfSBmbiBGdW5jdGlvbiB0byBjYWxsXHJcbiAqIEBwYXJhbSB7Kn0gY3R4IEZ1bmN0aW9uIGNvbnRleHRcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgRnVuY3Rpb24gYXJndW1lbnRzXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPCo+fSBQcm9taXNpZmllZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gYXNQcm9taXNlKGZuLCBjdHgvKiwgdmFyYXJncyAqLykge1xyXG4gICAgdmFyIHBhcmFtcyAgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgIG9mZnNldCAgPSAwLFxyXG4gICAgICAgIGluZGV4ICAgPSAyLFxyXG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xyXG4gICAgd2hpbGUgKGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aClcclxuICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW2luZGV4KytdO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIHBhcmFtc1tvZmZzZXRdID0gZnVuY3Rpb24gY2FsbGJhY2soZXJyLyosIHZhcmFyZ3MgKi8pIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyYW1zID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAob2Zmc2V0IDwgcGFyYW1zLmxlbmd0aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29mZnNldCsrXSA9IGFyZ3VtZW50c1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkobnVsbCwgcGFyYW1zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm4uYXBwbHkoY3R4IHx8IG51bGwsIHBhcmFtcyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBiYXNlNjQgaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciBiYXNlNjQgPSBleHBvcnRzO1xyXG5cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGJ5dGUgbGVuZ3RoIG9mIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxuYmFzZTY0Lmxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBwID0gc3RyaW5nLmxlbmd0aDtcclxuICAgIGlmICghcClcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciBuID0gMDtcclxuICAgIHdoaWxlICgtLXAgJSA0ID4gMSAmJiBzdHJpbmcuY2hhckF0KHApID09PSBcIj1cIilcclxuICAgICAgICArK247XHJcbiAgICByZXR1cm4gTWF0aC5jZWlsKHN0cmluZy5sZW5ndGggKiAzKSAvIDQgLSBuO1xyXG59O1xyXG5cclxuLy8gQmFzZTY0IGVuY29kaW5nIHRhYmxlXHJcbnZhciBiNjQgPSBuZXcgQXJyYXkoNjQpO1xyXG5cclxuLy8gQmFzZTY0IGRlY29kaW5nIHRhYmxlXHJcbnZhciBzNjQgPSBuZXcgQXJyYXkoMTIzKTtcclxuXHJcbi8vIDY1Li45MCwgOTcuLjEyMiwgNDguLjU3LCA0MywgNDdcclxuZm9yICh2YXIgaSA9IDA7IGkgPCA2NDspXHJcbiAgICBzNjRbYjY0W2ldID0gaSA8IDI2ID8gaSArIDY1IDogaSA8IDUyID8gaSArIDcxIDogaSA8IDYyID8gaSAtIDQgOiBpIC0gNTkgfCA0M10gPSBpKys7XHJcblxyXG4vKipcclxuICogRW5jb2RlcyBhIGJ1ZmZlciB0byBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgZW5jb2RlZCBzdHJpbmdcclxuICovXHJcbmJhc2U2NC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW107XHJcbiAgICB2YXIgaSA9IDAsIC8vIG91dHB1dCBpbmRleFxyXG4gICAgICAgIGogPSAwLCAvLyBnb3RvIGluZGV4XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdmFyIGIgPSBidWZmZXJbc3RhcnQrK107XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbYiA+PiAyXTtcclxuICAgICAgICAgICAgICAgIHQgPSAoYiAmIDMpIDw8IDQ7XHJcbiAgICAgICAgICAgICAgICBqID0gMTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDRdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMTUpIDw8IDI7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W3QgfCBiID4+IDZdO1xyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiICYgNjNdO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqKSB7XHJcbiAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFt0XTtcclxuICAgICAgICBjaHVua1tpKytdID0gNjE7XHJcbiAgICAgICAgaWYgKGogPT09IDEpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG52YXIgaW52YWxpZEVuY29kaW5nID0gXCJpbnZhbGlkIGVuY29kaW5nXCI7XHJcblxyXG4vKipcclxuICogRGVjb2RlcyBhIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlci5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTb3VyY2Ugc3RyaW5nXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIERlc3RpbmF0aW9uIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IERlc3RpbmF0aW9uIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgYnl0ZXMgd3JpdHRlblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgZW5jb2RpbmcgaXMgaW52YWxpZFxyXG4gKi9cclxuYmFzZTY0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShzdHJpbmcsIGJ1ZmZlciwgb2Zmc2V0KSB7XHJcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XHJcbiAgICB2YXIgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7KSB7XHJcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgIGlmIChjID09PSA2MSAmJiBqID4gMSlcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgaWYgKChjID0gczY0W2NdKSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgICAgIHN3aXRjaCAoaikge1xyXG4gICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSB0IDw8IDIgfCAoYyAmIDQ4KSA+PiA0O1xyXG4gICAgICAgICAgICAgICAgdCA9IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMjtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gKHQgJiAxNSkgPDwgNCB8IChjICYgNjApID4+IDI7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDMpIDw8IDYgfCBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkRW5jb2RpbmcpO1xyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgc3RyaW5nIGFwcGVhcnMgdG8gYmUgYmFzZTY0IGVuY29kZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU3RyaW5nIHRvIHRlc3RcclxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBwcm9iYWJseSBiYXNlNjQgZW5jb2RlZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAqL1xyXG5iYXNlNjQudGVzdCA9IGZ1bmN0aW9uIHRlc3Qoc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvLnRlc3Qoc3RyaW5nKTtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSBuZXcgZXZlbnQgZW1pdHRlciBpbnN0YW5jZS5cclxuICogQGNsYXNzZGVzYyBBIG1pbmltYWwgZXZlbnQgZW1pdHRlci5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlcmVkIGxpc3RlbmVycy5cclxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG59XHJcblxyXG4vKipcclxuICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gTGlzdGVuZXJcclxuICogQHBhcmFtIHsqfSBbY3R4XSBMaXN0ZW5lciBjb250ZXh0XHJcbiAqIEByZXR1cm5zIHt1dGlsLkV2ZW50RW1pdHRlcn0gYHRoaXNgXHJcbiAqL1xyXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZ0LCBmbiwgY3R4KSB7XHJcbiAgICAodGhpcy5fbGlzdGVuZXJzW2V2dF0gfHwgKHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW10pKS5wdXNoKHtcclxuICAgICAgICBmbiAgOiBmbixcclxuICAgICAgICBjdHggOiBjdHggfHwgdGhpc1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyIG9yIGFueSBtYXRjaGluZyBsaXN0ZW5lcnMgaWYgYXJndW1lbnRzIGFyZSBvbWl0dGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2V2dF0gRXZlbnQgbmFtZS4gUmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGlmIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtmbl0gTGlzdGVuZXIgdG8gcmVtb3ZlLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgb2YgYGV2dGAgaWYgb21pdHRlZC5cclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmKGV2dCwgZm4pIHtcclxuICAgIGlmIChldnQgPT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChmbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZ0XSA9IFtdO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLmZuID09PSBmbilcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0cyBhbiBldmVudCBieSBjYWxsaW5nIGl0cyBsaXN0ZW5lcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGFyZ3VtZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IGV2dCBFdmVudCBuYW1lXHJcbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZ0KSB7XHJcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2dF07XHJcbiAgICBpZiAobGlzdGVuZXJzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXSxcclxuICAgICAgICAgICAgaSA9IDE7XHJcbiAgICAgICAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOylcclxuICAgICAgICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDspXHJcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaSsrXS5jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGZhY3RvcnkpO1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIC8gd3JpdGVzIGZsb2F0cyAvIGRvdWJsZXMgZnJvbSAvIHRvIGJ1ZmZlcnMuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXRcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgMzIgYml0IGZsb2F0IHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZUZsb2F0QkVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgVGFyZ2V0IGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRhcmdldCBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDMyIGJpdCBmbG9hdCBmcm9tIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC5yZWFkRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgNjQgYml0IGRvdWJsZSB0byBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVEb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgbGl0dGxlIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSA2NCBiaXQgZG91YmxlIGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWREb3VibGVCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFNvdXJjZSBidWZmZXIgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcclxuICovXHJcblxyXG4vLyBGYWN0b3J5IGZ1bmN0aW9uIGZvciB0aGUgcHVycG9zZSBvZiBub2RlLWJhc2VkIHRlc3RpbmcgaW4gbW9kaWZpZWQgZ2xvYmFsIGVudmlyb25tZW50c1xyXG5mdW5jdGlvbiBmYWN0b3J5KGV4cG9ydHMpIHtcclxuXHJcbiAgICAvLyBmbG9hdDogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KFsgLTAgXSksXHJcbiAgICAgICAgICAgIGY4YiA9IG5ldyBVaW50OEFycmF5KGYzMi5idWZmZXIpLFxyXG4gICAgICAgICAgICBsZSAgPSBmOGJbM10gPT09IDEyODtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVGbG9hdF9mMzJfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjMyWzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX2NweSA6IHdyaXRlRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gbGUgPyB3cml0ZUZsb2F0X2YzMl9yZXYgOiB3cml0ZUZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9mMzJfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzJdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgcmV0dXJuIGYzMlswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9jcHkgOiByZWFkRmxvYXRfZjMyX3JldjtcclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZEZsb2F0QkUgPSBsZSA/IHJlYWRGbG9hdF9mMzJfcmV2IDogcmVhZEZsb2F0X2YzMl9jcHk7XHJcblxyXG4gICAgLy8gZmxvYXQ6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2llZWU3NTQod3JpdGVVaW50LCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMSAvIHZhbCA+IDAgPyAvKiBwb3NpdGl2ZSAqLyAwIDogLyogbmVnYXRpdmUgMCAqLyAyMTQ3NDgzNjQ4LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbCkpXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0MzI4OTM0NCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPiAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KSAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCAyMTM5MDk1MDQwKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIGlmICh2YWwgPCAxLjE3NTQ5NDM1MDgyMjI4NzVlLTM4KSAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgTWF0aC5yb3VuZCh2YWwgLyAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUpKSA+Pj4gMCwgYnVmLCBwb3MpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IE1hdGgucm91bmQodmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KSAqIDgzODg2MDgpICYgODM4ODYwNztcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTI3IDw8IDIzIHwgbWFudGlzc2EpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdExFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVGbG9hdEJFID0gd3JpdGVGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUpO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRmxvYXRfaWVlZTc1NChyZWFkVWludCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHVpbnQgPSByZWFkVWludChidWYsIHBvcyksXHJcbiAgICAgICAgICAgICAgICBzaWduID0gKHVpbnQgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IHVpbnQgPj4+IDIzICYgMjU1LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSB1aW50ICYgODM4ODYwNztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyNTVcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogMS40MDEyOTg0NjQzMjQ4MTdlLTQ1ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUwKSAqIChtYW50aXNzYSArIDgzODg2MDgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRMRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IHJlYWRGbG9hdF9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICAvLyBkb3VibGU6IHR5cGVkIGFycmF5XHJcbiAgICBpZiAodHlwZW9mIEZsb2F0NjRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB2YXIgZjY0ID0gbmV3IEZsb2F0NjRBcnJheShbLTBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjY0LmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4Yls3XSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9mNjRfY3B5KHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjY0WzBdID0gdmFsO1xyXG4gICAgICAgICAgICBidWZbcG9zICAgIF0gPSBmOGJbMF07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAxXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDJdID0gZjhiWzJdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgM10gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA0XSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDVdID0gZjhiWzVdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNl0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA3XSA9IGY4Yls3XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9yZXYodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4Yls3XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzZdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4Yls0XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9jcHkgOiB3cml0ZURvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUJFID0gbGUgPyB3cml0ZURvdWJsZV9mNjRfcmV2IDogd3JpdGVEb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfY3B5KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4YlswXSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4YlszXSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4Yls2XSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZERvdWJsZV9mNjRfcmV2KGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY4Yls3XSA9IGJ1Zltwb3MgICAgXTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDFdO1xyXG4gICAgICAgICAgICBmOGJbNV0gPSBidWZbcG9zICsgMl07XHJcbiAgICAgICAgICAgIGY4Yls0XSA9IGJ1Zltwb3MgKyAzXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDRdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgNV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyA2XTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDddO1xyXG4gICAgICAgICAgICByZXR1cm4gZjY0WzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfY3B5IDogcmVhZERvdWJsZV9mNjRfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSBsZSA/IHJlYWREb3VibGVfZjY0X3JldiA6IHJlYWREb3VibGVfZjY0X2NweTtcclxuXHJcbiAgICAvLyBkb3VibGU6IGllZWU3NTRcclxuICAgIH0pKCk7IGVsc2UgKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZURvdWJsZV9pZWVlNzU0KHdyaXRlVWludCwgb2ZmMCwgb2ZmMSwgdmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IHZhbCA8IDAgPyAxIDogMDtcclxuICAgICAgICAgICAgaWYgKHNpZ24pXHJcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4odmFsKSkge1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMjE0Njk1OTM2MCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgPiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCkgeyAvLyArLUluZmluaXR5XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxNDY0MzUwNzIpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hbnRpc3NhO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbCA8IDIuMjI1MDczODU4NTA3MjAxNGUtMzA4KSB7IC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFudGlzc2EgPSB2YWwgLyA1ZS0zMjQ7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IG1hbnRpc3NhIC8gNDI5NDk2NzI5NikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsKSAvIE1hdGguTE4yKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPT09IDEwMjQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gMTAyMztcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAqIE1hdGgucG93KDIsIC1leHBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KG1hbnRpc3NhICogNDUwMzU5OTYyNzM3MDQ5NiA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBleHBvbmVudCArIDEwMjMgPDwgMjAgfCBtYW50aXNzYSAqIDEwNDg1NzYgJiAxMDQ4NTc1KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZURvdWJsZUxFID0gd3JpdGVEb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHdyaXRlVWludExFLCAwLCA0KTtcclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50QkUsIDQsIDApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2llZWU3NTQocmVhZFVpbnQsIG9mZjAsIG9mZjEsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBsbyA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMCksXHJcbiAgICAgICAgICAgICAgICBoaSA9IHJlYWRVaW50KGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gKGhpID4+IDMxKSAqIDIgKyAxLFxyXG4gICAgICAgICAgICAgICAgZXhwb25lbnQgPSBoaSA+Pj4gMjAgJiAyMDQ3LFxyXG4gICAgICAgICAgICAgICAgbWFudGlzc2EgPSA0Mjk0OTY3Mjk2ICogKGhpICYgMTA0ODU3NSkgKyBsbztcclxuICAgICAgICAgICAgcmV0dXJuIGV4cG9uZW50ID09PSAyMDQ3XHJcbiAgICAgICAgICAgICAgICA/IG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA/IE5hTlxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIDogZXhwb25lbnQgPT09IDAgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgID8gc2lnbiAqIDVlLTMyNCAqIG1hbnRpc3NhXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBNYXRoLnBvdygyLCBleHBvbmVudCAtIDEwNzUpICogKG1hbnRpc3NhICsgNDUwMzU5OTYyNzM3MDQ5Nik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVMRSA9IHJlYWREb3VibGVfaWVlZTc1NC5iaW5kKG51bGwsIHJlYWRVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUJFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gZXhwb3J0cztcclxufVxyXG5cclxuLy8gdWludCBoZWxwZXJzXHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRMRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsICAgICAgICAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsID4+PiAyNDtcclxufVxyXG5cclxuZnVuY3Rpb24gd3JpdGVVaW50QkUodmFsLCBidWYsIHBvcykge1xyXG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCA+Pj4gMjQ7XHJcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAyXSA9ICB2YWwgPj4+IDggICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCAgICAgICAgJiAyNTU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50TEUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdXHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCA4XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAyXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10gPDwgMjQpID4+PiAwO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZWFkVWludEJFKGJ1ZiwgcG9zKSB7XHJcbiAgICByZXR1cm4gKGJ1Zltwb3MgICAgXSA8PCAyNFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMV0gPDwgMTZcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDNdKSA+Pj4gMDtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBpbnF1aXJlO1xyXG5cclxuLyoqXHJcbiAqIFJlcXVpcmVzIGEgbW9kdWxlIG9ubHkgaWYgYXZhaWxhYmxlLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZSBNb2R1bGUgdG8gcmVxdWlyZVxyXG4gKiBAcmV0dXJucyB7P09iamVjdH0gUmVxdWlyZWQgbW9kdWxlIGlmIGF2YWlsYWJsZSBhbmQgbm90IGVtcHR5LCBvdGhlcndpc2UgYG51bGxgXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnF1aXJlKG1vZHVsZU5hbWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIG1vZCA9IGV2YWwoXCJxdWlyZVwiLnJlcGxhY2UoL14vLFwicmVcIikpKG1vZHVsZU5hbWUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcclxuICAgICAgICBpZiAobW9kICYmIChtb2QubGVuZ3RoIHx8IE9iamVjdC5rZXlzKG1vZCkubGVuZ3RoKSlcclxuICAgICAgICAgICAgcmV0dXJuIG1vZDtcclxuICAgIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IHBvb2w7XHJcblxyXG4vKipcclxuICogQW4gYWxsb2NhdG9yIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xBbGxvY2F0b3JcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgc2xpY2VyIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwucG9vbH0uXHJcbiAqIEB0eXBlZGVmIFBvb2xTbGljZXJcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU3RhcnQgb2Zmc2V0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gQnVmZmVyIHNsaWNlXHJcbiAqIEB0aGlzIHtVaW50OEFycmF5fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIGdlbmVyYWwgcHVycG9zZSBidWZmZXIgcG9vbC5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7UG9vbEFsbG9jYXRvcn0gYWxsb2MgQWxsb2NhdG9yXHJcbiAqIEBwYXJhbSB7UG9vbFNsaWNlcn0gc2xpY2UgU2xpY2VyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT04MTkyXSBTbGFiIHNpemVcclxuICogQHJldHVybnMge1Bvb2xBbGxvY2F0b3J9IFBvb2xlZCBhbGxvY2F0b3JcclxuICovXHJcbmZ1bmN0aW9uIHBvb2woYWxsb2MsIHNsaWNlLCBzaXplKSB7XHJcbiAgICB2YXIgU0laRSAgID0gc2l6ZSB8fCA4MTkyO1xyXG4gICAgdmFyIE1BWCAgICA9IFNJWkUgPj4+IDE7XHJcbiAgICB2YXIgc2xhYiAgID0gbnVsbDtcclxuICAgIHZhciBvZmZzZXQgPSBTSVpFO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBvb2xfYWxsb2Moc2l6ZSkge1xyXG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gTUFYKVxyXG4gICAgICAgICAgICByZXR1cm4gYWxsb2Moc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCArIHNpemUgPiBTSVpFKSB7XHJcbiAgICAgICAgICAgIHNsYWIgPSBhbGxvYyhTSVpFKTtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IHNsaWNlLmNhbGwoc2xhYiwgb2Zmc2V0LCBvZmZzZXQgKz0gc2l6ZSk7XHJcbiAgICAgICAgaWYgKG9mZnNldCAmIDcpIC8vIGFsaWduIHRvIDMyIGJpdFxyXG4gICAgICAgICAgICBvZmZzZXQgPSAob2Zmc2V0IHwgNykgKyAxO1xyXG4gICAgICAgIHJldHVybiBidWY7XHJcbiAgICB9O1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuLyoqXHJcbiAqIEEgbWluaW1hbCBVVEY4IGltcGxlbWVudGF0aW9uIGZvciBudW1iZXIgYXJyYXlzLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG52YXIgdXRmOCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVVRGOCBieXRlIGxlbmd0aCBvZiBhIHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmdcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZSBsZW5ndGhcclxuICovXHJcbnV0ZjgubGVuZ3RoID0gZnVuY3Rpb24gdXRmOF9sZW5ndGgoc3RyaW5nKSB7XHJcbiAgICB2YXIgbGVuID0gMCxcclxuICAgICAgICBjID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjIDwgMTI4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMTtcclxuICAgICAgICBlbHNlIGlmIChjIDwgMjA0OClcclxuICAgICAgICAgICAgbGVuICs9IDI7XHJcbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweEZDMDApID09PSAweEQ4MDAgJiYgKHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGxlbiArPSA0O1xyXG4gICAgICAgIH0gZWxzZVxyXG4gICAgICAgICAgICBsZW4gKz0gMztcclxuICAgIH1cclxuICAgIHJldHVybiBsZW47XHJcbn07XHJcblxyXG4vKipcclxuICogUmVhZHMgVVRGOCBieXRlcyBhcyBhIHN0cmluZy5cclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgU291cmNlIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgU291cmNlIHN0YXJ0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgU291cmNlIGVuZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgcmVhZFxyXG4gKi9cclxudXRmOC5yZWFkID0gZnVuY3Rpb24gdXRmOF9yZWFkKGJ1ZmZlciwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgaWYgKGxlbiA8IDEpXHJcbiAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICB2YXIgcGFydHMgPSBudWxsLFxyXG4gICAgICAgIGNodW5rID0gW10sXHJcbiAgICAgICAgaSA9IDAsIC8vIGNoYXIgb2Zmc2V0XHJcbiAgICAgICAgdDsgICAgIC8vIHRlbXBvcmFyeVxyXG4gICAgd2hpbGUgKHN0YXJ0IDwgZW5kKSB7XHJcbiAgICAgICAgdCA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBpZiAodCA8IDEyOClcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IHQ7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDE5MSAmJiB0IDwgMjI0KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gKHQgJiAzMSkgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGVsc2UgaWYgKHQgPiAyMzkgJiYgdCA8IDM2NSkge1xyXG4gICAgICAgICAgICB0ID0gKCh0ICYgNykgPDwgMTggfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjMpIC0gMHgxMDAwMDtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4RDgwMCArICh0ID4+IDEwKTtcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDB4REMwMCArICh0ICYgMTAyMyk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDE1KSA8PCAxMiB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgNiB8IGJ1ZmZlcltzdGFydCsrXSAmIDYzO1xyXG4gICAgICAgIGlmIChpID4gODE5MSkge1xyXG4gICAgICAgICAgICAocGFydHMgfHwgKHBhcnRzID0gW10pKS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuaykpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocGFydHMpIHtcclxuICAgICAgICBpZiAoaSlcclxuICAgICAgICAgICAgcGFydHMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpKTtcclxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmsuc2xpY2UoMCwgaSkpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIHN0cmluZyBhcyBVVEY4IGJ5dGVzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGVzIHdyaXR0ZW5cclxuICovXHJcbnV0Zjgud3JpdGUgPSBmdW5jdGlvbiB1dGY4X3dyaXRlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldCxcclxuICAgICAgICBjMSwgLy8gY2hhcmFjdGVyIDFcclxuICAgICAgICBjMjsgLy8gY2hhcmFjdGVyIDJcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYzEgPCAyMDQ4KSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAgICAgIHwgMTkyO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9IGVsc2UgaWYgKChjMSAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoKGMyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4RkMwMCkgPT09IDB4REMwMCkge1xyXG4gICAgICAgICAgICBjMSA9IDB4MTAwMDAgKyAoKGMxICYgMHgwM0ZGKSA8PCAxMCkgKyAoYzIgJiAweDAzRkYpO1xyXG4gICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxOCAgICAgIHwgMjQwO1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gMTIgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAgICAgIHwgMjI0O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9mZnNldCAtIHN0YXJ0O1xyXG59O1xyXG4iLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKCh0PXR8fHNlbGYpLmlua2pzPXt9KX0odGhpcywoZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe2lmKHRoaXMuX2NvbXBvbmVudHM9W10sdGhpcy5fY29tcG9uZW50c1N0cmluZz1udWxsLHRoaXMuX2lzUmVsYXRpdmU9ITEsXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7bGV0IHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcG9uZW50c1N0cmluZz10fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlLkNvbXBvbmVudCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBlKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5fY29tcG9uZW50cy5wdXNoKHQpLHRoaXMuX2NvbXBvbmVudHM9dGhpcy5fY29tcG9uZW50cy5jb25jYXQoZS5fY29tcG9uZW50cyl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtsZXQgdD1hcmd1bWVudHNbMF0sZT0hIWFyZ3VtZW50c1sxXTt0aGlzLl9jb21wb25lbnRzPXRoaXMuX2NvbXBvbmVudHMuY29uY2F0KHQpLHRoaXMuX2lzUmVsYXRpdmU9ZX19Z2V0IGlzUmVsYXRpdmUoKXtyZXR1cm4gdGhpcy5faXNSZWxhdGl2ZX1nZXQgY29tcG9uZW50Q291bnQoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGh9Z2V0IGhlYWQoKXtyZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg+MD90aGlzLl9jb21wb25lbnRzWzBdOm51bGx9Z2V0IHRhaWwoKXtpZih0aGlzLl9jb21wb25lbnRzLmxlbmd0aD49Mil7bGV0IHQ9dGhpcy5fY29tcG9uZW50cy5zbGljZSgxLHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKTtyZXR1cm4gbmV3IGUodCl9cmV0dXJuIGUuc2VsZn1nZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RofWdldCBsYXN0Q29tcG9uZW50KCl7bGV0IHQ9dGhpcy5fY29tcG9uZW50cy5sZW5ndGgtMTtyZXR1cm4gdD49MD90aGlzLl9jb21wb25lbnRzW3RdOm51bGx9Z2V0IGNvbnRhaW5zTmFtZWRDb21wb25lbnQoKXtmb3IobGV0IHQ9MCxlPXRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO3Q8ZTt0KyspaWYoIXRoaXMuX2NvbXBvbmVudHNbdF0uaXNJbmRleClyZXR1cm4hMDtyZXR1cm4hMX1zdGF0aWMgZ2V0IHNlbGYoKXtsZXQgdD1uZXcgZTtyZXR1cm4gdC5faXNSZWxhdGl2ZT0hMCx0fUdldENvbXBvbmVudCh0KXtyZXR1cm4gdGhpcy5fY29tcG9uZW50c1t0XX1QYXRoQnlBcHBlbmRpbmdQYXRoKHQpe2xldCBuPW5ldyBlLGk9MDtmb3IobGV0IGU9MDtlPHQuX2NvbXBvbmVudHMubGVuZ3RoJiZ0Ll9jb21wb25lbnRzW2VdLmlzUGFyZW50OysrZSlpKys7Zm9yKGxldCB0PTA7dDx0aGlzLl9jb21wb25lbnRzLmxlbmd0aC1pOysrdCluLl9jb21wb25lbnRzLnB1c2godGhpcy5fY29tcG9uZW50c1t0XSk7Zm9yKGxldCBlPWk7ZTx0Ll9jb21wb25lbnRzLmxlbmd0aDsrK2Upbi5fY29tcG9uZW50cy5wdXNoKHQuX2NvbXBvbmVudHNbZV0pO3JldHVybiBufWdldCBjb21wb25lbnRzU3RyaW5nKCl7cmV0dXJuIG51bGw9PXRoaXMuX2NvbXBvbmVudHNTdHJpbmcmJih0aGlzLl9jb21wb25lbnRzU3RyaW5nPXRoaXMuX2NvbXBvbmVudHMuam9pbihcIi5cIiksdGhpcy5pc1JlbGF0aXZlJiYodGhpcy5fY29tcG9uZW50c1N0cmluZz1cIi5cIit0aGlzLl9jb21wb25lbnRzU3RyaW5nKSksdGhpcy5fY29tcG9uZW50c1N0cmluZ31zZXQgY29tcG9uZW50c1N0cmluZyh0KXtpZih0aGlzLl9jb21wb25lbnRzLmxlbmd0aD0wLHRoaXMuX2NvbXBvbmVudHNTdHJpbmc9dCxudWxsPT10aGlzLl9jb21wb25lbnRzU3RyaW5nfHxcIlwiPT10aGlzLl9jb21wb25lbnRzU3RyaW5nKXJldHVybjtcIi5cIj09dGhpcy5fY29tcG9uZW50c1N0cmluZ1swXSYmKHRoaXMuX2lzUmVsYXRpdmU9ITAsdGhpcy5fY29tcG9uZW50c1N0cmluZz10aGlzLl9jb21wb25lbnRzU3RyaW5nLnN1YnN0cmluZygxKSk7bGV0IG49dGhpcy5fY29tcG9uZW50c1N0cmluZy5zcGxpdChcIi5cIik7Zm9yKGxldCB0IG9mIG4pL14oXFwtfFxcKyk/KFswLTldK3xJbmZpbml0eSkkLy50ZXN0KHQpP3RoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgZS5Db21wb25lbnQocGFyc2VJbnQodCkpKTp0aGlzLl9jb21wb25lbnRzLnB1c2gobmV3IGUuQ29tcG9uZW50KHQpKX10b1N0cmluZygpe3JldHVybiB0aGlzLmNvbXBvbmVudHNTdHJpbmd9RXF1YWxzKHQpe2lmKG51bGw9PXQpcmV0dXJuITE7aWYodC5fY29tcG9uZW50cy5sZW5ndGghPXRoaXMuX2NvbXBvbmVudHMubGVuZ3RoKXJldHVybiExO2lmKHQuaXNSZWxhdGl2ZSE9dGhpcy5pc1JlbGF0aXZlKXJldHVybiExO2ZvcihsZXQgZT0wLG49dC5fY29tcG9uZW50cy5sZW5ndGg7ZTxuO2UrKylpZighdC5fY29tcG9uZW50c1tlXS5FcXVhbHModGhpcy5fY29tcG9uZW50c1tlXSkpcmV0dXJuITE7cmV0dXJuITB9UGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KHQpe2xldCBuPW5ldyBlO3JldHVybiBuLl9jb21wb25lbnRzLnB1c2guYXBwbHkobi5fY29tcG9uZW50cyx0aGlzLl9jb21wb25lbnRzKSxuLl9jb21wb25lbnRzLnB1c2godCksbn19dmFyIG4saSxyO2Z1bmN0aW9uIGEodCxlKXtyZXR1cm4gdCBpbnN0YW5jZW9mIGU/aCh0KTpudWxsfWZ1bmN0aW9uIHModCxlKXtpZih0IGluc3RhbmNlb2YgZSlyZXR1cm4gaCh0KTt0aHJvdyBuZXcgRXJyb3IoYCR7dH0gaXMgbm90IG9mIHR5cGUgJHtlfWApfWZ1bmN0aW9uIGwodCl7cmV0dXJuIHQuaGFzVmFsaWROYW1lJiZ0Lm5hbWU/dDpudWxsfWZ1bmN0aW9uIG8odCl7cmV0dXJuIHZvaWQgMD09PXQ/bnVsbDp0fWZ1bmN0aW9uIHUodCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuRXF1YWxzfWZ1bmN0aW9uIGgodCxlKXtyZXR1cm4gdH1lLnBhcmVudElkPVwiXlwiLGZ1bmN0aW9uKHQpe2NsYXNzIGV7Y29uc3RydWN0b3IodCl7dGhpcy5pbmRleD0tMSx0aGlzLm5hbWU9bnVsbCxcInN0cmluZ1wiPT10eXBlb2YgdD90aGlzLm5hbWU9dDp0aGlzLmluZGV4PXR9Z2V0IGlzSW5kZXgoKXtyZXR1cm4gdGhpcy5pbmRleD49MH1nZXQgaXNQYXJlbnQoKXtyZXR1cm4gdGhpcy5uYW1lPT10LnBhcmVudElkfXN0YXRpYyBUb1BhcmVudCgpe3JldHVybiBuZXcgZSh0LnBhcmVudElkKX10b1N0cmluZygpe3JldHVybiB0aGlzLmlzSW5kZXg/dGhpcy5pbmRleC50b1N0cmluZygpOnRoaXMubmFtZX1FcXVhbHModCl7cmV0dXJuIG51bGwhPXQmJnQuaXNJbmRleD09dGhpcy5pc0luZGV4JiYodGhpcy5pc0luZGV4P3RoaXMuaW5kZXg9PXQuaW5kZXg6dGhpcy5uYW1lPT10Lm5hbWUpfX10LkNvbXBvbmVudD1lfShlfHwoZT17fSkpLGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUodCxlKXtpZighdCl0aHJvdyB2b2lkIDAhPT1lJiZjb25zb2xlLndhcm4oZSksY29uc29sZS50cmFjZSYmY29uc29sZS50cmFjZSgpLG5ldyBFcnJvcihcIlwiKX10LkFzc2VydFR5cGU9ZnVuY3Rpb24odCxuLGkpe2UodCBpbnN0YW5jZW9mIG4saSl9LHQuQXNzZXJ0PWV9KG58fChuPXt9KSk7Y2xhc3MgYyBleHRlbmRzIEVycm9ye31mdW5jdGlvbiBkKHQpe3Rocm93IG5ldyBjKHQrXCIgaXMgbnVsbCBvciB1bmRlZmluZWRcIil9Y2xhc3MgcHtjb25zdHJ1Y3Rvcigpe3RoaXMucGFyZW50PW51bGwsdGhpcy5fZGVidWdNZXRhZGF0YT1udWxsLHRoaXMuX3BhdGg9bnVsbH1nZXQgZGVidWdNZXRhZGF0YSgpe3JldHVybiBudWxsPT09dGhpcy5fZGVidWdNZXRhZGF0YSYmdGhpcy5wYXJlbnQ/dGhpcy5wYXJlbnQuZGVidWdNZXRhZGF0YTp0aGlzLl9kZWJ1Z01ldGFkYXRhfXNldCBkZWJ1Z01ldGFkYXRhKHQpe3RoaXMuX2RlYnVnTWV0YWRhdGE9dH1nZXQgb3duRGVidWdNZXRhZGF0YSgpe3JldHVybiB0aGlzLl9kZWJ1Z01ldGFkYXRhfURlYnVnTGluZU51bWJlck9mUGF0aCh0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtsZXQgZT10aGlzLnJvb3RDb250ZW50Q29udGFpbmVyO2lmKGUpe2xldCBuPWUuQ29udGVudEF0UGF0aCh0KS5vYmo7aWYobil7bGV0IHQ9bi5kZWJ1Z01ldGFkYXRhO2lmKG51bGwhPT10KXJldHVybiB0LnN0YXJ0TGluZU51bWJlcn19cmV0dXJuIG51bGx9Z2V0IHBhdGgoKXtpZihudWxsPT10aGlzLl9wYXRoKWlmKG51bGw9PXRoaXMucGFyZW50KXRoaXMuX3BhdGg9bmV3IGU7ZWxzZXtsZXQgdD1bXSxuPXRoaXMsaT1hKG4ucGFyZW50LE4pO2Zvcig7bnVsbCE9PWk7KXtsZXQgcj1sKG4pO251bGwhPXImJnIuaGFzVmFsaWROYW1lP3QudW5zaGlmdChuZXcgZS5Db21wb25lbnQoci5uYW1lKSk6dC51bnNoaWZ0KG5ldyBlLkNvbXBvbmVudChpLmNvbnRlbnQuaW5kZXhPZihuKSkpLG49aSxpPWEoaS5wYXJlbnQsTil9dGhpcy5fcGF0aD1uZXcgZSh0KX1yZXR1cm4gdGhpcy5fcGF0aH1SZXNvbHZlUGF0aCh0KXtpZihudWxsPT09dClyZXR1cm4gZChcInBhdGhcIik7aWYodC5pc1JlbGF0aXZlKXtsZXQgZT1hKHRoaXMsTik7cmV0dXJuIG51bGw9PT1lJiYobi5Bc3NlcnQobnVsbCE9PXRoaXMucGFyZW50LFwiQ2FuJ3QgcmVzb2x2ZSByZWxhdGl2ZSBwYXRoIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudFwiKSxlPWEodGhpcy5wYXJlbnQsTiksbi5Bc3NlcnQobnVsbCE9PWUsXCJFeHBlY3RlZCBwYXJlbnQgdG8gYmUgYSBjb250YWluZXJcIiksbi5Bc3NlcnQodC5HZXRDb21wb25lbnQoMCkuaXNQYXJlbnQpLHQ9dC50YWlsKSxudWxsPT09ZT9kKFwibmVhcmVzdENvbnRhaW5lclwiKTplLkNvbnRlbnRBdFBhdGgodCl9e2xldCBlPXRoaXMucm9vdENvbnRlbnRDb250YWluZXI7cmV0dXJuIG51bGw9PT1lP2QoXCJjb250ZW50Q29udGFpbmVyXCIpOmUuQ29udGVudEF0UGF0aCh0KX19Q29udmVydFBhdGhUb1JlbGF0aXZlKHQpe2xldCBuPXRoaXMucGF0aCxpPU1hdGgubWluKHQubGVuZ3RoLG4ubGVuZ3RoKSxyPS0xO2ZvcihsZXQgZT0wO2U8aTsrK2Upe2xldCBpPW4uR2V0Q29tcG9uZW50KGUpLGE9dC5HZXRDb21wb25lbnQoZSk7aWYoIWkuRXF1YWxzKGEpKWJyZWFrO3I9ZX1pZigtMT09cilyZXR1cm4gdDtsZXQgYT1uLmNvbXBvbmVudENvdW50LTEtcixzPVtdO2ZvcihsZXQgdD0wO3Q8YTsrK3Qpcy5wdXNoKGUuQ29tcG9uZW50LlRvUGFyZW50KCkpO2ZvcihsZXQgZT1yKzE7ZTx0LmNvbXBvbmVudENvdW50OysrZSlzLnB1c2godC5HZXRDb21wb25lbnQoZSkpO3JldHVybiBuZXcgZShzLCEwKX1Db21wYWN0UGF0aFN0cmluZyh0KXtsZXQgZT1udWxsLG49bnVsbDtpZih0LmlzUmVsYXRpdmUpbj10LmNvbXBvbmVudHNTdHJpbmcsZT10aGlzLnBhdGguUGF0aEJ5QXBwZW5kaW5nUGF0aCh0KS5jb21wb25lbnRzU3RyaW5nO2Vsc2V7bj10aGlzLkNvbnZlcnRQYXRoVG9SZWxhdGl2ZSh0KS5jb21wb25lbnRzU3RyaW5nLGU9dC5jb21wb25lbnRzU3RyaW5nfXJldHVybiBuLmxlbmd0aDxlLmxlbmd0aD9uOmV9Z2V0IHJvb3RDb250ZW50Q29udGFpbmVyKCl7bGV0IHQ9dGhpcztmb3IoO3QucGFyZW50Oyl0PXQucGFyZW50O3JldHVybiBhKHQsTil9Q29weSgpe3Rocm93IEVycm9yKFwiTm90IEltcGxlbWVudGVkOiBEb2Vzbid0IHN1cHBvcnQgY29weWluZ1wiKX1TZXRDaGlsZCh0LGUsbil7dFtlXSYmKHRbZV09bnVsbCksdFtlXT1uLHRbZV0mJih0W2VdLnBhcmVudD10aGlzKX19Y2xhc3MgbXtjb25zdHJ1Y3Rvcih0KXt0PXZvaWQgMCE9PXQ/dC50b1N0cmluZygpOlwiXCIsdGhpcy5zdHJpbmc9dH1nZXQgTGVuZ3RoKCl7cmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aH1BcHBlbmQodCl7bnVsbCE9PXQmJih0aGlzLnN0cmluZys9dCl9QXBwZW5kTGluZSh0KXt2b2lkIDAhPT10JiZ0aGlzLkFwcGVuZCh0KSx0aGlzLnN0cmluZys9XCJcXG5cIn1BcHBlbmRGb3JtYXQodCwuLi5lKXt0aGlzLnN0cmluZys9dC5yZXBsYWNlKC97KFxcZCspfS9nLCh0LG4pPT52b2lkIDAhPT1lW25dP2Vbbl06dCl9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5zdHJpbmd9fWNsYXNzIGZ7Y29uc3RydWN0b3IoKXtpZih0aGlzLm9yaWdpbk5hbWU9bnVsbCx0aGlzLml0ZW1OYW1lPW51bGwsdm9pZCAwIT09YXJndW1lbnRzWzFdKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5vcmlnaW5OYW1lPXQsdGhpcy5pdGVtTmFtZT1lfWVsc2UgaWYoYXJndW1lbnRzWzBdKXtsZXQgdD1hcmd1bWVudHNbMF0udG9TdHJpbmcoKS5zcGxpdChcIi5cIik7dGhpcy5vcmlnaW5OYW1lPXRbMF0sdGhpcy5pdGVtTmFtZT10WzFdfX1zdGF0aWMgZ2V0IE51bGwoKXtyZXR1cm4gbmV3IGYobnVsbCxudWxsKX1nZXQgaXNOdWxsKCl7cmV0dXJuIG51bGw9PXRoaXMub3JpZ2luTmFtZSYmbnVsbD09dGhpcy5pdGVtTmFtZX1nZXQgZnVsbE5hbWUoKXtyZXR1cm4obnVsbCE9PXRoaXMub3JpZ2luTmFtZT90aGlzLm9yaWdpbk5hbWU6XCI/XCIpK1wiLlwiK3RoaXMuaXRlbU5hbWV9dG9TdHJpbmcoKXtyZXR1cm4gdGhpcy5mdWxsTmFtZX1FcXVhbHModCl7aWYodCBpbnN0YW5jZW9mIGYpe2xldCBlPXQ7cmV0dXJuIGUuaXRlbU5hbWU9PXRoaXMuaXRlbU5hbWUmJmUub3JpZ2luTmFtZT09dGhpcy5vcmlnaW5OYW1lfXJldHVybiExfWNvcHkoKXtyZXR1cm4gbmV3IGYodGhpcy5vcmlnaW5OYW1lLHRoaXMuaXRlbU5hbWUpfXNlcmlhbGl6ZWQoKXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoe29yaWdpbk5hbWU6dGhpcy5vcmlnaW5OYW1lLGl0ZW1OYW1lOnRoaXMuaXRlbU5hbWV9KX1zdGF0aWMgZnJvbVNlcmlhbGl6ZWRLZXkodCl7bGV0IGU9SlNPTi5wYXJzZSh0KTtpZighZi5pc0xpa2VJbmtMaXN0SXRlbShlKSlyZXR1cm4gZi5OdWxsO2xldCBuPWU7cmV0dXJuIG5ldyBmKG4ub3JpZ2luTmFtZSxuLml0ZW1OYW1lKX1zdGF0aWMgaXNMaWtlSW5rTGlzdEl0ZW0odCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIHQmJighKCF0Lmhhc093blByb3BlcnR5KFwib3JpZ2luTmFtZVwiKXx8IXQuaGFzT3duUHJvcGVydHkoXCJpdGVtTmFtZVwiKSkmJigoXCJzdHJpbmdcIj09dHlwZW9mIHQub3JpZ2luTmFtZXx8bnVsbD09PXR5cGVvZiB0Lm9yaWdpbk5hbWUpJiYoXCJzdHJpbmdcIj09dHlwZW9mIHQuaXRlbU5hbWV8fG51bGw9PT10eXBlb2YgdC5pdGVtTmFtZSkpKX19Y2xhc3MgZyBleHRlbmRzIE1hcHtjb25zdHJ1Y3Rvcigpe2lmKHN1cGVyKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZz9hcmd1bWVudHNbMF06W10pLHRoaXMub3JpZ2lucz1udWxsLHRoaXMuX29yaWdpbk5hbWVzPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7bGV0IHQ9YXJndW1lbnRzWzBdO3QuX29yaWdpbk5hbWVzJiYodGhpcy5fb3JpZ2luTmFtZXM9dC5fb3JpZ2luTmFtZXMuc2xpY2UoKSl9ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXtsZXQgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5TZXRJbml0aWFsT3JpZ2luTmFtZSh0KTtsZXQgbj1lLmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbih0LG51bGwpO2lmKCFuLmV4aXN0cyl0aHJvdyBuZXcgRXJyb3IoXCJJbmtMaXN0IG9yaWdpbiBjb3VsZCBub3QgYmUgZm91bmQgaW4gc3Rvcnkgd2hlbiBjb25zdHJ1Y3RpbmcgbmV3IGxpc3Q6IFwiK3QpO3RoaXMub3JpZ2lucz1bbi5yZXN1bHRdfWVsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiS2V5XCIpJiZhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoXCJWYWx1ZVwiKSl7bGV0IHQ9YXJndW1lbnRzWzBdO3RoaXMuQWRkKHQuS2V5LHQuVmFsdWUpfX1BZGRJdGVtKHQpe2lmKHQgaW5zdGFuY2VvZiBmKXtsZXQgZT10O2lmKG51bGw9PWUub3JpZ2luTmFtZSlyZXR1cm4gdm9pZCB0aGlzLkFkZEl0ZW0oZS5pdGVtTmFtZSk7aWYobnVsbD09PXRoaXMub3JpZ2lucylyZXR1cm4gZChcInRoaXMub3JpZ2luc1wiKTtmb3IobGV0IHQgb2YgdGhpcy5vcmlnaW5zKWlmKHQubmFtZT09ZS5vcmlnaW5OYW1lKXtsZXQgbj10LlRyeUdldFZhbHVlRm9ySXRlbShlLDApO2lmKG4uZXhpc3RzKXJldHVybiB2b2lkIHRoaXMuQWRkKGUsbi5yZXN1bHQpO3Rocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIrZStcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBsaXN0IGRlZmluaXRpb24gaW4gaW5rLlwiKX10aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYWRkIGl0ZW0gdG8gbGlzdCBiZWNhdXNlIHRoZSBpdGVtIHdhcyBmcm9tIGEgbmV3IGxpc3QgZGVmaW5pdGlvbiB0aGF0IHdhc24ndCBwcmV2aW91c2x5IGtub3duIHRvIHRoaXMgbGlzdC4gT25seSBpdGVtcyBmcm9tIHByZXZpb3VzbHkga25vd24gbGlzdHMgY2FuIGJlIHVzZWQsIHNvIHRoYXQgdGhlIGludCB2YWx1ZSBjYW4gYmUgZm91bmQuXCIpfXtsZXQgZT10LG49bnVsbDtpZihudWxsPT09dGhpcy5vcmlnaW5zKXJldHVybiBkKFwidGhpcy5vcmlnaW5zXCIpO2ZvcihsZXQgdCBvZiB0aGlzLm9yaWdpbnMpe2lmKG51bGw9PT1lKXJldHVybiBkKFwiaXRlbU5hbWVcIik7aWYodC5Db250YWluc0l0ZW1XaXRoTmFtZShlKSl7aWYobnVsbCE9bil0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiK2UrXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgY291bGQgY29tZSBmcm9tIGVpdGhlciBcIit0Lm5hbWUrXCIgb3IgXCIrbi5uYW1lKTtuPXR9fWlmKG51bGw9PW4pdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIitlK1wiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGlzbid0IGtub3duIHRvIGFueSBsaXN0IGRlZmluaXRpb25zIHByZXZpb3VzbHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGlzdC5cIik7bGV0IGk9bmV3IGYobi5uYW1lLGUpLHI9bi5WYWx1ZUZvckl0ZW0oaSk7dGhpcy5BZGQoaSxyKX19Q29udGFpbnNJdGVtTmFtZWQodCl7Zm9yKGxldFtlXW9mIHRoaXMpe2lmKGYuZnJvbVNlcmlhbGl6ZWRLZXkoZSkuaXRlbU5hbWU9PXQpcmV0dXJuITB9cmV0dXJuITF9Q29udGFpbnNLZXkodCl7cmV0dXJuIHRoaXMuaGFzKHQuc2VyaWFsaXplZCgpKX1BZGQodCxlKXtsZXQgbj10LnNlcmlhbGl6ZWQoKTtpZih0aGlzLmhhcyhuKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgTWFwIGFscmVhZHkgY29udGFpbnMgYW4gZW50cnkgZm9yIFwiK3QpO3RoaXMuc2V0KG4sZSl9UmVtb3ZlKHQpe3JldHVybiB0aGlzLmRlbGV0ZSh0LnNlcmlhbGl6ZWQoKSl9Z2V0IENvdW50KCl7cmV0dXJuIHRoaXMuc2l6ZX1nZXQgb3JpZ2luT2ZNYXhJdGVtKCl7aWYobnVsbD09dGhpcy5vcmlnaW5zKXJldHVybiBudWxsO2xldCB0PXRoaXMubWF4SXRlbS5LZXkub3JpZ2luTmFtZSxlPW51bGw7cmV0dXJuIHRoaXMub3JpZ2lucy5ldmVyeShuPT5uLm5hbWUhPXR8fChlPW4sITEpKSxlfWdldCBvcmlnaW5OYW1lcygpe2lmKHRoaXMuQ291bnQ+MCl7bnVsbD09dGhpcy5fb3JpZ2luTmFtZXMmJnRoaXMuQ291bnQ+MD90aGlzLl9vcmlnaW5OYW1lcz1bXToodGhpcy5fb3JpZ2luTmFtZXN8fCh0aGlzLl9vcmlnaW5OYW1lcz1bXSksdGhpcy5fb3JpZ2luTmFtZXMubGVuZ3RoPTApO2ZvcihsZXRbdF1vZiB0aGlzKXtsZXQgZT1mLmZyb21TZXJpYWxpemVkS2V5KHQpO2lmKG51bGw9PT1lLm9yaWdpbk5hbWUpcmV0dXJuIGQoXCJpdGVtLm9yaWdpbk5hbWVcIik7dGhpcy5fb3JpZ2luTmFtZXMucHVzaChlLm9yaWdpbk5hbWUpfX1yZXR1cm4gdGhpcy5fb3JpZ2luTmFtZXN9U2V0SW5pdGlhbE9yaWdpbk5hbWUodCl7dGhpcy5fb3JpZ2luTmFtZXM9W3RdfVNldEluaXRpYWxPcmlnaW5OYW1lcyh0KXt0aGlzLl9vcmlnaW5OYW1lcz1udWxsPT10P251bGw6dC5zbGljZSgpfWdldCBtYXhJdGVtKCl7bGV0IHQ9e0tleTpmLk51bGwsVmFsdWU6MH07Zm9yKGxldFtlLG5db2YgdGhpcyl7bGV0IGk9Zi5mcm9tU2VyaWFsaXplZEtleShlKTsodC5LZXkuaXNOdWxsfHxuPnQuVmFsdWUpJiYodD17S2V5OmksVmFsdWU6bn0pfXJldHVybiB0fWdldCBtaW5JdGVtKCl7bGV0IHQ9e0tleTpmLk51bGwsVmFsdWU6MH07Zm9yKGxldFtlLG5db2YgdGhpcyl7bGV0IGk9Zi5mcm9tU2VyaWFsaXplZEtleShlKTsodC5LZXkuaXNOdWxsfHxuPHQuVmFsdWUpJiYodD17S2V5OmksVmFsdWU6bn0pfXJldHVybiB0fWdldCBpbnZlcnNlKCl7bGV0IHQ9bmV3IGc7aWYobnVsbCE9dGhpcy5vcmlnaW5zKWZvcihsZXQgZSBvZiB0aGlzLm9yaWdpbnMpZm9yKGxldFtuLGldb2YgZS5pdGVtcyl7bGV0IGU9Zi5mcm9tU2VyaWFsaXplZEtleShuKTt0aGlzLkNvbnRhaW5zS2V5KGUpfHx0LkFkZChlLGkpfXJldHVybiB0fWdldCBhbGwoKXtsZXQgdD1uZXcgZztpZihudWxsIT10aGlzLm9yaWdpbnMpZm9yKGxldCBlIG9mIHRoaXMub3JpZ2lucylmb3IobGV0W24saV1vZiBlLml0ZW1zKXtsZXQgZT1mLmZyb21TZXJpYWxpemVkS2V5KG4pO3Quc2V0KGUuc2VyaWFsaXplZCgpLGkpfXJldHVybiB0fVVuaW9uKHQpe2xldCBlPW5ldyBnKHRoaXMpO2ZvcihsZXRbbixpXW9mIHQpZS5zZXQobixpKTtyZXR1cm4gZX1JbnRlcnNlY3QodCl7bGV0IGU9bmV3IGc7Zm9yKGxldFtuLGldb2YgdGhpcyl0LmhhcyhuKSYmZS5zZXQobixpKTtyZXR1cm4gZX1XaXRob3V0KHQpe2xldCBlPW5ldyBnKHRoaXMpO2ZvcihsZXRbbl1vZiB0KWUuZGVsZXRlKG4pO3JldHVybiBlfUNvbnRhaW5zKHQpe2ZvcihsZXRbZV1vZiB0KWlmKCF0aGlzLmhhcyhlKSlyZXR1cm4hMTtyZXR1cm4hMH1HcmVhdGVyVGhhbih0KXtyZXR1cm4gMCE9dGhpcy5Db3VudCYmKDA9PXQuQ291bnR8fHRoaXMubWluSXRlbS5WYWx1ZT50Lm1heEl0ZW0uVmFsdWUpfUdyZWF0ZXJUaGFuT3JFcXVhbHModCl7cmV0dXJuIDAhPXRoaXMuQ291bnQmJigwPT10LkNvdW50fHx0aGlzLm1pbkl0ZW0uVmFsdWU+PXQubWluSXRlbS5WYWx1ZSYmdGhpcy5tYXhJdGVtLlZhbHVlPj10Lm1heEl0ZW0uVmFsdWUpfUxlc3NUaGFuKHQpe3JldHVybiAwIT10LkNvdW50JiYoMD09dGhpcy5Db3VudHx8dGhpcy5tYXhJdGVtLlZhbHVlPHQubWluSXRlbS5WYWx1ZSl9TGVzc1RoYW5PckVxdWFscyh0KXtyZXR1cm4gMCE9dC5Db3VudCYmKDA9PXRoaXMuQ291bnR8fHRoaXMubWF4SXRlbS5WYWx1ZTw9dC5tYXhJdGVtLlZhbHVlJiZ0aGlzLm1pbkl0ZW0uVmFsdWU8PXQubWluSXRlbS5WYWx1ZSl9TWF4QXNMaXN0KCl7cmV0dXJuIHRoaXMuQ291bnQ+MD9uZXcgZyh0aGlzLm1heEl0ZW0pOm5ldyBnfU1pbkFzTGlzdCgpe3JldHVybiB0aGlzLkNvdW50PjA/bmV3IGcodGhpcy5taW5JdGVtKTpuZXcgZ31MaXN0V2l0aFN1YlJhbmdlKHQsZSl7aWYoMD09dGhpcy5Db3VudClyZXR1cm4gbmV3IGc7bGV0IG49dGhpcy5vcmRlcmVkSXRlbXMsaT0wLHI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7TnVtYmVyLmlzSW50ZWdlcih0KT9pPXQ6dCBpbnN0YW5jZW9mIGcmJnQuQ291bnQ+MCYmKGk9dC5taW5JdGVtLlZhbHVlKSxOdW1iZXIuaXNJbnRlZ2VyKGUpP3I9ZTp0IGluc3RhbmNlb2YgZyYmdC5Db3VudD4wJiYocj1lLm1heEl0ZW0uVmFsdWUpO2xldCBhPW5ldyBnO2EuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKHRoaXMub3JpZ2luTmFtZXMpO2ZvcihsZXQgdCBvZiBuKXQuVmFsdWU+PWkmJnQuVmFsdWU8PXImJmEuQWRkKHQuS2V5LHQuVmFsdWUpO3JldHVybiBhfUVxdWFscyh0KXtpZih0IGluc3RhbmNlb2YgZz09ITEpcmV0dXJuITE7aWYodC5Db3VudCE9dGhpcy5Db3VudClyZXR1cm4hMTtmb3IobGV0W2Vdb2YgdGhpcylpZighdC5oYXMoZSkpcmV0dXJuITE7cmV0dXJuITB9Z2V0IG9yZGVyZWRJdGVtcygpe2xldCB0PW5ldyBBcnJheTtmb3IobGV0W2Usbl1vZiB0aGlzKXtsZXQgaT1mLmZyb21TZXJpYWxpemVkS2V5KGUpO3QucHVzaCh7S2V5OmksVmFsdWU6bn0pfXJldHVybiB0LnNvcnQoKHQsZSk9Pm51bGw9PT10LktleS5vcmlnaW5OYW1lP2QoXCJ4LktleS5vcmlnaW5OYW1lXCIpOm51bGw9PT1lLktleS5vcmlnaW5OYW1lP2QoXCJ5LktleS5vcmlnaW5OYW1lXCIpOnQuVmFsdWU9PWUuVmFsdWU/dC5LZXkub3JpZ2luTmFtZS5sb2NhbGVDb21wYXJlKGUuS2V5Lm9yaWdpbk5hbWUpOnQuVmFsdWU8ZS5WYWx1ZT8tMTp0LlZhbHVlPmUuVmFsdWU/MTowKSx0fXRvU3RyaW5nKCl7bGV0IHQ9dGhpcy5vcmRlcmVkSXRlbXMsZT1uZXcgbTtmb3IobGV0IG49MDtuPHQubGVuZ3RoO24rKyl7bj4wJiZlLkFwcGVuZChcIiwgXCIpO2xldCBpPXRbbl0uS2V5O2lmKG51bGw9PT1pLml0ZW1OYW1lKXJldHVybiBkKFwiaXRlbS5pdGVtTmFtZVwiKTtlLkFwcGVuZChpLml0ZW1OYW1lKX1yZXR1cm4gZS50b1N0cmluZygpfXZhbHVlT2YoKXtyZXR1cm4gTmFOfX1jbGFzcyBTIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpcy51c2VFbmRMaW5lTnVtYmVyPSExLHRoaXMubWVzc2FnZT10LHRoaXMubmFtZT1cIlN0b3J5RXhjZXB0aW9uXCJ9fWZ1bmN0aW9uIHkodCxlLG4pe2lmKG51bGw9PT10KXJldHVybntyZXN1bHQ6bixleGlzdHM6ITF9O2xldCBpPXQuZ2V0KGUpO3JldHVybiB2b2lkIDA9PT1pP3tyZXN1bHQ6bixleGlzdHM6ITF9OntyZXN1bHQ6aSxleGlzdHM6ITB9fWNsYXNzIEMgZXh0ZW5kcyBwe3N0YXRpYyBDcmVhdGUodCxuKXtpZihuKXtpZihuPT09aS5JbnQmJk51bWJlci5pc0ludGVnZXIoTnVtYmVyKHQpKSlyZXR1cm4gbmV3IGIoTnVtYmVyKHQpKTtpZihuPT09aS5GbG9hdCYmIWlzTmFOKHQpKXJldHVybiBuZXcgXyhOdW1iZXIodCkpfWlmKFwiYm9vbGVhblwiPT10eXBlb2YgdCl7dD0hIXQ/MTowfXJldHVyblwic3RyaW5nXCI9PXR5cGVvZiB0P25ldyBUKFN0cmluZyh0KSk6TnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodCkpP25ldyBiKE51bWJlcih0KSk6aXNOYU4odCk/dCBpbnN0YW5jZW9mIGU/bmV3IFAocyh0LGUpKTp0IGluc3RhbmNlb2YgZz9uZXcgTyhzKHQsZykpOm51bGw6bmV3IF8oTnVtYmVyKHQpKX1Db3B5KCl7cmV0dXJuIHMoQy5DcmVhdGUodGhpcykscCl9QmFkQ2FzdEV4Y2VwdGlvbih0KXtyZXR1cm4gbmV3IFMoXCJDYW4ndCBjYXN0IFwiK3RoaXMudmFsdWVPYmplY3QrXCIgZnJvbSBcIit0aGlzLnZhbHVlVHlwZStcIiB0byBcIit0KX19Y2xhc3MgdiBleHRlbmRzIEN7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnZhbHVlPXR9Z2V0IHZhbHVlT2JqZWN0KCl7cmV0dXJuIHRoaXMudmFsdWV9dG9TdHJpbmcoKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWU/ZChcIlZhbHVlLnZhbHVlXCIpOnRoaXMudmFsdWUudG9TdHJpbmcoKX19Y2xhc3MgYiBleHRlbmRzIHZ7Y29uc3RydWN0b3IodCl7c3VwZXIodHx8MCl9Z2V0IGlzVHJ1dGh5KCl7cmV0dXJuIDAhPXRoaXMudmFsdWV9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLkludH1DYXN0KHQpe2lmKG51bGw9PT10aGlzLnZhbHVlKXJldHVybiBkKFwiVmFsdWUudmFsdWVcIik7aWYodD09dGhpcy52YWx1ZVR5cGUpcmV0dXJuIHRoaXM7aWYodD09aS5GbG9hdClyZXR1cm4gbmV3IF8odGhpcy52YWx1ZSk7aWYodD09aS5TdHJpbmcpcmV0dXJuIG5ldyBUKFwiXCIrdGhpcy52YWx1ZSk7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfX1jbGFzcyBfIGV4dGVuZHMgdntjb25zdHJ1Y3Rvcih0KXtzdXBlcih0fHwwKX1nZXQgaXNUcnV0aHkoKXtyZXR1cm4gMCE9dGhpcy52YWx1ZX1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuRmxvYXR9Q2FzdCh0KXtpZihudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gZChcIlZhbHVlLnZhbHVlXCIpO2lmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO2lmKHQ9PWkuSW50KXJldHVybiBuZXcgYih0aGlzLnZhbHVlKTtpZih0PT1pLlN0cmluZylyZXR1cm4gbmV3IFQoXCJcIit0aGlzLnZhbHVlKTt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9fWNsYXNzIFQgZXh0ZW5kcyB2e2NvbnN0cnVjdG9yKHQpe2lmKHN1cGVyKHR8fFwiXCIpLHRoaXMuX2lzTmV3bGluZT1cIlxcblwiPT10aGlzLnZhbHVlLHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZT0hMCxudWxsPT09dGhpcy52YWx1ZSlyZXR1cm4gZChcIlZhbHVlLnZhbHVlXCIpO3RoaXMudmFsdWUubGVuZ3RoPjAmJnRoaXMudmFsdWUuc3BsaXQoXCJcIikuZXZlcnkodD0+XCIgXCI9PXR8fFwiXFx0XCI9PXR8fCh0aGlzLl9pc0lubGluZVdoaXRlc3BhY2U9ITEsITEpKX1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuU3RyaW5nfWdldCBpc1RydXRoeSgpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZT9kKFwiVmFsdWUudmFsdWVcIik6dGhpcy52YWx1ZS5sZW5ndGg+MH1nZXQgaXNOZXdsaW5lKCl7cmV0dXJuIHRoaXMuX2lzTmV3bGluZX1nZXQgaXNJbmxpbmVXaGl0ZXNwYWNlKCl7cmV0dXJuIHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZX1nZXQgaXNOb25XaGl0ZXNwYWNlKCl7cmV0dXJuIXRoaXMuaXNOZXdsaW5lJiYhdGhpcy5pc0lubGluZVdoaXRlc3BhY2V9Q2FzdCh0KXtpZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpcztpZih0PT1pLkludCl7bGV0IGU9ZnVuY3Rpb24odCxlPTApe2xldCBuPXBhcnNlSW50KHQpO3JldHVybiBOdW1iZXIuaXNOYU4obik/e3Jlc3VsdDplLGV4aXN0czohMX06e3Jlc3VsdDpuLGV4aXN0czohMH19KHRoaXMudmFsdWUpO2lmKGUuZXhpc3RzKXJldHVybiBuZXcgYihlLnJlc3VsdCk7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfWlmKHQ9PWkuRmxvYXQpe2xldCBlPWZ1bmN0aW9uKHQsZT0wKXtsZXQgbj1wYXJzZUZsb2F0KHQpO3JldHVybiBOdW1iZXIuaXNOYU4obik/e3Jlc3VsdDplLGV4aXN0czohMX06e3Jlc3VsdDpuLGV4aXN0czohMH19KHRoaXMudmFsdWUpO2lmKGUuZXhpc3RzKXJldHVybiBuZXcgXyhlLnJlc3VsdCk7dGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKHQpfXRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX19Y2xhc3MgUCBleHRlbmRzIHZ7Y29uc3RydWN0b3IodCl7c3VwZXIodCl9Z2V0IHZhbHVlVHlwZSgpe3JldHVybiBpLkRpdmVydFRhcmdldH1nZXQgdGFyZ2V0UGF0aCgpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZT9kKFwiVmFsdWUudmFsdWVcIik6dGhpcy52YWx1ZX1zZXQgdGFyZ2V0UGF0aCh0KXt0aGlzLnZhbHVlPXR9Z2V0IGlzVHJ1dGh5KCl7dGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkbid0IGJlIGNoZWNraW5nIHRoZSB0cnV0aGluZXNzIG9mIGEgZGl2ZXJ0IHRhcmdldFwiKX1DYXN0KHQpe2lmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX10b1N0cmluZygpe3JldHVyblwiRGl2ZXJ0VGFyZ2V0VmFsdWUoXCIrdGhpcy50YXJnZXRQYXRoK1wiKVwifX1jbGFzcyB3IGV4dGVuZHMgdntjb25zdHJ1Y3Rvcih0LGU9LTEpe3N1cGVyKHQpLHRoaXMuX2NvbnRleHRJbmRleD1lfWdldCBjb250ZXh0SW5kZXgoKXtyZXR1cm4gdGhpcy5fY29udGV4dEluZGV4fXNldCBjb250ZXh0SW5kZXgodCl7dGhpcy5fY29udGV4dEluZGV4PXR9Z2V0IHZhcmlhYmxlTmFtZSgpe3JldHVybiBudWxsPT09dGhpcy52YWx1ZT9kKFwiVmFsdWUudmFsdWVcIik6dGhpcy52YWx1ZX1zZXQgdmFyaWFibGVOYW1lKHQpe3RoaXMudmFsdWU9dH1nZXQgdmFsdWVUeXBlKCl7cmV0dXJuIGkuVmFyaWFibGVQb2ludGVyfWdldCBpc1RydXRoeSgpe3Rocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIHZhcmlhYmxlIHBvaW50ZXJcIil9Q2FzdCh0KXtpZih0PT10aGlzLnZhbHVlVHlwZSlyZXR1cm4gdGhpczt0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24odCl9dG9TdHJpbmcoKXtyZXR1cm5cIlZhcmlhYmxlUG9pbnRlclZhbHVlKFwiK3RoaXMudmFyaWFibGVOYW1lK1wiKVwifUNvcHkoKXtyZXR1cm4gbmV3IHcodGhpcy52YXJpYWJsZU5hbWUsdGhpcy5jb250ZXh0SW5kZXgpfX1jbGFzcyBPIGV4dGVuZHMgdntnZXQgaXNUcnV0aHkoKXtyZXR1cm4gbnVsbD09PXRoaXMudmFsdWU/ZChcInRoaXMudmFsdWVcIik6dGhpcy52YWx1ZS5Db3VudD4wfWdldCB2YWx1ZVR5cGUoKXtyZXR1cm4gaS5MaXN0fUNhc3QodCl7aWYobnVsbD09PXRoaXMudmFsdWUpcmV0dXJuIGQoXCJWYWx1ZS52YWx1ZVwiKTtpZih0PT1pLkludCl7bGV0IHQ9dGhpcy52YWx1ZS5tYXhJdGVtO3JldHVybiB0LktleS5pc051bGw/bmV3IGIoMCk6bmV3IGIodC5WYWx1ZSl9aWYodD09aS5GbG9hdCl7bGV0IHQ9dGhpcy52YWx1ZS5tYXhJdGVtO3JldHVybiB0LktleS5pc051bGw/bmV3IF8oMCk6bmV3IF8odC5WYWx1ZSl9aWYodD09aS5TdHJpbmcpe2xldCB0PXRoaXMudmFsdWUubWF4SXRlbTtyZXR1cm4gdC5LZXkuaXNOdWxsP25ldyBUKFwiXCIpOm5ldyBUKHQuS2V5LnRvU3RyaW5nKCkpfWlmKHQ9PXRoaXMudmFsdWVUeXBlKXJldHVybiB0aGlzO3Rocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbih0KX1jb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKG51bGwpLHR8fGU/dCBpbnN0YW5jZW9mIGc/dGhpcy52YWx1ZT1uZXcgZyh0KTp0IGluc3RhbmNlb2YgZiYmXCJudW1iZXJcIj09dHlwZW9mIGUmJih0aGlzLnZhbHVlPW5ldyBnKHtLZXk6dCxWYWx1ZTplfSkpOnRoaXMudmFsdWU9bmV3IGd9c3RhdGljIFJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudCh0LGUpe2xldCBuPWEodCxPKSxpPWEoZSxPKTtyZXR1cm4gaSYmbnVsbD09PWkudmFsdWU/ZChcIm5ld0xpc3QudmFsdWVcIik6biYmbnVsbD09PW4udmFsdWU/ZChcIm9sZExpc3QudmFsdWVcIik6dm9pZChuJiZpJiYwPT1pLnZhbHVlLkNvdW50JiZpLnZhbHVlLlNldEluaXRpYWxPcmlnaW5OYW1lcyhuLnZhbHVlLm9yaWdpbk5hbWVzKSl9fSFmdW5jdGlvbih0KXt0W3QuSW50PTBdPVwiSW50XCIsdFt0LkZsb2F0PTFdPVwiRmxvYXRcIix0W3QuTGlzdD0yXT1cIkxpc3RcIix0W3QuU3RyaW5nPTNdPVwiU3RyaW5nXCIsdFt0LkRpdmVydFRhcmdldD00XT1cIkRpdmVydFRhcmdldFwiLHRbdC5WYXJpYWJsZVBvaW50ZXI9NV09XCJWYXJpYWJsZVBvaW50ZXJcIn0oaXx8KGk9e30pKTtjbGFzcyBFe2NvbnN0cnVjdG9yKCl7dGhpcy5vYmo9bnVsbCx0aGlzLmFwcHJveGltYXRlPSExfWdldCBjb3JyZWN0T2JqKCl7cmV0dXJuIHRoaXMuYXBwcm94aW1hdGU/bnVsbDp0aGlzLm9ian1nZXQgY29udGFpbmVyKCl7cmV0dXJuIHRoaXMub2JqIGluc3RhbmNlb2YgTj90aGlzLm9iajpudWxsfWNvcHkoKXtsZXQgdD1uZXcgRTtyZXR1cm4gdC5vYmo9dGhpcy5vYmosdC5hcHByb3hpbWF0ZT10aGlzLmFwcHJveGltYXRlLHR9fWNsYXNzIE4gZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLm5hbWU9XCJcIix0aGlzLl9jb250ZW50PVtdLHRoaXMubmFtZWRDb250ZW50PW5ldyBNYXAsdGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQ9ITEsdGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQ9ITEsdGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5PSExLHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQ9bnVsbH1nZXQgaGFzVmFsaWROYW1lKCl7cmV0dXJuIG51bGwhPXRoaXMubmFtZSYmdGhpcy5uYW1lLmxlbmd0aD4wfWdldCBjb250ZW50KCl7cmV0dXJuIHRoaXMuX2NvbnRlbnR9c2V0IGNvbnRlbnQodCl7dGhpcy5BZGRDb250ZW50KHQpfWdldCBuYW1lZE9ubHlDb250ZW50KCl7bGV0IHQ9bmV3IE1hcDtmb3IobGV0W2Usbl1vZiB0aGlzLm5hbWVkQ29udGVudCl7bGV0IGk9cyhuLHApO3Quc2V0KGUsaSl9Zm9yKGxldCBlIG9mIHRoaXMuY29udGVudCl7bGV0IG49bChlKTtudWxsIT1uJiZuLmhhc1ZhbGlkTmFtZSYmdC5kZWxldGUobi5uYW1lKX1yZXR1cm4gMD09dC5zaXplJiYodD1udWxsKSx0fXNldCBuYW1lZE9ubHlDb250ZW50KHQpe2xldCBlPXRoaXMubmFtZWRPbmx5Q29udGVudDtpZihudWxsIT1lKWZvcihsZXRbdF1vZiBlKXRoaXMubmFtZWRDb250ZW50LmRlbGV0ZSh0KTtpZihudWxsIT10KWZvcihsZXRbLGVdb2YgdCl7bGV0IHQ9bChlKTtudWxsIT10JiZ0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seSh0KX19Z2V0IGNvdW50RmxhZ3MoKXtsZXQgdD0wO3JldHVybiB0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZCYmKHR8PU4uQ291bnRGbGFncy5WaXNpdHMpLHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkJiYodHw9Ti5Db3VudEZsYWdzLlR1cm5zKSx0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkmJih0fD1OLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkpLHQ9PU4uQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSYmKHQ9MCksdH1zZXQgY291bnRGbGFncyh0KXtsZXQgZT10OyhlJk4uQ291bnRGbGFncy5WaXNpdHMpPjAmJih0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZD0hMCksKGUmTi5Db3VudEZsYWdzLlR1cm5zKT4wJiYodGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQ9ITApLChlJk4uQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSk+MCYmKHRoaXMuY291bnRpbmdBdFN0YXJ0T25seT0hMCl9Z2V0IHBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQoKXtyZXR1cm4gbnVsbD09dGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudCYmKHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQ9dGhpcy5wYXRoLlBhdGhCeUFwcGVuZGluZ1BhdGgodGhpcy5pbnRlcm5hbFBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQpKSx0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50fWdldCBpbnRlcm5hbFBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQoKXtsZXQgdD1bXSxuPXRoaXM7Zm9yKDtuIGluc3RhbmNlb2YgTjspbi5jb250ZW50Lmxlbmd0aD4wJiYodC5wdXNoKG5ldyBlLkNvbXBvbmVudCgwKSksbj1uLmNvbnRlbnRbMF0pO3JldHVybiBuZXcgZSh0KX1BZGRDb250ZW50KHQpe2lmKHQgaW5zdGFuY2VvZiBBcnJheSl7bGV0IGU9dDtmb3IobGV0IHQgb2YgZSl0aGlzLkFkZENvbnRlbnQodCl9ZWxzZXtsZXQgZT10O2lmKHRoaXMuX2NvbnRlbnQucHVzaChlKSxlLnBhcmVudCl0aHJvdyBuZXcgRXJyb3IoXCJjb250ZW50IGlzIGFscmVhZHkgaW4gXCIrZS5wYXJlbnQpO2UucGFyZW50PXRoaXMsdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoZSl9fVRyeUFkZE5hbWVkQ29udGVudCh0KXtsZXQgZT1sKHQpO251bGwhPWUmJmUuaGFzVmFsaWROYW1lJiZ0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seShlKX1BZGRUb05hbWVkQ29udGVudE9ubHkodCl7bi5Bc3NlcnRUeXBlKHQscCxcIkNhbiBvbmx5IGFkZCBSdW50aW1lLk9iamVjdHMgdG8gYSBSdW50aW1lLkNvbnRhaW5lclwiKSxzKHQscCkucGFyZW50PXRoaXMsdGhpcy5uYW1lZENvbnRlbnQuc2V0KHQubmFtZSx0KX1Db250ZW50QXRQYXRoKHQsZT0wLG49LTEpey0xPT1uJiYobj10Lmxlbmd0aCk7bGV0IGk9bmV3IEU7aS5hcHByb3hpbWF0ZT0hMTtsZXQgcj10aGlzLHM9dGhpcztmb3IobGV0IGw9ZTtsPG47KytsKXtsZXQgZT10LkdldENvbXBvbmVudChsKTtpZihudWxsPT1yKXtpLmFwcHJveGltYXRlPSEwO2JyZWFrfWxldCBuPXIuQ29udGVudFdpdGhQYXRoQ29tcG9uZW50KGUpO2lmKG51bGw9PW4pe2kuYXBwcm94aW1hdGU9ITA7YnJlYWt9cz1uLHI9YShuLE4pfXJldHVybiBpLm9iaj1zLGl9SW5zZXJ0Q29udGVudCh0LGUpe2lmKHRoaXMuY29udGVudFtlXT10LHQucGFyZW50KXRocm93IG5ldyBFcnJvcihcImNvbnRlbnQgaXMgYWxyZWFkeSBpbiBcIit0LnBhcmVudCk7dC5wYXJlbnQ9dGhpcyx0aGlzLlRyeUFkZE5hbWVkQ29udGVudCh0KX1BZGRDb250ZW50c09mQ29udGFpbmVyKHQpe3RoaXMuY29udGVudD10aGlzLmNvbnRlbnQuY29uY2F0KHQuY29udGVudCk7Zm9yKGxldCBlIG9mIHQuY29udGVudCllLnBhcmVudD10aGlzLHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KGUpfUNvbnRlbnRXaXRoUGF0aENvbXBvbmVudCh0KXtpZih0LmlzSW5kZXgpcmV0dXJuIHQuaW5kZXg+PTAmJnQuaW5kZXg8dGhpcy5jb250ZW50Lmxlbmd0aD90aGlzLmNvbnRlbnRbdC5pbmRleF06bnVsbDtpZih0LmlzUGFyZW50KXJldHVybiB0aGlzLnBhcmVudDt7aWYobnVsbD09PXQubmFtZSlyZXR1cm4gZChcImNvbXBvbmVudC5uYW1lXCIpO2xldCBlPXkodGhpcy5uYW1lZENvbnRlbnQsdC5uYW1lLG51bGwpO3JldHVybiBlLmV4aXN0cz9zKGUucmVzdWx0LHApOm51bGx9fUJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoKXtsZXQgdDtpZigwPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0PW5ldyBtLHRoaXMuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSh0LDAsbnVsbCksdC50b1N0cmluZygpO3Q9YXJndW1lbnRzWzBdO2xldCBlPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXTtmdW5jdGlvbiByKCl7Zm9yKGxldCBuPTA7bjw0KmU7KytuKXQuQXBwZW5kKFwiIFwiKX1yKCksdC5BcHBlbmQoXCJbXCIpLHRoaXMuaGFzVmFsaWROYW1lJiZ0LkFwcGVuZEZvcm1hdChcIiAoezB9KVwiLHRoaXMubmFtZSksdGhpcz09aSYmdC5BcHBlbmQoXCIgIDwtLS1cIiksdC5BcHBlbmRMaW5lKCksZSsrO2ZvcihsZXQgbj0wO248dGhpcy5jb250ZW50Lmxlbmd0aDsrK24pe2xldCBhPXRoaXMuY29udGVudFtuXTtpZihhIGluc3RhbmNlb2YgTil7YS5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHQsZSxpKX1lbHNlIHIoKSxhIGluc3RhbmNlb2YgVD8odC5BcHBlbmQoJ1wiJyksdC5BcHBlbmQoYS50b1N0cmluZygpLnJlcGxhY2UoXCJcXG5cIixcIlxcXFxuXCIpKSx0LkFwcGVuZCgnXCInKSk6dC5BcHBlbmQoYS50b1N0cmluZygpKTtuIT10aGlzLmNvbnRlbnQubGVuZ3RoLTEmJnQuQXBwZW5kKFwiLFwiKSxhIGluc3RhbmNlb2YgTnx8YSE9aXx8dC5BcHBlbmQoXCIgIDwtLS1cIiksdC5BcHBlbmRMaW5lKCl9bGV0IGE9bmV3IE1hcDtmb3IobGV0W3QsZV1vZiB0aGlzLm5hbWVkQ29udGVudCl0aGlzLmNvbnRlbnQuaW5kZXhPZihzKGUscCkpPj0wfHxhLnNldCh0LGUpO2lmKGEuc2l6ZT4wKXtyKCksdC5BcHBlbmRMaW5lKFwiLS0gbmFtZWQ6IC0tXCIpO2ZvcihsZXRbLHJdb2YgYSl7bi5Bc3NlcnRUeXBlKHIsTixcIkNhbiBvbmx5IHByaW50IG91dCBuYW1lZCBDb250YWluZXJzXCIpLHIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSh0LGUsaSksdC5BcHBlbmRMaW5lKCl9fWUtLSxyKCksdC5BcHBlbmQoXCJdXCIpfX0hZnVuY3Rpb24odCl7bGV0IGU7IWZ1bmN0aW9uKHQpe3RbdC5WaXNpdHM9MV09XCJWaXNpdHNcIix0W3QuVHVybnM9Ml09XCJUdXJuc1wiLHRbdC5Db3VudFN0YXJ0T25seT00XT1cIkNvdW50U3RhcnRPbmx5XCJ9KGU9dC5Db3VudEZsYWdzfHwodC5Db3VudEZsYWdzPXt9KSl9KE58fChOPXt9KSk7Y2xhc3MgeCBleHRlbmRzIHB7dG9TdHJpbmcoKXtyZXR1cm5cIkdsdWVcIn19Y2xhc3MgQSBleHRlbmRzIHB7Y29uc3RydWN0b3IodD1BLkNvbW1hbmRUeXBlLk5vdFNldCl7c3VwZXIoKSx0aGlzLl9jb21tYW5kVHlwZT10fWdldCBjb21tYW5kVHlwZSgpe3JldHVybiB0aGlzLl9jb21tYW5kVHlwZX1Db3B5KCl7cmV0dXJuIG5ldyBBKHRoaXMuY29tbWFuZFR5cGUpfXN0YXRpYyBFdmFsU3RhcnQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5FdmFsU3RhcnQpfXN0YXRpYyBFdmFsT3V0cHV0KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRXZhbE91dHB1dCl9c3RhdGljIEV2YWxFbmQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5FdmFsRW5kKX1zdGF0aWMgRHVwbGljYXRlKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRHVwbGljYXRlKX1zdGF0aWMgUG9wRXZhbHVhdGVkVmFsdWUoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZSl9c3RhdGljIFBvcEZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb24pfXN0YXRpYyBQb3BUdW5uZWwoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5Qb3BUdW5uZWwpfXN0YXRpYyBCZWdpblN0cmluZygpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKX1zdGF0aWMgRW5kU3RyaW5nKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuRW5kU3RyaW5nKX1zdGF0aWMgTm9PcCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLk5vT3ApfXN0YXRpYyBDaG9pY2VDb3VudCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50KX1zdGF0aWMgVHVybnMoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5UdXJucyl9c3RhdGljIFR1cm5zU2luY2UoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5UdXJuc1NpbmNlKX1zdGF0aWMgUmVhZENvdW50KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuUmVhZENvdW50KX1zdGF0aWMgUmFuZG9tKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuUmFuZG9tKX1zdGF0aWMgU2VlZFJhbmRvbSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlNlZWRSYW5kb20pfXN0YXRpYyBWaXNpdEluZGV4KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuVmlzaXRJbmRleCl9c3RhdGljIFNlcXVlbmNlU2h1ZmZsZUluZGV4KCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXgpfXN0YXRpYyBTdGFydFRocmVhZCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkKX1zdGF0aWMgRG9uZSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkRvbmUpfXN0YXRpYyBFbmQoKXtyZXR1cm4gbmV3IEEoQS5Db21tYW5kVHlwZS5FbmQpfXN0YXRpYyBMaXN0RnJvbUludCgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50KX1zdGF0aWMgTGlzdFJhbmdlKCl7cmV0dXJuIG5ldyBBKEEuQ29tbWFuZFR5cGUuTGlzdFJhbmdlKX1zdGF0aWMgTGlzdFJhbmRvbSgpe3JldHVybiBuZXcgQShBLkNvbW1hbmRUeXBlLkxpc3RSYW5kb20pfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29tbWFuZFR5cGUudG9TdHJpbmcoKX19IWZ1bmN0aW9uKHQpe2xldCBlOyFmdW5jdGlvbih0KXt0W3QuTm90U2V0PS0xXT1cIk5vdFNldFwiLHRbdC5FdmFsU3RhcnQ9MF09XCJFdmFsU3RhcnRcIix0W3QuRXZhbE91dHB1dD0xXT1cIkV2YWxPdXRwdXRcIix0W3QuRXZhbEVuZD0yXT1cIkV2YWxFbmRcIix0W3QuRHVwbGljYXRlPTNdPVwiRHVwbGljYXRlXCIsdFt0LlBvcEV2YWx1YXRlZFZhbHVlPTRdPVwiUG9wRXZhbHVhdGVkVmFsdWVcIix0W3QuUG9wRnVuY3Rpb249NV09XCJQb3BGdW5jdGlvblwiLHRbdC5Qb3BUdW5uZWw9Nl09XCJQb3BUdW5uZWxcIix0W3QuQmVnaW5TdHJpbmc9N109XCJCZWdpblN0cmluZ1wiLHRbdC5FbmRTdHJpbmc9OF09XCJFbmRTdHJpbmdcIix0W3QuTm9PcD05XT1cIk5vT3BcIix0W3QuQ2hvaWNlQ291bnQ9MTBdPVwiQ2hvaWNlQ291bnRcIix0W3QuVHVybnM9MTFdPVwiVHVybnNcIix0W3QuVHVybnNTaW5jZT0xMl09XCJUdXJuc1NpbmNlXCIsdFt0LlJhbmRvbT0xM109XCJSYW5kb21cIix0W3QuU2VlZFJhbmRvbT0xNF09XCJTZWVkUmFuZG9tXCIsdFt0LlZpc2l0SW5kZXg9MTVdPVwiVmlzaXRJbmRleFwiLHRbdC5TZXF1ZW5jZVNodWZmbGVJbmRleD0xNl09XCJTZXF1ZW5jZVNodWZmbGVJbmRleFwiLHRbdC5TdGFydFRocmVhZD0xN109XCJTdGFydFRocmVhZFwiLHRbdC5Eb25lPTE4XT1cIkRvbmVcIix0W3QuRW5kPTE5XT1cIkVuZFwiLHRbdC5MaXN0RnJvbUludD0yMF09XCJMaXN0RnJvbUludFwiLHRbdC5MaXN0UmFuZ2U9MjFdPVwiTGlzdFJhbmdlXCIsdFt0Lkxpc3RSYW5kb209MjJdPVwiTGlzdFJhbmRvbVwiLHRbdC5SZWFkQ291bnQ9MjNdPVwiUmVhZENvdW50XCIsdFt0LlRPVEFMX1ZBTFVFUz0yNF09XCJUT1RBTF9WQUxVRVNcIn0oZT10LkNvbW1hbmRUeXBlfHwodC5Db21tYW5kVHlwZT17fSkpfShBfHwoQT17fSkpLGZ1bmN0aW9uKHQpe3RbdC5UdW5uZWw9MF09XCJUdW5uZWxcIix0W3QuRnVuY3Rpb249MV09XCJGdW5jdGlvblwiLHRbdC5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZT0yXT1cIkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lXCJ9KHJ8fChyPXt9KSk7Y2xhc3MgSXtjb25zdHJ1Y3Rvcigpe3RoaXMuY29udGFpbmVyPW51bGwsdGhpcy5pbmRleD0tMSwyPT09YXJndW1lbnRzLmxlbmd0aCYmKHRoaXMuY29udGFpbmVyPWFyZ3VtZW50c1swXSx0aGlzLmluZGV4PWFyZ3VtZW50c1sxXSl9UmVzb2x2ZSgpe3JldHVybiB0aGlzLmluZGV4PDA/dGhpcy5jb250YWluZXI6bnVsbD09dGhpcy5jb250YWluZXI/bnVsbDowPT10aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aD90aGlzLmNvbnRhaW5lcjp0aGlzLmluZGV4Pj10aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aD9udWxsOnRoaXMuY29udGFpbmVyLmNvbnRlbnRbdGhpcy5pbmRleF19Z2V0IGlzTnVsbCgpe3JldHVybiBudWxsPT10aGlzLmNvbnRhaW5lcn1nZXQgcGF0aCgpe3JldHVybiB0aGlzLmlzTnVsbD9udWxsOnRoaXMuaW5kZXg+PTA/dGhpcy5jb250YWluZXIucGF0aC5QYXRoQnlBcHBlbmRpbmdDb21wb25lbnQobmV3IGUuQ29tcG9uZW50KHRoaXMuaW5kZXgpKTp0aGlzLmNvbnRhaW5lci5wYXRofXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuY29udGFpbmVyP1wiSW5rIFBvaW50ZXIgLT4gXCIrdGhpcy5jb250YWluZXIucGF0aC50b1N0cmluZygpK1wiIC0tIGluZGV4IFwiK3RoaXMuaW5kZXg6XCJJbmsgUG9pbnRlciAobnVsbClcIn1jb3B5KCl7cmV0dXJuIG5ldyBJKHRoaXMuY29udGFpbmVyLHRoaXMuaW5kZXgpfXN0YXRpYyBTdGFydE9mKHQpe3JldHVybiBuZXcgSSh0LDApfXN0YXRpYyBnZXQgTnVsbCgpe3JldHVybiBuZXcgSShudWxsLC0xKX19Y2xhc3MgayBleHRlbmRzIHB7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLl90YXJnZXRQYXRoPW51bGwsdGhpcy5fdGFyZ2V0UG9pbnRlcj1JLk51bGwsdGhpcy52YXJpYWJsZURpdmVydE5hbWU9bnVsbCx0aGlzLnB1c2hlc1RvU3RhY2s9ITEsdGhpcy5zdGFja1B1c2hUeXBlPTAsdGhpcy5pc0V4dGVybmFsPSExLHRoaXMuZXh0ZXJuYWxBcmdzPTAsdGhpcy5pc0NvbmRpdGlvbmFsPSExLHRoaXMucHVzaGVzVG9TdGFjaz0hMSx2b2lkIDAhPT10JiYodGhpcy5wdXNoZXNUb1N0YWNrPSEwLHRoaXMuc3RhY2tQdXNoVHlwZT10KX1nZXQgdGFyZ2V0UGF0aCgpe2lmKG51bGwhPXRoaXMuX3RhcmdldFBhdGgmJnRoaXMuX3RhcmdldFBhdGguaXNSZWxhdGl2ZSl7bGV0IHQ9dGhpcy50YXJnZXRQb2ludGVyLlJlc29sdmUoKTt0JiYodGhpcy5fdGFyZ2V0UGF0aD10LnBhdGgpfXJldHVybiB0aGlzLl90YXJnZXRQYXRofXNldCB0YXJnZXRQYXRoKHQpe3RoaXMuX3RhcmdldFBhdGg9dCx0aGlzLl90YXJnZXRQb2ludGVyPUkuTnVsbH1nZXQgdGFyZ2V0UG9pbnRlcigpe2lmKHRoaXMuX3RhcmdldFBvaW50ZXIuaXNOdWxsKXtsZXQgdD10aGlzLlJlc29sdmVQYXRoKHRoaXMuX3RhcmdldFBhdGgpLm9iajtpZihudWxsPT09dGhpcy5fdGFyZ2V0UGF0aClyZXR1cm4gZChcInRoaXMuX3RhcmdldFBhdGhcIik7aWYobnVsbD09PXRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudClyZXR1cm4gZChcInRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudFwiKTtpZih0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQuaXNJbmRleCl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJ0YXJnZXRPYmpcIik7dGhpcy5fdGFyZ2V0UG9pbnRlci5jb250YWluZXI9dC5wYXJlbnQgaW5zdGFuY2VvZiBOP3QucGFyZW50Om51bGwsdGhpcy5fdGFyZ2V0UG9pbnRlci5pbmRleD10aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQuaW5kZXh9ZWxzZSB0aGlzLl90YXJnZXRQb2ludGVyPUkuU3RhcnRPZih0IGluc3RhbmNlb2YgTj90Om51bGwpfXJldHVybiB0aGlzLl90YXJnZXRQb2ludGVyLmNvcHkoKX1nZXQgdGFyZ2V0UGF0aFN0cmluZygpe3JldHVybiBudWxsPT10aGlzLnRhcmdldFBhdGg/bnVsbDp0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMudGFyZ2V0UGF0aCl9c2V0IHRhcmdldFBhdGhTdHJpbmcodCl7dGhpcy50YXJnZXRQYXRoPW51bGw9PXQ/bnVsbDpuZXcgZSh0KX1nZXQgaGFzVmFyaWFibGVUYXJnZXQoKXtyZXR1cm4gbnVsbCE9dGhpcy52YXJpYWJsZURpdmVydE5hbWV9RXF1YWxzKHQpe2xldCBlPXQ7cmV0dXJuIGUgaW5zdGFuY2VvZiBrJiZ0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0PT1lLmhhc1ZhcmlhYmxlVGFyZ2V0JiYodGhpcy5oYXNWYXJpYWJsZVRhcmdldD90aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZT09ZS52YXJpYWJsZURpdmVydE5hbWU6bnVsbD09PXRoaXMudGFyZ2V0UGF0aD9kKFwidGhpcy50YXJnZXRQYXRoXCIpOnRoaXMudGFyZ2V0UGF0aC5FcXVhbHMoZS50YXJnZXRQYXRoKSl9dG9TdHJpbmcoKXtpZih0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0KXJldHVyblwiRGl2ZXJ0KHZhcmlhYmxlOiBcIit0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZStcIilcIjtpZihudWxsPT10aGlzLnRhcmdldFBhdGgpcmV0dXJuXCJEaXZlcnQobnVsbClcIjt7bGV0IHQ9bmV3IG0sZT10aGlzLnRhcmdldFBhdGgudG9TdHJpbmcoKTtyZXR1cm4gdC5BcHBlbmQoXCJEaXZlcnRcIiksdGhpcy5pc0NvbmRpdGlvbmFsJiZ0LkFwcGVuZChcIj9cIiksdGhpcy5wdXNoZXNUb1N0YWNrJiYodGhpcy5zdGFja1B1c2hUeXBlPT1yLkZ1bmN0aW9uP3QuQXBwZW5kKFwiIGZ1bmN0aW9uXCIpOnQuQXBwZW5kKFwiIHR1bm5lbFwiKSksdC5BcHBlbmQoXCIgLT4gXCIpLHQuQXBwZW5kKHRoaXMudGFyZ2V0UGF0aFN0cmluZyksdC5BcHBlbmQoXCIgKFwiKSx0LkFwcGVuZChlKSx0LkFwcGVuZChcIilcIiksdC50b1N0cmluZygpfX19Y2xhc3MgVyBleHRlbmRzIHB7Y29uc3RydWN0b3IodD0hMCl7c3VwZXIoKSx0aGlzLl9wYXRoT25DaG9pY2U9bnVsbCx0aGlzLmhhc0NvbmRpdGlvbj0hMSx0aGlzLmhhc1N0YXJ0Q29udGVudD0hMSx0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50PSExLHRoaXMuaXNJbnZpc2libGVEZWZhdWx0PSExLHRoaXMub25jZU9ubHk9ITAsdGhpcy5vbmNlT25seT10fWdldCBwYXRoT25DaG9pY2UoKXtpZihudWxsIT10aGlzLl9wYXRoT25DaG9pY2UmJnRoaXMuX3BhdGhPbkNob2ljZS5pc1JlbGF0aXZlKXtsZXQgdD10aGlzLmNob2ljZVRhcmdldDt0JiYodGhpcy5fcGF0aE9uQ2hvaWNlPXQucGF0aCl9cmV0dXJuIHRoaXMuX3BhdGhPbkNob2ljZX1zZXQgcGF0aE9uQ2hvaWNlKHQpe3RoaXMuX3BhdGhPbkNob2ljZT10fWdldCBjaG9pY2VUYXJnZXQoKXtyZXR1cm4gbnVsbD09PXRoaXMuX3BhdGhPbkNob2ljZT9kKFwiQ2hvaWNlUG9pbnQuX3BhdGhPbkNob2ljZVwiKTp0aGlzLlJlc29sdmVQYXRoKHRoaXMuX3BhdGhPbkNob2ljZSkuY29udGFpbmVyfWdldCBwYXRoU3RyaW5nT25DaG9pY2UoKXtyZXR1cm4gbnVsbD09PXRoaXMucGF0aE9uQ2hvaWNlP2QoXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik6dGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnBhdGhPbkNob2ljZSl9c2V0IHBhdGhTdHJpbmdPbkNob2ljZSh0KXt0aGlzLnBhdGhPbkNob2ljZT1uZXcgZSh0KX1nZXQgZmxhZ3MoKXtsZXQgdD0wO3JldHVybiB0aGlzLmhhc0NvbmRpdGlvbiYmKHR8PTEpLHRoaXMuaGFzU3RhcnRDb250ZW50JiYodHw9MiksdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudCYmKHR8PTQpLHRoaXMuaXNJbnZpc2libGVEZWZhdWx0JiYodHw9OCksdGhpcy5vbmNlT25seSYmKHR8PTE2KSx0fXNldCBmbGFncyh0KXt0aGlzLmhhc0NvbmRpdGlvbj0oMSZ0KT4wLHRoaXMuaGFzU3RhcnRDb250ZW50PSgyJnQpPjAsdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudD0oNCZ0KT4wLHRoaXMuaXNJbnZpc2libGVEZWZhdWx0PSg4JnQpPjAsdGhpcy5vbmNlT25seT0oMTYmdCk+MH10b1N0cmluZygpe2lmKG51bGw9PT10aGlzLnBhdGhPbkNob2ljZSlyZXR1cm4gZChcIkNob2ljZVBvaW50LnBhdGhPbkNob2ljZVwiKTtyZXR1cm5cIkNob2ljZTogLT4gXCIrdGhpcy5wYXRoT25DaG9pY2UudG9TdHJpbmcoKX19Y2xhc3MgRiBleHRlbmRzIHB7Y29uc3RydWN0b3IodD1udWxsKXtzdXBlcigpLHRoaXMucGF0aEZvckNvdW50PW51bGwsdGhpcy5uYW1lPXR9Z2V0IGNvbnRhaW5lckZvckNvdW50KCl7cmV0dXJuIG51bGw9PT10aGlzLnBhdGhGb3JDb3VudD9udWxsOnRoaXMuUmVzb2x2ZVBhdGgodGhpcy5wYXRoRm9yQ291bnQpLmNvbnRhaW5lcn1nZXQgcGF0aFN0cmluZ0ZvckNvdW50KCl7cmV0dXJuIG51bGw9PT10aGlzLnBhdGhGb3JDb3VudD9udWxsOnRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy5wYXRoRm9yQ291bnQpfXNldCBwYXRoU3RyaW5nRm9yQ291bnQodCl7dGhpcy5wYXRoRm9yQ291bnQ9bnVsbD09PXQ/bnVsbDpuZXcgZSh0KX10b1N0cmluZygpe2lmKG51bGwhPXRoaXMubmFtZSlyZXR1cm5cInZhcihcIit0aGlzLm5hbWUrXCIpXCI7cmV0dXJuXCJyZWFkX2NvdW50KFwiK3RoaXMucGF0aFN0cmluZ0ZvckNvdW50K1wiKVwifX1jbGFzcyBWIGV4dGVuZHMgcHtjb25zdHJ1Y3Rvcih0LGUpe3N1cGVyKCksdGhpcy52YXJpYWJsZU5hbWU9dHx8bnVsbCx0aGlzLmlzTmV3RGVjbGFyYXRpb249ISFlLHRoaXMuaXNHbG9iYWw9ITF9dG9TdHJpbmcoKXtyZXR1cm5cIlZhckFzc2lnbiB0byBcIit0aGlzLnZhcmlhYmxlTmFtZX19Y2xhc3MgTCBleHRlbmRzIHB7fWNsYXNzIFIgZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKCl7aWYoc3VwZXIoKSx0aGlzLl9uYW1lPW51bGwsdGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzPTAsdGhpcy5fcHJvdG90eXBlPW51bGwsdGhpcy5faXNQcm90b3R5cGU9ITEsdGhpcy5fb3BlcmF0aW9uRnVuY3M9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClSLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtsZXQgdD1hcmd1bWVudHNbMF07Ui5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCksdGhpcy5uYW1lPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7bGV0IHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuX2lzUHJvdG90eXBlPSEwLHRoaXMubmFtZT10LHRoaXMubnVtYmVyT2ZQYXJhbWV0ZXJzPWV9fXN0YXRpYyBDYWxsV2l0aE5hbWUodCl7cmV0dXJuIG5ldyBSKHQpfXN0YXRpYyBDYWxsRXhpc3RzV2l0aE5hbWUodCl7cmV0dXJuIHRoaXMuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpLHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5nZXQodCl9Z2V0IG5hbWUoKXtyZXR1cm4gbnVsbD09PXRoaXMuX25hbWU/ZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmFtZVwiKTp0aGlzLl9uYW1lfXNldCBuYW1lKHQpe3RoaXMuX25hbWU9dCx0aGlzLl9pc1Byb3RvdHlwZXx8KG51bGw9PT1SLl9uYXRpdmVGdW5jdGlvbnM/ZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zXCIpOnRoaXMuX3Byb3RvdHlwZT1SLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KHRoaXMuX25hbWUpfHxudWxsKX1nZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKCl7cmV0dXJuIHRoaXMuX3Byb3RvdHlwZT90aGlzLl9wcm90b3R5cGUubnVtYmVyT2ZQYXJhbWV0ZXJzOnRoaXMuX251bWJlck9mUGFyYW1ldGVyc31zZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKHQpe3RoaXMuX251bWJlck9mUGFyYW1ldGVycz10fUNhbGwodCl7aWYodGhpcy5fcHJvdG90eXBlKXJldHVybiB0aGlzLl9wcm90b3R5cGUuQ2FsbCh0KTtpZih0aGlzLm51bWJlck9mUGFyYW1ldGVycyE9dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBudW1iZXIgb2YgcGFyYW1ldGVyc1wiKTtsZXQgZT0hMTtmb3IobGV0IG4gb2YgdCl7aWYobiBpbnN0YW5jZW9mIEwpdGhyb3cgbmV3IFMoJ0F0dGVtcHRpbmcgdG8gcGVyZm9ybSBvcGVyYXRpb24gb24gYSB2b2lkIHZhbHVlLiBEaWQgeW91IGZvcmdldCB0byBcInJldHVyblwiIGEgdmFsdWUgZnJvbSBhIGZ1bmN0aW9uIHlvdSBjYWxsZWQgaGVyZT8nKTtuIGluc3RhbmNlb2YgTyYmKGU9ITApfWlmKDI9PXQubGVuZ3RoJiZlKXJldHVybiB0aGlzLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHQpO2xldCBuPXRoaXMuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlKHQpLHI9blswXS52YWx1ZVR5cGU7cmV0dXJuIHI9PWkuSW50fHxyPT1pLkZsb2F0fHxyPT1pLlN0cmluZ3x8cj09aS5EaXZlcnRUYXJnZXR8fHI9PWkuTGlzdD90aGlzLkNhbGxUeXBlKG4pOm51bGx9Q2FsbFR5cGUodCl7bGV0IGU9cyh0WzBdLHYpLG49ZS52YWx1ZVR5cGUscj1lLGE9dC5sZW5ndGg7aWYoMj09YXx8MT09YSl7aWYobnVsbD09PXRoaXMuX29wZXJhdGlvbkZ1bmNzKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtsZXQgbD10aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQobik7aWYoIWwpe2NvbnN0IHQ9aVtuXTt0aHJvdyBuZXcgUyhcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBcIit0aGlzLm5hbWUrXCIgb24gXCIrdCl9aWYoMj09YSl7bGV0IGU9cyh0WzFdLHYpLG49bDtpZihudWxsPT09ci52YWx1ZXx8bnVsbD09PWUudmFsdWUpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbCBCaW5hcnlPcCB2YWx1ZXNcIik7bGV0IGk9bihyLnZhbHVlLGUudmFsdWUpO3JldHVybiB2LkNyZWF0ZShpKX17bGV0IHQ9bDtpZihudWxsPT09ci52YWx1ZSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIFVuYXJ5T3AgdmFsdWVcIik7bGV0IG49dChyLnZhbHVlKTtyZXR1cm4gdGhpcy5uYW1lPT09Ui5JbnQ/di5DcmVhdGUobixpLkludCk6dGhpcy5uYW1lPT09Ui5GbG9hdD92LkNyZWF0ZShuLGkuRmxvYXQpOnYuQ3JlYXRlKG4sZS52YWx1ZVR5cGUpfX10aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzIHRvIE5hdGl2ZUZ1bmN0aW9uQ2FsbDogXCIrdC5sZW5ndGgpfUNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHQpe2lmKChcIitcIj09dGhpcy5uYW1lfHxcIi1cIj09dGhpcy5uYW1lKSYmdFswXWluc3RhbmNlb2YgTyYmdFsxXWluc3RhbmNlb2YgYilyZXR1cm4gdGhpcy5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbih0KTtsZXQgZT1zKHRbMF0sdiksbj1zKHRbMV0sdik7aWYoIShcIiYmXCIhPXRoaXMubmFtZSYmXCJ8fFwiIT10aGlzLm5hbWV8fGUudmFsdWVUeXBlPT1pLkxpc3QmJm4udmFsdWVUeXBlPT1pLkxpc3QpKXtpZihudWxsPT09dGhpcy5fb3BlcmF0aW9uRnVuY3MpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO2xldCB0PXRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChpLkludCk7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbEJpbmFyeUxpc3RPcGVyYXRpb24gb3BcIik7bGV0IHI9dChlLmlzVHJ1dGh5PzE6MCxuLmlzVHJ1dGh5PzE6MCk7cmV0dXJuIG5ldyBiKHIpfWlmKGUudmFsdWVUeXBlPT1pLkxpc3QmJm4udmFsdWVUeXBlPT1pLkxpc3QpcmV0dXJuIHRoaXMuQ2FsbFR5cGUoW2Usbl0pO3Rocm93IG5ldyBTKFwiQ2FuIG5vdCBjYWxsIHVzZSBcIit0aGlzLm5hbWUrXCIgb3BlcmF0aW9uIG9uIFwiK2lbZS52YWx1ZVR5cGVdK1wiIGFuZCBcIitpW24udmFsdWVUeXBlXSl9Q2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24odCl7bGV0IGU9cyh0WzBdLE8pLG49cyh0WzFdLGIpLHI9bmV3IGc7aWYobnVsbD09PWUudmFsdWUpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gbGlzdFZhbC52YWx1ZVwiKTtmb3IobGV0W3QsYV1vZiBlLnZhbHVlKXtsZXQgcz1mLmZyb21TZXJpYWxpemVkS2V5KHQpO2lmKG51bGw9PT10aGlzLl9vcGVyYXRpb25GdW5jcylyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7bGV0IGw9dGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KGkuSW50KTtpZihudWxsPT09bi52YWx1ZSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBpbnRWYWwudmFsdWVcIik7bGV0IG89bChhLG4udmFsdWUpLHU9bnVsbDtpZihudWxsPT09ZS52YWx1ZS5vcmlnaW5zKXJldHVybiBkKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWUub3JpZ2luc1wiKTtmb3IobGV0IHQgb2YgZS52YWx1ZS5vcmlnaW5zKWlmKHQubmFtZT09cy5vcmlnaW5OYW1lKXt1PXQ7YnJlYWt9aWYobnVsbCE9dSl7bGV0IHQ9dS5UcnlHZXRJdGVtV2l0aFZhbHVlKG8sZi5OdWxsKTt0LmV4aXN0cyYmci5BZGQodC5yZXN1bHQsbyl9fXJldHVybiBuZXcgTyhyKX1Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUodCl7bGV0IGU9aS5JbnQsbj1udWxsO2ZvcihsZXQgciBvZiB0KXtsZXQgdD1zKHIsdik7dC52YWx1ZVR5cGU+ZSYmKGU9dC52YWx1ZVR5cGUpLHQudmFsdWVUeXBlPT1pLkxpc3QmJihuPWEodCxPKSl9bGV0IHI9W107aWYoaVtlXT09aVtpLkxpc3RdKWZvcihsZXQgZSBvZiB0KXtsZXQgdD1zKGUsdik7aWYodC52YWx1ZVR5cGU9PWkuTGlzdClyLnB1c2godCk7ZWxzZXtpZih0LnZhbHVlVHlwZSE9aS5JbnQpe2NvbnN0IGU9aVt0LnZhbHVlVHlwZV07dGhyb3cgbmV3IFMoXCJDYW5ub3QgbWl4IExpc3RzIGFuZCBcIitlK1wiIHZhbHVlcyBpbiB0aGlzIG9wZXJhdGlvblwiKX17bGV0IGU9cGFyc2VJbnQodC52YWx1ZU9iamVjdCk7aWYobj1zKG4sTyksbnVsbD09PW4udmFsdWUpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIHNwZWNpYWxDYXNlTGlzdC52YWx1ZVwiKTtsZXQgaT1uLnZhbHVlLm9yaWdpbk9mTWF4SXRlbTtpZihudWxsPT09aSlyZXR1cm4gZChcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUgbGlzdFwiKTtsZXQgYT1pLlRyeUdldEl0ZW1XaXRoVmFsdWUoZSxmLk51bGwpO2lmKCFhLmV4aXN0cyl0aHJvdyBuZXcgUyhcIkNvdWxkIG5vdCBmaW5kIExpc3QgaXRlbSB3aXRoIHRoZSB2YWx1ZSBcIitlK1wiIGluIFwiK2kubmFtZSk7e2xldCB0PW5ldyBPKGEucmVzdWx0LGUpO3IucHVzaCh0KX19fX1lbHNlIGZvcihsZXQgbiBvZiB0KXtsZXQgdD1zKG4sdikuQ2FzdChlKTtyLnB1c2godCl9cmV0dXJuIHJ9c3RhdGljIElkZW50aXR5KHQpe3JldHVybiB0fXN0YXRpYyBHZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCl7aWYobnVsbD09dGhpcy5fbmF0aXZlRnVuY3Rpb25zKXt0aGlzLl9uYXRpdmVGdW5jdGlvbnM9bmV3IE1hcCx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuQWRkLCh0LGUpPT50K2UpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwodCxlKT0+dC1lKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTXVsdGlwbHksKHQsZSk9PnQqZSksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkRpdmlkZSwodCxlKT0+TWF0aC5mbG9vcih0L2UpKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTW9kLCh0LGUpPT50JWUpLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLk5lZ2F0ZSx0PT4tdCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkVxdWFsLCh0LGUpPT50PT1lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsKHQsZSk9PnQ+ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5MZXNzLCh0LGUpPT50PGU/MTowKSx0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywodCxlKT0+dD49ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCh0LGUpPT50PD1lPzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywodCxlKT0+dCE9ZT8xOjApLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLk5vdCx0PT4wPT10PzE6MCksdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFuZCwodCxlKT0+MCE9dCYmMCE9ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5PciwodCxlKT0+MCE9dHx8MCE9ZT8xOjApLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NYXgsKHQsZSk9Pk1hdGgubWF4KHQsZSkpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NaW4sKHQsZSk9Pk1hdGgubWluKHQsZSkpLHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Qb3csKHQsZSk9Pk1hdGgucG93KHQsZSkpLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb29yLFIuSWRlbnRpdHkpLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkNlaWxpbmcsUi5JZGVudGl0eSksdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuSW50LFIuSWRlbnRpdHkpLHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb2F0LHQ9PnQpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFkZCwodCxlKT0+dCtlKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwodCxlKT0+dC1lKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NdWx0aXBseSwodCxlKT0+dCplKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5EaXZpZGUsKHQsZSk9PnQvZSksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTW9kLCh0LGUpPT50JWUpLHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuTmVnYXRlLHQ9Pi10KSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5FcXVhbCwodCxlKT0+dD09ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsKHQsZSk9PnQ+ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkxlc3MsKHQsZSk9PnQ8ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsKHQsZSk9PnQ+PWU/MTowKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCh0LGUpPT50PD1lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCh0LGUpPT50IT1lPzE6MCksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5Ob3QsdD0+MD09dD8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFuZCwodCxlKT0+MCE9dCYmMCE9ZT8xOjApLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk9yLCh0LGUpPT4wIT10fHwwIT1lPzE6MCksdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTWF4LCh0LGUpPT5NYXRoLm1heCh0LGUpKSx0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NaW4sKHQsZSk9Pk1hdGgubWluKHQsZSkpLHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLlBvdywodCxlKT0+TWF0aC5wb3codCxlKSksdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5GbG9vcix0PT5NYXRoLmZsb29yKHQpKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkNlaWxpbmcsdD0+TWF0aC5jZWlsKHQpKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkludCx0PT5NYXRoLmZsb29yKHQpKSx0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkZsb2F0LFIuSWRlbnRpdHkpLHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5BZGQsKHQsZSk9PnQrZSksdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkVxdWFsLCh0LGUpPT50PT09ZT8xOjApLHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsKHQsZSk9PnQhPT1lPzE6MCksdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhcywodCxlKT0+dC5pbmNsdWRlcyhlKT8xOjApLHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5IYXNudCwodCxlKT0+dC5pbmNsdWRlcyhlKT8wOjEpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuQWRkLCh0LGUpPT50LlVuaW9uKGUpKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCh0LGUpPT50LldpdGhvdXQoZSkpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSGFzLCh0LGUpPT50LkNvbnRhaW5zKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXNudCwodCxlKT0+dC5Db250YWlucyhlKT8wOjEpLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSW50ZXJzZWN0LCh0LGUpPT50LkludGVyc2VjdChlKSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5FcXVhbCwodCxlKT0+dC5FcXVhbHMoZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsKHQsZSk9PnQuR3JlYXRlclRoYW4oZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3MsKHQsZSk9PnQuTGVzc1RoYW4oZSk/MTowKSx0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsKHQsZSk9PnQuR3JlYXRlclRoYW5PckVxdWFscyhlKT8xOjApLHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywodCxlKT0+dC5MZXNzVGhhbk9yRXF1YWxzKGUpPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsKHQsZSk9PnQuRXF1YWxzKGUpPzA6MSksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BbmQsKHQsZSk9PnQuQ291bnQ+MCYmZS5Db3VudD4wPzE6MCksdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5PciwodCxlKT0+dC5Db3VudD4wfHxlLkNvdW50PjA/MTowKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTm90LHQ9PjA9PXQuQ291bnQ/MTowKSx0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuSW52ZXJ0LHQ9PnQuaW52ZXJzZSksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkFsbCx0PT50LmFsbCksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkxpc3RNaW4sdD0+dC5NaW5Bc0xpc3QoKSksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkxpc3RNYXgsdD0+dC5NYXhBc0xpc3QoKSksdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkNvdW50LHQ9PnQuQ291bnQpLHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5WYWx1ZU9mTGlzdCx0PT50Lm1heEl0ZW0uVmFsdWUpO2xldCB0PSh0LGUpPT50LkVxdWFscyhlKT8xOjAsZT0odCxlKT0+dC5FcXVhbHMoZSk/MDoxO3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModGhpcy5FcXVhbCwyLGkuRGl2ZXJ0VGFyZ2V0LHQpLHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmModGhpcy5Ob3RFcXVhbHMsMixpLkRpdmVydFRhcmdldCxlKX19QWRkT3BGdW5jRm9yVHlwZSh0LGUpe251bGw9PXRoaXMuX29wZXJhdGlvbkZ1bmNzJiYodGhpcy5fb3BlcmF0aW9uRnVuY3M9bmV3IE1hcCksdGhpcy5fb3BlcmF0aW9uRnVuY3Muc2V0KHQsZSl9c3RhdGljIEFkZE9wVG9OYXRpdmVGdW5jKHQsZSxuLGkpe2lmKG51bGw9PT10aGlzLl9uYXRpdmVGdW5jdGlvbnMpcmV0dXJuIGQoXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTtsZXQgcj10aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KHQpO3J8fChyPW5ldyBSKHQsZSksdGhpcy5fbmF0aXZlRnVuY3Rpb25zLnNldCh0LHIpKSxyLkFkZE9wRnVuY0ZvclR5cGUobixpKX1zdGF0aWMgQWRkSW50QmluYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMixpLkludCxlKX1zdGF0aWMgQWRkSW50VW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwxLGkuSW50LGUpfXN0YXRpYyBBZGRGbG9hdEJpbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDIsaS5GbG9hdCxlKX1zdGF0aWMgQWRkRmxvYXRVbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDEsaS5GbG9hdCxlKX1zdGF0aWMgQWRkU3RyaW5nQmluYXJ5T3AodCxlKXt0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHQsMixpLlN0cmluZyxlKX1zdGF0aWMgQWRkTGlzdEJpbmFyeU9wKHQsZSl7dGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0LDIsaS5MaXN0LGUpfXN0YXRpYyBBZGRMaXN0VW5hcnlPcCh0LGUpe3RoaXMuQWRkT3BUb05hdGl2ZUZ1bmModCwxLGkuTGlzdCxlKX10b1N0cmluZygpe3JldHVybidOYXRpdmUgXCInK3RoaXMubmFtZSsnXCInfX1SLkFkZD1cIitcIixSLlN1YnRyYWN0PVwiLVwiLFIuRGl2aWRlPVwiL1wiLFIuTXVsdGlwbHk9XCIqXCIsUi5Nb2Q9XCIlXCIsUi5OZWdhdGU9XCJfXCIsUi5FcXVhbD1cIj09XCIsUi5HcmVhdGVyPVwiPlwiLFIuTGVzcz1cIjxcIixSLkdyZWF0ZXJUaGFuT3JFcXVhbHM9XCI+PVwiLFIuTGVzc1RoYW5PckVxdWFscz1cIjw9XCIsUi5Ob3RFcXVhbHM9XCIhPVwiLFIuTm90PVwiIVwiLFIuQW5kPVwiJiZcIixSLk9yPVwifHxcIixSLk1pbj1cIk1JTlwiLFIuTWF4PVwiTUFYXCIsUi5Qb3c9XCJQT1dcIixSLkZsb29yPVwiRkxPT1JcIixSLkNlaWxpbmc9XCJDRUlMSU5HXCIsUi5JbnQ9XCJJTlRcIixSLkZsb2F0PVwiRkxPQVRcIixSLkhhcz1cIj9cIixSLkhhc250PVwiIT9cIixSLkludGVyc2VjdD1cIl5cIixSLkxpc3RNaW49XCJMSVNUX01JTlwiLFIuTGlzdE1heD1cIkxJU1RfTUFYXCIsUi5BbGw9XCJMSVNUX0FMTFwiLFIuQ291bnQ9XCJMSVNUX0NPVU5UXCIsUi5WYWx1ZU9mTGlzdD1cIkxJU1RfVkFMVUVcIixSLkludmVydD1cIkxJU1RfSU5WRVJUXCIsUi5fbmF0aXZlRnVuY3Rpb25zPW51bGw7Y2xhc3MgaiBleHRlbmRzIHB7Y29uc3RydWN0b3IodCl7c3VwZXIoKSx0aGlzLnRleHQ9dC50b1N0cmluZygpfHxcIlwifXRvU3RyaW5nKCl7cmV0dXJuXCIjIFwiK3RoaXMudGV4dH19Y2xhc3MgRCBleHRlbmRzIHB7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMudGV4dD1cIlwiLHRoaXMuaW5kZXg9MCx0aGlzLnRocmVhZEF0R2VuZXJhdGlvbj1udWxsLHRoaXMuc291cmNlUGF0aD1cIlwiLHRoaXMudGFyZ2V0UGF0aD1udWxsLHRoaXMuaXNJbnZpc2libGVEZWZhdWx0PSExLHRoaXMub3JpZ2luYWxUaHJlYWRJbmRleD0wfWdldCBwYXRoU3RyaW5nT25DaG9pY2UoKXtyZXR1cm4gbnVsbD09PXRoaXMudGFyZ2V0UGF0aD9kKFwiQ2hvaWNlLnRhcmdldFBhdGhcIik6dGhpcy50YXJnZXRQYXRoLnRvU3RyaW5nKCl9c2V0IHBhdGhTdHJpbmdPbkNob2ljZSh0KXt0aGlzLnRhcmdldFBhdGg9bmV3IGUodCl9fWNsYXNzIEd7Y29uc3RydWN0b3IodCxlKXt0aGlzLl9uYW1lPXR8fFwiXCIsdGhpcy5faXRlbXM9bnVsbCx0aGlzLl9pdGVtTmFtZVRvVmFsdWVzPWV8fG5ldyBNYXB9Z2V0IG5hbWUoKXtyZXR1cm4gdGhpcy5fbmFtZX1nZXQgaXRlbXMoKXtpZihudWxsPT10aGlzLl9pdGVtcyl7dGhpcy5faXRlbXM9bmV3IE1hcDtmb3IobGV0W3QsZV1vZiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzKXtsZXQgbj1uZXcgZih0aGlzLm5hbWUsdCk7dGhpcy5faXRlbXMuc2V0KG4uc2VyaWFsaXplZCgpLGUpfX1yZXR1cm4gdGhpcy5faXRlbXN9VmFsdWVGb3JJdGVtKHQpe2lmKCF0Lml0ZW1OYW1lKXJldHVybiAwO2xldCBlPXRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KHQuaXRlbU5hbWUpO3JldHVybiB2b2lkIDAhPT1lP2U6MH1Db250YWluc0l0ZW0odCl7cmV0dXJuISF0Lml0ZW1OYW1lJiYodC5vcmlnaW5OYW1lPT10aGlzLm5hbWUmJnRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuaGFzKHQuaXRlbU5hbWUpKX1Db250YWluc0l0ZW1XaXRoTmFtZSh0KXtyZXR1cm4gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5oYXModCl9VHJ5R2V0SXRlbVdpdGhWYWx1ZSh0LGUpe2ZvcihsZXRbZSxuXW9mIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMpaWYobj09dClyZXR1cm57cmVzdWx0Om5ldyBmKHRoaXMubmFtZSxlKSxleGlzdHM6ITB9O3JldHVybntyZXN1bHQ6Zi5OdWxsLGV4aXN0czohMX19VHJ5R2V0VmFsdWVGb3JJdGVtKHQsZSl7aWYoIXQuaXRlbU5hbWUpcmV0dXJue3Jlc3VsdDowLGV4aXN0czohMX07bGV0IG49dGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5nZXQodC5pdGVtTmFtZSk7cmV0dXJuIG4/e3Jlc3VsdDpuLGV4aXN0czohMH06e3Jlc3VsdDowLGV4aXN0czohMX19fWNsYXNzIEJ7Y29uc3RydWN0b3IodCl7dGhpcy5fbGlzdHM9bmV3IE1hcCx0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlPW5ldyBNYXA7Zm9yKGxldCBlIG9mIHQpe3RoaXMuX2xpc3RzLnNldChlLm5hbWUsZSk7Zm9yKGxldFt0LG5db2YgZS5pdGVtcyl7bGV0IGU9Zi5mcm9tU2VyaWFsaXplZEtleSh0KSxpPW5ldyBPKGUsbik7aWYoIWUuaXRlbU5hbWUpdGhyb3cgbmV3IEVycm9yKFwiaXRlbS5pdGVtTmFtZSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cIik7dGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5zZXQoZS5pdGVtTmFtZSxpKSx0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChlLmZ1bGxOYW1lLGkpfX19Z2V0IGxpc3RzKCl7bGV0IHQ9W107Zm9yKGxldFssZV1vZiB0aGlzLl9saXN0cyl0LnB1c2goZSk7cmV0dXJuIHR9VHJ5TGlzdEdldERlZmluaXRpb24odCxlKXtpZihudWxsPT09dClyZXR1cm57cmVzdWx0OmUsZXhpc3RzOiExfTtsZXQgbj10aGlzLl9saXN0cy5nZXQodCk7cmV0dXJuIG4/e3Jlc3VsdDpuLGV4aXN0czohMH06e3Jlc3VsdDplLGV4aXN0czohMX19RmluZFNpbmdsZUl0ZW1MaXN0V2l0aE5hbWUodCl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJuYW1lXCIpO2xldCBlPXRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuZ2V0KHQpO3JldHVybiB2b2lkIDAhPT1lP2U6bnVsbH19Y2xhc3MgTXtzdGF0aWMgSkFycmF5VG9SdW50aW1lT2JqTGlzdCh0LGU9ITEpe2xldCBuPXQubGVuZ3RoO2UmJm4tLTtsZXQgaT1bXTtmb3IobGV0IGU9MDtlPG47ZSsrKXtsZXQgbj10W2VdLHI9dGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3Qobik7aWYobnVsbD09PXIpcmV0dXJuIGQoXCJydW50aW1lT2JqXCIpO2kucHVzaChyKX1yZXR1cm4gaX1zdGF0aWMgV3JpdGVEaWN0aW9uYXJ5UnVudGltZU9ianModCxlKXt0LldyaXRlT2JqZWN0U3RhcnQoKTtmb3IobGV0W24saV1vZiBlKXQuV3JpdGVQcm9wZXJ0eVN0YXJ0KG4pLHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHQsaSksdC5Xcml0ZVByb3BlcnR5RW5kKCk7dC5Xcml0ZU9iamVjdEVuZCgpfXN0YXRpYyBXcml0ZUxpc3RSdW50aW1lT2Jqcyh0LGUpe3QuV3JpdGVBcnJheVN0YXJ0KCk7Zm9yKGxldCBuIG9mIGUpdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3QodCxuKTt0LldyaXRlQXJyYXlFbmQoKX1zdGF0aWMgV3JpdGVJbnREaWN0aW9uYXJ5KHQsZSl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldFtuLGldb2YgZSl0LldyaXRlSW50UHJvcGVydHkobixpKTt0LldyaXRlT2JqZWN0RW5kKCl9c3RhdGljIFdyaXRlUnVudGltZU9iamVjdCh0LGUpe2xldCBuPWEoZSxOKTtpZihuKXJldHVybiB2b2lkIHRoaXMuV3JpdGVSdW50aW1lQ29udGFpbmVyKHQsbik7bGV0IGk9YShlLGspO2lmKGkpe2xldCBlLG49XCItPlwiO3JldHVybiBpLmlzRXh0ZXJuYWw/bj1cIngoKVwiOmkucHVzaGVzVG9TdGFjayYmKGkuc3RhY2tQdXNoVHlwZT09ci5GdW5jdGlvbj9uPVwiZigpXCI6aS5zdGFja1B1c2hUeXBlPT1yLlR1bm5lbCYmKG49XCItPnQtPlwiKSksZT1pLmhhc1ZhcmlhYmxlVGFyZ2V0P2kudmFyaWFibGVEaXZlcnROYW1lOmkudGFyZ2V0UGF0aFN0cmluZyx0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHkobixlKSxpLmhhc1ZhcmlhYmxlVGFyZ2V0JiZ0LldyaXRlUHJvcGVydHkoXCJ2YXJcIiwhMCksaS5pc0NvbmRpdGlvbmFsJiZ0LldyaXRlUHJvcGVydHkoXCJjXCIsITApLGkuZXh0ZXJuYWxBcmdzPjAmJnQuV3JpdGVJbnRQcm9wZXJ0eShcImV4QXJnc1wiLGkuZXh0ZXJuYWxBcmdzKSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKX1sZXQgcz1hKGUsVyk7aWYocylyZXR1cm4gdC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5KFwiKlwiLHMucGF0aFN0cmluZ09uQ2hvaWNlKSx0LldyaXRlSW50UHJvcGVydHkoXCJmbGdcIixzLmZsYWdzKSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKTtsZXQgbD1hKGUsYik7aWYobClyZXR1cm4gdm9pZCB0LldyaXRlSW50KGwudmFsdWUpO2xldCBvPWEoZSxfKTtpZihvKXJldHVybiB2b2lkIHQuV3JpdGVGbG9hdChvLnZhbHVlKTtsZXQgdT1hKGUsVCk7aWYodSlyZXR1cm4gdm9pZCh1LmlzTmV3bGluZT90LldyaXRlKFwiXFxuXCIsITEpOih0LldyaXRlU3RyaW5nU3RhcnQoKSx0LldyaXRlU3RyaW5nSW5uZXIoXCJeXCIpLHQuV3JpdGVTdHJpbmdJbm5lcih1LnZhbHVlKSx0LldyaXRlU3RyaW5nRW5kKCkpKTtsZXQgaD1hKGUsTyk7aWYoaClyZXR1cm4gdm9pZCB0aGlzLldyaXRlSW5rTGlzdCh0LGgpO2xldCBjPWEoZSxQKTtpZihjKXJldHVybiB0LldyaXRlT2JqZWN0U3RhcnQoKSxudWxsPT09Yy52YWx1ZT9kKFwiZGl2VGFyZ2V0VmFsLnZhbHVlXCIpOih0LldyaXRlUHJvcGVydHkoXCJeLT5cIixjLnZhbHVlLmNvbXBvbmVudHNTdHJpbmcpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpKTtsZXQgcD1hKGUsdyk7aWYocClyZXR1cm4gdC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5KFwiXnZhclwiLHAudmFsdWUpLHQuV3JpdGVJbnRQcm9wZXJ0eShcImNpXCIscC5jb250ZXh0SW5kZXgpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpO2lmKGEoZSx4KSlyZXR1cm4gdm9pZCB0LldyaXRlKFwiPD5cIik7bGV0IG09YShlLEEpO2lmKG0pcmV0dXJuIHZvaWQgdC5Xcml0ZShNLl9jb250cm9sQ29tbWFuZE5hbWVzW20uY29tbWFuZFR5cGVdKTtsZXQgZj1hKGUsUik7aWYoZil7bGV0IGU9Zi5uYW1lO3JldHVyblwiXlwiPT1lJiYoZT1cIkxeXCIpLHZvaWQgdC5Xcml0ZShlKX1sZXQgZz1hKGUsRik7aWYoZyl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7bGV0IGU9Zy5wYXRoU3RyaW5nRm9yQ291bnQ7cmV0dXJuIG51bGwhPWU/dC5Xcml0ZVByb3BlcnR5KFwiQ05UP1wiLGUpOnQuV3JpdGVQcm9wZXJ0eShcIlZBUj9cIixnLm5hbWUpLHZvaWQgdC5Xcml0ZU9iamVjdEVuZCgpfWxldCBTPWEoZSxWKTtpZihTKXt0LldyaXRlT2JqZWN0U3RhcnQoKTtsZXQgZT1TLmlzR2xvYmFsP1wiVkFSPVwiOlwidGVtcD1cIjtyZXR1cm4gdC5Xcml0ZVByb3BlcnR5KGUsUy52YXJpYWJsZU5hbWUpLFMuaXNOZXdEZWNsYXJhdGlvbnx8dC5Xcml0ZVByb3BlcnR5KFwicmVcIiwhMCksdm9pZCB0LldyaXRlT2JqZWN0RW5kKCl9aWYoYShlLEwpKXJldHVybiB2b2lkIHQuV3JpdGUoXCJ2b2lkXCIpO2xldCB5PWEoZSxqKTtpZih5KXJldHVybiB0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHkoXCIjXCIseS50ZXh0KSx2b2lkIHQuV3JpdGVPYmplY3RFbmQoKTtsZXQgQz1hKGUsRCk7aWYoIUMpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgcnVudGltZSBvYmplY3QgdG8gSnNvbiB0b2tlbjogXCIrZSk7dGhpcy5Xcml0ZUNob2ljZSh0LEMpfXN0YXRpYyBKT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianModCl7bGV0IGU9bmV3IE1hcDtmb3IobGV0IG4gaW4gdClpZih0Lmhhc093blByb3BlcnR5KG4pKXtsZXQgaT10aGlzLkpUb2tlblRvUnVudGltZU9iamVjdCh0W25dKTtpZihudWxsPT09aSlyZXR1cm4gZChcImlua09iamVjdFwiKTtlLnNldChuLGkpfXJldHVybiBlfXN0YXRpYyBKT2JqZWN0VG9JbnREaWN0aW9uYXJ5KHQpe2xldCBlPW5ldyBNYXA7Zm9yKGxldCBuIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShuKSYmZS5zZXQobixwYXJzZUludCh0W25dKSk7cmV0dXJuIGV9c3RhdGljIEpUb2tlblRvUnVudGltZU9iamVjdCh0KXtpZihcIm51bWJlclwiPT10eXBlb2YgdCYmIWlzTmFOKHQpKXJldHVybiB2LkNyZWF0ZSh0KTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl7bGV0IGU9dC50b1N0cmluZygpLG49ZVswXTtpZihcIl5cIj09bilyZXR1cm4gbmV3IFQoZS5zdWJzdHJpbmcoMSkpO2lmKFwiXFxuXCI9PW4mJjE9PWUubGVuZ3RoKXJldHVybiBuZXcgVChcIlxcblwiKTtpZihcIjw+XCI9PWUpcmV0dXJuIG5ldyB4O2ZvcihsZXQgdD0wO3Q8TS5fY29udHJvbENvbW1hbmROYW1lcy5sZW5ndGg7Kyt0KXtpZihlPT1NLl9jb250cm9sQ29tbWFuZE5hbWVzW3RdKXJldHVybiBuZXcgQSh0KX1pZihcIkxeXCI9PWUmJihlPVwiXlwiKSxSLkNhbGxFeGlzdHNXaXRoTmFtZShlKSlyZXR1cm4gUi5DYWxsV2l0aE5hbWUoZSk7aWYoXCItPi0+XCI9PWUpcmV0dXJuIEEuUG9wVHVubmVsKCk7aWYoXCJ+cmV0XCI9PWUpcmV0dXJuIEEuUG9wRnVuY3Rpb24oKTtpZihcInZvaWRcIj09ZSlyZXR1cm4gbmV3IEx9aWYoXCJvYmplY3RcIj09dHlwZW9mIHQmJiFBcnJheS5pc0FycmF5KHQpKXtsZXQgbixpPXQ7aWYoaVtcIl4tPlwiXSlyZXR1cm4gbj1pW1wiXi0+XCJdLG5ldyBQKG5ldyBlKG4udG9TdHJpbmcoKSkpO2lmKGlbXCJedmFyXCJdKXtuPWlbXCJedmFyXCJdO2xldCB0PW5ldyB3KG4udG9TdHJpbmcoKSk7cmV0dXJuXCJjaVwiaW4gaSYmKG49aS5jaSx0LmNvbnRleHRJbmRleD1wYXJzZUludChuKSksdH1sZXQgYT0hMSxzPSExLGw9ci5GdW5jdGlvbixvPSExO2lmKChuPWlbXCItPlwiXSk/YT0hMDoobj1pW1wiZigpXCJdKT8oYT0hMCxzPSEwLGw9ci5GdW5jdGlvbik6KG49aVtcIi0+dC0+XCJdKT8oYT0hMCxzPSEwLGw9ci5UdW5uZWwpOihuPWlbXCJ4KClcIl0pJiYoYT0hMCxvPSEwLHM9ITEsbD1yLkZ1bmN0aW9uKSxhKXtsZXQgdD1uZXcgazt0LnB1c2hlc1RvU3RhY2s9cyx0LnN0YWNrUHVzaFR5cGU9bCx0LmlzRXh0ZXJuYWw9bztsZXQgZT1uLnRvU3RyaW5nKCk7cmV0dXJuKG49aS52YXIpP3QudmFyaWFibGVEaXZlcnROYW1lPWU6dC50YXJnZXRQYXRoU3RyaW5nPWUsdC5pc0NvbmRpdGlvbmFsPSEhaS5jLG8mJihuPWkuZXhBcmdzKSYmKHQuZXh0ZXJuYWxBcmdzPXBhcnNlSW50KG4pKSx0fWlmKG49aVtcIipcIl0pe2xldCB0PW5ldyBXO3JldHVybiB0LnBhdGhTdHJpbmdPbkNob2ljZT1uLnRvU3RyaW5nKCksKG49aS5mbGcpJiYodC5mbGFncz1wYXJzZUludChuKSksdH1pZihuPWlbXCJWQVI/XCJdKXJldHVybiBuZXcgRihuLnRvU3RyaW5nKCkpO2lmKG49aVtcIkNOVD9cIl0pe2xldCB0PW5ldyBGO3JldHVybiB0LnBhdGhTdHJpbmdGb3JDb3VudD1uLnRvU3RyaW5nKCksdH1sZXQgdT0hMSxoPSExO2lmKChuPWlbXCJWQVI9XCJdKT8odT0hMCxoPSEwKToobj1pW1widGVtcD1cIl0pJiYodT0hMCxoPSExKSx1KXtsZXQgdD1uLnRvU3RyaW5nKCksZT0haS5yZSxyPW5ldyBWKHQsZSk7cmV0dXJuIHIuaXNHbG9iYWw9aCxyfWlmKHZvaWQgMCE9PWlbXCIjXCJdKXJldHVybiBuPWlbXCIjXCJdLG5ldyBqKG4udG9TdHJpbmcoKSk7aWYobj1pLmxpc3Qpe2xldCB0PW4sZT1uZXcgZztpZihuPWkub3JpZ2lucyl7bGV0IHQ9bjtlLlNldEluaXRpYWxPcmlnaW5OYW1lcyh0KX1mb3IobGV0IG4gaW4gdClpZih0Lmhhc093blByb3BlcnR5KG4pKXtsZXQgaT10W25dLHI9bmV3IGYobiksYT1wYXJzZUludChpKTtlLkFkZChyLGEpfXJldHVybiBuZXcgTyhlKX1pZihudWxsIT1pLm9yaWdpbmFsQ2hvaWNlUGF0aClyZXR1cm4gdGhpcy5KT2JqZWN0VG9DaG9pY2UoaSl9aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdGhpcy5KQXJyYXlUb0NvbnRhaW5lcih0KTtpZihudWxsPT10KXJldHVybiBudWxsO3Rocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHRva2VuIHRvIHJ1bnRpbWUgb2JqZWN0OiBcIitKU09OLnN0cmluZ2lmeSh0KSl9c3RhdGljIFdyaXRlUnVudGltZUNvbnRhaW5lcih0LGUsbj0hMSl7aWYodC5Xcml0ZUFycmF5U3RhcnQoKSxudWxsPT09ZSlyZXR1cm4gZChcImNvbnRhaW5lclwiKTtmb3IobGV0IG4gb2YgZS5jb250ZW50KXRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHQsbik7bGV0IGk9ZS5uYW1lZE9ubHlDb250ZW50LHI9ZS5jb3VudEZsYWdzLHM9bnVsbCE9ZS5uYW1lJiYhbixsPW51bGwhPWl8fHI+MHx8cztpZihsJiZ0LldyaXRlT2JqZWN0U3RhcnQoKSxudWxsIT1pKWZvcihsZXRbZSxuXW9mIGkpe2xldCBpPWUscj1hKG4sTik7dC5Xcml0ZVByb3BlcnR5U3RhcnQoaSksdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIodCxyLCEwKSx0LldyaXRlUHJvcGVydHlFbmQoKX1zJiZ0LldyaXRlUHJvcGVydHkoXCIjblwiLGUubmFtZSksbD90LldyaXRlT2JqZWN0RW5kKCk6dC5Xcml0ZU51bGwoKSx0LldyaXRlQXJyYXlFbmQoKX1zdGF0aWMgSkFycmF5VG9Db250YWluZXIodCl7bGV0IGU9bmV3IE47ZS5jb250ZW50PXRoaXMuSkFycmF5VG9SdW50aW1lT2JqTGlzdCh0LCEwKTtsZXQgbj10W3QubGVuZ3RoLTFdO2lmKG51bGwhPW4pe2xldCB0PW5ldyBNYXA7Zm9yKGxldCBpIGluIG4paWYoXCIjZlwiPT1pKWUuY291bnRGbGFncz1wYXJzZUludChuW2ldKTtlbHNlIGlmKFwiI25cIj09aSllLm5hbWU9bltpXS50b1N0cmluZygpO2Vsc2V7bGV0IGU9dGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3QobltpXSkscj1hKGUsTik7ciYmKHIubmFtZT1pKSx0LnNldChpLGUpfWUubmFtZWRPbmx5Q29udGVudD10fXJldHVybiBlfXN0YXRpYyBKT2JqZWN0VG9DaG9pY2UodCl7bGV0IGU9bmV3IEQ7cmV0dXJuIGUudGV4dD10LnRleHQudG9TdHJpbmcoKSxlLmluZGV4PXBhcnNlSW50KHQuaW5kZXgpLGUuc291cmNlUGF0aD10Lm9yaWdpbmFsQ2hvaWNlUGF0aC50b1N0cmluZygpLGUub3JpZ2luYWxUaHJlYWRJbmRleD1wYXJzZUludCh0Lm9yaWdpbmFsVGhyZWFkSW5kZXgpLGUucGF0aFN0cmluZ09uQ2hvaWNlPXQudGFyZ2V0UGF0aC50b1N0cmluZygpLGV9c3RhdGljIFdyaXRlQ2hvaWNlKHQsZSl7dC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5KFwidGV4dFwiLGUudGV4dCksdC5Xcml0ZUludFByb3BlcnR5KFwiaW5kZXhcIixlLmluZGV4KSx0LldyaXRlUHJvcGVydHkoXCJvcmlnaW5hbENob2ljZVBhdGhcIixlLnNvdXJjZVBhdGgpLHQuV3JpdGVJbnRQcm9wZXJ0eShcIm9yaWdpbmFsVGhyZWFkSW5kZXhcIixlLm9yaWdpbmFsVGhyZWFkSW5kZXgpLHQuV3JpdGVQcm9wZXJ0eShcInRhcmdldFBhdGhcIixlLnBhdGhTdHJpbmdPbkNob2ljZSksdC5Xcml0ZU9iamVjdEVuZCgpfXN0YXRpYyBXcml0ZUlua0xpc3QodCxlKXtsZXQgbj1lLnZhbHVlO2lmKG51bGw9PT1uKXJldHVybiBkKFwicmF3TGlzdFwiKTt0LldyaXRlT2JqZWN0U3RhcnQoKSx0LldyaXRlUHJvcGVydHlTdGFydChcImxpc3RcIiksdC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldFtlLGldb2Ygbil7bGV0IG49Zi5mcm9tU2VyaWFsaXplZEtleShlKSxyPWk7aWYobnVsbD09PW4uaXRlbU5hbWUpcmV0dXJuIGQoXCJpdGVtLml0ZW1OYW1lXCIpO3QuV3JpdGVQcm9wZXJ0eU5hbWVTdGFydCgpLHQuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihuLm9yaWdpbk5hbWU/bi5vcmlnaW5OYW1lOlwiP1wiKSx0LldyaXRlUHJvcGVydHlOYW1lSW5uZXIoXCIuXCIpLHQuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihuLml0ZW1OYW1lKSx0LldyaXRlUHJvcGVydHlOYW1lRW5kKCksdC5Xcml0ZShyKSx0LldyaXRlUHJvcGVydHlFbmQoKX1pZih0LldyaXRlT2JqZWN0RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCksMD09bi5Db3VudCYmbnVsbCE9bi5vcmlnaW5OYW1lcyYmbi5vcmlnaW5OYW1lcy5sZW5ndGg+MCl7dC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJvcmlnaW5zXCIpLHQuV3JpdGVBcnJheVN0YXJ0KCk7Zm9yKGxldCBlIG9mIG4ub3JpZ2luTmFtZXMpdC5Xcml0ZShlKTt0LldyaXRlQXJyYXlFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKX10LldyaXRlT2JqZWN0RW5kKCl9c3RhdGljIExpc3REZWZpbml0aW9uc1RvSlRva2VuKHQpe2xldCBlPXt9O2ZvcihsZXQgbiBvZiB0Lmxpc3RzKXtsZXQgdD17fTtmb3IobGV0W2UsaV1vZiBuLml0ZW1zKXtsZXQgbj1mLmZyb21TZXJpYWxpemVkS2V5KGUpO2lmKG51bGw9PT1uLml0ZW1OYW1lKXJldHVybiBkKFwiaXRlbS5pdGVtTmFtZVwiKTt0W24uaXRlbU5hbWVdPWl9ZVtuLm5hbWVdPXR9cmV0dXJuIGV9c3RhdGljIEpUb2tlblRvTGlzdERlZmluaXRpb25zKHQpe2xldCBlPXQsbj1bXTtmb3IobGV0IHQgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHQpKXtsZXQgaT10LnRvU3RyaW5nKCkscj1lW3RdLGE9bmV3IE1hcDtmb3IobGV0IG4gaW4gcilpZihlLmhhc093blByb3BlcnR5KHQpKXtsZXQgdD1yW25dO2Euc2V0KG4scGFyc2VJbnQodCkpfWxldCBzPW5ldyBHKGksYSk7bi5wdXNoKHMpfXJldHVybiBuZXcgQihuKX19TS5fY29udHJvbENvbW1hbmROYW1lcz0oKCk9PntsZXQgdD1bXTt0W0EuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0XT1cImV2XCIsdFtBLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXRdPVwib3V0XCIsdFtBLkNvbW1hbmRUeXBlLkV2YWxFbmRdPVwiL2V2XCIsdFtBLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZV09XCJkdVwiLHRbQS5Db21tYW5kVHlwZS5Qb3BFdmFsdWF0ZWRWYWx1ZV09XCJwb3BcIix0W0EuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb25dPVwifnJldFwiLHRbQS5Db21tYW5kVHlwZS5Qb3BUdW5uZWxdPVwiLT4tPlwiLHRbQS5Db21tYW5kVHlwZS5CZWdpblN0cmluZ109XCJzdHJcIix0W0EuQ29tbWFuZFR5cGUuRW5kU3RyaW5nXT1cIi9zdHJcIix0W0EuQ29tbWFuZFR5cGUuTm9PcF09XCJub3BcIix0W0EuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnRdPVwiY2hvaWNlQ250XCIsdFtBLkNvbW1hbmRUeXBlLlR1cm5zXT1cInR1cm5cIix0W0EuQ29tbWFuZFR5cGUuVHVybnNTaW5jZV09XCJ0dXJuc1wiLHRbQS5Db21tYW5kVHlwZS5SZWFkQ291bnRdPVwicmVhZGNcIix0W0EuQ29tbWFuZFR5cGUuUmFuZG9tXT1cInJuZFwiLHRbQS5Db21tYW5kVHlwZS5TZWVkUmFuZG9tXT1cInNybmRcIix0W0EuQ29tbWFuZFR5cGUuVmlzaXRJbmRleF09XCJ2aXNpdFwiLHRbQS5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleF09XCJzZXFcIix0W0EuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWRdPVwidGhyZWFkXCIsdFtBLkNvbW1hbmRUeXBlLkRvbmVdPVwiZG9uZVwiLHRbQS5Db21tYW5kVHlwZS5FbmRdPVwiZW5kXCIsdFtBLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50XT1cImxpc3RJbnRcIix0W0EuQ29tbWFuZFR5cGUuTGlzdFJhbmdlXT1cInJhbmdlXCIsdFtBLkNvbW1hbmRUeXBlLkxpc3RSYW5kb21dPVwibHJuZFwiO2ZvcihsZXQgZT0wO2U8QS5Db21tYW5kVHlwZS5UT1RBTF9WQUxVRVM7KytlKWlmKG51bGw9PXRbZV0pdGhyb3cgbmV3IEVycm9yKFwiQ29udHJvbCBjb21tYW5kIG5vdCBhY2NvdW50ZWQgZm9yIGluIHNlcmlhbGlzYXRpb25cIik7cmV0dXJuIHR9KSgpO2NsYXNzIHF7Y29uc3RydWN0b3IoKXtpZih0aGlzLl90aHJlYWRDb3VudGVyPTAsdGhpcy5fc3RhcnRPZlJvb3Q9SS5OdWxsLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgWCl7bGV0IHQ9YXJndW1lbnRzWzBdO3RoaXMuX3N0YXJ0T2ZSb290PUkuU3RhcnRPZih0LnJvb3RDb250ZW50Q29udGFpbmVyKSx0aGlzLlJlc2V0KCl9ZWxzZXtsZXQgdD1hcmd1bWVudHNbMF07dGhpcy5fdGhyZWFkcz1bXTtmb3IobGV0IGUgb2YgdC5fdGhyZWFkcyl0aGlzLl90aHJlYWRzLnB1c2goZS5Db3B5KCkpO3RoaXMuX3RocmVhZENvdW50ZXI9dC5fdGhyZWFkQ291bnRlcix0aGlzLl9zdGFydE9mUm9vdD10Ll9zdGFydE9mUm9vdH19Z2V0IGVsZW1lbnRzKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrfWdldCBkZXB0aCgpe3JldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aH1nZXQgY3VycmVudEVsZW1lbnQoKXtsZXQgdD10aGlzLl90aHJlYWRzW3RoaXMuX3RocmVhZHMubGVuZ3RoLTFdLmNhbGxzdGFjaztyZXR1cm4gdFt0Lmxlbmd0aC0xXX1nZXQgY3VycmVudEVsZW1lbnRJbmRleCgpe3JldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGgtMX1nZXQgY3VycmVudFRocmVhZCgpe3JldHVybiB0aGlzLl90aHJlYWRzW3RoaXMuX3RocmVhZHMubGVuZ3RoLTFdfXNldCBjdXJyZW50VGhyZWFkKHQpe24uQXNzZXJ0KDE9PXRoaXMuX3RocmVhZHMubGVuZ3RoLFwiU2hvdWxkbid0IGJlIGRpcmVjdGx5IHNldHRpbmcgdGhlIGN1cnJlbnQgdGhyZWFkIHdoZW4gd2UgaGF2ZSBhIHN0YWNrIG9mIHRoZW1cIiksdGhpcy5fdGhyZWFkcy5sZW5ndGg9MCx0aGlzLl90aHJlYWRzLnB1c2godCl9Z2V0IGNhblBvcCgpe3JldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGg+MX1SZXNldCgpe3RoaXMuX3RocmVhZHM9W10sdGhpcy5fdGhyZWFkcy5wdXNoKG5ldyBxLlRocmVhZCksdGhpcy5fdGhyZWFkc1swXS5jYWxsc3RhY2sucHVzaChuZXcgcS5FbGVtZW50KHIuVHVubmVsLHRoaXMuX3N0YXJ0T2ZSb290KSl9U2V0SnNvblRva2VuKHQsZSl7dGhpcy5fdGhyZWFkcy5sZW5ndGg9MDtsZXQgbj10LnRocmVhZHM7Zm9yKGxldCB0IG9mIG4pe2xldCBuPXQsaT1uZXcgcS5UaHJlYWQobixlKTt0aGlzLl90aHJlYWRzLnB1c2goaSl9dGhpcy5fdGhyZWFkQ291bnRlcj1wYXJzZUludCh0LnRocmVhZENvdW50ZXIpLHRoaXMuX3N0YXJ0T2ZSb290PUkuU3RhcnRPZihlLnJvb3RDb250ZW50Q29udGFpbmVyKX1Xcml0ZUpzb24odCl7dC5Xcml0ZU9iamVjdCh0PT57dC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRzXCIpLHQuV3JpdGVBcnJheVN0YXJ0KCk7Zm9yKGxldCBlIG9mIHRoaXMuX3RocmVhZHMpZS5Xcml0ZUpzb24odCk7dC5Xcml0ZUFycmF5RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCksdC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRDb3VudGVyXCIpLHQuV3JpdGVJbnQodGhpcy5fdGhyZWFkQ291bnRlciksdC5Xcml0ZVByb3BlcnR5RW5kKCl9KX1QdXNoVGhyZWFkKCl7bGV0IHQ9dGhpcy5jdXJyZW50VGhyZWFkLkNvcHkoKTt0aGlzLl90aHJlYWRDb3VudGVyKyssdC50aHJlYWRJbmRleD10aGlzLl90aHJlYWRDb3VudGVyLHRoaXMuX3RocmVhZHMucHVzaCh0KX1Gb3JrVGhyZWFkKCl7bGV0IHQ9dGhpcy5jdXJyZW50VGhyZWFkLkNvcHkoKTtyZXR1cm4gdGhpcy5fdGhyZWFkQ291bnRlcisrLHQudGhyZWFkSW5kZXg9dGhpcy5fdGhyZWFkQ291bnRlcix0fVBvcFRocmVhZCgpe2lmKCF0aGlzLmNhblBvcFRocmVhZCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgdGhyZWFkXCIpO3RoaXMuX3RocmVhZHMuc3BsaWNlKHRoaXMuX3RocmVhZHMuaW5kZXhPZih0aGlzLmN1cnJlbnRUaHJlYWQpLDEpfWdldCBjYW5Qb3BUaHJlYWQoKXtyZXR1cm4gdGhpcy5fdGhyZWFkcy5sZW5ndGg+MSYmIXRoaXMuZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZX1nZXQgZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZSgpe3JldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGU9PXIuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWV9UHVzaCh0LGU9MCxuPTApe2xldCBpPW5ldyBxLkVsZW1lbnQodCx0aGlzLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLCExKTtpLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ9ZSxpLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbT1uLHRoaXMuY2FsbFN0YWNrLnB1c2goaSl9Q2FuUG9wKHQ9bnVsbCl7cmV0dXJuISF0aGlzLmNhblBvcCYmKG51bGw9PXR8fHRoaXMuY3VycmVudEVsZW1lbnQudHlwZT09dCl9UG9wKHQ9bnVsbCl7aWYoIXRoaXMuQ2FuUG9wKHQpKXRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcHVzaC9wb3AgaW4gQ2FsbHN0YWNrXCIpO3RoaXMuY2FsbFN0YWNrLnBvcCgpfUdldFRlbXBvcmFyeVZhcmlhYmxlV2l0aE5hbWUodCxlPS0xKXstMT09ZSYmKGU9dGhpcy5jdXJyZW50RWxlbWVudEluZGV4KzEpO2xldCBuPXkodGhpcy5jYWxsU3RhY2tbZS0xXS50ZW1wb3JhcnlWYXJpYWJsZXMsdCxudWxsKTtyZXR1cm4gbi5leGlzdHM/bi5yZXN1bHQ6bnVsbH1TZXRUZW1wb3JhcnlWYXJpYWJsZSh0LGUsbixpPS0xKXstMT09aSYmKGk9dGhpcy5jdXJyZW50RWxlbWVudEluZGV4KzEpO2xldCByPXRoaXMuY2FsbFN0YWNrW2ktMV07aWYoIW4mJiFyLnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQodCkpdGhyb3cgbmV3IFMoXCJDb3VsZCBub3QgZmluZCB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gc2V0OiBcIit0KTtsZXQgYT15KHIudGVtcG9yYXJ5VmFyaWFibGVzLHQsbnVsbCk7YS5leGlzdHMmJk8uUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KGEucmVzdWx0LGUpLHIudGVtcG9yYXJ5VmFyaWFibGVzLnNldCh0LGUpfUNvbnRleHRGb3JWYXJpYWJsZU5hbWVkKHQpe3JldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQodCk/dGhpcy5jdXJyZW50RWxlbWVudEluZGV4KzE6MH1UaHJlYWRXaXRoSW5kZXgodCl7bGV0IGU9dGhpcy5fdGhyZWFkcy5maWx0ZXIoZT0+e2lmKGUudGhyZWFkSW5kZXg9PXQpcmV0dXJuIGV9KTtyZXR1cm4gZS5sZW5ndGg+MD9lWzBdOm51bGx9Z2V0IGNhbGxTdGFjaygpe3JldHVybiB0aGlzLmN1cnJlbnRUaHJlYWQuY2FsbHN0YWNrfWdldCBjYWxsU3RhY2tUcmFjZSgpe2xldCB0PW5ldyBtO2ZvcihsZXQgZT0wO2U8dGhpcy5fdGhyZWFkcy5sZW5ndGg7ZSsrKXtsZXQgbj10aGlzLl90aHJlYWRzW2VdLGk9ZT09dGhpcy5fdGhyZWFkcy5sZW5ndGgtMTt0LkFwcGVuZEZvcm1hdChcIj09PSBUSFJFQUQgezB9L3sxfSB7Mn09PT1cXG5cIixlKzEsdGhpcy5fdGhyZWFkcy5sZW5ndGgsaT9cIihjdXJyZW50KSBcIjpcIlwiKTtmb3IobGV0IGU9MDtlPG4uY2FsbHN0YWNrLmxlbmd0aDtlKyspe24uY2FsbHN0YWNrW2VdLnR5cGU9PXIuRnVuY3Rpb24/dC5BcHBlbmQoXCIgIFtGVU5DVElPTl0gXCIpOnQuQXBwZW5kKFwiICBbVFVOTkVMXSBcIik7bGV0IGk9bi5jYWxsc3RhY2tbZV0uY3VycmVudFBvaW50ZXI7aWYoIWkuaXNOdWxsKXtpZih0LkFwcGVuZChcIjxTT01FV0hFUkUgSU4gXCIpLG51bGw9PT1pLmNvbnRhaW5lcilyZXR1cm4gZChcInBvaW50ZXIuY29udGFpbmVyXCIpO3QuQXBwZW5kKGkuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSksdC5BcHBlbmRMaW5lKFwiPlwiKX19fXJldHVybiB0LnRvU3RyaW5nKCl9fSFmdW5jdGlvbih0KXtjbGFzcyBue2NvbnN0cnVjdG9yKHQsZSxuPSExKXt0aGlzLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ9MCx0aGlzLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbT0wLHRoaXMuY3VycmVudFBvaW50ZXI9ZS5jb3B5KCksdGhpcy5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPW4sdGhpcy50ZW1wb3JhcnlWYXJpYWJsZXM9bmV3IE1hcCx0aGlzLnR5cGU9dH1Db3B5KCl7bGV0IHQ9bmV3IG4odGhpcy50eXBlLHRoaXMuY3VycmVudFBvaW50ZXIsdGhpcy5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtyZXR1cm4gdC50ZW1wb3JhcnlWYXJpYWJsZXM9bmV3IE1hcCh0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcyksdC5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkPXRoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCx0LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbT10aGlzLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSx0fX10LkVsZW1lbnQ9bjtjbGFzcyBpe2NvbnN0cnVjdG9yKCl7aWYodGhpcy50aHJlYWRJbmRleD0wLHRoaXMucHJldmlvdXNQb2ludGVyPUkuTnVsbCx0aGlzLmNhbGxzdGFjaz1bXSxhcmd1bWVudHNbMF0mJmFyZ3VtZW50c1sxXSl7bGV0IHQ9YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMudGhyZWFkSW5kZXg9cGFyc2VJbnQodC50aHJlYWRJbmRleCk7bGV0IHI9dC5jYWxsc3RhY2s7Zm9yKGxldCB0IG9mIHIpe2xldCByLGE9dCxzPXBhcnNlSW50KGEudHlwZSksbD1JLk51bGwsbz1hLmNQYXRoO2lmKHZvaWQgMCE9PW8pe3I9by50b1N0cmluZygpO2xldCB0PWkuQ29udGVudEF0UGF0aChuZXcgZShyKSk7aWYobC5jb250YWluZXI9dC5jb250YWluZXIsbC5pbmRleD1wYXJzZUludChhLmlkeCksbnVsbD09dC5vYmopdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBsb2FkaW5nIHN0YXRlLCBpbnRlcm5hbCBzdG9yeSBsb2NhdGlvbiBjb3VsZG4ndCBiZSBmb3VuZDogXCIrcitcIi4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKTtpZih0LmFwcHJveGltYXRlKXtpZihudWxsPT09bC5jb250YWluZXIpcmV0dXJuIGQoXCJwb2ludGVyLmNvbnRhaW5lclwiKTtpLldhcm5pbmcoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGV4YWN0IGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiAnXCIrcitcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG8gJ1wiK2wuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKStcIicgdG8gcmVjb3Zlci4gSGFzIHRoZSBzdG9yeSBjaGFuZ2VkIHNpbmNlIHRoaXMgc2F2ZSBkYXRhIHdhcyBjcmVhdGVkP1wiKX19bGV0IHU9ISFhLmV4cCxoPW5ldyBuKHMsbCx1KSxjPWEudGVtcDt2b2lkIDAhPT1jP2gudGVtcG9yYXJ5VmFyaWFibGVzPU0uSk9iamVjdFRvRGljdGlvbmFyeVJ1bnRpbWVPYmpzKGMpOmgudGVtcG9yYXJ5VmFyaWFibGVzLmNsZWFyKCksdGhpcy5jYWxsc3RhY2sucHVzaChoKX1sZXQgYT10LnByZXZpb3VzQ29udGVudE9iamVjdDtpZih2b2lkIDAhPT1hKXtsZXQgdD1uZXcgZShhLnRvU3RyaW5nKCkpO3RoaXMucHJldmlvdXNQb2ludGVyPWkuUG9pbnRlckF0UGF0aCh0KX19fUNvcHkoKXtsZXQgdD1uZXcgaTt0LnRocmVhZEluZGV4PXRoaXMudGhyZWFkSW5kZXg7Zm9yKGxldCBlIG9mIHRoaXMuY2FsbHN0YWNrKXQuY2FsbHN0YWNrLnB1c2goZS5Db3B5KCkpO3JldHVybiB0LnByZXZpb3VzUG9pbnRlcj10aGlzLnByZXZpb3VzUG9pbnRlci5jb3B5KCksdH1Xcml0ZUpzb24odCl7dC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjYWxsc3RhY2tcIiksdC5Xcml0ZUFycmF5U3RhcnQoKTtmb3IobGV0IGUgb2YgdGhpcy5jYWxsc3RhY2spe2lmKHQuV3JpdGVPYmplY3RTdGFydCgpLCFlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCl7aWYobnVsbD09PWUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyKXJldHVybiBkKFwiZWwuY3VycmVudFBvaW50ZXIuY29udGFpbmVyXCIpO3QuV3JpdGVQcm9wZXJ0eShcImNQYXRoXCIsZS5jdXJyZW50UG9pbnRlci5jb250YWluZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKSx0LldyaXRlSW50UHJvcGVydHkoXCJpZHhcIixlLmN1cnJlbnRQb2ludGVyLmluZGV4KX10LldyaXRlUHJvcGVydHkoXCJleHBcIixlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pLHQuV3JpdGVJbnRQcm9wZXJ0eShcInR5cGVcIixlLnR5cGUpLGUudGVtcG9yYXJ5VmFyaWFibGVzLnNpemU+MCYmKHQuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGVtcFwiKSxNLldyaXRlRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHQsZS50ZW1wb3JhcnlWYXJpYWJsZXMpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpKSx0LldyaXRlT2JqZWN0RW5kKCl9aWYodC5Xcml0ZUFycmF5RW5kKCksdC5Xcml0ZVByb3BlcnR5RW5kKCksdC5Xcml0ZUludFByb3BlcnR5KFwidGhyZWFkSW5kZXhcIix0aGlzLnRocmVhZEluZGV4KSwhdGhpcy5wcmV2aW91c1BvaW50ZXIuaXNOdWxsKXtsZXQgZT10aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKCk7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJ0aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKClcIik7dC5Xcml0ZVByb3BlcnR5KFwicHJldmlvdXNDb250ZW50T2JqZWN0XCIsZS5wYXRoLnRvU3RyaW5nKCkpfXQuV3JpdGVPYmplY3RFbmQoKX19dC5UaHJlYWQ9aX0ocXx8KHE9e30pKTtjbGFzcyBKe2NvbnN0cnVjdG9yKHQsZSl7dGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcz1bXSx0aGlzLnBhdGNoPW51bGwsdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXM9ITEsdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcz1uZXcgTWFwLHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icz1uZXcgU2V0LHRoaXMuX2dsb2JhbFZhcmlhYmxlcz1uZXcgTWFwLHRoaXMuX2NhbGxTdGFjaz10LHRoaXMuX2xpc3REZWZzT3JpZ2luPWU7dHJ5e3JldHVybiBuZXcgUHJveHkodGhpcyx7Z2V0Oih0LGUpPT5lIGluIHQ/dFtlXTp0LiQoZSksc2V0Oih0LGUsbik9PihlIGluIHQ/dFtlXT1uOnQuJChlLG4pLCEwKX0pfWNhdGNoKHQpe319dmFyaWFibGVDaGFuZ2VkRXZlbnQodCxlKXtmb3IobGV0IG4gb2YgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcyluKHQsZSl9Z2V0IGJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKCl7cmV0dXJuIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzfXNldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyh0KXtpZih0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcz10LHQpdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzPW5ldyBTZXQ7ZWxzZSBpZihudWxsIT10aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpe2ZvcihsZXQgdCBvZiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMpe2xldCBlPXRoaXMuX2dsb2JhbFZhcmlhYmxlcy5nZXQodCk7ZT90aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHQsZSk6ZChcImN1cnJlbnRWYWx1ZVwiKX10aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnM9bnVsbH19Z2V0IGNhbGxTdGFjaygpe3JldHVybiB0aGlzLl9jYWxsU3RhY2t9c2V0IGNhbGxTdGFjayh0KXt0aGlzLl9jYWxsU3RhY2s9dH0kKHQsZSl7aWYodm9pZCAwPT09ZSl7bGV0IGU9bnVsbDtyZXR1cm4gbnVsbCE9PXRoaXMucGF0Y2gmJihlPXRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHQsbnVsbCksZS5leGlzdHMpP2UucmVzdWx0LnZhbHVlT2JqZWN0OihlPXRoaXMuX2dsb2JhbFZhcmlhYmxlcy5nZXQodCksdm9pZCAwPT09ZSYmKGU9dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQodCkpLHZvaWQgMCE9PWU/ZS52YWx1ZU9iamVjdDpudWxsKX17aWYodm9pZCAwPT09dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQodCkpdGhyb3cgbmV3IFMoXCJDYW5ub3QgYXNzaWduIHRvIGEgdmFyaWFibGUgKFwiK3QrXCIpIHRoYXQgaGFzbid0IGJlZW4gZGVjbGFyZWQgaW4gdGhlIHN0b3J5XCIpO2xldCBuPXYuQ3JlYXRlKGUpO2lmKG51bGw9PW4pdGhyb3cgbmV3IFMobnVsbD09ZT9cIkNhbm5vdCBwYXNzIG51bGwgdG8gVmFyaWFibGVTdGF0ZVwiOlwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gVmFyaWFibGVTdGF0ZTogXCIrZS50b1N0cmluZygpKTt0aGlzLlNldEdsb2JhbCh0LG4pfX1BcHBseVBhdGNoKCl7aWYobnVsbD09PXRoaXMucGF0Y2gpcmV0dXJuIGQoXCJ0aGlzLnBhdGNoXCIpO2ZvcihsZXRbdCxlXW9mIHRoaXMucGF0Y2guZ2xvYmFscyl0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHQsZSk7aWYobnVsbCE9PXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icylmb3IobGV0IHQgb2YgdGhpcy5wYXRjaC5jaGFuZ2VkVmFyaWFibGVzKXRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQodCk7dGhpcy5wYXRjaD1udWxsfVNldEpzb25Ub2tlbih0KXt0aGlzLl9nbG9iYWxWYXJpYWJsZXMuY2xlYXIoKTtmb3IobGV0W2Usbl1vZiB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzKXtsZXQgaT10W2VdO2lmKHZvaWQgMCE9PWkpe2xldCB0PU0uSlRva2VuVG9SdW50aW1lT2JqZWN0KGkpO2lmKG51bGw9PT10KXJldHVybiBkKFwidG9rZW5JbmtPYmplY3RcIik7dGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldChlLHQpfWVsc2UgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldChlLG4pfX1Xcml0ZUpzb24odCl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldFtlLG5db2YgdGhpcy5fZ2xvYmFsVmFyaWFibGVzKXtsZXQgaT1lLHI9bjtpZihKLmRvbnRTYXZlRGVmYXVsdFZhbHVlcyYmdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5oYXMoaSkpe2xldCB0PXRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KGkpO2lmKHRoaXMuUnVudGltZU9iamVjdHNFcXVhbChyLHQpKWNvbnRpbnVlfXQuV3JpdGVQcm9wZXJ0eVN0YXJ0KGkpLE0uV3JpdGVSdW50aW1lT2JqZWN0KHQsciksdC5Xcml0ZVByb3BlcnR5RW5kKCl9dC5Xcml0ZU9iamVjdEVuZCgpfVJ1bnRpbWVPYmplY3RzRXF1YWwodCxlKXtpZihudWxsPT09dClyZXR1cm4gZChcIm9iajFcIik7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJvYmoyXCIpO2lmKHQuY29uc3RydWN0b3IhPT1lLmNvbnN0cnVjdG9yKXJldHVybiExO2xldCBuPWEodCxiKTtpZihudWxsIT09bilyZXR1cm4gbi52YWx1ZT09PXMoZSxiKS52YWx1ZTtsZXQgaT1hKHQsXyk7aWYobnVsbCE9PWkpcmV0dXJuIGkudmFsdWU9PT1zKGUsXykudmFsdWU7bGV0IHI9YSh0LHYpLGw9YShlLHYpO2lmKG51bGwhPT1yJiZudWxsIT09bClyZXR1cm4gdShyLnZhbHVlT2JqZWN0KSYmdShsLnZhbHVlT2JqZWN0KT9yLnZhbHVlT2JqZWN0LkVxdWFscyhsLnZhbHVlT2JqZWN0KTpyLnZhbHVlT2JqZWN0PT09bC52YWx1ZU9iamVjdDt0aHJvdyBuZXcgRXJyb3IoXCJGYXN0Um91Z2hEZWZpbml0ZWx5RXF1YWxzOiBVbnN1cHBvcnRlZCBydW50aW1lIG9iamVjdCB0eXBlOiBcIit0LmNvbnN0cnVjdG9yLm5hbWUpfUdldFZhcmlhYmxlV2l0aE5hbWUodCxlPS0xKXtsZXQgbj10aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUodCxlKSxpPWEobix3KTtyZXR1cm4gbnVsbCE9PWkmJihuPXRoaXMuVmFsdWVBdFZhcmlhYmxlUG9pbnRlcihpKSksbn1UcnlHZXREZWZhdWx0VmFyaWFibGVWYWx1ZSh0KXtsZXQgZT15KHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsdCxudWxsKTtyZXR1cm4gZS5leGlzdHM/ZS5yZXN1bHQ6bnVsbH1HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHQpe3JldHVybiB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuaGFzKHQpfHxudWxsIT09dGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyYmdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5oYXModCl9R2V0UmF3VmFyaWFibGVXaXRoTmFtZSh0LGUpe2xldCBuPW51bGw7aWYoMD09ZXx8LTE9PWUpe2xldCBlPW51bGw7aWYobnVsbCE9PXRoaXMucGF0Y2gmJihlPXRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHQsbnVsbCksZS5leGlzdHMpKXJldHVybiBlLnJlc3VsdDtpZihlPXkodGhpcy5fZ2xvYmFsVmFyaWFibGVzLHQsbnVsbCksZS5leGlzdHMpcmV0dXJuIGUucmVzdWx0O2lmKG51bGwhPT10aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzJiYoZT15KHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsdCxudWxsKSxlLmV4aXN0cykpcmV0dXJuIGUucmVzdWx0O2lmKG51bGw9PT10aGlzLl9saXN0RGVmc09yaWdpbilyZXR1cm4gZChcIlZhcmlhYmxlc1N0YXRlLl9saXN0RGVmc09yaWdpblwiKTtsZXQgbj10aGlzLl9saXN0RGVmc09yaWdpbi5GaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZSh0KTtpZihuKXJldHVybiBufXJldHVybiBuPXRoaXMuX2NhbGxTdGFjay5HZXRUZW1wb3JhcnlWYXJpYWJsZVdpdGhOYW1lKHQsZSksbn1WYWx1ZUF0VmFyaWFibGVQb2ludGVyKHQpe3JldHVybiB0aGlzLkdldFZhcmlhYmxlV2l0aE5hbWUodC52YXJpYWJsZU5hbWUsdC5jb250ZXh0SW5kZXgpfUFzc2lnbih0LGUpe2xldCBuPXQudmFyaWFibGVOYW1lO2lmKG51bGw9PT1uKXJldHVybiBkKFwibmFtZVwiKTtsZXQgaT0tMSxyPSExO2lmKHI9dC5pc05ld0RlY2xhcmF0aW9uP3QuaXNHbG9iYWw6dGhpcy5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKG4pLHQuaXNOZXdEZWNsYXJhdGlvbil7bGV0IHQ9YShlLHcpO2lmKG51bGwhPT10KXtlPXRoaXMuUmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih0KX19ZWxzZXtsZXQgdD1udWxsO2Rve3Q9YSh0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobixpKSx3KSxudWxsIT10JiYobj10LnZhcmlhYmxlTmFtZSxpPXQuY29udGV4dEluZGV4LHI9MD09aSl9d2hpbGUobnVsbCE9dCl9cj90aGlzLlNldEdsb2JhbChuLGUpOnRoaXMuX2NhbGxTdGFjay5TZXRUZW1wb3JhcnlWYXJpYWJsZShuLGUsdC5pc05ld0RlY2xhcmF0aW9uLGkpfVNuYXBzaG90RGVmYXVsdEdsb2JhbHMoKXt0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzPW5ldyBNYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzKX1SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQodCxlKXtsZXQgbj1zKHQsTyksaT1zKGUsTyk7bi52YWx1ZSYmaS52YWx1ZSYmMD09aS52YWx1ZS5Db3VudCYmaS52YWx1ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXMobi52YWx1ZS5vcmlnaW5OYW1lcyl9U2V0R2xvYmFsKHQsZSl7bGV0IG49bnVsbDtpZihudWxsPT09dGhpcy5wYXRjaCYmKG49eSh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsdCxudWxsKSksbnVsbCE9PXRoaXMucGF0Y2gmJihuPXRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHQsbnVsbCksbi5leGlzdHN8fChuPXkodGhpcy5fZ2xvYmFsVmFyaWFibGVzLHQsbnVsbCkpKSxPLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChuLnJlc3VsdCxlKSxudWxsPT09dClyZXR1cm4gZChcInZhcmlhYmxlTmFtZVwiKTtpZihudWxsIT09dGhpcy5wYXRjaD90aGlzLnBhdGNoLlNldEdsb2JhbCh0LGUpOnRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodCxlKSxudWxsIT09dGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCYmbnVsbCE9PW4mJmUhPT1uLnJlc3VsdClpZih0aGlzLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKXtpZihudWxsPT09dGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKXJldHVybiBkKFwidGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzXCIpO251bGwhPT10aGlzLnBhdGNoP3RoaXMucGF0Y2guQWRkQ2hhbmdlZFZhcmlhYmxlKHQpOm51bGwhPT10aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMmJnRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQodCl9ZWxzZSB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHQsZSl9UmVzb2x2ZVZhcmlhYmxlUG9pbnRlcih0KXtsZXQgZT10LmNvbnRleHRJbmRleDstMT09ZSYmKGU9dGhpcy5HZXRDb250ZXh0SW5kZXhPZlZhcmlhYmxlTmFtZWQodC52YXJpYWJsZU5hbWUpKTtsZXQgbj1hKHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZSh0LnZhcmlhYmxlTmFtZSxlKSx3KTtyZXR1cm4gbnVsbCE9bj9uOm5ldyB3KHQudmFyaWFibGVOYW1lLGUpfUdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh0KXtyZXR1cm4gdGhpcy5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHQpPzA6dGhpcy5fY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50SW5kZXh9T2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlKHQpe3RoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MucHVzaCh0KX19Si5kb250U2F2ZURlZmF1bHRWYWx1ZXM9ITA7Y2xhc3MgS3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnNlZWQ9dCUyMTQ3NDgzNjQ3LHRoaXMuc2VlZDw9MCYmKHRoaXMuc2VlZCs9MjE0NzQ4MzY0Nil9bmV4dCgpe3JldHVybiB0aGlzLnNlZWQ9MTY4MDcqdGhpcy5zZWVkJTIxNDc0ODM2NDd9bmV4dEZsb2F0KCl7cmV0dXJuKHRoaXMubmV4dCgpLTEpLzIxNDc0ODM2NDZ9fWNsYXNzIFV7Y29uc3RydWN0b3IoKXtpZih0aGlzLl9jaGFuZ2VkVmFyaWFibGVzPW5ldyBTZXQsdGhpcy5fdmlzaXRDb3VudHM9bmV3IE1hcCx0aGlzLl90dXJuSW5kaWNlcz1uZXcgTWFwLDE9PT1hcmd1bWVudHMubGVuZ3RoJiZudWxsIT09YXJndW1lbnRzWzBdKXtsZXQgdD1hcmd1bWVudHNbMF07dGhpcy5fZ2xvYmFscz1uZXcgTWFwKHQuX2dsb2JhbHMpLHRoaXMuX2NoYW5nZWRWYXJpYWJsZXM9bmV3IFNldCh0Ll9jaGFuZ2VkVmFyaWFibGVzKSx0aGlzLl92aXNpdENvdW50cz1uZXcgTWFwKHQuX3Zpc2l0Q291bnRzKSx0aGlzLl90dXJuSW5kaWNlcz1uZXcgTWFwKHQuX3R1cm5JbmRpY2VzKX1lbHNlIHRoaXMuX2dsb2JhbHM9bmV3IE1hcCx0aGlzLl9jaGFuZ2VkVmFyaWFibGVzPW5ldyBTZXQsdGhpcy5fdmlzaXRDb3VudHM9bmV3IE1hcCx0aGlzLl90dXJuSW5kaWNlcz1uZXcgTWFwfWdldCBnbG9iYWxzKCl7cmV0dXJuIHRoaXMuX2dsb2JhbHN9Z2V0IGNoYW5nZWRWYXJpYWJsZXMoKXtyZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlc31nZXQgdmlzaXRDb3VudHMoKXtyZXR1cm4gdGhpcy5fdmlzaXRDb3VudHN9Z2V0IHR1cm5JbmRpY2VzKCl7cmV0dXJuIHRoaXMuX3R1cm5JbmRpY2VzfVRyeUdldEdsb2JhbCh0LGUpe3JldHVybiBudWxsIT09dCYmdGhpcy5fZ2xvYmFscy5oYXModCk/e3Jlc3VsdDp0aGlzLl9nbG9iYWxzLmdldCh0KSxleGlzdHM6ITB9OntyZXN1bHQ6ZSxleGlzdHM6ITF9fVNldEdsb2JhbCh0LGUpe3RoaXMuX2dsb2JhbHMuc2V0KHQsZSl9QWRkQ2hhbmdlZFZhcmlhYmxlKHQpe3JldHVybiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzLmFkZCh0KX1UcnlHZXRWaXNpdENvdW50KHQsZSl7cmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzLmhhcyh0KT97cmVzdWx0OnRoaXMuX3Zpc2l0Q291bnRzLmdldCh0KSxleGlzdHM6ITB9OntyZXN1bHQ6ZSxleGlzdHM6ITF9fVNldFZpc2l0Q291bnQodCxlKXt0aGlzLl92aXNpdENvdW50cy5zZXQodCxlKX1TZXRUdXJuSW5kZXgodCxlKXt0aGlzLl90dXJuSW5kaWNlcy5zZXQodCxlKX1UcnlHZXRUdXJuSW5kZXgodCxlKXtyZXR1cm4gdGhpcy5fdHVybkluZGljZXMuaGFzKHQpP3tyZXN1bHQ6dGhpcy5fdHVybkluZGljZXMuZ2V0KHQpLGV4aXN0czohMH06e3Jlc3VsdDplLGV4aXN0czohMX19fWNsYXNzIHp7c3RhdGljIFRleHRUb0RpY3Rpb25hcnkodCl7cmV0dXJuIG5ldyB6LlJlYWRlcih0KS5Ub0RpY3Rpb25hcnkoKX1zdGF0aWMgVGV4dFRvQXJyYXkodCl7cmV0dXJuIG5ldyB6LlJlYWRlcih0KS5Ub0FycmF5KCl9fSFmdW5jdGlvbih0KXt0LlJlYWRlcj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLl9yb290T2JqZWN0PUpTT04ucGFyc2UodCl9VG9EaWN0aW9uYXJ5KCl7cmV0dXJuIHRoaXMuX3Jvb3RPYmplY3R9VG9BcnJheSgpe3JldHVybiB0aGlzLl9yb290T2JqZWN0fX07Y2xhc3MgZXtjb25zdHJ1Y3Rvcigpe3RoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWU9bnVsbCx0aGlzLl9jdXJyZW50U3RyaW5nPW51bGwsdGhpcy5fc3RhdGVTdGFjaz1bXSx0aGlzLl9jb2xsZWN0aW9uU3RhY2s9W10sdGhpcy5fcHJvcGVydHlOYW1lU3RhY2s9W10sdGhpcy5fanNvbk9iamVjdD1udWxsfVdyaXRlT2JqZWN0KHQpe3RoaXMuV3JpdGVPYmplY3RTdGFydCgpLHQodGhpcyksdGhpcy5Xcml0ZU9iamVjdEVuZCgpfVdyaXRlT2JqZWN0U3RhcnQoKXt0aGlzLlN0YXJ0TmV3T2JqZWN0KCEwKTtsZXQgZT17fTtpZih0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpe3RoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSx0aGlzLkFzc2VydChudWxsIT09dGhpcy5jdXJyZW50UHJvcGVydHlOYW1lKTtsZXQgdD10aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTt0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3RdPWUsdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSl9ZWxzZSB0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXk/KHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSx0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2goZSksdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSkpOih0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuTm9uZSksdGhpcy5fanNvbk9iamVjdD1lLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKGUpKTt0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IHQuV3JpdGVyLlN0YXRlRWxlbWVudCh0LldyaXRlci5TdGF0ZS5PYmplY3QpKX1Xcml0ZU9iamVjdEVuZCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5PYmplY3QpLHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wb3AoKSx0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpfVdyaXRlUHJvcGVydHkodCxlKXtpZih0aGlzLldyaXRlUHJvcGVydHlTdGFydCh0KSxhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEZ1bmN0aW9uKXsoMCxhcmd1bWVudHNbMV0pKHRoaXMpfWVsc2V7bGV0IHQ9YXJndW1lbnRzWzFdO3RoaXMuV3JpdGUodCl9dGhpcy5Xcml0ZVByb3BlcnR5RW5kKCl9V3JpdGVJbnRQcm9wZXJ0eSh0LGUpe3RoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KHQpLHRoaXMuV3JpdGVJbnQoZSksdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCl9V3JpdGVGbG9hdFByb3BlcnR5KHQsZSl7dGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQodCksdGhpcy5Xcml0ZUZsb2F0KGUpLHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpfVdyaXRlUHJvcGVydHlTdGFydChlKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuT2JqZWN0KSx0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wdXNoKGUpLHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpLHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLlByb3BlcnR5KSl9V3JpdGVQcm9wZXJ0eUVuZCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSksdGhpcy5Bc3NlcnQoMT09PXRoaXMuY2hpbGRDb3VudCksdGhpcy5fc3RhdGVTdGFjay5wb3AoKX1Xcml0ZVByb3BlcnR5TmFtZVN0YXJ0KCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLk9iamVjdCksdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCksdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZT1cIlwiLHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLlByb3BlcnR5KSksdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKSl9V3JpdGVQcm9wZXJ0eU5hbWVFbmQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKSx0aGlzLkFzc2VydChudWxsIT09dGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSksdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKSx0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lPW51bGwsdGhpcy5fc3RhdGVTdGFjay5wb3AoKX1Xcml0ZVByb3BlcnR5TmFtZUlubmVyKGUpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpLHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKSx0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lKz1lfVdyaXRlQXJyYXlTdGFydCgpe3RoaXMuU3RhcnROZXdPYmplY3QoITApO2xldCBlPVtdO2lmKHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSl7dGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudENvbGxlY3Rpb24pLHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUpO2xldCB0PXRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO3RoaXMuY3VycmVudENvbGxlY3Rpb25bdF09ZSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKX1lbHNlIHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheT8odGhpcy5Bc3NlcnQobnVsbCE9PXRoaXMuY3VycmVudENvbGxlY3Rpb24pLHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChlKSx0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChlKSk6KHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Ob25lKSx0aGlzLl9qc29uT2JqZWN0PWUsdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2goZSkpO3RoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgdC5Xcml0ZXIuU3RhdGVFbGVtZW50KHQuV3JpdGVyLlN0YXRlLkFycmF5KSl9V3JpdGVBcnJheUVuZCgpe3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheSksdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpLHRoaXMuX3N0YXRlU3RhY2sucG9wKCl9V3JpdGUodCxlPSEwKXtudWxsIT09dD8odGhpcy5TdGFydE5ld09iamVjdCghMSksdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHQpKTpjb25zb2xlLmVycm9yKFwiV2FybmluZzogdHJ5aW5nIHRvIHdyaXRlIGEgbnVsbCBzdHJpbmdcIil9V3JpdGVJbnQodCl7bnVsbCE9PXQmJih0aGlzLlN0YXJ0TmV3T2JqZWN0KCExKSx0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoTWF0aC5mbG9vcih0KSkpfVdyaXRlRmxvYXQodCl7bnVsbCE9PXQmJih0aGlzLlN0YXJ0TmV3T2JqZWN0KCExKSx0PT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk/dGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDM0ZTM3KTp0PT1OdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk/dGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KC0zNGUzNyk6aXNOYU4odCk/dGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDApOnRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh0KSl9V3JpdGVOdWxsKCl7dGhpcy5TdGFydE5ld09iamVjdCghMSksdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KG51bGwpfVdyaXRlU3RyaW5nU3RhcnQoKXt0aGlzLlN0YXJ0TmV3T2JqZWN0KCExKSx0aGlzLl9jdXJyZW50U3RyaW5nPVwiXCIsdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyB0LldyaXRlci5TdGF0ZUVsZW1lbnQodC5Xcml0ZXIuU3RhdGUuU3RyaW5nKSl9V3JpdGVTdHJpbmdFbmQoKXt0aGlzLkFzc2VydCh0aGlzLnN0YXRlPT10LldyaXRlci5TdGF0ZS5TdHJpbmcpLHRoaXMuX3N0YXRlU3RhY2sucG9wKCksdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHRoaXMuX2N1cnJlbnRTdHJpbmcpLHRoaXMuX2N1cnJlbnRTdHJpbmc9bnVsbH1Xcml0ZVN0cmluZ0lubmVyKGUsbj0hMCl7dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlN0cmluZyksbnVsbCE9PWU/dGhpcy5fY3VycmVudFN0cmluZys9ZTpjb25zb2xlLmVycm9yKFwiV2FybmluZzogdHJ5aW5nIHRvIHdyaXRlIGEgbnVsbCBzdHJpbmdcIil9VG9TdHJpbmcoKXtyZXR1cm4gbnVsbD09PXRoaXMuX2pzb25PYmplY3Q/XCJcIjpKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uT2JqZWN0KX1TdGFydE5ld09iamVjdChlKXtlP3RoaXMuQXNzZXJ0KHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Ob25lfHx0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHl8fHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5BcnJheSk6dGhpcy5Bc3NlcnQodGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5fHx0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXkpLHRoaXMuc3RhdGU9PT10LldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSYmdGhpcy5Bc3NlcnQoMD09PXRoaXMuY2hpbGRDb3VudCksdGhpcy5zdGF0ZSE9PXQuV3JpdGVyLlN0YXRlLkFycmF5JiZ0aGlzLnN0YXRlIT09dC5Xcml0ZXIuU3RhdGUuUHJvcGVydHl8fHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpfWdldCBzdGF0ZSgpe3JldHVybiB0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aD4wP3RoaXMuX3N0YXRlU3RhY2tbdGhpcy5fc3RhdGVTdGFjay5sZW5ndGgtMV0udHlwZTp0LldyaXRlci5TdGF0ZS5Ob25lfWdldCBjaGlsZENvdW50KCl7cmV0dXJuIHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoPjA/dGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aC0xXS5jaGlsZENvdW50OjB9Z2V0IGN1cnJlbnRDb2xsZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5sZW5ndGg+MD90aGlzLl9jb2xsZWN0aW9uU3RhY2tbdGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aC0xXTpudWxsfWdldCBjdXJyZW50UHJvcGVydHlOYW1lKCl7cmV0dXJuIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLmxlbmd0aD4wP3RoaXMuX3Byb3BlcnR5TmFtZVN0YWNrW3RoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLmxlbmd0aC0xXTpudWxsfUluY3JlbWVudENoaWxkQ291bnQoKXt0aGlzLkFzc2VydCh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aD4wKTtsZXQgdD10aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO3QuY2hpbGRDb3VudCsrLHRoaXMuX3N0YXRlU3RhY2sucHVzaCh0KX1Bc3NlcnQodCl7aWYoIXQpdGhyb3cgRXJyb3IoXCJBc3NlcnQgZmFpbGVkIHdoaWxlIHdyaXRpbmcgSlNPTlwiKX1fYWRkVG9DdXJyZW50T2JqZWN0KGUpe3RoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSx0aGlzLnN0YXRlPT09dC5Xcml0ZXIuU3RhdGUuQXJyYXk/KHRoaXMuQXNzZXJ0KEFycmF5LmlzQXJyYXkodGhpcy5jdXJyZW50Q29sbGVjdGlvbikpLHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChlKSk6dGhpcy5zdGF0ZT09PXQuV3JpdGVyLlN0YXRlLlByb3BlcnR5JiYodGhpcy5Bc3NlcnQoIUFycmF5LmlzQXJyYXkodGhpcy5jdXJyZW50Q29sbGVjdGlvbikpLHRoaXMuQXNzZXJ0KG51bGwhPT10aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUpLHRoaXMuY3VycmVudENvbGxlY3Rpb25bdGhpcy5jdXJyZW50UHJvcGVydHlOYW1lXT1lLHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpKX19dC5Xcml0ZXI9ZSxmdW5jdGlvbihlKXtsZXQgbjshZnVuY3Rpb24odCl7dFt0Lk5vbmU9MF09XCJOb25lXCIsdFt0Lk9iamVjdD0xXT1cIk9iamVjdFwiLHRbdC5BcnJheT0yXT1cIkFycmF5XCIsdFt0LlByb3BlcnR5PTNdPVwiUHJvcGVydHlcIix0W3QuUHJvcGVydHlOYW1lPTRdPVwiUHJvcGVydHlOYW1lXCIsdFt0LlN0cmluZz01XT1cIlN0cmluZ1wifShuPWUuU3RhdGV8fChlLlN0YXRlPXt9KSk7ZS5TdGF0ZUVsZW1lbnQ9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy50eXBlPXQuV3JpdGVyLlN0YXRlLk5vbmUsdGhpcy5jaGlsZENvdW50PTAsdGhpcy50eXBlPWV9fX0oZT10LldyaXRlcnx8KHQuV3JpdGVyPXt9KSl9KHp8fCh6PXt9KSk7Y2xhc3MgSHtjb25zdHJ1Y3Rvcih0KXt0aGlzLmtJbmtTYXZlU3RhdGVWZXJzaW9uPTgsdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uPTgsdGhpcy5fY3VycmVudEVycm9ycz1udWxsLHRoaXMuX2N1cnJlbnRXYXJuaW5ncz1udWxsLHRoaXMuZGl2ZXJ0ZWRQb2ludGVyPUkuTnVsbCx0aGlzLl9jdXJyZW50VHVybkluZGV4PTAsdGhpcy5zdG9yeVNlZWQ9MCx0aGlzLnByZXZpb3VzUmFuZG9tPTAsdGhpcy5kaWRTYWZlRXhpdD0hMSx0aGlzLl9jdXJyZW50VGV4dD1udWxsLHRoaXMuX2N1cnJlbnRUYWdzPW51bGwsdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5PSEwLHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eT0hMCx0aGlzLl9wYXRjaD1udWxsLHRoaXMuc3Rvcnk9dCx0aGlzLl9vdXRwdXRTdHJlYW09W10sdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpLHRoaXMuX2V2YWx1YXRpb25TdGFjaz1bXSx0aGlzLmNhbGxTdGFjaz1uZXcgcSh0KSx0aGlzLl92YXJpYWJsZXNTdGF0ZT1uZXcgSih0aGlzLmNhbGxTdGFjayx0Lmxpc3REZWZpbml0aW9ucyksdGhpcy5fdmlzaXRDb3VudHM9bmV3IE1hcCx0aGlzLl90dXJuSW5kaWNlcz1uZXcgTWFwLHRoaXMuY3VycmVudFR1cm5JbmRleD0tMTtsZXQgZT0obmV3IERhdGUpLmdldFRpbWUoKTt0aGlzLnN0b3J5U2VlZD1uZXcgSyhlKS5uZXh0KCklMTAwLHRoaXMucHJldmlvdXNSYW5kb209MCx0aGlzLl9jdXJyZW50Q2hvaWNlcz1bXSx0aGlzLkdvVG9TdGFydCgpfVRvSnNvbih0PSExKXtsZXQgZT1uZXcgei5Xcml0ZXI7cmV0dXJuIHRoaXMuV3JpdGVKc29uKGUpLGUuVG9TdHJpbmcoKX10b0pzb24odD0hMSl7cmV0dXJuIHRoaXMuVG9Kc29uKHQpfUxvYWRKc29uKHQpe2xldCBlPXouVGV4dFRvRGljdGlvbmFyeSh0KTt0aGlzLkxvYWRKc29uT2JqKGUpfVZpc2l0Q291bnRBdFBhdGhTdHJpbmcodCl7bGV0IG47aWYobnVsbCE9PXRoaXMuX3BhdGNoKXtsZXQgaT10aGlzLnN0b3J5LkNvbnRlbnRBdFBhdGgobmV3IGUodCkpLmNvbnRhaW5lcjtpZihudWxsPT09aSl0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IGF0IHBhdGggbm90IGZvdW5kOiBcIit0KTtpZihuPXRoaXMuX3BhdGNoLlRyeUdldFZpc2l0Q291bnQoaSwwKSxuLmV4aXN0cylyZXR1cm4gbi5yZXN1bHR9cmV0dXJuIG49eSh0aGlzLl92aXNpdENvdW50cyx0LG51bGwpLG4uZXhpc3RzP24ucmVzdWx0OjB9VmlzaXRDb3VudEZvckNvbnRhaW5lcih0KXtpZihudWxsPT09dClyZXR1cm4gZChcImNvbnRhaW5lclwiKTtpZighdC52aXNpdHNTaG91bGRCZUNvdW50ZWQpcmV0dXJuIHRoaXMuc3RvcnkuRXJyb3IoXCJSZWFkIGNvdW50IGZvciB0YXJnZXQgKFwiK3QubmFtZStcIiAtIG9uIFwiK3QuZGVidWdNZXRhZGF0YStcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKSwwO2lmKG51bGwhPT10aGlzLl9wYXRjaCl7bGV0IGU9dGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudCh0LDApO2lmKGUuZXhpc3RzKXJldHVybiBlLnJlc3VsdH1sZXQgZT10LnBhdGgudG9TdHJpbmcoKSxuPXkodGhpcy5fdmlzaXRDb3VudHMsZSxudWxsKTtyZXR1cm4gbi5leGlzdHM/bi5yZXN1bHQ6MH1JbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKHQpe2lmKG51bGwhPT10aGlzLl9wYXRjaCl7bGV0IGU9dGhpcy5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHQpO3JldHVybiBlKyssdm9pZCB0aGlzLl9wYXRjaC5TZXRWaXNpdENvdW50KHQsZSl9bGV0IGU9dC5wYXRoLnRvU3RyaW5nKCksbj15KHRoaXMuX3Zpc2l0Q291bnRzLGUsbnVsbCk7bi5leGlzdHM/dGhpcy5fdmlzaXRDb3VudHMuc2V0KGUsbi5yZXN1bHQrMSk6dGhpcy5fdmlzaXRDb3VudHMuc2V0KGUsMSl9UmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcih0KXtpZihudWxsIT09dGhpcy5fcGF0Y2gpcmV0dXJuIHZvaWQgdGhpcy5fcGF0Y2guU2V0VHVybkluZGV4KHQsdGhpcy5jdXJyZW50VHVybkluZGV4KTtsZXQgZT10LnBhdGgudG9TdHJpbmcoKTt0aGlzLl90dXJuSW5kaWNlcy5zZXQoZSx0aGlzLmN1cnJlbnRUdXJuSW5kZXgpfVR1cm5zU2luY2VGb3JDb250YWluZXIodCl7aWYodC50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWR8fHRoaXMuc3RvcnkuRXJyb3IoXCJUVVJOU19TSU5DRSgpIGZvciB0YXJnZXQgKFwiK3QubmFtZStcIiAtIG9uIFwiK3QuZGVidWdNZXRhZGF0YStcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKSxudWxsIT09dGhpcy5fcGF0Y2gpe2xldCBlPXRoaXMuX3BhdGNoLlRyeUdldFR1cm5JbmRleCh0LDApO2lmKGUuZXhpc3RzKXJldHVybiB0aGlzLmN1cnJlbnRUdXJuSW5kZXgtZS5yZXN1bHR9bGV0IGU9dC5wYXRoLnRvU3RyaW5nKCksbj15KHRoaXMuX3R1cm5JbmRpY2VzLGUsMCk7cmV0dXJuIG4uZXhpc3RzP3RoaXMuY3VycmVudFR1cm5JbmRleC1uLnJlc3VsdDotMX1nZXQgY2FsbHN0YWNrRGVwdGgoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2suZGVwdGh9Z2V0IG91dHB1dFN0cmVhbSgpe3JldHVybiB0aGlzLl9vdXRwdXRTdHJlYW19Z2V0IGN1cnJlbnRDaG9pY2VzKCl7cmV0dXJuIHRoaXMuY2FuQ29udGludWU/W106dGhpcy5fY3VycmVudENob2ljZXN9Z2V0IGdlbmVyYXRlZENob2ljZXMoKXtyZXR1cm4gdGhpcy5fY3VycmVudENob2ljZXN9Z2V0IGN1cnJlbnRFcnJvcnMoKXtyZXR1cm4gdGhpcy5fY3VycmVudEVycm9yc31nZXQgY3VycmVudFdhcm5pbmdzKCl7cmV0dXJuIHRoaXMuX2N1cnJlbnRXYXJuaW5nc31nZXQgdmFyaWFibGVzU3RhdGUoKXtyZXR1cm4gdGhpcy5fdmFyaWFibGVzU3RhdGV9c2V0IHZhcmlhYmxlc1N0YXRlKHQpe3RoaXMuX3ZhcmlhYmxlc1N0YXRlPXR9Z2V0IGV2YWx1YXRpb25TdGFjaygpe3JldHVybiB0aGlzLl9ldmFsdWF0aW9uU3RhY2t9Z2V0IHZpc2l0Q291bnRzKCl7cmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzfWdldCB0dXJuSW5kaWNlcygpe3JldHVybiB0aGlzLl90dXJuSW5kaWNlc31nZXQgY3VycmVudFR1cm5JbmRleCgpe3JldHVybiB0aGlzLl9jdXJyZW50VHVybkluZGV4fXNldCBjdXJyZW50VHVybkluZGV4KHQpe3RoaXMuX2N1cnJlbnRUdXJuSW5kZXg9dH1nZXQgY3VycmVudFBhdGhTdHJpbmcoKXtsZXQgdD10aGlzLmN1cnJlbnRQb2ludGVyO3JldHVybiB0LmlzTnVsbD9udWxsOm51bGw9PT10LnBhdGg/ZChcInBvaW50ZXIucGF0aFwiKTp0LnBhdGgudG9TdHJpbmcoKX1nZXQgY3VycmVudFBvaW50ZXIoKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29weSgpfXNldCBjdXJyZW50UG9pbnRlcih0KXt0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlcj10LmNvcHkoKX1nZXQgcHJldmlvdXNQb2ludGVyKCl7cmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQucHJldmlvdXNQb2ludGVyLmNvcHkoKX1zZXQgcHJldmlvdXNQb2ludGVyKHQpe3RoaXMuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQucHJldmlvdXNQb2ludGVyPXQuY29weSgpfWdldCBjYW5Db250aW51ZSgpe3JldHVybiF0aGlzLmN1cnJlbnRQb2ludGVyLmlzTnVsbCYmIXRoaXMuaGFzRXJyb3J9Z2V0IGhhc0Vycm9yKCl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudEVycm9ycyYmdGhpcy5jdXJyZW50RXJyb3JzLmxlbmd0aD4wfWdldCBoYXNXYXJuaW5nKCl7cmV0dXJuIG51bGwhPXRoaXMuY3VycmVudFdhcm5pbmdzJiZ0aGlzLmN1cnJlbnRXYXJuaW5ncy5sZW5ndGg+MH1nZXQgY3VycmVudFRleHQoKXtpZih0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkpe2xldCB0PW5ldyBtO2ZvcihsZXQgZSBvZiB0aGlzLl9vdXRwdXRTdHJlYW0pe2xldCBuPWEoZSxUKTtudWxsIT09biYmdC5BcHBlbmQobi52YWx1ZSl9dGhpcy5fY3VycmVudFRleHQ9dGhpcy5DbGVhbk91dHB1dFdoaXRlc3BhY2UodC50b1N0cmluZygpKSx0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHk9ITF9cmV0dXJuIHRoaXMuX2N1cnJlbnRUZXh0fUNsZWFuT3V0cHV0V2hpdGVzcGFjZSh0KXtsZXQgZT1uZXcgbSxuPS0xLGk9MDtmb3IobGV0IHI9MDtyPHQubGVuZ3RoO3IrKyl7bGV0IGE9dC5jaGFyQXQocikscz1cIiBcIj09YXx8XCJcXHRcIj09YTtzJiYtMT09biYmKG49ciksc3x8KFwiXFxuXCIhPWEmJm4+MCYmbiE9aSYmZS5BcHBlbmQoXCIgXCIpLG49LTEpLFwiXFxuXCI9PWEmJihpPXIrMSksc3x8ZS5BcHBlbmQoYSl9cmV0dXJuIGUudG9TdHJpbmcoKX1nZXQgY3VycmVudFRhZ3MoKXtpZih0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkpe3RoaXMuX2N1cnJlbnRUYWdzPVtdO2ZvcihsZXQgdCBvZiB0aGlzLl9vdXRwdXRTdHJlYW0pe2xldCBlPWEodCxqKTtudWxsIT09ZSYmdGhpcy5fY3VycmVudFRhZ3MucHVzaChlLnRleHQpfXRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eT0hMX1yZXR1cm4gdGhpcy5fY3VycmVudFRhZ3N9Z2V0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24oKXtyZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuaW5FeHByZXNzaW9uRXZhbHVhdGlvbn1zZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbih0KXt0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPXR9R29Ub1N0YXJ0KCl7dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXI9SS5TdGFydE9mKHRoaXMuc3RvcnkubWFpbkNvbnRlbnRDb250YWluZXIpfUNvcHlBbmRTdGFydFBhdGNoaW5nKCl7bGV0IHQ9bmV3IEgodGhpcy5zdG9yeSk7cmV0dXJuIHQuX3BhdGNoPW5ldyBVKHRoaXMuX3BhdGNoKSx0Lm91dHB1dFN0cmVhbS5wdXNoLmFwcGx5KHQub3V0cHV0U3RyZWFtLHRoaXMuX291dHB1dFN0cmVhbSksdC5PdXRwdXRTdHJlYW1EaXJ0eSgpLHQuX2N1cnJlbnRDaG9pY2VzLnB1c2guYXBwbHkodC5fY3VycmVudENob2ljZXMsdGhpcy5fY3VycmVudENob2ljZXMpLHRoaXMuaGFzRXJyb3ImJih0Ll9jdXJyZW50RXJyb3JzPVtdLHQuX2N1cnJlbnRFcnJvcnMucHVzaC5hcHBseSh0Ll9jdXJyZW50RXJyb3JzLHRoaXMuY3VycmVudEVycm9yc3x8W10pKSx0aGlzLmhhc1dhcm5pbmcmJih0Ll9jdXJyZW50V2FybmluZ3M9W10sdC5fY3VycmVudFdhcm5pbmdzLnB1c2guYXBwbHkodC5fY3VycmVudFdhcm5pbmdzLHRoaXMuY3VycmVudFdhcm5pbmdzfHxbXSkpLHQuY2FsbFN0YWNrPW5ldyBxKHRoaXMuY2FsbFN0YWNrKSx0LnZhcmlhYmxlc1N0YXRlPXRoaXMudmFyaWFibGVzU3RhdGUsdC52YXJpYWJsZXNTdGF0ZS5jYWxsU3RhY2s9dC5jYWxsU3RhY2ssdC52YXJpYWJsZXNTdGF0ZS5wYXRjaD10Ll9wYXRjaCx0LmV2YWx1YXRpb25TdGFjay5wdXNoLmFwcGx5KHQuZXZhbHVhdGlvblN0YWNrLHRoaXMuZXZhbHVhdGlvblN0YWNrKSx0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGx8fCh0LmRpdmVydGVkUG9pbnRlcj10aGlzLmRpdmVydGVkUG9pbnRlci5jb3B5KCkpLHQucHJldmlvdXNQb2ludGVyPXRoaXMucHJldmlvdXNQb2ludGVyLmNvcHkoKSx0Ll92aXNpdENvdW50cz10aGlzLl92aXNpdENvdW50cyx0Ll90dXJuSW5kaWNlcz10aGlzLl90dXJuSW5kaWNlcyx0LmN1cnJlbnRUdXJuSW5kZXg9dGhpcy5jdXJyZW50VHVybkluZGV4LHQuc3RvcnlTZWVkPXRoaXMuc3RvcnlTZWVkLHQucHJldmlvdXNSYW5kb209dGhpcy5wcmV2aW91c1JhbmRvbSx0LmRpZFNhZmVFeGl0PXRoaXMuZGlkU2FmZUV4aXQsdH1SZXN0b3JlQWZ0ZXJQYXRjaCgpe3RoaXMudmFyaWFibGVzU3RhdGUuY2FsbFN0YWNrPXRoaXMuY2FsbFN0YWNrLHRoaXMudmFyaWFibGVzU3RhdGUucGF0Y2g9dGhpcy5fcGF0Y2h9QXBwbHlBbnlQYXRjaCgpe2lmKG51bGwhPT10aGlzLl9wYXRjaCl7dGhpcy52YXJpYWJsZXNTdGF0ZS5BcHBseVBhdGNoKCk7Zm9yKGxldFt0LGVdb2YgdGhpcy5fcGF0Y2gudmlzaXRDb3VudHMpdGhpcy5BcHBseUNvdW50Q2hhbmdlcyh0LGUsITApO2ZvcihsZXRbdCxlXW9mIHRoaXMuX3BhdGNoLnR1cm5JbmRpY2VzKXRoaXMuQXBwbHlDb3VudENoYW5nZXModCxlLCExKTt0aGlzLl9wYXRjaD1udWxsfX1BcHBseUNvdW50Q2hhbmdlcyh0LGUsbil7KG4/dGhpcy5fdmlzaXRDb3VudHM6dGhpcy5fdHVybkluZGljZXMpLnNldCh0LnBhdGgudG9TdHJpbmcoKSxlKX1Xcml0ZUpzb24odCl7dC5Xcml0ZU9iamVjdFN0YXJ0KCk7bGV0IGU9ITE7Zm9yKGxldCBuIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKXtpZihudWxsPT09bi50aHJlYWRBdEdlbmVyYXRpb24pcmV0dXJuIGQoXCJjLnRocmVhZEF0R2VuZXJhdGlvblwiKTtuLm9yaWdpbmFsVGhyZWFkSW5kZXg9bi50aHJlYWRBdEdlbmVyYXRpb24udGhyZWFkSW5kZXgsbnVsbD09PXRoaXMuY2FsbFN0YWNrLlRocmVhZFdpdGhJbmRleChuLm9yaWdpbmFsVGhyZWFkSW5kZXgpJiYoZXx8KGU9ITAsdC5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjaG9pY2VUaHJlYWRzXCIpLHQuV3JpdGVPYmplY3RTdGFydCgpKSx0LldyaXRlUHJvcGVydHlTdGFydChuLm9yaWdpbmFsVGhyZWFkSW5kZXgpLG4udGhyZWFkQXRHZW5lcmF0aW9uLldyaXRlSnNvbih0KSx0LldyaXRlUHJvcGVydHlFbmQoKSl9aWYoZSYmKHQuV3JpdGVPYmplY3RFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKSksdC5Xcml0ZVByb3BlcnR5KFwiY2FsbHN0YWNrVGhyZWFkc1wiLHQ9PnRoaXMuY2FsbFN0YWNrLldyaXRlSnNvbih0KSksdC5Xcml0ZVByb3BlcnR5KFwidmFyaWFibGVzU3RhdGVcIix0PT50aGlzLnZhcmlhYmxlc1N0YXRlLldyaXRlSnNvbih0KSksdC5Xcml0ZVByb3BlcnR5KFwiZXZhbFN0YWNrXCIsdD0+TS5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh0LHRoaXMuZXZhbHVhdGlvblN0YWNrKSksdC5Xcml0ZVByb3BlcnR5KFwib3V0cHV0U3RyZWFtXCIsdD0+TS5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh0LHRoaXMuX291dHB1dFN0cmVhbSkpLHQuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnRDaG9pY2VzXCIsdD0+e3QuV3JpdGVBcnJheVN0YXJ0KCk7Zm9yKGxldCBlIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKU0uV3JpdGVDaG9pY2UodCxlKTt0LldyaXRlQXJyYXlFbmQoKX0pLCF0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGwpe2lmKG51bGw9PT10aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoKXJldHVybiBkKFwiZGl2ZXJ0ZWRQb2ludGVyXCIpO3QuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnREaXZlcnRUYXJnZXRcIix0aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoLmNvbXBvbmVudHNTdHJpbmcpfXQuV3JpdGVQcm9wZXJ0eShcInZpc2l0Q291bnRzXCIsdD0+TS5Xcml0ZUludERpY3Rpb25hcnkodCx0aGlzLl92aXNpdENvdW50cykpLHQuV3JpdGVQcm9wZXJ0eShcInR1cm5JbmRpY2VzXCIsdD0+TS5Xcml0ZUludERpY3Rpb25hcnkodCx0aGlzLl90dXJuSW5kaWNlcykpLHQuV3JpdGVJbnRQcm9wZXJ0eShcInR1cm5JZHhcIix0aGlzLmN1cnJlbnRUdXJuSW5kZXgpLHQuV3JpdGVJbnRQcm9wZXJ0eShcInN0b3J5U2VlZFwiLHRoaXMuc3RvcnlTZWVkKSx0LldyaXRlSW50UHJvcGVydHkoXCJwcmV2aW91c1JhbmRvbVwiLHRoaXMucHJldmlvdXNSYW5kb20pLHQuV3JpdGVJbnRQcm9wZXJ0eShcImlua1NhdmVWZXJzaW9uXCIsdGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbiksdC5Xcml0ZUludFByb3BlcnR5KFwiaW5rRm9ybWF0VmVyc2lvblwiLFguaW5rVmVyc2lvbkN1cnJlbnQpLHQuV3JpdGVPYmplY3RFbmQoKX1Mb2FkSnNvbk9iaih0KXtsZXQgbj10LGk9bi5pbmtTYXZlVmVyc2lvbjtpZihudWxsPT1pKXRocm93IG5ldyBTKFwiaW5rIHNhdmUgZm9ybWF0IGluY29ycmVjdCwgY2FuJ3QgbG9hZC5cIik7aWYocGFyc2VJbnQoaSk8dGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uKXRocm93IG5ldyBTKFwiSW5rIHNhdmUgZm9ybWF0IGlzbid0IGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIChzYXcgJ1wiK2krXCInLCBidXQgbWluaW11bSBpcyBcIit0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24rXCIpLCBzbyBjYW4ndCBsb2FkLlwiKTt0aGlzLmNhbGxTdGFjay5TZXRKc29uVG9rZW4obi5jYWxsc3RhY2tUaHJlYWRzLHRoaXMuc3RvcnkpLHRoaXMudmFyaWFibGVzU3RhdGUuU2V0SnNvblRva2VuKG4udmFyaWFibGVzU3RhdGUpLHRoaXMuX2V2YWx1YXRpb25TdGFjaz1NLkpBcnJheVRvUnVudGltZU9iakxpc3Qobi5ldmFsU3RhY2spLHRoaXMuX291dHB1dFN0cmVhbT1NLkpBcnJheVRvUnVudGltZU9iakxpc3Qobi5vdXRwdXRTdHJlYW0pLHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKSx0aGlzLl9jdXJyZW50Q2hvaWNlcz1NLkpBcnJheVRvUnVudGltZU9iakxpc3Qobi5jdXJyZW50Q2hvaWNlcyk7bGV0IHI9bi5jdXJyZW50RGl2ZXJ0VGFyZ2V0O2lmKG51bGwhPXIpe2xldCB0PW5ldyBlKHIudG9TdHJpbmcoKSk7dGhpcy5kaXZlcnRlZFBvaW50ZXI9dGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKHQpfXRoaXMuX3Zpc2l0Q291bnRzPU0uSk9iamVjdFRvSW50RGljdGlvbmFyeShuLnZpc2l0Q291bnRzKSx0aGlzLl90dXJuSW5kaWNlcz1NLkpPYmplY3RUb0ludERpY3Rpb25hcnkobi50dXJuSW5kaWNlcyksdGhpcy5jdXJyZW50VHVybkluZGV4PXBhcnNlSW50KG4udHVybklkeCksdGhpcy5zdG9yeVNlZWQ9cGFyc2VJbnQobi5zdG9yeVNlZWQpLHRoaXMucHJldmlvdXNSYW5kb209cGFyc2VJbnQobi5wcmV2aW91c1JhbmRvbSk7bGV0IGE9bi5jaG9pY2VUaHJlYWRzO2ZvcihsZXQgdCBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcyl7bGV0IGU9dGhpcy5jYWxsU3RhY2suVGhyZWFkV2l0aEluZGV4KHQub3JpZ2luYWxUaHJlYWRJbmRleCk7aWYobnVsbCE9ZSl0LnRocmVhZEF0R2VuZXJhdGlvbj1lLkNvcHkoKTtlbHNle2xldCBlPWFbdC5vcmlnaW5hbFRocmVhZEluZGV4LnRvU3RyaW5nKCldO3QudGhyZWFkQXRHZW5lcmF0aW9uPW5ldyBxLlRocmVhZChlLHRoaXMuc3RvcnkpfX19UmVzZXRFcnJvcnMoKXt0aGlzLl9jdXJyZW50RXJyb3JzPW51bGwsdGhpcy5fY3VycmVudFdhcm5pbmdzPW51bGx9UmVzZXRPdXRwdXQodD1udWxsKXt0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoPTAsbnVsbCE9PXQmJnRoaXMuX291dHB1dFN0cmVhbS5wdXNoLmFwcGx5KHRoaXMuX291dHB1dFN0cmVhbSx0KSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9UHVzaFRvT3V0cHV0U3RyZWFtKHQpe2xldCBlPWEodCxUKTtpZihudWxsIT09ZSl7bGV0IHQ9dGhpcy5UcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2UoZSk7aWYobnVsbCE9PXQpe2ZvcihsZXQgZSBvZiB0KXRoaXMuUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbChlKTtyZXR1cm4gdm9pZCB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9fXRoaXMuUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbCh0KSx0aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9UG9wRnJvbU91dHB1dFN0cmVhbSh0KXt0aGlzLm91dHB1dFN0cmVhbS5zcGxpY2UodGhpcy5vdXRwdXRTdHJlYW0ubGVuZ3RoLXQsdCksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfVRyeVNwbGl0dGluZ0hlYWRUYWlsV2hpdGVzcGFjZSh0KXtsZXQgZT10LnZhbHVlO2lmKG51bGw9PT1lKXJldHVybiBkKFwic2luZ2xlLnZhbHVlXCIpO2xldCBuPS0xLGk9LTE7Zm9yKGxldCB0PTA7dDxlLmxlbmd0aDsrK3Qpe2xldCByPWVbdF07aWYoXCJcXG5cIiE9cil7aWYoXCIgXCI9PXJ8fFwiXFx0XCI9PXIpY29udGludWU7YnJlYWt9LTE9PW4mJihuPXQpLGk9dH1sZXQgcj0tMSxhPS0xO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtsZXQgbj1lW3RdO2lmKFwiXFxuXCIhPW4pe2lmKFwiIFwiPT1ufHxcIlxcdFwiPT1uKWNvbnRpbnVlO2JyZWFrfS0xPT1yJiYocj10KSxhPXR9aWYoLTE9PW4mJi0xPT1yKXJldHVybiBudWxsO2xldCBzPVtdLGw9MCxvPWUubGVuZ3RoO2lmKC0xIT1uKXtpZihuPjApe2xldCB0PW5ldyBUKGUuc3Vic3RyaW5nKDAsbikpO3MucHVzaCh0KX1zLnB1c2gobmV3IFQoXCJcXG5cIikpLGw9aSsxfWlmKC0xIT1yJiYobz1hKSxvPmwpe2xldCB0PWUuc3Vic3RyaW5nKGwsby1sKTtzLnB1c2gobmV3IFQodCkpfWlmKC0xIT1yJiZhPmkmJihzLnB1c2gobmV3IFQoXCJcXG5cIikpLHI8ZS5sZW5ndGgtMSkpe2xldCB0PWUubGVuZ3RoLXItMSxuPW5ldyBUKGUuc3Vic3RyaW5nKHIrMSx0KSk7cy5wdXNoKG4pfXJldHVybiBzfVB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwodCl7bGV0IGU9YSh0LHgpLG49YSh0LFQpLGk9ITA7aWYoZSl0aGlzLlRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKSxpPSEwO2Vsc2UgaWYobil7bGV0IHQ9LTEsZT10aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudDtlLnR5cGU9PXIuRnVuY3Rpb24mJih0PWUuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtKTtsZXQgYT0tMTtmb3IobGV0IGU9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO2U+PTA7ZS0tKXtsZXQgbj10aGlzLl9vdXRwdXRTdHJlYW1bZV0saT1uIGluc3RhbmNlb2YgQT9uOm51bGw7aWYobnVsbCE9KG4gaW5zdGFuY2VvZiB4P246bnVsbCkpe2E9ZTticmVha31pZihudWxsIT1pJiZpLmNvbW1hbmRUeXBlPT1BLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKXtlPj10JiYodD0tMSk7YnJlYWt9fWxldCBzPS0xO2lmKHM9LTEhPWEmJi0xIT10P01hdGgubWluKHQsYSk6LTEhPWE/YTp0LC0xIT1zKXtpZihuLmlzTmV3bGluZSlpPSExO2Vsc2UgaWYobi5pc05vbldoaXRlc3BhY2UmJihhPi0xJiZ0aGlzLlJlbW92ZUV4aXN0aW5nR2x1ZSgpLHQ+LTEpKXtsZXQgdD10aGlzLmNhbGxTdGFjay5lbGVtZW50cztmb3IobGV0IGU9dC5sZW5ndGgtMTtlPj0wO2UtLSl7bGV0IG49dFtlXTtpZihuLnR5cGUhPXIuRnVuY3Rpb24pYnJlYWs7bi5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW09LTF9fX1lbHNlIG4uaXNOZXdsaW5lJiYoIXRoaXMub3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSYmdGhpcy5vdXRwdXRTdHJlYW1Db250YWluc0NvbnRlbnR8fChpPSExKSl9aWYoaSl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJvYmpcIik7dGhpcy5fb3V0cHV0U3RyZWFtLnB1c2godCksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfX1UcmltTmV3bGluZXNGcm9tT3V0cHV0U3RyZWFtKCl7bGV0IHQ9LTEsZT10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7Zm9yKDtlPj0wOyl7bGV0IG49dGhpcy5fb3V0cHV0U3RyZWFtW2VdLGk9YShuLEEpLHI9YShuLFQpO2lmKG51bGwhPWl8fG51bGwhPXImJnIuaXNOb25XaGl0ZXNwYWNlKWJyZWFrO251bGwhPXImJnIuaXNOZXdsaW5lJiYodD1lKSxlLS19aWYodD49MClmb3IoZT10O2U8dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aDspe2EodGhpcy5fb3V0cHV0U3RyZWFtW2VdLFQpP3RoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoZSwxKTplKyt9dGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfVJlbW92ZUV4aXN0aW5nR2x1ZSgpe2ZvcihsZXQgdD10aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7dD49MDt0LS0pe2xldCBlPXRoaXMuX291dHB1dFN0cmVhbVt0XTtpZihlIGluc3RhbmNlb2YgeCl0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKHQsMSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgQSlicmVha310aGlzLk91dHB1dFN0cmVhbURpcnR5KCl9Z2V0IG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUoKXtpZih0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoPjApZm9yKGxldCB0PXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTt0Pj0wO3QtLSl7aWYodGhpcy5fb3V0cHV0U3RyZWFtW3RdaW5zdGFuY2VvZiBBKWJyZWFrO2xldCBlPXRoaXMuX291dHB1dFN0cmVhbVt0XTtpZihlIGluc3RhbmNlb2YgVCl7aWYoZS5pc05ld2xpbmUpcmV0dXJuITA7aWYoZS5pc05vbldoaXRlc3BhY2UpYnJlYWt9fXJldHVybiExfWdldCBvdXRwdXRTdHJlYW1Db250YWluc0NvbnRlbnQoKXtmb3IobGV0IHQ9MDt0PHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGg7dCsrKWlmKHRoaXMuX291dHB1dFN0cmVhbVt0XWluc3RhbmNlb2YgVClyZXR1cm4hMDtyZXR1cm4hMX1nZXQgaW5TdHJpbmdFdmFsdWF0aW9uKCl7Zm9yKGxldCB0PXRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgtMTt0Pj0wO3QtLSl7bGV0IGU9YSh0aGlzLl9vdXRwdXRTdHJlYW1bdF0sQSk7aWYoZSBpbnN0YW5jZW9mIEEmJmUuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpcmV0dXJuITB9cmV0dXJuITF9UHVzaEV2YWx1YXRpb25TdGFjayh0KXtsZXQgZT1hKHQsTyk7aWYoZSl7bGV0IHQ9ZS52YWx1ZTtpZihudWxsPT09dClyZXR1cm4gZChcInJhd0xpc3RcIik7aWYobnVsbCE9dC5vcmlnaW5OYW1lcyl7dC5vcmlnaW5zfHwodC5vcmlnaW5zPVtdKSx0Lm9yaWdpbnMubGVuZ3RoPTA7Zm9yKGxldCBlIG9mIHQub3JpZ2luTmFtZXMpe2lmKG51bGw9PT10aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucylyZXR1cm4gZChcIlN0b3J5U3RhdGUuc3RvcnkubGlzdERlZmluaXRpb25zXCIpO2xldCBuPXRoaXMuc3RvcnkubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKGUsbnVsbCk7aWYobnVsbD09PW4ucmVzdWx0KXJldHVybiBkKFwiU3RvcnlTdGF0ZSBkZWYucmVzdWx0XCIpO3Qub3JpZ2lucy5pbmRleE9mKG4ucmVzdWx0KTwwJiZ0Lm9yaWdpbnMucHVzaChuLnJlc3VsdCl9fX1pZihudWxsPT09dClyZXR1cm4gZChcIm9ialwiKTt0aGlzLmV2YWx1YXRpb25TdGFjay5wdXNoKHQpfVBvcEV2YWx1YXRpb25TdGFjayh0KXtpZih2b2lkIDA9PT10KXtyZXR1cm4gbyh0aGlzLmV2YWx1YXRpb25TdGFjay5wb3AoKSl9aWYodD50aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwidHJ5aW5nIHRvIHBvcCB0b28gbWFueSBvYmplY3RzXCIpO3JldHVybiBvKHRoaXMuZXZhbHVhdGlvblN0YWNrLnNwbGljZSh0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgtdCx0KSl9UGVla0V2YWx1YXRpb25TdGFjaygpe3JldHVybiB0aGlzLmV2YWx1YXRpb25TdGFja1t0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGgtMV19Rm9yY2VFbmQoKXt0aGlzLmNhbGxTdGFjay5SZXNldCgpLHRoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aD0wLHRoaXMuY3VycmVudFBvaW50ZXI9SS5OdWxsLHRoaXMucHJldmlvdXNQb2ludGVyPUkuTnVsbCx0aGlzLmRpZFNhZmVFeGl0PSEwfVRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCl7bi5Bc3NlcnQodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZT09ci5GdW5jdGlvbik7bGV0IHQ9dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtOy0xPT10JiYodD0wKTtmb3IobGV0IGU9dGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aC0xO2U+PXQ7ZS0tKXtsZXQgdD10aGlzLl9vdXRwdXRTdHJlYW1bZV0sbj1hKHQsVCksaT1hKHQsQSk7aWYobnVsbCE9bil7aWYoaSlicmVhaztpZighbi5pc05ld2xpbmUmJiFuLmlzSW5saW5lV2hpdGVzcGFjZSlicmVhazt0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGUsMSksdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpfX19UG9wQ2FsbFN0YWNrKHQ9bnVsbCl7dGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZT09ci5GdW5jdGlvbiYmdGhpcy5UcmltV2hpdGVzcGFjZUZyb21GdW5jdGlvbkVuZCgpLHRoaXMuY2FsbFN0YWNrLlBvcCh0KX1TZXRDaG9zZW5QYXRoKHQsZSl7dGhpcy5fY3VycmVudENob2ljZXMubGVuZ3RoPTA7bGV0IG49dGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKHQpO24uaXNOdWxsfHwtMSE9bi5pbmRleHx8KG4uaW5kZXg9MCksdGhpcy5jdXJyZW50UG9pbnRlcj1uLGUmJnRoaXMuY3VycmVudFR1cm5JbmRleCsrfVN0YXJ0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUodCxlKXt0aGlzLmNhbGxTdGFjay5QdXNoKHIuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUsdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKSx0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlcj1JLlN0YXJ0T2YodCksdGhpcy5QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soZSl9UGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKHQpe2lmKG51bGwhPXQpZm9yKGxldCBlPTA7ZTx0Lmxlbmd0aDtlKyspe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0W2VdJiZcInN0cmluZ1wiIT10eXBlb2YgdFtlXSl0aHJvdyBuZXcgRXJyb3IoXCJpbmsgYXJndW1lbnRzIHdoZW4gY2FsbGluZyBFdmFsdWF0ZUZ1bmN0aW9uIC8gQ2hvb3NlUGF0aFN0cmluZ1dpdGhQYXJhbWV0ZXJzICBtdXN0IGJlIGludCwgZmxvYXQgb3Igc3RyaW5nXCIpO3RoaXMuUHVzaEV2YWx1YXRpb25TdGFjayh2LkNyZWF0ZSh0W2VdKSl9fVRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpe3JldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlPT1yLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lJiYodGhpcy5jdXJyZW50UG9pbnRlcj1JLk51bGwsdGhpcy5kaWRTYWZlRXhpdD0hMCwhMCl9Q29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpe2lmKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUhPXIuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpdGhyb3cgbmV3IFMoXCJFeHBlY3RlZCBleHRlcm5hbCBmdW5jdGlvbiBldmFsdWF0aW9uIHRvIGJlIGNvbXBsZXRlLiBTdGFjayB0cmFjZTogXCIrdGhpcy5jYWxsU3RhY2suY2FsbFN0YWNrVHJhY2UpO2xldCB0PXRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQsZT1udWxsO2Zvcig7dGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoPnQ7KXtsZXQgdD10aGlzLlBvcEV2YWx1YXRpb25TdGFjaygpO251bGw9PT1lJiYoZT10KX1pZih0aGlzLlBvcENhbGxTdGFjayhyLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKSxlKXtpZihlIGluc3RhbmNlb2YgTClyZXR1cm4gbnVsbDtsZXQgdD1zKGUsdik7cmV0dXJuIHQudmFsdWVUeXBlPT1pLkRpdmVydFRhcmdldD90LnZhbHVlT2JqZWN0LnRvU3RyaW5nKCk6dC52YWx1ZU9iamVjdH1yZXR1cm4gbnVsbH1BZGRFcnJvcih0LGUpe2U/KG51bGw9PXRoaXMuX2N1cnJlbnRXYXJuaW5ncyYmKHRoaXMuX2N1cnJlbnRXYXJuaW5ncz1bXSksdGhpcy5fY3VycmVudFdhcm5pbmdzLnB1c2godCkpOihudWxsPT10aGlzLl9jdXJyZW50RXJyb3JzJiYodGhpcy5fY3VycmVudEVycm9ycz1bXSksdGhpcy5fY3VycmVudEVycm9ycy5wdXNoKHQpKX1PdXRwdXRTdHJlYW1EaXJ0eSgpe3RoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eT0hMCx0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHk9ITB9fWNsYXNzICR7Y29uc3RydWN0b3IoKXt0aGlzLnN0YXJ0VGltZT12b2lkIDB9Z2V0IEVsYXBzZWRNaWxsaXNlY29uZHMoKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5zdGFydFRpbWU/MDoobmV3IERhdGUpLmdldFRpbWUoKS10aGlzLnN0YXJ0VGltZX1TdGFydCgpe3RoaXMuc3RhcnRUaW1lPShuZXcgRGF0ZSkuZ2V0VGltZSgpfVN0b3AoKXt0aGlzLnN0YXJ0VGltZT12b2lkIDB9fU51bWJlci5pc0ludGVnZXJ8fChOdW1iZXIuaXNJbnRlZ2VyPWZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmdD4tOTAwNzE5OTI1NDc0MDk5MiYmdDw5MDA3MTk5MjU0NzQwOTkyJiZNYXRoLmZsb29yKHQpPT09dH0pO2NsYXNzIFggZXh0ZW5kcyBwe2NvbnN0cnVjdG9yKCl7bGV0IHQ7c3VwZXIoKSx0aGlzLmlua1ZlcnNpb25NaW5pbXVtQ29tcGF0aWJsZT0xOCx0aGlzLl9wcmV2Q29udGFpbmVycz1bXSx0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcz0hMSx0aGlzLl9saXN0RGVmaW5pdGlvbnM9bnVsbCx0aGlzLl92YXJpYWJsZU9ic2VydmVycz1udWxsLHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscz0hMSx0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyPW51bGwsdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZT0hMSx0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZT1udWxsLHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQ9MCx0aGlzLl9hc3luY1NhdmluZz0hMSx0aGlzLl9wcm9maWxlcj1udWxsO2xldCBlPW51bGwsbj1udWxsO2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTil0PWFyZ3VtZW50c1swXSx2b2lkIDAhPT1hcmd1bWVudHNbMV0mJihlPWFyZ3VtZW50c1sxXSksdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXI9dDtlbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe2xldCB0PWFyZ3VtZW50c1swXTtuPXouVGV4dFRvRGljdGlvbmFyeSh0KX1lbHNlIG49YXJndW1lbnRzWzBdO2lmKG51bGwhPWUmJih0aGlzLl9saXN0RGVmaW5pdGlvbnM9bmV3IEIoZSkpLHRoaXMuX2V4dGVybmFscz1uZXcgTWFwLG51bGwhPT1uKXtsZXQgdD1uLGU9dC5pbmtWZXJzaW9uO2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiaW5rIHZlcnNpb24gbnVtYmVyIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIGl0J3MgYSB2YWxpZCAuaW5rLmpzb24gZmlsZT9cIik7bGV0IGk9cGFyc2VJbnQoZSk7aWYoaT5YLmlua1ZlcnNpb25DdXJyZW50KXRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3Rvcnkgd2FzIG5ld2VyIHRoYW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgZW5naW5lXCIpO2lmKGk8dGhpcy5pbmtWZXJzaW9uTWluaW11bUNvbXBhdGlibGUpdGhyb3cgbmV3IEVycm9yKFwiVmVyc2lvbiBvZiBpbmsgdXNlZCB0byBidWlsZCBzdG9yeSBpcyB0b28gb2xkIHRvIGJlIGxvYWRlZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGVuZ2luZVwiKTtpIT1YLmlua1ZlcnNpb25DdXJyZW50JiZjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IGRvZXNuJ3QgbWF0Y2ggY3VycmVudCB2ZXJzaW9uIG9mIGVuZ2luZS4gTm9uLWNyaXRpY2FsLCBidXQgcmVjb21tZW5kIHN5bmNocm9uaXNpbmcuXCIpO2xldCByLGE9dC5yb290O2lmKG51bGw9PWEpdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBub2RlIGZvciBpbmsgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgaXQncyBhIHZhbGlkIC5pbmsuanNvbiBmaWxlP1wiKTsocj10Lmxpc3REZWZzKSYmKHRoaXMuX2xpc3REZWZpbml0aW9ucz1NLkpUb2tlblRvTGlzdERlZmluaXRpb25zKHIpKSx0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcj1zKE0uSlRva2VuVG9SdW50aW1lT2JqZWN0KGEpLE4pLHRoaXMuUmVzZXRTdGF0ZSgpfX1nZXQgY3VycmVudENob2ljZXMoKXtsZXQgdD1bXTtpZihudWxsPT09dGhpcy5fc3RhdGUpcmV0dXJuIGQoXCJ0aGlzLl9zdGF0ZVwiKTtmb3IobGV0IGUgb2YgdGhpcy5fc3RhdGUuY3VycmVudENob2ljZXMpZS5pc0ludmlzaWJsZURlZmF1bHR8fChlLmluZGV4PXQubGVuZ3RoLHQucHVzaChlKSk7cmV0dXJuIHR9Z2V0IGN1cnJlbnRUZXh0KCl7cmV0dXJuIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgY3VycmVudFRleHQgc2luY2UgaXQncyBhIHdvcmsgaW4gcHJvZ3Jlc3NcIiksdGhpcy5zdGF0ZS5jdXJyZW50VGV4dH1nZXQgY3VycmVudFRhZ3MoKXtyZXR1cm4gdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGFncyBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKSx0aGlzLnN0YXRlLmN1cnJlbnRUYWdzfWdldCBjdXJyZW50RXJyb3JzKCl7cmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudEVycm9yc31nZXQgY3VycmVudFdhcm5pbmdzKCl7cmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFdhcm5pbmdzfWdldCBoYXNFcnJvcigpe3JldHVybiB0aGlzLnN0YXRlLmhhc0Vycm9yfWdldCBoYXNXYXJuaW5nKCl7cmV0dXJuIHRoaXMuc3RhdGUuaGFzV2FybmluZ31nZXQgdmFyaWFibGVzU3RhdGUoKXtyZXR1cm4gdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZX1nZXQgbGlzdERlZmluaXRpb25zKCl7cmV0dXJuIHRoaXMuX2xpc3REZWZpbml0aW9uc31nZXQgc3RhdGUoKXtyZXR1cm4gdGhpcy5fc3RhdGV9U3RhcnRQcm9maWxpbmcoKXt9RW5kUHJvZmlsaW5nKCl7fVRvSnNvbih0KXtsZXQgZT0hMTtpZih0fHwoZT0hMCx0PW5ldyB6LldyaXRlciksdC5Xcml0ZU9iamVjdFN0YXJ0KCksdC5Xcml0ZUludFByb3BlcnR5KFwiaW5rVmVyc2lvblwiLFguaW5rVmVyc2lvbkN1cnJlbnQpLHQuV3JpdGVQcm9wZXJ0eShcInJvb3RcIix0PT5NLldyaXRlUnVudGltZUNvbnRhaW5lcih0LHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyKSksbnVsbCE9dGhpcy5fbGlzdERlZmluaXRpb25zKXt0LldyaXRlUHJvcGVydHlTdGFydChcImxpc3REZWZzXCIpLHQuV3JpdGVPYmplY3RTdGFydCgpO2ZvcihsZXQgZSBvZiB0aGlzLl9saXN0RGVmaW5pdGlvbnMubGlzdHMpe3QuV3JpdGVQcm9wZXJ0eVN0YXJ0KGUubmFtZSksdC5Xcml0ZU9iamVjdFN0YXJ0KCk7Zm9yKGxldFtuLGldb2YgZS5pdGVtcyl7bGV0IGU9Zi5mcm9tU2VyaWFsaXplZEtleShuKSxyPWk7dC5Xcml0ZUludFByb3BlcnR5KGUuaXRlbU5hbWUscil9dC5Xcml0ZU9iamVjdEVuZCgpLHQuV3JpdGVQcm9wZXJ0eUVuZCgpfXQuV3JpdGVPYmplY3RFbmQoKSx0LldyaXRlUHJvcGVydHlFbmQoKX1pZih0LldyaXRlT2JqZWN0RW5kKCksZSlyZXR1cm4gdC5Ub1N0cmluZygpfVJlc2V0U3RhdGUoKXt0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldFN0YXRlXCIpLHRoaXMuX3N0YXRlPW5ldyBIKHRoaXMpLHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLk9ic2VydmVWYXJpYWJsZUNoYW5nZSh0aGlzLlZhcmlhYmxlU3RhdGVEaWRDaGFuZ2VFdmVudC5iaW5kKHRoaXMpKSx0aGlzLlJlc2V0R2xvYmFscygpfVJlc2V0RXJyb3JzKCl7aWYobnVsbD09PXRoaXMuX3N0YXRlKXJldHVybiBkKFwidGhpcy5fc3RhdGVcIik7dGhpcy5fc3RhdGUuUmVzZXRFcnJvcnMoKX1SZXNldENhbGxzdGFjaygpe2lmKHRoaXMuSWZBc3luY1dlQ2FudChcIlJlc2V0Q2FsbHN0YWNrXCIpLG51bGw9PT10aGlzLl9zdGF0ZSlyZXR1cm4gZChcInRoaXMuX3N0YXRlXCIpO3RoaXMuX3N0YXRlLkZvcmNlRW5kKCl9UmVzZXRHbG9iYWxzKCl7aWYodGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldChcImdsb2JhbCBkZWNsXCIpKXtsZXQgdD10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTt0aGlzLkNob29zZVBhdGgobmV3IGUoXCJnbG9iYWwgZGVjbFwiKSwhMSksdGhpcy5Db250aW51ZUludGVybmFsKCksdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcj10fXRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuU25hcHNob3REZWZhdWx0R2xvYmFscygpfUNvbnRpbnVlKCl7cmV0dXJuIHRoaXMuQ29udGludWVBc3luYygwKSx0aGlzLmN1cnJlbnRUZXh0fWdldCBjYW5Db250aW51ZSgpe3JldHVybiB0aGlzLnN0YXRlLmNhbkNvbnRpbnVlfWdldCBhc3luY0NvbnRpbnVlQ29tcGxldGUoKXtyZXR1cm4hdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZX1Db250aW51ZUFzeW5jKHQpe3RoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFsc3x8dGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKSx0aGlzLkNvbnRpbnVlSW50ZXJuYWwodCl9Q29udGludWVJbnRlcm5hbCh0PTApe251bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5QcmVDb250aW51ZSgpO2xldCBlPXQ+MDtpZih0aGlzLl9yZWN1cnNpdmVDb250aW51ZUNvdW50KyssIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUpe2lmKHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmU9ZSwhdGhpcy5jYW5Db250aW51ZSl0aHJvdyBuZXcgUyhcIkNhbid0IGNvbnRpbnVlIC0gc2hvdWxkIGNoZWNrIGNhbkNvbnRpbnVlIGJlZm9yZSBjYWxsaW5nIENvbnRpbnVlXCIpO3RoaXMuX3N0YXRlLmRpZFNhZmVFeGl0PSExLHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCksMT09dGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCYmKHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzPSEwKX1sZXQgbj1uZXcgJDtuLlN0YXJ0KCk7bGV0IGk9ITE7ZG97dHJ5e2k9dGhpcy5Db250aW51ZVNpbmdsZVN0ZXAoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O3RoaXMuQWRkRXJyb3IodC5tZXNzYWdlLHZvaWQgMCx0LnVzZUVuZExpbmVOdW1iZXIpO2JyZWFrfWlmKGkpYnJlYWs7aWYodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSYmbi5FbGFwc2VkTWlsbGlzZWNvbmRzPnQpYnJlYWt9d2hpbGUodGhpcy5jYW5Db250aW51ZSk7bi5TdG9wKCksIWkmJnRoaXMuY2FuQ29udGludWV8fChudWxsIT09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUmJnRoaXMuUmVzdG9yZVN0YXRlU25hcHNob3QoKSx0aGlzLmNhbkNvbnRpbnVlfHwodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkJiZ0aGlzLkFkZEVycm9yKFwiVGhyZWFkIGF2YWlsYWJsZSB0byBwb3AsIHRocmVhZHMgc2hvdWxkIGFsd2F5cyBiZSBmbGF0IGJ5IHRoZSBlbmQgb2YgZXZhbHVhdGlvbj9cIiksMCE9dGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aHx8dGhpcy5zdGF0ZS5kaWRTYWZlRXhpdHx8bnVsbCE9dGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcnx8KHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChyLlR1bm5lbCk/dGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICctPi0+JyB0byByZXR1cm4gZnJvbSBhIHR1bm5lbD9cIik6dGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKHIuRnVuY3Rpb24pP3RoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnfiByZXR1cm4nP1wiKTp0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3A/dGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50IGZvciB1bmtub3duIHJlYXNvbi4gUGxlYXNlIGRlYnVnIGNvbXBpbGVyIVwiKTp0aGlzLkFkZEVycm9yKFwicmFuIG91dCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICctPiBET05FJyBvciAnLT4gRU5EJz9cIikpKSx0aGlzLnN0YXRlLmRpZFNhZmVFeGl0PSExLDE9PXRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQmJih0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcz0hMSksdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZT0hMSksdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudC0tLG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5Qb3N0Q29udGludWUoKX1Db250aW51ZVNpbmdsZVN0ZXAoKXtpZihudWxsIT10aGlzLl9wcm9maWxlciYmdGhpcy5fcHJvZmlsZXIuUHJlU3RlcCgpLHRoaXMuU3RlcCgpLG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5Qb3N0U3RlcCgpLHRoaXMuY2FuQ29udGludWV8fHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWV8fHRoaXMuVHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpLG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5QcmVTbmFwc2hvdCgpLCF0aGlzLnN0YXRlLmluU3RyaW5nRXZhbHVhdGlvbil7aWYobnVsbCE9PXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lKXtpZihudWxsPT09dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MpcmV0dXJuIGQoXCJ0aGlzLl9zdGF0ZUF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3NcIik7aWYobnVsbD09PXRoaXMuc3RhdGUuY3VycmVudFRhZ3MpcmV0dXJuIGQoXCJ0aGlzLnN0YXRlLmN1cnJlbnRUYWdzXCIpO2xldCB0PXRoaXMuQ2FsY3VsYXRlTmV3bGluZU91dHB1dFN0YXRlQ2hhbmdlKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUZXh0LHRoaXMuc3RhdGUuY3VycmVudFRleHQsdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MubGVuZ3RoLHRoaXMuc3RhdGUuY3VycmVudFRhZ3MubGVuZ3RoKTtpZih0PT1YLk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZSlyZXR1cm4gdGhpcy5SZXN0b3JlU3RhdGVTbmFwc2hvdCgpLCEwO3Q9PVguT3V0cHV0U3RhdGVDaGFuZ2UuTmV3bGluZVJlbW92ZWQmJnRoaXMuRGlzY2FyZFNuYXBzaG90KCl9dGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lJiYodGhpcy5jYW5Db250aW51ZT9udWxsPT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSYmdGhpcy5TdGF0ZVNuYXBzaG90KCk6dGhpcy5EaXNjYXJkU25hcHNob3QoKSl9cmV0dXJuIG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5Qb3N0U25hcHNob3QoKSwhMX1DYWxjdWxhdGVOZXdsaW5lT3V0cHV0U3RhdGVDaGFuZ2UodCxlLG4saSl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJwcmV2VGV4dFwiKTtpZihudWxsPT09ZSlyZXR1cm4gZChcImN1cnJUZXh0XCIpO2xldCByPWUubGVuZ3RoPj10Lmxlbmd0aCYmXCJcXG5cIj09ZS5jaGFyQXQodC5sZW5ndGgtMSk7aWYobj09aSYmdC5sZW5ndGg9PWUubGVuZ3RoJiZyKXJldHVybiBYLk91dHB1dFN0YXRlQ2hhbmdlLk5vQ2hhbmdlO2lmKCFyKXJldHVybiBYLk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkO2lmKGk+bilyZXR1cm4gWC5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmU7Zm9yKGxldCBuPXQubGVuZ3RoO248ZS5sZW5ndGg7bisrKXtsZXQgdD1lLmNoYXJBdChuKTtpZihcIiBcIiE9dCYmXCJcXHRcIiE9dClyZXR1cm4gWC5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmV9cmV0dXJuIFguT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2V9Q29udGludWVNYXhpbWFsbHkoKXt0aGlzLklmQXN5bmNXZUNhbnQoXCJDb250aW51ZU1heGltYWxseVwiKTtsZXQgdD1uZXcgbTtmb3IoO3RoaXMuY2FuQ29udGludWU7KXQuQXBwZW5kKHRoaXMuQ29udGludWUoKSk7cmV0dXJuIHQudG9TdHJpbmcoKX1Db250ZW50QXRQYXRoKHQpe3JldHVybiB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgodCl9S25vdENvbnRhaW5lcldpdGhOYW1lKHQpe2xldCBlPXRoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldCh0KTtyZXR1cm4gZSBpbnN0YW5jZW9mIE4/ZTpudWxsfVBvaW50ZXJBdFBhdGgodCl7aWYoMD09dC5sZW5ndGgpcmV0dXJuIEkuTnVsbDtsZXQgZT1uZXcgSSxuPXQubGVuZ3RoLGk9bnVsbDtyZXR1cm4gbnVsbD09PXQubGFzdENvbXBvbmVudD9kKFwicGF0aC5sYXN0Q29tcG9uZW50XCIpOih0Lmxhc3RDb21wb25lbnQuaXNJbmRleD8obj10Lmxlbmd0aC0xLGk9dGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHQsdm9pZCAwLG4pLGUuY29udGFpbmVyPWkuY29udGFpbmVyLGUuaW5kZXg9dC5sYXN0Q29tcG9uZW50LmluZGV4KTooaT10aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgodCksZS5jb250YWluZXI9aS5jb250YWluZXIsZS5pbmRleD0tMSksbnVsbD09aS5vYmp8fGkub2JqPT10aGlzLm1haW5Db250ZW50Q29udGFpbmVyJiZuPjA/dGhpcy5FcnJvcihcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIrdCtcIicsIGFuZCBubyBhcHByb3hpbWF0aW9uIG9mIGl0IHdhcyBwb3NzaWJsZS5cIik6aS5hcHByb3hpbWF0ZSYmdGhpcy5XYXJuaW5nKFwiRmFpbGVkIHRvIGZpbmQgY29udGVudCBhdCBwYXRoICdcIit0K1wiJywgc28gaXQgd2FzIGFwcHJveGltYXRlZCB0bzogJ1wiK2kub2JqLnBhdGgrXCInLlwiKSxlKX1TdGF0ZVNuYXBzaG90KCl7dGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU9dGhpcy5fc3RhdGUsdGhpcy5fc3RhdGU9dGhpcy5fc3RhdGUuQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKX1SZXN0b3JlU3RhdGVTbmFwc2hvdCgpe251bGw9PT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSYmZChcIl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZVwiKSx0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5SZXN0b3JlQWZ0ZXJQYXRjaCgpLHRoaXMuX3N0YXRlPXRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lPW51bGwsdGhpcy5fYXN5bmNTYXZpbmd8fHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKX1EaXNjYXJkU25hcHNob3QoKXt0aGlzLl9hc3luY1NhdmluZ3x8dGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpLHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lPW51bGx9Q29weVN0YXRlRm9yQmFja2dyb3VuZFRocmVhZFNhdmUoKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJzdGFydCBzYXZpbmcgb24gYSBiYWNrZ3JvdW5kIHRocmVhZFwiKSx0aGlzLl9hc3luY1NhdmluZyl0aHJvdyBuZXcgRXJyb3IoXCJTdG9yeSBpcyBhbHJlYWR5IGluIGJhY2tncm91bmQgc2F2aW5nIG1vZGUsIGNhbid0IGNhbGwgQ29weVN0YXRlRm9yQmFja2dyb3VuZFRocmVhZFNhdmUgYWdhaW4hXCIpO2xldCB0PXRoaXMuX3N0YXRlO3JldHVybiB0aGlzLl9zdGF0ZT10aGlzLl9zdGF0ZS5Db3B5QW5kU3RhcnRQYXRjaGluZygpLHRoaXMuX2FzeW5jU2F2aW5nPSEwLHR9QmFja2dyb3VuZFNhdmVDb21wbGV0ZSgpe251bGw9PT10aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSYmdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpLHRoaXMuX2FzeW5jU2F2aW5nPSExfVN0ZXAoKXtsZXQgdD0hMCxlPXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO2lmKGUuaXNOdWxsKXJldHVybjtsZXQgbj1hKGUuUmVzb2x2ZSgpLE4pO2Zvcig7biYmKHRoaXMuVmlzaXRDb250YWluZXIobiwhMCksMCE9bi5jb250ZW50Lmxlbmd0aCk7KWU9SS5TdGFydE9mKG4pLG49YShlLlJlc29sdmUoKSxOKTt0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyPWUuY29weSgpLG51bGwhPXRoaXMuX3Byb2ZpbGVyJiZ0aGlzLl9wcm9maWxlci5TdGVwKHRoaXMuc3RhdGUuY2FsbFN0YWNrKTtsZXQgaT1lLlJlc29sdmUoKSxyPXRoaXMuUGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2woaSk7aWYodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpcmV0dXJuO3ImJih0PSExKTtsZXQgcz1hKGksVyk7aWYocyl7bGV0IGU9dGhpcy5Qcm9jZXNzQ2hvaWNlKHMpO2UmJnRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5wdXNoKGUpLGk9bnVsbCx0PSExfWlmKGkgaW5zdGFuY2VvZiBOJiYodD0hMSksdCl7bGV0IHQ9YShpLHcpO2lmKHQmJi0xPT10LmNvbnRleHRJbmRleCl7bGV0IGU9dGhpcy5zdGF0ZS5jYWxsU3RhY2suQ29udGV4dEZvclZhcmlhYmxlTmFtZWQodC52YXJpYWJsZU5hbWUpO2k9bmV3IHcodC52YXJpYWJsZU5hbWUsZSl9dGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uP3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhpKTp0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShpKX10aGlzLk5leHRDb250ZW50KCk7bGV0IGw9YShpLEEpO2wmJmwuY29tbWFuZFR5cGU9PUEuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQmJnRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2hUaHJlYWQoKX1WaXNpdENvbnRhaW5lcih0LGUpe3QuY291bnRpbmdBdFN0YXJ0T25seSYmIWV8fCh0LnZpc2l0c1Nob3VsZEJlQ291bnRlZCYmdGhpcy5zdGF0ZS5JbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKHQpLHQudHVybkluZGV4U2hvdWxkQmVDb3VudGVkJiZ0aGlzLnN0YXRlLlJlY29yZFR1cm5JbmRleFZpc2l0VG9Db250YWluZXIodCkpfVZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpe2xldCB0PXRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyLmNvcHkoKSxlPXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO2lmKGUuaXNOdWxsfHwtMT09ZS5pbmRleClyZXR1cm47aWYodGhpcy5fcHJldkNvbnRhaW5lcnMubGVuZ3RoPTAsIXQuaXNOdWxsKXtsZXQgZT1hKHQuUmVzb2x2ZSgpLE4pfHxhKHQuY29udGFpbmVyLE4pO2Zvcig7ZTspdGhpcy5fcHJldkNvbnRhaW5lcnMucHVzaChlKSxlPWEoZS5wYXJlbnQsTil9bGV0IG49ZS5SZXNvbHZlKCk7aWYobnVsbD09bilyZXR1cm47bGV0IGk9YShuLnBhcmVudCxOKTtmb3IoO2kmJih0aGlzLl9wcmV2Q29udGFpbmVycy5pbmRleE9mKGkpPDB8fGkuY291bnRpbmdBdFN0YXJ0T25seSk7KXtsZXQgdD1pLmNvbnRlbnQubGVuZ3RoPjAmJm49PWkuY29udGVudFswXTt0aGlzLlZpc2l0Q29udGFpbmVyKGksdCksbj1pLGk9YShpLnBhcmVudCxOKX19UHJvY2Vzc0Nob2ljZSh0KXtsZXQgZT0hMDtpZih0Lmhhc0NvbmRpdGlvbil7bGV0IHQ9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTt0aGlzLklzVHJ1dGh5KHQpfHwoZT0hMSl9bGV0IG49XCJcIixpPVwiXCI7aWYodC5oYXNDaG9pY2VPbmx5Q29udGVudCl7aT1zKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksVCkudmFsdWV8fFwiXCJ9aWYodC5oYXNTdGFydENvbnRlbnQpe249cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLFQpLnZhbHVlfHxcIlwifWlmKHQub25jZU9ubHkpe3RoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcih0LmNob2ljZVRhcmdldCk+MCYmKGU9ITEpfWlmKCFlKXJldHVybiBudWxsO2xldCByPW5ldyBEO3JldHVybiByLnRhcmdldFBhdGg9dC5wYXRoT25DaG9pY2Usci5zb3VyY2VQYXRoPXQucGF0aC50b1N0cmluZygpLHIuaXNJbnZpc2libGVEZWZhdWx0PXQuaXNJbnZpc2libGVEZWZhdWx0LHIudGhyZWFkQXRHZW5lcmF0aW9uPXRoaXMuc3RhdGUuY2FsbFN0YWNrLkZvcmtUaHJlYWQoKSxyLnRleHQ9KG4raSkucmVwbGFjZSgvXlsgXFx0XSt8WyBcXHRdKyQvZyxcIlwiKSxyfUlzVHJ1dGh5KHQpe2lmKHQgaW5zdGFuY2VvZiB2KXtsZXQgZT10O2lmKGUgaW5zdGFuY2VvZiBQKXtsZXQgdD1lO3JldHVybiB0aGlzLkVycm9yKFwiU2hvdWxkbid0IHVzZSBhIGRpdmVydCB0YXJnZXQgKHRvIFwiK3QudGFyZ2V0UGF0aCtcIikgYXMgYSBjb25kaXRpb25hbCB2YWx1ZS4gRGlkIHlvdSBpbnRlbmQgYSBmdW5jdGlvbiBjYWxsICdsaWtlVGhpcygpJyBvciBhIHJlYWQgY291bnQgY2hlY2sgJ2xpa2VUaGlzJz8gKG5vIGFycm93cylcIiksITF9cmV0dXJuIGUuaXNUcnV0aHl9cmV0dXJuITF9UGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2wodCl7aWYobnVsbD09dClyZXR1cm4hMTtpZih0IGluc3RhbmNlb2Ygayl7bGV0IGU9dDtpZihlLmlzQ29uZGl0aW9uYWwpe2xldCB0PXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7aWYoIXRoaXMuSXNUcnV0aHkodCkpcmV0dXJuITB9aWYoZS5oYXNWYXJpYWJsZVRhcmdldCl7bGV0IHQ9ZS52YXJpYWJsZURpdmVydE5hbWUsbj10aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodCk7aWYobnVsbD09bil0aGlzLkVycm9yKFwiVHJpZWQgdG8gZGl2ZXJ0IHVzaW5nIGEgdGFyZ2V0IGZyb20gYSB2YXJpYWJsZSB0aGF0IGNvdWxkIG5vdCBiZSBmb3VuZCAoXCIrdCtcIilcIik7ZWxzZSBpZighKG4gaW5zdGFuY2VvZiBQKSl7bGV0IGU9YShuLGIpLGk9XCJUcmllZCB0byBkaXZlcnQgdG8gYSB0YXJnZXQgZnJvbSBhIHZhcmlhYmxlLCBidXQgdGhlIHZhcmlhYmxlIChcIit0K1wiKSBkaWRuJ3QgY29udGFpbiBhIGRpdmVydCB0YXJnZXQsIGl0IFwiO2UgaW5zdGFuY2VvZiBiJiYwPT1lLnZhbHVlP2krPVwid2FzIGVtcHR5L251bGwgKHRoZSB2YWx1ZSAwKS5cIjppKz1cImNvbnRhaW5lZCAnXCIrbitcIicuXCIsdGhpcy5FcnJvcihpKX1sZXQgaT1zKG4sUCk7dGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXI9dGhpcy5Qb2ludGVyQXRQYXRoKGkudGFyZ2V0UGF0aCl9ZWxzZXtpZihlLmlzRXh0ZXJuYWwpcmV0dXJuIHRoaXMuQ2FsbEV4dGVybmFsRnVuY3Rpb24oZS50YXJnZXRQYXRoU3RyaW5nLGUuZXh0ZXJuYWxBcmdzKSwhMDt0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlcj1lLnRhcmdldFBvaW50ZXIuY29weSgpfXJldHVybiBlLnB1c2hlc1RvU3RhY2smJnRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goZS5zdGFja1B1c2hUeXBlLHZvaWQgMCx0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgpLHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCYmIWUuaXNFeHRlcm5hbCYmKGUmJmUuZGVidWdNZXRhZGF0YSYmbnVsbCE9ZS5kZWJ1Z01ldGFkYXRhLnNvdXJjZU5hbWU/dGhpcy5FcnJvcihcIkRpdmVydCB0YXJnZXQgZG9lc24ndCBleGlzdDogXCIrZS5kZWJ1Z01ldGFkYXRhLnNvdXJjZU5hbWUpOnRoaXMuRXJyb3IoXCJEaXZlcnQgcmVzb2x1dGlvbiBmYWlsZWQ6IFwiK2UpKSwhMH1pZih0IGluc3RhbmNlb2YgQSl7bGV0IGU9dDtzd2l0Y2goZS5jb21tYW5kVHlwZSl7Y2FzZSBBLkNvbW1hbmRUeXBlLkV2YWxTdGFydDp0aGlzLkFzc2VydCghMT09PXRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbixcIkFscmVhZHkgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uP1wiKSx0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb249ITA7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkV2YWxFbmQ6dGhpcy5Bc3NlcnQoITA9PT10aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24sXCJOb3QgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uIG1vZGVcIiksdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPSExO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5FdmFsT3V0cHV0OmlmKHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aD4wKXtsZXQgdD10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO2lmKCEodCBpbnN0YW5jZW9mIEwpKXtsZXQgZT1uZXcgVCh0LnRvU3RyaW5nKCkpO3RoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGUpfX1icmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuTm9PcDpicmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRHVwbGljYXRlOnRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayh0aGlzLnN0YXRlLlBlZWtFdmFsdWF0aW9uU3RhY2soKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlOnRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uOmNhc2UgQS5Db21tYW5kVHlwZS5Qb3BUdW5uZWw6bGV0IHQ9ZS5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbj9yLkZ1bmN0aW9uOnIuVHVubmVsLG49bnVsbDtpZih0PT1yLlR1bm5lbCl7bGV0IHQ9dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtuPWEodCxQKSxudWxsPT09biYmdGhpcy5Bc3NlcnQodCBpbnN0YW5jZW9mIEwsXCJFeHBlY3RlZCB2b2lkIGlmIC0+LT4gZG9lc24ndCBvdmVycmlkZSB0YXJnZXRcIil9aWYodGhpcy5zdGF0ZS5UcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSlicmVhaztpZih0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlPT10JiZ0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKSxuJiYodGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXI9dGhpcy5Qb2ludGVyQXRQYXRoKG4udGFyZ2V0UGF0aCkpO2Vsc2V7bGV0IGU9bmV3IE1hcDtlLnNldChyLkZ1bmN0aW9uLFwiZnVuY3Rpb24gcmV0dXJuIHN0YXRlbWVudCAofiByZXR1cm4pXCIpLGUuc2V0KHIuVHVubmVsLFwidHVubmVsIG9ud2FyZHMgc3RhdGVtZW50ICgtPi0+KVwiKTtsZXQgbj1lLmdldCh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlKTt0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3B8fChuPVwiZW5kIG9mIGZsb3cgKC0+IEVORCBvciBjaG9pY2UpXCIpO2xldCBpPVwiRm91bmQgXCIrZS5nZXQodCkrXCIsIHdoZW4gZXhwZWN0ZWQgXCIrbjt0aGlzLkVycm9yKGkpfWJyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5CZWdpblN0cmluZzp0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShlKSx0aGlzLkFzc2VydCghMD09PXRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbixcIkV4cGVjdGVkIHRvIGJlIGluIGFuIGV4cHJlc3Npb24gd2hlbiBldmFsdWF0aW5nIGEgc3RyaW5nXCIpLHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbj0hMTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRW5kU3RyaW5nOmxldCBpPVtdLGw9MDtmb3IobGV0IHQ9dGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoLTE7dD49MDstLXQpe2xldCBlPXRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW3RdO2wrKztsZXQgbj1hKGUsQSk7aWYobiYmbi5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5CZWdpblN0cmluZylicmVhaztlIGluc3RhbmNlb2YgVCYmaS5wdXNoKGUpfXRoaXMuc3RhdGUuUG9wRnJvbU91dHB1dFN0cmVhbShsKSxpPWkucmV2ZXJzZSgpO2xldCBvPW5ldyBtO2ZvcihsZXQgdCBvZiBpKW8uQXBwZW5kKHQudG9TdHJpbmcoKSk7dGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uPSEwLHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVChvLnRvU3RyaW5nKCkpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnQ6bGV0IHU9dGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aDt0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIodSkpO2JyZWFrO2Nhc2UgQS5Db21tYW5kVHlwZS5UdXJuczp0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IGIodGhpcy5zdGF0ZS5jdXJyZW50VHVybkluZGV4KzEpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuVHVybnNTaW5jZTpjYXNlIEEuQ29tbWFuZFR5cGUuUmVhZENvdW50OmxldCBoPXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7aWYoIShoIGluc3RhbmNlb2YgUCkpe2xldCB0PVwiXCI7aCBpbnN0YW5jZW9mIGImJih0PVwiLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgcmVhZCBjb3VudCAoJ2tub3RfbmFtZScpIGluc3RlYWQgb2YgYSB0YXJnZXQgKCctPiBrbm90X25hbWUnKT9cIiksdGhpcy5FcnJvcihcIlRVUk5TX1NJTkNFIC8gUkVBRF9DT1VOVCBleHBlY3RlZCBhIGRpdmVydCB0YXJnZXQgKGtub3QsIHN0aXRjaCwgbGFiZWwgbmFtZSksIGJ1dCBzYXcgXCIraCt0KTticmVha31sZXQgYyxwPXMoaCxQKSx5PWEodGhpcy5Db250ZW50QXRQYXRoKHAudGFyZ2V0UGF0aCkuY29ycmVjdE9iaixOKTtudWxsIT15P2M9ZS5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5UdXJuc1NpbmNlP3RoaXMuc3RhdGUuVHVybnNTaW5jZUZvckNvbnRhaW5lcih5KTp0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoeSk6KGM9ZS5jb21tYW5kVHlwZT09QS5Db21tYW5kVHlwZS5UdXJuc1NpbmNlPy0xOjAsdGhpcy5XYXJuaW5nKFwiRmFpbGVkIHRvIGZpbmQgY29udGFpbmVyIGZvciBcIitlLnRvU3RyaW5nKCkrXCIgbG9va3VwIGF0IFwiK3AudGFyZ2V0UGF0aC50b1N0cmluZygpKSksdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKGMpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuUmFuZG9tOntsZXQgdD1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYiksZT1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksYik7aWYobnVsbD09ZXx8ZSBpbnN0YW5jZW9mIGI9PSExKXJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgbWluaW11bSBwYXJhbWV0ZXIgb2YgUkFORE9NKG1pbiwgbWF4KVwiKTtpZihudWxsPT10fHxlIGluc3RhbmNlb2YgYj09ITEpcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtYXhpbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO2lmKG51bGw9PT10LnZhbHVlKXJldHVybiBkKFwibWF4SW50LnZhbHVlXCIpO2lmKG51bGw9PT1lLnZhbHVlKXJldHVybiBkKFwibWluSW50LnZhbHVlXCIpO2xldCBuPXQudmFsdWUtZS52YWx1ZSsxO248PTAmJnRoaXMuRXJyb3IoXCJSQU5ET00gd2FzIGNhbGxlZCB3aXRoIG1pbmltdW0gYXMgXCIrZS52YWx1ZStcIiBhbmQgbWF4aW11bSBhcyBcIit0LnZhbHVlK1wiLiBUaGUgbWF4aW11bSBtdXN0IGJlIGxhcmdlclwiKTtsZXQgaT10aGlzLnN0YXRlLnN0b3J5U2VlZCt0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tLHI9bmV3IEsoaSkubmV4dCgpLHM9ciVuK2UudmFsdWU7dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKHMpKSx0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tPXI7YnJlYWt9Y2FzZSBBLkNvbW1hbmRUeXBlLlNlZWRSYW5kb206bGV0IEM9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpO2lmKG51bGw9PUN8fEMgaW5zdGFuY2VvZiBiPT0hMSlyZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgcGFzc2VkIHRvIFNFRURfUkFORE9NXCIpO2lmKG51bGw9PT1DLnZhbHVlKXJldHVybiBkKFwibWluSW50LnZhbHVlXCIpO3RoaXMuc3RhdGUuc3RvcnlTZWVkPUMudmFsdWUsdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbT0wLHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgTCk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXg6bGV0IF89dGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyKS0xO3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgYihfKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4OmxldCB3PXRoaXMuTmV4dFNlcXVlbmNlU2h1ZmZsZUluZGV4KCk7dGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBiKHcpKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQ6YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkRvbmU6dGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkP3RoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpOih0aGlzLnN0YXRlLmRpZFNhZmVFeGl0PSEwLHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXI9SS5OdWxsKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuRW5kOnRoaXMuc3RhdGUuRm9yY2VFbmQoKTticmVhaztjYXNlIEEuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQ6bGV0IEU9YSh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLGIpLHg9cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLFQpO2lmKG51bGw9PT1FKXRocm93IG5ldyBTKFwiUGFzc2VkIG5vbi1pbnRlZ2VyIHdoZW4gY3JlYXRpbmcgYSBsaXN0IGVsZW1lbnQgZnJvbSBhIG51bWVyaWNhbCB2YWx1ZS5cIik7bGV0IGs9bnVsbDtpZihudWxsPT09dGhpcy5saXN0RGVmaW5pdGlvbnMpcmV0dXJuIGQoXCJ0aGlzLmxpc3REZWZpbml0aW9uc1wiKTtsZXQgVz10aGlzLmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbih4LnZhbHVlLG51bGwpO2lmKCFXLmV4aXN0cyl0aHJvdyBuZXcgUyhcIkZhaWxlZCB0byBmaW5kIExJU1QgY2FsbGVkIFwiK3gudmFsdWUpO3tpZihudWxsPT09RS52YWx1ZSlyZXR1cm4gZChcIm1pbkludC52YWx1ZVwiKTtsZXQgdD1XLnJlc3VsdC5UcnlHZXRJdGVtV2l0aFZhbHVlKEUudmFsdWUsZi5OdWxsKTt0LmV4aXN0cyYmKGs9bmV3IE8odC5yZXN1bHQsRS52YWx1ZSkpfW51bGw9PWsmJihrPW5ldyBPKSx0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soayk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkxpc3RSYW5nZTpsZXQgRj1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksdiksVj1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksdiksUj1hKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksTyk7aWYobnVsbD09PVJ8fG51bGw9PT1WfHxudWxsPT09Ril0aHJvdyBuZXcgUyhcIkV4cGVjdGVkIGxpc3QsIG1pbmltdW0gYW5kIG1heGltdW0gZm9yIExJU1RfUkFOR0VcIik7aWYobnVsbD09PVIudmFsdWUpcmV0dXJuIGQoXCJ0YXJnZXRMaXN0LnZhbHVlXCIpO2xldCBqPVIudmFsdWUuTGlzdFdpdGhTdWJSYW5nZShWLnZhbHVlT2JqZWN0LEYudmFsdWVPYmplY3QpO3RoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgTyhqKSk7YnJlYWs7Y2FzZSBBLkNvbW1hbmRUeXBlLkxpc3RSYW5kb206e2xldCB0PXRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7aWYobnVsbD09PXQpdGhyb3cgbmV3IFMoXCJFeHBlY3RlZCBsaXN0IGZvciBMSVNUX1JBTkRPTVwiKTtsZXQgZT10LnZhbHVlLG49bnVsbDtpZihudWxsPT09ZSl0aHJvdyBkKFwibGlzdFwiKTtpZigwPT1lLkNvdW50KW49bmV3IGc7ZWxzZXtsZXQgdD10aGlzLnN0YXRlLnN0b3J5U2VlZCt0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tLGk9bmV3IEsodCkubmV4dCgpLHI9aSVlLkNvdW50LGE9ZS5lbnRyaWVzKCk7Zm9yKGxldCB0PTA7dDw9ci0xO3QrKylhLm5leHQoKTtsZXQgcz1hLm5leHQoKS52YWx1ZSxsPXtLZXk6Zi5mcm9tU2VyaWFsaXplZEtleShzWzBdKSxWYWx1ZTpzWzFdfTtpZihudWxsPT09bC5LZXkub3JpZ2luTmFtZSlyZXR1cm4gZChcInJhbmRvbUl0ZW0uS2V5Lm9yaWdpbk5hbWVcIik7bj1uZXcgZyhsLktleS5vcmlnaW5OYW1lLHRoaXMpLG4uQWRkKGwuS2V5LGwuVmFsdWUpLHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb209aX10aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IE8obikpO2JyZWFrfWRlZmF1bHQ6dGhpcy5FcnJvcihcInVuaGFuZGxlZCBDb250cm9sQ29tbWFuZDogXCIrZSl9cmV0dXJuITB9aWYodCBpbnN0YW5jZW9mIFYpe2xldCBlPXQsbj10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO3JldHVybiB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkFzc2lnbihlLG4pLCEwfWlmKHQgaW5zdGFuY2VvZiBGKXtsZXQgZT10LG49bnVsbDtpZihudWxsIT1lLnBhdGhGb3JDb3VudCl7bGV0IHQ9ZS5jb250YWluZXJGb3JDb3VudCxpPXRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcih0KTtuPW5ldyBiKGkpfWVsc2Ugbj10aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUoZS5uYW1lKSxudWxsPT1uJiYodGhpcy5XYXJuaW5nKFwiVmFyaWFibGUgbm90IGZvdW5kOiAnXCIrZS5uYW1lK1wiJy4gVXNpbmcgZGVmYXVsdCB2YWx1ZSBvZiAwIChmYWxzZSkuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIHRlbXBvcmFyeSB2YXJpYWJsZXMgaWYgdGhlIGRlY2xhcmF0aW9uIGhhc24ndCB5ZXQgYmVlbiBoaXQuIEdsb2JhbHMgYXJlIGFsd2F5cyBnaXZlbiBhIGRlZmF1bHQgdmFsdWUgb24gbG9hZCBpZiBhIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNhdmUgc3RhdGUuXCIpLG49bmV3IGIoMCkpO3JldHVybiB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobiksITB9aWYodCBpbnN0YW5jZW9mIFIpe2xldCBlPXQsbj10aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayhlLm51bWJlck9mUGFyYW1ldGVycyksaT1lLkNhbGwobik7cmV0dXJuIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhpKSwhMH1yZXR1cm4hMX1DaG9vc2VQYXRoU3RyaW5nKHQsbj0hMCxpPVtdKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIENob29zZVBhdGhTdHJpbmcgcmlnaHQgbm93XCIpLG4pdGhpcy5SZXNldENhbGxzdGFjaygpO2Vsc2UgaWYodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZT09ci5GdW5jdGlvbil7bGV0IGU9XCJcIixuPXRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcjt0aHJvdyBudWxsIT1uJiYoZT1cIihcIituLnBhdGgudG9TdHJpbmcoKStcIikgXCIpLG5ldyBFcnJvcihcIlN0b3J5IHdhcyBydW5uaW5nIGEgZnVuY3Rpb24gXCIrZStcIndoZW4geW91IGNhbGxlZCBDaG9vc2VQYXRoU3RyaW5nKFwiK3QrXCIpIC0gdGhpcyBpcyBhbG1vc3QgY2VydGFpbmx5IG5vdCBub3Qgd2hhdCB5b3Ugd2FudCEgRnVsbCBzdGFjayB0cmFjZTogXFxuXCIrdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FsbFN0YWNrVHJhY2UpfXRoaXMuc3RhdGUuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGkpLHRoaXMuQ2hvb3NlUGF0aChuZXcgZSh0KSl9SWZBc3luY1dlQ2FudCh0KXtpZih0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlKXRocm93IG5ldyBFcnJvcihcIkNhbid0IFwiK3QrXCIuIFN0b3J5IGlzIGluIHRoZSBtaWRkbGUgb2YgYSBDb250aW51ZUFzeW5jKCkuIE1ha2UgbW9yZSBDb250aW51ZUFzeW5jKCkgY2FsbHMgb3IgYSBzaW5nbGUgQ29udGludWUoKSBjYWxsIGJlZm9yZWhhbmQuXCIpfUNob29zZVBhdGgodCxlPSEwKXt0aGlzLnN0YXRlLlNldENob3NlblBhdGgodCxlKSx0aGlzLlZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpfUNob29zZUNob2ljZUluZGV4KHQpe3Q9dDtsZXQgZT10aGlzLmN1cnJlbnRDaG9pY2VzO3RoaXMuQXNzZXJ0KHQ+PTAmJnQ8ZS5sZW5ndGgsXCJjaG9pY2Ugb3V0IG9mIHJhbmdlXCIpO2xldCBuPWVbdF07cmV0dXJuIG51bGw9PT1uLnRocmVhZEF0R2VuZXJhdGlvbj9kKFwiY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpOm51bGw9PT1uLnRhcmdldFBhdGg/ZChcImNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGhcIik6KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQ9bi50aHJlYWRBdEdlbmVyYXRpb24sdm9pZCB0aGlzLkNob29zZVBhdGgobi50YXJnZXRQYXRoKSl9SGFzRnVuY3Rpb24odCl7dHJ5e3JldHVybiBudWxsIT10aGlzLktub3RDb250YWluZXJXaXRoTmFtZSh0KX1jYXRjaCh0KXtyZXR1cm4hMX19RXZhbHVhdGVGdW5jdGlvbih0LGU9W10sbj0hMSl7aWYodGhpcy5JZkFzeW5jV2VDYW50KFwiZXZhbHVhdGUgYSBmdW5jdGlvblwiKSxudWxsPT10KXRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlzIG51bGxcIik7aWYoXCJcIj09dHx8XCJcIj09dC50cmltKCkpdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgZW1wdHkgb3Igd2hpdGUgc3BhY2UuXCIpO2xldCBpPXRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKHQpO2lmKG51bGw9PWkpdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gZG9lc24ndCBleGlzdDogJ1wiK3QrXCInXCIpO2xldCByPVtdO3IucHVzaC5hcHBseShyLHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtKSx0aGlzLl9zdGF0ZS5SZXNldE91dHB1dCgpLHRoaXMuc3RhdGUuU3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZShpLGUpO2xldCBhPW5ldyBtO2Zvcig7dGhpcy5jYW5Db250aW51ZTspYS5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtsZXQgcz1hLnRvU3RyaW5nKCk7dGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQocik7bGV0IGw9dGhpcy5zdGF0ZS5Db21wbGV0ZUZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCk7cmV0dXJuIG4/e3JldHVybmVkOmwsb3V0cHV0OnN9Omx9RXZhbHVhdGVFeHByZXNzaW9uKHQpe2xldCBlPXRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aDt0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKHIuVHVubmVsKSx0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyPXQsdGhpcy5zdGF0ZS5Hb1RvU3RhcnQoKTtsZXQgbj10aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg7cmV0dXJuIHRoaXMuQ29udGludWUoKSx0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyPW51bGwsdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoPmUmJnRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKCksdGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoPm4/dGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTpudWxsfUNhbGxFeHRlcm5hbEZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIGQoXCJmdW5jTmFtZVwiKTtsZXQgbj10aGlzLl9leHRlcm5hbHMuZ2V0KHQpLGk9bnVsbDtpZighKHZvaWQgMCE9PW4pKXtpZih0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcylyZXR1cm4gaT10aGlzLktub3RDb250YWluZXJXaXRoTmFtZSh0KSx0aGlzLkFzc2VydChudWxsIT09aSxcIlRyeWluZyB0byBjYWxsIEVYVEVSTkFMIGZ1bmN0aW9uICdcIit0K1wiJyB3aGljaCBoYXMgbm90IGJlZW4gYm91bmQsIGFuZCBmYWxsYmFjayBpbmsgZnVuY3Rpb24gY291bGQgbm90IGJlIGZvdW5kLlwiKSx0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKHIuRnVuY3Rpb24sdm9pZCAwLHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCksdm9pZCh0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlcj1JLlN0YXJ0T2YoaSkpO3RoaXMuQXNzZXJ0KCExLFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiK3QrXCInIHdoaWNoIGhhcyBub3QgYmVlbiBib3VuZCAoYW5kIGluayBmYWxsYmFja3MgZGlzYWJsZWQpLlwiKX1sZXQgYT1bXTtmb3IobGV0IHQ9MDt0PGU7Kyt0KXtsZXQgdD1zKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksdikudmFsdWVPYmplY3Q7YS5wdXNoKHQpfWEucmV2ZXJzZSgpO2xldCBsPW4oYSksbz1udWxsO251bGwhPWw/KG89di5DcmVhdGUobCksdGhpcy5Bc3NlcnQobnVsbCE9PW8sXCJDb3VsZCBub3QgY3JlYXRlIGluayB2YWx1ZSBmcm9tIHJldHVybmVkIG9iamVjdCBvZiB0eXBlIFwiK3R5cGVvZiBsKSk6bz1uZXcgTCx0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobyl9QmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKHQsZSl7dGhpcy5JZkFzeW5jV2VDYW50KFwiYmluZCBhbiBleHRlcm5hbCBmdW5jdGlvblwiKSx0aGlzLkFzc2VydCghdGhpcy5fZXh0ZXJuYWxzLmhhcyh0KSxcIkZ1bmN0aW9uICdcIit0K1wiJyBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlwiKSx0aGlzLl9leHRlcm5hbHMuc2V0KHQsZSl9VHJ5Q29lcmNlKHQpe3JldHVybiB0fUJpbmRFeHRlcm5hbEZ1bmN0aW9uKHQsZSl7dGhpcy5Bc3NlcnQobnVsbCE9ZSxcIkNhbid0IGJpbmQgYSBudWxsIGZ1bmN0aW9uXCIpLHRoaXMuQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKHQsdD0+e3RoaXMuQXNzZXJ0KHQubGVuZ3RoPj1lLmxlbmd0aCxcIkV4dGVybmFsIGZ1bmN0aW9uIGV4cGVjdGVkIFwiK2UubGVuZ3RoK1wiIGFyZ3VtZW50c1wiKTtsZXQgbj1bXTtmb3IobGV0IGU9MCxpPXQubGVuZ3RoO2U8aTtlKyspbltlXT10aGlzLlRyeUNvZXJjZSh0W2VdKTtyZXR1cm4gZS5hcHBseShudWxsLG4pfSl9VW5iaW5kRXh0ZXJuYWxGdW5jdGlvbih0KXt0aGlzLklmQXN5bmNXZUNhbnQoXCJ1bmJpbmQgYW4gZXh0ZXJuYWwgYSBmdW5jdGlvblwiKSx0aGlzLkFzc2VydCh0aGlzLl9leHRlcm5hbHMuaGFzKHQpLFwiRnVuY3Rpb24gJ1wiK3QrXCInIGhhcyBub3QgYmVlbiBib3VuZC5cIiksdGhpcy5fZXh0ZXJuYWxzLmRlbGV0ZSh0KX1WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKXtsZXQgdD1udWxsLGU9bnVsbCxuPWFyZ3VtZW50c1sxXXx8bmV3IFNldDtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE4mJih0PWFyZ3VtZW50c1swXSksYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwJiYoZT1hcmd1bWVudHNbMF0pLG51bGw9PT10JiZudWxsPT09ZSlpZih0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyh0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcixuKSx0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHM9ITAsMD09bi5zaXplKXRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscz0hMDtlbHNle2xldCB0PVwiRXJyb3I6IE1pc3NpbmcgZnVuY3Rpb24gYmluZGluZyBmb3IgZXh0ZXJuYWxcIjt0Kz1uLnNpemU+MT9cInNcIjpcIlwiLHQrPVwiOiAnXCIsdCs9QXJyYXkuZnJvbShuKS5qb2luKFwiJywgJ1wiKSx0Kz1cIicgXCIsdCs9dGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3M/XCIsIGFuZCBubyBmYWxsYmFjayBpbmsgZnVuY3Rpb24gZm91bmQuXCI6XCIgKGluayBmYWxsYmFja3MgZGlzYWJsZWQpXCIsdGhpcy5FcnJvcih0KX1lbHNlIGlmKG51bGwhPXQpe2ZvcihsZXQgZSBvZiB0LmNvbnRlbnQpe2xldCB0PWU7bnVsbCE9dCYmdC5oYXNWYWxpZE5hbWV8fHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKGUsbil9Zm9yKGxldFssZV1vZiB0Lm5hbWVkQ29udGVudCl0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyhhKGUscCksbil9ZWxzZSBpZihudWxsIT1lKXtsZXQgdD1hKGUsayk7aWYodCYmdC5pc0V4dGVybmFsKXtsZXQgZT10LnRhcmdldFBhdGhTdHJpbmc7aWYobnVsbD09PWUpcmV0dXJuIGQoXCJuYW1lXCIpO2lmKCF0aGlzLl9leHRlcm5hbHMuaGFzKGUpKWlmKHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzKXt0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5oYXMoZSl8fG4uYWRkKGUpfWVsc2Ugbi5hZGQoZSl9fX1PYnNlcnZlVmFyaWFibGUodCxlKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJvYnNlcnZlIGEgbmV3IHZhcmlhYmxlXCIpLG51bGw9PT10aGlzLl92YXJpYWJsZU9ic2VydmVycyYmKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzPW5ldyBNYXApLCF0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodCkpdGhyb3cgbmV3IFMoXCJDYW5ub3Qgb2JzZXJ2ZSB2YXJpYWJsZSAnXCIrdCtcIicgYmVjYXVzZSBpdCB3YXNuJ3QgZGVjbGFyZWQgaW4gdGhlIGluayBzdG9yeS5cIik7dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuaGFzKHQpP3RoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh0KS5wdXNoKGUpOnRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLnNldCh0LFtlXSl9T2JzZXJ2ZVZhcmlhYmxlcyh0LGUpe2ZvcihsZXQgbj0wLGk9dC5sZW5ndGg7bjxpO24rKyl0aGlzLk9ic2VydmVWYXJpYWJsZSh0W25dLGVbbl0pfVJlbW92ZVZhcmlhYmxlT2JzZXJ2ZXIodCxlKXtpZih0aGlzLklmQXN5bmNXZUNhbnQoXCJyZW1vdmUgYSB2YXJpYWJsZSBvYnNlcnZlclwiKSxudWxsIT09dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMpaWYodm9pZCAwIT09ZSl7aWYodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuaGFzKGUpKXtsZXQgbj10aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQoZSk7bnVsbCE9PXQ/bi5zcGxpY2Uobi5pbmRleE9mKHQpLDEpOnRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmRlbGV0ZShlKX19ZWxzZSBpZihudWxsIT09dCl7bGV0IGU9dGhpcy5fdmFyaWFibGVPYnNlcnZlcnMua2V5cygpO2ZvcihsZXQgbiBvZiBlKXtsZXQgZT10aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQobik7ZS5zcGxpY2UoZS5pbmRleE9mKHQpLDEpfX19VmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50KHQsZSl7aWYobnVsbD09PXRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzKXJldHVybjtsZXQgbj10aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodCk7aWYodm9pZCAwIT09bil7aWYoIShlIGluc3RhbmNlb2YgdikpdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZ2V0IHRoZSB2YWx1ZSBvZiBhIHZhcmlhYmxlIHRoYXQgaXNuJ3QgYSBzdGFuZGFyZCB0eXBlXCIpO2xldCBpPXMoZSx2KTtmb3IobGV0IGUgb2YgbillKHQsaS52YWx1ZU9iamVjdCl9fWdldCBnbG9iYWxUYWdzKCl7cmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhcIlwiKX1UYWdzRm9yQ29udGVudEF0UGF0aCh0KXtyZXR1cm4gdGhpcy5UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKHQpfVRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcodCl7bGV0IG49bmV3IGUodCksaT10aGlzLkNvbnRlbnRBdFBhdGgobikuY29udGFpbmVyO2lmKG51bGw9PT1pKXJldHVybiBkKFwiZmxvd0NvbnRhaW5lclwiKTtmb3IoOzspe2xldCB0PWkuY29udGVudFswXTtpZighKHQgaW5zdGFuY2VvZiBOKSlicmVhaztpPXR9bGV0IHI9bnVsbDtmb3IobGV0IHQgb2YgaS5jb250ZW50KXtsZXQgZT1hKHQsaik7aWYoIWUpYnJlYWs7bnVsbD09ciYmKHI9W10pLHIucHVzaChlLnRleHQpfXJldHVybiByfUJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoKXtsZXQgdD1uZXcgbTtyZXR1cm4gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHQsMCx0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLlJlc29sdmUoKSksdC50b1N0cmluZygpfUJ1aWxkU3RyaW5nT2ZDb250YWluZXIodCl7bGV0IGU9bmV3IG07cmV0dXJuIHQuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShlLDAsdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpLGUudG9TdHJpbmcoKX1OZXh0Q29udGVudCgpe2lmKHRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyPXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpLCF0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlci5pc051bGwmJih0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyPXRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmNvcHkoKSx0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlcj1JLk51bGwsdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKSwhdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpKXJldHVybjtpZighdGhpcy5JbmNyZW1lbnRDb250ZW50UG9pbnRlcigpKXtsZXQgdD0hMTt0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3Aoci5GdW5jdGlvbik/KHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKHIuRnVuY3Rpb24pLHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiYmdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBMKSx0PSEwKTp0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQ/KHRoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpLHQ9ITApOnRoaXMuc3RhdGUuVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCksdCYmIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsJiZ0aGlzLk5leHRDb250ZW50KCl9fUluY3JlbWVudENvbnRlbnRQb2ludGVyKCl7bGV0IHQ9ITAsZT10aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb3B5KCk7aWYoZS5pbmRleCsrLG51bGw9PT1lLmNvbnRhaW5lcilyZXR1cm4gZChcInBvaW50ZXIuY29udGFpbmVyXCIpO2Zvcig7ZS5pbmRleD49ZS5jb250YWluZXIuY29udGVudC5sZW5ndGg7KXt0PSExO2xldCBuPWEoZS5jb250YWluZXIucGFyZW50LE4pO2lmKG4gaW5zdGFuY2VvZiBOPT0hMSlicmVhaztsZXQgaT1uLmNvbnRlbnQuaW5kZXhPZihlLmNvbnRhaW5lcik7aWYoLTE9PWkpYnJlYWs7aWYoZT1uZXcgSShuLGkpLGUuaW5kZXgrKyx0PSEwLG51bGw9PT1lLmNvbnRhaW5lcilyZXR1cm4gZChcInBvaW50ZXIuY29udGFpbmVyXCIpfXJldHVybiB0fHwoZT1JLk51bGwpLHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyPWUuY29weSgpLHR9VHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpe2xldCB0PXRoaXMuX3N0YXRlLmN1cnJlbnRDaG9pY2VzLGU9dC5maWx0ZXIodD0+dC5pc0ludmlzaWJsZURlZmF1bHQpO2lmKDA9PWUubGVuZ3RofHx0Lmxlbmd0aD5lLmxlbmd0aClyZXR1cm4hMTtsZXQgbj1lWzBdO3JldHVybiBudWxsPT09bi50YXJnZXRQYXRoP2QoXCJjaG9pY2UudGFyZ2V0UGF0aFwiKTpudWxsPT09bi50aHJlYWRBdEdlbmVyYXRpb24/ZChcImNob2ljZS50aHJlYWRBdEdlbmVyYXRpb25cIik6KHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQ9bi50aHJlYWRBdEdlbmVyYXRpb24sdGhpcy5DaG9vc2VQYXRoKG4udGFyZ2V0UGF0aCwhMSksITApfU5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpe2xldCB0PWEodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKTtpZighKHQgaW5zdGFuY2VvZiBiKSlyZXR1cm4gdGhpcy5FcnJvcihcImV4cGVjdGVkIG51bWJlciBvZiBlbGVtZW50cyBpbiBzZXF1ZW5jZSBmb3Igc2h1ZmZsZSBpbmRleFwiKSwwO2xldCBlPXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyO2lmKG51bGw9PT1lKXJldHVybiBkKFwic2VxQ29udGFpbmVyXCIpO2lmKG51bGw9PT10LnZhbHVlKXJldHVybiBkKFwibnVtRWxlbWVudHNJbnRWYWwudmFsdWVcIik7bGV0IG49dC52YWx1ZSxpPXModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSxiKS52YWx1ZTtpZihudWxsPT09aSlyZXR1cm4gZChcInNlcUNvdW50XCIpO2xldCByPWkvbixsPWklbixvPWUucGF0aC50b1N0cmluZygpLHU9MDtmb3IobGV0IHQ9MCxlPW8ubGVuZ3RoO3Q8ZTt0KyspdSs9by5jaGFyQ29kZUF0KHQpfHwwO2xldCBoPXUrcit0aGlzLnN0YXRlLnN0b3J5U2VlZCxjPW5ldyBLKE1hdGguZmxvb3IoaCkpLHA9W107Zm9yKGxldCB0PTA7dDxuOysrdClwLnB1c2godCk7Zm9yKGxldCB0PTA7dDw9bDsrK3Qpe2xldCBlPWMubmV4dCgpJXAubGVuZ3RoLG49cFtlXTtpZihwLnNwbGljZShlLDEpLHQ9PWwpcmV0dXJuIG59dGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIil9RXJyb3IodCxlPSExKXtsZXQgbj1uZXcgUyh0KTt0aHJvdyBuLnVzZUVuZExpbmVOdW1iZXI9ZSxufVdhcm5pbmcodCl7dGhpcy5BZGRFcnJvcih0LCEwKX1BZGRFcnJvcih0LGU9ITEsbj0hMSl7bGV0IGk9dGhpcy5jdXJyZW50RGVidWdNZXRhZGF0YSxyPWU/XCJXQVJOSU5HXCI6XCJFUlJPUlwiO2lmKG51bGwhPWkpe2xldCBlPW4/aS5lbmRMaW5lTnVtYmVyOmkuc3RhcnRMaW5lTnVtYmVyO3Q9XCJSVU5USU1FIFwiK3IrXCI6ICdcIitpLmZpbGVOYW1lK1wiJyBsaW5lIFwiK2UrXCI6IFwiK3R9ZWxzZSB0PXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsP1wiUlVOVElNRSBcIityK1wiOiBcIit0OlwiUlVOVElNRSBcIityK1wiOiAoXCIrdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcitcIik6IFwiK3Q7dGhpcy5zdGF0ZS5BZGRFcnJvcih0LGUpLGV8fHRoaXMuc3RhdGUuRm9yY2VFbmQoKX1Bc3NlcnQodCxlPW51bGwpe2lmKDA9PXQpdGhyb3cgbnVsbD09ZSYmKGU9XCJTdG9yeSBhc3NlcnRcIiksbmV3IEVycm9yKGUrXCIgXCIrdGhpcy5jdXJyZW50RGVidWdNZXRhZGF0YSl9Z2V0IGN1cnJlbnREZWJ1Z01ldGFkYXRhKCl7bGV0IHQsZT10aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyO2lmKCFlLmlzTnVsbCYmbnVsbCE9PWUuUmVzb2x2ZSgpJiYodD1lLlJlc29sdmUoKS5kZWJ1Z01ldGFkYXRhLG51bGwhPT10KSlyZXR1cm4gdDtmb3IobGV0IG49dGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoLTE7bj49MDstLW4paWYoZT10aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50c1tuXS5jdXJyZW50UG9pbnRlciwhZS5pc051bGwmJm51bGwhPT1lLlJlc29sdmUoKSYmKHQ9ZS5SZXNvbHZlKCkuZGVidWdNZXRhZGF0YSxudWxsIT09dCkpcmV0dXJuIHQ7Zm9yKGxldCBlPXRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aC0xO2U+PTA7LS1lKXtpZih0PXRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW2VdLmRlYnVnTWV0YWRhdGEsbnVsbCE9PXQpcmV0dXJuIHR9cmV0dXJuIG51bGx9Z2V0IG1haW5Db250ZW50Q29udGFpbmVyKCl7cmV0dXJuIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI/dGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcjp0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcn19WC5pbmtWZXJzaW9uQ3VycmVudD0xOSxmdW5jdGlvbih0KXtsZXQgZTshZnVuY3Rpb24odCl7dFt0Lk5vQ2hhbmdlPTBdPVwiTm9DaGFuZ2VcIix0W3QuRXh0ZW5kZWRCZXlvbmROZXdsaW5lPTFdPVwiRXh0ZW5kZWRCZXlvbmROZXdsaW5lXCIsdFt0Lk5ld2xpbmVSZW1vdmVkPTJdPVwiTmV3bGluZVJlbW92ZWRcIn0oZT10Lk91dHB1dFN0YXRlQ2hhbmdlfHwodC5PdXRwdXRTdGF0ZUNoYW5nZT17fSkpfShYfHwoWD17fSkpLHQuSW5rTGlzdD1nLHQuU3Rvcnk9WCxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluay1lczIwMTUuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbFN0YWNrID0gdm9pZCAwO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBTdG9yeV8xID0gcmVxdWlyZShcIi4vU3RvcnlcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgUG9pbnRlcl8xID0gcmVxdWlyZShcIi4vUG9pbnRlclwiKTtcbmNvbnN0IERlYnVnXzEgPSByZXF1aXJlKFwiLi9EZWJ1Z1wiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIENhbGxTdGFjayB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTdG9yeV8xLlN0b3J5KSB7XG4gICAgICAgICAgICBsZXQgc3RvcnlDb250ZXh0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHN0b3J5Q29udGV4dC5yb290Q29udGVudENvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLlJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgdG9Db3B5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5fdGhyZWFkcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgb3RoZXJUaHJlYWQgb2YgdG9Db3B5Ll90aHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKG90aGVyVGhyZWFkLkNvcHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyID0gdG9Db3B5Ll90aHJlYWRDb3VudGVyO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRPZlJvb3QgPSB0b0NvcHkuX3N0YXJ0T2ZSb290O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbGVtZW50KCkge1xuICAgICAgICBsZXQgdGhyZWFkID0gdGhpcy5fdGhyZWFkc1t0aGlzLl90aHJlYWRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBsZXQgY3MgPSB0aHJlYWQuY2FsbHN0YWNrO1xuICAgICAgICByZXR1cm4gY3NbY3MubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGdldCBjdXJyZW50RWxlbWVudEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2subGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aHJlYWRzW3RoaXMuX3RocmVhZHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHNldCBjdXJyZW50VGhyZWFkKHZhbHVlKSB7XG4gICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHRoaXMuX3RocmVhZHMubGVuZ3RoID09IDEsIFwiU2hvdWxkbid0IGJlIGRpcmVjdGx5IHNldHRpbmcgdGhlIGN1cnJlbnQgdGhyZWFkIHdoZW4gd2UgaGF2ZSBhIHN0YWNrIG9mIHRoZW1cIik7XG4gICAgICAgIHRoaXMuX3RocmVhZHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGNhblBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmxlbmd0aCA+IDE7XG4gICAgfVxuICAgIFJlc2V0KCkge1xuICAgICAgICB0aGlzLl90aHJlYWRzID0gW107XG4gICAgICAgIHRoaXMuX3RocmVhZHMucHVzaChuZXcgQ2FsbFN0YWNrLlRocmVhZCgpKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkc1swXS5jYWxsc3RhY2sucHVzaChuZXcgQ2FsbFN0YWNrLkVsZW1lbnQoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCwgdGhpcy5fc3RhcnRPZlJvb3QpKTtcbiAgICB9XG4gICAgU2V0SnNvblRva2VuKGpPYmplY3QsIHN0b3J5Q29udGV4dCkge1xuICAgICAgICB0aGlzLl90aHJlYWRzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIFRPRE86IChMaXN0PG9iamVjdD4pIGpPYmplY3QgW1widGhyZWFkc1wiXTtcbiAgICAgICAgbGV0IGpUaHJlYWRzID0gak9iamVjdFtcInRocmVhZHNcIl07XG4gICAgICAgIGZvciAobGV0IGpUaHJlYWRUb2sgb2YgalRocmVhZHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHZhciBqVGhyZWFkT2JqID0gKERpY3Rpb25hcnk8c3RyaW5nLCBvYmplY3Q+KWpUaHJlYWRUb2s7XG4gICAgICAgICAgICBsZXQgalRocmVhZE9iaiA9IGpUaHJlYWRUb2s7XG4gICAgICAgICAgICBsZXQgdGhyZWFkID0gbmV3IENhbGxTdGFjay5UaHJlYWQoalRocmVhZE9iaiwgc3RvcnlDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuX3RocmVhZHMucHVzaCh0aHJlYWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IChpbnQpak9iamVjdCBbXCJ0aHJlYWRDb3VudGVyXCJdO1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyID0gcGFyc2VJbnQoak9iamVjdFtcInRocmVhZENvdW50ZXJcIl0pO1xuICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2Yoc3RvcnlDb250ZXh0LnJvb3RDb250ZW50Q29udGFpbmVyKTtcbiAgICB9XG4gICAgV3JpdGVKc29uKHcpIHtcbiAgICAgICAgdy5Xcml0ZU9iamVjdCgod3JpdGVyKSA9PiB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGhyZWFkc1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHRocmVhZCBvZiB0aGlzLl90aHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgdGhyZWFkLldyaXRlSnNvbih3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGhyZWFkQ291bnRlclwiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludCh0aGlzLl90aHJlYWRDb3VudGVyKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBQdXNoVGhyZWFkKCkge1xuICAgICAgICBsZXQgbmV3VGhyZWFkID0gdGhpcy5jdXJyZW50VGhyZWFkLkNvcHkoKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlcisrO1xuICAgICAgICBuZXdUaHJlYWQudGhyZWFkSW5kZXggPSB0aGlzLl90aHJlYWRDb3VudGVyO1xuICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2gobmV3VGhyZWFkKTtcbiAgICB9XG4gICAgRm9ya1RocmVhZCgpIHtcbiAgICAgICAgbGV0IGZvcmtlZFRocmVhZCA9IHRoaXMuY3VycmVudFRocmVhZC5Db3B5KCk7XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIrKztcbiAgICAgICAgZm9ya2VkVGhyZWFkLnRocmVhZEluZGV4ID0gdGhpcy5fdGhyZWFkQ291bnRlcjtcbiAgICAgICAgcmV0dXJuIGZvcmtlZFRocmVhZDtcbiAgICB9XG4gICAgUG9wVGhyZWFkKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Qb3BUaHJlYWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RocmVhZHMuc3BsaWNlKHRoaXMuX3RocmVhZHMuaW5kZXhPZih0aGlzLmN1cnJlbnRUaHJlYWQpLCAxKTsgLy8gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gYSBwb3AoKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcG9wIHRocmVhZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FuUG9wVGhyZWFkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyZWFkcy5sZW5ndGggPiAxICYmICF0aGlzLmVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZTtcbiAgICB9XG4gICAgUHVzaCh0eXBlLCBleHRlcm5hbEV2YWx1YXRpb25TdGFja0hlaWdodCA9IDAsIG91dHB1dFN0cmVhbUxlbmd0aFdpdGhQdXNoZWQgPSAwKSB7XG4gICAgICAgIGxldCBlbGVtZW50ID0gbmV3IENhbGxTdGFjay5FbGVtZW50KHR5cGUsIHRoaXMuY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIsIGZhbHNlKTtcbiAgICAgICAgZWxlbWVudC5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkID0gZXh0ZXJuYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQ7XG4gICAgICAgIGVsZW1lbnQuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtID0gb3V0cHV0U3RyZWFtTGVuZ3RoV2l0aFB1c2hlZDtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2sucHVzaChlbGVtZW50KTtcbiAgICB9XG4gICAgQ2FuUG9wKHR5cGUgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5Qb3ApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVsZW1lbnQudHlwZSA9PSB0eXBlO1xuICAgIH1cbiAgICBQb3AodHlwZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuQ2FuUG9wKHR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc21hdGNoZWQgcHVzaC9wb3AgaW4gQ2FsbHN0YWNrXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdldFRlbXBvcmFyeVZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4ID0gLTEpIHtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IHRoaXMuY3VycmVudEVsZW1lbnRJbmRleCArIDE7XG4gICAgICAgIGxldCBjb250ZXh0RWxlbWVudCA9IHRoaXMuY2FsbFN0YWNrW2NvbnRleHRJbmRleCAtIDFdO1xuICAgICAgICBsZXQgdmFyVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAoY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgaWYgKHZhclZhbHVlLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIHZhclZhbHVlLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNldFRlbXBvcmFyeVZhcmlhYmxlKG5hbWUsIHZhbHVlLCBkZWNsYXJlTmV3LCBjb250ZXh0SW5kZXggPSAtMSkge1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IC0xKVxuICAgICAgICAgICAgY29udGV4dEluZGV4ID0gdGhpcy5jdXJyZW50RWxlbWVudEluZGV4ICsgMTtcbiAgICAgICAgbGV0IGNvbnRleHRFbGVtZW50ID0gdGhpcy5jYWxsU3RhY2tbY29udGV4dEluZGV4IC0gMV07XG4gICAgICAgIGlmICghZGVjbGFyZU5ldyAmJiAhY29udGV4dEVsZW1lbnQudGVtcG9yYXJ5VmFyaWFibGVzLmdldChuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDb3VsZCBub3QgZmluZCB0ZW1wb3JhcnkgdmFyaWFibGUgdG8gc2V0OiBcIiArIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcChjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICBpZiAob2xkVmFsdWUuZXhpc3RzKVxuICAgICAgICAgICAgVmFsdWVfMS5MaXN0VmFsdWUuUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLnJlc3VsdCwgdmFsdWUpO1xuICAgICAgICBjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgQ29udGV4dEZvclZhcmlhYmxlTmFtZWQobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRocmVhZFdpdGhJbmRleChpbmRleCkge1xuICAgICAgICBsZXQgZmlsdGVyZWQgPSB0aGlzLl90aHJlYWRzLmZpbHRlcigodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQudGhyZWFkSW5kZXggPT0gaW5kZXgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmlsdGVyZWQubGVuZ3RoID4gMCA/IGZpbHRlcmVkWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGNhbGxTdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRocmVhZC5jYWxsc3RhY2s7XG4gICAgfVxuICAgIGdldCBjYWxsU3RhY2tUcmFjZSgpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5fdGhyZWFkcy5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgbGV0IHRocmVhZCA9IHRoaXMuX3RocmVhZHNbdF07XG4gICAgICAgICAgICBsZXQgaXNDdXJyZW50ID0gdCA9PSB0aGlzLl90aHJlYWRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBzYi5BcHBlbmRGb3JtYXQoXCI9PT0gVEhSRUFEIHswfS97MX0gezJ9PT09XFxuXCIsIHQgKyAxLCB0aGlzLl90aHJlYWRzLmxlbmd0aCwgaXNDdXJyZW50ID8gXCIoY3VycmVudCkgXCIgOiBcIlwiKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhyZWFkLmNhbGxzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aHJlYWQuY2FsbHN0YWNrW2ldLnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgIFtGVU5DVElPTl0gXCIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiICBbVFVOTkVMXSBcIik7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSB0aHJlYWQuY2FsbHN0YWNrW2ldLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICAgICAgICAgIGlmICghcG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiPFNPTUVXSEVSRSBJTiBcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQocG9pbnRlci5jb250YWluZXIucGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kTGluZShcIj5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbFN0YWNrID0gQ2FsbFN0YWNrO1xuKGZ1bmN0aW9uIChDYWxsU3RhY2spIHtcbiAgICBjbGFzcyBFbGVtZW50IHtcbiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgcG9pbnRlciwgaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0gPSAwO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IHBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gaW5FeHByZXNzaW9uRXZhbHVhdGlvbjtcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5VmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICBDb3B5KCkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgRWxlbWVudCh0aGlzLnR5cGUsIHRoaXMuY3VycmVudFBvaW50ZXIsIHRoaXMuaW5FeHByZXNzaW9uRXZhbHVhdGlvbik7XG4gICAgICAgICAgICBjb3B5LnRlbXBvcmFyeVZhcmlhYmxlcyA9IG5ldyBNYXAodGhpcy50ZW1wb3JhcnlWYXJpYWJsZXMpO1xuICAgICAgICAgICAgY29weS5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkID0gdGhpcy5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkO1xuICAgICAgICAgICAgY29weS5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0gPSB0aGlzLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxTdGFjay5FbGVtZW50ID0gRWxlbWVudDtcbiAgICBjbGFzcyBUaHJlYWQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMudGhyZWFkSW5kZXggPSAwO1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c1BvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgdGhpcy5jYWxsc3RhY2sgPSBbXTtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gJiYgYXJndW1lbnRzWzFdKSB7XG4gICAgICAgICAgICAgICAgbGV0IGpUaHJlYWRPYmogPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgbGV0IHN0b3J5Q29udGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiAoaW50KSBqVGhyZWFkT2JqWyd0aHJlYWRJbmRleCddIGNhbiByYWlzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRocmVhZEluZGV4ID0gcGFyc2VJbnQoalRocmVhZE9ialtcInRocmVhZEluZGV4XCJdKTtcbiAgICAgICAgICAgICAgICBsZXQgalRocmVhZENhbGxzdGFjayA9IGpUaHJlYWRPYmpbXCJjYWxsc3RhY2tcIl07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgakVsVG9rIG9mIGpUaHJlYWRDYWxsc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGpFbGVtZW50T2JqID0gakVsVG9rO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiAoaW50KSBqRWxlbWVudE9ialsndHlwZSddIGNhbiByYWlzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHB1c2hQb3BUeXBlID0gcGFyc2VJbnQoakVsZW1lbnRPYmpbXCJ0eXBlXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lclBhdGhTdHI7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGpFbGVtZW50T2JqLlRyeUdldFZhbHVlIChcImNQYXRoXCIsIG91dCBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4gPSBqRWxlbWVudE9ialtcImNQYXRoXCJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJQYXRoU3RyID0gY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbi50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRocmVhZFBvaW50ZXJSZXN1bHQgPSBzdG9yeUNvbnRleHQuQ29udGVudEF0UGF0aChuZXcgUGF0aF8xLlBhdGgoY3VycmVudENvbnRhaW5lclBhdGhTdHIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuY29udGFpbmVyID0gdGhyZWFkUG9pbnRlclJlc3VsdC5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmluZGV4ID0gcGFyc2VJbnQoakVsZW1lbnRPYmpbXCJpZHhcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRocmVhZFBvaW50ZXJSZXN1bHQub2JqID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2hlbiBsb2FkaW5nIHN0YXRlLCBpbnRlcm5hbCBzdG9yeSBsb2NhdGlvbiBjb3VsZG4ndCBiZSBmb3VuZDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyUGF0aFN0ciArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLiBIYXMgdGhlIHN0b3J5IGNoYW5nZWQgc2luY2UgdGhpcyBzYXZlIGRhdGEgd2FzIGNyZWF0ZWQ/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhyZWFkUG9pbnRlclJlc3VsdC5hcHByb3hpbWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yeUNvbnRleHQuV2FybmluZyhcIldoZW4gbG9hZGluZyBzdGF0ZSwgZXhhY3QgaW50ZXJuYWwgc3RvcnkgbG9jYXRpb24gY291bGRuJ3QgYmUgZm91bmQ6ICdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJQYXRoU3RyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInLCBzbyBpdCB3YXMgYXBwcm94aW1hdGVkIHRvICdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiJyB0byByZWNvdmVyLiBIYXMgdGhlIHN0b3J5IGNoYW5nZWQgc2luY2UgdGhpcyBzYXZlIGRhdGEgd2FzIGNyZWF0ZWQ/XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gISFqRWxlbWVudE9ialtcImV4cFwiXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVsID0gbmV3IEVsZW1lbnQocHVzaFBvcFR5cGUsIHBvaW50ZXIsIGluRXhwcmVzc2lvbkV2YWx1YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcHMgPSBqRWxlbWVudE9ialtcInRlbXBcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnRlbXBvcmFyeVZhcmlhYmxlcyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSk9iamVjdFRvRGljdGlvbmFyeVJ1bnRpbWVPYmpzKHRlbXBzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLnRlbXBvcmFyeVZhcmlhYmxlcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbHN0YWNrLnB1c2goZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcHJldkNvbnRlbnRPYmpQYXRoID0galRocmVhZE9ialtcInByZXZpb3VzQ29udGVudE9iamVjdFwiXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByZXZDb250ZW50T2JqUGF0aCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldlBhdGggPSBuZXcgUGF0aF8xLlBhdGgocHJldkNvbnRlbnRPYmpQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnRlciA9IHN0b3J5Q29udGV4dC5Qb2ludGVyQXRQYXRoKHByZXZQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQ29weSgpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IFRocmVhZCgpO1xuICAgICAgICAgICAgY29weS50aHJlYWRJbmRleCA9IHRoaXMudGhyZWFkSW5kZXg7XG4gICAgICAgICAgICBmb3IgKGxldCBlIG9mIHRoaXMuY2FsbHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgY29weS5jYWxsc3RhY2sucHVzaChlLkNvcHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5LnByZXZpb3VzUG9pbnRlciA9IHRoaXMucHJldmlvdXNQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlSnNvbih3cml0ZXIpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwiY2FsbHN0YWNrXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZWwgb2YgdGhpcy5jYWxsc3RhY2spIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgICAgIGlmICghZWwuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZWwuY3VycmVudFBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY1BhdGhcIiwgZWwuY3VycmVudFBvaW50ZXIuY29udGFpbmVyLnBhdGguY29tcG9uZW50c1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaWR4XCIsIGVsLmN1cnJlbnRQb2ludGVyLmluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJleHBcIiwgZWwuaW5FeHByZXNzaW9uRXZhbHVhdGlvbik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJ0eXBlXCIsIGVsLnR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbC50ZW1wb3JhcnlWYXJpYWJsZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcInRlbXBcIik7XG4gICAgICAgICAgICAgICAgICAgIEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVEaWN0aW9uYXJ5UnVudGltZU9ianMod3JpdGVyLCBlbC50ZW1wb3JhcnlWYXJpYWJsZXMpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJ0aHJlYWRJbmRleFwiLCB0aGlzLnRocmVhZEluZGV4KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmV2aW91c1BvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc29sdmVkUG9pbnRlciA9IHRoaXMucHJldmlvdXNQb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQb2ludGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5wcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInByZXZpb3VzQ29udGVudE9iamVjdFwiLCByZXNvbHZlZFBvaW50ZXIucGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxTdGFjay5UaHJlYWQgPSBUaHJlYWQ7XG59KShDYWxsU3RhY2sgPSBleHBvcnRzLkNhbGxTdGFjayB8fCAoZXhwb3J0cy5DYWxsU3RhY2sgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FsbFN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaG9pY2UgPSB2b2lkIDA7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgQ2hvaWNlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMudGhyZWFkQXRHZW5lcmF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3VyY2VQYXRoID0gXCJcIjtcbiAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0ludmlzaWJsZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFRocmVhZEluZGV4ID0gMDtcbiAgICB9XG4gICAgZ2V0IHBhdGhTdHJpbmdPbkNob2ljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiQ2hvaWNlLnRhcmdldFBhdGhcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldFBhdGgudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgc2V0IHBhdGhTdHJpbmdPbkNob2ljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBuZXcgUGF0aF8xLlBhdGgodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hvaWNlID0gQ2hvaWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hvaWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaG9pY2VQb2ludCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBDaG9pY2VQb2ludCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3Iob25jZU9ubHkgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3BhdGhPbkNob2ljZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzU3RhcnRDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0ludmlzaWJsZURlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbmNlT25seSA9IHRydWU7XG4gICAgICAgIHRoaXMub25jZU9ubHkgPSBvbmNlT25seTtcbiAgICB9XG4gICAgZ2V0IHBhdGhPbkNob2ljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhPbkNob2ljZSAhPSBudWxsICYmIHRoaXMuX3BhdGhPbkNob2ljZS5pc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICBsZXQgY2hvaWNlVGFyZ2V0T2JqID0gdGhpcy5jaG9pY2VUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoY2hvaWNlVGFyZ2V0T2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aE9uQ2hvaWNlID0gY2hvaWNlVGFyZ2V0T2JqLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGhPbkNob2ljZTtcbiAgICB9XG4gICAgc2V0IHBhdGhPbkNob2ljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wYXRoT25DaG9pY2UgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNob2ljZVRhcmdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhPbkNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiQ2hvaWNlUG9pbnQuX3BhdGhPbkNob2ljZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuUmVzb2x2ZVBhdGgodGhpcy5fcGF0aE9uQ2hvaWNlKS5jb250YWluZXI7XG4gICAgfVxuICAgIGdldCBwYXRoU3RyaW5nT25DaG9pY2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhPbkNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiQ2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnBhdGhPbkNob2ljZSk7XG4gICAgfVxuICAgIHNldCBwYXRoU3RyaW5nT25DaG9pY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYXRoT25DaG9pY2UgPSBuZXcgUGF0aF8xLlBhdGgodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgZmxhZ3MoKSB7XG4gICAgICAgIGxldCBmbGFncyA9IDA7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbmRpdGlvbilcbiAgICAgICAgICAgIGZsYWdzIHw9IDE7XG4gICAgICAgIGlmICh0aGlzLmhhc1N0YXJ0Q29udGVudClcbiAgICAgICAgICAgIGZsYWdzIHw9IDI7XG4gICAgICAgIGlmICh0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50KVxuICAgICAgICAgICAgZmxhZ3MgfD0gNDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnZpc2libGVEZWZhdWx0KVxuICAgICAgICAgICAgZmxhZ3MgfD0gODtcbiAgICAgICAgaWYgKHRoaXMub25jZU9ubHkpXG4gICAgICAgICAgICBmbGFncyB8PSAxNjtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgIH1cbiAgICBzZXQgZmxhZ3ModmFsdWUpIHtcbiAgICAgICAgdGhpcy5oYXNDb25kaXRpb24gPSAodmFsdWUgJiAxKSA+IDA7XG4gICAgICAgIHRoaXMuaGFzU3RhcnRDb250ZW50ID0gKHZhbHVlICYgMikgPiAwO1xuICAgICAgICB0aGlzLmhhc0Nob2ljZU9ubHlDb250ZW50ID0gKHZhbHVlICYgNCkgPiAwO1xuICAgICAgICB0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCA9ICh2YWx1ZSAmIDgpID4gMDtcbiAgICAgICAgdGhpcy5vbmNlT25seSA9ICh2YWx1ZSAmIDE2KSA+IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoT25DaG9pY2UgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIkNob2ljZVBvaW50LnBhdGhPbkNob2ljZVwiKTtcbiAgICAgICAgLy8gaW50PyB0YXJnZXRMaW5lTnVtID0gRGVidWdMaW5lTnVtYmVyT2ZQYXRoIChwYXRoT25DaG9pY2UpO1xuICAgICAgICBsZXQgdGFyZ2V0TGluZU51bSA9IG51bGw7XG4gICAgICAgIGxldCB0YXJnZXRTdHJpbmcgPSB0aGlzLnBhdGhPbkNob2ljZS50b1N0cmluZygpO1xuICAgICAgICBpZiAodGFyZ2V0TGluZU51bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0YXJnZXRTdHJpbmcgPSBcIiBsaW5lIFwiICsgdGFyZ2V0TGluZU51bSArIFwiKFwiICsgdGFyZ2V0U3RyaW5nICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiQ2hvaWNlOiAtPiBcIiArIHRhcmdldFN0cmluZztcbiAgICB9XG59XG5leHBvcnRzLkNob2ljZVBvaW50ID0gQ2hvaWNlUG9pbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaG9pY2VQb2ludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udGFpbmVyID0gdm9pZCAwO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IFNlYXJjaFJlc3VsdF8xID0gcmVxdWlyZShcIi4vU2VhcmNoUmVzdWx0XCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IERlYnVnXzEgPSByZXF1aXJlKFwiLi9EZWJ1Z1wiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5uYW1lZENvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHVybkluZGV4U2hvdWxkQmVDb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY291bnRpbmdBdFN0YXJ0T25seSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGhhc1ZhbGlkTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSAhPSBudWxsICYmIHRoaXMubmFtZS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHNldCBjb250ZW50KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuQWRkQ29udGVudCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBuYW1lZE9ubHlDb250ZW50KCkge1xuICAgICAgICBsZXQgbmFtZWRPbmx5Q29udGVudERpY3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLm5hbWVkQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGlua09iamVjdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhbHVlLCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgICAgICAgICAgbmFtZWRPbmx5Q29udGVudERpY3Quc2V0KGtleSwgaW5rT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgbGV0IG5hbWVkID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbChjKTtcbiAgICAgICAgICAgIGlmIChuYW1lZCAhPSBudWxsICYmIG5hbWVkLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgICAgIG5hbWVkT25seUNvbnRlbnREaWN0LmRlbGV0ZShuYW1lZC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZWRPbmx5Q29udGVudERpY3Quc2l6ZSA9PSAwKVxuICAgICAgICAgICAgbmFtZWRPbmx5Q29udGVudERpY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gbmFtZWRPbmx5Q29udGVudERpY3Q7XG4gICAgfVxuICAgIHNldCBuYW1lZE9ubHlDb250ZW50KHZhbHVlKSB7XG4gICAgICAgIGxldCBleGlzdGluZ05hbWVkT25seSA9IHRoaXMubmFtZWRPbmx5Q29udGVudDtcbiAgICAgICAgaWYgKGV4aXN0aW5nTmFtZWRPbmx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXldIG9mIGV4aXN0aW5nTmFtZWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lZENvbnRlbnQuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IFssIHZhbF0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBuYW1lZCA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwodmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuQWRkVG9OYW1lZENvbnRlbnRPbmx5KG5hbWVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY291bnRGbGFncygpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gMDtcbiAgICAgICAgaWYgKHRoaXMudmlzaXRzU2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgZmxhZ3MgfD0gQ29udGFpbmVyLkNvdW50RmxhZ3MuVmlzaXRzO1xuICAgICAgICBpZiAodGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICBmbGFncyB8PSBDb250YWluZXIuQ291bnRGbGFncy5UdXJucztcbiAgICAgICAgaWYgKHRoaXMuY291bnRpbmdBdFN0YXJ0T25seSlcbiAgICAgICAgICAgIGZsYWdzIHw9IENvbnRhaW5lci5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5O1xuICAgICAgICBpZiAoZmxhZ3MgPT0gQ29udGFpbmVyLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHkpIHtcbiAgICAgICAgICAgIGZsYWdzID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfVxuICAgIHNldCBjb3VudEZsYWdzKHZhbHVlKSB7XG4gICAgICAgIGxldCBmbGFnID0gdmFsdWU7XG4gICAgICAgIGlmICgoZmxhZyAmIENvbnRhaW5lci5Db3VudEZsYWdzLlZpc2l0cykgPiAwKVxuICAgICAgICAgICAgdGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoKGZsYWcgJiBDb250YWluZXIuQ291bnRGbGFncy5UdXJucykgPiAwKVxuICAgICAgICAgICAgdGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoKGZsYWcgJiBDb250YWluZXIuQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSkgPiAwKVxuICAgICAgICAgICAgdGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50ID09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50ID0gdGhpcy5wYXRoLlBhdGhCeUFwcGVuZGluZ1BhdGgodGhpcy5pbnRlcm5hbFBhdGhUb0ZpcnN0TGVhZkNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aFRvRmlyc3RMZWFmQ29udGVudDtcbiAgICB9XG4gICAgZ2V0IGludGVybmFsUGF0aFRvRmlyc3RMZWFmQ29udGVudCgpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChjb250YWluZXIgaW5zdGFuY2VvZiBDb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKG5ldyBQYXRoXzEuUGF0aC5Db21wb25lbnQoMCkpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jb250ZW50WzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGF0aF8xLlBhdGgoY29tcG9uZW50cyk7XG4gICAgfVxuICAgIEFkZENvbnRlbnQoY29udGVudE9iak9yTGlzdCkge1xuICAgICAgICBpZiAoY29udGVudE9iak9yTGlzdCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgY29udGVudExpc3QgPSBjb250ZW50T2JqT3JMaXN0O1xuICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb250ZW50TGlzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuQWRkQ29udGVudChjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50T2JqID0gY29udGVudE9iak9yTGlzdDtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQucHVzaChjb250ZW50T2JqKTtcbiAgICAgICAgICAgIGlmIChjb250ZW50T2JqLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRlbnQgaXMgYWxyZWFkeSBpbiBcIiArIGNvbnRlbnRPYmoucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRlbnRPYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KGNvbnRlbnRPYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRyeUFkZE5hbWVkQ29udGVudChjb250ZW50T2JqKSB7XG4gICAgICAgIGxldCBuYW1lZENvbnRlbnRPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKGNvbnRlbnRPYmopO1xuICAgICAgICBpZiAobmFtZWRDb250ZW50T2JqICE9IG51bGwgJiYgbmFtZWRDb250ZW50T2JqLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5BZGRUb05hbWVkQ29udGVudE9ubHkobmFtZWRDb250ZW50T2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBZGRUb05hbWVkQ29udGVudE9ubHkobmFtZWRDb250ZW50T2JqKSB7XG4gICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0VHlwZShuYW1lZENvbnRlbnRPYmosIE9iamVjdF8xLklua09iamVjdCwgXCJDYW4gb25seSBhZGQgUnVudGltZS5PYmplY3RzIHRvIGEgUnVudGltZS5Db250YWluZXJcIik7XG4gICAgICAgIGxldCBydW50aW1lT2JqID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobmFtZWRDb250ZW50T2JqLCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgICAgICBydW50aW1lT2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMubmFtZWRDb250ZW50LnNldChuYW1lZENvbnRlbnRPYmoubmFtZSwgbmFtZWRDb250ZW50T2JqKTtcbiAgICB9XG4gICAgQ29udGVudEF0UGF0aChwYXRoLCBwYXJ0aWFsUGF0aFN0YXJ0ID0gMCwgcGFydGlhbFBhdGhMZW5ndGggPSAtMSkge1xuICAgICAgICBpZiAocGFydGlhbFBhdGhMZW5ndGggPT0gLTEpXG4gICAgICAgICAgICBwYXJ0aWFsUGF0aExlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IFNlYXJjaFJlc3VsdF8xLlNlYXJjaFJlc3VsdCgpO1xuICAgICAgICByZXN1bHQuYXBwcm94aW1hdGUgPSBmYWxzZTtcbiAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSB0aGlzO1xuICAgICAgICBsZXQgY3VycmVudE9iaiA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBwYXJ0aWFsUGF0aFN0YXJ0OyBpIDwgcGFydGlhbFBhdGhMZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNvbXAgPSBwYXRoLkdldENvbXBvbmVudChpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwcm94aW1hdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kT2JqID0gY3VycmVudENvbnRhaW5lci5Db250ZW50V2l0aFBhdGhDb21wb25lbnQoY29tcCk7XG4gICAgICAgICAgICBpZiAoZm91bmRPYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHByb3hpbWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50T2JqID0gZm91bmRPYmo7XG4gICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGZvdW5kT2JqLCBDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5vYmogPSBjdXJyZW50T2JqO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBJbnNlcnRDb250ZW50KGNvbnRlbnRPYmosIGluZGV4KSB7XG4gICAgICAgIHRoaXMuY29udGVudFtpbmRleF0gPSBjb250ZW50T2JqO1xuICAgICAgICBpZiAoY29udGVudE9iai5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnRlbnQgaXMgYWxyZWFkeSBpbiBcIiArIGNvbnRlbnRPYmoucGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50T2JqLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KGNvbnRlbnRPYmopO1xuICAgIH1cbiAgICBBZGRDb250ZW50c09mQ29udGFpbmVyKG90aGVyQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5jb25jYXQob3RoZXJDb250YWluZXIuY29udGVudCk7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiBvdGhlckNvbnRhaW5lci5jb250ZW50KSB7XG4gICAgICAgICAgICBvYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuVHJ5QWRkTmFtZWRDb250ZW50KG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29udGVudFdpdGhQYXRoQ29tcG9uZW50KGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoY29tcG9uZW50LmlzSW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQuaW5kZXggPj0gMCAmJiBjb21wb25lbnQuaW5kZXggPCB0aGlzLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtjb21wb25lbnQuaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LmlzUGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbXBvbmVudC5uYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvdW5kQ29udGVudCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLm5hbWVkQ29udGVudCwgY29tcG9uZW50Lm5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKGZvdW5kQ29udGVudC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoZm91bmRDb250ZW50LnJlc3VsdCwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoKSB7XG4gICAgICAgIGxldCBzYjtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgMCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzYiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgbGV0IGluZGVudGF0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBsZXQgcG9pbnRlZE9iaiA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kSW5kZW50YXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzcGFjZXNQZXJJbmRlbnQgPSA0OyAvLyBUcnVseSBjb25zdCBpbiB0aGUgb3JpZ2luYWwgY29kZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFjZXNQZXJJbmRlbnQgKiBpbmRlbnRhdGlvbjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICBzYi5BcHBlbmQoXCJbXCIpO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgIHNiLkFwcGVuZEZvcm1hdChcIiAoezB9KVwiLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzID09IHBvaW50ZWRPYmopIHtcbiAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgPC0tLVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzYi5BcHBlbmRMaW5lKCk7XG4gICAgICAgIGluZGVudGF0aW9uKys7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBvYmo7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIGluZGVudGF0aW9uLCBwb2ludGVkT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKCdcIicpO1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQob2JqLnRvU3RyaW5nKCkucmVwbGFjZShcIlxcblwiLCBcIlxcXFxuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKCdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKG9iai50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAhPSB0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShvYmogaW5zdGFuY2VvZiBDb250YWluZXIpICYmIG9iaiA9PSBwb2ludGVkT2JqKSB7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiICA8LS0tXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuQXBwZW5kTGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvbmx5TmFtZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLm5hbWVkQ29udGVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5pbmRleE9mKFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhbHVlLCBPYmplY3RfMS5JbmtPYmplY3QpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvbmx5TmFtZWQuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbmx5TmFtZWQuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgICAgICBzYi5BcHBlbmRMaW5lKFwiLS0gbmFtZWQ6IC0tXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgWywgdmFsdWVdIG9mIG9ubHlOYW1lZCkge1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0VHlwZSh2YWx1ZSwgQ29udGFpbmVyLCBcIkNhbiBvbmx5IHByaW50IG91dCBuYW1lZCBDb250YWluZXJzXCIpO1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgaW5kZW50YXRpb24sIHBvaW50ZWRPYmopO1xuICAgICAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmRlbnRhdGlvbi0tO1xuICAgICAgICBhcHBlbmRJbmRlbnRhdGlvbigpO1xuICAgICAgICBzYi5BcHBlbmQoXCJdXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udGFpbmVyID0gQ29udGFpbmVyO1xuKGZ1bmN0aW9uIChDb250YWluZXIpIHtcbiAgICBsZXQgQ291bnRGbGFncztcbiAgICAoZnVuY3Rpb24gKENvdW50RmxhZ3MpIHtcbiAgICAgICAgQ291bnRGbGFnc1tDb3VudEZsYWdzW1wiVmlzaXRzXCJdID0gMV0gPSBcIlZpc2l0c1wiO1xuICAgICAgICBDb3VudEZsYWdzW0NvdW50RmxhZ3NbXCJUdXJuc1wiXSA9IDJdID0gXCJUdXJuc1wiO1xuICAgICAgICBDb3VudEZsYWdzW0NvdW50RmxhZ3NbXCJDb3VudFN0YXJ0T25seVwiXSA9IDRdID0gXCJDb3VudFN0YXJ0T25seVwiO1xuICAgIH0pKENvdW50RmxhZ3MgPSBDb250YWluZXIuQ291bnRGbGFncyB8fCAoQ29udGFpbmVyLkNvdW50RmxhZ3MgPSB7fSkpO1xufSkoQ29udGFpbmVyID0gZXhwb3J0cy5Db250YWluZXIgfHwgKGV4cG9ydHMuQ29udGFpbmVyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRhaW5lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJvbENvbW1hbmQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIENvbnRyb2xDb21tYW5kIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb21tYW5kVHlwZSA9IENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vdFNldCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9jb21tYW5kVHlwZSA9IGNvbW1hbmRUeXBlO1xuICAgIH1cbiAgICBnZXQgY29tbWFuZFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21tYW5kVHlwZTtcbiAgICB9XG4gICAgQ29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZCh0aGlzLmNvbW1hbmRUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIEV2YWxTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsU3RhcnQpO1xuICAgIH1cbiAgICBzdGF0aWMgRXZhbE91dHB1dCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsT3V0cHV0KTtcbiAgICB9XG4gICAgc3RhdGljIEV2YWxFbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbEVuZCk7XG4gICAgfVxuICAgIHN0YXRpYyBEdXBsaWNhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRHVwbGljYXRlKTtcbiAgICB9XG4gICAgc3RhdGljIFBvcEV2YWx1YXRlZFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIFBvcEZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIFBvcFR1bm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BUdW5uZWwpO1xuICAgIH1cbiAgICBzdGF0aWMgQmVnaW5TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpO1xuICAgIH1cbiAgICBzdGF0aWMgRW5kU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZFN0cmluZyk7XG4gICAgfVxuICAgIHN0YXRpYyBOb09wKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vT3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQ2hvaWNlQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnQpO1xuICAgIH1cbiAgICBzdGF0aWMgVHVybnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnMpO1xuICAgIH1cbiAgICBzdGF0aWMgVHVybnNTaW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlKTtcbiAgICB9XG4gICAgc3RhdGljIFJlYWRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SZWFkQ291bnQpO1xuICAgIH1cbiAgICBzdGF0aWMgUmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJhbmRvbSk7XG4gICAgfVxuICAgIHN0YXRpYyBTZWVkUmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlZWRSYW5kb20pO1xuICAgIH1cbiAgICBzdGF0aWMgVmlzaXRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5WaXNpdEluZGV4KTtcbiAgICB9XG4gICAgc3RhdGljIFNlcXVlbmNlU2h1ZmZsZUluZGV4KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4KTtcbiAgICB9XG4gICAgc3RhdGljIFN0YXJ0VGhyZWFkKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkKTtcbiAgICB9XG4gICAgc3RhdGljIERvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRG9uZSk7XG4gICAgfVxuICAgIHN0YXRpYyBFbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kKTtcbiAgICB9XG4gICAgc3RhdGljIExpc3RGcm9tSW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50KTtcbiAgICB9XG4gICAgc3RhdGljIExpc3RSYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZ2UpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdFJhbmRvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZG9tKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRUeXBlLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cm9sQ29tbWFuZCA9IENvbnRyb2xDb21tYW5kO1xuKGZ1bmN0aW9uIChDb250cm9sQ29tbWFuZCkge1xuICAgIGxldCBDb21tYW5kVHlwZTtcbiAgICAoZnVuY3Rpb24gKENvbW1hbmRUeXBlKSB7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTm90U2V0XCJdID0gLTFdID0gXCJOb3RTZXRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFdmFsU3RhcnRcIl0gPSAwXSA9IFwiRXZhbFN0YXJ0XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRXZhbE91dHB1dFwiXSA9IDFdID0gXCJFdmFsT3V0cHV0XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRXZhbEVuZFwiXSA9IDJdID0gXCJFdmFsRW5kXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRHVwbGljYXRlXCJdID0gM10gPSBcIkR1cGxpY2F0ZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlBvcEV2YWx1YXRlZFZhbHVlXCJdID0gNF0gPSBcIlBvcEV2YWx1YXRlZFZhbHVlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUG9wRnVuY3Rpb25cIl0gPSA1XSA9IFwiUG9wRnVuY3Rpb25cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJQb3BUdW5uZWxcIl0gPSA2XSA9IFwiUG9wVHVubmVsXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiQmVnaW5TdHJpbmdcIl0gPSA3XSA9IFwiQmVnaW5TdHJpbmdcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFbmRTdHJpbmdcIl0gPSA4XSA9IFwiRW5kU3RyaW5nXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTm9PcFwiXSA9IDldID0gXCJOb09wXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiQ2hvaWNlQ291bnRcIl0gPSAxMF0gPSBcIkNob2ljZUNvdW50XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVHVybnNcIl0gPSAxMV0gPSBcIlR1cm5zXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVHVybnNTaW5jZVwiXSA9IDEyXSA9IFwiVHVybnNTaW5jZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlJhbmRvbVwiXSA9IDEzXSA9IFwiUmFuZG9tXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiU2VlZFJhbmRvbVwiXSA9IDE0XSA9IFwiU2VlZFJhbmRvbVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlZpc2l0SW5kZXhcIl0gPSAxNV0gPSBcIlZpc2l0SW5kZXhcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJTZXF1ZW5jZVNodWZmbGVJbmRleFwiXSA9IDE2XSA9IFwiU2VxdWVuY2VTaHVmZmxlSW5kZXhcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJTdGFydFRocmVhZFwiXSA9IDE3XSA9IFwiU3RhcnRUaHJlYWRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJEb25lXCJdID0gMThdID0gXCJEb25lXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiRW5kXCJdID0gMTldID0gXCJFbmRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJMaXN0RnJvbUludFwiXSA9IDIwXSA9IFwiTGlzdEZyb21JbnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJMaXN0UmFuZ2VcIl0gPSAyMV0gPSBcIkxpc3RSYW5nZVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkxpc3RSYW5kb21cIl0gPSAyMl0gPSBcIkxpc3RSYW5kb21cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJSZWFkQ291bnRcIl0gPSAyM10gPSBcIlJlYWRDb3VudFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlRPVEFMX1ZBTFVFU1wiXSA9IDI0XSA9IFwiVE9UQUxfVkFMVUVTXCI7XG4gICAgfSkoQ29tbWFuZFR5cGUgPSBDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZSB8fCAoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUgPSB7fSkpO1xufSkoQ29udHJvbENvbW1hbmQgPSBleHBvcnRzLkNvbnRyb2xDb21tYW5kIHx8IChleHBvcnRzLkNvbnRyb2xDb21tYW5kID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyb2xDb21tYW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWJ1ZyA9IHZvaWQgMDtcbnZhciBEZWJ1ZztcbihmdW5jdGlvbiAoRGVidWcpIHtcbiAgICBmdW5jdGlvbiBBc3NlcnRUeXBlKHZhcmlhYmxlLCB0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIEFzc2VydCh2YXJpYWJsZSBpbnN0YW5jZW9mIHR5cGUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBEZWJ1Zy5Bc3NlcnRUeXBlID0gQXNzZXJ0VHlwZTtcbiAgICBmdW5jdGlvbiBBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uc29sZS50cmFjZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEZWJ1Zy5Bc3NlcnQgPSBBc3NlcnQ7XG59KShEZWJ1ZyA9IGV4cG9ydHMuRGVidWcgfHwgKGV4cG9ydHMuRGVidWcgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVidWcuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRpdmVydCA9IHZvaWQgMDtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgUG9pbnRlcl8xID0gcmVxdWlyZShcIi4vUG9pbnRlclwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIERpdmVydCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3Ioc3RhY2tQdXNoVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl90YXJnZXRQYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMudmFyaWFibGVEaXZlcnROYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wdXNoZXNUb1N0YWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhY2tQdXNoVHlwZSA9IDA7XG4gICAgICAgIHRoaXMuaXNFeHRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV4dGVybmFsQXJncyA9IDA7XG4gICAgICAgIHRoaXMuaXNDb25kaXRpb25hbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFja1B1c2hUeXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hlc1RvU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFja1B1c2hUeXBlID0gc3RhY2tQdXNoVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGFyZ2V0UGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBhdGggIT0gbnVsbCAmJiB0aGlzLl90YXJnZXRQYXRoLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRPYmogPSB0aGlzLnRhcmdldFBvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgaWYgKHRhcmdldE9iaikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBhdGggPSB0YXJnZXRPYmoucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0UGF0aDtcbiAgICB9XG4gICAgc2V0IHRhcmdldFBhdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0UGF0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBvaW50ZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgbGV0IHRhcmdldE9iaiA9IHRoaXMuUmVzb2x2ZVBhdGgodGhpcy5fdGFyZ2V0UGF0aCkub2JqO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBhdGggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl90YXJnZXRQYXRoXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRPYmogPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGFyZ2V0T2JqXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIuY29udGFpbmVyID1cbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0T2JqLnBhcmVudCBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA/IHRhcmdldE9iai5wYXJlbnQgOiBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIuaW5kZXggPSB0aGlzLl90YXJnZXRQYXRoLmxhc3RDb21wb25lbnQuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZih0YXJnZXRPYmogaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIgPyB0YXJnZXRPYmogOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0UG9pbnRlci5jb3B5KCk7XG4gICAgfVxuICAgIGdldCB0YXJnZXRQYXRoU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRQYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuQ29tcGFjdFBhdGhTdHJpbmcodGhpcy50YXJnZXRQYXRoKTtcbiAgICB9XG4gICAgc2V0IHRhcmdldFBhdGhTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBuZXcgUGF0aF8xLlBhdGgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoYXNWYXJpYWJsZVRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGVEaXZlcnROYW1lICE9IG51bGw7XG4gICAgfVxuICAgIEVxdWFscyhvYmopIHtcbiAgICAgICAgbGV0IG90aGVyRGl2ZXJ0ID0gb2JqO1xuICAgICAgICBpZiAob3RoZXJEaXZlcnQgaW5zdGFuY2VvZiBEaXZlcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0ID09IG90aGVyRGl2ZXJ0Lmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFyaWFibGVEaXZlcnROYW1lID09IG90aGVyRGl2ZXJ0LnZhcmlhYmxlRGl2ZXJ0TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldFBhdGggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0UGF0aC5FcXVhbHMob3RoZXJEaXZlcnQudGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gXCJEaXZlcnQodmFyaWFibGU6IFwiICsgdGhpcy52YXJpYWJsZURpdmVydE5hbWUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRhcmdldFBhdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiRGl2ZXJ0KG51bGwpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRTdHIgPSB0aGlzLnRhcmdldFBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIGludD8gdGFyZ2V0TGluZU51bSA9IERlYnVnTGluZU51bWJlck9mUGF0aCAodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0TGluZU51bSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TGluZU51bSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U3RyID0gXCJsaW5lIFwiICsgdGFyZ2V0TGluZU51bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNiLkFwcGVuZChcIkRpdmVydFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29uZGl0aW9uYWwpXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiP1wiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnB1c2hlc1RvU3RhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFja1B1c2hUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgZnVuY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgdHVubmVsXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNiLkFwcGVuZChcIiAtPiBcIik7XG4gICAgICAgICAgICBzYi5BcHBlbmQodGhpcy50YXJnZXRQYXRoU3RyaW5nKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZChcIiAoXCIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKHRhcmdldFN0cik7XG4gICAgICAgICAgICBzYi5BcHBlbmQoXCIpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRpdmVydCA9IERpdmVydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpdmVydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2x1ZSA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgR2x1ZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIkdsdWVcIjtcbiAgICB9XG59XG5leHBvcnRzLkdsdWUgPSBHbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2x1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5rTGlzdCA9IGV4cG9ydHMuSW5rTGlzdEl0ZW0gPSB2b2lkIDA7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNsYXNzIElua0xpc3RJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gSW5rTGlzdEl0ZW0gaXMgYSBzdHJ1Y3RcbiAgICAgICAgdGhpcy5vcmlnaW5OYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdGVtTmFtZSA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luTmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBpdGVtTmFtZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luTmFtZSA9IG9yaWdpbk5hbWU7XG4gICAgICAgICAgICB0aGlzLml0ZW1OYW1lID0gaXRlbU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICBsZXQgZnVsbE5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgbmFtZVBhcnRzID0gZnVsbE5hbWUudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbk5hbWUgPSBuYW1lUGFydHNbMF07XG4gICAgICAgICAgICB0aGlzLml0ZW1OYW1lID0gbmFtZVBhcnRzWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0SXRlbShudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZ2V0IGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luTmFtZSA9PSBudWxsICYmIHRoaXMuaXRlbU5hbWUgPT0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGZ1bGxOYW1lKCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLm9yaWdpbk5hbWUgIT09IG51bGwgPyB0aGlzLm9yaWdpbk5hbWUgOiBcIj9cIikgKyBcIi5cIiArIHRoaXMuaXRlbU5hbWUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVsbE5hbWU7XG4gICAgfVxuICAgIEVxdWFscyhvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIElua0xpc3RJdGVtKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXJJdGVtID0gb2JqO1xuICAgICAgICAgICAgcmV0dXJuIChvdGhlckl0ZW0uaXRlbU5hbWUgPT0gdGhpcy5pdGVtTmFtZSAmJlxuICAgICAgICAgICAgICAgIG90aGVySXRlbS5vcmlnaW5OYW1lID09IHRoaXMub3JpZ2luTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBUaGVzZSBtZXRob2RzIGRpZCBub3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUuIFRoZWlyIHB1cnBvc2UgaXMgdG9cbiAgICAvLyBtYWtlIGBJbmtMaXN0SXRlbWAgbWltaWNzIHRoZSB2YWx1ZS10eXBlIHNlbWFudGljcyBvZiB0aGUgb3JpZ2luYWxcbiAgICAvLyBzdHJ1Y3QuIFBsZWFzZSByZWZlciB0byB0aGUgZW5kIG9mIHRoaXMgZmlsZSwgZm9yIGEgbW9yZSBpbi1kZXB0aFxuICAgIC8vIGV4cGxhbmF0aW9uLlxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaGFsbG93IGNsb25lIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5rTGlzdEl0ZW0odGhpcy5vcmlnaW5OYW1lLCB0aGlzLml0ZW1OYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBTZXJpYWxpemVkSW5rTGlzdEl0ZW1gIHJlcHJlc2VudGluZyB0aGUgY3VycmVudFxuICAgICAqIGluc3RhbmNlLiBUaGUgcmVzdWx0IGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSBrZXkgaW5zaWRlIGEgTWFwLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZWQoKSB7XG4gICAgICAgIC8vIFdlIGFyZSBzaW1wbHkgdXNpbmcgYSBKU09OIHJlcHJlc2VudGF0aW9uIGFzIGEgdmFsdWUtdHlwZWQga2V5LlxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgb3JpZ2luTmFtZTogdGhpcy5vcmlnaW5OYW1lLFxuICAgICAgICAgICAgaXRlbU5hbWU6IHRoaXMuaXRlbU5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbnN0cnVjdHMgYSBgSW5rTGlzdEl0ZW1gIGZyb20gdGhlIGdpdmVuIFNlcmlhbGl6ZWRJbmtMaXN0SXRlbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KSB7XG4gICAgICAgIGxldCBvYmogPSBKU09OLnBhcnNlKGtleSk7XG4gICAgICAgIGlmICghSW5rTGlzdEl0ZW0uaXNMaWtlSW5rTGlzdEl0ZW0ob2JqKSlcbiAgICAgICAgICAgIHJldHVybiBJbmtMaXN0SXRlbS5OdWxsO1xuICAgICAgICBsZXQgaW5rTGlzdEl0ZW0gPSBvYmo7XG4gICAgICAgIHJldHVybiBuZXcgSW5rTGlzdEl0ZW0oaW5rTGlzdEl0ZW0ub3JpZ2luTmFtZSwgaW5rTGlzdEl0ZW0uaXRlbU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGl0ZW0gaXMgc3VmZmljaWVudGx5IGBJbmtMaXN0SXRlbWAtbGlrZVxuICAgICAqIHRvIGJlIHVzZWQgYXMgYSB0ZW1wbGF0ZSB3aGVuIHJlY29uc3RydWN0aW5nIHRoZSBJbmtMaXN0SXRlbS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNMaWtlSW5rTGlzdEl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gIT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghaXRlbS5oYXNPd25Qcm9wZXJ0eShcIm9yaWdpbk5hbWVcIikgfHwgIWl0ZW0uaGFzT3duUHJvcGVydHkoXCJpdGVtTmFtZVwiKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLm9yaWdpbk5hbWUgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGl0ZW0ub3JpZ2luTmFtZSAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtLml0ZW1OYW1lICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBpdGVtLml0ZW1OYW1lICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLklua0xpc3RJdGVtID0gSW5rTGlzdEl0ZW07XG5jbGFzcyBJbmtMaXN0IGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gVHJ5aW5nIHRvIGJlIHNtYXJ0IGhlcmUsIHRoaXMgZW11bGF0ZXMgdGhlIGNvbnN0cnVjdG9yIGluaGVyaXRhbmNlIGZvdW5kXG4gICAgICAgIC8vIGluIHRoZSBvcmlnaW5hbCBjb2RlLCBidXQgb25seSBpZiBvdGhlckxpc3QgaXMgYW4gSW5rTGlzdC4gSUlGRSBGVFcuXG4gICAgICAgIHN1cGVyKCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgSW5rTGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCkpO1xuICAgICAgICB0aGlzLm9yaWdpbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtdO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgSW5rTGlzdCkge1xuICAgICAgICAgICAgbGV0IG90aGVyTGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmIChvdGhlckxpc3QuX29yaWdpbk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBvdGhlckxpc3QuX29yaWdpbk5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHNpbmdsZU9yaWdpbkxpc3ROYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IG9yaWdpblN0b3J5ID0gYXJndW1lbnRzWzFdOyAvKiBhcyBTdG9yeSAqL1xuICAgICAgICAgICAgdGhpcy5TZXRJbml0aWFsT3JpZ2luTmFtZShzaW5nbGVPcmlnaW5MaXN0TmFtZSk7XG4gICAgICAgICAgICBsZXQgZGVmID0gb3JpZ2luU3RvcnkubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKHNpbmdsZU9yaWdpbkxpc3ROYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChkZWYuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5zID0gW2RlZi5yZXN1bHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5rTGlzdCBvcmlnaW4gY291bGQgbm90IGJlIGZvdW5kIGluIHN0b3J5IHdoZW4gY29uc3RydWN0aW5nIG5ldyBsaXN0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZU9yaWdpbkxpc3ROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMF0uaGFzT3duUHJvcGVydHkoXCJLZXlcIikgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShcIlZhbHVlXCIpKSB7XG4gICAgICAgICAgICBsZXQgc2luZ2xlRWxlbWVudCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuQWRkKHNpbmdsZUVsZW1lbnQuS2V5LCBzaW5nbGVFbGVtZW50LlZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBZGRJdGVtKGl0ZW1Pckl0ZW1OYW1lKSB7XG4gICAgICAgIGlmIChpdGVtT3JJdGVtTmFtZSBpbnN0YW5jZW9mIElua0xpc3RJdGVtKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IGl0ZW1Pckl0ZW1OYW1lO1xuICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5BZGRJdGVtKGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLm9yaWdpbnNcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBvcmlnaW4gb2YgdGhpcy5vcmlnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5uYW1lID09IGl0ZW0ub3JpZ2luTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50VmFsID0gb3JpZ2luLlRyeUdldFZhbHVlRm9ySXRlbShpdGVtLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludFZhbC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkKGl0ZW0sIGludFZhbC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgZG9lc24ndCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgbGlzdCBkZWZpbml0aW9uIGluIGluay5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gYWRkIGl0ZW0gdG8gbGlzdCBiZWNhdXNlIHRoZSBpdGVtIHdhcyBmcm9tIGEgbmV3IGxpc3QgZGVmaW5pdGlvbiB0aGF0IHdhc24ndCBwcmV2aW91c2x5IGtub3duIHRvIHRoaXMgbGlzdC4gT25seSBpdGVtcyBmcm9tIHByZXZpb3VzbHkga25vd24gbGlzdHMgY2FuIGJlIHVzZWQsIHNvIHRoYXQgdGhlIGludCB2YWx1ZSBjYW4gYmUgZm91bmQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGl0ZW1OYW1lID0gaXRlbU9ySXRlbU5hbWU7XG4gICAgICAgICAgICBsZXQgZm91bmRMaXN0RGVmID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLm9yaWdpbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLm9yaWdpbnNcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBvcmlnaW4gb2YgdGhpcy5vcmlnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1OYW1lID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4uQ29udGFpbnNJdGVtV2l0aE5hbWUoaXRlbU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZExpc3REZWYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGNvdWxkIGNvbWUgZnJvbSBlaXRoZXIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbi5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRMaXN0RGVmLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRMaXN0RGVmID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kTGlzdERlZiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBhZGQgdGhlIGl0ZW0gXCIgK1xuICAgICAgICAgICAgICAgICAgICBpdGVtTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiIHRvIHRoaXMgbGlzdCBiZWNhdXNlIGl0IGlzbid0IGtub3duIHRvIGFueSBsaXN0IGRlZmluaXRpb25zIHByZXZpb3VzbHkgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbGlzdC5cIik7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJbmtMaXN0SXRlbShmb3VuZExpc3REZWYubmFtZSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgbGV0IGl0ZW1WYWwgPSBmb3VuZExpc3REZWYuVmFsdWVGb3JJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5BZGQoaXRlbSwgaXRlbVZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29udGFpbnNJdGVtTmFtZWQoaXRlbU5hbWUpIHtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT0gaXRlbU5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDb250YWluc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzKGtleS5zZXJpYWxpemVkKCkpO1xuICAgIH1cbiAgICBBZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZEtleSA9IGtleS5zZXJpYWxpemVkKCk7XG4gICAgICAgIGlmICh0aGlzLmhhcyhzZXJpYWxpemVkS2V5KSkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIHRvIG1hdGNoIHRoZSBDIyBiZWhhdmlvci5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIE1hcCBhbHJlYWR5IGNvbnRhaW5zIGFuIGVudHJ5IGZvciAke2tleX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldChzZXJpYWxpemVkS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFJlbW92ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGtleS5zZXJpYWxpemVkKCkpO1xuICAgIH1cbiAgICBnZXQgQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBvcmlnaW5PZk1heEl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLm9yaWdpbnMgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgbWF4T3JpZ2luTmFtZSA9IHRoaXMubWF4SXRlbS5LZXkub3JpZ2luTmFtZTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2lucy5ldmVyeSgob3JpZ2luKSA9PiB7XG4gICAgICAgICAgICBpZiAob3JpZ2luLm5hbWUgPT0gbWF4T3JpZ2luTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXQgb3JpZ2luTmFtZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29yaWdpbk5hbWVzID09IG51bGwgJiYgdGhpcy5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fb3JpZ2luTmFtZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ub3JpZ2luTmFtZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMucHVzaChpdGVtLm9yaWdpbk5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5OYW1lcztcbiAgICB9XG4gICAgU2V0SW5pdGlhbE9yaWdpbk5hbWUoaW5pdGlhbE9yaWdpbk5hbWUpIHtcbiAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbaW5pdGlhbE9yaWdpbk5hbWVdO1xuICAgIH1cbiAgICBTZXRJbml0aWFsT3JpZ2luTmFtZXMoaW5pdGlhbE9yaWdpbk5hbWVzKSB7XG4gICAgICAgIGlmIChpbml0aWFsT3JpZ2luTmFtZXMgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gbnVsbDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBpbml0aWFsT3JpZ2luTmFtZXMuc2xpY2UoKTsgLy8gc3RvcmUgYSBjb3B5XG4gICAgfVxuICAgIGdldCBtYXhJdGVtKCkge1xuICAgICAgICBsZXQgbWF4ID0ge1xuICAgICAgICAgICAgS2V5OiBJbmtMaXN0SXRlbS5OdWxsLFxuICAgICAgICAgICAgVmFsdWU6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwgfHwgdmFsdWUgPiBtYXguVmFsdWUpXG4gICAgICAgICAgICAgICAgbWF4ID0geyBLZXk6IGl0ZW0sIFZhbHVlOiB2YWx1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBtaW5JdGVtKCkge1xuICAgICAgICBsZXQgbWluID0ge1xuICAgICAgICAgICAgS2V5OiBJbmtMaXN0SXRlbS5OdWxsLFxuICAgICAgICAgICAgVmFsdWU6IDAsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAobWluLktleS5pc051bGwgfHwgdmFsdWUgPCBtaW4uVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSB7IEtleTogaXRlbSwgVmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IGludmVyc2UoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2lucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBvcmlnaW4gb2YgdGhpcy5vcmlnaW5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG9yaWdpbi5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5Db250YWluc0tleShpdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QuQWRkKGl0ZW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIGdldCBhbGwoKSB7XG4gICAgICAgIGxldCBsaXN0ID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2lucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBvcmlnaW4gb2YgdGhpcy5vcmlnaW5zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG9yaWdpbi5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGxpc3Quc2V0KGl0ZW0uc2VyaWFsaXplZCgpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBVbmlvbihvdGhlckxpc3QpIHtcbiAgICAgICAgbGV0IHVuaW9uID0gbmV3IElua0xpc3QodGhpcyk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBvdGhlckxpc3QpIHtcbiAgICAgICAgICAgIHVuaW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pb247XG4gICAgfVxuICAgIEludGVyc2VjdChvdGhlckxpc3QpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJMaXN0LmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbiAgICB9XG4gICAgV2l0aG91dChsaXN0VG9SZW1vdmUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG5ldyBJbmtMaXN0KHRoaXMpO1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiBsaXN0VG9SZW1vdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb250YWlucyhvdGhlckxpc3QpIHtcbiAgICAgICAgZm9yIChsZXQgW2tleV0gb2Ygb3RoZXJMaXN0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBHcmVhdGVyVGhhbihvdGhlckxpc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVyTGlzdC5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbkl0ZW0uVmFsdWUgPiBvdGhlckxpc3QubWF4SXRlbS5WYWx1ZTtcbiAgICB9XG4gICAgR3JlYXRlclRoYW5PckVxdWFscyhvdGhlckxpc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVyTGlzdC5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAodGhpcy5taW5JdGVtLlZhbHVlID49IG90aGVyTGlzdC5taW5JdGVtLlZhbHVlICYmXG4gICAgICAgICAgICB0aGlzLm1heEl0ZW0uVmFsdWUgPj0gb3RoZXJMaXN0Lm1heEl0ZW0uVmFsdWUpO1xuICAgIH1cbiAgICBMZXNzVGhhbihvdGhlckxpc3QpIHtcbiAgICAgICAgaWYgKG90aGVyTGlzdC5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEl0ZW0uVmFsdWUgPCBvdGhlckxpc3QubWluSXRlbS5WYWx1ZTtcbiAgICB9XG4gICAgTGVzc1RoYW5PckVxdWFscyhvdGhlckxpc3QpIHtcbiAgICAgICAgaWYgKG90aGVyTGlzdC5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiAodGhpcy5tYXhJdGVtLlZhbHVlIDw9IG90aGVyTGlzdC5tYXhJdGVtLlZhbHVlICYmXG4gICAgICAgICAgICB0aGlzLm1pbkl0ZW0uVmFsdWUgPD0gb3RoZXJMaXN0Lm1pbkl0ZW0uVmFsdWUpO1xuICAgIH1cbiAgICBNYXhBc0xpc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCh0aGlzLm1heEl0ZW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QoKTtcbiAgICB9XG4gICAgTWluQXNMaXN0KCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QodGhpcy5taW5JdGVtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KCk7XG4gICAgfVxuICAgIExpc3RXaXRoU3ViUmFuZ2UobWluQm91bmQsIG1heEJvdW5kKSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QoKTtcbiAgICAgICAgbGV0IG9yZGVyZWQgPSB0aGlzLm9yZGVyZWRJdGVtcztcbiAgICAgICAgbGV0IG1pblZhbHVlID0gMDtcbiAgICAgICAgbGV0IG1heFZhbHVlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG1pbkJvdW5kKSkge1xuICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5Cb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtaW5Cb3VuZCBpbnN0YW5jZW9mIElua0xpc3QgJiYgbWluQm91bmQuQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIG1pblZhbHVlID0gbWluQm91bmQubWluSXRlbS5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihtYXhCb3VuZCkpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gbWF4Qm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobWluQm91bmQgaW5zdGFuY2VvZiBJbmtMaXN0ICYmIG1pbkJvdW5kLkNvdW50ID4gMClcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IG1heEJvdW5kLm1heEl0ZW0uVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1Ykxpc3QgPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBzdWJMaXN0LlNldEluaXRpYWxPcmlnaW5OYW1lcyh0aGlzLm9yaWdpbk5hbWVzKTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiBvcmRlcmVkKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5WYWx1ZSA+PSBtaW5WYWx1ZSAmJiBpdGVtLlZhbHVlIDw9IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3ViTGlzdC5BZGQoaXRlbS5LZXksIGl0ZW0uVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJMaXN0O1xuICAgIH1cbiAgICBFcXVhbHMob3RoZXJJbmtMaXN0KSB7XG4gICAgICAgIGlmIChvdGhlcklua0xpc3QgaW5zdGFuY2VvZiBJbmtMaXN0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVySW5rTGlzdC5Db3VudCAhPSB0aGlzLkNvdW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAoIW90aGVySW5rTGlzdC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIEdldEhhc2hDb2RlIG5vdCBpbXBsZW1lbnRlZFxuICAgIGdldCBvcmRlcmVkSXRlbXMoKSB7XG4gICAgICAgIC8vIExpc3Q8S2V5VmFsdWVQYWlyPElua0xpc3RJdGVtLCBpbnQ+PlxuICAgICAgICBsZXQgb3JkZXJlZCA9IG5ldyBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgb3JkZXJlZC5wdXNoKHsgS2V5OiBpdGVtLCBWYWx1ZTogdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXJlZC5zb3J0KCh4LCB5KSA9PiB7XG4gICAgICAgICAgICBpZiAoeC5LZXkub3JpZ2luTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwieC5LZXkub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5LktleS5vcmlnaW5OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ5LktleS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHguVmFsdWUgPT0geS5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LktleS5vcmlnaW5OYW1lLmxvY2FsZUNvbXBhcmUoeS5LZXkub3JpZ2luTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciB0aGlzIGJpdCBpbnRvIGEgbnVtYmVyQ29tcGFyZVRvIG1ldGhvZD9cbiAgICAgICAgICAgICAgICBpZiAoeC5WYWx1ZSA8IHkuVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4geC5WYWx1ZSA+IHkuVmFsdWUgPyAxIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvcmRlcmVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IG9yZGVyZWQgPSB0aGlzLm9yZGVyZWRJdGVtcztcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JkZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPiAwKVxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiwgXCIpO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBvcmRlcmVkW2ldLktleTtcbiAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5pdGVtTmFtZVwiKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZChpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLy8gY2FzdGluZyBhIElua0xpc3QgdG8gYSBOdW1iZXIsIGZvciBzb21lcmVhc29uLCBhY3R1YWxseSBnaXZlcyBhIG51bWJlci5cbiAgICAvLyBUaGlzIG1lc3NlcyB1cCB0aGUgdHlwZSBkZXRlY3Rpb24gd2hlbiBjcmVhdGluZyBhIFZhbHVlIGZyb20gYSBJbmtMaXN0LlxuICAgIC8vIFJldHVybmluZyBOYU4gaGVyZSBwcmV2ZW50cyB0aGF0LlxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxufVxuZXhwb3J0cy5JbmtMaXN0ID0gSW5rTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlua0xpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpzb25TZXJpYWxpc2F0aW9uID0gdm9pZCAwO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBHbHVlXzEgPSByZXF1aXJlKFwiLi9HbHVlXCIpO1xuY29uc3QgQ29udHJvbENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xDb21tYW5kXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IERpdmVydF8xID0gcmVxdWlyZShcIi4vRGl2ZXJ0XCIpO1xuY29uc3QgQ2hvaWNlUG9pbnRfMSA9IHJlcXVpcmUoXCIuL0Nob2ljZVBvaW50XCIpO1xuY29uc3QgVmFyaWFibGVSZWZlcmVuY2VfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlUmVmZXJlbmNlXCIpO1xuY29uc3QgVmFyaWFibGVBc3NpZ25tZW50XzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZUFzc2lnbm1lbnRcIik7XG5jb25zdCBOYXRpdmVGdW5jdGlvbkNhbGxfMSA9IHJlcXVpcmUoXCIuL05hdGl2ZUZ1bmN0aW9uQ2FsbFwiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBUYWdfMSA9IHJlcXVpcmUoXCIuL1RhZ1wiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBDaG9pY2VfMSA9IHJlcXVpcmUoXCIuL0Nob2ljZVwiKTtcbmNvbnN0IExpc3REZWZpbml0aW9uXzEgPSByZXF1aXJlKFwiLi9MaXN0RGVmaW5pdGlvblwiKTtcbmNvbnN0IExpc3REZWZpbml0aW9uc09yaWdpbl8xID0gcmVxdWlyZShcIi4vTGlzdERlZmluaXRpb25zT3JpZ2luXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgSnNvblNlcmlhbGlzYXRpb24ge1xuICAgIHN0YXRpYyBKQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpBcnJheSwgc2tpcExhc3QgPSBmYWxzZSkge1xuICAgICAgICBsZXQgY291bnQgPSBqQXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAoc2tpcExhc3QpXG4gICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGxldCBqVG9rID0gakFycmF5W2ldO1xuICAgICAgICAgICAgbGV0IHJ1bnRpbWVPYmogPSB0aGlzLkpUb2tlblRvUnVudGltZU9iamVjdChqVG9rKTtcbiAgICAgICAgICAgIGlmIChydW50aW1lT2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJydW50aW1lT2JqXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKHJ1bnRpbWVPYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVEaWN0aW9uYXJ5UnVudGltZU9ianMod3JpdGVyLCBkaWN0aW9uYXJ5KSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkaWN0aW9uYXJ5KSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KGtleSk7XG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUxpc3RSdW50aW1lT2Jqcyh3cml0ZXIsIGxpc3QpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiBsaXN0KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVJbnREaWN0aW9uYXJ5KHdyaXRlciwgZGljdCkge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZGljdCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCBvYmopIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lQ29udGFpbmVyKHdyaXRlciwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGl2ZXJ0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgRGl2ZXJ0XzEuRGl2ZXJ0KTtcbiAgICAgICAgaWYgKGRpdmVydCkge1xuICAgICAgICAgICAgbGV0IGRpdlR5cGVLZXkgPSBcIi0+XCI7XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICBkaXZUeXBlS2V5ID0gXCJ4KClcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmVydC5wdXNoZXNUb1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmVydC5zdGFja1B1c2hUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBkaXZUeXBlS2V5ID0gXCJmKClcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGl2ZXJ0LnN0YWNrUHVzaFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCkge1xuICAgICAgICAgICAgICAgICAgICBkaXZUeXBlS2V5ID0gXCItPnQtPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0YXJnZXRTdHI7XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0Lmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U3RyID0gZGl2ZXJ0LnZhcmlhYmxlRGl2ZXJ0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldFN0ciA9IGRpdmVydC50YXJnZXRQYXRoU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KGRpdlR5cGVLZXksIHRhcmdldFN0cik7XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0Lmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ2YXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0LmlzQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImNcIiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGl2ZXJ0LmV4dGVybmFsQXJncyA+IDApIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImV4QXJnc1wiLCBkaXZlcnQuZXh0ZXJuYWxBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaG9pY2VQb2ludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENob2ljZVBvaW50XzEuQ2hvaWNlUG9pbnQpO1xuICAgICAgICBpZiAoY2hvaWNlUG9pbnQpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIipcIiwgY2hvaWNlUG9pbnQucGF0aFN0cmluZ09uQ2hvaWNlKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiZmxnXCIsIGNob2ljZVBvaW50LmZsYWdzKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgaWYgKGludFZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50KGludFZhbC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsb2F0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5GbG9hdFZhbHVlKTtcbiAgICAgICAgaWYgKGZsb2F0VmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVGbG9hdChmbG9hdFZhbC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICBpZiAoc3RyVmFsKSB7XG4gICAgICAgICAgICBpZiAoc3RyVmFsLmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZShcIlxcblwiLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdTdGFydCgpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ0lubmVyKFwiXlwiKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVTdHJpbmdJbm5lcihzdHJWYWwudmFsdWUpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ0VuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaXN0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBpZiAobGlzdFZhbCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZUlua0xpc3Qod3JpdGVyLCBsaXN0VmFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGl2VGFyZ2V0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSk7XG4gICAgICAgIGlmIChkaXZUYXJnZXRWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBpZiAoZGl2VGFyZ2V0VmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJkaXZUYXJnZXRWYWwudmFsdWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIl4tPlwiLCBkaXZUYXJnZXRWYWwudmFsdWUuY29tcG9uZW50c1N0cmluZyk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFyUHRyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgIGlmICh2YXJQdHJWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIl52YXJcIiwgdmFyUHRyVmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiY2lcIiwgdmFyUHRyVmFsLmNvbnRleHRJbmRleCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZ2x1ZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIEdsdWVfMS5HbHVlKTtcbiAgICAgICAgaWYgKGdsdWUpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShcIjw+XCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250cm9sQ21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgIGlmIChjb250cm9sQ21kKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXNbY29udHJvbENtZC5jb21tYW5kVHlwZV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuYXRpdmVGdW5jID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsKTtcbiAgICAgICAgaWYgKG5hdGl2ZUZ1bmMpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gbmF0aXZlRnVuYy5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJeXCIpXG4gICAgICAgICAgICAgICAgbmFtZSA9IFwiTF5cIjtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFyUmVmID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZSk7XG4gICAgICAgIGlmICh2YXJSZWYpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBsZXQgcmVhZENvdW50UGF0aCA9IHZhclJlZi5wYXRoU3RyaW5nRm9yQ291bnQ7XG4gICAgICAgICAgICBpZiAocmVhZENvdW50UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJDTlQ/XCIsIHJlYWRDb3VudFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJWQVI/XCIsIHZhclJlZi5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YXJBc3MgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYXJpYWJsZUFzc2lnbm1lbnRfMS5WYXJpYWJsZUFzc2lnbm1lbnQpO1xuICAgICAgICBpZiAodmFyQXNzKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgbGV0IGtleSA9IHZhckFzcy5pc0dsb2JhbCA/IFwiVkFSPVwiIDogXCJ0ZW1wPVwiO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoa2V5LCB2YXJBc3MudmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIC8vIFJlYXNzaWdubWVudD9cbiAgICAgICAgICAgIGlmICghdmFyQXNzLmlzTmV3RGVjbGFyYXRpb24pXG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJyZVwiLCB0cnVlKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2b2lkT2JqID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVm9pZF8xLlZvaWQpO1xuICAgICAgICBpZiAodm9pZE9iaikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKFwidm9pZFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFnID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVGFnXzEuVGFnKTtcbiAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiI1wiLCB0YWcudGV4dCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hvaWNlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ2hvaWNlXzEuQ2hvaWNlKTtcbiAgICAgICAgaWYgKGNob2ljZSkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZUNob2ljZSh3cml0ZXIsIGNob2ljZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNvbnZlcnQgcnVudGltZSBvYmplY3QgdG8gSnNvbiB0b2tlbjogXCIgKyBvYmopO1xuICAgIH1cbiAgICBzdGF0aWMgSk9iamVjdFRvRGljdGlvbmFyeVJ1bnRpbWVPYmpzKGpPYmplY3QpIHtcbiAgICAgICAgbGV0IGRpY3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBqT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoak9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlua09iamVjdCA9IHRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KGpPYmplY3Rba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGlua09iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImlua09iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGljdC5zZXQoa2V5LCBpbmtPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH1cbiAgICBzdGF0aWMgSk9iamVjdFRvSW50RGljdGlvbmFyeShqT2JqZWN0KSB7XG4gICAgICAgIGxldCBkaWN0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gak9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGpPYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGRpY3Quc2V0KGtleSwgcGFyc2VJbnQoak9iamVjdFtrZXldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICAgIHN0YXRpYyBKVG9rZW5Ub1J1bnRpbWVPYmplY3QodG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJudW1iZXJcIiAmJiAhaXNOYU4odG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gVmFsdWVfMS5WYWx1ZS5DcmVhdGUodG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBzdHIgPSB0b2tlbi50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gU3RyaW5nIHZhbHVlXG4gICAgICAgICAgICBsZXQgZmlyc3RDaGFyID0gc3RyWzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q2hhciA9PSBcIl5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoc3RyLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaXJzdENoYXIgPT0gXCJcXG5cIiAmJiBzdHIubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKFwiXFxuXCIpO1xuICAgICAgICAgICAgLy8gR2x1ZVxuICAgICAgICAgICAgaWYgKHN0ciA9PSBcIjw+XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBHbHVlXzEuR2x1ZSgpO1xuICAgICAgICAgICAgLy8gQ29udHJvbCBjb21tYW5kcyAod291bGQgbG9va2luZyB1cCBpbiBhIGhhc2ggc2V0IGJlIGZhc3Rlcj8pXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNtZE5hbWUgPSBKc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyID09IGNtZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5hdGl2ZSBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCJMXlwiKVxuICAgICAgICAgICAgICAgIHN0ciA9IFwiXlwiO1xuICAgICAgICAgICAgaWYgKE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsRXhpc3RzV2l0aE5hbWUoc3RyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxXaXRoTmFtZShzdHIpO1xuICAgICAgICAgICAgLy8gUG9wXG4gICAgICAgICAgICBpZiAoc3RyID09IFwiLT4tPlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLlBvcFR1bm5lbCgpO1xuICAgICAgICAgICAgZWxzZSBpZiAoc3RyID09IFwifnJldFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLlBvcEZ1bmN0aW9uKCk7XG4gICAgICAgICAgICAvLyBWb2lkXG4gICAgICAgICAgICBpZiAoc3RyID09IFwidm9pZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVm9pZF8xLlZvaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRva2VuO1xuICAgICAgICAgICAgbGV0IHByb3BWYWx1ZTtcbiAgICAgICAgICAgIC8vIERpdmVydCB0YXJnZXQgdmFsdWUgdG8gcGF0aFxuICAgICAgICAgICAgaWYgKG9ialtcIl4tPlwiXSkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcIl4tPlwiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUobmV3IFBhdGhfMS5QYXRoKHByb3BWYWx1ZS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBWYXJpYWJsZVBvaW50ZXJWYWx1ZVxuICAgICAgICAgICAgaWYgKG9ialtcIl52YXJcIl0pIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCJedmFyXCJdO1xuICAgICAgICAgICAgICAgIGxldCB2YXJQdHIgPSBuZXcgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZShwcm9wVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiY2lcIiBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiY2lcIl07XG4gICAgICAgICAgICAgICAgICAgIHZhclB0ci5jb250ZXh0SW5kZXggPSBwYXJzZUludChwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFyUHRyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGl2ZXJ0XG4gICAgICAgICAgICBsZXQgaXNEaXZlcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBwdXNoZXNUb1N0YWNrID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZGl2UHVzaFR5cGUgPSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb247XG4gICAgICAgICAgICBsZXQgZXh0ZXJuYWwgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiLT5cIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNEaXZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcImYoKVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaGVzVG9TdGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGl2UHVzaFR5cGUgPSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wiLT50LT5cIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNEaXZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2hlc1RvU3RhY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGRpdlB1c2hUeXBlID0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJ4KClcIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNEaXZlcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwdXNoZXNUb1N0YWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGl2UHVzaFR5cGUgPSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXZlcnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGl2ZXJ0ID0gbmV3IERpdmVydF8xLkRpdmVydCgpO1xuICAgICAgICAgICAgICAgIGRpdmVydC5wdXNoZXNUb1N0YWNrID0gcHVzaGVzVG9TdGFjaztcbiAgICAgICAgICAgICAgICBkaXZlcnQuc3RhY2tQdXNoVHlwZSA9IGRpdlB1c2hUeXBlO1xuICAgICAgICAgICAgICAgIGRpdmVydC5pc0V4dGVybmFsID0gZXh0ZXJuYWw7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1widmFyXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0LnZhcmlhYmxlRGl2ZXJ0TmFtZSA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpdmVydC50YXJnZXRQYXRoU3RyaW5nID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGRpdmVydC5pc0NvbmRpdGlvbmFsID0gISFvYmpbXCJjXCJdO1xuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcImV4QXJnc1wiXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXZlcnQuZXh0ZXJuYWxBcmdzID0gcGFyc2VJbnQocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdmVydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENob2ljZVxuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCIqXCJdKSkge1xuICAgICAgICAgICAgICAgIGxldCBjaG9pY2UgPSBuZXcgQ2hvaWNlUG9pbnRfMS5DaG9pY2VQb2ludCgpO1xuICAgICAgICAgICAgICAgIGNob2ljZS5wYXRoU3RyaW5nT25DaG9pY2UgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcImZsZ1wiXSkpXG4gICAgICAgICAgICAgICAgICAgIGNob2ljZS5mbGFncyA9IHBhcnNlSW50KHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIHJlZmVyZW5jZVxuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJWQVI/XCJdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZShwcm9wVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wiQ05UP1wiXSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVhZENvdW50VmFyUmVmID0gbmV3IFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UoKTtcbiAgICAgICAgICAgICAgICByZWFkQ291bnRWYXJSZWYucGF0aFN0cmluZ0ZvckNvdW50ID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb3VudFZhclJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhcmlhYmxlIGFzc2lnbm1lbnRcbiAgICAgICAgICAgIGxldCBpc1ZhckFzcyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGlzR2xvYmFsVmFyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIlZBUj1cIl0pKSB7XG4gICAgICAgICAgICAgICAgaXNWYXJBc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlzR2xvYmFsVmFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJ0ZW1wPVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhckFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNHbG9iYWxWYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhckFzcykge1xuICAgICAgICAgICAgICAgIGxldCB2YXJOYW1lID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgbGV0IGlzTmV3RGVjbCA9ICFvYmpbXCJyZVwiXTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyQXNzID0gbmV3IFZhcmlhYmxlQXNzaWdubWVudF8xLlZhcmlhYmxlQXNzaWdubWVudCh2YXJOYW1lLCBpc05ld0RlY2wpO1xuICAgICAgICAgICAgICAgIHZhckFzcy5pc0dsb2JhbCA9IGlzR2xvYmFsVmFyO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJBc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqW1wiI1wiXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiI1wiXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFRhZ18xLlRhZyhwcm9wVmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0IHZhbHVlXG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcImxpc3RcIl0pKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIGxpc3RDb250ZW50ID0gKERpY3Rpb25hcnk8c3RyaW5nLCBvYmplY3Q+KXByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgbGlzdENvbnRlbnQgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHJhd0xpc3QgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QoKTtcbiAgICAgICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIm9yaWdpbnNcIl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBuYW1lc0FzT2JqcyA9IChMaXN0PG9iamVjdD4pcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZXNBc09ianMgPSBwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJhd0xpc3QuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG5hbWVzQXNPYmpzLkNhc3Q8c3RyaW5nPigpLlRvTGlzdCgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5TZXRJbml0aWFsT3JpZ2luTmFtZXMobmFtZXNBc09ianMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gbGlzdENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RDb250ZW50Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lVG9WYWwgPSBsaXN0Q29udGVudFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBuZXcgSW5rTGlzdF8xLklua0xpc3RJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gcGFyc2VJbnQobmFtZVRvVmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0xpc3QuQWRkKGl0ZW0sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShyYXdMaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmpbXCJvcmlnaW5hbENob2ljZVBhdGhcIl0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5KT2JqZWN0VG9DaG9pY2Uob2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheSBpcyBhbHdheXMgYSBSdW50aW1lLkNvbnRhaW5lclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkpBcnJheVRvQ29udGFpbmVyKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCB0b2tlbiB0byBydW50aW1lIG9iamVjdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0b2tlbikpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVSdW50aW1lQ29udGFpbmVyKHdyaXRlciwgY29udGFpbmVyLCB3aXRob3V0TmFtZSA9IGZhbHNlKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYyBvZiBjb250YWluZXIuY29udGVudClcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgYyk7XG4gICAgICAgIGxldCBuYW1lZE9ubHlDb250ZW50ID0gY29udGFpbmVyLm5hbWVkT25seUNvbnRlbnQ7XG4gICAgICAgIGxldCBjb3VudEZsYWdzID0gY29udGFpbmVyLmNvdW50RmxhZ3M7XG4gICAgICAgIGxldCBoYXNOYW1lUHJvcGVydHkgPSBjb250YWluZXIubmFtZSAhPSBudWxsICYmICF3aXRob3V0TmFtZTtcbiAgICAgICAgbGV0IGhhc1Rlcm1pbmF0b3IgPSBuYW1lZE9ubHlDb250ZW50ICE9IG51bGwgfHwgY291bnRGbGFncyA+IDAgfHwgaGFzTmFtZVByb3BlcnR5O1xuICAgICAgICBpZiAoaGFzVGVybWluYXRvcikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZWRPbmx5Q29udGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgbmFtZWRPbmx5Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgIGxldCBuYW1lZENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lQ29udGFpbmVyKHdyaXRlciwgbmFtZWRDb250YWluZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc05hbWVQcm9wZXJ0eSlcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiI25cIiwgY29udGFpbmVyLm5hbWUpO1xuICAgICAgICBpZiAoaGFzVGVybWluYXRvcilcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVOdWxsKCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBKQXJyYXlUb0NvbnRhaW5lcihqQXJyYXkpIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLmNvbnRlbnQgPSB0aGlzLkpBcnJheVRvUnVudGltZU9iakxpc3QoakFycmF5LCB0cnVlKTtcbiAgICAgICAgbGV0IHRlcm1pbmF0aW5nT2JqID0gakFycmF5W2pBcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRlcm1pbmF0aW5nT2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBuYW1lZE9ubHlDb250ZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRlcm1pbmF0aW5nT2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PSBcIiNmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLmNvdW50RmxhZ3MgPSBwYXJzZUludCh0ZXJtaW5hdGluZ09ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09IFwiI25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSA9IHRlcm1pbmF0aW5nT2JqW2tleV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lZENvbnRlbnRJdGVtID0gdGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3QodGVybWluYXRpbmdPYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBuYW1lZFN1YkNvbnRhaW5lciA9IG5hbWVkQ29udGVudEl0ZW0gYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZWRTdWJDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwobmFtZWRDb250ZW50SXRlbSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVkU3ViQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZWRTdWJDb250YWluZXIubmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZWRPbmx5Q29udGVudC5zZXQoa2V5LCBuYW1lZENvbnRlbnRJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250YWluZXIubmFtZWRPbmx5Q29udGVudCA9IG5hbWVkT25seUNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgc3RhdGljIEpPYmplY3RUb0Nob2ljZShqT2JqKSB7XG4gICAgICAgIGxldCBjaG9pY2UgPSBuZXcgQ2hvaWNlXzEuQ2hvaWNlKCk7XG4gICAgICAgIGNob2ljZS50ZXh0ID0gak9ialtcInRleHRcIl0udG9TdHJpbmcoKTtcbiAgICAgICAgY2hvaWNlLmluZGV4ID0gcGFyc2VJbnQoak9ialtcImluZGV4XCJdKTtcbiAgICAgICAgY2hvaWNlLnNvdXJjZVBhdGggPSBqT2JqW1wib3JpZ2luYWxDaG9pY2VQYXRoXCJdLnRvU3RyaW5nKCk7XG4gICAgICAgIGNob2ljZS5vcmlnaW5hbFRocmVhZEluZGV4ID0gcGFyc2VJbnQoak9ialtcIm9yaWdpbmFsVGhyZWFkSW5kZXhcIl0pO1xuICAgICAgICBjaG9pY2UucGF0aFN0cmluZ09uQ2hvaWNlID0gak9ialtcInRhcmdldFBhdGhcIl0udG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGNob2ljZTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlQ2hvaWNlKHdyaXRlciwgY2hvaWNlKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidGV4dFwiLCBjaG9pY2UudGV4dCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiaW5kZXhcIiwgY2hvaWNlLmluZGV4KTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJvcmlnaW5hbENob2ljZVBhdGhcIiwgY2hvaWNlLnNvdXJjZVBhdGgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcIm9yaWdpbmFsVGhyZWFkSW5kZXhcIiwgY2hvaWNlLm9yaWdpbmFsVGhyZWFkSW5kZXgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInRhcmdldFBhdGhcIiwgY2hvaWNlLnBhdGhTdHJpbmdPbkNob2ljZSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVJbmtMaXN0KHdyaXRlciwgbGlzdFZhbCkge1xuICAgICAgICBsZXQgcmF3TGlzdCA9IGxpc3RWYWwudmFsdWU7XG4gICAgICAgIGlmIChyYXdMaXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInJhd0xpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImxpc3RcIik7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgcmF3TGlzdCkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGxldCBpdGVtVmFsID0gdmFsO1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0uaXRlbU5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lSW5uZXIoaXRlbS5vcmlnaW5OYW1lID8gaXRlbS5vcmlnaW5OYW1lIDogXCI/XCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lSW5uZXIoXCIuXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlOYW1lSW5uZXIoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShpdGVtVmFsKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIGlmIChyYXdMaXN0LkNvdW50ID09IDAgJiZcbiAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2luTmFtZXMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5OYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwib3JpZ2luc1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgcmF3TGlzdC5vcmlnaW5OYW1lcylcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGUobmFtZSk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIExpc3REZWZpbml0aW9uc1RvSlRva2VuKG9yaWdpbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAobGV0IGRlZiBvZiBvcmlnaW4ubGlzdHMpIHtcbiAgICAgICAgICAgIGxldCBsaXN0RGVmSnNvbiA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiBkZWYuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5pdGVtTmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdERlZkpzb25baXRlbS5pdGVtTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRbZGVmLm5hbWVdID0gbGlzdERlZkpzb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIEpUb2tlblRvTGlzdERlZmluaXRpb25zKG9iaikge1xuICAgICAgICAvLyB2YXIgZGVmc09iaiA9IChEaWN0aW9uYXJ5PHN0cmluZywgb2JqZWN0PilvYmo7XG4gICAgICAgIGxldCBkZWZzT2JqID0gb2JqO1xuICAgICAgICBsZXQgYWxsRGVmcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gZGVmc09iaikge1xuICAgICAgICAgICAgaWYgKGRlZnNPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0ga2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIGxpc3REZWZKc29uID0gKERpY3Rpb25hcnk8c3RyaW5nLCBvYmplY3Q+KWt2LlZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0RGVmSnNvbiA9IGRlZnNPYmpba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBDYXN0IChzdHJpbmcsIG9iamVjdCkgdG8gKHN0cmluZywgaW50KSBmb3IgaXRlbXNcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbmFtZVZhbHVlS2V5IGluIGxpc3REZWZKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZzT2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lVmFsdWUgPSBsaXN0RGVmSnNvbltuYW1lVmFsdWVLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0KG5hbWVWYWx1ZUtleSwgcGFyc2VJbnQobmFtZVZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGRlZiA9IG5ldyBMaXN0RGVmaW5pdGlvbl8xLkxpc3REZWZpbml0aW9uKG5hbWUsIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICBhbGxEZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpc3REZWZpbml0aW9uc09yaWdpbl8xLkxpc3REZWZpbml0aW9uc09yaWdpbihhbGxEZWZzKTtcbiAgICB9XG59XG5leHBvcnRzLkpzb25TZXJpYWxpc2F0aW9uID0gSnNvblNlcmlhbGlzYXRpb247XG5Kc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lcyA9ICgoKSA9PiB7XG4gICAgbGV0IF9jb250cm9sQ29tbWFuZE5hbWVzID0gW107XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsU3RhcnRdID0gXCJldlwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbE91dHB1dF0gPSBcIm91dFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbEVuZF0gPSBcIi9ldlwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRHVwbGljYXRlXSA9IFwiZHVcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlXSA9IFwicG9wXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbl0gPSBcIn5yZXRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcFR1bm5lbF0gPSBcIi0+LT5cIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nXSA9IFwic3RyXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRTdHJpbmddID0gXCIvc3RyXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob09wXSA9IFwibm9wXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5DaG9pY2VDb3VudF0gPSBcImNob2ljZUNudFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNdID0gXCJ0dXJuXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlXSA9IFwidHVybnNcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJlYWRDb3VudF0gPSBcInJlYWRjXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SYW5kb21dID0gXCJybmRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlZWRSYW5kb21dID0gXCJzcm5kXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5WaXNpdEluZGV4XSA9IFwidmlzaXRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4XSA9XG4gICAgICAgIFwic2VxXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZF0gPSBcInRocmVhZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRG9uZV0gPSBcImRvbmVcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZF0gPSBcImVuZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnRdID0gXCJsaXN0SW50XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZ2VdID0gXCJyYW5nZVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmRvbV0gPSBcImxybmRcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVE9UQUxfVkFMVUVTOyArK2kpIHtcbiAgICAgICAgaWYgKF9jb250cm9sQ29tbWFuZE5hbWVzW2ldID09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cm9sIGNvbW1hbmQgbm90IGFjY291bnRlZCBmb3IgaW4gc2VyaWFsaXNhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIF9jb250cm9sQ29tbWFuZE5hbWVzO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb25TZXJpYWxpc2F0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jbGFzcyBMaXN0RGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgaXRlbXMpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWUgfHwgXCJcIjtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzID0gaXRlbXMgfHwgbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0odGhpcy5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLnNldChpdGVtLnNlcmlhbGl6ZWQoKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG4gICAgVmFsdWVGb3JJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBpbnRWYWwgPSB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmdldChpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnRWYWwgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm4gaW50VmFsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgQ29udGFpbnNJdGVtKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtLml0ZW1OYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoaXRlbS5vcmlnaW5OYW1lICE9IHRoaXMubmFtZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuaGFzKGl0ZW0uaXRlbU5hbWUpO1xuICAgIH1cbiAgICBDb250YWluc0l0ZW1XaXRoTmFtZShpdGVtTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5oYXMoaXRlbU5hbWUpO1xuICAgIH1cbiAgICBUcnlHZXRJdGVtV2l0aFZhbHVlKHZhbCwgXG4gICAgLyogb3V0ICovIGl0ZW0pIHtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBpdGVtID0gbmV3IElua0xpc3RfMS5JbmtMaXN0SXRlbSh0aGlzLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpdGVtLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGw7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogaXRlbSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBUcnlHZXRWYWx1ZUZvckl0ZW0oaXRlbSwgXG4gICAgLyogb3V0ICovIGludFZhbCkge1xuICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IDAsIGV4aXN0czogZmFsc2UgfTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5nZXQoaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IDAsIGV4aXN0czogZmFsc2UgfTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiB0cnVlIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbiA9IExpc3REZWZpbml0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdERlZmluaXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3REZWZpbml0aW9uc09yaWdpbiA9IHZvaWQgMDtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgTGlzdERlZmluaXRpb25zT3JpZ2luIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0cykge1xuICAgICAgICB0aGlzLl9saXN0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgbGlzdCBvZiBsaXN0cykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdHMuc2V0KGxpc3QubmFtZSwgbGlzdCk7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGxpc3QuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0VmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoaXRlbSwgdmFsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaXRlbS5pdGVtTmFtZSBpcyBudWxsIG9yIHVuZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2FsbFVuYW1iaWd1b3VzTGlzdFZhbHVlQ2FjaGUuc2V0KGl0ZW0uaXRlbU5hbWUsIGxpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5zZXQoaXRlbS5mdWxsTmFtZSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGlzdHMoKSB7XG4gICAgICAgIGxldCBsaXN0T2ZMaXN0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBbLCB2YWx1ZV0gb2YgdGhpcy5fbGlzdHMpIHtcbiAgICAgICAgICAgIGxpc3RPZkxpc3RzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0T2ZMaXN0cztcbiAgICB9XG4gICAgVHJ5TGlzdEdldERlZmluaXRpb24obmFtZSwgXG4gICAgLyogb3V0ICovIGRlZikge1xuICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWYsIGV4aXN0czogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbml0aWFsbHksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGJvb2xlYW4gYW5kIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIGFuIG91dC5cbiAgICAgICAgbGV0IGRlZmluaXRpb24gPSB0aGlzLl9saXN0cy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmLCBleGlzdHM6IGZhbHNlIH07XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmaW5pdGlvbiwgZXhpc3RzOiB0cnVlIH07XG4gICAgfVxuICAgIEZpbmRTaW5nbGVJdGVtTGlzdFdpdGhOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsID0gdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5nZXQobmFtZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdERlZmluaXRpb25zT3JpZ2luID0gTGlzdERlZmluaXRpb25zT3JpZ2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGlzdERlZmluaXRpb25zT3JpZ2luLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYXRpdmVGdW5jdGlvbkNhbGwgPSB2b2lkIDA7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBWb2lkXzEgPSByZXF1aXJlKFwiLi9Wb2lkXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBOYXRpdmVGdW5jdGlvbkNhbGwgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzID0gMDtcbiAgICAgICAgdGhpcy5fcHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5faXNQcm90b3R5cGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uRnVuY3MgPSBudWxsO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgTmF0aXZlRnVuY3Rpb25DYWxsLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5HZW5lcmF0ZU5hdGl2ZUZ1bmN0aW9uc0lmTmVjZXNzYXJ5KCk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IG51bWJlck9mUGFyYW1ldGVycyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2lzUHJvdG90eXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mUGFyYW1ldGVycyA9IG51bWJlck9mUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgQ2FsbFdpdGhOYW1lKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUZ1bmN0aW9uQ2FsbChmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICBzdGF0aWMgQ2FsbEV4aXN0c1dpdGhOYW1lKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICB0aGlzLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5nZXQoZnVuY3Rpb25OYW1lKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hbWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XG4gICAgICAgIGlmICghdGhpcy5faXNQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIGlmIChOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnNcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvdG90eXBlID1cbiAgICAgICAgICAgICAgICAgICAgTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KHRoaXMuX25hbWUpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG51bWJlck9mUGFyYW1ldGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3RvdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvdHlwZS5udW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldCBudW1iZXJPZlBhcmFtZXRlcnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZQYXJhbWV0ZXJzID0gdmFsdWU7XG4gICAgfVxuICAgIENhbGwocGFyYW1ldGVycykge1xuICAgICAgICBpZiAodGhpcy5fcHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG90eXBlLkNhbGwocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubnVtYmVyT2ZQYXJhbWV0ZXJzICE9IHBhcmFtZXRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNMaXN0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHAgb2YgcGFyYW1ldGVycykge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBWb2lkXzEuVm9pZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbignQXR0ZW1wdGluZyB0byBwZXJmb3JtIG9wZXJhdGlvbiBvbiBhIHZvaWQgdmFsdWUuIERpZCB5b3UgZm9yZ2V0IHRvIFwicmV0dXJuXCIgYSB2YWx1ZSBmcm9tIGEgZnVuY3Rpb24geW91IGNhbGxlZCBoZXJlPycpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBWYWx1ZV8xLkxpc3RWYWx1ZSlcbiAgICAgICAgICAgICAgICBoYXNMaXN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1ldGVycy5sZW5ndGggPT0gMiAmJiBoYXNMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsQmluYXJ5TGlzdE9wZXJhdGlvbihwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29lcmNlZFBhcmFtcyA9IHRoaXMuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlKHBhcmFtZXRlcnMpO1xuICAgICAgICBsZXQgY29lcmNlZFR5cGUgPSBjb2VyY2VkUGFyYW1zWzBdLnZhbHVlVHlwZTtcbiAgICAgICAgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgQ2FsbFR5cGUocGFyYW1ldGVyc09mU2luZ2xlVHlwZSkge1xuICAgICAgICBsZXQgcGFyYW0xID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc09mU2luZ2xlVHlwZVswXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGxldCB2YWxUeXBlID0gcGFyYW0xLnZhbHVlVHlwZTtcbiAgICAgICAgbGV0IHZhbDEgPSBwYXJhbTE7XG4gICAgICAgIGxldCBwYXJhbUNvdW50ID0gcGFyYW1ldGVyc09mU2luZ2xlVHlwZS5sZW5ndGg7XG4gICAgICAgIGlmIChwYXJhbUNvdW50ID09IDIgfHwgcGFyYW1Db3VudCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO1xuICAgICAgICAgICAgbGV0IG9wRm9yVHlwZU9iaiA9IHRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldCh2YWxUeXBlKTtcbiAgICAgICAgICAgIGlmICghb3BGb3JUeXBlT2JqKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gVmFsdWVfMS5WYWx1ZVR5cGVbdmFsVHlwZV07XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgcGVyZm9ybSBvcGVyYXRpb24gXCIgKyB0aGlzLm5hbWUgKyBcIiBvbiBcIiArIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1Db3VudCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmFtMiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNPZlNpbmdsZVR5cGVbMV0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCB2YWwyID0gcGFyYW0yO1xuICAgICAgICAgICAgICAgIGxldCBvcEZvclR5cGUgPSBvcEZvclR5cGVPYmo7XG4gICAgICAgICAgICAgICAgaWYgKHZhbDEudmFsdWUgPT09IG51bGwgfHwgdmFsMi52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbCBCaW5hcnlPcCB2YWx1ZXNcIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdFZhbCA9IG9wRm9yVHlwZSh2YWwxLnZhbHVlLCB2YWwyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gVmFsdWVfMS5WYWx1ZS5DcmVhdGUocmVzdWx0VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBvcEZvclR5cGUgPSBvcEZvclR5cGVPYmo7XG4gICAgICAgICAgICAgICAgaWYgKHZhbDEudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGwgVW5hcnlPcCB2YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VmFsID0gb3BGb3JUeXBlKHZhbDEudmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSBpcyBkaWZmZXJlbnQgZnJvbSB1cHN0cmVhbS4gU2luY2UgSmF2YVNjcmlwdCB0cmVhdHNcbiAgICAgICAgICAgICAgICAvLyBpbnRlZ2VycyBhbmQgZmxvYXRzIGFzIHRoZSBzYW1lIG51bWJlcnMsIGl0J3MgaW1wb3NzaWJsZVxuICAgICAgICAgICAgICAgIC8vIHRvIGZvcmNlIGFuIG51bWJlciB0byBiZSBlaXRoZXIgYW4gaW50ZWdlciBvciBhIGZsb2F0LlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSXQgY2FuIGJlIHVzZWZ1bCB0byBmb3JjZSBhIHNwZWNpZmljIG51bWJlciB0eXBlXG4gICAgICAgICAgICAgICAgLy8gKGVzcGVjaWFsbHkgZm9yIGRpdmlzaW9ucyksIHNvIHRoZSByZXN1bHQgb2YgSU5UKCkgJiBGTE9BVCgpXG4gICAgICAgICAgICAgICAgLy8gaXMgY29lcmNlZCB0byB0aGUgdGhlIHByb3BlciB2YWx1ZSB0eXBlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFsc28gZm9yY2UgYWxsIG90aGVyIHVuYXJ5IG9wZXJhdGlvbiB0b1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGUgc2FtZSB2YWx1ZSB0eXBlLCBhbHRob3VnaCB0aGlzIGlzIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBtZWFuaW5nZnVsIGZvciBudW1iZXJzLiBTZWUgYFZhbHVlLkNyZWF0ZWAuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gTmF0aXZlRnVuY3Rpb25DYWxsLkludCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsdWVfMS5WYWx1ZS5DcmVhdGUocmVzdWx0VmFsLCBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm5hbWUgPT09IE5hdGl2ZUZ1bmN0aW9uQ2FsbC5GbG9hdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsdWVfMS5WYWx1ZS5DcmVhdGUocmVzdWx0VmFsLCBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVmFsdWVfMS5WYWx1ZS5DcmVhdGUocmVzdWx0VmFsLCBwYXJhbTEudmFsdWVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG51bWJlciBvZiBwYXJhbWV0ZXJzIHRvIE5hdGl2ZUZ1bmN0aW9uQ2FsbDogXCIgK1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPZlNpbmdsZVR5cGUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsQmluYXJ5TGlzdE9wZXJhdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICgodGhpcy5uYW1lID09IFwiK1wiIHx8IHRoaXMubmFtZSA9PSBcIi1cIikgJiZcbiAgICAgICAgICAgIHBhcmFtZXRlcnNbMF0gaW5zdGFuY2VvZiBWYWx1ZV8xLkxpc3RWYWx1ZSAmJlxuICAgICAgICAgICAgcGFyYW1ldGVyc1sxXSBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbihwYXJhbWV0ZXJzKTtcbiAgICAgICAgbGV0IHYxID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc1swXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGxldCB2MiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHBhcmFtZXRlcnNbMV0sIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBpZiAoKHRoaXMubmFtZSA9PSBcIiYmXCIgfHwgdGhpcy5uYW1lID09IFwifHxcIikgJiZcbiAgICAgICAgICAgICh2MS52YWx1ZVR5cGUgIT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCB8fCB2Mi52YWx1ZVR5cGUgIT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7XG4gICAgICAgICAgICBsZXQgb3AgPSB0aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQoVmFsdWVfMS5WYWx1ZVR5cGUuSW50KTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsQmluYXJ5TGlzdE9wZXJhdGlvbiBvcFwiKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBvcCh2MS5pc1RydXRoeSA/IDEgOiAwLCB2Mi5pc1RydXRoeSA/IDEgOiAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5JbnRWYWx1ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2MS52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCAmJiB2Mi52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKFt2MSwgdjJdKTtcbiAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW4gbm90IGNhbGwgdXNlIFwiICtcbiAgICAgICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICAgICBcIiBvcGVyYXRpb24gb24gXCIgK1xuICAgICAgICAgICAgVmFsdWVfMS5WYWx1ZVR5cGVbdjEudmFsdWVUeXBlXSArXG4gICAgICAgICAgICBcIiBhbmQgXCIgK1xuICAgICAgICAgICAgVmFsdWVfMS5WYWx1ZVR5cGVbdjIudmFsdWVUeXBlXSk7XG4gICAgfVxuICAgIENhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uKGxpc3RJbnRQYXJhbXMpIHtcbiAgICAgICAgbGV0IGxpc3RWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhsaXN0SW50UGFyYW1zWzBdLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGxldCBpbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhsaXN0SW50UGFyYW1zWzFdLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgbGV0IHJlc3VsdElua0xpc3QgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QoKTtcbiAgICAgICAgaWYgKGxpc3RWYWwudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBsaXN0VmFsLnZhbHVlXCIpO1xuICAgICAgICBmb3IgKGxldCBbbGlzdEl0ZW1LZXksIGxpc3RJdGVtVmFsdWVdIG9mIGxpc3RWYWwudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBsaXN0SXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShsaXN0SXRlbUtleSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRnVuY3MgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX29wZXJhdGlvbkZ1bmNzXCIpO1xuICAgICAgICAgICAgbGV0IGludE9wID0gdGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KFZhbHVlXzEuVmFsdWVUeXBlLkludCk7XG4gICAgICAgICAgICBpZiAoaW50VmFsLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGludFZhbC52YWx1ZVwiKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRJbnQgPSBpbnRPcChsaXN0SXRlbVZhbHVlLCBpbnRWYWwudmFsdWUpO1xuICAgICAgICAgICAgbGV0IGl0ZW1PcmlnaW4gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGxpc3RWYWwudmFsdWUub3JpZ2lucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsTGlzdEluY3JlbWVudE9wZXJhdGlvbiBsaXN0VmFsLnZhbHVlLm9yaWdpbnNcIik7XG4gICAgICAgICAgICBmb3IgKGxldCBvcmlnaW4gb2YgbGlzdFZhbC52YWx1ZS5vcmlnaW5zKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5uYW1lID09IGxpc3RJdGVtLm9yaWdpbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW1PcmlnaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmNyZW1lbnRlZEl0ZW0gPSBpdGVtT3JpZ2luLlRyeUdldEl0ZW1XaXRoVmFsdWUodGFyZ2V0SW50LCBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKGluY3JlbWVudGVkSXRlbS5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdElua0xpc3QuQWRkKGluY3JlbWVudGVkSXRlbS5yZXN1bHQsIHRhcmdldEludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShyZXN1bHRJbmtMaXN0KTtcbiAgICB9XG4gICAgQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlKHBhcmFtZXRlcnNJbikge1xuICAgICAgICBsZXQgdmFsVHlwZSA9IFZhbHVlXzEuVmFsdWVUeXBlLkludDtcbiAgICAgICAgbGV0IHNwZWNpYWxDYXNlTGlzdCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IG9iaiBvZiBwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvYmosIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbC52YWx1ZVR5cGUgPiB2YWxUeXBlKSB7XG4gICAgICAgICAgICAgICAgdmFsVHlwZSA9IHZhbC52YWx1ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbENhc2VMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbCwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbWV0ZXJzT3V0ID0gW107XG4gICAgICAgIGlmIChWYWx1ZV8xLlZhbHVlVHlwZVt2YWxUeXBlXSA9PSBWYWx1ZV8xLlZhbHVlVHlwZVtWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0XSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5rT2JqZWN0VmFsIG9mIHBhcmFtZXRlcnNJbikge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhpbmtPYmplY3RWYWwsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc091dC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRWYWwgPSBwYXJzZUludCh2YWwudmFsdWVPYmplY3QpO1xuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQ2FzZUxpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhzcGVjaWFsQ2FzZUxpc3QsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWNpYWxDYXNlTGlzdC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSBzcGVjaWFsQ2FzZUxpc3QudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gc3BlY2lhbENhc2VMaXN0LnZhbHVlLm9yaWdpbk9mTWF4SXRlbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUgbGlzdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBsaXN0LlRyeUdldEl0ZW1XaXRoVmFsdWUoaW50VmFsLCBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNhc3RlZFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKGl0ZW0ucmVzdWx0LCBpbnRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyc091dC5wdXNoKGNhc3RlZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBmaW5kIExpc3QgaXRlbSB3aXRoIHRoZSB2YWx1ZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50VmFsICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFZhbHVlXzEuVmFsdWVUeXBlW3ZhbC52YWx1ZVR5cGVdO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBtaXggTGlzdHMgYW5kIFwiICsga2V5ICsgXCIgdmFsdWVzIGluIHRoaXMgb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlua09iamVjdFZhbCBvZiBwYXJhbWV0ZXJzSW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoaW5rT2JqZWN0VmFsLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgY2FzdGVkVmFsdWUgPSB2YWwuQ2FzdCh2YWxUeXBlKTtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT3V0LnB1c2goY2FzdGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbWV0ZXJzT3V0O1xuICAgIH1cbiAgICBzdGF0aWMgSWRlbnRpdHkodCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgc3RhdGljIEdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYXRpdmVGdW5jdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnVuY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgLy8gSW50IG9wZXJhdGlvbnNcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4ICsgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsICh4LCB5KSA9PiB4IC0geSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTXVsdGlwbHksICh4LCB5KSA9PiB4ICogeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuRGl2aWRlLCAoeCwgeSkgPT4gTWF0aC5mbG9vcih4IC8geSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1vZCwgKHgsIHkpID0+IHggJSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLk5lZ2F0ZSwgKHgpID0+IC14KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4ID09IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsICh4LCB5KSA9PiAoeCA+IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkxlc3MsICh4LCB5KSA9PiAoeCA8IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiAoeCA+PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4gKHggPD0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKHggIT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5Ob3QsICh4KSA9PiAoeCA9PSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5BbmQsICh4LCB5KSA9PiAoeCAhPSAwICYmIHkgIT0gMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuT3IsICh4LCB5KSA9PiAoeCAhPSAwIHx8IHkgIT0gMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTWF4LCAoeCwgeSkgPT4gTWF0aC5tYXgoeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLk1pbiwgKHgsIHkpID0+IE1hdGgubWluKHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Qb3csICh4LCB5KSA9PiBNYXRoLnBvdyh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5GbG9vciwgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkNlaWxpbmcsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5JbnQsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludFVuYXJ5T3AodGhpcy5GbG9hdCwgKHgpID0+IHgpO1xuICAgICAgICAgICAgLy8gRmxvYXQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geCArIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuU3VidHJhY3QsICh4LCB5KSA9PiB4IC0geSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NdWx0aXBseSwgKHgsIHkpID0+IHggKiB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkRpdmlkZSwgKHgsIHkpID0+IHggLyB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk1vZCwgKHgsIHkpID0+IHggJSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuTmVnYXRlLCAoeCkgPT4gLXgpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeCA9PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsICh4LCB5KSA9PiAoeCA+IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTGVzcywgKHgsIHkpID0+ICh4IDwgeSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4geCA+PSB5ID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTGVzc1RoYW5PckVxdWFscywgKHgsIHkpID0+ICh4IDw9IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKHggIT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLk5vdCwgKHgpID0+ICh4ID09IDAuMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5BbmQsICh4LCB5KSA9PiAoeCAhPSAwLjAgJiYgeSAhPSAwLjAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuT3IsICh4LCB5KSA9PiAoeCAhPSAwLjAgfHwgeSAhPSAwLjAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTWF4LCAoeCwgeSkgPT4gTWF0aC5tYXgoeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTWluLCAoeCwgeSkgPT4gTWF0aC5taW4oeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuUG93LCAoeCwgeSkgPT4gTWF0aC5wb3coeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5GbG9vciwgKHgpID0+IE1hdGguZmxvb3IoeCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5DZWlsaW5nLCAoeCkgPT4gTWF0aC5jZWlsKHgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuSW50LCAoeCkgPT4gTWF0aC5mbG9vcih4KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkZsb2F0LCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgLy8gU3RyaW5nIG9wZXJhdGlvbnNcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4ICsgeSk7IC8vIGNvbmNhdFxuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHggPT09IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICghKHggPT09IHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5IYXMsICh4LCB5KSA9PiAoeC5pbmNsdWRlcyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuSGFzbnQsICh4LCB5KSA9PiAoeC5pbmNsdWRlcyh5KSA/IDAgOiAxKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHguVW5pb24oeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwgKHgsIHkpID0+IHguV2l0aG91dCh5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkhhcywgKHgsIHkpID0+ICh4LkNvbnRhaW5zKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSGFzbnQsICh4LCB5KSA9PiAoeC5Db250YWlucyh5KSA/IDAgOiAxKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkludGVyc2VjdCwgKHgsIHkpID0+IHguSW50ZXJzZWN0KHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeC5FcXVhbHMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5HcmVhdGVyLCAoeCwgeSkgPT4gKHguR3JlYXRlclRoYW4oeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5MZXNzLCAoeCwgeSkgPT4gKHguTGVzc1RoYW4oeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5HcmVhdGVyVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4geC5HcmVhdGVyVGhhbk9yRXF1YWxzKHkpID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4geC5MZXNzVGhhbk9yRXF1YWxzKHkpID8gMSA6IDApO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoIXguRXF1YWxzKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuQW5kLCAoeCwgeSkgPT4geC5Db3VudCA+IDAgJiYgeS5Db3VudCA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLk9yLCAoeCwgeSkgPT4geC5Db3VudCA+IDAgfHwgeS5Db3VudCA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTm90LCAoeCkgPT4gKHguQ291bnQgPT0gMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuSW52ZXJ0LCAoeCkgPT4geC5pbnZlcnNlKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5BbGwsICh4KSA9PiB4LmFsbCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTGlzdE1pbiwgKHgpID0+IHguTWluQXNMaXN0KCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkxpc3RNYXgsICh4KSA9PiB4Lk1heEFzTGlzdCgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5Db3VudCwgKHgpID0+IHguQ291bnQpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLlZhbHVlT2ZMaXN0LCAoeCkgPT4geC5tYXhJdGVtLlZhbHVlKTtcbiAgICAgICAgICAgIGxldCBkaXZlcnRUYXJnZXRzRXF1YWwgPSAoZDEsIGQyKSA9PiAoZDEuRXF1YWxzKGQyKSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBkaXZlcnRUYXJnZXRzTm90RXF1YWwgPSAoZDEsIGQyKSA9PiBkMS5FcXVhbHMoZDIpID8gMCA6IDE7XG4gICAgICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKHRoaXMuRXF1YWwsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCwgZGl2ZXJ0VGFyZ2V0c0VxdWFsKTtcbiAgICAgICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmModGhpcy5Ob3RFcXVhbHMsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCwgZGl2ZXJ0VGFyZ2V0c05vdEVxdWFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBZGRPcEZ1bmNGb3JUeXBlKHZhbFR5cGUsIG9wKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9vcGVyYXRpb25GdW5jcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vcGVyYXRpb25GdW5jcy5zZXQodmFsVHlwZSwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgYXJncywgdmFsVHlwZSwgb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUZ1bmN0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnNcIik7XG4gICAgICAgIGxldCBuYXRpdmVGdW5jID0gdGhpcy5fbmF0aXZlRnVuY3Rpb25zLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuYXRpdmVGdW5jKSB7XG4gICAgICAgICAgICBuYXRpdmVGdW5jID0gbmV3IE5hdGl2ZUZ1bmN0aW9uQ2FsbChuYW1lLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuX25hdGl2ZUZ1bmN0aW9ucy5zZXQobmFtZSwgbmF0aXZlRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgbmF0aXZlRnVuYy5BZGRPcEZ1bmNGb3JUeXBlKHZhbFR5cGUsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEludEJpbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuSW50LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRJbnRVbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMSwgVmFsdWVfMS5WYWx1ZVR5cGUuSW50LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRGbG9hdEJpbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEZsb2F0VW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDEsIFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRTdHJpbmdCaW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDIsIFZhbHVlXzEuVmFsdWVUeXBlLlN0cmluZywgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkTGlzdEJpbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkTGlzdFVuYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAxLCBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0LCBvcCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gJ05hdGl2ZSBcIicgKyB0aGlzLm5hbWUgKyAnXCInO1xuICAgIH1cbn1cbmV4cG9ydHMuTmF0aXZlRnVuY3Rpb25DYWxsID0gTmF0aXZlRnVuY3Rpb25DYWxsO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkFkZCA9IFwiK1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLlN1YnRyYWN0ID0gXCItXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRGl2aWRlID0gXCIvXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTXVsdGlwbHkgPSBcIipcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Nb2QgPSBcIiVcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5OZWdhdGUgPSBcIl9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5FcXVhbCA9IFwiPT1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5HcmVhdGVyID0gXCI+XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTGVzcyA9IFwiPFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkdyZWF0ZXJUaGFuT3JFcXVhbHMgPSBcIj49XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTGVzc1RoYW5PckVxdWFscyA9IFwiPD1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Ob3RFcXVhbHMgPSBcIiE9XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTm90ID0gXCIhXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQW5kID0gXCImJlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk9yID0gXCJ8fFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk1pbiA9IFwiTUlOXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTWF4ID0gXCJNQVhcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Qb3cgPSBcIlBPV1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkZsb29yID0gXCJGTE9PUlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkNlaWxpbmcgPSBcIkNFSUxJTkdcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5JbnQgPSBcIklOVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkZsb2F0ID0gXCJGTE9BVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkhhcyA9IFwiP1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkhhc250ID0gXCIhP1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkludGVyc2VjdCA9IFwiXlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkxpc3RNaW4gPSBcIkxJU1RfTUlOXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTGlzdE1heCA9IFwiTElTVF9NQVhcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5BbGwgPSBcIkxJU1RfQUxMXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQ291bnQgPSBcIkxJU1RfQ09VTlRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5WYWx1ZU9mTGlzdCA9IFwiTElTVF9WQUxVRVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkludmVydCA9IFwiTElTVF9JTlZFUlRcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zID0gbnVsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5hdGl2ZUZ1bmN0aW9uQ2FsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGhyb3dOdWxsRXhjZXB0aW9uID0gZXhwb3J0cy5OdWxsRXhjZXB0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBJbiB0aGUgb3JpZ2luYWwgQyMgY29kZSwgYSBTeXN0ZW1FeGNlcHRpb24gd291bGQgYmUgdGhyb3duIHdoZW4gcGFzc2luZ1xuICogbnVsbCB0byBtZXRob2RzIGV4cGVjdGVkIGEgdmFsaWQgaW5zdGFuY2UuIEphdmFzY3JpcHQgaGFzIG5vIHN1Y2hcbiAqIGNvbmNlcHQsIGJ1dCBUeXBlU2NyaXB0IHdpbGwgbm90IGFsbG93IGBudWxsYCB0byBiZSBwYXNzZWQgdG8gbWV0aG9kc1xuICogZXhwbGljaXRlbHkgcmVxdWlyaW5nIGEgdmFsaWQgdHlwZS5cbiAqXG4gKiBXaGVuZXZlciBUeXBlU2NyaXB0IGNvbXBsYWluIGFib3V0IHRoZSBwb3NzaWJpbGl0eSBvZiBhIGBudWxsYCB2YWx1ZSxcbiAqIGNoZWNrIHRoZSBvZmZlbmRpbmcgdmFsdWUgYW5kIGl0IGl0J3MgbnVsbCwgdGhyb3cgdGhpcyBleGNlcHRpb24gdXNpbmdcbiAqIGB0aHJvd051bGxFeGNlcHRpb24obmFtZTogc3RyaW5nKWAuXG4gKi9cbmNsYXNzIE51bGxFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG59XG5leHBvcnRzLk51bGxFeGNlcHRpb24gPSBOdWxsRXhjZXB0aW9uO1xuLyoqXG4gKiBUaHJvdyBhIE51bGxFeGNlcHRpb24uXG4gKlxuICogQHBhcmFtIG5hbWUgYSBzaG9ydCBkZXNjcmlwdGlvbiBvZiB0aGUgb2ZmZW5kaW5nIHZhbHVlIChvZnRlbiBpdHMgbmFtZSB3aXRoaW4gdGhlIGNvZGUpLlxuICovXG5mdW5jdGlvbiB0aHJvd051bGxFeGNlcHRpb24obmFtZSkge1xuICAgIHRocm93IG5ldyBOdWxsRXhjZXB0aW9uKGAke25hbWV9IGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG59XG5leHBvcnRzLnRocm93TnVsbEV4Y2VwdGlvbiA9IHRocm93TnVsbEV4Y2VwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU51bGxFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklua09iamVjdCA9IHZvaWQgMDtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IERlYnVnXzEgPSByZXF1aXJlKFwiLi9EZWJ1Z1wiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9kZWJ1Z01ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBkZWJ1Z01ldGFkYXRhKCkge1xuICAgICAgICBpZiAodGhpcy5fZGVidWdNZXRhZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnTWV0YWRhdGE7XG4gICAgfVxuICAgIHNldCBkZWJ1Z01ldGFkYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnTWV0YWRhdGEgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IG93bkRlYnVnTWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1Z01ldGFkYXRhO1xuICAgIH1cbiAgICBEZWJ1Z0xpbmVOdW1iZXJPZlBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBUcnkgdG8gZ2V0IGEgbGluZSBudW1iZXIgZnJvbSBkZWJ1ZyBtZXRhZGF0YVxuICAgICAgICBsZXQgcm9vdCA9IHRoaXMucm9vdENvbnRlbnRDb250YWluZXI7XG4gICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Q29udGVudCA9IHJvb3QuQ29udGVudEF0UGF0aChwYXRoKS5vYmo7XG4gICAgICAgICAgICBpZiAodGFyZ2V0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBkbSA9IHRhcmdldENvbnRlbnQuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZG0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRtLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGggPSBuZXcgUGF0aF8xLlBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjb21wcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjaGlsZC5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZWRDaGlsZCA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZWRDaGlsZCAhPSBudWxsICYmIG5hbWVkQ2hpbGQuaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wcy51bnNoaWZ0KG5ldyBQYXRoXzEuUGF0aC5Db21wb25lbnQobmFtZWRDaGlsZC5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wcy51bnNoaWZ0KG5ldyBQYXRoXzEuUGF0aC5Db21wb25lbnQoY29udGFpbmVyLmNvbnRlbnQuaW5kZXhPZihjaGlsZCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGNvbnRhaW5lci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BhdGggPSBuZXcgUGF0aF8xLlBhdGgoY29tcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICAgIH1cbiAgICBSZXNvbHZlUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwYXRoXCIpO1xuICAgICAgICBpZiAocGF0aC5pc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICBsZXQgbmVhcmVzdENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5lYXJlc3RDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydCh0aGlzLnBhcmVudCAhPT0gbnVsbCwgXCJDYW4ndCByZXNvbHZlIHJlbGF0aXZlIHBhdGggYmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgcGFyZW50XCIpO1xuICAgICAgICAgICAgICAgIG5lYXJlc3RDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQobmVhcmVzdENvbnRhaW5lciAhPT0gbnVsbCwgXCJFeHBlY3RlZCBwYXJlbnQgdG8gYmUgYSBjb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQocGF0aC5HZXRDb21wb25lbnQoMCkuaXNQYXJlbnQpO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoLnRhaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVhcmVzdENvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmVhcmVzdENvbnRhaW5lclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZWFyZXN0Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudENvbnRhaW5lciA9IHRoaXMucm9vdENvbnRlbnRDb250YWluZXI7XG4gICAgICAgICAgICBpZiAoY29udGVudENvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29udGVudENvbnRhaW5lclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ29udmVydFBhdGhUb1JlbGF0aXZlKGdsb2JhbFBhdGgpIHtcbiAgICAgICAgbGV0IG93blBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIGxldCBtaW5QYXRoTGVuZ3RoID0gTWF0aC5taW4oZ2xvYmFsUGF0aC5sZW5ndGgsIG93blBhdGgubGVuZ3RoKTtcbiAgICAgICAgbGV0IGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluUGF0aExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgb3duQ29tcCA9IG93blBhdGguR2V0Q29tcG9uZW50KGkpO1xuICAgICAgICAgICAgbGV0IG90aGVyQ29tcCA9IGdsb2JhbFBhdGguR2V0Q29tcG9uZW50KGkpO1xuICAgICAgICAgICAgaWYgKG93bkNvbXAuRXF1YWxzKG90aGVyQ29tcCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0U2hhcmVkUGF0aENvbXBJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBzaGFyZWQgcGF0aCBjb21wb25lbnRzLCBzbyBqdXN0IHVzZSBnbG9iYWwgcGF0aFxuICAgICAgICBpZiAobGFzdFNoYXJlZFBhdGhDb21wSW5kZXggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsUGF0aDtcbiAgICAgICAgbGV0IG51bVVwd2FyZHNNb3ZlcyA9IG93blBhdGguY29tcG9uZW50Q291bnQgLSAxIC0gbGFzdFNoYXJlZFBhdGhDb21wSW5kZXg7XG4gICAgICAgIGxldCBuZXdQYXRoQ29tcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgdXAgPSAwOyB1cCA8IG51bVVwd2FyZHNNb3ZlczsgKyt1cClcbiAgICAgICAgICAgIG5ld1BhdGhDb21wcy5wdXNoKFBhdGhfMS5QYXRoLkNvbXBvbmVudC5Ub1BhcmVudCgpKTtcbiAgICAgICAgZm9yIChsZXQgZG93biA9IGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ICsgMTsgZG93biA8IGdsb2JhbFBhdGguY29tcG9uZW50Q291bnQ7ICsrZG93bilcbiAgICAgICAgICAgIG5ld1BhdGhDb21wcy5wdXNoKGdsb2JhbFBhdGguR2V0Q29tcG9uZW50KGRvd24pKTtcbiAgICAgICAgbGV0IHJlbGF0aXZlUGF0aCA9IG5ldyBQYXRoXzEuUGF0aChuZXdQYXRoQ29tcHMsIHRydWUpO1xuICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoO1xuICAgIH1cbiAgICBDb21wYWN0UGF0aFN0cmluZyhvdGhlclBhdGgpIHtcbiAgICAgICAgbGV0IGdsb2JhbFBhdGhTdHIgPSBudWxsO1xuICAgICAgICBsZXQgcmVsYXRpdmVQYXRoU3RyID0gbnVsbDtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5pc1JlbGF0aXZlKSB7XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGhTdHIgPSBvdGhlclBhdGguY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgICAgIGdsb2JhbFBhdGhTdHIgPSB0aGlzLnBhdGguUGF0aEJ5QXBwZW5kaW5nUGF0aChvdGhlclBhdGgpLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVsYXRpdmVQYXRoID0gdGhpcy5Db252ZXJ0UGF0aFRvUmVsYXRpdmUob3RoZXJQYXRoKTtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aFN0ciA9IHJlbGF0aXZlUGF0aC5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICAgICAgZ2xvYmFsUGF0aFN0ciA9IG90aGVyUGF0aC5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZVBhdGhTdHIubGVuZ3RoIDwgZ2xvYmFsUGF0aFN0ci5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmVQYXRoU3RyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsUGF0aFN0cjtcbiAgICB9XG4gICAgZ2V0IHJvb3RDb250ZW50Q29udGFpbmVyKCkge1xuICAgICAgICBsZXQgYW5jZXN0b3IgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoYW5jZXN0b3IucGFyZW50KSB7XG4gICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGFuY2VzdG9yLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgIH1cbiAgICBDb3B5KCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIk5vdCBJbXBsZW1lbnRlZDogRG9lc24ndCBzdXBwb3J0IGNvcHlpbmdcIik7XG4gICAgfVxuICAgIC8vIFNldENoaWxkIHdvcmtzIHNsaWdodGx5IGRpZmVyZW50bHkgaW4gdGhlIGpzIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIFNpbmNlIHdlIGNhbid0IHBhc3MgYW4gb2JqZXRzIHByb3BlcnR5IGJ5IHJlZmVyZW5jZSwgd2UgaW5zdGVhZCBwYXNzXG4gICAgLy8gdGhlIG9iamVjdCBhbmQgdGhlIHByb3BlcnR5IHN0cmluZy5cbiAgICAvLyBUT0RPOiBUaGlzIG1ldGhvZCBjYW4gcHJvYmFibHkgYmUgcmV3cml0dGVuIHdpdGggdHlwZS1zYWZldHkgaW4gbWluZC5cbiAgICBTZXRDaGlsZChvYmosIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0pXG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBudWxsO1xuICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKG9ialtwcm9wXSlcbiAgICAgICAgICAgIG9ialtwcm9wXS5wYXJlbnQgPSB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5rT2JqZWN0ID0gSW5rT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QUk5HID0gdm9pZCAwO1xuLy8gVGFrZW4gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9ibGl4dC9mMTdiNDdjNjI1MDhiZTU5OTg3YlxuLy8gSW5rIHVzZXMgYSBzZWVkYWJsZSBQUk5HIG9mIHdoaWNoIHRoZXJlIGlzIG5vbmUgaW4gbmF0aXZlIGphdmFzY3JpcHQuXG5jbGFzcyBQUk5HIHtcbiAgICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQgJSAyMTQ3NDgzNjQ3O1xuICAgICAgICBpZiAodGhpcy5zZWVkIDw9IDApXG4gICAgICAgICAgICB0aGlzLnNlZWQgKz0gMjE0NzQ4MzY0NjtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnNlZWQgPSAodGhpcy5zZWVkICogMTY4MDcpICUgMjE0NzQ4MzY0Nyk7XG4gICAgfVxuICAgIG5leHRGbG9hdCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5leHQoKSAtIDEpIC8gMjE0NzQ4MzY0NjtcbiAgICB9XG59XG5leHBvcnRzLlBSTkcgPSBQUk5HO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UFJORy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGF0aCA9IHZvaWQgMDtcbmNsYXNzIFBhdGgge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1JlbGF0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRzU3RyaW5nID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzU3RyaW5nID0gY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQYXRoLkNvbXBvbmVudCAmJlxuICAgICAgICAgICAgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUGF0aCkge1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgdGFpbCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChoZWFkKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLmNvbmNhdCh0YWlsLl9jb21wb25lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgbGV0IGhlYWQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgcmVsYXRpdmUgPSAhIWFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLmNvbmNhdChoZWFkKTtcbiAgICAgICAgICAgIHRoaXMuX2lzUmVsYXRpdmUgPSByZWxhdGl2ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNSZWxhdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUmVsYXRpdmU7XG4gICAgfVxuICAgIGdldCBjb21wb25lbnRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgaGVhZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdGFpbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIC8vIGNhcmVmdWwsIHRoZSBvcmlnaW5hbCBjb2RlIHVzZXMgbGVuZ3RoLTEgaGVyZS4gVGhpcyBpcyBiZWNhdXNlIHRoZSBzZWNvbmQgYXJndW1lbnQgb2ZcbiAgICAgICAgICAgIC8vIExpc3QuR2V0UmFuZ2UgaXMgYSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZXh0cmFjdCwgd2hlcmVhc2UgQXJyYXkuc2xpY2UgdXNlcyBhbiBpbmRleFxuICAgICAgICAgICAgbGV0IHRhaWxDb21wcyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoMSwgdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXRoKHRhaWxDb21wcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5zZWxmO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGxhc3RDb21wb25lbnQoKSB7XG4gICAgICAgIGxldCBsYXN0Q29tcG9uZW50SWR4ID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdENvbXBvbmVudElkeCA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tsYXN0Q29tcG9uZW50SWR4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb250YWluc05hbWVkQ29tcG9uZW50KCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHNbaV0uaXNJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBzZWxmKCkge1xuICAgICAgICBsZXQgcGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIHBhdGguX2lzUmVsYXRpdmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgR2V0Q29tcG9uZW50KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgUGF0aEJ5QXBwZW5kaW5nUGF0aChwYXRoVG9BcHBlbmQpIHtcbiAgICAgICAgbGV0IHAgPSBuZXcgUGF0aCgpO1xuICAgICAgICBsZXQgdXB3YXJkTW92ZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhUb0FwcGVuZC5fY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHBhdGhUb0FwcGVuZC5fY29tcG9uZW50c1tpXS5pc1BhcmVudCkge1xuICAgICAgICAgICAgICAgIHVwd2FyZE1vdmVzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoIC0gdXB3YXJkTW92ZXM7ICsraSkge1xuICAgICAgICAgICAgcC5fY29tcG9uZW50cy5wdXNoKHRoaXMuX2NvbXBvbmVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB1cHdhcmRNb3ZlczsgaSA8IHBhdGhUb0FwcGVuZC5fY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcC5fY29tcG9uZW50cy5wdXNoKHBhdGhUb0FwcGVuZC5fY29tcG9uZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGdldCBjb21wb25lbnRzU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1N0cmluZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gdGhpcy5fY29tcG9uZW50cy5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmVsYXRpdmUpXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IFwiLlwiICsgdGhpcy5fY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1N0cmluZztcbiAgICB9XG4gICAgc2V0IGNvbXBvbmVudHNTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzU3RyaW5nID09IG51bGwgfHwgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9PSBcIlwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1N0cmluZ1swXSA9PSBcIi5cIikge1xuICAgICAgICAgICAgdGhpcy5faXNSZWxhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gdGhpcy5fY29tcG9uZW50c1N0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBvbmVudFN0cmluZ3MgPSB0aGlzLl9jb21wb25lbnRzU3RyaW5nLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgZm9yIChsZXQgc3RyIG9mIGNvbXBvbmVudFN0cmluZ3MpIHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBuYW1lZCBjb21wb25lbnRzIHRoYXQgc3RhcnQgd2l0aCBhIG51bWJlciwgZWcgXCI0MnNvbWV3aGVyZVwiLCBhbmQgaW5kZXhlZCBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyB0aGUgbm9ybWFsIHBhcnNlSW50IHdvbid0IGRvIGZvciB0aGUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQncyB0b28gcmVsYXhlZC5cbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9wYXJzZUludFxuICAgICAgICAgICAgaWYgKC9eKFxcLXxcXCspPyhbMC05XSt8SW5maW5pdHkpJC8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKG5ldyBQYXRoLkNvbXBvbmVudChwYXJzZUludChzdHIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLnB1c2gobmV3IFBhdGguQ29tcG9uZW50KHN0cikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnRzU3RyaW5nO1xuICAgIH1cbiAgICBFcXVhbHMob3RoZXJQYXRoKSB7XG4gICAgICAgIGlmIChvdGhlclBhdGggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5fY29tcG9uZW50cy5sZW5ndGggIT0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvdGhlclBhdGguaXNSZWxhdGl2ZSAhPSB0aGlzLmlzUmVsYXRpdmUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCBjb2RlIHVzZXMgU2VxdWVuY2VFcXVhbCBoZXJlLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgb3ZlciB0aGUgY29tcG9uZW50cyBtYW51YWxseS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvdGhlclBhdGguX2NvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBpdCdzIG5vdCBxdWl0ZSBjbGVhciB3aGV0aGVyIHRoaXMgdGVzdCBzaG91bGQgdXNlIEVxdWFscyBvciBhIHNpbXBsZSA9PSBvcGVyYXRvcixcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20veS1sb2hzZS9pbmtqcy9pc3N1ZXMvMjJcbiAgICAgICAgICAgIGlmICghb3RoZXJQYXRoLl9jb21wb25lbnRzW2ldLkVxdWFscyh0aGlzLl9jb21wb25lbnRzW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFBhdGhCeUFwcGVuZGluZ0NvbXBvbmVudChjKSB7XG4gICAgICAgIGxldCBwID0gbmV3IFBhdGgoKTtcbiAgICAgICAgcC5fY29tcG9uZW50cy5wdXNoLmFwcGx5KHAuX2NvbXBvbmVudHMsIHRoaXMuX2NvbXBvbmVudHMpO1xuICAgICAgICBwLl9jb21wb25lbnRzLnB1c2goYyk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG5QYXRoLnBhcmVudElkID0gXCJeXCI7XG4oZnVuY3Rpb24gKFBhdGgpIHtcbiAgICBjbGFzcyBDb21wb25lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihpbmRleE9yTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXhPck5hbWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IGluZGV4T3JOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4T3JOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBpc0luZGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPj0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgaXNQYXJlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09IFBhdGgucGFyZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIFRvUGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnQoUGF0aC5wYXJlbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgRXF1YWxzKG90aGVyQ29tcCkge1xuICAgICAgICAgICAgaWYgKG90aGVyQ29tcCAhPSBudWxsICYmIG90aGVyQ29tcC5pc0luZGV4ID09IHRoaXMuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggPT0gb3RoZXJDb21wLmluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PSBvdGhlckNvbXAubmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUGF0aC5Db21wb25lbnQgPSBDb21wb25lbnQ7XG59KShQYXRoID0gZXhwb3J0cy5QYXRoIHx8IChleHBvcnRzLlBhdGggPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGF0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9pbnRlciA9IHZvaWQgMDtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jbGFzcyBQb2ludGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzb2x2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gdGhpcy5jb250YWluZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLmNvbnRlbnRbdGhpcy5pbmRleF07XG4gICAgfVxuICAgIGdldCBpc051bGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lciA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOdWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID49IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIucGF0aC5QYXRoQnlBcHBlbmRpbmdDb21wb25lbnQobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudCh0aGlzLmluZGV4KSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5wYXRoO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcilcbiAgICAgICAgICAgIHJldHVybiBcIkluayBQb2ludGVyIChudWxsKVwiO1xuICAgICAgICByZXR1cm4gKFwiSW5rIFBvaW50ZXIgLT4gXCIgK1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgIFwiIC0tIGluZGV4IFwiICtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgQyMgY29kZSwgYnV0IGlzIGhlcmUgdG8gbWFpbnRhaW4gdGhlXG4gICAgLy8gdmFsdWUgc2VtYW50aWNzIG9mIFBvaW50ZXIuXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludGVyKHRoaXMuY29udGFpbmVyLCB0aGlzLmluZGV4KTtcbiAgICB9XG4gICAgc3RhdGljIFN0YXJ0T2YoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnRlcihjb250YWluZXIsIDApO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE51bGwoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnRlcihudWxsLCAtMSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2ludGVyID0gUG9pbnRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvaW50ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1c2hQb3BUeXBlID0gdm9pZCAwO1xudmFyIFB1c2hQb3BUeXBlO1xuKGZ1bmN0aW9uIChQdXNoUG9wVHlwZSkge1xuICAgIFB1c2hQb3BUeXBlW1B1c2hQb3BUeXBlW1wiVHVubmVsXCJdID0gMF0gPSBcIlR1bm5lbFwiO1xuICAgIFB1c2hQb3BUeXBlW1B1c2hQb3BUeXBlW1wiRnVuY3Rpb25cIl0gPSAxXSA9IFwiRnVuY3Rpb25cIjtcbiAgICBQdXNoUG9wVHlwZVtQdXNoUG9wVHlwZVtcIkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lXCJdID0gMl0gPSBcIkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lXCI7XG59KShQdXNoUG9wVHlwZSA9IGV4cG9ydHMuUHVzaFBvcFR5cGUgfHwgKGV4cG9ydHMuUHVzaFBvcFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVzaFBvcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VhcmNoUmVzdWx0ID0gdm9pZCAwO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jbGFzcyBTZWFyY2hSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9iaiA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwcm94aW1hdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGNvcnJlY3RPYmooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcHJveGltYXRlID8gbnVsbCA6IHRoaXMub2JqO1xuICAgIH1cbiAgICBnZXQgY29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmogaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIgPyB0aGlzLm9iaiA6IG51bGw7XG4gICAgfVxuICAgIGNvcHkoKSB7XG4gICAgICAgIGxldCBzZWFyY2hSZXN1bHQgPSBuZXcgU2VhcmNoUmVzdWx0KCk7XG4gICAgICAgIHNlYXJjaFJlc3VsdC5vYmogPSB0aGlzLm9iajtcbiAgICAgICAgc2VhcmNoUmVzdWx0LmFwcHJveGltYXRlID0gdGhpcy5hcHByb3hpbWF0ZTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlNlYXJjaFJlc3VsdCA9IFNlYXJjaFJlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlYXJjaFJlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlSnNvbiA9IHZvaWQgMDtcbmNsYXNzIFNpbXBsZUpzb24ge1xuICAgIHN0YXRpYyBUZXh0VG9EaWN0aW9uYXJ5KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVKc29uLlJlYWRlcih0ZXh0KS5Ub0RpY3Rpb25hcnkoKTtcbiAgICB9XG4gICAgc3RhdGljIFRleHRUb0FycmF5KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW1wbGVKc29uLlJlYWRlcih0ZXh0KS5Ub0FycmF5KCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVKc29uID0gU2ltcGxlSnNvbjtcbihmdW5jdGlvbiAoU2ltcGxlSnNvbikge1xuICAgIGNsYXNzIFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvb3RPYmplY3QgPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIFRvRGljdGlvbmFyeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIFRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdE9iamVjdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTaW1wbGVKc29uLlJlYWRlciA9IFJlYWRlcjtcbiAgICAvLyBJbiBDIywgdGhpcyBjbGFzcyB3cml0ZXMganNvbiB0b2tlbnMgZGlyZWN0bHkgdG8gYSBTdHJpbmdXcml0ZXIgb3JcbiAgICAvLyBhbm90aGVyIHN0cmVhbS4gSGVyZSwgYSB0ZW1wb3JhcnkgaGllcmFyY2h5IGlzIGNyZWF0ZWQgaW4gdGhlIGZvcm1cbiAgICAvLyBvZiBhIGphdmFzY3JpcHQgb2JqZWN0LCB3aGljaCBpcyBzZXJpYWxpc2VkIGluIHRoZSBgdG9TdHJpbmdgIG1ldGhvZC5cbiAgICAvLyBTZWUgaW5kaXZpZHVhbCBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgIGNsYXNzIFdyaXRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgLy8gSW4gYWRkaXRpb24gdG8gYF9zdGF0ZVN0YWNrYCBwcmVzZW50IGluIHRoZSBvcmlnaW5hbCBjb2RlLFxuICAgICAgICAgICAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBvZiBTaW1wbGVKc29uIHVzZSB0d28gb3RoZXIgc3RhY2tzIGFuZCB0d29cbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSB2YXJpYWJsZXMgaG9sZGluZyB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgICAgICAgICAgLy8gVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHByb3BlcnR5IG5hbWUgYmVpbmcgYnVpbHRcbiAgICAgICAgICAgIC8vIHdpdGggYFdyaXRlUHJvcGVydHlOYW1lU3RhcnRgLCBgV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcmAgYW5kXG4gICAgICAgICAgICAvLyBgV3JpdGVQcm9wZXJ0eU5hbWVFbmRgLlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgc3RyaW5nIHZhbHVlIGJlaW5nIGJ1aWx0XG4gICAgICAgICAgICAvLyB3aXRoIGBXcml0ZVN0cmluZ1N0YXJ0YCwgYFdyaXRlU3RyaW5nSW5uZXJgIGFuZFxuICAgICAgICAgICAgLy8gYFdyaXRlU3RyaW5nRW5kYC5cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGJlaW5nIGJ1aWx0IChlaXRoZXIgYW4gYXJyYXlcbiAgICAgICAgICAgIC8vIG9yIGFuIG9iamVjdCkuIEZvciBpbnN0YW5jZSwgYXQgdGhlICc/JyBzdGVwIGR1cmluZyB0aGUgaGlhcmNoeVxuICAgICAgICAgICAgLy8gY3JlYXRpb24sIHRoaXMgaGllcmFyY2h5OlxuICAgICAgICAgICAgLy8gWzMsIHthOiBbYiwgP119XSB3aWxsIGhhdmUgdGhpcyBjb3JyZXNwb25kaW5nIHN0YWNrOlxuICAgICAgICAgICAgLy8gKGJvdHRvbSkgW0FycmF5LCBPYmplY3QsIEFycmF5XSAodG9wKVxuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrID0gW107XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IHByb3BlcnR5IGJlaW5nIGFzc2lnbmVkLiBGb3IgaW5zdGFuY2UsIGF0XG4gICAgICAgICAgICAvLyB0aGUgJz8nIHN0ZXAgZHVyaW5nIHRoZSBoaWFyY2h5IGNyZWF0aW9uLCB0aGlzIGhpZXJhcmNoeTpcbiAgICAgICAgICAgIC8vIFszLCB7YTogW2IsIHtjOiA/fV19XSB3aWxsIGhhdmUgdGhpcyBjb3JyZXNwb25kaW5nIHN0YWNrOlxuICAgICAgICAgICAgLy8gKGJvdHRvbSkgW2EsIGNdICh0b3ApXG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjayA9IFtdO1xuICAgICAgICAgICAgLy8gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVudGlyZSBoaWVhcmNoeS5cbiAgICAgICAgICAgIHRoaXMuX2pzb25PYmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlT2JqZWN0KGlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGlubmVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIG5ldyBvYmplY3QuXG4gICAgICAgIFdyaXRlT2JqZWN0U3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KHRydWUpO1xuICAgICAgICAgICAgbGV0IG5ld09iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgY3JlYXRlZCBhcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gb3RoZXIgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5TmFtZSA9IHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb25bcHJvcGVydHlOYW1lXSA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyBjcmVhdGVkIGFzIHRoZSBjaGlsZCBvZiBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBvYmplY3QgaXMgdGhlIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzb25PYmplY3QgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlT2JqZWN0RW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuT2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV3JpdGUgYSBwcm9wZXJ0eSBuYW1lIC8gdmFsdWUgcGFpciB0byB0aGUgY3VycmVudCBvYmplY3QuXG4gICAgICAgIFdyaXRlUHJvcGVydHkobmFtZSwgaW5uZXJPckNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIGlubmVyKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5Xcml0ZShjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludCBhbmQgRmxvYXQgYXJlIHNlcGFyYXRlIGNhbGxzLCBzaW5jZSB0aGVyZSBib3RoIGFyZVxuICAgICAgICAvLyBudW1iZXJzIGluIEphdmFTY3JpcHQsIGJ1dCBuZWVkIHRvIGJlIGhhbmRsZWQgZGlmZmVyZW50bHkuXG4gICAgICAgIFdyaXRlSW50UHJvcGVydHkobmFtZSwgY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICB0aGlzLldyaXRlSW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVGbG9hdFByb3BlcnR5KG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZUZsb2F0KGNvbnRlbnQpO1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBhIG5ldyBwcm9wZXJ0eSBuYW1lLCB3aGljaCB3aWxsIGJlIHVzZSB0byBhZGQgdGhlXG4gICAgICAgIC8vIG5ldyBvYmplY3Qgd2hlbiBjYWxsaW5nIF9hZGRUb0N1cnJlbnRPYmplY3QoKSBmcm9tIGEgV3JpdGVcbiAgICAgICAgLy8gbWV0aG9kLlxuICAgICAgICBXcml0ZVByb3BlcnR5U3RhcnQobmFtZSkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuT2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnB1c2gobmFtZSk7XG4gICAgICAgICAgICB0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVQcm9wZXJ0eUVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY2hpbGRDb3VudCA9PT0gMSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgYSBuZXcgcHJvcGVydHkgbmFtZSwgZXhjZXB0IHRoaXMgdGltZSwgdGhlIHByb3BlcnR5IG5hbWVcbiAgICAgICAgLy8gd2lsbCBiZSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgYWxsIHRoZSBzdHJpbmdzIHBhc3NlZCB0b1xuICAgICAgICAvLyBXcml0ZVByb3BlcnR5TmFtZUlubmVyLlxuICAgICAgICBXcml0ZVByb3BlcnR5TmFtZVN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuT2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHlOYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVQcm9wZXJ0eU5hbWVFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wdXNoKHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlUHJvcGVydHlOYW1lSW5uZXIoc3RyKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lICs9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYSBuZXcgYXJyYXkuXG4gICAgICAgIFdyaXRlQXJyYXlTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QodHJ1ZSk7XG4gICAgICAgICAgICBsZXQgbmV3T2JqZWN0ID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFycmF5IGlzIGNyZWF0ZWQgYXMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWUgIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIGxldCBwcm9wZXJ0eU5hbWUgPSB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3Byb3BlcnR5TmFtZV0gPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhcnJheSBpcyBjcmVhdGVkIGFzIHRoZSBjaGlsZCBvZiBhbm90aGVyIGFycmF5LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHRoZSByb290IG9iamVjdC5cbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9qc29uT2JqZWN0ID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlQXJyYXlFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSk7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgdmFsdWUgdG8gdGhlIGFwcHJvcHJpYXRlIGNvbGxlY3Rpb24gKGFycmF5IC8gb2JqZWN0KSwgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gY29udGV4dC5cbiAgICAgICAgV3JpdGUodmFsdWUsIGVzY2FwZSA9IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB0cnlpbmcgdG8gd3JpdGUgYSBudWxsIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVJbnQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBpcyB1c2VkIGFzIGEgcHJlY2F1dGlvbjpcbiAgICAgICAgICAgIC8vICAgICAxLiB0byBlbnN1cmUgdGhhdCB0aGUgdmFsdWUgaXMgd3JpdHRlbiBhcyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICAvLyAgICAgICAgKHdpdGhvdXQgYSBmcmFjdGlvbmFsIHBhcnQgLT4gMSBpbnN0ZWFkIG9mIDEuMCksIGV2ZW5cbiAgICAgICAgICAgIC8vICAgICAgICB0aG91Z2ggaXQgc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZlxuICAgICAgICAgICAgLy8gICAgICAgIEpTT04uc2VyaWFsaXplO1xuICAgICAgICAgICAgLy8gICAgIDIuIHRvIGVuc3VyZSB0aGF0IGlmIGEgZmxvYXRpbmcgbnVtYmVyIGlzIHBhc3NlZFxuICAgICAgICAgICAgLy8gICAgICAgIGFjY2lkZW50YWxseSwgaXQncyBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGd1YXJhbnRlZXMgc2F2ZWdhbWUgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgIC8vIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KE1hdGguZmxvb3IodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaW5jZSBKU09OIGRvZXNuJ3Qgc3VwcG9ydCBOYU4gYW5kIEluZmluaXR5LCB0aGVzZSB2YWx1ZXNcbiAgICAgICAgLy8gYXJlIGNvbnZlcnRlZCBoZXJlLlxuICAgICAgICBXcml0ZUZsb2F0KHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoMy40ZTM4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgtMy40ZTM4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgwLjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBXcml0ZU51bGwoKSB7XG4gICAgICAgICAgICB0aGlzLlN0YXJ0TmV3T2JqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIGEgc3RyaW5nIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlvbiBpblxuICAgICAgICAvLyBXcml0ZVN0cmluZ0VuZCgpLiBUaGUgc3RyaW5nIHdpbGwgYmUgYSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0aGVcbiAgICAgICAgLy8gc3RyaW5ncyBwYXNzZWQgdG8gV3JpdGVTdHJpbmdJbm5lci5cbiAgICAgICAgV3JpdGVTdHJpbmdTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5TdHJpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVN0cmluZ0VuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuU3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodGhpcy5fY3VycmVudFN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVN0cmluZ0lubmVyKHN0ciwgZXNjYXBlID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogdHJ5aW5nIHRvIHdyaXRlIGEgbnVsbCBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyArPSBzdHI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VyaWFsaXNlIHRoZSByb290IG9iamVjdCBpbnRvIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgIFRvU3RyaW5nKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2pzb25PYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLl9qc29uT2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIHRoZSBzdGF0ZSBzdGFjayB3aGVuIGFkZGluZyBuZXcgb2JqZWN0cyAvIHZhbHVlcy5cbiAgICAgICAgU3RhcnROZXdPYmplY3QoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLmNoaWxkQ291bnQgPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkluY3JlbWVudENoaWxkQ291bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSBnZXR0ZXJzIHBlZWsgYWxsIHRoZSBkaWZmZXJlbnQgc3RhY2tzLlxuICAgICAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RhY2tbdGhpcy5fc3RhdGVTdGFjay5sZW5ndGggLSAxXS50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNoaWxkQ291bnQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlU3RhY2tbdGhpcy5fc3RhdGVTdGFjay5sZW5ndGggLSAxXS5jaGlsZENvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGN1cnJlbnRDb2xsZWN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbGxlY3Rpb25TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb25TdGFja1t0aGlzLl9jb2xsZWN0aW9uU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgY3VycmVudFByb3BlcnR5TmFtZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrW3RoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgSW5jcmVtZW50Q2hpbGRDb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX3N0YXRlU3RhY2subGVuZ3RoID4gMCk7XG4gICAgICAgICAgICBsZXQgY3VyckVsID0gdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGN1cnJFbC5jaGlsZENvdW50Kys7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2goY3VyckVsKTtcbiAgICAgICAgfVxuICAgICAgICBBc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmRpdGlvbilcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkFzc2VydCBmYWlsZWQgd2hpbGUgd3JpdGluZyBKU09OXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGRpZCBub3QgZXhpc3QgaW4gdGhlIG9yaWdpbmFsIEMjIGNvZGUuIEl0IGFkZHNcbiAgICAgICAgLy8gdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gKHVzZWQgYnkgV3JpdGUgbWV0aG9kcykuXG4gICAgICAgIF9hZGRUb0N1cnJlbnRPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoQXJyYXkuaXNBcnJheSh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoIUFycmF5LmlzQXJyYXkodGhpcy5jdXJyZW50Q29sbGVjdGlvbikpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvblt0aGlzLmN1cnJlbnRQcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2ltcGxlSnNvbi5Xcml0ZXIgPSBXcml0ZXI7XG4gICAgKGZ1bmN0aW9uIChXcml0ZXIpIHtcbiAgICAgICAgbGV0IFN0YXRlO1xuICAgICAgICAoZnVuY3Rpb24gKFN0YXRlKSB7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJPYmplY3RcIl0gPSAxXSA9IFwiT2JqZWN0XCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIkFycmF5XCJdID0gMl0gPSBcIkFycmF5XCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlByb3BlcnR5XCJdID0gM10gPSBcIlByb3BlcnR5XCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIlByb3BlcnR5TmFtZVwiXSA9IDRdID0gXCJQcm9wZXJ0eU5hbWVcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiU3RyaW5nXCJdID0gNV0gPSBcIlN0cmluZ1wiO1xuICAgICAgICB9KShTdGF0ZSA9IFdyaXRlci5TdGF0ZSB8fCAoV3JpdGVyLlN0YXRlID0ge30pKTtcbiAgICAgICAgY2xhc3MgU3RhdGVFbGVtZW50IHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBXcml0ZXIuU3RhdGVFbGVtZW50ID0gU3RhdGVFbGVtZW50O1xuICAgIH0pKFdyaXRlciA9IFNpbXBsZUpzb24uV3JpdGVyIHx8IChTaW1wbGVKc29uLldyaXRlciA9IHt9KSk7XG59KShTaW1wbGVKc29uID0gZXhwb3J0cy5TaW1wbGVKc29uIHx8IChleHBvcnRzLlNpbXBsZUpzb24gPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2ltcGxlSnNvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdGVQYXRjaCA9IHZvaWQgMDtcbmNsYXNzIFN0YXRlUGF0Y2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGFyZ3VtZW50c1swXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHRvQ29weSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbHMgPSBuZXcgTWFwKHRvQ29weS5fZ2xvYmFscyk7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzID0gbmV3IFNldCh0b0NvcHkuX2NoYW5nZWRWYXJpYWJsZXMpO1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMgPSBuZXcgTWFwKHRvQ29weS5fdmlzaXRDb3VudHMpO1xuICAgICAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBuZXcgTWFwKHRvQ29weS5fdHVybkluZGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBnbG9iYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFscztcbiAgICB9XG4gICAgZ2V0IGNoYW5nZWRWYXJpYWJsZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzO1xuICAgIH1cbiAgICBnZXQgdmlzaXRDb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdENvdW50cztcbiAgICB9XG4gICAgZ2V0IHR1cm5JbmRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHVybkluZGljZXM7XG4gICAgfVxuICAgIFRyeUdldEdsb2JhbChuYW1lLCAvKiBvdXQgKi8gdmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgdGhpcy5fZ2xvYmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fZ2xvYmFscy5nZXQobmFtZSksIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgU2V0R2xvYmFsKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbHMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgQWRkQ2hhbmdlZFZhcmlhYmxlKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMuYWRkKG5hbWUpO1xuICAgIH1cbiAgICBUcnlHZXRWaXNpdENvdW50KGNvbnRhaW5lciwgLyogb3V0ICovIGNvdW50KSB7XG4gICAgICAgIGlmICh0aGlzLl92aXNpdENvdW50cy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl92aXNpdENvdW50cy5nZXQoY29udGFpbmVyKSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBjb3VudCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBTZXRWaXNpdENvdW50KGNvbnRhaW5lciwgY291bnQpIHtcbiAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMuc2V0KGNvbnRhaW5lciwgY291bnQpO1xuICAgIH1cbiAgICBTZXRUdXJuSW5kZXgoY29udGFpbmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcy5zZXQoY29udGFpbmVyLCBpbmRleCk7XG4gICAgfVxuICAgIFRyeUdldFR1cm5JbmRleChjb250YWluZXIsIC8qIG91dCAqLyBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5fdHVybkluZGljZXMuaGFzKGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdGhpcy5fdHVybkluZGljZXMuZ2V0KGNvbnRhaW5lciksIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogaW5kZXgsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnRzLlN0YXRlUGF0Y2ggPSBTdGF0ZVBhdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RhdGVQYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcHdhdGNoID0gdm9pZCAwO1xuLy8gVGhpcyBpcyBzaW1wbGUgcmVwbGFjZW1lbnQgb2YgdGhlIFN0b3B3YXRjaCBjbGFzcyBmcm9tIHRoZSAuTkVUIEZyYW1ld29yay5cbi8vIFRoZSBvcmlnaW5hbCBjbGFzcyBjYW4gY291bnQgdGltZSB3aXRoIG11Y2ggbW9yZSBhY2N1cmFjeSB0aGFuIHRoZSBKYXZhc2NyaXB0IHZlcnNpb24uXG4vLyBJdCBtaWdodCBiZSB3b3J0aCBjb25zaWRlcmluZyB1c2luZyBgd2luZG93LnBlcmZvcm1hbmNlYCBpbiB0aGUgYnJvd3NlclxuLy8gb3IgYHByb2Nlc3MuaHJ0aW1lKClgIGluIG5vZGUuXG5jbGFzcyBTdG9wd2F0Y2gge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IEVsYXBzZWRNaWxsaXNlY29uZHMoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGFydFRpbWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuc3RhcnRUaW1lO1xuICAgIH1cbiAgICBTdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG4gICAgU3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9wd2F0Y2ggPSBTdG9wd2F0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9wV2F0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3J5ID0gdm9pZCAwO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFN0b3J5U3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0b3J5U3RhdGVcIik7XG5jb25zdCBDb250cm9sQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29udHJvbENvbW1hbmRcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgQ2hvaWNlUG9pbnRfMSA9IHJlcXVpcmUoXCIuL0Nob2ljZVBvaW50XCIpO1xuY29uc3QgQ2hvaWNlXzEgPSByZXF1aXJlKFwiLi9DaG9pY2VcIik7XG5jb25zdCBEaXZlcnRfMSA9IHJlcXVpcmUoXCIuL0RpdmVydFwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBWb2lkXzEgPSByZXF1aXJlKFwiLi9Wb2lkXCIpO1xuY29uc3QgVGFnXzEgPSByZXF1aXJlKFwiLi9UYWdcIik7XG5jb25zdCBWYXJpYWJsZUFzc2lnbm1lbnRfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlQXNzaWdubWVudFwiKTtcbmNvbnN0IFZhcmlhYmxlUmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZVJlZmVyZW5jZVwiKTtcbmNvbnN0IE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xID0gcmVxdWlyZShcIi4vTmF0aXZlRnVuY3Rpb25DYWxsXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgUFJOR18xID0gcmVxdWlyZShcIi4vUFJOR1wiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMSA9IHJlcXVpcmUoXCIuL0xpc3REZWZpbml0aW9uc09yaWdpblwiKTtcbmNvbnN0IFN0b3BXYXRjaF8xID0gcmVxdWlyZShcIi4vU3RvcFdhdGNoXCIpO1xuY29uc3QgUG9pbnRlcl8xID0gcmVxdWlyZShcIi4vUG9pbnRlclwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFNpbXBsZUpzb25fMSA9IHJlcXVpcmUoXCIuL1NpbXBsZUpzb25cIik7XG52YXIgSW5rTGlzdF8yID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklua0xpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIElua0xpc3RfMi5JbmtMaXN0OyB9IH0pO1xuaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKSB7XG4gICAgTnVtYmVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uIGlzSW50ZWdlcihuVmFsKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIG5WYWwgPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGlzRmluaXRlKG5WYWwpICYmXG4gICAgICAgICAgICBuVmFsID4gLTkwMDcxOTkyNTQ3NDA5OTIgJiZcbiAgICAgICAgICAgIG5WYWwgPCA5MDA3MTk5MjU0NzQwOTkyICYmXG4gICAgICAgICAgICBNYXRoLmZsb29yKG5WYWwpID09PSBuVmFsKTtcbiAgICB9O1xufVxuY2xhc3MgU3RvcnkgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlua1ZlcnNpb25NaW5pbXVtQ29tcGF0aWJsZSA9IDE4O1xuICAgICAgICB0aGlzLl9wcmV2Q29udGFpbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9saXN0RGVmaW5pdGlvbnMgPSBudWxsO1xuICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLl9hc3luY1NhdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wcm9maWxlciA9IG51bGw7IC8vIFRPRE86IFByb2ZpbGVyXG4gICAgICAgIC8vIERpc2NyaW1pbmF0aW9uIGJldHdlZW4gY29uc3RydWN0b3JzXG4gICAgICAgIGxldCBjb250ZW50Q29udGFpbmVyO1xuICAgICAgICBsZXQgbGlzdHMgPSBudWxsO1xuICAgICAgICBsZXQganNvbiA9IG51bGw7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRlbnRDb250YWluZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1sxXSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGxpc3RzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tLS0tIFN0b3J5IChDb250YWluZXIgY29udGVudENvbnRhaW5lciwgTGlzdDxSdW50aW1lLkxpc3REZWZpbml0aW9uPiBsaXN0cyA9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lciA9IGNvbnRlbnRDb250YWluZXI7XG4gICAgICAgICAgICAvLyAtLS0tLS1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGpzb25TdHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAganNvbiA9IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLlRleHRUb0RpY3Rpb25hcnkoanNvblN0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBqc29uID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLSBTdG9yeSAoQ29udGFpbmVyIGNvbnRlbnRDb250YWluZXIsIExpc3Q8UnVudGltZS5MaXN0RGVmaW5pdGlvbj4gbGlzdHMgPSBudWxsKVxuICAgICAgICBpZiAobGlzdHMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX2xpc3REZWZpbml0aW9ucyA9IG5ldyBMaXN0RGVmaW5pdGlvbnNPcmlnaW5fMS5MaXN0RGVmaW5pdGlvbnNPcmlnaW4obGlzdHMpO1xuICAgICAgICB0aGlzLl9leHRlcm5hbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIC0tLS0tLVxuICAgICAgICAvLyAtLS0tLS0gU3Rvcnkoc3RyaW5nIGpzb25TdHJpbmcpIDogdGhpcygoQ29udGFpbmVyKW51bGwpXG4gICAgICAgIGlmIChqc29uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgcm9vdE9iamVjdCA9IGpzb247XG4gICAgICAgICAgICBsZXQgdmVyc2lvbk9iaiA9IHJvb3RPYmplY3RbXCJpbmtWZXJzaW9uXCJdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb25PYmogPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbmsgdmVyc2lvbiBudW1iZXIgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgaXQncyBhIHZhbGlkIC5pbmsuanNvbiBmaWxlP1wiKTtcbiAgICAgICAgICAgIGxldCBmb3JtYXRGcm9tRmlsZSA9IHBhcnNlSW50KHZlcnNpb25PYmopO1xuICAgICAgICAgICAgaWYgKGZvcm1hdEZyb21GaWxlID4gU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IHdhcyBuZXdlciB0aGFuIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIGVuZ2luZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdEZyb21GaWxlIDwgdGhpcy5pbmtWZXJzaW9uTWluaW11bUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IGlzIHRvbyBvbGQgdG8gYmUgbG9hZGVkIGJ5IHRoaXMgdmVyc2lvbiBvZiB0aGUgZW5naW5lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0RnJvbUZpbGUgIT0gU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBWZXJzaW9uIG9mIGluayB1c2VkIHRvIGJ1aWxkIHN0b3J5IGRvZXNuJ3QgbWF0Y2ggY3VycmVudCB2ZXJzaW9uIG9mIGVuZ2luZS4gTm9uLWNyaXRpY2FsLCBidXQgcmVjb21tZW5kIHN5bmNocm9uaXNpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJvb3RUb2tlbiA9IHJvb3RPYmplY3RbXCJyb290XCJdO1xuICAgICAgICAgICAgaWYgKHJvb3RUb2tlbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3Qgbm9kZSBmb3IgaW5rIG5vdCBmb3VuZC4gQXJlIHlvdSBzdXJlIGl0J3MgYSB2YWxpZCAuaW5rLmpzb24gZmlsZT9cIik7XG4gICAgICAgICAgICBsZXQgbGlzdERlZnNPYmo7XG4gICAgICAgICAgICBpZiAoKGxpc3REZWZzT2JqID0gcm9vdE9iamVjdFtcImxpc3REZWZzXCJdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3REZWZpbml0aW9ucyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSlRva2VuVG9MaXN0RGVmaW5pdGlvbnMobGlzdERlZnNPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpUb2tlblRvUnVudGltZU9iamVjdChyb290VG9rZW4pLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5SZXNldFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tXG4gICAgfVxuICAgIGdldCBjdXJyZW50Q2hvaWNlcygpIHtcbiAgICAgICAgbGV0IGNob2ljZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fc3RhdGUuY3VycmVudENob2ljZXMpIHtcbiAgICAgICAgICAgIGlmICghYy5pc0ludmlzaWJsZURlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBjLmluZGV4ID0gY2hvaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY2hvaWNlcy5wdXNoKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaG9pY2VzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRleHQoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgY3VycmVudFRleHQgc2luY2UgaXQncyBhIHdvcmsgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRUZXh0O1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRhZ3MoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImNhbGwgY3VycmVudFRhZ3Mgc2luY2UgaXQncyBhIHdvcmsgaW4gcHJvZ3Jlc3NcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmN1cnJlbnRUYWdzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudEVycm9ycztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRXYXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFdhcm5pbmdzO1xuICAgIH1cbiAgICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmhhc0Vycm9yO1xuICAgIH1cbiAgICBnZXQgaGFzV2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaGFzV2FybmluZztcbiAgICB9XG4gICAgZ2V0IHZhcmlhYmxlc1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGxpc3REZWZpbml0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3REZWZpbml0aW9ucztcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuICAgIC8vIFRPRE86IEltcGxlbWVudCBQcm9maWxlclxuICAgIFN0YXJ0UHJvZmlsaW5nKCkge1xuICAgICAgICAvKiAqL1xuICAgIH1cbiAgICBFbmRQcm9maWxpbmcoKSB7XG4gICAgICAgIC8qICovXG4gICAgfVxuICAgIC8vIE1lcmdlIHRvZ2V0aGVyIGBwdWJsaWMgc3RyaW5nIFRvSnNvbigpYCBhbmQgYHZvaWQgVG9Kc29uKFNpbXBsZUpzb24uV3JpdGVyIHdyaXRlcilgLlxuICAgIC8vIFdpbGwgb25seSByZXR1cm4gYSB2YWx1ZSBpZiB3cml0ZXIgd2FzIG5vdCBwcm92aWRlZC5cbiAgICBUb0pzb24od3JpdGVyKSB7XG4gICAgICAgIGxldCBzaG91bGRSZXR1cm4gPSBmYWxzZTtcbiAgICAgICAgaWYgKCF3cml0ZXIpIHtcbiAgICAgICAgICAgIHNob3VsZFJldHVybiA9IHRydWU7XG4gICAgICAgICAgICB3cml0ZXIgPSBuZXcgU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uV3JpdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpbmtWZXJzaW9uXCIsIFN0b3J5Lmlua1ZlcnNpb25DdXJyZW50KTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJyb290XCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlUnVudGltZUNvbnRhaW5lcih3LCB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lcikpO1xuICAgICAgICBpZiAodGhpcy5fbGlzdERlZmluaXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJsaXN0RGVmc1wiKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBkZWYgb2YgdGhpcy5fbGlzdERlZmluaXRpb25zLmxpc3RzKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChkZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZGVmLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoaXRlbS5pdGVtTmFtZSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgaWYgKHNob3VsZFJldHVybilcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXIuVG9TdHJpbmcoKTtcbiAgICB9XG4gICAgUmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiUmVzZXRTdGF0ZVwiKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RvcnlTdGF0ZV8xLlN0b3J5U3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLk9ic2VydmVWYXJpYWJsZUNoYW5nZSh0aGlzLlZhcmlhYmxlU3RhdGVEaWRDaGFuZ2VFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5SZXNldEdsb2JhbHMoKTtcbiAgICB9XG4gICAgUmVzZXRFcnJvcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5SZXNldEVycm9ycygpO1xuICAgIH1cbiAgICBSZXNldENhbGxzdGFjaygpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiUmVzZXRDYWxsc3RhY2tcIik7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9zdGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZS5Gb3JjZUVuZCgpO1xuICAgIH1cbiAgICBSZXNldEdsb2JhbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYWluQ29udGVudENvbnRhaW5lci5uYW1lZENvbnRlbnQuZ2V0KFwiZ2xvYmFsIGRlY2xcIikpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbFBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMuQ2hvb3NlUGF0aChuZXcgUGF0aF8xLlBhdGgoXCJnbG9iYWwgZGVjbFwiKSwgZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5Db250aW51ZUludGVybmFsKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gb3JpZ2luYWxQb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuU25hcHNob3REZWZhdWx0R2xvYmFscygpO1xuICAgIH1cbiAgICBDb250aW51ZSgpIHtcbiAgICAgICAgdGhpcy5Db250aW51ZUFzeW5jKDApO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGV4dDtcbiAgICB9XG4gICAgZ2V0IGNhbkNvbnRpbnVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jYW5Db250aW51ZTtcbiAgICB9XG4gICAgZ2V0IGFzeW5jQ29udGludWVDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlO1xuICAgIH1cbiAgICBDb250aW51ZUFzeW5jKG1pbGxpc2Vjc0xpbWl0QXN5bmMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMpXG4gICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLkNvbnRpbnVlSW50ZXJuYWwobWlsbGlzZWNzTGltaXRBc3luYyk7XG4gICAgfVxuICAgIENvbnRpbnVlSW50ZXJuYWwobWlsbGlzZWNzTGltaXRBc3luYyA9IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5QcmVDb250aW51ZSgpO1xuICAgICAgICBsZXQgaXNBc3luY1RpbWVMaW1pdGVkID0gbWlsbGlzZWNzTGltaXRBc3luYyA+IDA7XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQrKztcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlID0gaXNBc3luY1RpbWVMaW1pdGVkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW4ndCBjb250aW51ZSAtIHNob3VsZCBjaGVjayBjYW5Db250aW51ZSBiZWZvcmUgY2FsbGluZyBDb250aW51ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmRpZFNhZmVFeGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5SZXNldE91dHB1dCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQgPT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGR1cmF0aW9uU3RvcHdhdGNoID0gbmV3IFN0b3BXYXRjaF8xLlN0b3B3YXRjaCgpO1xuICAgICAgICBkdXJhdGlvblN0b3B3YXRjaC5TdGFydCgpO1xuICAgICAgICBsZXQgb3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUgPSB0aGlzLkNvbnRpbnVlU2luZ2xlU3RlcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihlLm1lc3NhZ2UsIHVuZGVmaW5lZCwgZS51c2VFbmRMaW5lTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgJiZcbiAgICAgICAgICAgICAgICBkdXJhdGlvblN0b3B3YXRjaC5FbGFwc2VkTWlsbGlzZWNvbmRzID4gbWlsbGlzZWNzTGltaXRBc3luYykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICh0aGlzLmNhbkNvbnRpbnVlKTtcbiAgICAgICAgZHVyYXRpb25TdG9wd2F0Y2guU3RvcCgpO1xuICAgICAgICBpZiAob3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSB8fCAhdGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5SZXN0b3JlU3RhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcIlRocmVhZCBhdmFpbGFibGUgdG8gcG9wLCB0aHJlYWRzIHNob3VsZCBhbHdheXMgYmUgZmxhdCBieSB0aGUgZW5kIG9mIGV2YWx1YXRpb24/XCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMubGVuZ3RoID09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuc3RhdGUuZGlkU2FmZUV4aXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3AoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJy0+LT4nIHRvIHJldHVybiBmcm9tIGEgdHVubmVsP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwidW5leHBlY3RlZGx5IHJlYWNoZWQgZW5kIG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJ34gcmV0dXJuJz9cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwicmFuIG91dCBvZiBjb250ZW50LiBEbyB5b3UgbmVlZCBhICctPiBET05FJyBvciAnLT4gRU5EJz9cIik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudCBmb3IgdW5rbm93biByZWFzb24uIFBsZWFzZSBkZWJ1ZyBjb21waWxlciFcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQgPT0gMSlcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZS52YXJpYWJsZXNTdGF0ZS5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlY3Vyc2l2ZUNvbnRpbnVlQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5Qb3N0Q29udGludWUoKTtcbiAgICB9XG4gICAgQ29udGludWVTaW5nbGVTdGVwKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlByZVN0ZXAoKTtcbiAgICAgICAgdGhpcy5TdGVwKCk7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUG9zdFN0ZXAoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhbkNvbnRpbnVlICYmICF0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50SXNFdmFsdWF0ZUZyb21HYW1lKSB7XG4gICAgICAgICAgICB0aGlzLlRyeUZvbGxvd0RlZmF1bHRJbnZpc2libGVDaG9pY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlByZVNuYXBzaG90KCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5pblN0cmluZ0V2YWx1YXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGFncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlQXRMYXN0TmV3bGluZS5jdXJyZW50VGFnc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3VycmVudFRhZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnN0YXRlLmN1cnJlbnRUYWdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2hhbmdlID0gdGhpcy5DYWxjdWxhdGVOZXdsaW5lT3V0cHV0U3RhdGVDaGFuZ2UodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRleHQsIHRoaXMuc3RhdGUuY3VycmVudFRleHQsIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzLmxlbmd0aCwgdGhpcy5zdGF0ZS5jdXJyZW50VGFncy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UgPT0gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUmVzdG9yZVN0YXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5nZSA9PSBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5OZXdsaW5lUmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkRpc2NhcmRTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuU3RhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5EaXNjYXJkU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5Qb3N0U25hcHNob3QoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDYWxjdWxhdGVOZXdsaW5lT3V0cHV0U3RhdGVDaGFuZ2UocHJldlRleHQsIGN1cnJUZXh0LCBwcmV2VGFnQ291bnQsIGN1cnJUYWdDb3VudCkge1xuICAgICAgICBpZiAocHJldlRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicHJldlRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJUZXh0ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImN1cnJUZXh0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXdsaW5lU3RpbGxFeGlzdHMgPSBjdXJyVGV4dC5sZW5ndGggPj0gcHJldlRleHQubGVuZ3RoICYmXG4gICAgICAgICAgICBjdXJyVGV4dC5jaGFyQXQocHJldlRleHQubGVuZ3RoIC0gMSkgPT0gXCJcXG5cIjtcbiAgICAgICAgaWYgKHByZXZUYWdDb3VudCA9PSBjdXJyVGFnQ291bnQgJiZcbiAgICAgICAgICAgIHByZXZUZXh0Lmxlbmd0aCA9PSBjdXJyVGV4dC5sZW5ndGggJiZcbiAgICAgICAgICAgIG5ld2xpbmVTdGlsbEV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5Ob0NoYW5nZTtcbiAgICAgICAgaWYgKCFuZXdsaW5lU3RpbGxFeGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5OZXdsaW5lUmVtb3ZlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyclRhZ0NvdW50ID4gcHJldlRhZ0NvdW50KVxuICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHByZXZUZXh0Lmxlbmd0aDsgaSA8IGN1cnJUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IGN1cnJUZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmIChjICE9IFwiIFwiICYmIGMgIT0gXCJcXHRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5vQ2hhbmdlO1xuICAgIH1cbiAgICBDb250aW51ZU1heGltYWxseSgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiQ29udGludWVNYXhpbWFsbHlcIik7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAodGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgc2IuQXBwZW5kKHRoaXMuQ29udGludWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIENvbnRlbnRBdFBhdGgocGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgIH1cbiAgICBLbm90Q29udGFpbmVyV2l0aE5hbWUobmFtZSkge1xuICAgICAgICBsZXQgbmFtZWRDb250YWluZXIgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChuYW1lZENvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcilcbiAgICAgICAgICAgIHJldHVybiBuYW1lZENvbnRhaW5lcjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFBvaW50ZXJBdFBhdGgocGF0aCkge1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICBsZXQgcCA9IG5ldyBQb2ludGVyXzEuUG9pbnRlcigpO1xuICAgICAgICBsZXQgcGF0aExlbmd0aFRvVXNlID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAocGF0aC5sYXN0Q29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBhdGgubGFzdENvbXBvbmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sYXN0Q29tcG9uZW50LmlzSW5kZXgpIHtcbiAgICAgICAgICAgIHBhdGhMZW5ndGhUb1VzZSA9IHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoLCB1bmRlZmluZWQsIHBhdGhMZW5ndGhUb1VzZSk7XG4gICAgICAgICAgICBwLmNvbnRhaW5lciA9IHJlc3VsdC5jb250YWluZXI7XG4gICAgICAgICAgICBwLmluZGV4ID0gcGF0aC5sYXN0Q29tcG9uZW50LmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgpO1xuICAgICAgICAgICAgcC5jb250YWluZXIgPSByZXN1bHQuY29udGFpbmVyO1xuICAgICAgICAgICAgcC5pbmRleCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQub2JqID09IG51bGwgfHxcbiAgICAgICAgICAgIChyZXN1bHQub2JqID09IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIgJiYgcGF0aExlbmd0aFRvVXNlID4gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBjb250ZW50IGF0IHBhdGggJ1wiICtcbiAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICBcIicsIGFuZCBubyBhcHByb3hpbWF0aW9uIG9mIGl0IHdhcyBwb3NzaWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0LmFwcHJveGltYXRlKVxuICAgICAgICAgICAgdGhpcy5XYXJuaW5nKFwiRmFpbGVkIHRvIGZpbmQgY29udGVudCBhdCBwYXRoICdcIiArXG4gICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgXCInLCBzbyBpdCB3YXMgYXBwcm94aW1hdGVkIHRvOiAnXCIgK1xuICAgICAgICAgICAgICAgIHJlc3VsdC5vYmoucGF0aCArXG4gICAgICAgICAgICAgICAgXCInLlwiKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIFN0YXRlU25hcHNob3QoKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gdGhpcy5fc3RhdGU7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fc3RhdGUuQ29weUFuZFN0YXJ0UGF0Y2hpbmcoKTtcbiAgICB9XG4gICAgUmVzdG9yZVN0YXRlU25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5SZXN0b3JlQWZ0ZXJQYXRjaCgpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lO1xuICAgICAgICB0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNTYXZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEaXNjYXJkU25hcHNob3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXN5bmNTYXZpbmcpXG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gbnVsbDtcbiAgICB9XG4gICAgQ29weVN0YXRlRm9yQmFja2dyb3VuZFRocmVhZFNhdmUoKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcInN0YXJ0IHNhdmluZyBvbiBhIGJhY2tncm91bmQgdGhyZWFkXCIpO1xuICAgICAgICBpZiAodGhpcy5fYXN5bmNTYXZpbmcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9yeSBpcyBhbHJlYWR5IGluIGJhY2tncm91bmQgc2F2aW5nIG1vZGUsIGNhbid0IGNhbGwgQ29weVN0YXRlRm9yQmFja2dyb3VuZFRocmVhZFNhdmUgYWdhaW4hXCIpO1xuICAgICAgICBsZXQgc3RhdGVUb1NhdmUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5Db3B5QW5kU3RhcnRQYXRjaGluZygpO1xuICAgICAgICB0aGlzLl9hc3luY1NhdmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBzdGF0ZVRvU2F2ZTtcbiAgICB9XG4gICAgQmFja2dyb3VuZFNhdmVDb21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5BcHBseUFueVBhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXN5bmNTYXZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgU3RlcCgpIHtcbiAgICAgICAgbGV0IHNob3VsZEFkZFRvU3RyZWFtID0gdHJ1ZTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udGFpbmVyIGNvbnRhaW5lclRvRW50ZXIgPSBwb2ludGVyLlJlc29sdmUgKCkgYXMgQ29udGFpbmVyO1xuICAgICAgICBsZXQgY29udGFpbmVyVG9FbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb2ludGVyLlJlc29sdmUoKSwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lclRvRW50ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuVmlzaXRDb250YWluZXIoY29udGFpbmVyVG9FbnRlciwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBObyBjb250ZW50PyB0aGUgbW9zdCB3ZSBjYW4gZG8gaXMgc3RlcCBwYXN0IGl0XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyVG9FbnRlci5jb250ZW50Lmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihjb250YWluZXJUb0VudGVyKTtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lclRvRW50ZXIgPSBwb2ludGVyLlJlc29sdmUoKSBhcyBDb250YWluZXI7XG4gICAgICAgICAgICBjb250YWluZXJUb0VudGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvaW50ZXIuUmVzb2x2ZSgpLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSBwb2ludGVyLmNvcHkoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5TdGVwKHRoaXMuc3RhdGUuY2FsbFN0YWNrKTtcbiAgICAgICAgLy8gSXMgdGhlIGN1cnJlbnQgY29udGVudCBvYmplY3Q6XG4gICAgICAgIC8vICAtIE5vcm1hbCBjb250ZW50XG4gICAgICAgIC8vICAtIE9yIGEgbG9naWMvZmxvdyBzdGF0ZW1lbnQgLSBpZiBzbywgZG8gaXRcbiAgICAgICAgLy8gU3RvcCBmbG93IGlmIHdlIGhpdCBhIHN0YWNrIHBvcCB3aGVuIHdlJ3JlIHVuYWJsZSB0byBwb3AgKGUuZy4gcmV0dXJuL2RvbmUgc3RhdGVtZW50IGluIGtub3RcbiAgICAgICAgLy8gdGhhdCB3YXMgZGl2ZXJ0ZWQgdG8gcmF0aGVyIHRoYW4gY2FsbGVkIGFzIGEgZnVuY3Rpb24pXG4gICAgICAgIGxldCBjdXJyZW50Q29udGVudE9iaiA9IHBvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICBsZXQgaXNMb2dpY09yRmxvd0NvbnRyb2wgPSB0aGlzLlBlcmZvcm1Mb2dpY0FuZEZsb3dDb250cm9sKGN1cnJlbnRDb250ZW50T2JqKTtcbiAgICAgICAgLy8gSGFzIGZsb3cgYmVlbiBmb3JjZWQgdG8gZW5kIGJ5IGZsb3cgY29udHJvbCBhYm92ZT9cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTG9naWNPckZsb3dDb250cm9sKSB7XG4gICAgICAgICAgICBzaG91bGRBZGRUb1N0cmVhbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENob2ljZSB3aXRoIGNvbmRpdGlvbj9cbiAgICAgICAgLy8gdmFyIGNob2ljZVBvaW50ID0gY3VycmVudENvbnRlbnRPYmogYXMgQ2hvaWNlUG9pbnQ7XG4gICAgICAgIGxldCBjaG9pY2VQb2ludCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGVudE9iaiwgQ2hvaWNlUG9pbnRfMS5DaG9pY2VQb2ludCk7XG4gICAgICAgIGlmIChjaG9pY2VQb2ludCkge1xuICAgICAgICAgICAgbGV0IGNob2ljZSA9IHRoaXMuUHJvY2Vzc0Nob2ljZShjaG9pY2VQb2ludCk7XG4gICAgICAgICAgICBpZiAoY2hvaWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLnB1c2goY2hvaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRDb250ZW50T2JqID0gbnVsbDtcbiAgICAgICAgICAgIHNob3VsZEFkZFRvU3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvbnRhaW5lciBoYXMgbm8gY29udGVudCwgdGhlbiBpdCB3aWxsIGJlXG4gICAgICAgIC8vIHRoZSBcImNvbnRlbnRcIiBpdHNlbGYsIGJ1dCB3ZSBza2lwIG92ZXIgaXQuXG4gICAgICAgIGlmIChjdXJyZW50Q29udGVudE9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgc2hvdWxkQWRkVG9TdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb250ZW50IHRvIGFkZCB0byBldmFsdWF0aW9uIHN0YWNrIG9yIHRoZSBvdXRwdXQgc3RyZWFtXG4gICAgICAgIGlmIChzaG91bGRBZGRUb1N0cmVhbSkge1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgcHVzaGluZyBhIHZhcmlhYmxlIHBvaW50ZXIgb250byB0aGUgZXZhbHVhdGlvbiBzdGFjaywgZW5zdXJlIHRoYXQgaXQncyBzcGVjaWZpY1xuICAgICAgICAgICAgLy8gdG8gb3VyIGN1cnJlbnQgKHBvc3NpYmx5IHRlbXBvcmFyeSkgY29udGV4dCBpbmRleC4gQW5kIG1ha2UgYSBjb3B5IG9mIHRoZSBwb2ludGVyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHdlJ3JlIG5vdCBlZGl0aW5nIHRoZSBvcmlnaW5hbCBydW50aW1lIG9iamVjdC5cbiAgICAgICAgICAgIC8vIHZhciB2YXJQb2ludGVyID0gY3VycmVudENvbnRlbnRPYmogYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgICAgICBsZXQgdmFyUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGVudE9iaiwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFyUG9pbnRlciAmJiB2YXJQb2ludGVyLmNvbnRleHRJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBuZXcgb2JqZWN0IHNvIHdlJ3JlIG5vdCBvdmVyd3JpdGluZyB0aGUgc3RvcnkncyBvd24gZGF0YVxuICAgICAgICAgICAgICAgIGxldCBjb250ZXh0SWR4ID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suQ29udGV4dEZvclZhcmlhYmxlTmFtZWQodmFyUG9pbnRlci52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZW50T2JqID0gbmV3IFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUodmFyUG9pbnRlci52YXJpYWJsZU5hbWUsIGNvbnRleHRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhwcmVzc2lvbiBldmFsdWF0aW9uIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soY3VycmVudENvbnRlbnRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT3V0cHV0IHN0cmVhbSBjb250ZW50IChpLmUuIG5vdCBleHByZXNzaW9uIGV2YWx1YXRpb24pXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShjdXJyZW50Q29udGVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSBjb250ZW50IHBvaW50ZXIsIGZvbGxvd2luZyBkaXZlcnRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0aGlzLk5leHRDb250ZW50KCk7XG4gICAgICAgIC8vIFN0YXJ0aW5nIGEgdGhyZWFkIHNob3VsZCBiZSBkb25lIGFmdGVyIHRoZSBpbmNyZW1lbnQgdG8gdGhlIGNvbnRlbnQgcG9pbnRlcixcbiAgICAgICAgLy8gc28gdGhhdCB3aGVuIHJldHVybmluZyBmcm9tIHRoZSB0aHJlYWQsIGl0IHJldHVybnMgdG8gdGhlIGNvbnRlbnQgYWZ0ZXIgdGhpcyBpbnN0cnVjdGlvbi5cbiAgICAgICAgLy8gdmFyIGNvbnRyb2xDbWQgPSBjdXJyZW50Q29udGVudE9iaiBhcyA7XG4gICAgICAgIGxldCBjb250cm9sQ21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250ZW50T2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgaWYgKGNvbnRyb2xDbWQgJiZcbiAgICAgICAgICAgIGNvbnRyb2xDbWQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TdGFydFRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaFRocmVhZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFZpc2l0Q29udGFpbmVyKGNvbnRhaW5lciwgYXRTdGFydCkge1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5jb3VudGluZ0F0U3RhcnRPbmx5IHx8IGF0U3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIudmlzaXRzU2hvdWxkQmVDb3VudGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuSW5jcmVtZW50VmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5SZWNvcmRUdXJuSW5kZXhWaXNpdFRvQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCkge1xuICAgICAgICBsZXQgcHJldmlvdXNQb2ludGVyID0gdGhpcy5zdGF0ZS5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAocG9pbnRlci5pc051bGwgfHwgcG9pbnRlci5pbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcHJldkNvbnRhaW5lcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKCFwcmV2aW91c1BvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAvLyBDb250YWluZXIgcHJldkFuY2VzdG9yID0gcHJldmlvdXNQb2ludGVyLlJlc29sdmUoKSBhcyBDb250YWluZXIgPz8gcHJldmlvdXNQb2ludGVyLmNvbnRhaW5lciBhcyBDb250YWluZXI7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRQcmV2aW91c0FuY2VzdG9yID0gcHJldmlvdXNQb2ludGVyLlJlc29sdmUoKTtcbiAgICAgICAgICAgIGxldCBwcmV2QW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocmVzb2x2ZWRQcmV2aW91c0FuY2VzdG9yLCBDb250YWluZXJfMS5Db250YWluZXIpIHx8XG4gICAgICAgICAgICAgICAgVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHByZXZpb3VzUG9pbnRlci5jb250YWluZXIsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICB3aGlsZSAocHJldkFuY2VzdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcHJldkNvbnRhaW5lcnMucHVzaChwcmV2QW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgIC8vIHByZXZBbmNlc3RvciA9IHByZXZBbmNlc3Rvci5wYXJlbnQgYXMgQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIHByZXZBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwcmV2QW5jZXN0b3IucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9IHBvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICBpZiAoY3VycmVudENoaWxkT2ZDb250YWluZXIgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ29udGFpbmVyIGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyLnBhcmVudCBhcyBDb250YWluZXI7XG4gICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENoaWxkT2ZDb250YWluZXIucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB3aGlsZSAoY3VycmVudENvbnRhaW5lckFuY2VzdG9yICYmXG4gICAgICAgICAgICAodGhpcy5fcHJldkNvbnRhaW5lcnMuaW5kZXhPZihjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IpIDwgMCB8fFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5jb3VudGluZ0F0U3RhcnRPbmx5KSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIGFuY2VzdG9yIGNvbnRhaW5lciBpcyBiZWluZyBlbnRlcmVkIGF0IHRoZSBzdGFydCxcbiAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIHdoZXRoZXIgdGhlIGNoaWxkIG9iamVjdCBpcyB0aGUgZmlyc3QuXG4gICAgICAgICAgICBsZXQgZW50ZXJpbmdBdFN0YXJ0ID0gY3VycmVudENvbnRhaW5lckFuY2VzdG9yLmNvbnRlbnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID09IGN1cnJlbnRDb250YWluZXJBbmNlc3Rvci5jb250ZW50WzBdO1xuICAgICAgICAgICAgLy8gTWFyayBhIHZpc2l0IHRvIHRoaXMgY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLlZpc2l0Q29udGFpbmVyKGN1cnJlbnRDb250YWluZXJBbmNlc3RvciwgZW50ZXJpbmdBdFN0YXJ0KTtcbiAgICAgICAgICAgIGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID0gY3VycmVudENvbnRhaW5lckFuY2VzdG9yO1xuICAgICAgICAgICAgLy8gY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gY3VycmVudENvbnRhaW5lckFuY2VzdG9yLnBhcmVudCBhcyBDb250YWluZXI7XG4gICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRhaW5lckFuY2VzdG9yLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQcm9jZXNzQ2hvaWNlKGNob2ljZVBvaW50KSB7XG4gICAgICAgIGxldCBzaG93Q2hvaWNlID0gdHJ1ZTtcbiAgICAgICAgLy8gRG9uJ3QgY3JlYXRlIGNob2ljZSBpZiBjaG9pY2UgcG9pbnQgZG9lc24ndCBwYXNzIGNvbmRpdGlvbmFsXG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5oYXNDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGxldCBjb25kaXRpb25WYWx1ZSA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuSXNUcnV0aHkoY29uZGl0aW9uVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2hvd0Nob2ljZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydFRleHQgPSBcIlwiO1xuICAgICAgICBsZXQgY2hvaWNlT25seVRleHQgPSBcIlwiO1xuICAgICAgICBpZiAoY2hvaWNlUG9pbnQuaGFzQ2hvaWNlT25seUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIHZhciBjaG9pY2VPbmx5U3RyVmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgbGV0IGNob2ljZU9ubHlTdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGNob2ljZU9ubHlUZXh0ID0gY2hvaWNlT25seVN0clZhbC52YWx1ZSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5oYXNTdGFydENvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIHZhciBzdGFydFN0clZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgIGxldCBzdGFydFN0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgc3RhcnRUZXh0ID0gc3RhcnRTdHJWYWwudmFsdWUgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBjcmVhdGUgY2hvaWNlIGlmIHBsYXllciBoYXMgYWxyZWFkeSByZWFkIHRoaXMgY29udGVudFxuICAgICAgICBpZiAoY2hvaWNlUG9pbnQub25jZU9ubHkpIHtcbiAgICAgICAgICAgIGxldCB2aXNpdENvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKGNob2ljZVBvaW50LmNob2ljZVRhcmdldCk7XG4gICAgICAgICAgICBpZiAodmlzaXRDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBzaG93Q2hvaWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZ28gdGhyb3VnaCB0aGUgZnVsbCBwcm9jZXNzIG9mIGNyZWF0aW5nIHRoZSBjaG9pY2UgYWJvdmUgc29cbiAgICAgICAgLy8gdGhhdCB3ZSBjb25zdW1lIHRoZSBjb250ZW50IGZvciBpdCwgc2luY2Ugb3RoZXJ3aXNlIGl0J2xsXG4gICAgICAgIC8vIGJlIHNob3duIG9uIHRoZSBvdXRwdXQgc3RyZWFtLlxuICAgICAgICBpZiAoIXNob3dDaG9pY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaG9pY2UgPSBuZXcgQ2hvaWNlXzEuQ2hvaWNlKCk7XG4gICAgICAgIGNob2ljZS50YXJnZXRQYXRoID0gY2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlO1xuICAgICAgICBjaG9pY2Uuc291cmNlUGF0aCA9IGNob2ljZVBvaW50LnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgY2hvaWNlLmlzSW52aXNpYmxlRGVmYXVsdCA9IGNob2ljZVBvaW50LmlzSW52aXNpYmxlRGVmYXVsdDtcbiAgICAgICAgY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvbiA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLkZvcmtUaHJlYWQoKTtcbiAgICAgICAgY2hvaWNlLnRleHQgPSAoc3RhcnRUZXh0ICsgY2hvaWNlT25seVRleHQpLnJlcGxhY2UoL15bIFxcdF0rfFsgXFx0XSskL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgIH1cbiAgICBJc1RydXRoeShvYmopIHtcbiAgICAgICAgbGV0IHRydXRoeSA9IGZhbHNlO1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVmFsdWVfMS5WYWx1ZSkge1xuICAgICAgICAgICAgbGV0IHZhbCA9IG9iajtcbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpdlRhcmdldCA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiU2hvdWxkbid0IHVzZSBhIGRpdmVydCB0YXJnZXQgKHRvIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZGl2VGFyZ2V0LnRhcmdldFBhdGggK1xuICAgICAgICAgICAgICAgICAgICBcIikgYXMgYSBjb25kaXRpb25hbCB2YWx1ZS4gRGlkIHlvdSBpbnRlbmQgYSBmdW5jdGlvbiBjYWxsICdsaWtlVGhpcygpJyBvciBhIHJlYWQgY291bnQgY2hlY2sgJ2xpa2VUaGlzJz8gKG5vIGFycm93cylcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbC5pc1RydXRoeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1dGh5O1xuICAgIH1cbiAgICBQZXJmb3JtTG9naWNBbmRGbG93Q29udHJvbChjb250ZW50T2JqKSB7XG4gICAgICAgIGlmIChjb250ZW50T2JqID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXZlcnRcbiAgICAgICAgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBEaXZlcnRfMS5EaXZlcnQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50RGl2ZXJ0ID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0LmlzQ29uZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29uZGl0aW9uVmFsdWUgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgIC8vIEZhbHNlIGNvbmRpdGlvbmFsPyBDYW5jZWwgZGl2ZXJ0XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLklzVHJ1dGh5KGNvbmRpdGlvblZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudERpdmVydC5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGxldCB2YXJOYW1lID0gY3VycmVudERpdmVydC52YXJpYWJsZURpdmVydE5hbWU7XG4gICAgICAgICAgICAgICAgbGV0IHZhckNvbnRlbnRzID0gdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKHZhck5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJDb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJUcmllZCB0byBkaXZlcnQgdXNpbmcgYSB0YXJnZXQgZnJvbSBhIHZhcmlhYmxlIHRoYXQgY291bGQgbm90IGJlIGZvdW5kIChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoISh2YXJDb250ZW50cyBpbnN0YW5jZW9mIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBpbnRDb250ZW50ID0gdmFyQ29udGVudHMgYXMgSW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRDb250ZW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhckNvbnRlbnRzLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiVHJpZWQgdG8gZGl2ZXJ0IHRvIGEgdGFyZ2V0IGZyb20gYSB2YXJpYWJsZSwgYnV0IHRoZSB2YXJpYWJsZSAoXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIikgZGlkbid0IGNvbnRhaW4gYSBkaXZlcnQgdGFyZ2V0LCBpdCBcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludENvbnRlbnQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlICYmIGludENvbnRlbnQudmFsdWUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwid2FzIGVtcHR5L251bGwgKHRoZSB2YWx1ZSAwKS5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBcImNvbnRhaW5lZCAnXCIgKyB2YXJDb250ZW50cyArIFwiJy5cIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YXJDb250ZW50cywgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLlBvaW50ZXJBdFBhdGgodGFyZ2V0LnRhcmdldFBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudERpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5DYWxsRXh0ZXJuYWxGdW5jdGlvbihjdXJyZW50RGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmcsIGN1cnJlbnREaXZlcnQuZXh0ZXJuYWxBcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gY3VycmVudERpdmVydC50YXJnZXRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0LnB1c2hlc1RvU3RhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoKGN1cnJlbnREaXZlcnQuc3RhY2tQdXNoVHlwZSwgdW5kZWZpbmVkLCB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCAmJiAhY3VycmVudERpdmVydC5pc0V4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpdmVydC5kZWJ1Z01ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREaXZlcnQuZGVidWdNZXRhZGF0YS5zb3VyY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIkRpdmVydCB0YXJnZXQgZG9lc24ndCBleGlzdDogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERpdmVydC5kZWJ1Z01ldGFkYXRhLnNvdXJjZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIkRpdmVydCByZXNvbHV0aW9uIGZhaWxlZDogXCIgKyBjdXJyZW50RGl2ZXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGFydC9lbmQgYW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uPyBPciBwcmludCBvdXQgdGhlIHJlc3VsdD9cbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpIHtcbiAgICAgICAgICAgIGxldCBldmFsQ29tbWFuZCA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxTdGFydDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID09PSBmYWxzZSwgXCJBbHJlYWR5IGluIGV4cHJlc3Npb24gZXZhbHVhdGlvbj9cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsRW5kOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPT09IHRydWUsIFwiTm90IGluIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBtb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBleHByZXNzaW9uIHR1cm5lZCBvdXQgdG8gYmUgZW1wdHksIHRoZXJlIG1heSBub3QgYmUgYW55dGhpbmcgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9ucyBtYXkgZXZhbHVhdGUgdG8gVm9pZCwgaW4gd2hpY2ggY2FzZSB3ZSBza2lwIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEob3V0cHV0IGluc3RhbmNlb2YgVm9pZF8xLlZvaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHJlYWxseSBhbHdheXMgYmxhbmtldCBjb252ZXJ0IHRvIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCB3b3VsZCBiZSBva2F5IHRvIGhhdmUgbnVtYmVycyBpbiB0aGUgb3V0cHV0IHN0cmVhbSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHByb2JsZW0gaXMgd2hlbiBleHBvcnRpbmcgdGV4dCBmb3Igdmlld2luZywgaXQgc2tpcHMgb3ZlciBudW1iZXJzIGV0Yy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKG91dHB1dC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbSh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm9PcDpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkR1cGxpY2F0ZTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKHRoaXMuc3RhdGUuUGVla0V2YWx1YXRpb25TdGFjaygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEV2YWx1YXRlZFZhbHVlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb246XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcFR1bm5lbDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvcFR5cGUgPSBldmFsQ29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgOiBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsO1xuICAgICAgICAgICAgICAgICAgICBsZXQgb3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9wVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9wcGVkID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID0gcG9wcGVkIGFzIERpdmVydFRhcmdldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9wcGVkLCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHBvcHBlZCBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkLCBcIkV4cGVjdGVkIHZvaWQgaWYgLT4tPiBkb2Vzbid0IG92ZXJyaWRlIHRhcmdldFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5UcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSAhPSBwb3BUeXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lcy5zZXQoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uLCBcImZ1bmN0aW9uIHJldHVybiBzdGF0ZW1lbnQgKH4gcmV0dXJuKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnNldChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsLCBcInR1bm5lbCBvbndhcmRzIHN0YXRlbWVudCAoLT4tPilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhwZWN0ZWQgPSBuYW1lcy5nZXQodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gXCJlbmQgb2YgZmxvdyAoLT4gRU5EIG9yIGNob2ljZSlcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlcnJvck1zZyA9IFwiRm91bmQgXCIgKyBuYW1lcy5nZXQocG9wVHlwZSkgKyBcIiwgd2hlbiBleHBlY3RlZCBcIiArIGV4cGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcENhbGxTdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5Qb2ludGVyQXRQYXRoKG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0LnRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoVG9PdXRwdXRTdHJlYW0oZXZhbENvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPT09IHRydWUsIFwiRXhwZWN0ZWQgdG8gYmUgaW4gYW4gZXhwcmVzc2lvbiB3aGVuIGV2YWx1YXRpbmcgYSBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudFN0YWNrRm9yU3RyaW5nID0gW107XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXRDb3VudENvbnN1bWVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDb3VudENvbnN1bWVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB2YXIgY29tbWFuZCA9IG9iaiBhcyBDb250cm9sQ29tbWFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb21tYW5kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RhY2tGb3JTdHJpbmcucHVzaChvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnN1bWUgdGhlIGNvbnRlbnQgdGhhdCB3YXMgcHJvZHVjZWQgZm9yIHRoaXMgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wRnJvbU91dHB1dFN0cmVhbShvdXRwdXRDb3VudENvbnN1bWVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIEMjIHZlcnNpb24gdXNlcyBhIFN0YWNrIGZvciBjb250ZW50U3RhY2tGb3JTdHJpbmcsIGJ1dCB3ZSdyZVxuICAgICAgICAgICAgICAgICAgICAvLyB1c2luZyBhIHNpbXBsZSBhcnJheSwgc28gd2UgbmVlZCB0byByZXZlcnNlIGl0IGJlZm9yZSB1c2luZyBpdFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50U3RhY2tGb3JTdHJpbmcgPSBjb250ZW50U3RhY2tGb3JTdHJpbmcucmV2ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZCBzdHJpbmcgb3V0IG9mIHRoZSBjb250ZW50IHdlIGNvbGxlY3RlZFxuICAgICAgICAgICAgICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYyBvZiBjb250ZW50U3RhY2tGb3JTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChjLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0byBleHByZXNzaW9uIGV2YWx1YXRpb24gKGZyb20gY29udGVudCBtb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoc2IudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQ2hvaWNlQ291bnQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaG9pY2VDb3VudCA9IHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShjaG9pY2VDb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZSh0aGlzLnN0YXRlLmN1cnJlbnRUdXJuSW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlOlxuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5SZWFkQ291bnQ6XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISh0YXJnZXQgaW5zdGFuY2VvZiBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV4dHJhTm90ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYU5vdGUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIi4gRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIHJlYWQgY291bnQgKCdrbm90X25hbWUnKSBpbnN0ZWFkIG9mIGEgdGFyZ2V0ICgnLT4ga25vdF9uYW1lJyk/XCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiVFVSTlNfU0lOQ0UgLyBSRUFEX0NPVU5UIGV4cGVjdGVkIGEgZGl2ZXJ0IHRhcmdldCAoa25vdCwgc3RpdGNoLCBsYWJlbCBuYW1lKSwgYnV0IHNhdyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRyYU5vdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGRpdmVydFRhcmdldCA9IHRhcmdldCBhcyBEaXZlcnRUYXJnZXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpdmVydFRhcmdldCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRhcmdldCwgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb250YWluZXIgPSBDb250ZW50QXRQYXRoIChkaXZlcnRUYXJnZXQudGFyZ2V0UGF0aCkuY29ycmVjdE9iaiBhcyBDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5Db250ZW50QXRQYXRoKGRpdmVydFRhcmdldC50YXJnZXRQYXRoKS5jb3JyZWN0T2JqLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWl0aGVyQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVHVybnNTaW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IHRoaXMuc3RhdGUuVHVybnNTaW5jZUZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbENvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5XYXJuaW5nKFwiRmFpbGVkIHRvIGZpbmQgY29udGFpbmVyIGZvciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZhbENvbW1hbmQudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgbG9va3VwIGF0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXZlcnRUYXJnZXQudGFyZ2V0UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoZWl0aGVyQ291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJhbmRvbToge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4SW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluSW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluSW50ID09IG51bGwgfHwgbWluSW50IGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIG1pbmltdW0gcGFyYW1ldGVyIG9mIFJBTkRPTShtaW4sIG1heClcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhJbnQgPT0gbnVsbCB8fCBtaW5JbnQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgbWF4aW11bSBwYXJhbWV0ZXIgb2YgUkFORE9NKG1pbiwgbWF4KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFJlcGxhY2UgYnkgZGVmYXVsdCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEludC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJtYXhJbnQudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkludC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJtaW5JbnQudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbVJhbmdlID0gbWF4SW50LnZhbHVlIC0gbWluSW50LnZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmRvbVJhbmdlIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiUkFORE9NIHdhcyBjYWxsZWQgd2l0aCBtaW5pbXVtIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5JbnQudmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGFuZCBtYXhpbXVtIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhJbnQudmFsdWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLiBUaGUgbWF4aW11bSBtdXN0IGJlIGxhcmdlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdFNlZWQgPSB0aGlzLnN0YXRlLnN0b3J5U2VlZCArIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb207XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5kb20gPSBuZXcgUFJOR18xLlBSTkcocmVzdWx0U2VlZCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0UmFuZG9tID0gcmFuZG9tLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNob3NlblZhbHVlID0gKG5leHRSYW5kb20gJSByYW5kb21SYW5nZSkgKyBtaW5JbnQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShjaG9zZW5WYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXh0IHJhbmRvbSBudW1iZXIgKHJhdGhlciB0aGFuIGtlZXBpbmcgdGhlIFJhbmRvbSBvYmplY3QgYXJvdW5kKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tID0gbmV4dFJhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZWVkUmFuZG9tOlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VlZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZWQgPT0gbnVsbCB8fCBzZWVkIGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5FcnJvcihcIkludmFsaWQgdmFsdWUgcGFzc2VkIHRvIFNFRURfUkFORE9NXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJtaW5JbnQudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdG9yeVNlZWQgPSBzZWVkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWb2lkXzEuVm9pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXg6XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcih0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lcikgLSAxOyAvLyBpbmRleCBub3QgY291bnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5TZXF1ZW5jZVNodWZmbGVJbmRleDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNodWZmbGVJbmRleCA9IHRoaXMuTmV4dFNlcXVlbmNlU2h1ZmZsZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShzaHVmZmxlSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkOlxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGluIG1haW4gc3RlcCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRG9uZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF5IGV4aXN0IGluIHRoZSBjb250ZXh0IG9mIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFjdCBvZiBjcmVhdGluZyB0aGUgdGhyZWFkLCBvciBpbiB0aGUgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAgICAvLyBldmFsdWF0aW5nIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5Qb3BUaHJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBub3JtYWwgZmxvdyAtIGFsbG93IHNhZmUgZXhpdCB3aXRob3V0IHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpZFNhZmVFeGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgZmxvdyBpbiBjdXJyZW50IHRocmVhZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgZmxvdyB0byBlbmQgY29tcGxldGVseVxuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuRm9yY2VFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RGcm9tSW50OlxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgaW50VmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIEludFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgbGlzdE5hbWVWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0TmFtZVZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50VmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIlBhc3NlZCBub24taW50ZWdlciB3aGVuIGNyZWF0aW5nIGEgbGlzdCBlbGVtZW50IGZyb20gYSBudW1lcmljYWwgdmFsdWUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBnZW5lcmF0ZWRMaXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0RGVmaW5pdGlvbnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5saXN0RGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kTGlzdERlZiA9IHRoaXMubGlzdERlZmluaXRpb25zLlRyeUxpc3RHZXREZWZpbml0aW9uKGxpc3ROYW1lVmFsLnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kTGlzdERlZi5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludFZhbC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibWluSW50LnZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kSXRlbSA9IGZvdW5kTGlzdERlZi5yZXN1bHQuVHJ5R2V0SXRlbVdpdGhWYWx1ZShpbnRWYWwudmFsdWUsIElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZEl0ZW0uZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkTGlzdFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKGZvdW5kSXRlbS5yZXN1bHQsIGludFZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkZhaWxlZCB0byBmaW5kIExJU1QgY2FsbGVkIFwiICsgbGlzdE5hbWVWYWwudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRMaXN0VmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZExpc3RWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soZ2VuZXJhdGVkTGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5nZTpcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1heCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIHRhcmdldExpc3QgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgTGlzdFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0TGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRMaXN0ID09PSBudWxsIHx8IG1pbiA9PT0gbnVsbCB8fCBtYXggPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkV4cGVjdGVkIGxpc3QsIG1pbmltdW0gYW5kIG1heGltdW0gZm9yIExJU1RfUkFOR0VcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRMaXN0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRhcmdldExpc3QudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRhcmdldExpc3QudmFsdWUuTGlzdFdpdGhTdWJSYW5nZShtaW4udmFsdWVPYmplY3QsIG1heC52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5MaXN0VmFsdWUocmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZG9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0VmFsID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RWYWwgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkV4cGVjdGVkIGxpc3QgZm9yIExJU1RfUkFORE9NXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdCA9IGxpc3RWYWwudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdMaXN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJsaXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0LkNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgcmFuZG9tIGluZGV4IGZvciB0aGUgZWxlbWVudCB0byB0YWtlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0U2VlZCA9IHRoaXMuc3RhdGUuc3RvcnlTZWVkICsgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5kb20gPSBuZXcgUFJOR18xLlBSTkcocmVzdWx0U2VlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dFJhbmRvbSA9IHJhbmRvbS5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdEl0ZW1JbmRleCA9IG5leHRSYW5kb20gJSBsaXN0LkNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBiaXQgaXMgYSBsaXR0bGUgZGlmZmVyZW50IGZyb20gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDIyBjb2RlLCBzaW5jZSBpdGVyYXRvcnMgZG8gbm90IHdvcmsgaW4gdGhlIHNhbWUgd2F5LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QsIHdlIGl0ZXJhdGUgbGlzdEl0ZW1JbmRleCAtIDEgdGltZXMsIGNhbGxpbmcgbmV4dCgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3RJdGVtSW5kZXgtdGggdGltZSBpcyBtYWRlIG91dHNpZGUgb2YgdGhlIGxvb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciB0byByZXRyaWV2ZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbGlzdEVudW1lcmF0b3IgPSBsaXN0LmVudHJpZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpc3RJdGVtSW5kZXggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0RW51bWVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBsaXN0RW51bWVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBLZXk6IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleSh2YWx1ZVswXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVmFsdWU6IHZhbHVlWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbiBsaXN0IGlzIHNpbXBseSB0aGUgb3JpZ2luIG9mIHRoZSBvbmUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmRvbUl0ZW0uS2V5Lm9yaWdpbk5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInJhbmRvbUl0ZW0uS2V5Lm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KHJhbmRvbUl0ZW0uS2V5Lm9yaWdpbk5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdC5BZGQocmFuZG9tSXRlbS5LZXksIHJhbmRvbUl0ZW0uVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbSA9IG5leHRSYW5kb207XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShuZXdMaXN0KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwidW5oYW5kbGVkIENvbnRyb2xDb21tYW5kOiBcIiArIGV2YWxDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZSBhc3NpZ25tZW50XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBWYXJpYWJsZUFzc2lnbm1lbnRfMS5WYXJpYWJsZUFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIGxldCB2YXJBc3MgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgbGV0IGFzc2lnbmVkVmFsID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuQXNzaWduKHZhckFzcywgYXNzaWduZWRWYWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnRPYmogaW5zdGFuY2VvZiBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBsZXQgdmFyUmVmID0gY29udGVudE9iajtcbiAgICAgICAgICAgIGxldCBmb3VuZFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IHJlYWQgY291bnQgdmFsdWVcbiAgICAgICAgICAgIGlmICh2YXJSZWYucGF0aEZvckNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdmFyUmVmLmNvbnRhaW5lckZvckNvdW50O1xuICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuc3RhdGUuVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIGZvdW5kVmFsdWUgPSBuZXcgVmFsdWVfMS5JbnRWYWx1ZShjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWwgdmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3VuZFZhbHVlID0gdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HZXRWYXJpYWJsZVdpdGhOYW1lKHZhclJlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuV2FybmluZyhcIlZhcmlhYmxlIG5vdCBmb3VuZDogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhclJlZi5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiJy4gVXNpbmcgZGVmYXVsdCB2YWx1ZSBvZiAwIChmYWxzZSkuIFRoaXMgY2FuIGhhcHBlbiB3aXRoIHRlbXBvcmFyeSB2YXJpYWJsZXMgaWYgdGhlIGRlY2xhcmF0aW9uIGhhc24ndCB5ZXQgYmVlbiBoaXQuIEdsb2JhbHMgYXJlIGFsd2F5cyBnaXZlbiBhIGRlZmF1bHQgdmFsdWUgb24gbG9hZCBpZiBhIHZhbHVlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIHNhdmUgc3RhdGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFZhbHVlID0gbmV3IFZhbHVlXzEuSW50VmFsdWUoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKGZvdW5kVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmF0aXZlIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xLk5hdGl2ZUZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgbGV0IGZ1bmMgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgbGV0IGZ1bmNQYXJhbXMgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayhmdW5jLm51bWJlck9mUGFyYW1ldGVycyk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZnVuYy5DYWxsKGZ1bmNQYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKHJlc3VsdCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBjb250cm9sIGNvbnRlbnQsIG11c3QgYmUgb3JkaW5hcnkgY29udGVudFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENob29zZVBhdGhTdHJpbmcocGF0aCwgcmVzZXRDYWxsc3RhY2sgPSB0cnVlLCBhcmdzID0gW10pIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBDaG9vc2VQYXRoU3RyaW5nIHJpZ2h0IG5vd1wiKTtcbiAgICAgICAgaWYgKHJlc2V0Q2FsbHN0YWNrKSB7XG4gICAgICAgICAgICB0aGlzLlJlc2V0Q2FsbHN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgZnVuY0RldGFpbCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIC5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmNEZXRhaWwgPSBcIihcIiArIGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkgKyBcIikgXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0b3J5IHdhcyBydW5uaW5nIGEgZnVuY3Rpb24gXCIgK1xuICAgICAgICAgICAgICAgICAgICBmdW5jRGV0YWlsICtcbiAgICAgICAgICAgICAgICAgICAgXCJ3aGVuIHlvdSBjYWxsZWQgQ2hvb3NlUGF0aFN0cmluZyhcIiArXG4gICAgICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgICAgICBcIikgLSB0aGlzIGlzIGFsbW9zdCBjZXJ0YWlubHkgbm90IG5vdCB3aGF0IHlvdSB3YW50ISBGdWxsIHN0YWNrIHRyYWNlOiBcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhbGxTdGFja1RyYWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLlBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhhcmdzKTtcbiAgICAgICAgdGhpcy5DaG9vc2VQYXRoKG5ldyBQYXRoXzEuUGF0aChwYXRoKSk7XG4gICAgfVxuICAgIElmQXN5bmNXZUNhbnQoYWN0aXZpdHlTdHIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBcIiArXG4gICAgICAgICAgICAgICAgYWN0aXZpdHlTdHIgK1xuICAgICAgICAgICAgICAgIFwiLiBTdG9yeSBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgQ29udGludWVBc3luYygpLiBNYWtlIG1vcmUgQ29udGludWVBc3luYygpIGNhbGxzIG9yIGEgc2luZ2xlIENvbnRpbnVlKCkgY2FsbCBiZWZvcmVoYW5kLlwiKTtcbiAgICB9XG4gICAgQ2hvb3NlUGF0aChwLCBpbmNyZW1lbnRpbmdUdXJuSW5kZXggPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuU2V0Q2hvc2VuUGF0aChwLCBpbmNyZW1lbnRpbmdUdXJuSW5kZXgpO1xuICAgICAgICAvLyBUYWtlIGEgbm90ZSBvZiBuZXdseSB2aXNpdGVkIGNvbnRhaW5lcnMgZm9yIHJlYWQgY291bnRzIGV0Y1xuICAgICAgICB0aGlzLlZpc2l0Q2hhbmdlZENvbnRhaW5lcnNEdWVUb0RpdmVydCgpO1xuICAgIH1cbiAgICBDaG9vc2VDaG9pY2VJbmRleChjaG9pY2VJZHgpIHtcbiAgICAgICAgY2hvaWNlSWR4ID0gY2hvaWNlSWR4O1xuICAgICAgICBsZXQgY2hvaWNlcyA9IHRoaXMuY3VycmVudENob2ljZXM7XG4gICAgICAgIHRoaXMuQXNzZXJ0KGNob2ljZUlkeCA+PSAwICYmIGNob2ljZUlkeCA8IGNob2ljZXMubGVuZ3RoLCBcImNob2ljZSBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBjaG9pY2VUb0Nob29zZSA9IGNob2ljZXNbY2hvaWNlSWR4XTtcbiAgICAgICAgaWYgKGNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVRvQ2hvb3NlLnRhcmdldFBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY2hvaWNlVG9DaG9vc2UudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkID0gY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uO1xuICAgICAgICB0aGlzLkNob29zZVBhdGgoY2hvaWNlVG9DaG9vc2UudGFyZ2V0UGF0aCk7XG4gICAgfVxuICAgIEhhc0Z1bmN0aW9uKGZ1bmN0aW9uTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKGZ1bmN0aW9uTmFtZSkgIT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIEV2YWx1YXRlRnVuY3Rpb24oZnVuY3Rpb25OYW1lLCBhcmdzID0gW10sIHJldHVyblRleHRPdXRwdXQgPSBmYWxzZSkge1xuICAgICAgICAvLyBFdmFsdWF0ZUZ1bmN0aW9uIGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50bHkgdGhhbiB0aGUgQyMgdmVyc2lvbi5cbiAgICAgICAgLy8gSW4gQyMsIHlvdSBjYW4gcGFzcyBhIChzZWNvbmQpIHBhcmFtZXRlciBgb3V0IHRleHRPdXRwdXRgIHRvIGdldCB0aGVcbiAgICAgICAgLy8gdGV4dCBvdXRwdXR0ZWQgYnkgdGhlIGZ1bmN0aW9uLiBUaGlzIGlzIG5vdCBwb3NzaWJsZSBpbiBqcy4gSW5zdGVhZCxcbiAgICAgICAgLy8gd2UgbWFpbnRhaW4gdGhlIHJlZ3VsYXIgc2lnbmF0dXJlIChmdW5jdGlvbk5hbWUsIGFyZ3MpLCBwbHVzIGFuXG4gICAgICAgIC8vIG9wdGlvbmFsIHRoaXJkIHBhcmFtZXRlciByZXR1cm5UZXh0T3V0cHV0LiBJZiBzZXQgdG8gdHJ1ZSwgd2Ugd2lsbFxuICAgICAgICAvLyByZXR1cm4gYm90aCB0aGUgdGV4dE91dHB1dCBhbmQgdGhlIHJldHVybmVkIHZhbHVlLCBhcyBhbiBvYmplY3QuXG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImV2YWx1YXRlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIGlmIChmdW5jdGlvbk5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgbnVsbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmdW5jdGlvbk5hbWUgPT0gXCJcIiB8fCBmdW5jdGlvbk5hbWUudHJpbSgpID09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGlzIGVtcHR5IG9yIHdoaXRlIHNwYWNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuY0NvbnRhaW5lciA9IHRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKGZ1bmN0aW9uTmFtZSk7XG4gICAgICAgIGlmIChmdW5jQ29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3Q6ICdcIiArIGZ1bmN0aW9uTmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0cHV0U3RyZWFtQmVmb3JlID0gW107XG4gICAgICAgIG91dHB1dFN0cmVhbUJlZm9yZS5wdXNoLmFwcGx5KG91dHB1dFN0cmVhbUJlZm9yZSwgdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0pO1xuICAgICAgICB0aGlzLl9zdGF0ZS5SZXNldE91dHB1dCgpO1xuICAgICAgICB0aGlzLnN0YXRlLlN0YXJ0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoZnVuY0NvbnRhaW5lciwgYXJncyk7XG4gICAgICAgIC8vIEV2YWx1YXRlIHRoZSBmdW5jdGlvbiwgYW5kIGNvbGxlY3QgdGhlIHN0cmluZyBvdXRwdXRcbiAgICAgICAgbGV0IHN0cmluZ091dHB1dCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICB3aGlsZSAodGhpcy5jYW5Db250aW51ZSkge1xuICAgICAgICAgICAgc3RyaW5nT3V0cHV0LkFwcGVuZCh0aGlzLkNvbnRpbnVlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0ZXh0T3V0cHV0ID0gc3RyaW5nT3V0cHV0LnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KG91dHB1dFN0cmVhbUJlZm9yZSk7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnN0YXRlLkNvbXBsZXRlRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblRleHRPdXRwdXQgPyB7IHJldHVybmVkOiByZXN1bHQsIG91dHB1dDogdGV4dE91dHB1dCB9IDogcmVzdWx0O1xuICAgIH1cbiAgICBFdmFsdWF0ZUV4cHJlc3Npb24oZXhwckNvbnRhaW5lcikge1xuICAgICAgICBsZXQgc3RhcnRDYWxsU3RhY2tIZWlnaHQgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goUHVzaFBvcF8xLlB1c2hQb3BUeXBlLlR1bm5lbCk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPSBleHByQ29udGFpbmVyO1xuICAgICAgICB0aGlzLnN0YXRlLkdvVG9TdGFydCgpO1xuICAgICAgICBsZXQgZXZhbFN0YWNrSGVpZ2h0ID0gdGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoO1xuICAgICAgICB0aGlzLkNvbnRpbnVlKCk7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPSBudWxsO1xuICAgICAgICAvLyBTaG91bGQgaGF2ZSBmYWxsZW4gb2ZmIHRoZSBlbmQgb2YgdGhlIENvbnRhaW5lciwgd2hpY2ggc2hvdWxkXG4gICAgICAgIC8vIGhhdmUgYXV0by1wb3BwZWQsIGJ1dCBqdXN0IGluIGNhc2Ugd2UgZGlkbid0IGZvciBzb21lIHJlYXNvbixcbiAgICAgICAgLy8gbWFudWFsbHkgcG9wIHRvIHJlc3RvcmUgdGhlIHN0YXRlIChpbmNsdWRpbmcgY3VycmVudFBhdGgpLlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHMubGVuZ3RoID4gc3RhcnRDYWxsU3RhY2tIZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZFN0YWNrSGVpZ2h0ID0gdGhpcy5zdGF0ZS5ldmFsdWF0aW9uU3RhY2subGVuZ3RoO1xuICAgICAgICBpZiAoZW5kU3RhY2tIZWlnaHQgPiBldmFsU3RhY2tIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUsIG51bWJlck9mQXJndW1lbnRzKSB7XG4gICAgICAgIGlmIChmdW5jTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJmdW5jTmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVuYyA9IHRoaXMuX2V4dGVybmFscy5nZXQoZnVuY05hbWUpO1xuICAgICAgICBsZXQgZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIGxldCBmb3VuZEV4dGVybmFsID0gdHlwZW9mIGZ1bmMgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIC8vIFRyeSB0byB1c2UgZmFsbGJhY2sgZnVuY3Rpb24/XG4gICAgICAgIGlmICghZm91bmRFeHRlcm5hbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lciA9IHRoaXMuS25vdENvbnRhaW5lcldpdGhOYW1lKGZ1bmNOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyICE9PSBudWxsLCBcIlRyeWluZyB0byBjYWxsIEVYVEVSTkFMIGZ1bmN0aW9uICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCInIHdoaWNoIGhhcyBub3QgYmVlbiBib3VuZCwgYW5kIGZhbGxiYWNrIGluayBmdW5jdGlvbiBjb3VsZCBub3QgYmUgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIC8vIERpdmVydCBkaXJlY3QgaW50byBmYWxsYmFjayBmdW5jdGlvbiBhbmQgd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uLCB1bmRlZmluZWQsIHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KGZhbHNlLCBcIlRyeWluZyB0byBjYWxsIEVYVEVSTkFMIGZ1bmN0aW9uICdcIiArXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCInIHdoaWNoIGhhcyBub3QgYmVlbiBib3VuZCAoYW5kIGluayBmYWxsYmFja3MgZGlzYWJsZWQpLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQb3AgYXJndW1lbnRzXG4gICAgICAgIGxldCBhcmdzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZBcmd1bWVudHM7ICsraSkge1xuICAgICAgICAgICAgLy8gdmFyIHBvcHBlZE9iaiA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBWYWx1ZTtcbiAgICAgICAgICAgIGxldCBwb3BwZWRPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZU9iaiA9IHBvcHBlZE9iai52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh2YWx1ZU9iaik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV2ZXJzZSBhcmd1bWVudHMgZnJvbSB0aGUgb3JkZXIgdGhleSB3ZXJlIHBvcHBlZCxcbiAgICAgICAgLy8gc28gdGhleSdyZSB0aGUgcmlnaHQgd2F5IHJvdW5kIGFnYWluLlxuICAgICAgICBhcmdzLnJldmVyc2UoKTtcbiAgICAgICAgLy8gUnVuIHRoZSBmdW5jdGlvbiFcbiAgICAgICAgbGV0IGZ1bmNSZXN1bHQgPSBmdW5jKGFyZ3MpO1xuICAgICAgICAvLyBDb252ZXJ0IHJldHVybiB2YWx1ZSAoaWYgYW55KSB0byB0aGUgYSB0eXBlIHRoYXQgdGhlIGluayBlbmdpbmUgY2FuIHVzZVxuICAgICAgICBsZXQgcmV0dXJuT2JqID0gbnVsbDtcbiAgICAgICAgaWYgKGZ1bmNSZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuT2JqID0gVmFsdWVfMS5WYWx1ZS5DcmVhdGUoZnVuY1Jlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydChyZXR1cm5PYmogIT09IG51bGwsIFwiQ291bGQgbm90IGNyZWF0ZSBpbmsgdmFsdWUgZnJvbSByZXR1cm5lZCBvYmplY3Qgb2YgdHlwZSBcIiArXG4gICAgICAgICAgICAgICAgdHlwZW9mIGZ1bmNSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuT2JqID0gbmV3IFZvaWRfMS5Wb2lkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKHJldHVybk9iaik7XG4gICAgfVxuICAgIEJpbmRFeHRlcm5hbEZ1bmN0aW9uR2VuZXJhbChmdW5jTmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJiaW5kIGFuIGV4dGVybmFsIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLkFzc2VydCghdGhpcy5fZXh0ZXJuYWxzLmhhcyhmdW5jTmFtZSksIFwiRnVuY3Rpb24gJ1wiICsgZnVuY05hbWUgKyBcIicgaGFzIGFscmVhZHkgYmVlbiBib3VuZC5cIik7XG4gICAgICAgIHRoaXMuX2V4dGVybmFscy5zZXQoZnVuY05hbWUsIGZ1bmMpO1xuICAgIH1cbiAgICBUcnlDb2VyY2UodmFsdWUpIHtcbiAgICAgICAgLy8gV2UncmUgc2tpcHBpbmcgdHlwZSBjb2VyY2l0aW9uIGluIHRoaXMgaW1wbGVtZW50YXRpb24uIEZpcnN0IG9mLCBqc1xuICAgICAgICAvLyBpcyBsb29zZWx5IHR5cGVkLCBzbyBpdCdzIG5vdCB0aGF0IGltcG9ydGFudC4gU2Vjb25kbHksIHRoZXJlIGlzIG5vXG4gICAgICAgIC8vIGNsZWFuIHdheSAoQUZBSUspIGZvciB0aGUgdXNlciB0byBkZXNjcmliZSB3aGF0IHR5cGUgb2YgcGFyYW1ldGVyc1xuICAgICAgICAvLyB0aGV5IGV4cGVjdC5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBCaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLkFzc2VydChmdW5jICE9IG51bGwsIFwiQ2FuJ3QgYmluZCBhIG51bGwgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKGZ1bmNOYW1lLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQoYXJncy5sZW5ndGggPj0gZnVuYy5sZW5ndGgsIFwiRXh0ZXJuYWwgZnVuY3Rpb24gZXhwZWN0ZWQgXCIgKyBmdW5jLmxlbmd0aCArIFwiIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgICAgIGxldCBjb2VyY2VkQXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBhcmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvZXJjZWRBcmdzW2ldID0gdGhpcy5UcnlDb2VyY2UoYXJnc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBjb2VyY2VkQXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBVbmJpbmRFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcInVuYmluZCBhbiBleHRlcm5hbCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9leHRlcm5hbHMuaGFzKGZ1bmNOYW1lKSwgXCJGdW5jdGlvbiAnXCIgKyBmdW5jTmFtZSArIFwiJyBoYXMgbm90IGJlZW4gYm91bmQuXCIpO1xuICAgICAgICB0aGlzLl9leHRlcm5hbHMuZGVsZXRlKGZ1bmNOYW1lKTtcbiAgICB9XG4gICAgVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKCkge1xuICAgICAgICBsZXQgYyA9IG51bGw7XG4gICAgICAgIGxldCBvID0gbnVsbDtcbiAgICAgICAgbGV0IG1pc3NpbmdFeHRlcm5hbHMgPSBhcmd1bWVudHNbMV0gfHwgbmV3IFNldCgpO1xuICAgICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3RfMS5JbmtPYmplY3QpIHtcbiAgICAgICAgICAgIG8gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IG51bGwgJiYgbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3ModGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXIsIG1pc3NpbmdFeHRlcm5hbHMpO1xuICAgICAgICAgICAgdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIE5vIHByb2JsZW0hIFZhbGlkYXRpb24gY29tcGxldGVcbiAgICAgICAgICAgIGlmIChtaXNzaW5nRXh0ZXJuYWxzLnNpemUgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwiRXJyb3I6IE1pc3NpbmcgZnVuY3Rpb24gYmluZGluZyBmb3IgZXh0ZXJuYWxcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IG1pc3NpbmdFeHRlcm5hbHMuc2l6ZSA+IDEgPyBcInNcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIjogJ1wiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gQXJyYXkuZnJvbShtaXNzaW5nRXh0ZXJuYWxzKS5qb2luKFwiJywgJ1wiKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiJyBcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgID8gXCIsIGFuZCBubyBmYWxsYmFjayBpbmsgZnVuY3Rpb24gZm91bmQuXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcIiAoaW5rIGZhbGxiYWNrcyBkaXNhYmxlZClcIjtcbiAgICAgICAgICAgICAgICB0aGlzLkVycm9yKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5uZXJDb250ZW50IG9mIGMuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSBpbm5lckNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciA9PSBudWxsIHx8ICFjb250YWluZXIuaGFzVmFsaWROYW1lKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyhpbm5lckNvbnRlbnQsIG1pc3NpbmdFeHRlcm5hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgWywgdmFsdWVdIG9mIGMubmFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5WYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlLCBPYmplY3RfMS5JbmtPYmplY3QpLCBtaXNzaW5nRXh0ZXJuYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBkaXZlcnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwobywgRGl2ZXJ0XzEuRGl2ZXJ0KTtcbiAgICAgICAgICAgIGlmIChkaXZlcnQgJiYgZGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGRpdmVydC50YXJnZXRQYXRoU3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9leHRlcm5hbHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93RXh0ZXJuYWxGdW5jdGlvbkZhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZhbGxiYWNrRm91bmQgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5oYXMobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZhbGxiYWNrRm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaXNzaW5nRXh0ZXJuYWxzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdFeHRlcm5hbHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIE9ic2VydmVWYXJpYWJsZSh2YXJpYWJsZU5hbWUsIG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcIm9ic2VydmUgYSBuZXcgdmFyaWFibGVcIik7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUudmFyaWFibGVzU3RhdGUuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZSh2YXJpYWJsZU5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3Qgb2JzZXJ2ZSB2YXJpYWJsZSAnXCIgK1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSArXG4gICAgICAgICAgICAgICAgXCInIGJlY2F1c2UgaXQgd2Fzbid0IGRlY2xhcmVkIGluIHRoZSBpbmsgc3RvcnkuXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuaGFzKHZhcmlhYmxlTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh2YXJpYWJsZU5hbWUpLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuc2V0KHZhcmlhYmxlTmFtZSwgW29ic2VydmVyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JzZXJ2ZVZhcmlhYmxlcyh2YXJpYWJsZU5hbWVzLCBvYnNlcnZlcnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSB2YXJpYWJsZU5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5PYnNlcnZlVmFyaWFibGUodmFyaWFibGVOYW1lc1tpXSwgb2JzZXJ2ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZW1vdmVWYXJpYWJsZU9ic2VydmVyKG9ic2VydmVyLCBzcGVjaWZpY1ZhcmlhYmxlTmFtZSkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJyZW1vdmUgYSB2YXJpYWJsZSBvYnNlcnZlclwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZW9mIHNwZWNpZmljVmFyaWFibGVOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuaGFzKHNwZWNpZmljVmFyaWFibGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQoc3BlY2lmaWNWYXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5kZWxldGUoc3BlY2lmaWNWYXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGtleXMgPSB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5rZXlzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCB2YXJOYW1lIG9mIGtleXMpIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JzZXJ2ZXJzID0gdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHZhck5hbWUpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uob2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBWYXJpYWJsZVN0YXRlRGlkQ2hhbmdlRXZlbnQodmFyaWFibGVOYW1lLCBuZXdWYWx1ZU9iaikge1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlcnMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICghKG5ld1ZhbHVlT2JqIGluc3RhbmNlb2YgVmFsdWVfMS5WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllZCB0byBnZXQgdGhlIHZhbHVlIG9mIGEgdmFyaWFibGUgdGhhdCBpc24ndCBhIHN0YW5kYXJkIHR5cGVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YXIgdmFsID0gbmV3VmFsdWVPYmogYXMgVmFsdWU7XG4gICAgICAgICAgICBsZXQgdmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobmV3VmFsdWVPYmosIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgZm9yIChsZXQgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIodmFyaWFibGVOYW1lLCB2YWwudmFsdWVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBnbG9iYWxUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5UYWdzQXRTdGFydE9mRmxvd0NvbnRhaW5lcldpdGhQYXRoU3RyaW5nKFwiXCIpO1xuICAgIH1cbiAgICBUYWdzRm9yQ29udGVudEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcocGF0aCk7XG4gICAgfVxuICAgIFRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcocGF0aFN0cmluZykge1xuICAgICAgICBsZXQgcGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwYXRoU3RyaW5nKTtcbiAgICAgICAgbGV0IGZsb3dDb250YWluZXIgPSB0aGlzLkNvbnRlbnRBdFBhdGgocGF0aCkuY29udGFpbmVyO1xuICAgICAgICBpZiAoZmxvd0NvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJmbG93Q29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RDb250ZW50ID0gZmxvd0NvbnRhaW5lci5jb250ZW50WzBdO1xuICAgICAgICAgICAgaWYgKGZpcnN0Q29udGVudCBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcilcbiAgICAgICAgICAgICAgICBmbG93Q29udGFpbmVyID0gZmlyc3RDb250ZW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWdzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgYyBvZiBmbG93Q29udGFpbmVyLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIHZhciB0YWcgPSBjIGFzIFJ1bnRpbWUuVGFnO1xuICAgICAgICAgICAgbGV0IHRhZyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjLCBUYWdfMS5UYWcpO1xuICAgICAgICAgICAgaWYgKHRhZykge1xuICAgICAgICAgICAgICAgIGlmICh0YWdzID09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB0YWdzLnB1c2godGFnLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH1cbiAgICBCdWlsZFN0cmluZ09mSGllcmFyY2h5KCkge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCAwLCB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLlJlc29sdmUoKSk7XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICBCdWlsZFN0cmluZ09mQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgY29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIDAsIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuUmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIE5leHRDb250ZW50KCkge1xuICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzUG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZGl2ZXJ0ZWRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgIHRoaXMuVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdWNjZXNzZnVsUG9pbnRlckluY3JlbWVudCA9IHRoaXMuSW5jcmVtZW50Q29udGVudFBvaW50ZXIoKTtcbiAgICAgICAgaWYgKCFzdWNjZXNzZnVsUG9pbnRlckluY3JlbWVudCkge1xuICAgICAgICAgICAgbGV0IGRpZFBvcCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVm9pZF8xLlZvaWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpZFBvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5Qb3BUaHJlYWQoKTtcbiAgICAgICAgICAgICAgICBkaWRQb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5UcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWRQb3AgJiYgIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5OZXh0Q29udGVudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEluY3JlbWVudENvbnRlbnRQb2ludGVyKCkge1xuICAgICAgICBsZXQgc3VjY2Vzc2Z1bEluY3JlbWVudCA9IHRydWU7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICBwb2ludGVyLmluZGV4Kys7XG4gICAgICAgIGlmIChwb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocG9pbnRlci5pbmRleCA+PSBwb2ludGVyLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aCkge1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bEluY3JlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ29udGFpbmVyIG5leHRBbmNlc3RvciA9IHBvaW50ZXIuY29udGFpbmVyLnBhcmVudCBhcyBDb250YWluZXI7XG4gICAgICAgICAgICBsZXQgbmV4dEFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvaW50ZXIuY29udGFpbmVyLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChuZXh0QW5jZXN0b3IgaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5kZXhJbkFuY2VzdG9yID0gbmV4dEFuY2VzdG9yLmNvbnRlbnQuaW5kZXhPZihwb2ludGVyLmNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoaW5kZXhJbkFuY2VzdG9yID09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyID0gbmV3IFBvaW50ZXJfMS5Qb2ludGVyKG5leHRBbmNlc3RvciwgaW5kZXhJbkFuY2VzdG9yKTtcbiAgICAgICAgICAgIHBvaW50ZXIuaW5kZXgrKztcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxJbmNyZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwb2ludGVyLmNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWxJbmNyZW1lbnQpXG4gICAgICAgICAgICBwb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSBwb2ludGVyLmNvcHkoKTtcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NmdWxJbmNyZW1lbnQ7XG4gICAgfVxuICAgIFRyeUZvbGxvd0RlZmF1bHRJbnZpc2libGVDaG9pY2UoKSB7XG4gICAgICAgIGxldCBhbGxDaG9pY2VzID0gdGhpcy5fc3RhdGUuY3VycmVudENob2ljZXM7XG4gICAgICAgIGxldCBpbnZpc2libGVDaG9pY2VzID0gYWxsQ2hvaWNlcy5maWx0ZXIoKGMpID0+IGMuaXNJbnZpc2libGVEZWZhdWx0KTtcbiAgICAgICAgaWYgKGludmlzaWJsZUNob2ljZXMubGVuZ3RoID09IDAgfHxcbiAgICAgICAgICAgIGFsbENob2ljZXMubGVuZ3RoID4gaW52aXNpYmxlQ2hvaWNlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaG9pY2UgPSBpbnZpc2libGVDaG9pY2VzWzBdO1xuICAgICAgICBpZiAoY2hvaWNlLnRhcmdldFBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY2hvaWNlLnRhcmdldFBhdGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZS50aHJlYWRBdEdlbmVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkID0gY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvbjtcbiAgICAgICAgdGhpcy5DaG9vc2VQYXRoKGNob2ljZS50YXJnZXRQYXRoLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBOZXh0U2VxdWVuY2VTaHVmZmxlSW5kZXgoKSB7XG4gICAgICAgIC8vIHZhciBudW1FbGVtZW50c0ludFZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBJbnRWYWx1ZTtcbiAgICAgICAgbGV0IG51bUVsZW1lbnRzSW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBpZiAoIShudW1FbGVtZW50c0ludFZhbCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLkVycm9yKFwiZXhwZWN0ZWQgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHNlcXVlbmNlIGZvciBzaHVmZmxlIGluZGV4XCIpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcUNvbnRhaW5lciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyO1xuICAgICAgICBpZiAoc2VxQ29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInNlcUNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICBpZiAobnVtRWxlbWVudHNJbnRWYWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibnVtRWxlbWVudHNJbnRWYWwudmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bUVsZW1lbnRzID0gbnVtRWxlbWVudHNJbnRWYWwudmFsdWU7XG4gICAgICAgIC8vIHZhciBzZXFDb3VudFZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBJbnRWYWx1ZTtcbiAgICAgICAgbGV0IHNlcUNvdW50VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGxldCBzZXFDb3VudCA9IHNlcUNvdW50VmFsLnZhbHVlO1xuICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICBpZiAoc2VxQ291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwic2VxQ291bnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvb3BJbmRleCA9IHNlcUNvdW50IC8gbnVtRWxlbWVudHM7XG4gICAgICAgIGxldCBpdGVyYXRpb25JbmRleCA9IHNlcUNvdW50ICUgbnVtRWxlbWVudHM7XG4gICAgICAgIGxldCBzZXFQYXRoU3RyID0gc2VxQ29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IHNlcXVlbmNlSGFzaCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gc2VxUGF0aFN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHNlcXVlbmNlSGFzaCArPSBzZXFQYXRoU3RyLmNoYXJDb2RlQXQoaSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmFuZG9tU2VlZCA9IHNlcXVlbmNlSGFzaCArIGxvb3BJbmRleCArIHRoaXMuc3RhdGUuc3RvcnlTZWVkO1xuICAgICAgICBsZXQgcmFuZG9tID0gbmV3IFBSTkdfMS5QUk5HKE1hdGguZmxvb3IocmFuZG9tU2VlZCkpO1xuICAgICAgICBsZXQgdW5waWNrZWRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtRWxlbWVudHM7ICsraSkge1xuICAgICAgICAgICAgdW5waWNrZWRJbmRpY2VzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gaXRlcmF0aW9uSW5kZXg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNob3NlbiA9IHJhbmRvbS5uZXh0KCkgJSB1bnBpY2tlZEluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNob3NlbkluZGV4ID0gdW5waWNrZWRJbmRpY2VzW2Nob3Nlbl07XG4gICAgICAgICAgICB1bnBpY2tlZEluZGljZXMuc3BsaWNlKGNob3NlbiwgMSk7XG4gICAgICAgICAgICBpZiAoaSA9PSBpdGVyYXRpb25JbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaG9zZW5JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKTtcbiAgICB9XG4gICAgRXJyb3IobWVzc2FnZSwgdXNlRW5kTGluZU51bWJlciA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBlID0gbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24obWVzc2FnZSk7XG4gICAgICAgIGUudXNlRW5kTGluZU51bWJlciA9IHVzZUVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIFdhcm5pbmcobWVzc2FnZSkge1xuICAgICAgICB0aGlzLkFkZEVycm9yKG1lc3NhZ2UsIHRydWUpO1xuICAgIH1cbiAgICBBZGRFcnJvcihtZXNzYWdlLCBpc1dhcm5pbmcgPSBmYWxzZSwgdXNlRW5kTGluZU51bWJlciA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkbSA9IHRoaXMuY3VycmVudERlYnVnTWV0YWRhdGE7XG4gICAgICAgIGxldCBlcnJvclR5cGVTdHIgPSBpc1dhcm5pbmcgPyBcIldBUk5JTkdcIiA6IFwiRVJST1JcIjtcbiAgICAgICAgaWYgKGRtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBsaW5lTnVtID0gdXNlRW5kTGluZU51bWJlciA/IGRtLmVuZExpbmVOdW1iZXIgOiBkbS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIlJVTlRJTUUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBlcnJvclR5cGVTdHIgK1xuICAgICAgICAgICAgICAgICAgICBcIjogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgZG0uZmlsZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIicgbGluZSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGxpbmVOdW0gK1xuICAgICAgICAgICAgICAgICAgICBcIjogXCIgK1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgXCJSVU5USU1FIFwiICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JUeXBlU3RyICtcbiAgICAgICAgICAgICAgICAgICAgXCI6IChcIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgK1xuICAgICAgICAgICAgICAgICAgICBcIik6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJVTlRJTUUgXCIgKyBlcnJvclR5cGVTdHIgKyBcIjogXCIgKyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuQWRkRXJyb3IobWVzc2FnZSwgaXNXYXJuaW5nKTtcbiAgICAgICAgLy8gSW4gYSBicm9rZW4gc3RhdGUgZG9uJ3QgbmVlZCB0byBrbm93IGFib3V0IGFueSBvdGhlciBlcnJvcnMuXG4gICAgICAgIGlmICghaXNXYXJuaW5nKVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5Gb3JjZUVuZCgpO1xuICAgIH1cbiAgICBBc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlID0gbnVsbCkge1xuICAgICAgICBpZiAoY29uZGl0aW9uID09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiU3RvcnkgYXNzZXJ0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSArIFwiIFwiICsgdGhpcy5jdXJyZW50RGVidWdNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnREZWJ1Z01ldGFkYXRhKCkge1xuICAgICAgICBsZXQgZG07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgaWYgKCFwb2ludGVyLmlzTnVsbCAmJiBwb2ludGVyLlJlc29sdmUoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZG0gPSBwb2ludGVyLlJlc29sdmUoKS5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKGRtICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgcG9pbnRlciA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzW2ldLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICAgICAgaWYgKCFwb2ludGVyLmlzTnVsbCAmJiBwb2ludGVyLlJlc29sdmUoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRtID0gcG9pbnRlci5SZXNvbHZlKCkuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICBpZiAoZG0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBvdXRwdXRPYmogPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGRtID0gb3V0cHV0T2JqLmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoZG0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBtYWluQ29udGVudENvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yeSA9IFN0b3J5O1xuU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQgPSAxOTtcbihmdW5jdGlvbiAoU3RvcnkpIHtcbiAgICBsZXQgT3V0cHV0U3RhdGVDaGFuZ2U7XG4gICAgKGZ1bmN0aW9uIChPdXRwdXRTdGF0ZUNoYW5nZSkge1xuICAgICAgICBPdXRwdXRTdGF0ZUNoYW5nZVtPdXRwdXRTdGF0ZUNoYW5nZVtcIk5vQ2hhbmdlXCJdID0gMF0gPSBcIk5vQ2hhbmdlXCI7XG4gICAgICAgIE91dHB1dFN0YXRlQ2hhbmdlW091dHB1dFN0YXRlQ2hhbmdlW1wiRXh0ZW5kZWRCZXlvbmROZXdsaW5lXCJdID0gMV0gPSBcIkV4dGVuZGVkQmV5b25kTmV3bGluZVwiO1xuICAgICAgICBPdXRwdXRTdGF0ZUNoYW5nZVtPdXRwdXRTdGF0ZUNoYW5nZVtcIk5ld2xpbmVSZW1vdmVkXCJdID0gMl0gPSBcIk5ld2xpbmVSZW1vdmVkXCI7XG4gICAgfSkoT3V0cHV0U3RhdGVDaGFuZ2UgPSBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZSB8fCAoU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UgPSB7fSkpO1xufSkoU3RvcnkgPSBleHBvcnRzLlN0b3J5IHx8IChleHBvcnRzLlN0b3J5ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9yeUV4Y2VwdGlvbiA9IHZvaWQgMDtcbmNsYXNzIFN0b3J5RXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMudXNlRW5kTGluZU51bWJlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlN0b3J5RXhjZXB0aW9uXCI7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yeUV4Y2VwdGlvbiA9IFN0b3J5RXhjZXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcnlFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3J5U3RhdGUgPSB2b2lkIDA7XG5jb25zdCBDYWxsU3RhY2tfMSA9IHJlcXVpcmUoXCIuL0NhbGxTdGFja1wiKTtcbmNvbnN0IFZhcmlhYmxlc1N0YXRlXzEgPSByZXF1aXJlKFwiLi9WYXJpYWJsZXNTdGF0ZVwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBUYWdfMSA9IHJlcXVpcmUoXCIuL1RhZ1wiKTtcbmNvbnN0IEdsdWVfMSA9IHJlcXVpcmUoXCIuL0dsdWVcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgQ29udHJvbENvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL0NvbnRyb2xDb21tYW5kXCIpO1xuY29uc3QgU3RvcnlFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL1N0b3J5RXhjZXB0aW9uXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFBSTkdfMSA9IHJlcXVpcmUoXCIuL1BSTkdcIik7XG5jb25zdCBWb2lkXzEgPSByZXF1aXJlKFwiLi9Wb2lkXCIpO1xuY29uc3QgUG9pbnRlcl8xID0gcmVxdWlyZShcIi4vUG9pbnRlclwiKTtcbmNvbnN0IFRyeUdldFJlc3VsdF8xID0gcmVxdWlyZShcIi4vVHJ5R2V0UmVzdWx0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IERlYnVnXzEgPSByZXF1aXJlKFwiLi9EZWJ1Z1wiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTdG9yeV8xID0gcmVxdWlyZShcIi4vU3RvcnlcIik7XG5jb25zdCBTdGF0ZVBhdGNoXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVBhdGNoXCIpO1xuY29uc3QgU2ltcGxlSnNvbl8xID0gcmVxdWlyZShcIi4vU2ltcGxlSnNvblwiKTtcbmNsYXNzIFN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0b3J5KSB7XG4gICAgICAgIHRoaXMua0lua1NhdmVTdGF0ZVZlcnNpb24gPSA4O1xuICAgICAgICB0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24gPSA4O1xuICAgICAgICB0aGlzLl9jdXJyZW50RXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXZlcnRlZFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50VHVybkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdG9yeVNlZWQgPSAwO1xuICAgICAgICB0aGlzLnByZXZpb3VzUmFuZG9tID0gMDtcbiAgICAgICAgdGhpcy5kaWRTYWZlRXhpdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYWdzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLnN0b3J5ID0gc3Rvcnk7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbSA9IFtdO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRpb25TdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmNhbGxTdGFjayA9IG5ldyBDYWxsU3RhY2tfMS5DYWxsU3RhY2soc3RvcnkpO1xuICAgICAgICB0aGlzLl92YXJpYWJsZXNTdGF0ZSA9IG5ldyBWYXJpYWJsZXNTdGF0ZV8xLlZhcmlhYmxlc1N0YXRlKHRoaXMuY2FsbFN0YWNrLCBzdG9yeS5saXN0RGVmaW5pdGlvbnMpO1xuICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFR1cm5JbmRleCA9IC0xO1xuICAgICAgICBsZXQgdGltZVNlZWQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdGhpcy5zdG9yeVNlZWQgPSBuZXcgUFJOR18xLlBSTkcodGltZVNlZWQpLm5leHQoKSAlIDEwMDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1JhbmRvbSA9IDA7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzID0gW107XG4gICAgICAgIHRoaXMuR29Ub1N0YXJ0KCk7XG4gICAgfVxuICAgIFRvSnNvbihpbmRlbnRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCB3cml0ZXIgPSBuZXcgU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uV3JpdGVyKCk7XG4gICAgICAgIHRoaXMuV3JpdGVKc29uKHdyaXRlcik7XG4gICAgICAgIHJldHVybiB3cml0ZXIuVG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdG9Kc29uKGluZGVudGVkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVG9Kc29uKGluZGVudGVkKTtcbiAgICB9XG4gICAgTG9hZEpzb24oanNvbikge1xuICAgICAgICBsZXQgak9iamVjdCA9IFNpbXBsZUpzb25fMS5TaW1wbGVKc29uLlRleHRUb0RpY3Rpb25hcnkoanNvbik7XG4gICAgICAgIHRoaXMuTG9hZEpzb25PYmooak9iamVjdCk7XG4gICAgfVxuICAgIFZpc2l0Q291bnRBdFBhdGhTdHJpbmcocGF0aFN0cmluZykge1xuICAgICAgICBsZXQgdmlzaXRDb3VudE91dDtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5zdG9yeS5Db250ZW50QXRQYXRoKG5ldyBQYXRoXzEuUGF0aChwYXRoU3RyaW5nKSkuY29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZW50IGF0IHBhdGggbm90IGZvdW5kOiBcIiArIHBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgdmlzaXRDb3VudE91dCA9IHRoaXMuX3BhdGNoLlRyeUdldFZpc2l0Q291bnQoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIGlmICh2aXNpdENvdW50T3V0LmV4aXN0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRDb3VudE91dC5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRDb3VudE91dCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl92aXNpdENvdW50cywgcGF0aFN0cmluZywgbnVsbCk7XG4gICAgICAgIGlmICh2aXNpdENvdW50T3V0LmV4aXN0cylcbiAgICAgICAgICAgIHJldHVybiB2aXNpdENvdW50T3V0LnJlc3VsdDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIFZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmIChjb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyLnZpc2l0c1Nob3VsZEJlQ291bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yeS5FcnJvcihcIlJlYWQgY291bnQgZm9yIHRhcmdldCAoXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lICtcbiAgICAgICAgICAgICAgICBcIiAtIG9uIFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZGVidWdNZXRhZGF0YSArXG4gICAgICAgICAgICAgICAgXCIpIHVua25vd24uIFRoZSBzdG9yeSBtYXkgbmVlZCB0byBiZSBjb21waWxlZCB3aXRoIGNvdW50QWxsVmlzaXRzIGZsYWcgKC1jKS5cIik7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuX3BhdGNoLlRyeUdldFZpc2l0Q291bnQoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIGlmIChjb3VudC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY291bnQucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNvdW50MiA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl92aXNpdENvdW50cywgY29udGFpbmVyUGF0aFN0ciwgbnVsbCk7XG4gICAgICAgIGlmIChjb3VudDIuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gY291bnQyLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgSW5jcmVtZW50VmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY3VyckNvdW50ID0gdGhpcy5WaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBjdXJyQ291bnQrKztcbiAgICAgICAgICAgIHRoaXMuX3BhdGNoLlNldFZpc2l0Q291bnQoY29udGFpbmVyLCBjdXJyQ291bnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGNvdW50ID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3Zpc2l0Q291bnRzLCBjb250YWluZXJQYXRoU3RyLCBudWxsKTtcbiAgICAgICAgaWYgKGNvdW50LmV4aXN0cykge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMuc2V0KGNvbnRhaW5lclBhdGhTdHIsIGNvdW50LnJlc3VsdCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdmlzaXRDb3VudHMuc2V0KGNvbnRhaW5lclBhdGhTdHIsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlY29yZFR1cm5JbmRleFZpc2l0VG9Db250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcGF0Y2guU2V0VHVybkluZGV4KGNvbnRhaW5lciwgdGhpcy5jdXJyZW50VHVybkluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzLnNldChjb250YWluZXJQYXRoU3RyLCB0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO1xuICAgIH1cbiAgICBUdXJuc1NpbmNlRm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoIWNvbnRhaW5lci50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcnkuRXJyb3IoXCJUVVJOU19TSU5DRSgpIGZvciB0YXJnZXQgKFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIubmFtZSArXG4gICAgICAgICAgICAgICAgXCIgLSBvbiBcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmRlYnVnTWV0YWRhdGEgK1xuICAgICAgICAgICAgICAgIFwiKSB1bmtub3duLiBUaGUgc3RvcnkgbWF5IG5lZWQgdG8gYmUgY29tcGlsZWQgd2l0aCBjb3VudEFsbFZpc2l0cyBmbGFnICgtYykuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5fcGF0Y2guVHJ5R2V0VHVybkluZGV4KGNvbnRhaW5lciwgMCk7XG4gICAgICAgICAgICBpZiAoaW5kZXguZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFR1cm5JbmRleCAtIGluZGV4LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGFpbmVyUGF0aFN0ciA9IGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBpbmRleDIgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdHVybkluZGljZXMsIGNvbnRhaW5lclBhdGhTdHIsIDApO1xuICAgICAgICBpZiAoaW5kZXgyLmV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFR1cm5JbmRleCAtIGluZGV4Mi5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbGxzdGFja0RlcHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suZGVwdGg7XG4gICAgfVxuICAgIGdldCBvdXRwdXRTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXRwdXRTdHJlYW07XG4gICAgfVxuICAgIGdldCBjdXJyZW50Q2hvaWNlcygpIHtcbiAgICAgICAgLy8gSWYgd2UgY2FuIGNvbnRpbnVlIGdlbmVyYXRpbmcgdGV4dCBjb250ZW50IHJhdGhlciB0aGFuIGNob2ljZXMsXG4gICAgICAgIC8vIHRoZW4gd2UgcmVmbGVjdCB0aGUgY2hvaWNlIGxpc3QgYXMgYmVpbmcgZW1wdHksIHNpbmNlIGNob2ljZXNcbiAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyBjb21lIGF0IHRoZSBlbmQuXG4gICAgICAgIGlmICh0aGlzLmNhbkNvbnRpbnVlKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENob2ljZXM7XG4gICAgfVxuICAgIGdldCBnZW5lcmF0ZWRDaG9pY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudENob2ljZXM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEVycm9ycztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRXYXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRXYXJuaW5ncztcbiAgICB9XG4gICAgZ2V0IHZhcmlhYmxlc1N0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFyaWFibGVzU3RhdGU7XG4gICAgfVxuICAgIHNldCB2YXJpYWJsZXNTdGF0ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92YXJpYWJsZXNTdGF0ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXZhbHVhdGlvblN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZhbHVhdGlvblN0YWNrO1xuICAgIH1cbiAgICBnZXQgdmlzaXRDb3VudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdENvdW50cztcbiAgICB9XG4gICAgZ2V0IHR1cm5JbmRpY2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHVybkluZGljZXM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VHVybkluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFR1cm5JbmRleDtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRUdXJuSW5kZXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudFR1cm5JbmRleCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFBhdGhTdHJpbmcoKSB7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5jdXJyZW50UG9pbnRlcjtcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwb2ludGVyLnBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIucGF0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludGVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VycmVudFBvaW50ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgfVxuICAgIHNldCBjdXJyZW50UG9pbnRlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IHZhbHVlLmNvcHkoKTtcbiAgICB9XG4gICAgZ2V0IHByZXZpb3VzUG9pbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQucHJldmlvdXNQb2ludGVyLmNvcHkoKTtcbiAgICB9XG4gICAgc2V0IHByZXZpb3VzUG9pbnRlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50VGhyZWFkLnByZXZpb3VzUG9pbnRlciA9IHZhbHVlLmNvcHkoKTtcbiAgICB9XG4gICAgZ2V0IGNhbkNvbnRpbnVlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudFBvaW50ZXIuaXNOdWxsICYmICF0aGlzLmhhc0Vycm9yO1xuICAgIH1cbiAgICBnZXQgaGFzRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFcnJvcnMgIT0gbnVsbCAmJiB0aGlzLmN1cnJlbnRFcnJvcnMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGhhc1dhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRXYXJuaW5ncyAhPSBudWxsICYmIHRoaXMuY3VycmVudFdhcm5pbmdzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSkge1xuICAgICAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBvdXRwdXRPYmogb2YgdGhpcy5fb3V0cHV0U3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHRleHRDb250ZW50ID0gb3V0cHV0T2JqIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0Q29udGVudCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvdXRwdXRPYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29udGVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQodGV4dENvbnRlbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUZXh0ID0gdGhpcy5DbGVhbk91dHB1dFdoaXRlc3BhY2Uoc2IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRleHQ7XG4gICAgfVxuICAgIENsZWFuT3V0cHV0V2hpdGVzcGFjZShzdHIpIHtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIGxldCBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID0gLTE7XG4gICAgICAgIGxldCBzdGFydE9mTGluZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBsZXQgaXNJbmxpbmVXaGl0ZXNwYWNlID0gYyA9PSBcIiBcIiB8fCBjID09IFwiXFx0XCI7XG4gICAgICAgICAgICBpZiAoaXNJbmxpbmVXaGl0ZXNwYWNlICYmIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPT0gLTEpXG4gICAgICAgICAgICAgICAgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9IGk7XG4gICAgICAgICAgICBpZiAoIWlzSW5saW5lV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChjICE9IFwiXFxuXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdoaXRlc3BhY2VTdGFydCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFdoaXRlc3BhY2VTdGFydCAhPSBzdGFydE9mTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PSBcIlxcblwiKVxuICAgICAgICAgICAgICAgIHN0YXJ0T2ZMaW5lID0gaSArIDE7XG4gICAgICAgICAgICBpZiAoIWlzSW5saW5lV2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFncygpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IG91dHB1dE9iaiBvZiB0aGlzLl9vdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgdGFnID0gb3V0cHV0T2JqIGFzIFRhZztcbiAgICAgICAgICAgICAgICBsZXQgdGFnID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG91dHB1dE9iaiwgVGFnXzEuVGFnKTtcbiAgICAgICAgICAgICAgICBpZiAodGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUYWdzLnB1c2godGFnLnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGFncztcbiAgICB9XG4gICAgZ2V0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5pbkV4cHJlc3Npb25FdmFsdWF0aW9uO1xuICAgIH1cbiAgICBzZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIEdvVG9TdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHRoaXMuc3RvcnkubWFpbkNvbnRlbnRDb250YWluZXIpO1xuICAgIH1cbiAgICBDb3B5QW5kU3RhcnRQYXRjaGluZygpIHtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgU3RvcnlTdGF0ZSh0aGlzLnN0b3J5KTtcbiAgICAgICAgY29weS5fcGF0Y2ggPSBuZXcgU3RhdGVQYXRjaF8xLlN0YXRlUGF0Y2godGhpcy5fcGF0Y2gpO1xuICAgICAgICBjb3B5Lm91dHB1dFN0cmVhbS5wdXNoLmFwcGx5KGNvcHkub3V0cHV0U3RyZWFtLCB0aGlzLl9vdXRwdXRTdHJlYW0pO1xuICAgICAgICBjb3B5Lk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgIGNvcHkuX2N1cnJlbnRDaG9pY2VzLnB1c2guYXBwbHkoY29weS5fY3VycmVudENob2ljZXMsIHRoaXMuX2N1cnJlbnRDaG9pY2VzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgICAgICAgIGNvcHkuX2N1cnJlbnRFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvcHkuX2N1cnJlbnRFcnJvcnMucHVzaC5hcHBseShjb3B5Ll9jdXJyZW50RXJyb3JzLCB0aGlzLmN1cnJlbnRFcnJvcnMgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGNvcHkuX2N1cnJlbnRXYXJuaW5ncyA9IFtdO1xuICAgICAgICAgICAgY29weS5fY3VycmVudFdhcm5pbmdzLnB1c2guYXBwbHkoY29weS5fY3VycmVudFdhcm5pbmdzLCB0aGlzLmN1cnJlbnRXYXJuaW5ncyB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29weS5jYWxsU3RhY2sgPSBuZXcgQ2FsbFN0YWNrXzEuQ2FsbFN0YWNrKHRoaXMuY2FsbFN0YWNrKTtcbiAgICAgICAgY29weS52YXJpYWJsZXNTdGF0ZSA9IHRoaXMudmFyaWFibGVzU3RhdGU7XG4gICAgICAgIGNvcHkudmFyaWFibGVzU3RhdGUuY2FsbFN0YWNrID0gY29weS5jYWxsU3RhY2s7XG4gICAgICAgIGNvcHkudmFyaWFibGVzU3RhdGUucGF0Y2ggPSBjb3B5Ll9wYXRjaDtcbiAgICAgICAgY29weS5ldmFsdWF0aW9uU3RhY2sucHVzaC5hcHBseShjb3B5LmV2YWx1YXRpb25TdGFjaywgdGhpcy5ldmFsdWF0aW9uU3RhY2spO1xuICAgICAgICBpZiAoIXRoaXMuZGl2ZXJ0ZWRQb2ludGVyLmlzTnVsbClcbiAgICAgICAgICAgIGNvcHkuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5kaXZlcnRlZFBvaW50ZXIuY29weSgpO1xuICAgICAgICBjb3B5LnByZXZpb3VzUG9pbnRlciA9IHRoaXMucHJldmlvdXNQb2ludGVyLmNvcHkoKTtcbiAgICAgICAgY29weS5fdmlzaXRDb3VudHMgPSB0aGlzLl92aXNpdENvdW50cztcbiAgICAgICAgY29weS5fdHVybkluZGljZXMgPSB0aGlzLl90dXJuSW5kaWNlcztcbiAgICAgICAgY29weS5jdXJyZW50VHVybkluZGV4ID0gdGhpcy5jdXJyZW50VHVybkluZGV4O1xuICAgICAgICBjb3B5LnN0b3J5U2VlZCA9IHRoaXMuc3RvcnlTZWVkO1xuICAgICAgICBjb3B5LnByZXZpb3VzUmFuZG9tID0gdGhpcy5wcmV2aW91c1JhbmRvbTtcbiAgICAgICAgY29weS5kaWRTYWZlRXhpdCA9IHRoaXMuZGlkU2FmZUV4aXQ7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICBSZXN0b3JlQWZ0ZXJQYXRjaCgpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5jYWxsU3RhY2sgPSB0aGlzLmNhbGxTdGFjaztcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5wYXRjaCA9IHRoaXMuX3BhdGNoO1xuICAgIH1cbiAgICBBcHBseUFueVBhdGNoKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUuQXBwbHlQYXRjaCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fcGF0Y2gudmlzaXRDb3VudHMpXG4gICAgICAgICAgICB0aGlzLkFwcGx5Q291bnRDaGFuZ2VzKGtleSwgdmFsdWUsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5fcGF0Y2gudHVybkluZGljZXMpXG4gICAgICAgICAgICB0aGlzLkFwcGx5Q291bnRDaGFuZ2VzKGtleSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcGF0Y2ggPSBudWxsO1xuICAgIH1cbiAgICBBcHBseUNvdW50Q2hhbmdlcyhjb250YWluZXIsIG5ld0NvdW50LCBpc1Zpc2l0KSB7XG4gICAgICAgIGxldCBjb3VudHMgPSBpc1Zpc2l0ID8gdGhpcy5fdmlzaXRDb3VudHMgOiB0aGlzLl90dXJuSW5kaWNlcztcbiAgICAgICAgY291bnRzLnNldChjb250YWluZXIucGF0aC50b1N0cmluZygpLCBuZXdDb3VudCk7XG4gICAgfVxuICAgIFdyaXRlSnNvbih3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgbGV0IGhhc0Nob2ljZVRocmVhZHMgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcykge1xuICAgICAgICAgICAgaWYgKGMudGhyZWFkQXRHZW5lcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjLnRocmVhZEF0R2VuZXJhdGlvblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMub3JpZ2luYWxUaHJlYWRJbmRleCA9IGMudGhyZWFkQXRHZW5lcmF0aW9uLnRocmVhZEluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLlRocmVhZFdpdGhJbmRleChjLm9yaWdpbmFsVGhyZWFkSW5kZXgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNDaG9pY2VUaHJlYWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0Nob2ljZVRocmVhZHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwiY2hvaWNlVGhyZWFkc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChjLm9yaWdpbmFsVGhyZWFkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGMudGhyZWFkQXRHZW5lcmF0aW9uLldyaXRlSnNvbih3cml0ZXIpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Nob2ljZVRocmVhZHMpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nIHR3byBjYWxscywgYFdyaXRlSnNvbmAgaXMgY2FsbGVkIGluc2lkZSBhbiBhcnJvd1xuICAgICAgICAvLyBmdW5jdGlvbiB0byBtYWtlIHN1cmUgYHRoaXNgIGlzIGNvcnJlY3RseSBib3VuZCBhbmQgcGFzc2VkIGRvd25cbiAgICAgICAgLy8gdGhlIGNhbGwgaGllcmFyY2h5LlxuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImNhbGxzdGFja1RocmVhZHNcIiwgKHcpID0+IHRoaXMuY2FsbFN0YWNrLldyaXRlSnNvbih3KSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidmFyaWFibGVzU3RhdGVcIiwgKHcpID0+IHRoaXMudmFyaWFibGVzU3RhdGUuV3JpdGVKc29uKHcpKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJldmFsU3RhY2tcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVMaXN0UnVudGltZU9ianModywgdGhpcy5ldmFsdWF0aW9uU3RhY2spKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJvdXRwdXRTdHJlYW1cIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVMaXN0UnVudGltZU9ianModywgdGhpcy5fb3V0cHV0U3RyZWFtKSk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY3VycmVudENob2ljZXNcIiwgKHcpID0+IHtcbiAgICAgICAgICAgIHcuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKVxuICAgICAgICAgICAgICAgIEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVDaG9pY2UodywgYyk7XG4gICAgICAgICAgICB3LldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXZlcnRlZFBvaW50ZXIucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiZGl2ZXJ0ZWRQb2ludGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjdXJyZW50RGl2ZXJ0VGFyZ2V0XCIsIHRoaXMuZGl2ZXJ0ZWRQb2ludGVyLnBhdGguY29tcG9uZW50c1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ2aXNpdENvdW50c1wiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUludERpY3Rpb25hcnkodywgdGhpcy5fdmlzaXRDb3VudHMpKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ0dXJuSW5kaWNlc1wiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUludERpY3Rpb25hcnkodywgdGhpcy5fdHVybkluZGljZXMpKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJ0dXJuSWR4XCIsIHRoaXMuY3VycmVudFR1cm5JbmRleCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwic3RvcnlTZWVkXCIsIHRoaXMuc3RvcnlTZWVkKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJwcmV2aW91c1JhbmRvbVwiLCB0aGlzLnByZXZpb3VzUmFuZG9tKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpbmtTYXZlVmVyc2lvblwiLCB0aGlzLmtJbmtTYXZlU3RhdGVWZXJzaW9uKTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpbmtGb3JtYXRWZXJzaW9uXCIsIFN0b3J5XzEuU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgTG9hZEpzb25PYmoodmFsdWUpIHtcbiAgICAgICAgbGV0IGpPYmplY3QgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGpTYXZlVmVyc2lvbiA9IGpPYmplY3RbXCJpbmtTYXZlVmVyc2lvblwiXTtcbiAgICAgICAgaWYgKGpTYXZlVmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcImluayBzYXZlIGZvcm1hdCBpbmNvcnJlY3QsIGNhbid0IGxvYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnNlSW50KGpTYXZlVmVyc2lvbikgPCB0aGlzLmtNaW5Db21wYXRpYmxlTG9hZFZlcnNpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiSW5rIHNhdmUgZm9ybWF0IGlzbid0IGNvbXBhdGlibGUgd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIChzYXcgJ1wiICtcbiAgICAgICAgICAgICAgICBqU2F2ZVZlcnNpb24gK1xuICAgICAgICAgICAgICAgIFwiJywgYnV0IG1pbmltdW0gaXMgXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbiArXG4gICAgICAgICAgICAgICAgXCIpLCBzbyBjYW4ndCBsb2FkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxTdGFjay5TZXRKc29uVG9rZW4oak9iamVjdFtcImNhbGxzdGFja1RocmVhZHNcIl0sIHRoaXMuc3RvcnkpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLlNldEpzb25Ub2tlbihqT2JqZWN0W1widmFyaWFibGVzU3RhdGVcIl0pO1xuICAgICAgICB0aGlzLl9ldmFsdWF0aW9uU3RhY2sgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpBcnJheVRvUnVudGltZU9iakxpc3Qoak9iamVjdFtcImV2YWxTdGFja1wiXSk7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbSA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdChqT2JqZWN0W1wib3V0cHV0U3RyZWFtXCJdKTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgICAgICAvLyBjdXJyZW50Q2hvaWNlcyA9IEpzb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdDxDaG9pY2U+KChKQXJyYXkpak9iamVjdCBbXCJjdXJyZW50Q2hvaWNlc1wiXSk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpPYmplY3RbXCJjdXJyZW50Q2hvaWNlc1wiXSk7XG4gICAgICAgIGxldCBjdXJyZW50RGl2ZXJ0VGFyZ2V0UGF0aCA9IGpPYmplY3RbXCJjdXJyZW50RGl2ZXJ0VGFyZ2V0XCJdO1xuICAgICAgICBpZiAoY3VycmVudERpdmVydFRhcmdldFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRpdmVydFBhdGggPSBuZXcgUGF0aF8xLlBhdGgoY3VycmVudERpdmVydFRhcmdldFBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLmRpdmVydGVkUG9pbnRlciA9IHRoaXMuc3RvcnkuUG9pbnRlckF0UGF0aChkaXZlcnRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSk9iamVjdFRvSW50RGljdGlvbmFyeShqT2JqZWN0W1widmlzaXRDb3VudHNcIl0pO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSk9iamVjdFRvSW50RGljdGlvbmFyeShqT2JqZWN0W1widHVybkluZGljZXNcIl0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRUdXJuSW5kZXggPSBwYXJzZUludChqT2JqZWN0W1widHVybklkeFwiXSk7XG4gICAgICAgIHRoaXMuc3RvcnlTZWVkID0gcGFyc2VJbnQoak9iamVjdFtcInN0b3J5U2VlZFwiXSk7XG4gICAgICAgIHRoaXMucHJldmlvdXNSYW5kb20gPSBwYXJzZUludChqT2JqZWN0W1wicHJldmlvdXNSYW5kb21cIl0pO1xuICAgICAgICAvLyB2YXIgakNob2ljZVRocmVhZHMgPSBqT2JqZWN0W1wiY2hvaWNlVGhyZWFkc1wiXSBhcyBKT2JqZWN0O1xuICAgICAgICBsZXQgakNob2ljZVRocmVhZHMgPSBqT2JqZWN0W1wiY2hvaWNlVGhyZWFkc1wiXTtcbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9jdXJyZW50Q2hvaWNlcykge1xuICAgICAgICAgICAgbGV0IGZvdW5kQWN0aXZlVGhyZWFkID0gdGhpcy5jYWxsU3RhY2suVGhyZWFkV2l0aEluZGV4KGMub3JpZ2luYWxUaHJlYWRJbmRleCk7XG4gICAgICAgICAgICBpZiAoZm91bmRBY3RpdmVUaHJlYWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGMudGhyZWFkQXRHZW5lcmF0aW9uID0gZm91bmRBY3RpdmVUaHJlYWQuQ29weSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGpTYXZlZENob2ljZVRocmVhZCA9IGpDaG9pY2VUaHJlYWRzW2Mub3JpZ2luYWxUaHJlYWRJbmRleC50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICBjLnRocmVhZEF0R2VuZXJhdGlvbiA9IG5ldyBDYWxsU3RhY2tfMS5DYWxsU3RhY2suVGhyZWFkKGpTYXZlZENob2ljZVRocmVhZCwgdGhpcy5zdG9yeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVzZXRFcnJvcnMoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MgPSBudWxsO1xuICAgIH1cbiAgICBSZXNldE91dHB1dChvYmpzID0gbnVsbCkge1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKG9ianMgIT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0ucHVzaC5hcHBseSh0aGlzLl9vdXRwdXRTdHJlYW0sIG9ianMpO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIFB1c2hUb091dHB1dFN0cmVhbShvYmopIHtcbiAgICAgICAgLy8gdmFyIHRleHQgPSBvYmogYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgIGxldCB0ZXh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgIGlmICh0ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbGlzdFRleHQgPSB0aGlzLlRyeVNwbGl0dGluZ0hlYWRUYWlsV2hpdGVzcGFjZSh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChsaXN0VGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHRleHRPYmogb2YgbGlzdFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKHRleHRPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbChvYmopO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIFBvcEZyb21PdXRwdXRTdHJlYW0oY291bnQpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRTdHJlYW0uc3BsaWNlKHRoaXMub3V0cHV0U3RyZWFtLmxlbmd0aCAtIGNvdW50LCBjb3VudCk7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgVHJ5U3BsaXR0aW5nSGVhZFRhaWxXaGl0ZXNwYWNlKHNpbmdsZSkge1xuICAgICAgICBsZXQgc3RyID0gc2luZ2xlLnZhbHVlO1xuICAgICAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInNpbmdsZS52YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVhZEZpcnN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBsZXQgaGVhZExhc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHN0cltpXTtcbiAgICAgICAgICAgIGlmIChjID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgaGVhZEZpcnN0TmV3bGluZUlkeCA9IGk7XG4gICAgICAgICAgICAgICAgaGVhZExhc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gXCIgXCIgfHwgYyA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWlsTGFzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgbGV0IHRhaWxGaXJzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRhaWxMYXN0TmV3bGluZUlkeCA9IGk7XG4gICAgICAgICAgICAgICAgdGFpbEZpcnN0TmV3bGluZUlkeCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09IFwiIFwiIHx8IGMgPT0gXCJcXHRcIilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBzcGxpdHRpbmcgdG8gYmUgZG9uZT9cbiAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggPT0gLTEgJiYgdGFpbExhc3ROZXdsaW5lSWR4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBsaXN0VGV4dHMgPSBbXTtcbiAgICAgICAgbGV0IGlubmVyU3RyU3RhcnQgPSAwO1xuICAgICAgICBsZXQgaW5uZXJTdHJFbmQgPSBzdHIubGVuZ3RoO1xuICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCAhPSAtMSkge1xuICAgICAgICAgICAgaWYgKGhlYWRGaXJzdE5ld2xpbmVJZHggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGxlYWRpbmdTcGFjZXMgPSBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzdHIuc3Vic3RyaW5nKDAsIGhlYWRGaXJzdE5ld2xpbmVJZHgpKTtcbiAgICAgICAgICAgICAgICBsaXN0VGV4dHMucHVzaChsZWFkaW5nU3BhY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIGlubmVyU3RyU3RhcnQgPSBoZWFkTGFzdE5ld2xpbmVJZHggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggIT0gLTEpIHtcbiAgICAgICAgICAgIGlubmVyU3RyRW5kID0gdGFpbEZpcnN0TmV3bGluZUlkeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5uZXJTdHJFbmQgPiBpbm5lclN0clN0YXJ0KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXJTdHJUZXh0ID0gc3RyLnN1YnN0cmluZyhpbm5lclN0clN0YXJ0LCBpbm5lclN0ckVuZCAtIGlubmVyU3RyU3RhcnQpO1xuICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoaW5uZXJTdHJUZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCAhPSAtMSAmJiB0YWlsRmlyc3ROZXdsaW5lSWR4ID4gaGVhZExhc3ROZXdsaW5lSWR4KSB7XG4gICAgICAgICAgICBsaXN0VGV4dHMucHVzaChuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShcIlxcblwiKSk7XG4gICAgICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4IDwgc3RyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgbnVtU3BhY2VzID0gc3RyLmxlbmd0aCAtIHRhaWxMYXN0TmV3bGluZUlkeCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWlsaW5nU3BhY2VzID0gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoc3RyLnN1YnN0cmluZyh0YWlsTGFzdE5ld2xpbmVJZHggKyAxLCBudW1TcGFjZXMpKTtcbiAgICAgICAgICAgICAgICBsaXN0VGV4dHMucHVzaCh0cmFpbGluZ1NwYWNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RUZXh0cztcbiAgICB9XG4gICAgUHVzaFRvT3V0cHV0U3RyZWFtSW5kaXZpZHVhbChvYmopIHtcbiAgICAgICAgbGV0IGdsdWUgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBHbHVlXzEuR2x1ZSk7XG4gICAgICAgIGxldCB0ZXh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgIGxldCBpbmNsdWRlSW5PdXRwdXQgPSB0cnVlO1xuICAgICAgICBpZiAoZ2x1ZSkge1xuICAgICAgICAgICAgdGhpcy5UcmltTmV3bGluZXNGcm9tT3V0cHV0U3RyZWFtKCk7XG4gICAgICAgICAgICBpbmNsdWRlSW5PdXRwdXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRleHQpIHtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvblRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgbGV0IGN1cnJFbCA9IHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGN1cnJFbC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uVHJpbUluZGV4ID0gY3VyckVsLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBnbHVlVHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG8gPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICAgICAgbGV0IGMgPSBvIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCA/IG8gOiBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBnID0gbyBpbnN0YW5jZW9mIEdsdWVfMS5HbHVlID8gbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnbHVlVHJpbUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGMgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBjLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPj0gZnVuY3Rpb25UcmltSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uVHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyaW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKGdsdWVUcmltSW5kZXggIT0gLTEgJiYgZnVuY3Rpb25UcmltSW5kZXggIT0gLTEpXG4gICAgICAgICAgICAgICAgdHJpbUluZGV4ID0gTWF0aC5taW4oZnVuY3Rpb25UcmltSW5kZXgsIGdsdWVUcmltSW5kZXgpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZ2x1ZVRyaW1JbmRleCAhPSAtMSlcbiAgICAgICAgICAgICAgICB0cmltSW5kZXggPSBnbHVlVHJpbUluZGV4O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRyaW1JbmRleCA9IGZ1bmN0aW9uVHJpbUluZGV4O1xuICAgICAgICAgICAgaWYgKHRyaW1JbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmlzTmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlSW5PdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGV4dC5pc05vbldoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsdWVUcmltSW5kZXggPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuUmVtb3ZlRXhpc3RpbmdHbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvblRyaW1JbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FsbFN0YWNrRWxlbWVudHMgPSB0aGlzLmNhbGxTdGFjay5lbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBjYWxsU3RhY2tFbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbCA9IGNhbGxTdGFja0VsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRleHQuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSB8fCAhdGhpcy5vdXRwdXRTdHJlYW1Db250YWluc0NvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVJbk91dHB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbmNsdWRlSW5PdXRwdXQpIHtcbiAgICAgICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9ialwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5wdXNoKG9iaik7XG4gICAgICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJpbU5ld2xpbmVzRnJvbU91dHB1dFN0cmVhbSgpIHtcbiAgICAgICAgbGV0IHJlbW92ZVdoaXRlc3BhY2VGcm9tID0gLTE7XG4gICAgICAgIGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBsZXQgY21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgICAgICBsZXQgdHh0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoY21kICE9IG51bGwgfHwgKHR4dCAhPSBudWxsICYmIHR4dC5pc05vbldoaXRlc3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eHQgIT0gbnVsbCAmJiB0eHQuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlV2hpdGVzcGFjZUZyb20gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgd2hpdGVzcGFjZVxuICAgICAgICBpZiAocmVtb3ZlV2hpdGVzcGFjZUZyb20gPj0gMCkge1xuICAgICAgICAgICAgaSA9IHJlbW92ZVdoaXRlc3BhY2VGcm9tO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5fb3V0cHV0U3RyZWFtW2ldLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIFJlbW92ZUV4aXN0aW5nR2x1ZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEdsdWVfMS5HbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBnZXQgb3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB0aGlzLl9vdXRwdXRTdHJlYW1baV07XG4gICAgICAgICAgICAgICAgaWYgKHRleHQgaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0LmlzTmV3bGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0LmlzTm9uV2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBvdXRwdXRTdHJlYW1Db250YWluc0NvbnRlbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtW2ldIGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBpblN0cmluZ0V2YWx1YXRpb24oKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIC8vIHZhciBjbWQgPSB0aGlzLl9vdXRwdXRTdHJlYW1baV0gYXMgQ29udHJvbENvbW1hbmQ7XG4gICAgICAgICAgICBsZXQgY21kID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuX291dHB1dFN0cmVhbVtpXSwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCk7XG4gICAgICAgICAgICBpZiAoY21kIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCAmJlxuICAgICAgICAgICAgICAgIGNtZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBQdXNoRXZhbHVhdGlvblN0YWNrKG9iaikge1xuICAgICAgICAvLyB2YXIgbGlzdFZhbHVlID0gb2JqIGFzIExpc3RWYWx1ZTtcbiAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKGxpc3RWYWx1ZSkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIG9yaWdpbiB3aGVuIGxpc3QgaXMgaGFzIHNvbWV0aGluZyB0byBpbmRpY2F0ZSB0aGUgbGlzdCBvcmlnaW5cbiAgICAgICAgICAgIGxldCByYXdMaXN0ID0gbGlzdFZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhd0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInJhd0xpc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmF3TGlzdC5vcmlnaW5OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyYXdMaXN0Lm9yaWdpbnMpXG4gICAgICAgICAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2lucyA9IFtdO1xuICAgICAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2lucy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG4gb2YgcmF3TGlzdC5vcmlnaW5OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yeS5saXN0RGVmaW5pdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlN0b3J5U3RhdGUuc3RvcnkubGlzdERlZmluaXRpb25zXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVmID0gdGhpcy5zdG9yeS5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24obiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYucmVzdWx0ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJTdG9yeVN0YXRlIGRlZi5yZXN1bHRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYXdMaXN0Lm9yaWdpbnMuaW5kZXhPZihkZWYucmVzdWx0KSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdMaXN0Lm9yaWdpbnMucHVzaChkZWYucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmpcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmFsdWF0aW9uU3RhY2sucHVzaChvYmopO1xuICAgIH1cbiAgICBQb3BFdmFsdWF0aW9uU3RhY2sobnVtYmVyT2ZPYmplY3RzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtYmVyT2ZPYmplY3RzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5ldmFsdWF0aW9uU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLm51bGxJZlVuZGVmaW5lZChvYmopO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG51bWJlck9mT2JqZWN0cyA+IHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeWluZyB0byBwb3AgdG9vIG1hbnkgb2JqZWN0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb3BwZWQgPSB0aGlzLmV2YWx1YXRpb25TdGFjay5zcGxpY2UodGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoIC0gbnVtYmVyT2ZPYmplY3RzLCBudW1iZXJPZk9iamVjdHMpO1xuICAgICAgICAgICAgcmV0dXJuIFR5cGVBc3NlcnRpb25fMS5udWxsSWZVbmRlZmluZWQocG9wcGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQZWVrRXZhbHVhdGlvblN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ldmFsdWF0aW9uU3RhY2tbdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIEZvcmNlRW5kKCkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5SZXNldCgpO1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy5wcmV2aW91c1BvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLmRpZFNhZmVFeGl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgVHJpbVdoaXRlc3BhY2VGcm9tRnVuY3Rpb25FbmQoKSB7XG4gICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKTtcbiAgICAgICAgbGV0IGZ1bmN0aW9uU3RhcnRQb2ludCA9IHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50XG4gICAgICAgICAgICAuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtO1xuICAgICAgICBpZiAoZnVuY3Rpb25TdGFydFBvaW50ID09IC0xKSB7XG4gICAgICAgICAgICBmdW5jdGlvblN0YXJ0UG9pbnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSBmdW5jdGlvblN0YXJ0UG9pbnQ7IGktLSkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGxldCB0eHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGxldCBjbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgIGlmICh0eHQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjbWQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodHh0LmlzTmV3bGluZSB8fCB0eHQuaXNJbmxpbmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQb3BDYWxsU3RhY2socG9wVHlwZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKVxuICAgICAgICAgICAgdGhpcy5UcmltV2hpdGVzcGFjZUZyb21GdW5jdGlvbkVuZCgpO1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5Qb3AocG9wVHlwZSk7XG4gICAgfVxuICAgIFNldENob3NlblBhdGgocGF0aCwgaW5jcmVtZW50aW5nVHVybkluZGV4KSB7XG4gICAgICAgIC8vIENoYW5naW5nIGRpcmVjdGlvbiwgYXNzdW1lIHdlIG5lZWQgdG8gY2xlYXIgY3VycmVudCBzZXQgb2YgY2hvaWNlc1xuICAgICAgICB0aGlzLl9jdXJyZW50Q2hvaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICBsZXQgbmV3UG9pbnRlciA9IHRoaXMuc3RvcnkuUG9pbnRlckF0UGF0aChwYXRoKTtcbiAgICAgICAgaWYgKCFuZXdQb2ludGVyLmlzTnVsbCAmJiBuZXdQb2ludGVyLmluZGV4ID09IC0xKVxuICAgICAgICAgICAgbmV3UG9pbnRlci5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBuZXdQb2ludGVyO1xuICAgICAgICBpZiAoaW5jcmVtZW50aW5nVHVybkluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUdXJuSW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdGFydEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKGZ1bmNDb250YWluZXIsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suUHVzaChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUsIHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihmdW5jQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5QYXNzQXJndW1lbnRzVG9FdmFsdWF0aW9uU3RhY2soYXJncyk7XG4gICAgfVxuICAgIFBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhhcmdzKSB7XG4gICAgICAgIC8vIFBhc3MgYXJndW1lbnRzIG9udG8gdGhlIGV2YWx1YXRpb24gc3RhY2tcbiAgICAgICAgaWYgKGFyZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGFyZ3NbaV0gPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGFyZ3NbaV0gPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluayBhcmd1bWVudHMgd2hlbiBjYWxsaW5nIEV2YWx1YXRlRnVuY3Rpb24gLyBDaG9vc2VQYXRoU3RyaW5nV2l0aFBhcmFtZXRlcnMgIG11c3QgYmUgaW50LCBmbG9hdCBvciBzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuUHVzaEV2YWx1YXRpb25TdGFjayhWYWx1ZV8xLlZhbHVlLkNyZWF0ZShhcmdzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJ5RXhpdEZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PVxuICAgICAgICAgICAgUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGlkU2FmZUV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBDb21wbGV0ZUZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKCkge1xuICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSAhPVxuICAgICAgICAgICAgUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkV4cGVjdGVkIGV4dGVybmFsIGZ1bmN0aW9uIGV2YWx1YXRpb24gdG8gYmUgY29tcGxldGUuIFN0YWNrIHRyYWNlOiBcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsU3RhY2suY2FsbFN0YWNrVHJhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcmlnaW5hbEV2YWx1YXRpb25TdGFja0hlaWdodCA9IHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50XG4gICAgICAgICAgICAuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZDtcbiAgICAgICAgbGV0IHJldHVybmVkT2JqID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHRoaXMuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCA+IG9yaWdpbmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0KSB7XG4gICAgICAgICAgICBsZXQgcG9wcGVkT2JqID0gdGhpcy5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZE9iaiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm5lZE9iaiA9IHBvcHBlZE9iajtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLlBvcENhbGxTdGFjayhQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpO1xuICAgICAgICBpZiAocmV0dXJuZWRPYmopIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZE9iaiBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgLy8gU29tZSBraW5kIG9mIHZhbHVlLCBpZiBub3Qgdm9pZFxuICAgICAgICAgICAgLy8gdmFyIHJldHVyblZhbCA9IHJldHVybmVkT2JqIGFzIFJ1bnRpbWUuVmFsdWU7XG4gICAgICAgICAgICBsZXQgcmV0dXJuVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocmV0dXJuZWRPYmosIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgLy8gRGl2ZXJ0VGFyZ2V0cyBnZXQgcmV0dXJuZWQgYXMgdGhlIHN0cmluZyBvZiBjb21wb25lbnRzXG4gICAgICAgICAgICAvLyAocmF0aGVyIHRoYW4gYSBQYXRoLCB3aGljaCBpc24ndCBwdWJsaWMpXG4gICAgICAgICAgICBpZiAocmV0dXJuVmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsLnZhbHVlT2JqZWN0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdGhlciB0eXBlcyBjYW4ganVzdCBoYXZlIHRoZWlyIGV4YWN0IG9iamVjdCB0eXBlOlxuICAgICAgICAgICAgLy8gaW50LCBmbG9hdCwgc3RyaW5nLiBWYXJpYWJsZVBvaW50ZXJzIGdldCByZXR1cm5lZCBhcyBzdHJpbmdzLlxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbC52YWx1ZU9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgQWRkRXJyb3IobWVzc2FnZSwgaXNXYXJuaW5nKSB7XG4gICAgICAgIGlmICghaXNXYXJuaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEVycm9ycyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRFcnJvcnMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50V2FybmluZ3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE91dHB1dFN0cmVhbURpcnR5KCkge1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RvcnlTdGF0ZSA9IFN0b3J5U3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yeVN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpbmdCdWlsZGVyID0gdm9pZCAwO1xuY2xhc3MgU3RyaW5nQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyKSB7XG4gICAgICAgIHN0ciA9IHR5cGVvZiBzdHIgIT09IFwidW5kZWZpbmVkXCIgPyBzdHIudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyO1xuICAgIH1cbiAgICBnZXQgTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBBcHBlbmQoc3RyKSB7XG4gICAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyaW5nICs9IHN0cjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcHBlbmRMaW5lKHN0cikge1xuICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRoaXMuQXBwZW5kKHN0cik7XG4gICAgICAgIHRoaXMuc3RyaW5nICs9IFwiXFxuXCI7XG4gICAgfVxuICAgIEFwcGVuZEZvcm1hdChmb3JtYXQsIC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gdGFrZW4gZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYxMDQwNi9qYXZhc2NyaXB0LWVxdWl2YWxlbnQtdG8tcHJpbnRmLXN0cmluZy1mb3JtYXRcbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gZm9ybWF0LnJlcGxhY2UoL3soXFxkKyl9L2csIChtYXRjaCwgbnVtKSA9PiB0eXBlb2YgYXJnc1tudW1dICE9IFwidW5kZWZpbmVkXCIgPyBhcmdzW251bV0gOiBtYXRjaCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmc7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdCdWlsZGVyID0gU3RyaW5nQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0J1aWxkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRhZyA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgVGFnIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdUZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGV4dCA9IHRhZ1RleHQudG9TdHJpbmcoKSB8fCBcIlwiO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiIyBcIiArIHRoaXMudGV4dDtcbiAgICB9XG59XG5leHBvcnRzLlRhZyA9IFRhZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJ5UGFyc2VGbG9hdCA9IGV4cG9ydHMudHJ5UGFyc2VJbnQgPSBleHBvcnRzLnRyeUdldFZhbHVlRnJvbU1hcCA9IHZvaWQgMDtcbmZ1bmN0aW9uIHRyeUdldFZhbHVlRnJvbU1hcChtYXAsIGtleSwgXG4vKiBvdXQgKi8gdmFsdWUpIHtcbiAgICBpZiAobWFwID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgbGV0IHZhbCA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbCwgZXhpc3RzOiB0cnVlIH07XG4gICAgfVxufVxuZXhwb3J0cy50cnlHZXRWYWx1ZUZyb21NYXAgPSB0cnlHZXRWYWx1ZUZyb21NYXA7XG5mdW5jdGlvbiB0cnlQYXJzZUludCh2YWx1ZSwgXG4vKiBvdXQgKi8gZGVmYXVsdFZhbHVlID0gMCkge1xuICAgIGxldCB2YWwgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbCwgZXhpc3RzOiB0cnVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZmF1bHRWYWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJ5UGFyc2VJbnQgPSB0cnlQYXJzZUludDtcbmZ1bmN0aW9uIHRyeVBhcnNlRmxvYXQodmFsdWUsIFxuLyogb3V0ICovIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgICBsZXQgdmFsID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbCwgZXhpc3RzOiB0cnVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZmF1bHRWYWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMudHJ5UGFyc2VGbG9hdCA9IHRyeVBhcnNlRmxvYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcnlHZXRSZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRXF1YXRhYmxlID0gZXhwb3J0cy5udWxsSWZVbmRlZmluZWQgPSBleHBvcnRzLmFzSU5hbWVkQ29udGVudE9yTnVsbCA9IGV4cG9ydHMuYXNOdW1iZXJPclRocm93cyA9IGV4cG9ydHMuYXNPclRocm93cyA9IGV4cG9ydHMuYXNPck51bGwgPSB2b2lkIDA7XG5mdW5jdGlvbiBhc09yTnVsbChvYmosIHR5cGUpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICByZXR1cm4gdW5zYWZlVHlwZUFzc2VydGlvbihvYmosIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5hc09yTnVsbCA9IGFzT3JOdWxsO1xuZnVuY3Rpb24gYXNPclRocm93cyhvYmosIHR5cGUpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICByZXR1cm4gdW5zYWZlVHlwZUFzc2VydGlvbihvYmosIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke29ian0gaXMgbm90IG9mIHR5cGUgJHt0eXBlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNPclRocm93cyA9IGFzT3JUaHJvd3M7XG5mdW5jdGlvbiBhc051bWJlck9yVGhyb3dzKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqfSBpcyBub3QgYSBudW1iZXJgKTtcbiAgICB9XG59XG5leHBvcnRzLmFzTnVtYmVyT3JUaHJvd3MgPSBhc051bWJlck9yVGhyb3dzO1xuLy8gU28gaGVyZSwgaW4gdGhlIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvbiwgY29udGVudE9iaiBpcyBjYXN0ZWQgdG8gYW4gSU5hbWVkQ29udGVudFxuLy8gYnV0IGhlcmUgd2UgdXNlIGpzLXN0eWxlIGR1Y2sgdHlwaW5nOiBpZiBpdCBpbXBsZW1lbnRzIHRoZSBzYW1lIHByb3BzIGFzIHRoZSBpbnRlcmZhY2UsXG4vLyB3ZSB0cmVhdCBpdCBhcyB2YWxpZC5cbmZ1bmN0aW9uIGFzSU5hbWVkQ29udGVudE9yTnVsbChvYmopIHtcbiAgICBpZiAob2JqLmhhc1ZhbGlkTmFtZSAmJiBvYmoubmFtZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuYXNJTmFtZWRDb250ZW50T3JOdWxsID0gYXNJTmFtZWRDb250ZW50T3JOdWxsO1xuZnVuY3Rpb24gbnVsbElmVW5kZWZpbmVkKG9iaikge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0cy5udWxsSWZVbmRlZmluZWQgPSBudWxsSWZVbmRlZmluZWQ7XG5mdW5jdGlvbiBpc0VxdWF0YWJsZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB0eXBlLkVxdWFscyA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0VxdWF0YWJsZSA9IGlzRXF1YXRhYmxlO1xuZnVuY3Rpb24gdW5zYWZlVHlwZUFzc2VydGlvbihvYmosIHR5cGUpIHtcbiAgICByZXR1cm4gb2JqO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHlwZUFzc2VydGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsdWVUeXBlID0gZXhwb3J0cy5MaXN0VmFsdWUgPSBleHBvcnRzLlZhcmlhYmxlUG9pbnRlclZhbHVlID0gZXhwb3J0cy5EaXZlcnRUYXJnZXRWYWx1ZSA9IGV4cG9ydHMuU3RyaW5nVmFsdWUgPSBleHBvcnRzLkZsb2F0VmFsdWUgPSBleHBvcnRzLkludFZhbHVlID0gZXhwb3J0cy5WYWx1ZSA9IGV4cG9ydHMuQWJzdHJhY3RWYWx1ZSA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IElua0xpc3RfMSA9IHJlcXVpcmUoXCIuL0lua0xpc3RcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgQWJzdHJhY3RWYWx1ZSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgc3RhdGljIENyZWF0ZSh2YWwsIHByZWZlcnJlZE51bWJlclR5cGUpIHtcbiAgICAgICAgLy8gVGhpcyBjb2RlIGRvZXNuJ3QgZXhpc3QgaW4gdXBzdHJlYW0gYW5kIGlzIHNpbXBseSBoZXJlIHRvIGVuZm9yY2VcbiAgICAgICAgLy8gdGhlIGNyZWF0aW9uIG9mIHRoZSBwcm9wZXIgbnVtYmVyIHZhbHVlLlxuICAgICAgICAvLyBJZiBgcHJlZmVycmVkTnVtYmVyVHlwZWAgaXMgbm90IHByb3ZpZGVkIG9yIGlmIHZhbHVlIGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgLy8gYHByZWZlcnJlZE51bWJlclR5cGVgLCB0aGlzIGNvbmRpdGlvbmFsIGRvZXMgbm90aGluZy5cbiAgICAgICAgaWYgKHByZWZlcnJlZE51bWJlclR5cGUpIHtcbiAgICAgICAgICAgIGlmIChwcmVmZXJyZWROdW1iZXJUeXBlID09PSBWYWx1ZVR5cGUuSW50ICYmXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZWZlcnJlZE51bWJlclR5cGUgPT09IFZhbHVlVHlwZS5GbG9hdCAmJlxuICAgICAgICAgICAgICAgICFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdFZhbHVlKE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbXBsaWNpdGx5IGNvbnZlcnQgYm9vbHMgaW50byBpbnRzXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgbGV0IGIgPSAhIXZhbDtcbiAgICAgICAgICAgIHZhbCA9IGIgPyAxIDogMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20veS1sb2hzZS9pbmtqcy9pc3N1ZXMvNDI1XG4gICAgICAgIC8vIENoYW5nZWQgY29uZGl0aW9uIHNlcXVlbmNlLCBiZWNhdXNlIE51bWJlcignJykgaXNcbiAgICAgICAgLy8gcGFyc2VkIHRvIDAsIHdoaWNoIG1hZGUgc2V0dGluZyBzdHJpbmcgdG8gZW1wdHlcbiAgICAgICAgLy8gaW1wb3NzaWJsZVxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShTdHJpbmcodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc05hTih2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFBhdGhfMS5QYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERpdmVydFRhcmdldFZhbHVlKFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhbCwgUGF0aF8xLlBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBJbmtMaXN0XzEuSW5rTGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaXN0VmFsdWUoVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsLCBJbmtMaXN0XzEuSW5rTGlzdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBDb3B5KCkge1xuICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MoQWJzdHJhY3RWYWx1ZS5DcmVhdGUodGhpcyksIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgfVxuICAgIEJhZENhc3RFeGNlcHRpb24odGFyZ2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW4ndCBjYXN0IFwiICtcbiAgICAgICAgICAgIHRoaXMudmFsdWVPYmplY3QgK1xuICAgICAgICAgICAgXCIgZnJvbSBcIiArXG4gICAgICAgICAgICB0aGlzLnZhbHVlVHlwZSArXG4gICAgICAgICAgICBcIiB0byBcIiArXG4gICAgICAgICAgICB0YXJnZXRUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0VmFsdWUgPSBBYnN0cmFjdFZhbHVlO1xuY2xhc3MgVmFsdWUgZXh0ZW5kcyBBYnN0cmFjdFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlZhbHVlID0gVmFsdWU7XG5jbGFzcyBJbnRWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgc3VwZXIodmFsIHx8IDApO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICE9IDA7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuSW50O1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShcIlwiICsgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50VmFsdWUgPSBJbnRWYWx1ZTtcbmNsYXNzIEZsb2F0VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKHZhbCB8fCAwLjApO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICE9IDAuMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5GbG9hdDtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLlN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShcIlwiICsgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXRWYWx1ZSA9IEZsb2F0VmFsdWU7XG5jbGFzcyBTdHJpbmdWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgc3VwZXIodmFsIHx8IFwiXCIpO1xuICAgICAgICB0aGlzLl9pc05ld2xpbmUgPSB0aGlzLnZhbHVlID09IFwiXFxuXCI7XG4gICAgICAgIHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS5zcGxpdChcIlwiKS5ldmVyeSgoYykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjICE9IFwiIFwiICYmIGMgIT0gXCJcXHRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0lubGluZVdoaXRlc3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuU3RyaW5nO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGlzTmV3bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTmV3bGluZTtcbiAgICB9XG4gICAgZ2V0IGlzSW5saW5lV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZTtcbiAgICB9XG4gICAgZ2V0IGlzTm9uV2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzTmV3bGluZSAmJiAhdGhpcy5pc0lubGluZVdoaXRlc3BhY2U7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZEludCA9IFRyeUdldFJlc3VsdF8xLnRyeVBhcnNlSW50KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZEludC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKHBhcnNlZEludC5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgbGV0IHBhcnNlZEZsb2F0ID0gVHJ5R2V0UmVzdWx0XzEudHJ5UGFyc2VGbG9hdCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRGbG9hdC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUocGFyc2VkRmxvYXQucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpbmdWYWx1ZSA9IFN0cmluZ1ZhbHVlO1xuY2xhc3MgRGl2ZXJ0VGFyZ2V0VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0UGF0aCkge1xuICAgICAgICBzdXBlcih0YXJnZXRQYXRoKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5EaXZlcnRUYXJnZXQ7XG4gICAgfVxuICAgIGdldCB0YXJnZXRQYXRoKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0UGF0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2hvdWxkbid0IGJlIGNoZWNraW5nIHRoZSB0cnV0aGluZXNzIG9mIGEgZGl2ZXJ0IHRhcmdldFwiKTtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIkRpdmVydFRhcmdldFZhbHVlKFwiICsgdGhpcy50YXJnZXRQYXRoICsgXCIpXCI7XG4gICAgfVxufVxuZXhwb3J0cy5EaXZlcnRUYXJnZXRWYWx1ZSA9IERpdmVydFRhcmdldFZhbHVlO1xuY2xhc3MgVmFyaWFibGVQb2ludGVyVmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgY29uc3RydWN0b3IodmFyaWFibGVOYW1lLCBjb250ZXh0SW5kZXggPSAtMSkge1xuICAgICAgICBzdXBlcih2YXJpYWJsZU5hbWUpO1xuICAgICAgICB0aGlzLl9jb250ZXh0SW5kZXggPSBjb250ZXh0SW5kZXg7XG4gICAgfVxuICAgIGdldCBjb250ZXh0SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0SW5kZXg7XG4gICAgfVxuICAgIHNldCBjb250ZXh0SW5kZXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dEluZGV4ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB2YXJpYWJsZU5hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHNldCB2YXJpYWJsZU5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLlZhcmlhYmxlUG9pbnRlcjtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGRuJ3QgYmUgY2hlY2tpbmcgdGhlIHRydXRoaW5lc3Mgb2YgYSB2YXJpYWJsZSBwb2ludGVyXCIpO1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiVmFyaWFibGVQb2ludGVyVmFsdWUoXCIgKyB0aGlzLnZhcmlhYmxlTmFtZSArIFwiKVwiO1xuICAgIH1cbiAgICBDb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlUG9pbnRlclZhbHVlKHRoaXMudmFyaWFibGVOYW1lLCB0aGlzLmNvbnRleHRJbmRleCk7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZVBvaW50ZXJWYWx1ZSA9IFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuY2xhc3MgTGlzdFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy52YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5Db3VudCA+IDA7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuTGlzdDtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMudmFsdWUubWF4SXRlbTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludFZhbHVlKDApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUobWF4LlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMudmFsdWUubWF4SXRlbTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUoMC4wKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUobWF4LlZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuZXdUeXBlID09IFZhbHVlVHlwZS5TdHJpbmcpIHtcbiAgICAgICAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heEl0ZW07XG4gICAgICAgICAgICBpZiAobWF4LktleS5pc051bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShcIlwiKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nVmFsdWUobWF4LktleS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxpc3RPclNpbmdsZUl0ZW0sIHNpbmdsZVZhbHVlKSB7XG4gICAgICAgIHN1cGVyKG51bGwpO1xuICAgICAgICBpZiAoIWxpc3RPclNpbmdsZUl0ZW0gJiYgIXNpbmdsZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlzdE9yU2luZ2xlSXRlbSBpbnN0YW5jZW9mIElua0xpc3RfMS5JbmtMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KGxpc3RPclNpbmdsZUl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpc3RPclNpbmdsZUl0ZW0gaW5zdGFuY2VvZiBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0gJiZcbiAgICAgICAgICAgIHR5cGVvZiBzaW5nbGVWYWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCh7XG4gICAgICAgICAgICAgICAgS2V5OiBsaXN0T3JTaW5nbGVJdGVtLFxuICAgICAgICAgICAgICAgIFZhbHVlOiBzaW5nbGVWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBSZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGxldCBvbGRMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9sZFZhbHVlLCBMaXN0VmFsdWUpO1xuICAgICAgICBsZXQgbmV3TGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChuZXdWYWx1ZSwgTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKG5ld0xpc3QgJiYgbmV3TGlzdC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwibmV3TGlzdC52YWx1ZVwiKTtcbiAgICAgICAgaWYgKG9sZExpc3QgJiYgb2xkTGlzdC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2xkTGlzdC52YWx1ZVwiKTtcbiAgICAgICAgLy8gV2hlbiBhc3NpZ25pbmcgdGhlIGVtcHR5IGxpc3QsIHRyeSB0byByZXRhaW4gYW55IGluaXRpYWwgb3JpZ2luIG5hbWVzXG4gICAgICAgIGlmIChvbGRMaXN0ICYmIG5ld0xpc3QgJiYgbmV3TGlzdC52YWx1ZS5Db3VudCA9PSAwKVxuICAgICAgICAgICAgbmV3TGlzdC52YWx1ZS5TZXRJbml0aWFsT3JpZ2luTmFtZXMob2xkTGlzdC52YWx1ZS5vcmlnaW5OYW1lcyk7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0VmFsdWUgPSBMaXN0VmFsdWU7XG52YXIgVmFsdWVUeXBlO1xuKGZ1bmN0aW9uIChWYWx1ZVR5cGUpIHtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiSW50XCJdID0gMF0gPSBcIkludFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJGbG9hdFwiXSA9IDFdID0gXCJGbG9hdFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJMaXN0XCJdID0gMl0gPSBcIkxpc3RcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiU3RyaW5nXCJdID0gM10gPSBcIlN0cmluZ1wiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJEaXZlcnRUYXJnZXRcIl0gPSA0XSA9IFwiRGl2ZXJ0VGFyZ2V0XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIlZhcmlhYmxlUG9pbnRlclwiXSA9IDVdID0gXCJWYXJpYWJsZVBvaW50ZXJcIjtcbn0pKFZhbHVlVHlwZSA9IGV4cG9ydHMuVmFsdWVUeXBlIHx8IChleHBvcnRzLlZhbHVlVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYWx1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVBc3NpZ25tZW50ID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBWYXJpYWJsZUFzc2lnbm1lbnQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHZhcmlhYmxlTmFtZSwgaXNOZXdEZWNsYXJhdGlvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZSA9IHZhcmlhYmxlTmFtZSB8fCBudWxsO1xuICAgICAgICB0aGlzLmlzTmV3RGVjbGFyYXRpb24gPSAhIWlzTmV3RGVjbGFyYXRpb247XG4gICAgICAgIHRoaXMuaXNHbG9iYWwgPSBmYWxzZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlZhckFzc2lnbiB0byBcIiArIHRoaXMudmFyaWFibGVOYW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVBc3NpZ25tZW50ID0gVmFyaWFibGVBc3NpZ25tZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVBc3NpZ25tZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZVJlZmVyZW5jZSA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNsYXNzIFZhcmlhYmxlUmVmZXJlbmNlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhdGhGb3JDb3VudCA9IG51bGw7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIGdldCBjb250YWluZXJGb3JDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aEZvckNvdW50ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLlJlc29sdmVQYXRoKHRoaXMucGF0aEZvckNvdW50KS5jb250YWluZXI7XG4gICAgfVxuICAgIGdldCBwYXRoU3RyaW5nRm9yQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhGb3JDb3VudCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnBhdGhGb3JDb3VudCk7XG4gICAgfVxuICAgIHNldCBwYXRoU3RyaW5nRm9yQ291bnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5wYXRoRm9yQ291bnQgPSBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnBhdGhGb3JDb3VudCA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcInZhcihcIiArIHRoaXMubmFtZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhdGhTdHIgPSB0aGlzLnBhdGhTdHJpbmdGb3JDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBcInJlYWRfY291bnQoXCIgKyBwYXRoU3RyICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlUmVmZXJlbmNlID0gVmFyaWFibGVSZWZlcmVuY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZVJlZmVyZW5jZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFyaWFibGVzU3RhdGUgPSB2b2lkIDA7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBKc29uU2VyaWFsaXNhdGlvbl8xID0gcmVxdWlyZShcIi4vSnNvblNlcmlhbGlzYXRpb25cIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgVmFyaWFibGVzU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxTdGFjaywgbGlzdERlZnNPcmlnaW4pIHtcbiAgICAgICAgLy8gVGhlIHdheSB2YXJpYWJsZUNoYW5nZWRFdmVudCBpcyBhIGJpdCBkaWZmZXJlbnQgdGhhbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAvLyBPcmlnaW5hbGx5IGl0IHVzZXMgdGhlIEMjICs9IG9wZXJhdG9yIHRvIGFkZCBkZWxlZ2F0ZXMsIGJ1dCBpbiBqcyB3ZSBuZWVkIHRvIG1haW50YWluXG4gICAgICAgIC8vIGFuIGFjdHVhbCBjb2xsZWN0aW9uIG9mIGRlbGVnYXRlcyAoaWUuIGNhbGxiYWNrcykgdG8gcmVnaXN0ZXIgYSBuZXcgb25lLCB0aGVyZSBpcyBhXG4gICAgICAgIC8vIHNwZWNpYWwgT2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlIG1ldGhvZCBiZWxvdy5cbiAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLnBhdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2NhbGxTdGFjayA9IGNhbGxTdGFjaztcbiAgICAgICAgdGhpcy5fbGlzdERlZnNPcmlnaW4gPSBsaXN0RGVmc09yaWdpbjtcbiAgICAgICAgLy8gaWYgZXM2IHByb3hpZXMgYXJlIGF2YWlsYWJsZSwgdXNlIHRoZW0uXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB0aGUgcHJveHkgaXMgdXNlZCB0byBhbGxvdyBkaXJlY3QgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbCB2YXJpYWJsZXMuXG4gICAgICAgICAgICAvLyBJdCBmaXJzdCB0cmllcyB0byBhY2Nlc3MgdGhlIG9iamVjdHMgb3duIHByb3BlcnR5LCBhbmQgaWYgbm9uZSBpc1xuICAgICAgICAgICAgLy8gZm91bmQgaXQgZGVsZWdhdGVzIHRoZSBjYWxsIHRvIHRoZSAkIG1ldGhvZCwgZGVmaW5lZCBiZWxvd1xuICAgICAgICAgICAgbGV0IHAgPSBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGFyZ2V0ID8gdGFyZ2V0W25hbWVdIDogdGFyZ2V0LiQobmFtZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSBpbiB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LiQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gcmV0dXJuaW5nIGEgZmFsc3kgdmFsdWUgbWFrZSB0aGUgdHJhcCBmYWlsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHRociBwcm94eSBvYmplY3QgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGNvbnRleHQuIHdlIHNob3VsZCB3YXJuIHRoZVxuICAgICAgICAgICAgLy8gZGV2IGJ1dCB3cml0dGluZyB0byB0aGUgY29uc29sZSBmZWVscyBhIGJpdCBpbnRydXNpdmUuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIkVTNiBQcm94eSBub3QgYXZhaWxhYmxlIC0gZGlyZWN0IG1hbmlwdWxhdGlvbiBvZiBnbG9iYWwgdmFyaWFibGVzIGNhbid0IHdvcmssIHVzZSAkKCkgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyaWFibGVDaGFuZ2VkRXZlbnQodmFyaWFibGVOYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBjYWxsYmFjayBvZiB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcztcbiAgICB9XG4gICAgc2V0IGJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdmFyaWFibGVOYW1lIG9mIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZhbHVlID0gdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImN1cnJlbnRWYWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQodmFyaWFibGVOYW1lLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhbGxTdGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFjaztcbiAgICB9XG4gICAgc2V0IGNhbGxTdGFjayhjYWxsU3RhY2spIHtcbiAgICAgICAgdGhpcy5fY2FsbFN0YWNrID0gY2FsbFN0YWNrO1xuICAgIH1cbiAgICAvLyB0aGUgb3JpZ2luYWwgY29kZSB1c2VzIGEgbWFnaWMgZ2V0dGVyIGFuZCBzZXR0ZXIgZm9yIGdsb2JhbCB2YXJpYWJsZXMsXG4gICAgLy8gYWxsb3dpbmcgdGhpbmdzIGxpa2UgdmFyaWFibGVTdGF0ZVsndmFybmFtZV0uIFRoaXMgaXMgbm90IHF1aXRlIHBvc3NpYmxlXG4gICAgLy8gaW4ganMgd2l0aG91dCBhIFByb3h5LCBzbyBpdCBpcyByZXBsYWNlZCB3aXRoIHRoaXMgJCBmdW5jdGlvbi5cbiAgICAkKHZhcmlhYmxlTmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHZhckNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyQ29udGVudHMgPSB0aGlzLnBhdGNoLlRyeUdldEdsb2JhbCh2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJDb250ZW50cy5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb250ZW50cy5yZXN1bHQudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXJDb250ZW50cyA9IHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFyQ29udGVudHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXJDb250ZW50cyA9IHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhckNvbnRlbnRzICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJDb250ZW50cy52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBhc3NpZ24gdG8gYSB2YXJpYWJsZSAoXCIgK1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZU5hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIikgdGhhdCBoYXNuJ3QgYmVlbiBkZWNsYXJlZCBpbiB0aGUgc3RvcnlcIik7XG4gICAgICAgICAgICBsZXQgdmFsID0gVmFsdWVfMS5WYWx1ZS5DcmVhdGUodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJDYW5ub3QgcGFzcyBudWxsIHRvIFZhcmlhYmxlU3RhdGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkludmFsaWQgdmFsdWUgcGFzc2VkIHRvIFZhcmlhYmxlU3RhdGU6IFwiICsgdmFsdWUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TZXRHbG9iYWwodmFyaWFibGVOYW1lLCB2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFwcGx5UGF0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMucGF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgW25hbWVkVmFyS2V5LCBuYW1lZFZhclZhbHVlXSBvZiB0aGlzLnBhdGNoLmdsb2JhbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQobmFtZWRWYXJLZXksIG5hbWVkVmFyVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgb2YgdGhpcy5wYXRjaC5jaGFuZ2VkVmFyaWFibGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhdGNoID0gbnVsbDtcbiAgICB9XG4gICAgU2V0SnNvblRva2VuKGpUb2tlbikge1xuICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgW3ZhclZhbEtleSwgdmFyVmFsVmFsdWVdIG9mIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGxldCBsb2FkZWRUb2tlbiA9IGpUb2tlblt2YXJWYWxLZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZWRUb2tlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGxldCB0b2tlbklua09iamVjdCA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSlRva2VuVG9SdW50aW1lT2JqZWN0KGxvYWRlZFRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5JbmtPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0b2tlbklua09iamVjdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh2YXJWYWxLZXksIHRva2VuSW5rT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodmFyVmFsS2V5LCB2YXJWYWxWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgV3JpdGVKc29uKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBmb3IgKGxldCBba2V5VmFsS2V5LCBrZXlWYWxWYWx1ZV0gb2YgdGhpcy5fZ2xvYmFsVmFyaWFibGVzKSB7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGtleVZhbEtleTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBrZXlWYWxWYWx1ZTtcbiAgICAgICAgICAgIGlmIChWYXJpYWJsZXNTdGF0ZS5kb250U2F2ZURlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRWYWwgPSB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuUnVudGltZU9iamVjdHNFcXVhbCh2YWwsIGRlZmF1bHRWYWwpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgdmFsKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIFJ1bnRpbWVPYmplY3RzRXF1YWwob2JqMSwgb2JqMikge1xuICAgICAgICBpZiAob2JqMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvYmoxXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9iajJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iajEuY29uc3RydWN0b3IgIT09IG9iajIuY29uc3RydWN0b3IpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBpbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGlmIChpbnRWYWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWwudmFsdWUgPT09IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9iajIsIFZhbHVlXzEuSW50VmFsdWUpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmbG9hdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoxLCBWYWx1ZV8xLkZsb2F0VmFsdWUpO1xuICAgICAgICBpZiAoZmxvYXRWYWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmbG9hdFZhbC52YWx1ZSA9PT0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2JqMiwgVmFsdWVfMS5GbG9hdFZhbHVlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsMSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoxLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgbGV0IHZhbDIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqMiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGlmICh2YWwxICE9PSBudWxsICYmIHZhbDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChUeXBlQXNzZXJ0aW9uXzEuaXNFcXVhdGFibGUodmFsMS52YWx1ZU9iamVjdCkgJiYgVHlwZUFzc2VydGlvbl8xLmlzRXF1YXRhYmxlKHZhbDIudmFsdWVPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDEudmFsdWVPYmplY3QuRXF1YWxzKHZhbDIudmFsdWVPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDEudmFsdWVPYmplY3QgPT09IHZhbDIudmFsdWVPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFzdFJvdWdoRGVmaW5pdGVseUVxdWFsczogVW5zdXBwb3J0ZWQgcnVudGltZSBvYmplY3QgdHlwZTogXCIgK1xuICAgICAgICAgICAgb2JqMS5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICB9XG4gICAgR2V0VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXggPSAtMSkge1xuICAgICAgICBsZXQgdmFyVmFsdWUgPSB0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgLy8gdmFyIHZhclBvaW50ZXIgPSB2YXJWYWx1ZSBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgbGV0IHZhclBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFyVmFsdWUsIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICBpZiAodmFyUG9pbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyVmFsdWUgPSB0aGlzLlZhbHVlQXRWYXJpYWJsZVBvaW50ZXIodmFyUG9pbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhclZhbHVlO1xuICAgIH1cbiAgICBUcnlHZXREZWZhdWx0VmFyaWFibGVWYWx1ZShuYW1lKSB7XG4gICAgICAgIGxldCB2YWwgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgIHJldHVybiB2YWwuZXhpc3RzID8gdmFsLnJlc3VsdCA6IG51bGw7XG4gICAgfVxuICAgIEdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5oYXMobmFtZSkpKTtcbiAgICB9XG4gICAgR2V0UmF3VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpIHtcbiAgICAgICAgbGV0IHZhclZhbHVlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbnRleHRJbmRleCA9PSAwIHx8IGNvbnRleHRJbmRleCA9PSAtMSkge1xuICAgICAgICAgICAgbGV0IHZhcmlhYmxlVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gdGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwobmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUuZXhpc3RzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFyaWFibGVWYWx1ZS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGEgY29uZGl0aW9uYWwgYXNzaWdubWVudFxuICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKHZhcmlhYmxlVmFsdWUuZXhpc3RzKVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlLnJlc3VsdDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGVWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlLnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9saXN0RGVmc09yaWdpbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhcmlhYmxlc1N0YXRlLl9saXN0RGVmc09yaWdpblwiKTtcbiAgICAgICAgICAgIGxldCBsaXN0SXRlbVZhbHVlID0gdGhpcy5fbGlzdERlZnNPcmlnaW4uRmluZFNpbmdsZUl0ZW1MaXN0V2l0aE5hbWUobmFtZSk7XG4gICAgICAgICAgICBpZiAobGlzdEl0ZW1WYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdEl0ZW1WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXJWYWx1ZSA9IHRoaXMuX2NhbGxTdGFjay5HZXRUZW1wb3JhcnlWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIHJldHVybiB2YXJWYWx1ZTtcbiAgICB9XG4gICAgVmFsdWVBdFZhcmlhYmxlUG9pbnRlcihwb2ludGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkdldFZhcmlhYmxlV2l0aE5hbWUocG9pbnRlci52YXJpYWJsZU5hbWUsIHBvaW50ZXIuY29udGV4dEluZGV4KTtcbiAgICB9XG4gICAgQXNzaWduKHZhckFzcywgdmFsdWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSB2YXJBc3MudmFyaWFibGVOYW1lO1xuICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZXh0SW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHNldEdsb2JhbCA9IGZhbHNlO1xuICAgICAgICBpZiAodmFyQXNzLmlzTmV3RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHNldEdsb2JhbCA9IHZhckFzcy5pc0dsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldEdsb2JhbCA9IHRoaXMuR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyQXNzLmlzTmV3RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIHZhciB2YXJQb2ludGVyID0gdmFsdWUgYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgICAgICBsZXQgdmFyUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YWx1ZSwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFyUG9pbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBmdWxseVJlc29sdmVkVmFyaWFibGVQb2ludGVyID0gdGhpcy5SZXNvbHZlVmFyaWFibGVQb2ludGVyKHZhclBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZnVsbHlSZXNvbHZlZFZhcmlhYmxlUG9pbnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBleGlzdGluZ1BvaW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nUG9pbnRlciA9IEdldFJhd1ZhcmlhYmxlV2l0aE5hbWUgKG5hbWUsIGNvbnRleHRJbmRleCkgYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdQb2ludGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGV4aXN0aW5nUG9pbnRlci52YXJpYWJsZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRJbmRleCA9IGV4aXN0aW5nUG9pbnRlci5jb250ZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHNldEdsb2JhbCA9IGNvbnRleHRJbmRleCA9PSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKGV4aXN0aW5nUG9pbnRlciAhPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0R2xvYmFsKSB7XG4gICAgICAgICAgICB0aGlzLlNldEdsb2JhbChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsU3RhY2suU2V0VGVtcG9yYXJ5VmFyaWFibGUobmFtZSwgdmFsdWUsIHZhckFzcy5pc05ld0RlY2xhcmF0aW9uLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNuYXBzaG90RGVmYXVsdEdsb2JhbHMoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgPSBuZXcgTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcyk7XG4gICAgfVxuICAgIFJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZExpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvbGRWYWx1ZSwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBsZXQgbmV3TGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG5ld1ZhbHVlLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChvbGRMaXN0LnZhbHVlICYmIG5ld0xpc3QudmFsdWUgJiYgbmV3TGlzdC52YWx1ZS5Db3VudCA9PSAwKSB7XG4gICAgICAgICAgICBuZXdMaXN0LnZhbHVlLlNldEluaXRpYWxPcmlnaW5OYW1lcyhvbGRMaXN0LnZhbHVlLm9yaWdpbk5hbWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTZXRHbG9iYWwodmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgb2xkVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgb2xkVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLCB2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IHRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoIW9sZFZhbHVlLmV4aXN0cykge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcywgdmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBWYWx1ZV8xLkxpc3RWYWx1ZS5SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUucmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YXJpYWJsZU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidmFyaWFibGVOYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBhdGNoLlNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5zZXQodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogTm90IHN1cmUgIT09IGlzIGVxdWl2YWxlbnQgdG8gIXZhbHVlLkVxdWFscyhvbGRWYWx1ZSlcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnQgIT09IG51bGwgJiZcbiAgICAgICAgICAgIG9sZFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gb2xkVmFsdWUucmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF0Y2guQWRkQ2hhbmdlZFZhcmlhYmxlKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMuYWRkKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlVmFyaWFibGVQb2ludGVyKHZhclBvaW50ZXIpIHtcbiAgICAgICAgbGV0IGNvbnRleHRJbmRleCA9IHZhclBvaW50ZXIuY29udGV4dEluZGV4O1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IC0xKVxuICAgICAgICAgICAgY29udGV4dEluZGV4ID0gdGhpcy5HZXRDb250ZXh0SW5kZXhPZlZhcmlhYmxlTmFtZWQodmFyUG9pbnRlci52YXJpYWJsZU5hbWUpO1xuICAgICAgICBsZXQgdmFsdWVPZlZhcmlhYmxlUG9pbnRlZFRvID0gdGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKHZhclBvaW50ZXIudmFyaWFibGVOYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICAvLyB2YXIgZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyID0gdmFsdWVPZlZhcmlhYmxlUG9pbnRlZFRvIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICBsZXQgZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlT2ZWYXJpYWJsZVBvaW50ZWRUbywgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgIGlmIChkb3VibGVSZWRpcmVjdGlvblBvaW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBHZXRDb250ZXh0SW5kZXhPZlZhcmlhYmxlTmFtZWQodmFyTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHZhck5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWxsU3RhY2suY3VycmVudEVsZW1lbnRJbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBzcGVjaWZpYyB0byB0aGUganMgdmVyc2lvbiBvZiBpbmsuIEl0IGFsbG93cyB0byByZWdpc3RlciBhXG4gICAgICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIGEgdmFyaWFibGUgY2hhbmdlcy4gVGhlIG9yaWdpbmFsIGNvZGUgdXNlc1xuICAgICAqIGBzdGF0ZS52YXJpYWJsZUNoYW5nZWRFdmVudCArPSBjYWxsYmFja2AgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgT2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZXNTdGF0ZSA9IFZhcmlhYmxlc1N0YXRlO1xuVmFyaWFibGVzU3RhdGUuZG9udFNhdmVEZWZhdWx0VmFsdWVzID0gdHJ1ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlc1N0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Wb2lkID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBWb2lkIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbn1cbmV4cG9ydHMuVm9pZCA9IFZvaWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Wb2lkLmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIiwiLy8gbWluaW1hbCBsaWJyYXJ5IGVudHJ5IHBvaW50LlxuXG5cInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vc3JjL2luZGV4LW1pbmltYWxcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IGV4cG9ydHM7XG5cbi8qKlxuICogQnVpbGQgdHlwZSwgb25lIG9mIGBcImZ1bGxcImAsIGBcImxpZ2h0XCJgIG9yIGBcIm1pbmltYWxcImAuXG4gKiBAbmFtZSBidWlsZFxuICogQHR5cGUge3N0cmluZ31cbiAqIEBjb25zdFxuICovXG5wcm90b2J1Zi5idWlsZCA9IFwibWluaW1hbFwiO1xuXG4vLyBTZXJpYWxpemF0aW9uXG5wcm90b2J1Zi5Xcml0ZXIgICAgICAgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJfYnVmZmVyXCIpO1xucHJvdG9idWYuUmVhZGVyICAgICAgID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xucHJvdG9idWYuQnVmZmVyUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyX2J1ZmZlclwiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudXRpbCAgICAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xucHJvdG9idWYucnBjICAgICAgICAgID0gcmVxdWlyZShcIi4vcnBjXCIpO1xucHJvdG9idWYucm9vdHMgICAgICAgID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5wcm90b2J1Zi5jb25maWd1cmUgICAgPSBjb25maWd1cmU7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKipcbiAqIFJlY29uZmlndXJlcyB0aGUgbGlicmFyeSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50LlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlKCkge1xuICAgIHByb3RvYnVmLnV0aWwuX2NvbmZpZ3VyZSgpO1xuICAgIHByb3RvYnVmLldyaXRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlcldyaXRlcik7XG4gICAgcHJvdG9idWYuUmVhZGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyUmVhZGVyKTtcbn1cblxuLy8gU2V0IHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnRcbmNvbmZpZ3VyZSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlclJlYWRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGluZGV4T3V0T2ZSYW5nZShyZWFkZXIsIHdyaXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIFJhbmdlRXJyb3IoXCJpbmRleCBvdXQgb2YgcmFuZ2U6IFwiICsgcmVhZGVyLnBvcyArIFwiICsgXCIgKyAod3JpdGVMZW5ndGggfHwgMSkgKyBcIiA+IFwiICsgcmVhZGVyLmxlbik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByZWFkZXIgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHJlYWRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBSZWFkZXIoYnVmZmVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAdHlwZSB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZiA9IGJ1ZmZlcjtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBidWZmZXIubGVuZ3RoO1xufVxuXG52YXIgY3JlYXRlX2FycmF5ID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IGZ1bmN0aW9uIGNyZWF0ZV90eXBlZF9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheShidWZmZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfTtcblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKGJ1ZmZlcikge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFkZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5CdWZmZXIuaXNCdWZmZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBCdWZmZXJSZWFkZXIoYnVmZmVyKVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZV9hcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGNyZWF0ZV9hcnJheTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyByZWFkZXIgdXNpbmcgdGhlIHNwZWNpZmllZCBidWZmZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheXxCdWZmZXJ9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKiBAcmV0dXJucyB7UmVhZGVyfEJ1ZmZlclJlYWRlcn0gQSB7QGxpbmsgQnVmZmVyUmVhZGVyfSBpZiBgYnVmZmVyYCBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGEge0BsaW5rIFJlYWRlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgYnVmZmVyYCBpcyBub3QgYSB2YWxpZCBidWZmZXJcbiAqL1xuUmVhZGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG5SZWFkZXIucHJvdG90eXBlLl9zbGljZSA9IHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5IHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnVpbnQzMiA9IChmdW5jdGlvbiByZWFkX3VpbnQzMl9zZXR1cCgpIHtcbiAgICB2YXIgdmFsdWUgPSA0Mjk0OTY3Mjk1OyAvLyBvcHRpbWl6ZXIgdHlwZS1oaW50LCB0ZW5kcyB0byBkZW9wdCBvdGhlcndpc2UgKD8hKVxuICAgIHJldHVybiBmdW5jdGlvbiByZWFkX3VpbnQzMigpIHtcbiAgICAgICAgdmFsdWUgPSAoICAgICAgICAgdGhpcy5idWZbdGhpcy5wb3NdICYgMTI3ICAgICAgICkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8ICA3KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMTQpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyMSkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAgMTUpIDw8IDI4KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICgodGhpcy5wb3MgKz0gNSkgPiB0aGlzLmxlbikge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmxlbjtcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHJlYWRfaW50MzIoKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ludDMyKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudWludDMyKCk7XG4gICAgcmV0dXJuIHZhbHVlID4+PiAxIF4gLSh2YWx1ZSAmIDEpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkTG9uZ1ZhcmludCgpIHtcbiAgICAvLyB0ZW5kcyB0byBkZW9wdCB3aXRoIGxvY2FsIHZhcnMgZm9yIG9jdGV0IGV0Yy5cbiAgICB2YXIgYml0cyA9IG5ldyBMb25nQml0cygwLCAwKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGxvKVxuICAgICAgICBmb3IgKDsgaSA8IDQ7ICsraSkge1xuICAgICAgICAgICAgLy8gMXN0Li40dGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA1dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjgpID4+PiAwO1xuICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA+PiAgNCkgPj4+IDA7XG4gICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICBpID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gMXN0Li4zdGhcbiAgICAgICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLyA0dGhcbiAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zKytdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgIHJldHVybiBiaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAoaGkpXG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgRXJyb3IoXCJpbnZhbGlkIHZhcmludCBlbmNvZGluZ1wiKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciN1aW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjc2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIGJvb2xlYW4uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiByZWFkX2Jvb2woKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCkgIT09IDA7XG59O1xuXG5mdW5jdGlvbiByZWFkRml4ZWQzMl9lbmQoYnVmLCBlbmQpIHsgLy8gbm90ZSB0aGF0IHRoaXMgdXNlcyBgZW5kYCwgbm90IGBwb3NgXG4gICAgcmV0dXJuIChidWZbZW5kIC0gNF1cbiAgICAgICAgICB8IGJ1ZltlbmQgLSAzXSA8PCA4XG4gICAgICAgICAgfCBidWZbZW5kIC0gMl0gPDwgMTZcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAxXSA8PCAyNCkgPj4+IDA7XG59XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gcmVhZF9maXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KTtcbn07XG5cbi8qKlxuICogUmVhZHMgZml4ZWQgMzIgYml0cyBhcyBhIHNpZ25lZCAzMiBiaXQgaW50ZWdlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpIHwgMDtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG5mdW5jdGlvbiByZWFkRml4ZWQ2NCgvKiB0aGlzOiBSZWFkZXIgKi8pIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDgpO1xuXG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhyZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpLCByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpKTtcbn1cblxuLyogZXNsaW50LWVuYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIHppZy16YWcgZW5jb2RlZCBmaXhlZCA2NCBiaXRzLlxuICogQG5hbWUgUmVhZGVyI3NmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIGZsb2F0ICgzMiBiaXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiByZWFkX2Zsb2F0KCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWRGbG9hdExFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gNDtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpIGFzIGEgbnVtYmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZG91YmxlID0gZnVuY3Rpb24gcmVhZF9kb3VibGUoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZERvdWJsZUxFKHRoaXMuYnVmLCB0aGlzLnBvcyk7XG4gICAgdGhpcy5wb3MgKz0gODtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gcmVhZF9ieXRlcygpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy51aW50MzIoKSxcbiAgICAgICAgc3RhcnQgID0gdGhpcy5wb3MsXG4gICAgICAgIGVuZCAgICA9IHRoaXMucG9zICsgbGVuZ3RoO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVuZCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcblxuICAgIHRoaXMucG9zICs9IGxlbmd0aDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmJ1ZikpIC8vIHBsYWluIGFycmF5XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zbGljZShzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gc3RhcnQgPT09IGVuZCAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICA/IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKVxuICAgICAgICA6IHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNjcm9zcyBtb2R1bGVzLlxuICogQG5hbWUgcm9vdHNcbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSb290Pn1cbiAqIEBleGFtcGxlXG4gKiAvLyBwYmpzIC1yIG15cm9vdCAtbyBjb21waWxlZC5qcyAuLi5cbiAqXG4gKiAvLyBpbiBhbm90aGVyIG1vZHVsZTpcbiAqIHJlcXVpcmUoXCIuL2NvbXBpbGVkLmpzXCIpO1xuICpcbiAqIC8vIGluIGFueSBzdWJzZXF1ZW50IG1vZHVsZTpcbiAqIHZhciByb290ID0gcHJvdG9idWYucm9vdHNbXCJteXJvb3RcIl07XG4gKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFN0cmVhbWluZyBSUEMgaGVscGVycy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHJwYyA9IGV4cG9ydHM7XG5cbi8qKlxuICogUlBDIGltcGxlbWVudGF0aW9uIHBhc3NlZCB0byB7QGxpbmsgU2VydmljZSNjcmVhdGV9IHBlcmZvcm1pbmcgYSBzZXJ2aWNlIHJlcXVlc3Qgb24gbmV0d29yayBsZXZlbCwgaS5lLiBieSB1dGlsaXppbmcgaHR0cCByZXF1ZXN0cyBvciB3ZWJzb2NrZXRzLlxuICogQHR5cGVkZWYgUlBDSW1wbFxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXRob2R8cnBjLlNlcnZpY2VNZXRob2Q8TWVzc2FnZTx7fT4sTWVzc2FnZTx7fT4+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2QgYmVpbmcgY2FsbGVkXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHJlcXVlc3REYXRhIFJlcXVlc3QgZGF0YVxuICogQHBhcmFtIHtSUENJbXBsQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQGV4YW1wbGVcbiAqIGZ1bmN0aW9uIHJwY0ltcGwobWV0aG9kLCByZXF1ZXN0RGF0YSwgY2FsbGJhY2spIHtcbiAqICAgICBpZiAocHJvdG9idWYudXRpbC5sY0ZpcnN0KG1ldGhvZC5uYW1lKSAhPT0gXCJteU1ldGhvZFwiKSAvLyBjb21wYXRpYmxlIHdpdGggc3RhdGljIGNvZGVcbiAqICAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIG1ldGhvZFwiKTtcbiAqICAgICBhc3luY2hyb25vdXNseU9idGFpbkFSZXNwb25zZShyZXF1ZXN0RGF0YSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZURhdGEpIHtcbiAqICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZURhdGEpO1xuICogICAgIH0pO1xuICogfVxuICovXG5cbi8qKlxuICogTm9kZS1zdHlsZSBjYWxsYmFjayBhcyB1c2VkIGJ5IHtAbGluayBSUENJbXBsfS5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxDYWxsYmFja1xuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnJvciBFcnJvciwgaWYgYW55LCBvdGhlcndpc2UgYG51bGxgXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8bnVsbH0gW3Jlc3BvbnNlXSBSZXNwb25zZSBkYXRhIG9yIGBudWxsYCB0byBzaWduYWwgZW5kIG9mIHN0cmVhbSwgaWYgdGhlcmUgaGFzbid0IGJlZW4gYW4gZXJyb3JcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxucnBjLlNlcnZpY2UgPSByZXF1aXJlKFwiLi9ycGMvc2VydmljZVwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBTZXJ2aWNlO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8vIEV4dGVuZHMgRXZlbnRFbWl0dGVyXG4oU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHV0aWwuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gU2VydmljZTtcblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHJwYy5TZXJ2aWNlTWV0aG9kfFNlcnZpY2VNZXRob2R9LlxuICpcbiAqIERpZmZlcnMgZnJvbSB7QGxpbmsgUlBDSW1wbENhbGxiYWNrfSBpbiB0aGF0IGl0IGlzIGFuIGFjdHVhbCBjYWxsYmFjayBvZiBhIHNlcnZpY2UgbWV0aG9kIHdoaWNoIG1heSBub3QgcmV0dXJuIGByZXNwb25zZSA9IG51bGxgLlxuICogQHR5cGVkZWYgcnBjLlNlcnZpY2VNZXRob2RDYWxsYmFja1xuICogQHRlbXBsYXRlIFRSZXMgZXh0ZW5kcyBNZXNzYWdlPFRSZXM+XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcbiAqIEBwYXJhbSB7VFJlc30gW3Jlc3BvbnNlXSBSZXNwb25zZSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQSBzZXJ2aWNlIG1ldGhvZCBwYXJ0IG9mIGEge0BsaW5rIHJwYy5TZXJ2aWNlfSBhcyBjcmVhdGVkIGJ5IHtAbGluayBTZXJ2aWNlLmNyZWF0ZX0uXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZFxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7VFJlcXxQcm9wZXJ0aWVzPFRSZXE+fSByZXF1ZXN0IFJlcXVlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3RcbiAqIEBwYXJhbSB7cnBjLlNlcnZpY2VNZXRob2RDYWxsYmFjazxUUmVzPn0gW2NhbGxiYWNrXSBOb2RlLXN0eWxlIGNhbGxiYWNrIGNhbGxlZCB3aXRoIHRoZSBlcnJvciwgaWYgYW55LCBhbmQgdGhlIHJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lc3NhZ2U8VFJlcz4+fSBQcm9taXNlIGlmIGBjYWxsYmFja2AgaGFzIGJlZW4gb21pdHRlZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IFJQQyBzZXJ2aWNlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBbiBSUEMgc2VydmljZSBhcyByZXR1cm5lZCBieSB7QGxpbmsgU2VydmljZSNjcmVhdGV9LlxuICogQGV4cG9ydHMgcnBjLlNlcnZpY2VcbiAqIEBleHRlbmRzIHV0aWwuRXZlbnRFbWl0dGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UlBDSW1wbH0gcnBjSW1wbCBSUEMgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVlc3REZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc3BvbnNlRGVsaW1pdGVkPWZhbHNlXSBXaGV0aGVyIHJlc3BvbnNlcyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICovXG5mdW5jdGlvbiBTZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKSB7XG5cbiAgICBpZiAodHlwZW9mIHJwY0ltcGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwicnBjSW1wbCBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG5cbiAgICB1dGlsLkV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogUlBDIGltcGxlbWVudGF0aW9uLiBCZWNvbWVzIGBudWxsYCBvbmNlIHRoZSBzZXJ2aWNlIGlzIGVuZGVkLlxuICAgICAqIEB0eXBlIHtSUENJbXBsfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5ycGNJbXBsID0gcnBjSW1wbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVxdWVzdHMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0RGVsaW1pdGVkID0gQm9vbGVhbihyZXF1ZXN0RGVsaW1pdGVkKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzcG9uc2VEZWxpbWl0ZWQgPSBCb29sZWFuKHJlc3BvbnNlRGVsaW1pdGVkKTtcbn1cblxuLyoqXG4gKiBDYWxscyBhIHNlcnZpY2UgbWV0aG9kIHRocm91Z2gge0BsaW5rIHJwYy5TZXJ2aWNlI3JwY0ltcGx8cnBjSW1wbH0uXG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxUUmVxLFRSZXM+fSBtZXRob2QgUmVmbGVjdGVkIG9yIHN0YXRpYyBtZXRob2RcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcT59IHJlcXVlc3RDdG9yIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VFJlcz59IHJlc3BvbnNlQ3RvciBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBjYWxsYmFjayBTZXJ2aWNlIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHRlbXBsYXRlIFRSZXEgZXh0ZW5kcyBNZXNzYWdlPFRSZXE+XG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqL1xuU2VydmljZS5wcm90b3R5cGUucnBjQ2FsbCA9IGZ1bmN0aW9uIHJwY0NhbGwobWV0aG9kLCByZXF1ZXN0Q3RvciwgcmVzcG9uc2VDdG9yLCByZXF1ZXN0LCBjYWxsYmFjaykge1xuXG4gICAgaWYgKCFyZXF1ZXN0KVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0IG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghY2FsbGJhY2spXG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShycGNDYWxsLCBzZWxmLCBtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QpO1xuXG4gICAgaWYgKCFzZWxmLnJwY0ltcGwpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soRXJyb3IoXCJhbHJlYWR5IGVuZGVkXCIpKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHNlbGYucnBjSW1wbChcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RDdG9yW3NlbGYucmVxdWVzdERlbGltaXRlZCA/IFwiZW5jb2RlRGVsaW1pdGVkXCIgOiBcImVuY29kZVwiXShyZXF1ZXN0KS5maW5pc2goKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJwY0NhbGxiYWNrKGVyciwgcmVzcG9uc2UpIHtcblxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5lbmQoLyogZW5kZWRCeVJQQyAqLyB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIHJlc3BvbnNlQ3RvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzcG9uc2VDdG9yW3NlbGYucmVzcG9uc2VEZWxpbWl0ZWQgPyBcImRlY29kZURlbGltaXRlZFwiIDogXCJkZWNvZGVcIl0ocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZGF0YVwiLCByZXNwb25zZSwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGVycik7IH0sIDApO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5kcyB0aGlzIHNlcnZpY2UgYW5kIGVtaXRzIHRoZSBgZW5kYCBldmVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VuZGVkQnlSUEM9ZmFsc2VdIFdoZXRoZXIgdGhlIHNlcnZpY2UgaGFzIGJlZW4gZW5kZWQgYnkgdGhlIFJQQyBpbXBsZW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIHtycGMuU2VydmljZX0gYHRoaXNgXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIGVuZChlbmRlZEJ5UlBDKSB7XG4gICAgaWYgKHRoaXMucnBjSW1wbCkge1xuICAgICAgICBpZiAoIWVuZGVkQnlSUEMpIC8vIHNpZ25hbCBlbmQgdG8gcnBjSW1wbFxuICAgICAgICAgICAgdGhpcy5ycGNJbXBsKG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJwY0ltcGwgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoXCJlbmRcIikub2ZmKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBMb25nQml0cztcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cy5cbiAqIEBjbGFzc2Rlc2MgSGVscGVyIGNsYXNzIGZvciB3b3JraW5nIHdpdGggdGhlIGxvdyBhbmQgaGlnaCBiaXRzIG9mIGEgNjQgYml0IHZhbHVlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxvIExvdyAzMiBiaXRzLCB1bnNpZ25lZFxuICogQHBhcmFtIHtudW1iZXJ9IGhpIEhpZ2ggMzIgYml0cywgdW5zaWduZWRcbiAqL1xuZnVuY3Rpb24gTG9uZ0JpdHMobG8sIGhpKSB7XG5cbiAgICAvLyBub3RlIHRoYXQgdGhlIGNhc3RzIGJlbG93IGFyZSB0aGVvcmV0aWNhbGx5IHVubmVjZXNzYXJ5IGFzIG9mIHRvZGF5LCBidXQgb2xkZXIgc3RhdGljYWxseVxuICAgIC8vIGdlbmVyYXRlZCBjb252ZXJ0ZXIgY29kZSBtaWdodCBzdGlsbCBjYWxsIHRoZSBjdG9yIHdpdGggc2lnbmVkIDMyYml0cy4ga2VwdCBmb3IgY29tcGF0LlxuXG4gICAgLyoqXG4gICAgICogTG93IGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxvID0gbG8gPj4+IDA7XG5cbiAgICAvKipcbiAgICAgKiBIaWdoIGJpdHMuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmhpID0gaGkgPj4+IDA7XG59XG5cbi8qKlxuICogWmVybyBiaXRzLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHt1dGlsLkxvbmdCaXRzfVxuICovXG52YXIgemVybyA9IExvbmdCaXRzLnplcm8gPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG5cbnplcm8udG9OdW1iZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG56ZXJvLnp6RW5jb2RlID0gemVyby56ekRlY29kZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfTtcbnplcm8ubGVuZ3RoID0gZnVuY3Rpb24oKSB7IHJldHVybiAxOyB9O1xuXG4vKipcbiAqIFplcm8gaGFzaC5cbiAqIEBtZW1iZXJvZiB1dGlsLkxvbmdCaXRzXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG52YXIgemVyb0hhc2ggPSBMb25nQml0cy56ZXJvSGFzaCA9IFwiXFwwXFwwXFwwXFwwXFwwXFwwXFwwXFwwXCI7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tTnVtYmVyID0gZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHplcm87XG4gICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDA7XG4gICAgaWYgKHNpZ24pXG4gICAgICAgIHZhbHVlID0gLXZhbHVlO1xuICAgIHZhciBsbyA9IHZhbHVlID4+PiAwLFxuICAgICAgICBoaSA9ICh2YWx1ZSAtIGxvKSAvIDQyOTQ5NjcyOTYgPj4+IDA7XG4gICAgaWYgKHNpZ24pIHtcbiAgICAgICAgaGkgPSB+aGkgPj4+IDA7XG4gICAgICAgIGxvID0gfmxvID4+PiAwO1xuICAgICAgICBpZiAoKytsbyA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgIGxvID0gMDtcbiAgICAgICAgICAgIGlmICgrK2hpID4gNDI5NDk2NzI5NSlcbiAgICAgICAgICAgICAgICBoaSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb25nQml0cyhsbywgaGkpO1xufTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSBhIG51bWJlciwgbG9uZyBvciBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWVcbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBJbnN0YW5jZVxuICovXG5Mb25nQml0cy5mcm9tID0gZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgICAgIHZhbHVlID0gdXRpbC5Mb25nLmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZ0JpdHMuZnJvbU51bWJlcihwYXJzZUludCh2YWx1ZSwgMTApKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLmxvdyB8fCB2YWx1ZS5oaWdoID8gbmV3IExvbmdCaXRzKHZhbHVlLmxvdyA+Pj4gMCwgdmFsdWUuaGlnaCA+Pj4gMCkgOiB6ZXJvO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIHBvc3NpYmx5IHVuc2FmZSBKYXZhU2NyaXB0IG51bWJlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge251bWJlcn0gUG9zc2libHkgdW5zYWZlIG51bWJlclxuICovXG5Mb25nQml0cy5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcih1bnNpZ25lZCkge1xuICAgIGlmICghdW5zaWduZWQgJiYgdGhpcy5oaSA+Pj4gMzEpIHtcbiAgICAgICAgdmFyIGxvID0gfnRoaXMubG8gKyAxID4+PiAwLFxuICAgICAgICAgICAgaGkgPSB+dGhpcy5oaSAgICAgPj4+IDA7XG4gICAgICAgIGlmICghbG8pXG4gICAgICAgICAgICBoaSA9IGhpICsgMSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIC0obG8gKyBoaSAqIDQyOTQ5NjcyOTYpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sbyArIHRoaXMuaGkgKiA0Mjk0OTY3Mjk2O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIGxvbmcuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfSBMb25nXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0xvbmcgPSBmdW5jdGlvbiB0b0xvbmcodW5zaWduZWQpIHtcbiAgICByZXR1cm4gdXRpbC5Mb25nXG4gICAgICAgID8gbmV3IHV0aWwuTG9uZyh0aGlzLmxvIHwgMCwgdGhpcy5oaSB8IDAsIEJvb2xlYW4odW5zaWduZWQpKVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IHsgbG93OiB0aGlzLmxvIHwgMCwgaGlnaDogdGhpcy5oaSB8IDAsIHVuc2lnbmVkOiBCb29sZWFuKHVuc2lnbmVkKSB9O1xufTtcblxudmFyIGNoYXJDb2RlQXQgPSBTdHJpbmcucHJvdG90eXBlLmNoYXJDb2RlQXQ7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzIGZyb20gdGhlIHNwZWNpZmllZCA4IGNoYXJhY3RlcnMgbG9uZyBoYXNoLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2ggSGFzaFxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEJpdHNcbiAqL1xuTG9uZ0JpdHMuZnJvbUhhc2ggPSBmdW5jdGlvbiBmcm9tSGFzaChoYXNoKSB7XG4gICAgaWYgKGhhc2ggPT09IHplcm9IYXNoKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCAwKVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCAxKSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDIpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDMpIDw8IDI0KSA+Pj4gMFxuICAgICxcbiAgICAgICAgKCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNClcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgNSkgPDwgOFxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA2KSA8PCAxNlxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA3KSA8PCAyNCkgPj4+IDBcbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGxvbmcgYml0cyB0byBhIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b0hhc2ggPSBmdW5jdGlvbiB0b0hhc2goKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAgIHRoaXMubG8gICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDI0ICAgICAgLFxuICAgICAgICB0aGlzLmhpICAgICAgICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gOCAgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDE2ICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiAyNFxuICAgICk7XG59O1xuXG4vKipcbiAqIFppZy16YWcgZW5jb2RlcyB0aGlzIGxvbmcgYml0cy5cbiAqIEByZXR1cm5zIHt1dGlsLkxvbmdCaXRzfSBgdGhpc2BcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnp6RW5jb2RlID0gZnVuY3Rpb24genpFbmNvZGUoKSB7XG4gICAgdmFyIG1hc2sgPSAgIHRoaXMuaGkgPj4gMzE7XG4gICAgdGhpcy5oaSAgPSAoKHRoaXMuaGkgPDwgMSB8IHRoaXMubG8gPj4+IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMubG8gID0gKCB0aGlzLmxvIDw8IDEgICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogWmlnLXphZyBkZWNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpEZWNvZGUgPSBmdW5jdGlvbiB6ekRlY29kZSgpIHtcbiAgICB2YXIgbWFzayA9IC0odGhpcy5sbyAmIDEpO1xuICAgIHRoaXMubG8gID0gKCh0aGlzLmxvID4+PiAxIHwgdGhpcy5oaSA8PCAzMSkgXiBtYXNrKSA+Pj4gMDtcbiAgICB0aGlzLmhpICA9ICggdGhpcy5oaSA+Pj4gMSAgICAgICAgICAgICAgICAgIF4gbWFzaykgPj4+IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGlzIGxvbmdiaXRzIHdoZW4gZW5jb2RlZCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IExlbmd0aFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgIHZhciBwYXJ0MCA9ICB0aGlzLmxvLFxuICAgICAgICBwYXJ0MSA9ICh0aGlzLmxvID4+PiAyOCB8IHRoaXMuaGkgPDwgNCkgPj4+IDAsXG4gICAgICAgIHBhcnQyID0gIHRoaXMuaGkgPj4+IDI0O1xuICAgIHJldHVybiBwYXJ0MiA9PT0gMFxuICAgICAgICAgPyBwYXJ0MSA9PT0gMFxuICAgICAgICAgICA/IHBhcnQwIDwgMTYzODRcbiAgICAgICAgICAgICA/IHBhcnQwIDwgMTI4ID8gMSA6IDJcbiAgICAgICAgICAgICA6IHBhcnQwIDwgMjA5NzE1MiA/IDMgOiA0XG4gICAgICAgICAgIDogcGFydDEgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDEgPCAxMjggPyA1IDogNlxuICAgICAgICAgICAgIDogcGFydDEgPCAyMDk3MTUyID8gNyA6IDhcbiAgICAgICAgIDogcGFydDIgPCAxMjggPyA5IDogMTA7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIChDdXN0b21FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQ3VzdG9tRXJyb3I7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ3VzdG9tRXJyb3IucHJvdG90eXBlLCBcIm5hbWVcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmFtZTsgfSB9KTtcblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIlxyXG5pbXBvcnQge1VuaXRUZXN0fSBmcm9tICcuL3VuaXR0ZXN0L1VuaXRUZXN0JztcclxuaW1wb3J0IHsgR2FtZU9iamVjdFBvb2wgfSBmcm9tICcuL2ZyYW1ld29yay9jb21tb24vR2FtZU9iamVjdFBvb2wnO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tICcuL2ZyYW1ld29yay91aS9VSU1hbmFnZXInO1xyXG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSAnLi9mcmFtZXdvcmsvY29tbW9uL1Jlc01hbmFnZXInO1xyXG5cclxuaW1wb3J0IHsgSnNNYW5hZ2VyICxHYW1lTGF1bmNoLCBOaWNlVFMgfSBmcm9tICdjc2hhcnAnO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gJy4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lRGVmJztcclxuaW1wb3J0IHsgU2NlbmVNYW5hZ2VyIH0gZnJvbSAnLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVNYW5hZ2VyJztcclxuaW1wb3J0IHsgU3RvcnlNYW5hZ2VyIH0gZnJvbSAnLi9mcmFtZXdvcmsvaW5rL1N0b3J5TWFuYWdlcic7XHJcblxyXG5cclxuXHJcbmNsYXNzIEdhbWVNYWlue1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIEpzTWFuYWdlci5JbnN0YW5jZS5Kc09uQXBwbGljYXRpb25RdWl0ID0gKCkgPT4gdGhpcy5vbkFwcGxpY2F0aW9uUXVpdCgpO1xyXG4gICAgICAgIEpzTWFuYWdlci5JbnN0YW5jZS5Kc09uRGlzcG9zZSA9ICgpID0+IHRoaXMub25EaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFzeW5jIHN0YXJ0KCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHYW1lIHN0YXJ0IGluIEpTLi4uLlwiKTtcclxuXHJcbiAgICAgICAgICAgIC8v5ZCv5Yqo5Y2V5L6LXHJcbiAgICAgICAgICAgIEdhbWVPYmplY3RQb29sLkluc3RhbmNlKEdhbWVPYmplY3RQb29sKTtcclxuICAgIFxyXG4gICAgICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKTtcclxuICAgICAgICAgICAgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKTtcclxuICAgICAgICAgICAgU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcikuaW5pdGlhbGl6ZSgpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8v6aKE5Yqg6L29ZXhjZWzmlbDmja5cclxuICAgICAgICAgICAgLy9FeGNlbE1hbmFnZXIuSW5zdGFuY2UoRXhjZWxNYW5hZ2VyKTtcclxuICAgICAgXHJcbiAgICAgICAgICAgIC8vZG8gVW5pdCBUZXN0XHJcbiAgICAgICAgICAgIFVuaXRUZXN0LmRvVGVzdCgpO1xyXG5cclxuICAgICAgICAgICAgLy/ov5vlhaXnmbvlvZXmqKHlnZdcclxuICAgICAgICAgICAgYXdhaXQgU2NlbmVNYW5hZ2VyLkluc3RhbmNlKFNjZW5lTWFuYWdlcikubG9hZFNjZW5lKFNjZW5lRGVmLkxvZ2luU2NlbmUpO1xyXG5cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vSlPlkK/liqjlrozmiJDvvIzpgJrnn6VDI+WxglxyXG4gICAgICAgICAgICBHYW1lTGF1bmNoLkluc3RhbmNlLkpzTHVhbmNoRmluaXNoKCk7XHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQXBwbGljYXRpb25RdWl0KCk6dm9pZCB7XHJcblxyXG4gICAgICAgIEdhbWVPYmplY3RQb29sLkluc3RhbmNlKEdhbWVPYmplY3RQb29sKS5jbGVhbnVwKHRydWUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2FtZSBvbkFwcGxpY2F0aW9uUXVpdCBpbiBKUy4uLi5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRGlzcG9zZSgpOnZvaWQge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2FtZSBvbkRpc3Bvc2UgaW4gSlMuLi4uXCIpO1xyXG4gICAgfVxyXG4gICAgXHJcbn1cclxuXHJcbm5ldyBHYW1lTWFpbigpLnN0YXJ0KCk7XHJcblxyXG4iLCJpbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b25cIjtcclxuZXhwb3J0IGNsYXNzIFNraWxsQ29uZmlnVFJ7XHJcblx0IHB1YmxpYyBfaWQ6bnVtYmVyIDtcclxuXHQgcHVibGljIF9OYW1lOnN0cmluZyA7XHJcblx0IHB1YmxpYyBfRGVzY3JpcHRpb246c3RyaW5nIDtcclxuXHQgcHVibGljIF9Db29sVGltZTpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0Nvc3RTUDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0F0dGFja0Rpc3RhbmNlOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXR0YWNrQW5nbGU6bnVtYmVyIDtcclxuXHQgcHVibGljIF9BdHRhY2tUYXJnZXRUYWdzOkFycmF5PHN0cmluZz4gO1xyXG5cdCBwdWJsaWMgX0ltcGFjdFR5cGU6QXJyYXk8c3RyaW5nPiA7XHJcblx0IHB1YmxpYyBfTmV4dEJhdHRsZXJJZDpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX0F0a1JhdGlvOm51bWJlciA7XHJcblx0IHB1YmxpYyBfRHVyYXRpb25UaW1lOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXRrSW50ZXJ2YWw6bnVtYmVyIDtcclxuXHQgcHVibGljIF9Ta2lsbFByZWZhYjpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0FuaW1hdGlvbk5hbWU6c3RyaW5nIDtcclxuXHQgcHVibGljIF9IaXRGeFByZWZhYjpzdHJpbmcgO1xyXG5cdCBwdWJsaWMgX0xldmVsOm51bWJlciA7XHJcblx0IHB1YmxpYyBfQXR0YWNrVHlwZTpudW1iZXIgO1xyXG5cdCBwdWJsaWMgX1NlbGVjdG9yVHlwZTpudW1iZXIgO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihfaWQ6bnVtYmVyLCBfTmFtZTpzdHJpbmcsIF9EZXNjcmlwdGlvbjpzdHJpbmcsIF9Db29sVGltZTpudW1iZXIsIF9Db3N0U1A6bnVtYmVyLCBfQXR0YWNrRGlzdGFuY2U6bnVtYmVyLCBfQXR0YWNrQW5nbGU6bnVtYmVyLCBfQXR0YWNrVGFyZ2V0VGFnczpBcnJheTxzdHJpbmc+LCBfSW1wYWN0VHlwZTpBcnJheTxzdHJpbmc+LCBfTmV4dEJhdHRsZXJJZDpudW1iZXIsIF9BdGtSYXRpbzpudW1iZXIsIF9EdXJhdGlvblRpbWU6bnVtYmVyLCBfQXRrSW50ZXJ2YWw6bnVtYmVyLCBfU2tpbGxQcmVmYWI6c3RyaW5nLCBfQW5pbWF0aW9uTmFtZTpzdHJpbmcsIF9IaXRGeFByZWZhYjpzdHJpbmcsIF9MZXZlbDpudW1iZXIsIF9BdHRhY2tUeXBlOm51bWJlciwgX1NlbGVjdG9yVHlwZTpudW1iZXIpe1xyXG5cdFx0dGhpcy5faWQgPSBfaWQ7XHJcblx0XHR0aGlzLl9OYW1lID0gX05hbWU7XHJcblx0XHR0aGlzLl9EZXNjcmlwdGlvbiA9IF9EZXNjcmlwdGlvbjtcclxuXHRcdHRoaXMuX0Nvb2xUaW1lID0gX0Nvb2xUaW1lO1xyXG5cdFx0dGhpcy5fQ29zdFNQID0gX0Nvc3RTUDtcclxuXHRcdHRoaXMuX0F0dGFja0Rpc3RhbmNlID0gX0F0dGFja0Rpc3RhbmNlO1xyXG5cdFx0dGhpcy5fQXR0YWNrQW5nbGUgPSBfQXR0YWNrQW5nbGU7XHJcblx0XHR0aGlzLl9BdHRhY2tUYXJnZXRUYWdzID0gX0F0dGFja1RhcmdldFRhZ3M7XHJcblx0XHR0aGlzLl9JbXBhY3RUeXBlID0gX0ltcGFjdFR5cGU7XHJcblx0XHR0aGlzLl9OZXh0QmF0dGxlcklkID0gX05leHRCYXR0bGVySWQ7XHJcblx0XHR0aGlzLl9BdGtSYXRpbyA9IF9BdGtSYXRpbztcclxuXHRcdHRoaXMuX0R1cmF0aW9uVGltZSA9IF9EdXJhdGlvblRpbWU7XHJcblx0XHR0aGlzLl9BdGtJbnRlcnZhbCA9IF9BdGtJbnRlcnZhbDtcclxuXHRcdHRoaXMuX1NraWxsUHJlZmFiID0gX1NraWxsUHJlZmFiO1xyXG5cdFx0dGhpcy5fQW5pbWF0aW9uTmFtZSA9IF9BbmltYXRpb25OYW1lO1xyXG5cdFx0dGhpcy5fSGl0RnhQcmVmYWIgPSBfSGl0RnhQcmVmYWI7XHJcblx0XHR0aGlzLl9MZXZlbCA9IF9MZXZlbDtcclxuXHRcdHRoaXMuX0F0dGFja1R5cGUgPSBfQXR0YWNrVHlwZTtcclxuXHRcdHRoaXMuX1NlbGVjdG9yVHlwZSA9IF9TZWxlY3RvclR5cGU7XHJcblxyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNraWxsQ29uZmlnVEIgZXh0ZW5kcyBTaW5nbGV0b248U2tpbGxDb25maWdUQj57IFxyXG5cdHB1YmxpYyB0cnM6TWFwPG51bWJlciwgU2tpbGxDb25maWdUUj4gPSBuZXcgTWFwPG51bWJlciwgU2tpbGxDb25maWdUUj4oKTtcclxuXHRjb25zdHJ1Y3Rvcigpe1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMudHJzLnNldCgxMDAxLCBuZXcgU2tpbGxDb25maWdUUigxMDAxLCBcIumZjem+meWNgeWFq+aOjFwiLCBcIuW4puacieW8uuWKm+aUu+WHu+aKgOiDvVwiLCAxMCwgMTc4LCAxLCAzMCwgW1wiRW5lbXlcIl0sIFtcIkNvc3RTUFwiLCBcIkRhbWFnZVwiXSwgMCwgMiwgMiwgMSwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIFwic2tpbGwxXCIsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCAxLCAxLCAxKSk7XHJcblx0XHR0aGlzLnRycy5zZXQoMTAwMiwgbmV3IFNraWxsQ29uZmlnVFIoMTAwMiwgXCLmmrTpm6jmoqjoirFcIiwgXCLluKbmnInlvLrlipvmlLvlh7vmioDog71cIiwgMTAsIDE3OCwgMSwgMzAsIFtcIkVuZW15XCJdLCBbXCJDb3N0U1BcIiwgXCJEYW1hZ2VcIl0sIDAsIDIsIDIsIDEsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCBcInNraWxsMlwiLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgMSwgMSwgMSkpO1xyXG5cdFx0dGhpcy50cnMuc2V0KDEwMDMsIG5ldyBTa2lsbENvbmZpZ1RSKDEwMDMsIFwi5o6S5bGx5YCS5rW3XCIsIFwi5bim5pyJ5by65Yqb5pS75Ye75oqA6IO9XCIsIDEwLCAxNzgsIDEsIDMwLCBbXCJFbmVteVwiXSwgW1wiQ29zdFNQXCIsIFwiRGFtYWdlXCJdLCAwLCAyLCAyLCAxLCBcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfVGFza0ZpbmlzaC5wcmVmYWJcIiwgXCJza2lsbDNcIiwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIDEsIDEsIDEpKTtcclxuXHRcdHRoaXMudHJzLnNldCgxMDA0LCBuZXcgU2tpbGxDb25maWdUUigxMDA0LCBcIuiRteiKseeCueeptOaJi1wiLCBcIuW4puacieW8uuWKm+aUu+WHu+aKgOiDvVwiLCAxMCwgMTc4LCAxLCAzMCwgW1wiRW5lbXlcIl0sIFtcIkNvc3RTUFwiLCBcIkRhbWFnZVwiXSwgMCwgMiwgMiwgMSwgXCJFZmZlY3QvUHJlZmFiL1VJL2VmX3VpX1Rhc2tGaW5pc2gucHJlZmFiXCIsIFwic2tpbGw0XCIsIFwiRWZmZWN0L1ByZWZhYi9VSS9lZl91aV9UYXNrRmluaXNoLnByZWZhYlwiLCAxLCAxLCAxKSk7XHJcblx0IH1cclxufVxyXG5cclxuIiwiaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuL2dlbi9wYlwiO1xyXG5leHBvcnQgY2xhc3MgRGVjb2RlTXNne1xyXG5cdHB1YmxpYyBycGNJZDpudW1iZXI7XHJcblx0cHVibGljIG1zZ09iajphbnk7XHJcbn1cclxuZXhwb3J0IGNsYXNzIE9wY29kZXtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMlJfTG9naW46bnVtYmVyID0gMTAwMDtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19SMkNfTG9naW46bnVtYmVyID0gMTAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdfTG9naW5HYXRlOm51bWJlciA9IDEwMDI7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfRzJDX0xvZ2luR2F0ZTpudW1iZXIgPSAxMDAzO1xyXG5cclxuXHRwdWJsaWMgc3RhdGljIE1TR19DMkdTX1Rlc3Q6bnVtYmVyID0gMjAwMTtcclxuXHRwdWJsaWMgc3RhdGljIE1TR19HUzJDX1Rlc3Q6bnVtYmVyID0gMjAwMjtcclxuXHJcblx0cHVibGljIHN0YXRpYyBtYXAgPSB7XHJcblx0XHQxMDAwIDoge1wiZGVjb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5DMlJfTG9naW4uZW5jb2RlfSxcclxuXHRcdDEwMDEgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLlIyQ19Mb2dpbi5lbmNvZGV9LFxyXG5cdFx0MTAwMiA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHX0xvZ2luR2F0ZS5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLkMyR19Mb2dpbkdhdGUuZW5jb2RlfSxcclxuXHRcdDEwMDMgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLkcyQ19Mb2dpbkdhdGUuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HMkNfTG9naW5HYXRlLmVuY29kZX0sXHJcblxyXG5cdFx0MjAwMSA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuQzJHU19UZXN0LmVuY29kZX0sXHJcblx0XHQyMDAyIDoge1wiZGVjb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5HUzJDX1Rlc3QuZW5jb2RlfVxyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGRlY29kZShvcGNvZGU6bnVtYmVyLCBtc2c6VWludDhBcnJheSk6RGVjb2RlTXNnIHtcclxuXHRcdGxldCBtc2dPYmogPSB0aGlzLm1hcFtvcGNvZGVdW1wiZGVjb2RlXCJdKG1zZyk7XHJcblx0XHRsZXQgZGVjb2RlTXNnID0gbmV3IERlY29kZU1zZygpO1xyXG5cdFx0ZGVjb2RlTXNnLnJwY0lkID0gbXNnT2JqLlJwY0lkO1xyXG5cdFx0ZGVjb2RlTXNnLm1zZ09iaiA9IG1zZ09iajtcclxuXHRcdHJldHVybiBkZWNvZGVNc2c7XHJcblx0fVxyXG5cdHB1YmxpYyBzdGF0aWMgZW5jb2RlKG9wY29kZTpudW1iZXIsIG1zZzpVaW50OEFycmF5KXtcclxuXHRcdGxldCBidWYgPSB0aGlzLm1hcFtvcGNvZGVdW1wiZW5jb2RlXCJdKG1zZykuZmluaXNoKCk7XHJcblx0XHRyZXR1cm4gYnVmXHJcblx0fVxyXG5cclxuXHJcblxyXG59XHJcbiIsIi8qZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgaWQtbGVuZ3RoLCBuby1jb250cm9sLXJlZ2V4LCBuby1tYWdpYy1udW1iZXJzLCBuby1wcm90b3R5cGUtYnVpbHRpbnMsIG5vLXJlZGVjbGFyZSwgbm8tc2hhZG93LCBuby12YXIsIHNvcnQtdmFycyovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL21pbmltYWxcIik7XG5cbi8vIENvbW1vbiBhbGlhc2VzXG52YXIgJFJlYWRlciA9ICRwcm90b2J1Zi5SZWFkZXIsICRXcml0ZXIgPSAkcHJvdG9idWYuV3JpdGVyLCAkdXRpbCA9ICRwcm90b2J1Zi51dGlsO1xuXG52YXIgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xuJHByb3RvYnVmLnV0aWwuTG9uZyA9IExvbmc7XG4kcHJvdG9idWYuY29uZmlndXJlKCk7XG5cblxuLy8gRXhwb3J0ZWQgcm9vdCBuYW1lc3BhY2VcbnZhciAkcm9vdCA9ICRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gfHwgKCRwcm90b2J1Zi5yb290c1tcImRlZmF1bHRcIl0gPSB7fSk7XG5cbiRyb290Lm5pY2VfdHMgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgbmljZV90cy5cbiAgICAgKiBAZXhwb3J0cyBuaWNlX3RzXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqL1xuICAgIHZhciBuaWNlX3RzID0ge307XG5cbiAgICBuaWNlX3RzLkMyUl9Mb2dpbiA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEMyUl9Mb2dpbi5cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcbiAgICAgICAgICogQGludGVyZmFjZSBJQzJSX0xvZ2luXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtBY2NvdW50XSBDMlJfTG9naW4gQWNjb3VudFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbUGFzc3dvcmRdIEMyUl9Mb2dpbiBQYXNzd29yZFxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDMlJfTG9naW4uXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyUl9Mb2dpbi5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyUl9Mb2dpblxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMlJfTG9naW49fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEMyUl9Mb2dpbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEMyUl9Mb2dpbiBBY2NvdW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEFjY291bnRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQzJSX0xvZ2luLnByb3RvdHlwZS5BY2NvdW50ID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQzJSX0xvZ2luIFBhc3N3b3JkLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IFBhc3N3b3JkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUuUGFzc3dvcmQgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyUl9Mb2dpbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMlJfTG9naW49fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW4gaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMlJfTG9naW4ocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMlJfTG9naW4gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMlJfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMlJfTG9naW59IG1lc3NhZ2UgQzJSX0xvZ2luIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQzJSX0xvZ2luLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJBY2NvdW50XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuQWNjb3VudCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QYXNzd29yZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiUGFzc3dvcmRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS5QYXNzd29yZCk7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJSX0xvZ2luIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJSX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJSX0xvZ2lufSBtZXNzYWdlIEMyUl9Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbigpO1xuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFjY291bnQgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QYXNzd29yZCA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEMyUl9Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBDMlJfTG9naW4gbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFjY291bnRcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLkFjY291bnQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBY2NvdW50OiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBhc3N3b3JkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIlBhc3N3b3JkXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5QYXNzd29yZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlBhc3N3b3JkOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJSX0xvZ2luIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxuICAgICAgICAgKi9cbiAgICAgICAgQzJSX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJSX0xvZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5BY2NvdW50ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5BY2NvdW50ID0gU3RyaW5nKG9iamVjdC5BY2NvdW50KTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuUGFzc3dvcmQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLlBhc3N3b3JkID0gU3RyaW5nKG9iamVjdC5QYXNzd29yZCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJSX0xvZ2luIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5DMlJfTG9naW59IG1lc3NhZ2UgQzJSX0xvZ2luXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJSX0xvZ2luLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LkFjY291bnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIG9iamVjdC5QYXNzd29yZCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFjY291bnRcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LkFjY291bnQgPSBtZXNzYWdlLkFjY291bnQ7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QYXNzd29yZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQYXNzd29yZFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuUGFzc3dvcmQgPSBtZXNzYWdlLlBhc3N3b3JkO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDMlJfTG9naW4gdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEMyUl9Mb2dpbjtcbiAgICB9KSgpO1xuXG4gICAgbmljZV90cy5SMkNfTG9naW4gPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBSMkNfTG9naW4uXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSVIyQ19Mb2dpblxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbRXJyb3JdIFIyQ19Mb2dpbiBFcnJvclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbTWVzc2FnZV0gUjJDX0xvZ2luIE1lc3NhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW0FkZHJlc3NdIFIyQ19Mb2dpbiBBZGRyZXNzXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0tleV0gUjJDX0xvZ2luIEtleVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtHYXRlSWRdIFIyQ19Mb2dpbiBHYXRlSWRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUjJDX0xvZ2luLlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBSMkNfTG9naW4uXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElSMkNfTG9naW5cbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JUjJDX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBSMkNfTG9naW4ocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSMkNfTG9naW4gRXJyb3IuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gRXJyb3JcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5FcnJvciA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFIyQ19Mb2dpbiBNZXNzYWdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5NZXNzYWdlID0gXCJcIjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUjJDX0xvZ2luIEFkZHJlc3MuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gQWRkcmVzc1xuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkFkZHJlc3MgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSMkNfTG9naW4gS2V5LlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gS2V5XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5wcm90b3R5cGUuS2V5ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFIyQ19Mb2dpbiBHYXRlSWQuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBHYXRlSWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5HYXRlSWQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBSMkNfTG9naW4gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gY3JlYXRlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JUjJDX0xvZ2luPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4uY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUjJDX0xvZ2luKHByb3BlcnRpZXMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUjJDX0xvZ2luIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuUjJDX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcbiAgICAgICAgICAgICAgICB3cml0ZXIgPSAkV3JpdGVyLmNyZWF0ZSgpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWRkcmVzcyAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiQWRkcmVzc1wiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLkFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJLZXlcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAwID0qLzE2KS5pbnQ2NChtZXNzYWdlLktleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkdhdGVJZFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDMsIHdpcmVUeXBlIDAgPSovMjQpLmludDY0KG1lc3NhZ2UuR2F0ZUlkKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBSMkNfTG9naW4gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5SMkNfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW59IG1lc3NhZ2UgUjJDX0xvZ2luIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgUjJDX0xvZ2luIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuUjJDX0xvZ2luKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkFkZHJlc3MgPSByZWFkZXIuc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHJlYWRlci5pbnQ2NCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgUjJDX0xvZ2luIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIFIyQ19Mb2dpbiBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuRXJyb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5NZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BZGRyZXNzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFkZHJlc3NcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLkFkZHJlc3MpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJBZGRyZXNzOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkpICYmICEobWVzc2FnZS5LZXkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiS2V5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQpICYmICEobWVzc2FnZS5HYXRlSWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2F0ZUlkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgUjJDX0xvZ2luIG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpblxuICAgICAgICAgKi9cbiAgICAgICAgUjJDX0xvZ2luLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuUjJDX0xvZ2luKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLlIyQ19Mb2dpbigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5FcnJvciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSBvYmplY3QuRXJyb3IgfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gU3RyaW5nKG9iamVjdC5NZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuQWRkcmVzcyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuQWRkcmVzcyA9IFN0cmluZyhvYmplY3QuQWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LktleSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5LZXkgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuS2V5KSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBwYXJzZUludChvYmplY3QuS2V5LCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gb2JqZWN0LktleTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LktleS5sb3cgPj4+IDAsIG9iamVjdC5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuR2F0ZUlkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLkdhdGVJZCA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5HYXRlSWQpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHBhcnNlSW50KG9iamVjdC5HYXRlSWQsIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBvYmplY3QuR2F0ZUlkO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuR2F0ZUlkLmxvdyA+Pj4gMCwgb2JqZWN0LkdhdGVJZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIFIyQ19Mb2dpbiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpblxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIFIyQ19Mb2dpbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IDA7XG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWRkcmVzcyAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJBZGRyZXNzXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5BZGRyZXNzID0gbWVzc2FnZS5BZGRyZXNzO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuS2V5ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuS2V5KSA6IG1lc3NhZ2UuS2V5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5LZXkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuS2V5LmxvdyA+Pj4gMCwgbWVzc2FnZS5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuS2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuR2F0ZUlkID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuR2F0ZUlkKSA6IG1lc3NhZ2UuR2F0ZUlkO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5HYXRlSWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuR2F0ZUlkLmxvdyA+Pj4gMCwgbWVzc2FnZS5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuR2F0ZUlkO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gbWVzc2FnZS5FcnJvcjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IG1lc3NhZ2UuTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgUjJDX0xvZ2luIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBSMkNfTG9naW47XG4gICAgfSkoKTtcblxuICAgIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEMyR19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbS2V5XSBDMkdfTG9naW5HYXRlIEtleVxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtHYXRlSWRdIEMyR19Mb2dpbkdhdGUgR2F0ZUlkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEMyR19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyR19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGU9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEMyR19Mb2dpbkdhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW2tleXNbaV1dID0gcHJvcGVydGllc1trZXlzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDMkdfTG9naW5HYXRlIEtleS5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfExvbmd9IEtleVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUuS2V5ID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEMyR19Mb2dpbkdhdGUgR2F0ZUlkLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gR2F0ZUlkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLnByb3RvdHlwZS5HYXRlSWQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDMkdfTG9naW5HYXRlIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IEMyR19Mb2dpbkdhdGUgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJHX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyR19Mb2dpbkdhdGUgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMkdfTG9naW5HYXRlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiS2V5XCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLktleSk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkdhdGVJZFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDY0KG1lc3NhZ2UuR2F0ZUlkKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdfTG9naW5HYXRlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlfSBtZXNzYWdlIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdfTG9naW5HYXRlKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcmVhZGVyLmludDY0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IEMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBDMkdfTG9naW5HYXRlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkpICYmICEobWVzc2FnZS5LZXkgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5LmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiS2V5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQpICYmICEobWVzc2FnZS5HYXRlSWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkLmhpZ2gpKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2F0ZUlkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IEMyR19Mb2dpbkdhdGVcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5DMkdfTG9naW5HYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyR19Mb2dpbkdhdGUoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuS2V5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLktleSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5LZXkpKS51bnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IHBhcnNlSW50KG9iamVjdC5LZXksIDEwKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBvYmplY3QuS2V5O1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuS2V5LmxvdyA+Pj4gMCwgb2JqZWN0LktleS5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5HYXRlSWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuR2F0ZUlkID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LkdhdGVJZCkpLnVuc2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gcGFyc2VJbnQob2JqZWN0LkdhdGVJZCwgMTApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IG9iamVjdC5HYXRlSWQ7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5HYXRlSWQubG93ID4+PiAwLCBvYmplY3QuR2F0ZUlkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEMyR19Mb2dpbkdhdGUudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbG9uZyA9IG5ldyAkdXRpbC5Mb25nKDAsIDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuS2V5ID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuS2V5KSA6IG1lc3NhZ2UuS2V5O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5LZXkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuS2V5LmxvdyA+Pj4gMCwgbWVzc2FnZS5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuS2V5O1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuR2F0ZUlkID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuR2F0ZUlkKSA6IG1lc3NhZ2UuR2F0ZUlkO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5HYXRlSWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuR2F0ZUlkLmxvdyA+Pj4gMCwgbWVzc2FnZS5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuR2F0ZUlkO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDMkdfTG9naW5HYXRlIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEMyR19Mb2dpbkdhdGU7XG4gICAgfSkoKTtcblxuICAgIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEcyQ19Mb2dpbkdhdGUuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBHMkNfTG9naW5HYXRlIEVycm9yXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNZXNzYWdlXSBHMkNfTG9naW5HYXRlIE1lc3NhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbUGxheWVySWRdIEcyQ19Mb2dpbkdhdGUgUGxheWVySWRcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRzJDX0xvZ2luR2F0ZS5cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgRzJDX0xvZ2luR2F0ZS5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRzJDX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEcyQ19Mb2dpbkdhdGUgRXJyb3IuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gRXJyb3JcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLkVycm9yID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRzJDX0xvZ2luR2F0ZSBNZXNzYWdlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHMkNfTG9naW5HYXRlIFBsYXllcklkLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gUGxheWVySWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLlBsYXllcklkID0gJHV0aWwuTG9uZyA/ICR1dGlsLkxvbmcuZnJvbUJpdHMoMCwwLGZhbHNlKSA6IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRzJDX0xvZ2luR2F0ZSBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlIGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEcyQ19Mb2dpbkdhdGUocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHMkNfTG9naW5HYXRlIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlfSBtZXNzYWdlIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QbGF5ZXJJZCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiUGxheWVySWRcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuUGxheWVySWQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkVycm9yXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTEsIHdpcmVUeXBlIDAgPSovNzI4KS5pbnQzMihtZXNzYWdlLkVycm9yKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIk1lc3NhZ2VcIikpXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5Miwgd2lyZVR5cGUgMiA9Ki83MzgpLnN0cmluZyhtZXNzYWdlLk1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HMkNfTG9naW5HYXRlLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGV9IG1lc3NhZ2UgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkcyQ19Mb2dpbkdhdGUoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSByZWFkZXIuaW50NjQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IEcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuRXJyb3IpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS5NZXNzYWdlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5QbGF5ZXJJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJQbGF5ZXJJZFwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLlBsYXllcklkKSAmJiAhKG1lc3NhZ2UuUGxheWVySWQgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuUGxheWVySWQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5QbGF5ZXJJZC5oaWdoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlBsYXllcklkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IEcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICovXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5HMkNfTG9naW5HYXRlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkcyQ19Mb2dpbkdhdGUoKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QuRXJyb3IgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcbiAgICAgICAgICAgIGlmIChvYmplY3QuTWVzc2FnZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IFN0cmluZyhvYmplY3QuTWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAob2JqZWN0LlBsYXllcklkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLlBsYXllcklkID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LlBsYXllcklkKSkudW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLlBsYXllcklkID0gcGFyc2VJbnQob2JqZWN0LlBsYXllcklkLCAxMCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5QbGF5ZXJJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5QbGF5ZXJJZCA9IG9iamVjdC5QbGF5ZXJJZDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLlBsYXllcklkID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5QbGF5ZXJJZC5sb3cgPj4+IDAsIG9iamVjdC5QbGF5ZXJJZC5oaWdoID4+PiAwKS50b051bWJlcigpO1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBtZXNzYWdlIEcyQ19Mb2dpbkdhdGVcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBHMkNfTG9naW5HYXRlLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBsYXllcklkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIlBsYXllcklkXCIpKVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5QbGF5ZXJJZCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuUGxheWVySWQpIDogbWVzc2FnZS5QbGF5ZXJJZDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5QbGF5ZXJJZCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5QbGF5ZXJJZC5sb3cgPj4+IDAsIG1lc3NhZ2UuUGxheWVySWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuUGxheWVySWQ7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSBtZXNzYWdlLkVycm9yO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gbWVzc2FnZS5NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBHMkNfTG9naW5HYXRlIHRvIEpTT04uXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEcyQ19Mb2dpbkdhdGU7XG4gICAgfSkoKTtcblxuICAgIG5pY2VfdHMuQzJHU19UZXN0ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJHU19UZXN0LlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xuICAgICAgICAgKiBAaW50ZXJmYWNlIElDMkdTX1Rlc3RcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW3Rlc3RJRF0gQzJHU19UZXN0IHRlc3RJRFxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdGVzdE5hbWVdIEMyR1NfVGVzdCB0ZXN0TmFtZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBDMkdTX1Rlc3QuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyR1NfVGVzdC5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUMyR1NfVGVzdFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEMyR1NfVGVzdChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEMyR1NfVGVzdCB0ZXN0SUQuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gdGVzdElEXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudGVzdElEID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQzJHU19UZXN0IHRlc3ROYW1lLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRlc3ROYW1lXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudGVzdE5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyR1NfVGVzdCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHU19UZXN0fSBDMkdTX1Rlc3QgaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDMkdTX1Rlc3QocHJvcGVydGllcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMkdTX1Rlc3QgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMkdTX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0SUQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3RJRFwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDAgPSovOCkuaW50MzIobWVzc2FnZS50ZXN0SUQpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdE5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3ROYW1lXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UudGVzdE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyR1NfVGVzdCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyR1NfVGVzdC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdTX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHU19UZXN0fSBDMkdTX1Rlc3RcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMkdTX1Rlc3QoKTtcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0SUQgPSByZWFkZXIuaW50MzIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3ROYW1lID0gcmVhZGVyLnN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZWFkZXIuc2tpcFR5cGUodGFnICYgNyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR1NfVGVzdH0gQzJHU19UZXN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJpZmllcyBhIEMyR1NfVGVzdCBtZXNzYWdlLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0SURcIikpXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50ZXN0SUQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ0ZXN0SUQ6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3ROYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3ROYW1lXCIpKVxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZXN0TmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlc3ROYW1lOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxuICAgICAgICAgKi9cbiAgICAgICAgQzJHU19UZXN0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyR1NfVGVzdCgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC50ZXN0SUQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RJRCA9IG9iamVjdC50ZXN0SUQgfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC50ZXN0TmFtZSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdE5hbWUgPSBTdHJpbmcob2JqZWN0LnRlc3ROYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgcGxhaW4gb2JqZWN0IGZyb20gYSBDMkdTX1Rlc3QgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyR1NfVGVzdH0gbWVzc2FnZSBDMkdTX1Rlc3RcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XG4gICAgICAgICAqL1xuICAgICAgICBDMkdTX1Rlc3QudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdElEID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdE5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdElEICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RJRFwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdElEID0gbWVzc2FnZS50ZXN0SUQ7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0TmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0TmFtZVwiKSlcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdE5hbWUgPSBtZXNzYWdlLnRlc3ROYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBDMkdTX1Rlc3QgdG8gSlNPTi5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIEMyR1NfVGVzdDtcbiAgICB9KSgpO1xuXG4gICAgbmljZV90cy5HUzJDX1Rlc3QgPSAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHUzJDX1Rlc3QuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUdTMkNfVGVzdFxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbRXJyb3JdIEdTMkNfVGVzdCBFcnJvclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbTWVzc2FnZV0gR1MyQ19UZXN0IE1lc3NhZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd8bnVsbH0gW3Rlc3RSZXNwb25zZV0gR1MyQ19UZXN0IHRlc3RSZXNwb25zZVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29uc3RydWN0cyBhIG5ldyBHUzJDX1Rlc3QuXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEdTMkNfVGVzdC5cbiAgICAgICAgICogQGltcGxlbWVudHMgSUdTMkNfVGVzdFxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHUzJDX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEdTMkNfVGVzdChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcGVydGllcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdTMkNfVGVzdCBFcnJvci5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLkVycm9yID0gMDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR1MyQ19UZXN0IE1lc3NhZ2UuXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gTWVzc2FnZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHUzJDX1Rlc3QgdGVzdFJlc3BvbnNlLlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRlc3RSZXNwb25zZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLnRlc3RSZXNwb25zZSA9IFwiXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgR1MyQ19UZXN0IGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HUzJDX1Rlc3R9IEdTMkNfVGVzdCBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEdTMkNfVGVzdChwcm9wZXJ0aWVzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEdTMkNfVGVzdCBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkdTMkNfVGVzdC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXG4gICAgICAgICAqL1xuICAgICAgICBHUzJDX1Rlc3QuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgICAgICAgICAgaWYgKCF3cml0ZXIpXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RSZXNwb25zZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVzdFJlc3BvbnNlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHUzJDX1Rlc3QgbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HUzJDX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHUzJDX1Rlc3R9IG1lc3NhZ2UgR1MyQ19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNvZGVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkdTMkNfVGVzdH0gR1MyQ19UZXN0XG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuR1MyQ19UZXN0KCk7XG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RSZXNwb25zZSA9IHJlYWRlci5zdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLCBsZW5ndGggZGVsaW1pdGVkLlxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HUzJDX1Rlc3R9IEdTMkNfVGVzdFxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmVyaWZpZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZS5cbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcbiAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAgICAgICAgICovXG4gICAgICAgIEdTMkNfVGVzdC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IGludGVnZXIgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2U6IHN0cmluZyBleHBlY3RlZFwiO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdFJlc3BvbnNlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3RSZXNwb25zZVwiKSlcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UudGVzdFJlc3BvbnNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdFJlc3BvbnNlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XG4gICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HUzJDX1Rlc3R9IEdTMkNfVGVzdFxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuR1MyQ19UZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdCgpO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5FcnJvciAhPSBudWxsKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSBvYmplY3QuRXJyb3IgfCAwO1xuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gU3RyaW5nKG9iamVjdC5NZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdFJlc3BvbnNlICE9IG51bGwpXG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0UmVzcG9uc2UgPSBTdHJpbmcob2JqZWN0LnRlc3RSZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgR1MyQ19UZXN0IG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5HUzJDX1Rlc3R9IG1lc3NhZ2UgR1MyQ19UZXN0XG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3RSZXNwb25zZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gMDtcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0UmVzcG9uc2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdFJlc3BvbnNlXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC50ZXN0UmVzcG9uc2UgPSBtZXNzYWdlLnRlc3RSZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IG1lc3NhZ2UuRXJyb3I7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBtZXNzYWdlLk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEdTMkNfVGVzdCB0byBKU09OLlxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gR1MyQ19UZXN0O1xuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gbmljZV90cztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gJHJvb3Q7XG4iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3MgY29tbW9uVUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwiY29tbW9uXCI7XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlQnl0ZXM6c3RyaW5nID0gXCJjb21tb25fZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUxvYWRpbmdQYWdlOnN0cmluZyA9IFwiTG9hZGluZ1BhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJVUlOb3RpY2VXaW46c3RyaW5nID0gXCJVSU5vdGljZVdpblwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBob21lVUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwiaG9tZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZUJ5dGVzOnN0cmluZyA9IFwiaG9tZV9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJSG9tZVBhZ2U6c3RyaW5nID0gXCJIb21lUGFnZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlMZXZlbFBhZ2U6c3RyaW5nID0gXCJMZXZlbFBhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJU2hvcFBhZ2U6c3RyaW5nID0gXCJTaG9wUGFnZVwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBsb2dpblVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImxvZ2luXCI7XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlQnl0ZXM6c3RyaW5nID0gXCJsb2dpbl9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJTG9naW5QYWdlOnN0cmluZyA9IFwiTG9naW5QYWdlXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVNlbFNlcnZlcldpbjpzdHJpbmcgPSBcIlNlbFNlcnZlcldpblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlBcmVhSXRlbTpzdHJpbmcgPSBcIkFyZWFJdGVtXCI7XG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIHN0b3J5VUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwic3RvcnlcIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcInN0b3J5X2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlTdG9yeVdpbjpzdHJpbmcgPSBcIlN0b3J5V2luXCI7XG59IiwiXHJcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gJy4vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gJy4vUmVzTWFuYWdlcic7XHJcbmltcG9ydCB7IFVuaXR5RW5naW5lIH0gZnJvbSAnY3NoYXJwJztcclxuXHJcblxyXG5cclxuLy8gLS0gR2FtZU9iamVjdOe8k+WtmOaxoFxyXG4vLyAtLSDms6jmhI/vvJpcclxuLy8gLS0gMeOAgeaJgOaciemcgOimgemihOiuvumDveS7jui/memHjOWKoOi9ve+8jOS4jeimgeebtOaOpeWIsFJlc291cmNlc01hbmFnZXLljrvliqDovb3vvIznlLHov5nph4znu5/kuIDlgZrnvJPlrZjnrqHnkIZcclxuLy8gLS0gMuOAgee8k+WtmOWIhuS4uuS4pOmDqOWIhu+8muS7jui1hOa6kOWxguWKoOi9veeahOWOn+Wni0dhbWVPYmplY3QoQXNzZXQp77yM5LuOR2FtZU9iamVjdOWunuS+i+WMluWHuuadpeeahOWkmuS4qkluc3RcclxuZXhwb3J0IGNsYXNzIEdhbWVPYmplY3RQb29sIGV4dGVuZHMgU2luZ2xldG9uPEdhbWVPYmplY3RQb29sPntcclxuXHJcbiAgICBwcml2YXRlIF9fY2FjaGVUcmFuc1Jvb3QgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfX2dvUG9vbCA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgX19pbnN0Q2FjaGU6TWFwPHN0cmluZyxBcnJheTxhbnk+PiA9IG5ldyBNYXA8c3RyaW5nLEFycmF5PGFueT4+KCk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgbGV0IGdvID0gVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5GaW5kKFwiR2FtZU9iamVjdENhY2hlUm9vdFwiKTtcclxuXHJcbiAgICAgICAgaWYoZ28gPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgZ28gPSBuZXcgVW5pdHlFbmdpbmUuR2FtZU9iamVjdChcIkdhbWVPYmplY3RDYWNoZVJvb3RcIik7XHJcbiAgICAgICAgICAgIFVuaXR5RW5naW5lLk9iamVjdC5Eb250RGVzdHJveU9uTG9hZChnbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9fY2FjaGVUcmFuc1Jvb3QgPSBnby50cmFuc2Zvcm07XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLSDmo4DmtYvmmK/lkKblt7Lnu4/ooqvnvJPlrZhcclxuICAgIHB1YmxpYyBjaGVja0hhc0NhY2hlZChwYXRoOnN0cmluZyl7XHJcblxyXG4gICAgICAgIGxldCBjYWNoZWRJbnN0OkFycmF5PGFueT4gPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICBpZihjYWNoZWRJbnN0ICE9IHVuZGVmaW5lZCAmJiBjYWNoZWRJbnN0Lmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb29sZWRHbyA9IHRoaXMuX19nb1Bvb2wuZ2V0KHBhdGgpO1xyXG4gICAgICAgIHJldHVybiBwb29sZWRHbyAhPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g57yT5a2Y5bm25a6e5L6L5YyWR2FtZU9iamVjdFxyXG4gICAgcHVibGljIGNhY2hlQW5kSW5zdEdhbWVPYmplY3QocGF0aDpzdHJpbmcsIGdvOmFueSwgaW5zdF9jb3VudDpudW1iZXIgPSAxKXtcclxuXHJcbiAgICAgICAgdGhpcy5fX2dvUG9vbC5zZXQocGF0aCwgZ28pO1xyXG4gICAgICAgIGlmKGluc3RfY291bnQgPiAwKXtcclxuXHJcbiAgICAgICAgICAgIGxldCBjYWNoZWRJbnN0OkFycmF5PGFueT4gPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpOm51bWJlciA9MDsgaSA8IGluc3RfY291bnQ7IGkrKyl7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGluc3QgPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKGdvKSBhcyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgaW5zdC50cmFuc2Zvcm0uU2V0UGFyZW50KHRoaXMuX19jYWNoZVRyYW5zUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBpbnN0LlNldEFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FjaGVkSW5zdC5wdXNoKGluc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0g5bCd6K+V5LuO57yT5a2Y5Lit6I635Y+WXHJcbiAgICBwdWJsaWMgdHJ5R2V0RnJvbUNhY2hlKHBhdGg6c3RyaW5nKTphbnl7XHJcblxyXG4gICAgICAgIGlmKCF0aGlzLmNoZWNrSGFzQ2FjaGVkKHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8b2JqZWN0PiAgPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICBpZihjYWNoZWRJbnN0ICE9IHVuZGVmaW5lZCAmJiBjYWNoZWRJbnN0Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBpbnN0ID0gY2FjaGVkSW5zdC5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcG9vbGVkR28gPSB0aGlzLl9fZ29Qb29sLmdldChwYXRoKTtcclxuICAgICAgICBpZihwb29sZWRHbyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBsZXQgaW5zdCA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuSW5zdGFudGlhdGUocG9vbGVkR28pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8v6aKE5Yqg6L2977ya5Y+v5o+Q5L6b5Yid5aeL5a6e5L6L5YyW5Liq5pWwXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJlTG9hZEdhbWVPYmplY3RBc3luYyhwYXRoOnN0cmluZywgaW5zdF9jb3VudDpudW1iZXIsIGNhbGxiYWNrOkZ1bmN0aW9uLC4uLnBhcmFtcyl7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuY2hlY2tIYXNDYWNoZWQocGF0aCkpe1xyXG4gICAgICAgICAgICBpZihjYWxsYmFjayE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBnbyA9IGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFByZWZhYihwYXRoKTtcclxuICAgICAgICBpZihnbyE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZUFuZEluc3RHYW1lT2JqZWN0KHBhdGgsIGdvLGluc3RfY291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoY2FsbGJhY2shPW51bGwpe1xyXG4gICAgICAgICAgICBjYWxsYmFjayhwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDlvILmraXojrflj5bvvJrlv4XopoHml7bliqDovb1cclxuICAgIHB1YmxpYyBhc3luYyBnZXRHYW1lT2JqZWN0QXN5bmMocGF0aDpzdHJpbmcsIGNhbGxiYWNrOkZ1bmN0aW9uLC4uLnBhcmFtcyl7XHJcblxyXG4gICAgICAgIGxldCBpbnN0OmFueSA9IHRoaXMudHJ5R2V0RnJvbUNhY2hlKHBhdGgpO1xyXG4gICAgICAgIGlmKGluc3QgPT1udWxsKXtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVMb2FkR2FtZU9iamVjdEFzeW5jKHBhdGgsIDEsIGNhbGxiYWNrLCBwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5zdCA9IHRoaXMudHJ5R2V0RnJvbUNhY2hlKHBhdGgpO1xyXG4gICAgICAgIGluc3QuU2V0QWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDlm57mlLZcclxuICAgIHB1YmxpYyByZWN5Y2xlR2FtZU9iamVjdChwYXRoOnN0cmluZywgaW5zdDphbnkpe1xyXG5cclxuICAgICAgICBpbnN0LnRyYW5zZm9ybS5TZXRQYXJlbnQodGhpcy5fX2NhY2hlVHJhbnNSb290KTtcclxuICAgICAgICBpbnN0LlNldEFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgIGxldCBjYWNoZWRJbnN0ID0gdGhpcy5fX2luc3RDYWNoZS5nZXQocGF0aCkgfHwgbmV3IEFycmF5KCk7XHJcbiAgICAgICAgY2FjaGVkSW5zdC5wdXNoKGluc3QpO1xyXG5cclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLnNldChwYXRoLCBjYWNoZWRJbnN0KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g5riF55CG57yT5a2YXHJcbiAgICBwdWJsaWMgY2xlYW51cChpbmNsdWRlUG9vbGVkR286Ym9vbGVhbiA9IGZhbHNlKXtcclxuXHJcbiAgICAgICAgdGhpcy5fX2luc3RDYWNoZS5mb3JFYWNoKCh2YWx1ZXMsIGtleSk9PntcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaW5zdCBvZiB2YWx1ZXMpe1xyXG4gICAgICAgICAgICAgICAgaWYoaW5zdCAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBVbml0eUVuZ2luZS5HYW1lT2JqZWN0LkRlc3Ryb3koaW5zdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLmNsZWFyKCk7IFxyXG5cclxuICAgICAgICBpZihpbmNsdWRlUG9vbGVkR28pe1xyXG4gICAgICAgICAgICB0aGlzLl9fZ29Qb29sLmZvckVhY2goKGdvLCBrZXkpPT57XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZ28gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5yZWxlYXNlQWRkcmVzc0dPKGdvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9fZ29Qb29sLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiXHJcblxyXG5leHBvcnQgY2xhc3MgTWVzT2Jqe1xyXG4gICAgcHVibGljIGxpc3RlbmVyczpBcnJheTxGdW5jdGlvbj47XHJcbiAgICBwdWJsaWMgb2JqOmFueTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBNZXNzZW5nZXJ7XHJcblxyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lck1hcCA9IG5ldyBNYXA8bnVtYmVyLE1lc09iaj4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIoZV90eXBlOm51bWJlciwgZV9vYmo6YW55LCBlX2xpc3RuZXI6RnVuY3Rpb24pOnZvaWR7XHJcblxyXG4gICAgICAgIGxldCBtc2dPYmogPSB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YobXNnT2JqKSA9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgbXNnT2JqID0gbmV3IE1lc09iaigpO1xyXG4gICAgICAgICAgICBtc2dPYmoub2JqID0gZV9vYmo7XHJcbiAgICAgICAgICAgIG1zZ09iai5saXN0ZW5lcnMgPSBuZXcgQXJyYXk8RnVuY3Rpb24+KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zZ09iai5saXN0ZW5lcnMucHVzaChlX2xpc3RuZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyTWFwLnNldChlX3R5cGUsIG1zZ09iaik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldExpc3RlbmVyKGVfdHlwZTpudW1iZXIpOk1lc09iantcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0KGVfdHlwZTpudW1iZXIsIC4uLnBhcmFtczphbnlbXSkgOiB2b2lkIHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZW9mKG1zZ09iaikgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIGZvcihsZXQgbCBvZiBtc2dPYmoubGlzdGVuZXJzKXtcclxuICAgICAgICAgICAgICAgbC5hcHBseShtc2dPYmoub2JqLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5VHlwZShlX3R5cGU6bnVtYmVyKSA6dm9pZCB7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuZGVsZXRlKGVfdHlwZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihlX3R5cGU6bnVtYmVyLCBlX2xpc3RlbmVyOkZ1bmN0aW9uICk6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZihtc2dPYmopICE9IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKGxldCBpOm51bWJlciA9MDsgaTwgbXNnT2JqLmxpc3RlbmVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpZihtc2dPYmoubGlzdGVuZXJzW2ldID09IGVfbGlzdGVuZXIpe1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ09iai5saXN0ZW5lcnMuc3BsaWNlKGksMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFydXAoKTp2b2lke1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG59IiwiXHJcblxyXG5cclxuLy8gRmFpcnlHVUkg5YWD5Lu2IOe7keWumuWZqFxyXG5leHBvcnQgZnVuY3Rpb24gYmluZGVyKG5hbWU6c3RyaW5nKXtcclxuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6YW55LCBrZXk6c3RyaW5nIHwgc3ltYm9sKXtcclxuICAgICAgICB0YXJnZXRbXCJiaW5kZXJzXCJdID0gdGFyZ2V0W1wiYmluZGVyc1wiXSB8fCB7fTtcclxuICAgICAgICB0YXJnZXRbXCJiaW5kZXJzXCJdW2tleV0gPSBuYW1lO1xyXG4gICAgfVxyXG59IiwiXHJcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gJy4vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgJHByb21pc2UgfSBmcm9tICdwdWVydHMnO1xyXG5pbXBvcnQge05pY2VUUywgVW5pdHlFbmdpbmV9IGZyb20gJ2NzaGFycCc7XHJcblxyXG5leHBvcnQgY2xhc3MgUmVzTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZXNNYW5hZ2VyPntcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFNjZW5lKHNjZW5lTmFtZTpzdHJpbmcpe1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHNpbmdsZSA9IFVuaXR5RW5naW5lLlNjZW5lTWFuYWdlbWVudC5Mb2FkU2NlbmVNb2RlLlNpbmdsZTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkU2NlbmUoc2NlbmVOYW1lLCBzaW5nbGUsKHByb2dyZXNzOk51bWJlcik9PntcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9hZCBzY2VuZTogXCIrcHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNjZW5JbnN0YW5jZSA9IGF3YWl0ICRwcm9taXNlKHRhc2spXHJcbiAgICAgICAgICAgIHJldHVybiBzY2VuSW5zdGFuY2VcclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExvYWQgU2NlbmUgOiR7c2NlbmVOYW1lfSA6ICR7ZXh9YClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgYXN5bmMgdW5sb2FkU2NlbmUoc2NlbmVJbnN0YW5jZTpVbml0eUVuZ2luZS5SZXNvdXJjZU1hbmFnZW1lbnQuUmVzb3VyY2VQcm92aWRlcnMuU2NlbmVJbnN0YW5jZSl7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzaz0gTmljZVRTLlJlc291cmNlTWFuYWdlci5VbmxvYWRTY2VuZShzY2VuZUluc3RhbmNlKVxyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBVbmxvYWQgc2NlbmUgIDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRQcmVmYWIoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRQcmVmYWIoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExvYWQgcHJlZmFiIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkVGV4dEFzc2V0KGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFRleHRBc3NldChhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBMb2FkIHRleHRhc3NldCA6JHthZGRyZXNzfSA6ICR7ZXh9YClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgYXN5bmMgbG9hZFRleHRCeXRlcyhhZGRyZXNzOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRUZXh0Qnl0ZXMoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBieXRlcyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gYnl0ZXM7XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgTG9hZFRleHRCeXRlcyA6JHthZGRyZXNzfSA6ICR7ZXh9YClcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZFNwcml0ZShhZGRyZXNzOnN0cmluZyl7XHJcblxyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgbGV0IHRhc2sgPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLkxvYWRTcHJpdGUoYWRkcmVzcyk7XHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcblxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYExvYWQgc3ByaXRlIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRGYWlyeUdVSVBhY2thZ2UoYWRkcmVzczpzdHJpbmcsIHBhY2thZ2VOYW1lOnN0cmluZywgY2FsbGJhY2s/OkZ1bmN0aW9uKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZEZhaXJ5R1VJUGFja2FnZShhZGRyZXNzLHBhY2thZ2VOYW1lKTtcclxuICAgICAgICAgICAgYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soKTtcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBMb2FkIGZhaXJ5R1VJIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVsZWFzZUFkZHJlc3NHTyhnbzphbnkpe1xyXG5cclxuICAgICAgICBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlJlbGVhc2VBZGRyZXNzR08oZ28pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWxlYXNlRmFpcnlHVUlQYWNrYWdlKHBhY2thZ2VOYW1lKXtcclxuICAgICAgICBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlJlbGVhc2VGR1VJUGFja2FnZShwYWNrYWdlTmFtZSk7XHJcbiAgICB9XHJcbn0iLCJcclxuXHJcbmV4cG9ydCBjbGFzcyBTaW5nbGV0b248VD57XHJcblxyXG4gICAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6YW55ID0gbnVsbDtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIEluc3RhbmNlPFQ+KCBjOiB7IG5ldygpOiBUIH0gKSA6IFR7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaW5zdGFuY2UgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgYygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgICB9XHJcblxyXG59IiwiaW1wb3J0IHsgU3RvcnkgfSBmcm9tIFwiaW5ranMvZW5naW5lL1N0b3J5XCI7XG5cbmV4cG9ydCBjbGFzcyBJbmtTdGF0ZUluc3BlY3RvcntcblxuICAgIHB1YmxpYyBCaW5kSW5rTWV0aG9kcyhpbmtTdG9yeTpTdG9yeSk6dm9pZHtcbiAgICAgICAgXG4gICAgICAgIC8vM+WPguaVsOS7peS4i+mHh+eUqOatpOaWueW8j1xuICAgICAgICB0aGlzLmJpbmRJbmtNZXRob2RPbmNlKGlua1N0b3J5LFwiR2V0Q2hhcmFjdGVyTmFtZVwiLHRoaXMuZ2V0Q2hhcmFjdGVyTmFtZSk7XG4gICAgICAgIC8vM+WPguaVsOS7peS4iumHh+eUqOatpOaWueW8jyBcbiAgICAgICAgdGhpcy5iaW5kSW5rTWV0aG9kT25jZUdlbmVyYWwoaW5rU3RvcnksXCJHZXRDaGFyYWN0ZXJOYW1lQnlNdXRpUGFyYW1zXCIsdGhpcy5nZXRDaGFyYWN0ZXJOYW1lTXV0aVBhcmFtcyk7XG4gICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDaGFyYWN0ZXJOYW1lKCk6c3RyaW5ne1xuICAgICAgICByZXR1cm4gXCJKdXN0aW4gVGVzdCBQdWVydHNcIjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENoYXJhY3Rlck5hbWVNdXRpUGFyYW1zKHAxOm51bWJlcixwMjpudW1iZXIscDM6bnVtYmVyKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIkp1c3RpbiBNdXRpIFBhcmFtc1wiO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBiaW5kSW5rTWV0aG9kT25jZShpbmtTdG9yeTpTdG9yeSxmdW5jTmFtZTpzdHJpbmcsZnVuYzpTdG9yeS5FeHRlcm5hbEZ1bmN0aW9uKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuQmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUsIGZ1bmMpO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuICAgIHByaXZhdGUgYmluZElua01ldGhvZE9uY2VHZW5lcmFsKGlua1N0b3J5OlN0b3J5LCBmdW5jTmFtZTpzdHJpbmcsZnVuYzpTdG9yeS5FeHRlcm5hbEZ1bmN0aW9uKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKGZ1bmNOYW1lLCBmdW5jKTtcbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgICAgICAgfSAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIHVuYmluZElua01ldGhvZChpbmtTdG9yeTpTdG9yeSxmdW5jTmFtZTpzdHJpbmcpe1xuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuVW5iaW5kRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSk7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycik7XG4gICAgICAgIH0gICAgIFxuICAgIH1cbn0iLCJpbXBvcnQgeyBTdG9yeSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvU3RvcnlcIjtcbmltcG9ydCB7IElua1N0YXRlSW5zcGVjdG9yIH0gZnJvbSBcIi4vSW5rU3RhdGVJbnNwZWN0b3JcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBJbmtXcml0ZXJ7XG5cbiAgICBwdWJsaWMgc3RhdGljIERFQlVHX1NUT1JZX0lEOnN0cmluZyA9IFwiREVCVUdfU1RPUllcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfUFJFRklYOnN0cmluZyA9IFwiPj4+XCI7XG4gICAgcHVibGljIHN0YXRpYyBDT01NQU5EX0RFTElNSVRFUjpzdHJpbmcgPSBcIjpcIjtcbiAgICBwdWJsaWMgc3RhdGljIENPTU1BTkRfQVJHX0RFTElNSVRFUjpzdHJpbmcgPSAnLCc7XG5cbiAgICBwcml2YXRlIF9jdXJyZW50U3Rvcnk6U3Rvcnk7XG4gICAgcHJpdmF0ZSBfYWxsSW5rQ29tbWFuZHM6TWFwPHN0cmluZyxGdW5jdGlvbj4gPSBuZXcgTWFwPHN0cmluZyxGdW5jdGlvbj4oKTtcblxuXG4gICAgY29uc3RydWN0b3Ioc3RvcnlKc29uOnN0cmluZyl7XG4gICAgICAgIHRoaXMuc2V0dXBJbmtDb21tYW5kcygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVN0cm95KHN0b3J5SnNvbik7XG4gICAgICAgIHRoaXMubG9hZCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkKCk6dm9pZHtcbiAgICAgICAgbGV0IHN0b3J5U3RhdGU6c3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYoc3RvcnlTdGF0ZSE9bnVsbCAmJiBzdG9yeVN0YXRlIT1cIlwiKXtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS5Mb2FkSnNvbihzdG9yeVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlU3Ryb3koanNvbjpzdHJpbmcpe1xuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkgPSBuZXcgU3RvcnkoanNvbik7XG5cbiAgICAgICBcbiAgICB9XG5cbiAgICBwdWJsaWMgYmVnaW5TdG9yeShrbm90TmFtZTpzdHJpbmcpe1xuICAgICAgICBpZih0aGlzLl9jdXJyZW50U3RvcnkgPT0gbnVsbCl7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUcnlpbmcgdG8gQWR2YW5jZVN0b3J5IGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWVuIGNyZWF0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuQ2hvb3NlUGF0aFN0cmluZyhrbm90TmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgIGxldCBpbmtTdGF0ZTpJbmtTdGF0ZUluc3BlY3RvciA9IG5ldyBJbmtTdGF0ZUluc3BlY3RvcigpO1xuICAgICAgICAgaW5rU3RhdGUuQmluZElua01ldGhvZHModGhpcy5fY3VycmVudFN0b3J5KTtcblxuICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBnaXZlUmV3YXJkKCk6Ym9vbGVhbntcbiAgICAgICAgY29uc29sZS5sb2coXCJnaXZlIHJld2FyZC4uLlwiKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldHVwSW5rQ29tbWFuZHMoKTp2b2lke1xuICAgICAgICB0aGlzLl9hbGxJbmtDb21tYW5kcy5zZXQoXCJHSVZFX1JFV0FSRFwiLHRoaXMuZ2l2ZVJld2FyZClcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZUNvbW1hbmQoY29tbWFuZDpzdHJpbmcsIGFyZ3M6c3RyaW5nW10pOmJvb2xlYW57XG4gICAgICAgIGlmKHRoaXMuX2FsbElua0NvbW1hbmRzLmhhcyhjb21tYW5kKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWxsSW5rQ29tbWFuZHMuZ2V0KGNvbW1hbmQpKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZCBub3QgZmluZCBJbmtDb21tYW5kIHdpdGggbmFtZTpcIitjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYXJzZUNvbW1hbmROYW1lKHRleHQ6c3RyaW5nKTpzdHJpbmd7XG4gICAgICAgIGxldCBudW06bnVtYmVyID0gdGV4dC5pbmRleE9mKElua1dyaXRlci5DT01NQU5EX1BSRUZJWCk7XG4gICAgICAgIGxldCBudW0yOm51bWJlciA9IHRleHQuaW5kZXhPZihJbmtXcml0ZXIuQ09NTUFORF9ERUxJTUlURVIpO1xuICAgICAgICBpZihudW0yID09IC0xKXtcbiAgICAgICAgICAgIG51bTIgPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsZW5ndGg6bnVtYmVyID0gbnVtMiAtIChudW0gKyBJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyKG51bSArIElua1dyaXRlci5DT01NQU5EX1BSRUZJWC5sZW5ndGgsIGxlbmd0aCkudHJpbSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBwYXJzZUNvbW1hbmRBcmdzKHRleHQ6c3RyaW5nKTpzdHJpbmdbXXtcbiAgICAgICAgbGV0IG51bTpudW1iZXIgPSB0ZXh0LmluZGV4T2YoSW5rV3JpdGVyLkNPTU1BTkRfREVMSU1JVEVSKTtcbiAgICAgICAgaWYobnVtID09IC0xKXtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlciA9IHRleHQubGVuZ3RoIC0gKG51bSArIDEpO1xuICAgICAgICBsZXQgbGlzdDpzdHJpbmdbXSA9IHRleHQuc3Vic3RyKG51bSsxLCBsZW5ndGgpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW0oKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGxpdChJbmtXcml0ZXIuQ09NTUFORF9BUkdfREVMSU1JVEVSKTtcbiAgICAgICAgZm9yIChsZXQgaTpudW1iZXI9MDsgaTxsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gbGlzdFtpXS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuXG4gICAgcHVibGljIGV4dHJhY3RTcGVha2VyKGxpbmU6c3RyaW5nKTpbc3RyaW5nLHN0cmluZ117XG4gICAgICAgIGlmKGxpbmUuc3RhcnRzV2l0aChJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpKXtcbiAgICAgICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFycmF5OnN0cmluZ1tdID0gbGluZS5zcGxpdCgnOicsMik7XG4gICAgICAgIGlmKGFycmF5Lmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgbGV0IHNwZWFrSUQ6c3RyaW5nID0gYXJyYXlbMF0udHJpbSgpO1xuICAgICAgICAgICAgbGV0IHNwZWFrQ29udGVudDpzdHJpbmcgPSBhcnJheVsxXS50cmltKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbc3BlYWtJRCwgc3BlYWtDb250ZW50XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCIwXCIsbGluZS50cmltKCldO1xuICAgIH1cblxuICAgIHB1YmxpYyBzYXZlQ3VycmVudFN0b3J5KCk6dm9pZHtcbiAgICAgICAgbGV0IGN1cnJTdGF0ZSA9IHRoaXMuX2N1cnJlbnRTdG9yeS5zdGF0ZS50b0pzb24oKTtcbiAgICAgICAgLy9UT0RP772T772B772W772FXG4gICAgfVxuXG4gICAgcHVibGljIGNhbkNvbnRpbnVlKCk6Ym9vbGVhbntcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdG9yeS5jYW5Db250aW51ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWR2YW5jZVN0b3J5KCk6dm9pZHtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIEFkdmFuY2VTdG9yeSBpbiBJbmtXcml0ZXIgd2hlbiBubyBzdG9yeSBoYXMgYmVlbiBjcmVhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5fY3VycmVudFN0b3J5LmNhbkNvbnRpbnVlKXtcbiAgICAgICAgICAgIGxldCB0ZXh0OnN0cmluZyA9IHRoaXMuX2N1cnJlbnRTdG9yeS5Db250aW51ZSgpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmKHRleHQgPT0gXCJcIil7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RvcnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNwZWFrSUQ6c3RyaW5nO1xuICAgICAgICAgICAgbGV0IHNwZWFrQ29udGVudDpzdHJpbmc7XG5cbiAgICAgICAgICAgIFtzcGVha0lELCBzcGVha0NvbnRlbnRdID0gdGhpcy5leHRyYWN0U3BlYWtlcih0ZXh0KTtcblxuICAgICAgICAgICAgbGV0IGNvbW1hbmROYW1lOnN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJnczpzdHJpbmdbXSA9IG51bGw7XG4gICAgICAgICAgICBpZihzcGVha0NvbnRlbnQuc3RhcnRzV2l0aChJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpKXtcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZSA9IHRoaXMucGFyc2VDb21tYW5kTmFtZShzcGVha0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnBhcnNlQ29tbWFuZEFyZ3Moc3BlYWtDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZihjb21tYW5kTmFtZSAhPSBudWxsICYmIGNvbW1hbmROYW1lICE9XCJcIil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFuZGxlQ29tbWFuZChjb21tYW5kTmFtZSwgYXJncykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vT25Db250ZW50UmVhZHlcbiAgICAgICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdENvbnRlbnRSZWFkeShcbiAgICAgICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNPTlRFTlRSRUFEWSxcbiAgICAgICAgICAgICAgICAgICAgc3BlYWtDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBzcGVha0lELFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuY3VycmVudFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9jdXJyZW50U3RvcnkuY3VycmVudENob2ljZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAvL09uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5icm9hZGNhc3RDaG9pY2VzUHJlc2VudGVkKFxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DSE9JQ0VTUFJFU0VOVEVELFxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL09uU3RvcnlGaW5pc2hlZFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5icm9hZGNhc3RTdG9yeUZpbmlzaGVkKFxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05TVE9SWUZJTklTSEVEXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2VsZWN0Q2hvaWNlKGNob2ljZUluZGV4Om51bWJlcik6dm9pZHtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJ5aW5nIHRvIENob29zZUNob2ljZSBpbiBJbmtXcml0ZXIgd2hlbiBubyBzdG9yeSBoYXMgYmVndW5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LkNob29zZUNob2ljZUluZGV4KGNob2ljZUluZGV4KTtcbiAgICAgICAgdGhpcy5hZHZhbmNlU3RvcnkoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZyk6YW55e1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0b3J5LnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodmFyaWFibGVOYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZywgdmFsdWU6YW55KXtcbiAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5LnZhcmlhYmxlc1N0YXRlLiQodmFyaWFibGVOYW1lLCB2YWx1ZSk7XG4gICAgfVxufSIsImltcG9ydCB7IENob2ljZSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvQ2hvaWNlXCI7XG5pbXBvcnQgeyBSZXNNYW5hZ2VyIH0gZnJvbSBcIi4uL2NvbW1vbi9SZXNNYW5hZ2VyXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vY29tbW9uL1NpbmdsZXRvblwiO1xuaW1wb3J0IHsgSW5rV3JpdGVyIH0gZnJvbSBcIi4vSW5rV3JpdGVyXCI7XG5cbmV4cG9ydCBjbGFzcyBTdG9yeU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U3RvcnlNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgX2lua1dyaXRlcjpJbmtXcml0ZXI7XG4gICAgcHJpdmF0ZSBzdG9yeUFkZHJlc3M6c3RyaW5nID0gXCJTdG9yeS9UZXN0U3RvcnkuanNvblwiO1xuXG4gICAgcHVibGljIGdldCBpbmtXcml0ZXIoKTpJbmtXcml0ZXJ7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmtXcml0ZXI7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgaW5pdGlhbGl6ZSgpe1xuXG4gICAgICAgIGlmKHRoaXMuX2lua1dyaXRlciA9PSBudWxsKXtcblxuICAgICAgICAgICAgdmFyIGpzb24gPSAgKGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFRleHRBc3NldCh0aGlzLnN0b3J5QWRkcmVzcykpLnRleHQ7XG4gICAgICAgICAgICB0aGlzLl9pbmtXcml0ZXIgPSBuZXcgSW5rV3JpdGVyKGpzb24pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgYmVnaW5TdG9yeShrbm90TmFtZTpzdHJpbmcpOnZvaWR7XG4gICAgICAgIHRoaXMuX2lua1dyaXRlci5iZWdpblN0b3J5KGtub3ROYW1lKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2FuQ29udGludWUoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lua1dyaXRlci5jYW5Db250aW51ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWR2YW5jZVN0b3J5KCl7XG4gICAgICAgIHRoaXMuX2lua1dyaXRlci5hZHZhbmNlU3RvcnkoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2VsZWN0Q2hvaWNlKGNob2ljZTpDaG9pY2UpOnZvaWR7XG4gICAgICAgIHRoaXMuX2lua1dyaXRlci5zZWxlY3RDaG9pY2UoY2hvaWNlLmluZGV4KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbG9hZEN1cnJlbnQoKTp2b2lke1xuICAgICAgICBpZih0aGlzLl9pbmtXcml0ZXIhPW51bGwpIHRoaXMuX2lua1dyaXRlci5sb2FkKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcpOmFueXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lua1dyaXRlci5nZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nLCB2YWx1ZTphbnkpe1xuICAgICAgICB0aGlzLmlua1dyaXRlci5zZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBDaG9pY2UgfSBmcm9tIFwiaW5ranMvZW5naW5lL0Nob2ljZVwiO1xuaW1wb3J0IHsgTWVzc2VuZ2VyIH0gZnJvbSBcIi4uL2NvbW1vbi9NZXNzZW5nZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5cbmV4cG9ydCBjbGFzcyBTdG9yeU1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFN0b3J5TWVzc2FnZU1hbmFnZXI+e1xuXG4gICAgcHVibGljIHN0YXRpYyBPTkNPTlRFTlRSRUFEWTpudW1iZXIgPSAxMDAxO1xuICAgIHB1YmxpYyBzdGF0aWMgT05DSE9JQ0VTUFJFU0VOVEVEOm51bWJlciA9IDEwMDI7XG4gICAgcHVibGljIHN0YXRpYyBPTlNUT1JZRklOSVNIRUQ6bnVtYmVyID0gMTAwMztcblxuICAgIHByaXZhdGUgc3RvcnlNZXNzYWdlOk1lc3NlbmdlciA9IG5ldyBNZXNzZW5nZXIoKTtcblxuXG4gICAgcHVibGljIGFkZExpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLG9iajphbnksIGxpc3RlbmVyOkZ1bmN0aW9uKXtcblxuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5hZGRMaXN0ZW5lcihtc2dDb2RlLCBvYmosIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsIGxpc3RlbmVyOkZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobXNnQ29kZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5Q29kZShtc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyQnlUeXBlKG1zZ0NvZGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhcnVwKCl7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmNsZWFydXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0Q29udGVudFJlYWR5KFxuICAgICAgICBtc2dDb2RlOm51bWJlcixcbiAgICAgICAgc3BlYWtlckNvbnRlbnQ6c3RyaW5nLFxuICAgICAgICBzcGVha2VySWQ6c3RyaW5nLFxuICAgICAgICBjdXJyZW50VGFnczpzdHJpbmdbXSxcbiAgICAgICAgY3VycmVudENob2ljZXM6Q2hvaWNlW11cbiAgICAgICAgKVxuICAgIHtcblxuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5icm9hZGNhc3QobXNnQ29kZSwgc3BlYWtlckNvbnRlbnQsc3BlYWtlcklkLGN1cnJlbnRUYWdzLGN1cnJlbnRDaG9pY2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0Q2hvaWNlc1ByZXNlbnRlZChcbiAgICAgICAgbWVzZ0NvZGU6bnVtYmVyLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXVxuICAgICl7XG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmJyb2FkY2FzdChtZXNnQ29kZSxjdXJyZW50Q2hvaWNlcyk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdFN0b3J5RmluaXNoZWQobWVzZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYnJvYWRjYXN0KG1lc2dDb2RlKTsgICBcbiAgICB9XG59IiwiaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcclxuaW1wb3J0IHsgT3Bjb2RlIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvT3Bjb2RlXCI7XHJcbmltcG9ydCB7IE5ldEVycm9yQ29kZSB9IGZyb20gXCIuL05ldEVycm9yQ29kZVwiO1xyXG5pbXBvcnQgeyBOaWNlVFMgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IE1lc3NhZ2VQYXJzZXIgfSBmcm9tIFwiLi9NZXNzYWdlUGFyc2VyXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIE1zZ1BhY2t7XHJcbiAgICBwdWJsaWMgc2VuZFRpbWU6bnVtYmVyO1xyXG4gICAgcHVibGljIGNhbGxiYWNrOkZ1bmN0aW9uO1xyXG4gICAgcHVibGljIHJldHJ5VGltZXM6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBieXRlczpVaW50OEFycmF5O1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR2FtZVNlc3Npb24gZXh0ZW5kcyBTaW5nbGV0b248R2FtZVNlc3Npb24+e1xyXG5cclxuICAgIHB1YmxpYyBpZDpudW1iZXIgPSAwOyAgLy9zZXNzaW9uIElEXHJcbiAgICBwcml2YXRlIHJlU2VuZEludGVydmFsOm51bWJlciA9IDEwMDAwOyAvLzEw56eS6YeN5Y+R5LiA5qyhXHJcbiAgICBwcml2YXRlIHRpbWVvdXRJbnRlcnZhbDpudW1iZXIgPSA1MDAwOyAvLzXnp5Lmo4Dmn6XkuIDmrKHmmK/lkKbotoXml7ZcclxuICAgIHByaXZhdGUgbWF4UmVTZW5kVGltZXM6bnVtYmVyID0gNTsgLy/mnIDlpKfph43lj5HmrKHmlbBcclxuICAgIHByaXZhdGUgdGltZW91dElpbWVyOmFueTtcclxuXHJcbiAgICBwcml2YXRlIF9ycGNJZDpudW1iZXIgPSAxO1xyXG4gICAgcHJpdmF0ZSBjaGFubmVsOmFueTtcclxuICAgIHByaXZhdGUgcmVxdWVzdENhbGxiYWNrOk1hcDxudW1iZXIsTXNnUGFjaz4gPSBuZXcgTWFwPG51bWJlcixNc2dQYWNrPigpO1xyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lcnM6TWFwPG51bWJlcixGdW5jdGlvbj4gPSBuZXcgTWFwPG51bWJlcixGdW5jdGlvbj4oKTtcclxuXHJcbiAgICAvL+i/lOWbnueahOacjeWKoeWZqElELCDnsbvlnotcclxuICAgIHByaXZhdGUgX3NlcnZlcklkOm51bWJlciA9IC0xO1xyXG4gICAgcHJpdmF0ZSBfc2VydmVyVHlwZTpudW1iZXIgPSAxO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IHJwY0lkKCk6bnVtYmVye1xyXG4gICAgICAgIHJldHVybiArK3RoaXMuX3JwY0lkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vYWRkcmVzcy0+IGlwOnBvcnRcclxuICAgIHB1YmxpYyBjb25uZWN0Q2hhbm5lbChhZGRyZXNzOnN0cmluZywgY29ubkNhYmFjazphbnkpe1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwgPSBOaWNlVFMuVFNlcnZpY2UuSW5zdGFuY2UuR2V0Q2hhbm5lbCgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5lcnJvckNhbGxiYWNrID0gKGNoYW5uZWw6YW55LCBjb2RlOm51bWJlcik9PntcclxuICAgICAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElpbWVyID0gc2V0SW50ZXJ2YWwoKCk9PntcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrVGltZW91dE1zZygpO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcy50aW1lb3V0SW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25uQ2FiYWNrKGNoYW5uZWwsIGNvZGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLnJlYWRDYWxsYmFjayA9IChidWZmZXI6VWludDhBcnJheSk9PntcclxuICAgICAgICAgICAgdGhpcy5vblJlY2VpdmUoYnVmZmVyKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLmNoYW5uZWwuQ29ubmVjdChhZGRyZXNzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy/mjqXmlLbmnI3liqHlmajpgJrnn6VcclxuICAgIHB1YmxpYyBsaXN0ZW4ob3Bjb2RlOm51bWJlcixjYWxsYmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc2V0KG9wY29kZSwgY2FsbGJhY2spO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5Y+R6YCBcHJvdG91Ymbmtojmga9cclxuICAgIC8v5raI5oGv77yaIHJwY19pZFs0XSAtIG9wY29kZVsyXSAtIHNlcnZlcl9pZFsyXSAtIHNlcnZlcl90eXBlWzFdIC0gXHJcbiAgICBwdWJsaWMgc2VuZChvcGNvZGU6bnVtYmVyLHJwY2lkOm51bWJlciwgbWVzc2FnZTpVaW50OEFycmF5LCBjYWxsQmFjazpGdW5jdGlvbil7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy/lsIHoo4Xmtojmga/vvJpcclxuICAgICAgICBsZXQgcnBjQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZUludChycGNpZCk7IC8vNFxyXG4gICAgICAgIGxldCBvcGNvZGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlU2hvcnQob3Bjb2RlKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcmlkQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZVNob3J0KHRoaXMuX3NlcnZlcklkKTsgLy8yXHJcbiAgICAgICAgbGV0IHNlcnZlcnR5cGVCdWY6VWludDhBcnJheSA9IE1lc3NhZ2VQYXJzZXIuZW5jb2RlQnl0ZSh0aGlzLl9zZXJ2ZXJUeXBlKTsgLy8xXHJcblxyXG5cclxuICAgICAgICBsZXQgc2VuZEFycmF5OlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0ICsgMiArIDIgKyAxICttZXNzYWdlLmxlbmd0aCk7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChycGNCdWYpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQob3Bjb2RlQnVmLCAgICA0KTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KHNlcnZlcmlkQnVmLCAgNCArIDIpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQoc2VydmVydHlwZUJ1ZiwgNCArIDIgKyAyKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KG1lc3NhZ2UsICAgICAgIDQgKyAyICsgMiArIDEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGNhbGxCYWNrICE9IG51bGwpe1xyXG4gICAgICAgICAgICBsZXQgbXNnUGFjazpNc2dQYWNrID0gbmV3IE1zZ1BhY2soKTtcclxuICAgICAgICAgICAgbXNnUGFjay5zZW5kVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICBtc2dQYWNrLmNhbGxiYWNrID0gY2FsbEJhY2s7XHJcbiAgICAgICAgICAgIG1zZ1BhY2suYnl0ZXMgPSBzZW5kQXJyYXk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5zZXQocnBjaWQsIG1zZ1BhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3IobGV0IGkgaW4gc2VuZEFycmF5KXtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJUUyAtLSBzZW5kIGFycmF5OiBcIitpKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy9Db25zb2xlLmxvZyhcInNlbmQgYXJyYXk6IFwiK3NlbmRBcnJheSk7XHJcbiAgICAgICAgdGhpcy5jaGFubmVsLlNlbmQoc2VuZEFycmF5KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlU2VuZChieXRlczpVaW50OEFycmF5KXtcclxuICAgICAgICB0aGlzLmNoYW5uZWwuU2VuZChieXRlcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uUmVjZWl2ZShidWZmZXI6VWludDhBcnJheSl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IG1zZ0J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XHJcblxyXG4gICAgICAgIGxldCBycGNpZCA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlSW50KG1zZ0J1Zi5zdWJhcnJheSgwLDQpKTtcclxuICAgICAgICBsZXQgb3Bjb2RlID0gTWVzc2FnZVBhcnNlci5kZWNvZGVTaG9ydChtc2dCdWYuc3ViYXJyYXkoNCw2KSk7XHJcbiAgICAgICAgbGV0IHNlcnZlcmlkID0gTWVzc2FnZVBhcnNlci5kZWNvZGVTaG9ydChtc2dCdWYuc3ViYXJyYXkoNiw4KSk7XHJcbiAgICAgICAgbGV0IHNlcnZlcnR5cGUgPSBNZXNzYWdlUGFyc2VyLmRlY29kZUJ5dGUobXNnQnVmLnN1YmFycmF5KDgsOSkpO1xyXG5cclxuICAgICAgICB0aGlzLl9zZXJ2ZXJJZCA9IHNlcnZlcmlkO1xyXG4gICAgICAgIHRoaXMuX3NlcnZlclR5cGUgPSBzZXJ2ZXJ0eXBlO1xyXG5cclxuICAgICAgICBsZXQgbXNnQnl0ZXM6VWludDhBcnJheSA9IG1zZ0J1Zi5zdWJhcnJheSg5KTtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgZGVjb2RlTXNnID0gIE9wY29kZS5kZWNvZGUob3Bjb2RlLCBtc2dCeXRlcyk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYocnBjaWQ9PXVuZGVmaW5lZCB8fCAhdGhpcy5yZXF1ZXN0Q2FsbGJhY2suaGFzKHJwY2lkKSl7XHJcbiAgICAgICAgICAgICAgICAvL+ajgOafpeaYr+WQpuaYr+acjeWKoeWZqOS4i+WPkeeahOa2iOaBr1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5saXN0ZW5lcnMuaGFzKG9wY29kZSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ZW4gPSB0aGlzLmxpc3RlbmVycy5nZXQob3Bjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW4oZGVjb2RlTXNnLm1zZ09iaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICBcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBsZXQgbXNnUGFjazpNc2dQYWNrID0gdGhpcy5yZXF1ZXN0Q2FsbGJhY2suZ2V0KHJwY2lkKTtcclxuICAgICAgICAgICAgICAgIG1zZ1BhY2suY2FsbGJhY2soZGVjb2RlTXNnLm1zZ09iaik7ICBcclxuICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2FsbGJhY2suZGVsZXRlKHJwY2lkKTtcclxuICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWNhdGNoKGUpe1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwicGFyc2UgbXNnIGVycm9yLCBvcGNvZGU6XCIrb3Bjb2RlKVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjaGVja1RpbWVvdXRNc2coKXtcclxuXHJcbiAgICAgICAgbGV0IGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgICAgIHRoaXMucmVxdWVzdENhbGxiYWNrLmZvckVhY2goKHZhbHVlLCBrZXkpID0+e1xyXG5cclxuICAgICAgICAgICAgaWYodmFsdWUucmV0cnlUaW1lcyA+PSB0aGlzLm1heFJlU2VuZFRpbWVzKSB7XHJcbiAgICAgICAgICAgICAgICAvL+i2hei/h+acgOWkp+mHjeWPkeasoeaVsO+8jOS4ouW8g1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYE1lc3NhZ2UgcmVzZW5kIHRvbyBtb3JlLCBvcGNvZGU6JHtrZXl9LCBsYXN0c2VuZDoke3ZhbHVlLnNlbmRUaW1lfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2FsbGJhY2suZGVsZXRlKGtleSk7IFxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgICAgICBpZigoY3VyclRpbWUgLSB2YWx1ZS5zZW5kVGltZSkgPj0gdGhpcy5yZVNlbmRJbnRlcnZhbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucmV0cnlUaW1lcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNlbmRUaW1lID0gY3VyclRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/ph43lj5Hmtojmga9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlU2VuZCh2YWx1ZS5ieXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHJlc2VuZCBtZXNzYWdlOiwgb3Bjb2RlOiR7a2V5fSwgcmV0cnkgdGltZXM6JHt2YWx1ZS5yZXRyeVRpbWVzfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBkaXNjb25uZWN0KCk6dm9pZHtcclxuXHJcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVvdXRJaW1lcik7XHJcblxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5EaXNwb3NlKCk7XHJcbiAgICB9XHJcbn0iLCJcbmV4cG9ydCBjbGFzcyBNZXNzYWdlUGFyc2Vye1xuXG5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZUludChuOm51bWJlcik6VWludDhBcnJheXtcblxuICAgICAgICBsZXQgYnVmZmVyOlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gMjQ7XG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gPj4+IDE2O1xuICAgICAgICBidWZmZXJbMl0gPSBuID4+PiA4O1xuICAgICAgICBidWZmZXJbM10gPSBuICYgMHhmZjtcblxuICAgICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkZWNvZGVJbnQoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcbiAgICAgICAgXG4gICAgICAgIGxldCBuID0gYnVmZmVyWzBdIDw8IDI0IHwgYnVmZmVyWzFdIDw8IDE2IHwgYnVmZmVyWzJdIDw8IDggfCBidWZmZXJbM107XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZVNob3J0KG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXIgOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gICAgICAgIGJ1ZmZlclswXSA9IG4gPj4+IDg7XG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZVNob3J0KGJ1ZmZlcjpVaW50OEFycmF5KTpudW1iZXJ7XG5cbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF0gPDwgOCB8IGJ1ZmZlclsxXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlQnl0ZShuOm51bWJlcik6VWludDhBcnJheXtcblxuICAgICAgICBsZXQgYnVmZmVyIDogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgICAgIGJ1ZmZlclswXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkZWNvZGVCeXRlKGJ1ZmZlcjpVaW50OEFycmF5KTpudW1iZXJ7XG5cbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF07XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG5cblxufSIsIlxuXG4gZXhwb3J0IGNsYXNzIE5ldEVycm9yQ29kZVxuIHtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldENvbm5TdWNjOm51bWJlciA9IDEwMDAwMDtcblxuICAgICBwdWJsaWMgc3RhdGljICBFUlJfQ29ubmVjdEdhdGVLZXlFcnJvcjpudW1iZXIgPSAxMDAwMDY7XG5cbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1BlZXJEaXNjb25uZWN0Om51bWJlciAgID0gMTAyMDA4O1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q2FudFNlbmQ6bnVtYmVyICAgPSAxMDIwMDk7XG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Tb2NrZXRFcnJvcjpudW1iZXIgICAgICA9IDEwMjAxMDtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldENvbm5FcnJvcjpudW1iZXIgID0gMTAyMDExO1xuXG5cbiAgICAgXG5cbiB9IiwiXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcbmltcG9ydCB7IEdhbWVDb25maWcgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuL0dhbWVTZXNzaW9uXCI7XG5pbXBvcnQgeyBOZXRFcnJvckNvZGUgfSBmcm9tIFwiLi9OZXRFcnJvckNvZGVcIjtcblxuXG5leHBvcnQgY2xhc3MgU2Vzc2lvbk1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U2Vzc2lvbk1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBzZXNzaW9uUmVhbTpHYW1lU2Vzc2lvbjtcbiAgICBwcml2YXRlIHNlc3Npb25HYXRlOkdhbWVTZXNzaW9uO1xuXG5cbiAgICBwdWJsaWMgZ2V0IHJlYWxtUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvblJlYW0ucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnYXRlUnBjSUQoKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Vzc2lvbkdhdGUucnBjSWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIGNvbm5lY3RSZWFsbVNlcnZlcigpOlByb21pc2U8Ym9vbGVhbj4ge1xuXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8Ym9vbGVhbj4ocmVzb3ZlID0+e1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbSA9IEdhbWVTZXNzaW9uLkluc3RhbmNlKEdhbWVTZXNzaW9uKS5jb25uZWN0Q2hhbm5lbChcbiAgICAgICAgICAgICAgICBHYW1lQ29uZmlnLnJlYWxtU2VydmVySVArXCI6XCIrR2FtZUNvbmZpZy5yZWFsbVNlcnZlclBvcnQsXG4gICAgICAgICAgICAgICAgKGNoYW5uZWw6YW55LGNvZGU6bnVtYmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBpZihjb2RlID09IE5ldEVycm9yQ29kZS5FUlJfU29ja2V0Q29ublN1Y2Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5pZCA9IGNoYW5uZWwuSWQ7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZShmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJsb2dpbiByZWFtc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgIH1cblxuICAgIFxuICAgIHB1YmxpYyBkaXNjb25uZWN0UmVhbG1TZXJ2ZXIoKXtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblJlYW0gPSBudWxsO1xuICAgIH1cblxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRSZWFsbU1zZyhvcGNvZGU6bnVtYmVyLG1zZzphbnkpOlByb21pc2U8YW55PntcbiAgICAgICAgXG4gICAgICAgIGxldCBycGNJRCA9IHRoaXMuc2Vzc2lvblJlYW0ucnBjSWRcbiAgICAgICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxhbnk+KChyZXNvdmUpID0+IHtcblxuICAgICAgICAgICAgbGV0IGJ1ZiA9IE9wY29kZS5lbmNvZGUob3Bjb2RlLCBtc2cpXG5cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYW0uc2VuZChvcGNvZGUsIHJwY0lELCBidWYsIChyZXNwb25zZTphbnkpPT57XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvdmUocmVzcG9uc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG5cbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdEdhdGVTZXJ2ZXIoYWRkcmVzczpzdHJpbmcpOlByb21pc2U8Ym9vbGVhbj57XG5cbiAgICAgICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxib29sZWFuPihyZXNvdmUgPT57XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlID0gR2FtZVNlc3Npb24uSW5zdGFuY2UoR2FtZVNlc3Npb24pLmNvbm5lY3RDaGFubmVsKFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgKGNoYW5uZWw6YW55LGNvZGU6bnVtYmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luIEdhdGUgU2VydmVyOiBcIitjb2RlKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUuaWQgPSBjaGFubmVsLklkO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZSh0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc292ZShmYWxzZSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImdhdGUgc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2VcbiAgICB9XG5cblxuICAgIHB1YmxpYyBkaXNjb25uZWN0R2F0ZVNlcnZlcigpe1xuICAgICAgICB0aGlzLnNlc3Npb25HYXRlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRHYXRlTXNnKG9wY29kZTpudW1iZXIsIG1zZzphbnkpOlByb21pc2U8YW55PntcblxuICAgICAgICBsZXQgcnBjSUQgPSB0aGlzLnNlc3Npb25HYXRlLnJwY0lkXG4gICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2U8YW55PigocmVzb3ZlKSA9PiB7XG5cbiAgICAgICAgICAgIGxldCBidWYgPSBPcGNvZGUuZW5jb2RlKG9wY29kZSwgbXNnKVxuXG4gICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlLnNlbmQob3Bjb2RlLCBycGNJRCwgYnVmLCAocmVzcG9uc2U6YW55KT0+e1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVzb3ZlKHJlc3BvbnNlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcHJvbWlzZVxuXG4gICAgfVxufSAgIFxuIiwiaW1wb3J0IHsgZW1pdCB9IGZyb20gXCJwdWVydHNcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyIH0gZnJvbSBcIi4vUmVkSGludHNNZXNzYWdlTWFuYWdlclwiO1xuXG5leHBvcnQgZW51bSBlbnVtUmVkSGludHMge1xuICAgIC8qKiDmoIforrDkvY0gKi9cbiAgICBub25lID0gMCxcbiAgICAvKiog6IGK5aSpICovXG4gICAgY2hhdCA9IDEsXG4gICAgLyoqIOiBiuWkqeS4lueVjOmikemBkyAqL1xuICAgIGNoYXRfd29ybGQgPSAyLFxuICAgIC8qKiDogYrlpKnlhazkvJrpopHpgZMgKi9cbiAgICBjaGF0X2ZhbWlseSA9IDMsXG4gICAgLyoqIOiBiuWkqeezu+e7n+mikemBkyAqL1xuICAgIGNoYXRfc3lzdGVtID0gNCxcbn1cblxuXG5leHBvcnQgY2xhc3MgUmVkSGludHNNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFJlZEhpbnRzTWFuYWdlcj57XG5cbiAgICBwcml2YXRlIF9kYXRhOiBBcnJheTxudW1iZXI+Oy8v6K6w5b2V5q+P5Liq57qi54K555qE5pWw5YC8XG4gICAgcHJpdmF0ZSBfcGFyZW50SW5kZXg6IEFycmF5PG51bWJlcj47Ly/orrDlvZXniLbnuqfntKLlvJVcbiAgICBwcml2YXRlIF9jaGlsZE51bTogQXJyYXk8bnVtYmVyPjsvL+iusOW9leWtkOmhueaVsOmHj1xuICAgIHByaXZhdGUgX2NoaWxkSW5kZXg6IEFycmF5PG51bWJlcj47Ly/orrDlvZXlrZDpobnlnKjniLbnuqfkuK3nmoTmjpLluo/ntKLlvJVcblxuICAgIC8qKlxuICAgICAqIOe6oueCueWAvOaUueWPmFxuICAgICovXG4gICAgcHVibGljIHN0YXRpYyBSRURfSElOVF9WQUxVRV9DSEFOR0VEOiBzdHJpbmcgPSBcIlJFRF9ISU5UX1ZBTFVFX0NIQU5HRURcIjtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFswXTsvL+esrOS4gOS9jeaXoOaEj+S5iVxuICAgICAgICB0aGlzLl9wYXJlbnRJbmRleCA9IFswXTtcbiAgICAgICAgdGhpcy5fY2hpbGROdW0gPSBbMF07XG4gICAgICAgIHRoaXMuX2NoaWxkSW5kZXggPSBbMF07XG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t6K6w5b2V54i25a2Q5YWz57O7LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgLy/ogYrlpKlcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQoZW51bVJlZEhpbnRzLmNoYXRfd29ybGQsIGVudW1SZWRIaW50cy5jaGF0KTtcbiAgICAgICAgdGhpcy5zZXRQYXJlbnQoZW51bVJlZEhpbnRzLmNoYXRfZmFtaWx5LCBlbnVtUmVkSGludHMuY2hhdCk7XG4gICAgICAgIHRoaXMuc2V0UGFyZW50KGVudW1SZWRIaW50cy5jaGF0X3N5c3RlbSwgZW51bVJlZEhpbnRzLmNoYXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOiuvue9rue6oueCueeahOW8gOWQr+WSjOWFs+mXrVxuICAgICovXG4gICBwdWJsaWMgc2V0UmVkSGludE9wZW5PckNsb3NlKHJlZDogbnVtYmVyLCBpc09wZW46IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkTnVtW3JlZF0gPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIue6oueCueaVsOaNruiuvue9rumUmeivr++8muS4jeiDveebtOaOpeWvuemrmOe6p+eahOe6oueCueaVsOaNruaTjeS9nFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvU2V0UmVkSGludE9wZW5PckNsb3NlKHJlZCwgaXNPcGVuID8gMSA6IDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICog6K6w5b2V54i25a2Q5YWz57O777ya5a2QLS0t54i2XG4gICAgKi9cbiAgICBwcml2YXRlIHNldFBhcmVudChjaGlsZDogbnVtYmVyLCBwYXJlbnQ6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50SW5kZXhbcGFyZW50XSA9PSBjaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLlhbPns7vlj43kuoZcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudEluZGV4W2NoaWxkXSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLph43lpI3orr7nva5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyZW50SW5kZXhbY2hpbGRdID0gcGFyZW50O1xuICAgICAgICBpZiAoaXNOYU4odGhpcy5fY2hpbGROdW1bcGFyZW50XSkpIHsgdGhpcy5fY2hpbGROdW1bcGFyZW50XSA9IDAgfVxuICAgICAgICB0aGlzLl9jaGlsZE51bVtwYXJlbnRdKys7Ly/lrZDpobnmlbDph4/lop7liqBcbiAgICAgICAgdGhpcy5fY2hpbGRJbmRleFtjaGlsZF0gPSB0aGlzLl9jaGlsZE51bVtwYXJlbnRdOy8v5a2Q6aG555qE57Si5byVIOS7jjHlvIDlp4tcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvU2V0UmVkSGludE9wZW5PckNsb3NlKHJlZDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhW3JlZF0gIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbcmVkXSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IF9wYXJlbnQ6IG51bWJlciA9IHRoaXMuX3BhcmVudEluZGV4W3JlZF1cbiAgICAgICAgICAgIGlmIChfcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy/lpoLmnpzmnInniLbnuqfvvIzmm7TmlrDniLbnuqdcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg6IG51bWJlciA9IHRoaXMuX2NoaWxkSW5kZXhbcmVkXTsvL+iOt+WPluWcqOeItue6p+S4reeahOe0ouW8lVxuICAgICAgICAgICAgICAgIHRoaXMuZG9TZXRSZWRIaW50T3Blbk9yQ2xvc2UoX3BhcmVudCwgdmFsdWUgPiAwID8gdGhpcy5fZGF0YVtfcGFyZW50XSB8IHRoaXMuYWRkVihpbmRleCkgOiB0aGlzLl9kYXRhW19wYXJlbnRdICYgdGhpcy5zdWJWKGluZGV4KSk7Ly/orr7nva7niLbnuqfnmoTlgLxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy/lj5HmlLnlj5jkuovku7Y65YWo5bGA5LqL5Lu2XG4gICAgICAgICAgICAvL2VtaXQoUmVkSGludHNNYW5hZ2VyLlJFRF9ISU5UX1ZBTFVFX0NIQU5HRUQsIHJlZCk7XG4gICAgICAgICAgICAvL+e6oueCueS6i+S7tu+8jOWxgOmDqOS6i+S7tlxuICAgICAgICAgICAgUmVkSGludHNNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01lc3NhZ2VNYW5hZ2VyKS5icm9hZGNhc3QocmVkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBhZGRWKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gMSA8PCAoaW5kZXggLSAxKTtcbiAgICB9XG4gICAgcHJpdmF0ZSBzdWJWKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gfnRoaXMuYWRkVihpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOafpeeci+e6oueCueaYr+WQpuW8gOWQr1xuICAgICovXG4gICAgcHVibGljIGNoZWNrUmVkSXNPcGVuKHJlZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhW3JlZF0gPiAwO1xuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgTWVzc2VuZ2VyIH0gZnJvbSBcIi4uL2NvbW1vbi9NZXNzZW5nZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgUmVkSGludHNNZXNzYWdlTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxSZWRIaW50c01lc3NhZ2VNYW5hZ2VyPntcblxuICAgIHByaXZhdGUgcmVkaGludHNNZXNzYWdlOk1lc3NlbmdlciA9IG5ldyBNZXNzZW5nZXIoKTtcblxuXG4gICAgcHVibGljIGFkZExpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLG9iajphbnksIGxpc3RlbmVyOkZ1bmN0aW9uKXtcblxuICAgICAgICB0aGlzLnJlZGhpbnRzTWVzc2FnZS5hZGRMaXN0ZW5lcihtc2dDb2RlLCBvYmosIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsIGxpc3RlbmVyOkZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy5yZWRoaW50c01lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobXNnQ29kZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5Q29kZShtc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMucmVkaGludHNNZXNzYWdlLnJlbW92ZUxpc3RlbmVyQnlUeXBlKG1zZ0NvZGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhcnVwKCl7XG4gICAgICAgIHRoaXMucmVkaGludHNNZXNzYWdlLmNsZWFydXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0KG1zZ0NvZGU6bnVtYmVyLHBhcmFtczphbnkpe1xuXG5cbiAgICAgICAgdGhpcy5yZWRoaW50c01lc3NhZ2UuYnJvYWRjYXN0KG1zZ0NvZGUsIHBhcmFtcylcbiAgICB9XG4gICAgXG5cbn0iLCJpbXBvcnQgeyBVbml0eUVuZ2luZSB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7IEdhbWVPYmplY3RQb29sIH0gZnJvbSBcIi4uL2NvbW1vbi9HYW1lT2JqZWN0UG9vbFwiO1xuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gXCIuLi9jb21tb24vUmVzTWFuYWdlclwiO1xuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlU2NlbmV7XG5cbiAgICBwcml2YXRlIHByZWxvYWRGYWlyeUdVSVBhY2thZ2U6TWFwPHN0cmluZyxzdHJpbmc+O1xuICAgIHByaXZhdGUgcHJlbG9hZFByZWZhYjpNYXA8c3RyaW5nLG51bWJlcj47XG4gICAgcHJpdmF0ZSBzY2VuZUluc3RhbmNlOlVuaXR5RW5naW5lLlJlc291cmNlTWFuYWdlbWVudC5SZXNvdXJjZVByb3ZpZGVycy5TY2VuZUluc3RhbmNlXG5cbiAgICBwdWJsaWMgZmluaXNoQ291bnQgPSAwO1xuICAgIHB1YmxpYyB0b3RhbENvdW50ID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKCl7XG5cbiAgICAgICAgdGhpcy5wcmVsb2FkRmFpcnlHVUlQYWNrYWdlID0gbmV3IE1hcDxzdHJpbmcsc3RyaW5nPigpO1xuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIgPSBuZXcgTWFwPHN0cmluZyxudW1iZXI+KCk7XG4gICAgICAgIHRoaXMuZmluaXNoQ291bnQgPSAwO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRQcmVsb2FkRmFpcnlHVUlQYWNrYWdlKGFkZHJlc3M6c3RyaW5nLCBwYWNrYWdlTmFtZTpzdHJpbmcpe1xuICAgICAgICB0aGlzLnByZWxvYWRGYWlyeUdVSVBhY2thZ2Uuc2V0KGFkZHJlc3MscGFja2FnZU5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZGRQcmVsb2FkUHJlZmFiKGFkZHJlc3M6c3RyaW5nLCBpbnN0Q291bnQpe1xuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIuc2V0KGFkZHJlc3MsIGluc3RDb3VudCk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFNjZW5lSW5zdGFuY2Uoc2NlbmVJbnN0YW5jZTpVbml0eUVuZ2luZS5SZXNvdXJjZU1hbmFnZW1lbnQuUmVzb3VyY2VQcm92aWRlcnMuU2NlbmVJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMuc2NlbmVJbnN0YW5jZSA9IHNjZW5lSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IG9uRW50ZXIoKTtcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25Db21wbGV0ZSgpO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkxlYXZlKCk7XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZEFzc2V0c0FzeW5jKCl7XG5cbiAgICAgICAgbGV0IGZndWlQa2dDb3VudCA9IHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5zaXplO1xuICAgICAgICBsZXQgcHJlZmFiQ291bnQgPSB0aGlzLnByZWxvYWRQcmVmYWIuc2l6ZTtcblxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSBmZ3VpUGtnQ291bnQgKyBwcmVmYWJDb3VudDtcblxuXG4gICAgICAgIGxldCBwcmVtaXNlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgbGV0IHByZW1pc2UgPSBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRGYWlyeUdVSVBhY2thZ2Uoa2V5LCB2YWx1ZSwoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuZmluaXNoQ291bnQgKys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZW1pc2VzLnB1c2gocHJlbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucHJlbG9hZFByZWZhYi5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuICAgICAgICAgICAgbGV0IHByZW1pc2UgPSBHYW1lT2JqZWN0UG9vbC5JbnN0YW5jZShHYW1lT2JqZWN0UG9vbCkucHJlTG9hZEdhbWVPYmplY3RBc3luYyhrZXksIHZhbHVlLCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hDb3VudCsrO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHByZW1pc2VzLnB1c2gocHJlbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZW1pc2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25EZXN0cm95KCl7XG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5mb3JFYWNoKCh2YWx1ZSwga2V5KT0+e1xuXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRlc3Ryb3kgc2NlbmU6IFwiK2tleSk7XG5cbiAgICAgICAgICAgIFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikucmVsZWFzZUZhaXJ5R1VJUGFja2FnZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8v5riF55CG6LWE5rqQ57yT5a2YXG4gICAgICAgIEdhbWVPYmplY3RQb29sLkluc3RhbmNlKEdhbWVPYmplY3RQb29sKS5jbGVhbnVwKHRydWUpO1xuXG4gICAgICAgIC8v5Y246L295Zy65pmvXG4gICAgICAgIFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikudW5sb2FkU2NlbmUodGhpcy5zY2VuZUluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHJlbG9hZEZhaXJ5R1VJUGFja2FnZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnByZWxvYWRQcmVmYWIuY2xlYXIoKTtcbiAgICB9XG59IiwiZXhwb3J0ICBjbGFzcyBTY2VuZURlZntcblxuICAgIHB1YmxpYyBzdGF0aWMgTG9hZGluZ1NjZW5lOnN0cmluZyA9IFwiTG9hZGluZ1NjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBMYXVuY2hTY2VuZTpzdHJpbmcgPSBcIkxhdW5jaFNjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBIb21lU2NlbmU6c3RyaW5nID0gXCJIb21lU2NlbmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIExvZ2luU2NlbmU6c3RyaW5nID0gXCJMb2dpblNjZW5lXCI7XG4gICAgcHVibGljIHN0YXRpYyBQdmVTY2VuZTpzdHJpbmcgPSBcIlB2ZVNjZW5lXCI7XG59XG4iLCJpbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi9CYXNlU2NlbmVcIjtcclxuaW1wb3J0IHsgUHZlU2NlbmUgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvcHZlL3NjZW5lL1B2ZVNjZW5lXCI7XHJcbmltcG9ydCB7IEhvbWVTY2VuZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9ob21lL3NjZW5lL0hvbWVTY2VuZVwiO1xyXG5pbXBvcnQgeyBMb2dpblNjZW5lIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2xvZ2luL3NjZW5lL0xvZ2luU2NlbmVcIjtcclxuaW1wb3J0IHsgU2NlbmVEZWYgfSBmcm9tIFwiLi9TY2VuZURlZlwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgU2NlbmVGYWN0b3J5e1xyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVNjZW5lKHNjZW5lTmFtZTpzdHJpbmcpOkJhc2VTY2VuZXtcclxuXHJcbiAgICAgICAgbGV0IHNjZW5lOkJhc2VTY2VuZSA9IG51bGw7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoc2NlbmVOYW1lKXtcclxuICAgICAgICAgICAgY2FzZSBTY2VuZURlZi5Mb2dpblNjZW5lOlxyXG4gICAgICAgICAgICAgICAgc2NlbmUgPSBuZXcgTG9naW5TY2VuZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgU2NlbmVEZWYuSG9tZVNjZW5lOlxyXG4gICAgICAgICAgICAgICAgc2NlbmUgPSBuZXcgSG9tZVNjZW5lKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY2VuZURlZi5QdmVTY2VuZTpcclxuICAgICAgICAgICAgICAgIHNjZW5lID0gbmV3IFB2ZVNjZW5lKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzY2VuZTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vZ2FtZS9ldmVudC9VSU1lc3NhZ2VcIjtcbmltcG9ydCB7IFVJTWVzc2FnZU1hbmdlciB9IGZyb20gXCIuLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tIFwiLi4vY29tbW9uL1Jlc01hbmFnZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vdWkvVUlNYW5hZ2VyXCI7XG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi9CYXNlU2NlbmVcIjtcbmltcG9ydCB7IFNjZW5lRmFjdG9yeSB9IGZyb20gXCIuL1NjZW5lRmFjdG9yeVwiO1xuXG5cblxuXG5leHBvcnQgY2xhc3MgU2NlbmVNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFNjZW5lTWFuYWdlcj57XG5cbiAgICBwcml2YXRlIGN1cnJlbnRTY2VuZTpCYXNlU2NlbmU7XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBsb2FkU2NlbmUoc2NlbmU6c3RyaW5nKXtcbiAgICAgICAgXG4gICAgICAgIHRyeXtcblxuICAgICAgICAgICAgLy/miZPlvIBMb2FkaW5n55WM6Z2iXG4gICAgICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuTG9hZGluZyhjb21tb25VSS5QYWNrYWdlTmFtZSwgY29tbW9uVUkuVUlMb2FkaW5nUGFnZSk7XG5cbiAgICAgICAgICAgIC8v5riF55CG5pen5Zy65pmvXG4gICAgICAgICAgICBpZih0aGlzLmN1cnJlbnRTY2VuZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25MZWF2ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL+W8gOWni+WKoOi9veWcuuaZr1xuICAgICAgICAgICAgbGV0IHNjZW5lSW5zdGFuY2UgPSBhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRTY2VuZShzY2VuZSk7XG5cbiAgICAgICAgICAgIC8v5byA5aeL5Yqg6L296L+b5YWl5Zy65pmv55qE6LWE5rqQXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9ICBTY2VuZUZhY3RvcnkuY3JlYXRlU2NlbmUoc2NlbmUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuc2V0U2NlbmVJbnN0YW5jZShzY2VuZUluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRW50ZXIoKTtcblxuICAgICAgICAgICAgLy/orr7nva7lvZPliY3lnLrmma/liqDovb3ov5vluqZUaW1lclxuICAgICAgICAgICAgbGV0IHByb2dyZXNzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xuXG4gICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gdGhpcy5jdXJyZW50U2NlbmUuZmluaXNoQ291bnQvdGhpcy5jdXJyZW50U2NlbmUudG90YWxDb3VudDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByb2dyZXNzOlwiK3Byb2dyZXNzICsgXCIgPSBcIit0aGlzLmN1cnJlbnRTY2VuZS5maW5pc2hDb3VudCArIFwiID0gXCIrdGhpcy5jdXJyZW50U2NlbmUudG90YWxDb3VudCk7XG5cbiAgICAgICAgICAgICAgICBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKS5icm9hZGNhc3QoXG4gICAgICAgICAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0NFTkVfUFJPR1JFU1MsXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKjEwMCk7XG5cbiAgICAgICAgICAgIH0sIDEwMCk7XG5cbiAgICAgICAgICAgIC8v5Yqg6L296LWE5rqQXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnRTY2VuZS5sb2FkQXNzZXRzQXN5bmMoKTtcblxuICAgICAgICAgICAgLy/liqDovb3lrozmiJBcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocHJvZ3Jlc3NJbnRlcnZhbClcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uQ29tcGxldGUoKVxuICAgICAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikuY2xvc2VMb2FkaW5nKGNvbW1vblVJLlVJTG9hZGluZ1BhZ2UpO1xuXG4gICAgICAgIH1jYXRjaChleCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvYWQgc2NlbmUgZXhjZXA6XCIrZXgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH1cblxuXG5cbiAgICBcbn0iLCJcclxuXHJcblxyXG5leHBvcnQgZW51bSBVSVR5cGVEZWZ7XHJcbiAgICBVbmtvd24gPSAwLFxyXG4gICAgUGFnZSA9IDEsXHJcbiAgICBXaW5kb3c9MixcclxuICAgIFdpZGdldCA9IDMsXHJcbiAgICBMb2FkaW5nID00XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxheWVyRGVme1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgQmFja2dyb3VuZDpudW1iZXIgPSAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBQYWdlOm51bWJlciA9IDEwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIE5vcm1hbFdpbmRvdzpudW1iZXIgPSAyMDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBUb3BXaW5kb3c6bnVtYmVyID0gMzAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgV2lkZ2V0Om51bWJlciA9IDQwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIExvYWRpbmc6bnVtYmVyID0gNTAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgVW5rb3duOm51bWJlciA9IDk5OTk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyAgZ2V0RGVmYXVsdExheWVyKHR5cGU6VUlUeXBlRGVmKTpudW1iZXJ7XHJcblxyXG4gICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuTG9hZGluZzogcmV0dXJuIHRoaXMuTG9hZGluZztcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuV2lkZ2V0OiByZXR1cm4gdGhpcy5XaWRnZXQ7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLldpbmRvdzogcmV0dXJuIHRoaXMuTm9ybWFsV2luZG93O1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5QYWdlOiByZXR1cm4gdGhpcy5QYWdlO1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5Vbmtvd246IHJldHVybiB0aGlzLlVua293bjtcclxuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHRoaXMuVW5rb3duOyBcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlDb21EZWZze1xyXG4gICAgcHVibGljIHN0YXRpYyBCYWNrQnRuID0gXCJiYWNrX2J0blwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBXaW5kb3dDbG9zZUJ0biA9IFwid2luX2Nsb3NlX2J0blwiO1xyXG59XHJcblxyXG5cclxuXHJcbiIsIlxyXG5pbXBvcnQgeyBVSUxvZ2luUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSUxvZ2luUGFnZVwiO1xyXG5pbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSUhvbWVQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlIb21lUGFnZVwiO1xyXG5pbXBvcnQgeyBVSUxvYWRpbmcgfSBmcm9tIFwiLi9VSUxpYi9VSUxvYWRpbmdcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IGhvbWVVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2hvbWVcIjtcclxuaW1wb3J0IHsgVUlNc2dCb3ggfSBmcm9tIFwiLi9VSUxpYi9VSU1zZ0JveFwiO1xyXG5pbXBvcnQgeyBVSVNlbFNlcnZlcldpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9sb2dpbi91aS9VSVNlbFNlcnZlcldpblwiO1xyXG5pbXBvcnQgeyBVSVNob3BQYWdlIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlTaG9wUGFnZVwiO1xyXG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcclxuaW1wb3J0IHsgVUlTdG9yeVdpbiB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9zdG9yeS9VSVN0b3J5V2luXCI7XHJcblxyXG5cclxuXHJcbmNvbnN0IENTID0gcmVxdWlyZSgnY3NoYXJwJyk7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJRmFjdG9yeXtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHVpQ2FjaGU6TWFwPHN0cmluZyxVSVBhbmVsPiA9IG5ldyBNYXA8c3RyaW5nLFVJUGFuZWw+KCk7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBjcmVhdGVVSShwa2c6c3RyaW5nLCBuYW1lOnN0cmluZyl7XHJcbiAgICAgICAgY29uc29sZS5sb2coYGNyZWF0ZSBVSTogJHtwa2d9OiR7bmFtZX1gKVxyXG4gICAgICAgIGxldCBjb21wID0gQ1MuRmFpcnlHVUkuVUlQYWNrYWdlLkNyZWF0ZU9iamVjdChwa2csIG5hbWUpLmFzQ29tXHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHVpOlVJUGFuZWwgPSB0aGlzLnVpQ2FjaGUuZ2V0KG5hbWUpO1xyXG5cclxuICAgICAgICBpZighdWkpe1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgLy9jb21tb25cclxuICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuVUlVSU5vdGljZVdpbjpcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSU1zZ0JveCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBjb21tb25VSS5VSUxvYWRpbmdQYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy9sb2dpblxyXG4gICAgICAgICAgICAgICAgY2FzZSBsb2dpblVJLlVJTG9naW5QYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJTG9naW5QYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuVUlTZWxTZXJ2ZXJXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlTZWxTZXJ2ZXJXaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvL2hvbWVcclxuICAgICAgICAgICAgICAgIGNhc2UgaG9tZVVJLlVJSG9tZVBhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlIb21lUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBob21lVUkuVUlTaG9wUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVNob3BQYWdlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcnlcclxuICAgICAgICAgICAgICAgIGNhc2Ugc3RvcnlVSS5VSVN0b3J5V2luOlxyXG4gICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJU3RvcnlXaW4oKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy51aUNhY2hlLnNldChuYW1lLCB1aSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHVpIT1udWxsKXtcclxuICAgICAgICAgICAgdWkuZnVpID0gY29tcDtcclxuICAgICAgICAgICAgdWkubmFtZSA9IG5hbWU7XHJcblxyXG4gICAgICAgICAgICAvL+e7keWumkZhaXJ5R1VJ5o6n5Lu2XHJcbiAgICAgICAgICAgIHVpLmJpbmRBbGwodWkpO1xyXG4gICAgICAgICAgICB1aS5hd2FrZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBub3QgY3JlYXRlIHVpOiAke3BrZ30tJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuLi9VSVBhbmVsXCI7XHJcbmltcG9ydCB7IFVJVHlwZURlZiB9IGZyb20gXCIuLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZU1hbmdlciB9IGZyb20gXCIuLi8uLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2dhbWUvZXZlbnQvVUlNZXNzYWdlXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyAgVUlMb2FkaW5nIGV4dGVuZHMgVUlQYW5lbHtcclxuXHJcblxyXG4gICAgQGJpbmRlcihcImxvYWRpbmdfcHJlZ3Jlc3NcIilcclxuICAgIHB1YmxpYyBwcm9ncmVzc0xvYWRpbmc6IEZhaXJ5R1VJLkdQcm9ncmVzc0JhcjtcclxuXHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6IHZvaWQge1xyXG4gICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuTG9hZGluZztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKGFyZyk7XHJcblxyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NMb2FkaW5nLnZhbHVlID0gMDtcclxuICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgVUlNZXNzYWdlTWFuZ2VyLkluc3RhbmNlKFVJTWVzc2FnZU1hbmdlcikuYWRkTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0NFTkVfUFJPR1JFU1MsXHJcbiAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgIChwcm9ncmVzczpudW1iZXIpPT57XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2dyZXNzTG9hZGluZy5Ud2VlblZhbHVlKHByb2dyZXNzLCAwLjEpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIFVJTWVzc2FnZU1hbmdlci5JbnN0YW5jZShVSU1lc3NhZ2VNYW5nZXIpLnJlbW92ZUxpc3RlbmVyQnlDb2RlKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vVUlXaW5kb3dcIjtcclxuXHJcbi8vIOmAmueUqOW8ueeql1xyXG5leHBvcnQgY2xhc3MgVUlNc2dCb3hBcmd7XHJcbiAgICBwdWJsaWMgdGl0bGU6c3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBjb250ZW50OnN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgYnRuVGV4dDpzdHJpbmcgPSBcIlwiOy8vXCLnoa7lrpp85Y+W5raIfOWFs+mXrVwiXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlNc2dCb3ggZXh0ZW5kcyBVSVdpbmRvd3tcclxuXHJcbiAgICBwcml2YXRlIG1fYXJnOlVJTXNnQm94QXJnO1xyXG5cclxuICAgIEBiaW5kZXIoXCJtc2dUeHRcIilcclxuICAgIHByaXZhdGUgbV90eHQ6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm9rQnRuXCIpXHJcbiAgICBwcml2YXRlIG1fb2tCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJjYW5jZWxCdG5cIilcclxuICAgIHByaXZhdGUgbV9jYW5jZWxCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEFsbCh0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4oYXJnKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICBcclxuICAgIH1cclxuXHJcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi4vY29tbW9uL1NpbmdsZXRvbic7XHJcbmltcG9ydCB7IFVJTG9hZGluZyB9IGZyb20gJy4vVUlMaWIvVUlMb2FkaW5nJztcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tICcuL1VJV2luZG93JztcclxuaW1wb3J0IHsgVUlXaWRnZSB9IGZyb20gJy4vVUlXaWRnZSc7XHJcbmltcG9ydCB7IFVJUGFuZWwgfSBmcm9tICcuL1VJUGFuZWwnO1xyXG5pbXBvcnQgeyBVSUZhY3RvcnkgfSBmcm9tICcuL1VJRmFjdG9yeSc7XHJcbmltcG9ydCB7IFNjZW5lRGVmIH0gZnJvbSAnLi4vc2NlbmUvU2NlbmVEZWYnO1xyXG5pbXBvcnQgeyBob21lVUkgfSBmcm9tICcuLi8uLi9kYXRhL3VpL2hvbWUnO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSVBhZ2VUcmFja3tcclxuICAgIHB1YmxpYyBwa2c6c3RyaW5nO1xyXG4gICAgcHVibGljIG5hbWU6c3RyaW5nO1xyXG4gICAgcHVibGljIGFyZzphbnk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFVJTWFuYWdlcj57XHJcblxyXG4gICAgcHJpdmF0ZSAgbV9wYWdlVHJhY2tTdGFjazpBcnJheTxVSVBhZ2VUcmFjaz47XHJcbiAgICBwcml2YXRlIG1fY3VycmVudFBhZ2U6VUlQYWdlVHJhY2s7XHJcblxyXG4gICAgcHJpdmF0ZSBtX2xpc3RMb2FkZWRQYW5lbDpBcnJheTxVSVBhbmVsPjtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcGFnZVRyYWNrU3RhY2sgPSBuZXcgQXJyYXk8VUlQYWdlVHJhY2s+KCk7XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbCA9IG5ldyBBcnJheTxVSVBhbmVsPigpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNsb3NlQWxsTG9hZGVkUGFuZWwoKTp2b2lke1xyXG5cclxuICAgICAgICBmb3IobGV0IGk9IHRoaXMubV9saXN0TG9hZGVkUGFuZWwubGVuZ3RoLTE7IGk+PTA7IGktLSl7XHJcbiAgICAgICAgICAgIGxldCBwYW5lbCA9IHRoaXMubV9saXN0TG9hZGVkUGFuZWxbaV07XHJcblxyXG4gICAgICAgICAgICBpZihwYW5lbC5pc09wZW4pe1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuY2xvc2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcGFuZWwuZGlzcG9zZSgpOyAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubV9saXN0TG9hZGVkUGFuZWwubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYW4oKTp2b2lke1xyXG5cclxuICAgICAgICB0aGlzLmNsb3NlQWxsTG9hZGVkUGFuZWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvcGVuKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTphbnkgPSB0aGlzLmdldFVJKG5hbWUpO1xyXG5cclxuICAgICAgICBpZih1aSA9PSBudWxsKXtcclxuICAgICAgICAgICAgdWkgPSBVSUZhY3RvcnkuY3JlYXRlVUkocGtnLCBuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5wdXNoKHVpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICB1aS5vcGVuKGFyZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBnZXRVSShuYW1lOnN0cmluZyk6VUlQYW5lbHtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBwYW5lbCBvZiB0aGlzLm1fbGlzdExvYWRlZFBhbmVsKSB7XHJcbiAgICAgICAgICAgIGlmKHBhbmVsLm5hbWUgPT0gbmFtZSl7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJmaW5kIHBhbmVsIGluIGNhY2hlOiBcIituYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy/miZPlvIDlnLrmma/pobXpnaIs5q2k6aG16Z2i5LiN6K6h5YWl6aG16Z2i5qCILOaXoOi/lOWbnuS4iuS4gOmdouaMiemSrlxyXG4gICAgcHVibGljIG9wZW5QYWdlSW5TY2VuZShwa2c6c3RyaW5nLCBwYWdlOnN0cmluZywgYXJnOmFueSl7XHJcbiAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcihwa2csIHBhZ2UsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09VUlMb2FkaW5nXHJcbiAgICAvL+aJk+W8gExvYWRpbmfnlYzpnaJcclxuICAgIHB1YmxpYyBvcGVuTG9hZGluZyhwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnPzphbnkpe1xyXG5cclxuICAgICAgICB0aGlzLm9wZW5QYWdlSW5TY2VuZShwa2csIG5hbWUsIGFyZyk7XHJcblxyXG4gICAgfVxyXG4gICAgLy/lhbPpl61Mb2FkaW5n55WM6Z2iXHJcbiAgICBwdWJsaWMgY2xvc2VMb2FkaW5nKG5hbWU6c3RyaW5nLCBhcmc/OmFueSk6dm9pZHtcclxuICAgICAgICBsZXQgdWk6VUlMb2FkaW5nID0gdGhpcy5nZXRVSShuYW1lKSBhcyBVSUxvYWRpbmc7XHJcbiAgICAgICAgaWYodWkgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmNsb3NlKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1QYWdlXHJcbiAgICBwcml2YXRlIG9wZW5QYWdlV29ya2VyKHBrZzpzdHJpbmcsIHBhZ2U6c3RyaW5nLCBhcmc6YW55KXtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UgPSBuZXcgVUlQYWdlVHJhY2soKTtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UucGtnID0gcGtnO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5uYW1lID0gcGFnZTtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UuYXJnID0gYXJnO1xyXG5cclxuICAgICAgICB0aGlzLmNsb3NlQWxsTG9hZGVkUGFuZWwoKTtcclxuXHJcbiAgICAgICAgdGhpcy5vcGVuKHBrZywgcGFnZSwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+aJk+W8gOmhtemdoiwg5Lya5YWz6Zet5LiK5LiA5Liq6aG16Z2i5LiK55qE5omA5pyJ56qX5Y+jLFdpZGlnZXTnrYlcclxuICAgIHB1YmxpYyBvcGVuUGFnZShwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnPzphbnkpe1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fY3VycmVudFBhZ2UgIT0gdW5kZWZpbmVkICYmIHRoaXMubV9jdXJyZW50UGFnZS5uYW1lIT1uYW1lKXtcclxuICAgICAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrLnB1c2godGhpcy5tX2N1cnJlbnRQYWdlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMub3BlblBhZ2VXb3JrZXIocGtnLCBuYW1lLCBhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v6L+U5Zue5LiK5LiA5Liq6aG16Z2iXHJcbiAgICBwdWJsaWMgZ29CYWNrUGFnZSgpOnZvaWR7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgbGV0IHRyYWNrID0gdGhpcy5tX3BhZ2VUcmFja1N0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5QYWdlV29ya2VyKHRyYWNrLnBrZyAsdHJhY2submFtZSwgdHJhY2suYXJnKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5lbnRlck1haW5QYWdlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcblxyXG4gICAgLy/lm57liLDkuLvln45cclxuICAgIHB1YmxpYyBlbnRlck1haW5QYWdlKCk6dm9pZHtcclxuXHJcbiAgICAgICAgdGhpcy5tX3BhZ2VUcmFja1N0YWNrLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5vcGVuUGFnZUluU2NlbmUoaG9tZVVJLlBhY2thZ2VOYW1lICxob21lVUkuVUlIb21lUGFnZSxudWxsKVxyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVVJV2luZG93XHJcbiAgICAvL+aJk+W8gOeql+WPo1xyXG4gICAgcHVibGljIG9wZW5XaW5kb3cocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZzphbnkpOlVJV2luZG93e1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaW5kb3cgPSB0aGlzLm9wZW4ocGtnLCBuYW1lLCBhcmcpO1xyXG5cclxuICAgICAgICByZXR1cm4gdWk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/lhbPpl63nqpflj6NcclxuICAgIHB1YmxpYyBjbG9zZVdpbmRvdyhuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpbmRvdyA9IHRoaXMuZ2V0VUkobmFtZSkgYXMgVUlXaW5kb3c7XHJcbiAgICAgICAgaWYodWkgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmNsb3NlKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVVJV2lkZ2V0XHJcbiAgICAvL+aJk+W8gFdpZGlnZXRcclxuICAgIHB1YmxpYyBvcGVuV2lkZ2V0KHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc6YW55KTpVSVdpZGdle1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaWRnZSA9IHRoaXMub3Blbihwa2csIG5hbWUsIGFyZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB1aTtcclxuICAgIH1cclxuXHJcbiAgICAvL3XlhbPpl61XaWRpZ2V0XHJcbiAgICBwdWJsaWMgY2xvc2VXaWRnZXQobmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaWRnZSA9IHRoaXMuZ2V0VUkobmFtZSkgYXMgVUlXaWRnZTtcclxuICAgICAgICBpZih1aSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmNsb3NlKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYsIFVJQ29tRGVmcyB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IFVJTWFuYWdlciB9IGZyb20gXCIuL1VJTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVSVBhZ2UgZXh0ZW5kcyBVSVBhbmVse1xyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5QYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbV9idG5Hb0JhY2s6RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubV9idG5Hb0JhY2sgPSB0aGlzLmZ1aS5HZXRDaGlsZChVSUNvbURlZnMuQmFja0J0bik7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9idG5Hb0JhY2shPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5Hb0JhY2sub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMub25CdG5Hb0JhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKHZvOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4odm8pO1xyXG5cclxuICAgICAgICBcclxuICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgb25CdG5Hb0JhY2soKXtcclxuICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5nb0JhY2tQYWdlKCk7XHJcbiAgICB9XHJcblxyXG59ICIsImltcG9ydCB7IFVJVHlwZURlZiwgVUlMYXllckRlZiB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFVJUGFuZWwge1xyXG5cclxuICAgIHB1YmxpYyBmdWk6YW55OyAgLy9GYWlyeUdVSSDlr7nosaFcclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfbmFtZTpzdHJpbmc7XHJcbiAgICBwdWJsaWMgc2V0IG5hbWUodjpzdHJpbmcpe1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSB2O1xyXG4gICAgfVxyXG4gICAgcHVibGljIGdldCBuYW1lKCk6c3RyaW5ne1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuVW5rb3duO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIG1fbGF5ZXI6VUlMYXllckRlZiA9IFVJTGF5ZXJEZWYuVW5rb3duO1xyXG4gICAgcHVibGljIGdldCBsYXllcigpIDogVUlMYXllckRlZiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubV9sYXllcjsgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgc2V0IGxheWVyKHYgOiBVSUxheWVyRGVmKSB7XHJcbiAgICAgICAgdGhpcy5tX2xheWVyID0gdjtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcHVibGljICBnZXQgaXNPcGVuKCkgOiBib29sZWFue1xyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5mdWkudmlzaWJsZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25Bd2FrZSgpOnZvaWQ7XHJcbiAgICBwdWJsaWMgb25VcGRhdGUoKTp2b2lke31cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKHZvOmFueSk6dm9pZHtcclxuICAgICAgICB0aGlzLmxheWVyID0gVUlMYXllckRlZi5nZXREZWZhdWx0TGF5ZXIodGhpcy51aVR5cGUpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHt9XHJcblxyXG4gICAgcHVibGljIGF3YWtlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLm9uQXdha2UoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy/nu5HlrppGYWlyeUdVSeWFg+S7tlxyXG4gICAgcHVibGljIGJpbmRBbGwodGFyZ2V0OmFueSk6dm9pZHtcclxuICAgICAgICBmb3IobGV0IGsgaW4gdGFyZ2V0W1wiYmluZGVyc1wiXSl7XHJcbiAgICAgICAgICAgIGxldCBmZ3VpTmFtZSA9IHRoaXNbXCJiaW5kZXJzXCJdW2tdO1xyXG4gICAgICAgICAgICB0aGlzW2tdID0gdGhpcy5mdWkuR2V0Q2hpbGQoZmd1aU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9wZW4oYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLm9uT3BlbihhcmcpO1xyXG5cclxuICAgICAgICBGYWlyeUdVSS5HUm9vdC5pbnN0LkFkZENoaWxkKHRoaXMuZnVpKTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbG9zZShhcmc6YW55ID0gbnVsbCk6dm9pZHtcclxuXHJcblxyXG4gICAgICAgIHRoaXMub25DbG9zZShhcmcpO1xyXG5cclxuICAgICAgICBGYWlyeUdVSS5HUm9vdC5pbnN0LlJlbW92ZUNoaWxkKHRoaXMuZnVpKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRpc3Bvc2UoKTp2b2lke1xyXG4gICAgICAgIHRoaXMuZnVpLkRpc3Bvc2UoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IFVJUGFuZWwgfSBmcm9tIFwiLi9VSVBhbmVsXCI7XHJcbmltcG9ydCB7IFVJVHlwZURlZiwgVUlDb21EZWZzIH0gZnJvbSBcIi4vVUlEZWZpbmVcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcblxyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzICBVSVdpbmRvdyBleHRlbmRzIFVJUGFuZWx7XHJcbiAgIFxyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5XaW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBtX2J0bkNsb3NlOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubV9idG5DbG9zZSA9IHRoaXMuZnVpLkdldENoaWxkKFVJQ29tRGVmcy5XaW5kb3dDbG9zZUJ0bik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4oYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4oYXJnKTtcclxuXHJcbiAgICAgICAgdGhpcy5mdWkueCA9IEZhaXJ5R1VJLkdSb290Lmluc3Qud2lkdGgvMiAtIHRoaXMuZnVpLndpZHRoLzI7XHJcbiAgICAgICAgdGhpcy5mdWkueSA9IEZhaXJ5R1VJLkdSb290Lmluc3QuaGVpZ2h0LzIgLSB0aGlzLmZ1aS5oZWlnaHQvMjtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2J0bkNsb3NlIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm1fYnRuQ2xvc2Uub25DbGljay5BZGQodGhpcy5vbkJ0bkNsb3NlKTtcclxuICAgICAgICB9XHJcbiAgICBcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fYnRuQ2xvc2UhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5DbG9zZS5vbkNsaWNrLlJlbW92ZSh0aGlzLm9uQnRuQ2xvc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQnRuQ2xvc2UoKXtcclxuICAgICAgICB0aGlzLmNsb3NlKDApO1xyXG4gICAgfVxyXG5cclxufSIsIlxyXG5cclxuZXhwb3J0IGNsYXNzIFRpbWVVdGlse1xyXG5cclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBwcmVmaXhJbnRlZ2VyKG51bSwgbGVuZ3RoKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIHJldHVybiAgKEFycmF5KGxlbmd0aCkuam9pbignMCcpICsgbnVtKS5zbGljZSgtbGVuZ3RoKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDA6MDA6MDBcIuagvOW8j1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRUaW1lU3RyaW5nMSh0aW1lSW50IDogbnVtYmVyKTpzdHJpbmcge1xyXG5cclxuICAgICAgICBpZih0aW1lSW50IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMDowMDowMFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG5cclxuICAgICAgICAgICAgbGV0IGhvdXI6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50IC8gKDYwICogNjApKTtcclxuICAgICAgICAgICAgbGV0IGhvdXJzdHIgPSB0aGlzLnByZWZpeEludGVnZXIoaG91ciwgMik7XHJcblxyXG4gICAgICAgICAgICBsZXQgbWlubnV0ZTpudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVJbnQvIDYwKSAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihtaW5udXRlLCAyKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBzZWNvbmQ6bnVtYmVyID0gdGltZUludCAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgc2Vjb25kc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihzZWNvbmQsMik7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gYCR7aG91cnN0cn06JHttaW51dGVzdHJ9OiR7c2Vjb25kc3RyfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIC8v5bCG5LiA5Liq5pe26Ze05pWw6L2s5o2i5oiQXCIwMDowMFwi5qC85byPXHJcbiAgICBwdWJsaWMgc3RhdGljIGdldFRpbWVTdHJpbmcodGltZUludDpudW1iZXIpOnN0cmluZ3tcclxuXHJcbiAgICAgICAgaWYodGltZUludCA8PSAwKXtcclxuICAgICAgICAgICAgcmV0dXJuIFwiMDA6MDA6MDBcIjtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgbGV0IGhvdXI6bnVtYmVyID0gTWF0aC5mbG9vcih0aW1lSW50IC8gKDYwICogNjApKTtcclxuICAgICAgICAgICAgbGV0IGhvdXJzdHIgPSB0aGlzLnByZWZpeEludGVnZXIoaG91ciwgMik7XHJcblxyXG4gICAgICAgICAgICBsZXQgbWlubnV0ZTpudW1iZXIgPSBNYXRoLmZsb29yKHRpbWVJbnQvIDYwKSAlIDYwO1xyXG4gICAgICAgICAgICBsZXQgbWludXRlc3RyOnN0cmluZyA9IHRoaXMucHJlZml4SW50ZWdlcihtaW5udXRlLCAyKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBgJHtob3Vyc3RyfToke21pbnV0ZXN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDBcIuWIhuagvOW8j1xyXG4gICAgcHVibGljIHN0YXRpYyBnZXRUaW1lTWludXRlU3RyaW5nKHRpbWVJbnQ6bnVtYmVyKTpzdHJpbmd7XHJcblxyXG4gICAgICAgIGlmKHRpbWVJbnQgPD0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiBcIjAwOjAwOjAwXCI7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBtaW5udXRlOm51bWJlciA9IE1hdGguZmxvb3IodGltZUludC8gNjApICUgNjA7XHJcbiAgICAgICAgICAgIGxldCBtaW51dGVzdHI6c3RyaW5nID0gdGhpcy5wcmVmaXhJbnRlZ2VyKG1pbm51dGUsIDIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAke21pbnV0ZXN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+WwhuS4gOS4quaXtumXtOaVsOi9rOaNouaIkFwiMDDigJznp5LmoLzlvI9cclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0VGltZVNlY29uZFN0cmluZyh0aW1lSW50Om51bWJlcik6c3RyaW5ne1xyXG5cclxuICAgICAgICBpZih0aW1lSW50IDw9IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gXCIwMDowMDowMFwiO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBsZXQgc2Vjb25kOm51bWJlciA9IHRpbWVJbnQgJSA2MDtcclxuICAgICAgICAgICAgbGV0IHNlY29uZHN0cjpzdHJpbmcgPSB0aGlzLnByZWZpeEludGVnZXIoc2Vjb25kLDIpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGAke3NlY29uZHN0cn1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvL+iOt+WPluacrOaciDHlj7fmmK/mmJ/mnJ/lh6BcclxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0V2Vla09mTW9udGhGaXJzdERheSh0aW1lOm51bWJlcik6bnVtYmVye1xyXG5cclxuICAgICAgICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpO1xyXG4gICAgICAgIGRhdGUuc2V0RGF0ZSgxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/liKTmlq3mmK/lkKbkuLrpl7DlubRcclxuICAgIHB1YmxpYyBzdGF0aWMgaXNMZWFwWWVhcih5ZWFyOm51bWJlcilcclxuICAgIHtcclxuICAgICAgICBpZiAoICh5ZWFyICUgNCA9PSAwICYmIHllYXIgJSAxMDAgIT0gMCkgfHwgKHllYXIgJSA0MDAgPT0gMCkgKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvL+avj+S4quaciOWvueW6lOeahOWkqeaVsFxyXG4gICAgc3RhdGljICBtb250aHM6QXJyYXk8bnVtYmVyPiA9IFszMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcclxuICAgIHByaXZhdGUgc3RhdGljIGdldE1vbnRoRGF5c18oeWVhcjpudW1iZXIsIG1vbnRoOm51bWJlcik6bnVtYmVye1xyXG4gICAgICAgIGlmKG1vbnRoID09IDIpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmlzTGVhcFllYXIoeWVhcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjk7XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMjg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhzW21vbnRoXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZXRNb250aERheXModGltZTpudW1iZXIpOm51bWJlciB7XHJcblxyXG4gICAgICAgIGxldCB0ID0gbmV3IERhdGUodGltZSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldE1vbnRoRGF5c18odC5nZXRGdWxsWWVhcigpLCB0LmdldE1vbnRoKCkpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIHNsZWVwKG1zOm51bWJlcil7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PntcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgnJyk7XHJcbiAgICAgICAgICAgIH0sIG1zKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyB0ZXN0KCk6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IHQxOnN0cmluZyA9IHRoaXMuZ2V0VGltZVN0cmluZzEoNTAwMCk7XHJcbiAgICAgICAgY29uc29sZS5sb2codDEpO1xyXG4gICAgICAgIFxyXG5cclxuICAgICAgICBsZXQgdDI6c3RyaW5nID0gdGhpcy5nZXRUaW1lU3RyaW5nKDUwMDApO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHQyKTtcclxuXHJcbiAgICAgICAgbGV0IHQzOnN0cmluZyA9IHRoaXMuZ2V0VGltZU1pbnV0ZVN0cmluZyg1MDAwKTtcclxuICAgICAgICBjb25zb2xlLmxvZyh0Myk7XHJcblxyXG4gICAgICAgIGxldCB0NDpzdHJpbmcgPSB0aGlzLmdldFRpbWVTZWNvbmRTdHJpbmcoNTAwMCk7XHJcbiAgICAgICAgY29uc29sZS5sb2codDQpO1xyXG5cclxuICAgICAgICBsZXQgdGltZTpudW1iZXIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuXHJcbiAgICAgICAgbGV0IHQ1Om51bWJlciA9IHRoaXMuZ2V0V2Vla09mTW9udGhGaXJzdERheSh0aW1lKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImdldFdlZWtPZk1vbnRoRmlyc3REYXk6IFwiK3Q1ICsgXCIgLHRpbWU6XCIrdGltZSk7XHJcblxyXG4gICAgICAgIGxldCB0NjpudW1iZXIgPSB0aGlzLmdldE1vbnRoRGF5cyh0aW1lKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImdldE1vbnRoRGF5czogXCIrdDYpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL2dlbi9wYlwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL25ldC9TZXNzaW9uTWFuYWdlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dpbkFQSXtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGJlbmNobWFya1Rlc3QoKXtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBpPTE7IGk8MjtpKyspe1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gbmljZV90cy5DMkdTX1Rlc3QuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIG1zZy50ZXN0SUQgPSBpO1xyXG4gICAgICAgICAgICBtc2cudGVzdE5hbWUgPSBcImJlbmNobWFyayB0ZXN0XCI7XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgICAgICBPcGNvZGUuTVNHX0MyR1NfVGVzdCxcclxuICAgICAgICAgICAgICAgIG1zZ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICAgIGxldCB0ZXN0ICA9ICByZXNwb25zZSBhcyBuaWNlX3RzLkdTMkNfVGVzdDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb2RlOiBcIit0ZXN0LkVycm9yICtcIixtc2c6XCIrdGVzdC5NZXNzYWdlICtcIixyZXM6XCIrdGVzdC50ZXN0UmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2dpblJlYWxtU2VydmVyKGFjY291bnQ6c3RyaW5nLCBwYXNzd29yZDpzdHJpbmcpOlByb21pc2U8bmljZV90cy5SMkNfTG9naW4+e1xyXG5cclxuICAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJSX0xvZ2luLmNyZWF0ZSgpO1xyXG4gICAgICAgICBtc2cuQWNjb3VudCA9IGFjY291bnQ7XHJcbiAgICAgICAgIG1zZy5QYXNzd29yZCA9IHBhc3N3b3JkO1xyXG5cclxuICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgU2Vzc2lvbk1hbmFnZXIuSW5zdGFuY2UoU2Vzc2lvbk1hbmFnZXIpLnNlbmRSZWFsbU1zZyhcclxuICAgICAgICAgICAgT3Bjb2RlLk1TR19DMlJfTG9naW4sXHJcbiAgICAgICAgICAgIG1zZ1xyXG4gICAgICAgIClcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlIGFzIG5pY2VfdHMuUjJDX0xvZ2luO1xyXG4gICAgfVxyXG4gICAgXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2dpbkdhdGVTZXJ2ZXIoZ2F0ZUlkLCBnYXRlS2V5KTpQcm9taXNlPG5pY2VfdHMuRzJDX0xvZ2luR2F0ZT57XHJcblxyXG4gICAgICAgIGxldCBtc2cgPSBuaWNlX3RzLkMyR19Mb2dpbkdhdGUuY3JlYXRlKCk7XHJcbiAgICAgICAgbXNnLkdhdGVJZCA9IGdhdGVJZDtcclxuICAgICAgICBtc2cuS2V5ID0gZ2F0ZUtleTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuc2VuZEdhdGVNc2coXHJcbiAgICAgICAgICAgIE9wY29kZS5NU0dfQzJHX0xvZ2luR2F0ZSxcclxuICAgICAgICAgICAgbXNnXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlIGFzIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZTtcclxuICAgIH1cclxufSIsIlxuXG5cbmV4cG9ydCBjbGFzcyBVSU1lc3NhZ2V7XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgTVNHX1NFTEVDVF9TRVJWRVI6bnVtYmVyICA9IDEwMDA7XG4gICAgcHVibGljIHN0YXRpYyBNU0dfU0NFTkVfUFJPR1JFU1M6bnVtYmVyID0gMTAwMTtcbiAgICBcblxuXG59IiwiaW1wb3J0IHsgTWVzc2VuZ2VyIH0gZnJvbSBcIi4uLy4uL2ZyYW1ld29yay9jb21tb24vTWVzc2VuZ2VyXCI7XG5pbXBvcnQgeyBTaW5nbGV0b24gfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9TaW5nbGV0b25cIjtcblxuXG5leHBvcnQgY2xhc3MgVUlNZXNzYWdlTWFuZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFVJTWVzc2FnZU1hbmdlcj57XG5cbiAgICBwcml2YXRlIHVpTWVzc2FnZTpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XG5cblxuICAgIHB1YmxpYyBhZGRMaXN0ZW5lcihtc2dDb2RlOm51bWJlcixvYmo6YW55LCBsaXN0ZW5lcjpGdW5jdGlvbil7XG5cbiAgICAgICAgdGhpcy51aU1lc3NhZ2UuYWRkTGlzdGVuZXIobXNnQ29kZSwgb2JqLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLCBsaXN0ZW5lcjpGdW5jdGlvbil7XG4gICAgICAgIHRoaXMudWlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyKG1zZ0NvZGUsIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXJCeUNvZGUobXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnVpTWVzc2FnZS5yZW1vdmVMaXN0ZW5lckJ5VHlwZShtc2dDb2RlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY2xlYXJ1cCgpe1xuICAgICAgICB0aGlzLnVpTWVzc2FnZS5jbGVhcnVwKCk7XG4gICAgfVxuXG4gICAgcHVibGljIGJyb2FkY2FzdChtc2dDb2RlOm51bWJlcixwYXJhbXM6YW55KXtcblxuXG4gICAgICAgIHRoaXMudWlNZXNzYWdlLmJyb2FkY2FzdChtc2dDb2RlLCBwYXJhbXMpXG4gICAgfVxufSIsImltcG9ydCB7IGhvbWVVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2hvbWVcIjtcclxuaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmVcIjtcclxuaW1wb3J0IHsgVUlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVm9Ib21lIH0gZnJvbSBcIi4uL3ZvL1ZvSG9tZVwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBIb21lU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuXHJcbiAgICAgICAgdGhpcy5hZGRQcmVsb2FkRmFpcnlHVUlQYWNrYWdlKGhvbWVVSS5QYWNrYWdlQnl0ZXMsaG9tZVVJLlBhY2thZ2VOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Db21wbGV0ZSgpIHtcclxuXHJcbiAgICAgICAgbGV0IHZvOlZvSG9tZSA9IG5ldyBWb0hvbWUoKTtcclxuICAgICAgICB2by5uYW1lID0gXCJKdXN0aW5cIjtcclxuICAgICAgICB2by5ocCA9IDEyMDA7XHJcbiAgICAgICAgdm8ubXAgPSAzMzAwO1xyXG4gICAgICAgIHZvLm1vbmV5ID0gNjY2O1xyXG5cclxuICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuUGFnZUluU2NlbmUoXHJcbiAgICAgICAgICAgIGhvbWVVSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgaG9tZVVJLlVJSG9tZVBhZ2UsXHJcbiAgICAgICAgICAgIHZvKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25MZWF2ZSgpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IFVJTWFuYWdlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IGNvbW1vbiB9IGZyb20gXCJwcm90b2J1ZmpzXCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IGhvbWVVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2hvbWVcIjtcclxuaW1wb3J0IHsgVm9Ib21lIH0gZnJvbSBcIi4uL3ZvL1ZvSG9tZVwiO1xyXG5pbXBvcnQgeyBMb2dpbkFQSSB9IGZyb20gXCIuLi8uLi8uLi9hcGkvTG9naW5BUElcIjtcclxuaW1wb3J0IHsgR2FtZVNlc3Npb24gfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL25ldC9HYW1lU2Vzc2lvblwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3BiL2dlbi9wYlwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlIb21lUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiY2hhdEJ0blwiKVxyXG4gICAgcHVibGljIG1fY2hhdEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImJhZ0J0blwiKVxyXG4gICAgcHVibGljIG1fYmFnQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwic2hvcEJ0blwiKVxyXG4gICAgcHVibGljIG1fc2hvcEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImxldmVsQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9sZXZlbEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJuYW1lVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9uYW1lTGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJocFR4dFwiKVxyXG4gICAgcHVibGljIG1faHBMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm1wVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9tcExibDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwibW9uZXlUeHRcIilcclxuICAgIHB1YmxpYyBtX21vbmV5TGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX2NoYXRCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbmNoYXRCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fYmFnQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25iYWdCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fc2hvcEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvcEJ0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubV9sZXZlbEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9ubGV2ZWxCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHB1YmxpYyBvbk9wZW4odm86Vm9Ib21lKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uT3Blbih2byk7XHJcblxyXG4gICAgICAgIHRoaXMubV9uYW1lTGJsLnRleHQgPSB2by5uYW1lO1xyXG4gICAgICAgIHRoaXMubV9tcExibC50ZXh0ID0gdm8ubXAudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLm1faHBMYmwudGV4dCA9IHZvLmhwLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tX21vbmV5TGJsLnRleHQgPSB2by5tb25leS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBHYW1lU2Vzc2lvbi5JbnN0YW5jZShHYW1lU2Vzc2lvbikubGlzdGVuKE9wY29kZS5NU0dfR1MyQ19UZXN0LGZ1bmN0aW9uKG1zZzpuaWNlX3RzLkdTMkNfVGVzdCl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5pS25Yiw5pyN5Yqh5Zmo5LiL5Y+R55qE5raI5oGv44CC44CC44CC44CCXCIrbXNnLnRlc3RSZXNwb25zZSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25jaGF0QnRuKCl7XHJcblxyXG4gICAgICAgIFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgIGNvbW1vblVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICBjb21tb25VSS5VSVVJTm90aWNlV2luLFxyXG4gICAgICAgICAgICBudWxsKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uIGNoYXQuLi5cIik7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25iYWdCdG4oKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uIGJhZyAuLlwiKTtcclxuXHJcbiAgICAgICAgLy9iZW5jaG1hcmsgdGVzdFxyXG4gICAgICAgIExvZ2luQVBJLmJlbmNobWFya1Rlc3QoKTtcclxuXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25zaG9wQnRuKCl7XHJcbiAgICAgICAgXHJcbiAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikub3BlblBhZ2UoXHJcbiAgICAgICAgICAgIGhvbWVVSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgaG9tZVVJLlVJU2hvcFBhZ2UpO1xyXG4gICAgfVxyXG4gICAgcHVibGljIG9ubGV2ZWxCdG4oKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm9uIGxldmVsLi4uXCIpO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgVUlTaG9wUGFnZSBleHRlbmRzIFVJUGFnZXtcblxuXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XG5cbiAgICB9XG5cbiAgICBcbiAgICBwdWJsaWMgb25PcGVuKHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25PcGVuKHZvKTtcblxuICAgICAgICBcbiAgICB9XG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgfVxuXG59IiwiXG5cbmV4cG9ydCBjbGFzcyBWb0hvbWV7XG5cbiAgICBwdWJsaWMgbmFtZTpzdHJpbmc7XG4gICAgcHVibGljIGhwOm51bWJlcjtcbiAgICBwdWJsaWMgbXA6bnVtYmVyO1xuICAgIHB1YmxpYyBtb25leTpudW1iZXI7XG5cbn0iLCJcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xyXG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJTWFuYWdlclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgTG9naW5TY2VuZSBleHRlbmRzIEJhc2VTY2VuZXtcclxuXHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkVudGVyKCkge1xyXG5cclxuICAgICAgICAvL+a3u+WKoOmihOWKoOi9vei1hOa6kFxyXG4gICAgICAgdGhpcy5hZGRQcmVsb2FkRmFpcnlHVUlQYWNrYWdlKGxvZ2luVUkuUGFja2FnZUJ5dGVzLGxvZ2luVUkuUGFja2FnZU5hbWUpO1xyXG4gICAgICAgLy/mtYvor5VTdG9yeVxyXG4gICAgICAgdGhpcy5hZGRQcmVsb2FkRmFpcnlHVUlQYWNrYWdlKHN0b3J5VUkuUGFja2FnZUJ5dGVzLHN0b3J5VUkuUGFja2FnZU5hbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpLm9wZW5QYWdlSW5TY2VuZShcclxuICAgICAgICAgICAgbG9naW5VSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgbG9naW5VSS5VSUxvZ2luUGFnZSxcclxuICAgICAgICAgICAgbnVsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgXHJcblxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVBhZ2VcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL25ldC9TZXNzaW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBMb2dpbkFQSSB9IGZyb20gXCIuLi8uLi8uLi9hcGkvTG9naW5BUElcIjtcclxuaW1wb3J0IHsgVUlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IFZvU2VydmVyLCBWb1NlcnZlckl0ZW0gfSBmcm9tIFwiLi4vdm8vVm9TZXJ2ZXJcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlTWFuZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBTY2VuZU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWZcIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IG5pY2VfdHMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS9wYi9nZW4vcGJcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJTG9naW5QYWdlIGV4dGVuZHMgVUlQYWdle1xyXG5cclxuICAgIEBiaW5kZXIoXCJhY2NvdW50XCIpXHJcbiAgICBwdWJsaWMgbV9hY2NvdW50OkZhaXJ5R1VJLkdUZXh0RmllbGQ7XHJcbiAgICBAYmluZGVyKFwicGFzc3dvcmRcIilcclxuICAgIHB1YmxpYyBtX3Bhc3N3b3JkOkZhaXJ5R1VJLkdUZXh0RmllbGQ7XHJcblxyXG4gICAgQGJpbmRlcihcInNlbHNlcnZlckJ0blwiKVxyXG4gICAgcHVibGljIG1fc2Vsc2VydmVyQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcImxvZ2luQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9sb2dpbkJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJzdG9yeUJ0blwiKVxyXG4gICAgcHVibGljIG1fc3RvcnlCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBwcml2YXRlIGdhdGVJZDphbnk7XHJcbiAgICBwcml2YXRlIGdhdGVLZXk6bnVtYmVyfExvbmc7XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG9uQXdha2UoKXtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2dpbkNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubV9zdG9yeUJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICBVSU1hbmFnZXIuSW5zdGFuY2UoVUlNYW5hZ2VyKS5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICAgICAgc3RvcnlVSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgICAgICBzdG9yeVVJLlVJU3RvcnlXaW4sXHJcbiAgICAgICAgICAgICAgICBudWxsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TZWxTZXJ2ZXJXaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGxldCBjb25uZWN0ZWQgPSBhd2FpdCBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLmVuYWJsZWQgPSBjb25uZWN0ZWQ7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0IHJlYW0gc2VydmVyOiBcIitjb25uZWN0ZWQpXHJcbiAgICB9XHJcbiAgICBcclxuXHJcbiAgICBwcml2YXRlIG9uU2VsZWN0U2VydmVyKHNlcnZlckl0ZW06Vm9TZXJ2ZXJJdGVtKXtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCIgc2VydmVyIHNlbGVjdGVkOiBcIitzZXJ2ZXJJdGVtLnNlcnZlck5hbWUpXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi50ZXh0ID0gc2VydmVySXRlbS5zZXJ2ZXJOYW1lO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25PcGVuKHZvOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbk9wZW4odm8pO1xyXG5cclxuICAgICAgICAgLy/nm5HlkKzpgInmnI3mtojmga9cclxuICAgICAgICAgVUlNZXNzYWdlTWFuZ2VyLkluc3RhbmNlKFVJTWVzc2FnZU1hbmdlcikuYWRkTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0VMRUNUX1NFUlZFUixcclxuICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlclxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcclxuXHJcbiAgICAgICAgVUlNZXNzYWdlTWFuZ2VyLkluc3RhbmNlKFVJTWVzc2FnZU1hbmdlcikucmVtb3ZlTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0VMRUNUX1NFUlZFUixcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlclxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvcGVuU2VsU2VydmVyV2luKCl7XHJcblxyXG4gICAgICAgIC8vIOa1i+ivleaVsOaNrlxyXG4gICAgICAgIGxldCB2b1NlcnZlcjpWb1NlcnZlciA9IG5ldyBWb1NlcnZlcigpO1xyXG4gICAgICAgIGZvcihsZXQgaT0xOyBpPDEwOyBpKyspe1xyXG4gICAgICAgICAgICB2b1NlcnZlci5hcmVhTWFwLnNldChpLFwi5YiG5Yy6XCIraSk7XHJcbiAgICAgICAgICAgIHZvU2VydmVyLnNlcnZlck1hcC5zZXQoaSwgbmV3IEFycmF5PFZvU2VydmVySXRlbT4oKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGo9MTsgajwyMDsgaisrKXtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdm9TZXJ2ZXJJdGVtOlZvU2VydmVySXRlbSA9IG5ldyBWb1NlcnZlckl0ZW0oKTtcclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5hcmVhSWQgPSBpO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLnNlcnZlcklkID0gajtcclxuXHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVyTmFtZSA9IFwi5rWL6K+V5pyN5Yqh5ZmoXCIraStcIjpcIitqO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLnNlcnZlclN0YXR1cyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSozKzEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXIuc2VydmVyTWFwLmdldChpKS5wdXNoKHZvU2VydmVySXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgIGxvZ2luVUkuUGFja2FnZU5hbWUsIFxyXG4gICAgICAgICAgICBsb2dpblVJLlVJU2VsU2VydmVyV2luLFxyXG4gICAgICAgICAgICB2b1NlcnZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBvbkxvZ2luQ2xpY2soKXtcclxuXHJcbiAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLm1fYWNjb3VudC50ZXh0O1xyXG4gICAgICAgIGxldCBwYXNzd29yZCA9IHRoaXMubV9wYXNzd29yZC50ZXh0O1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhgYWNjb3VudDoke2FjY291bnR9IC0gcGFzc3dvcmQ6ICR7cGFzc3dvcmR9YCk7XHJcblxyXG4gICAgICAgIGlmKGFjY291bnQgIT0gXCJcIiAmJiBwYXNzd29yZCAhPSBcIlwiKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBtc2cgPSBhd2FpdCBMb2dpbkFQSS5sb2dpblJlYWxtU2VydmVyKGFjY291bnQsIHBhc3N3b3JkKVxyXG4gICAgICAgICAgICB0aGlzLmdhdGVJZCA9IG1zZy5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXRlS2V5ID0gbXNnLktleTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luIHJlYW0gc3VjYywgZ2F0ZSBhZGRyOlwiK21zZy5BZGRyZXNzICsgXCIsa2V5OlwiK21zZy5LZXkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBTZXNzaW9uTWFuYWdlci5JbnN0YW5jZShTZXNzaW9uTWFuYWdlcikuZGlzY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy/nmbvlvZXnvZHlhbPmnI1cclxuICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RlZCA9IGF3YWl0IFNlc3Npb25NYW5hZ2VyLkluc3RhbmNlKFNlc3Npb25NYW5hZ2VyKS5jb25uZWN0R2F0ZVNlcnZlcihtc2cuQWRkcmVzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgIGlmKGNvbm5lY3RlZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNvbm5lY3QgZ2F0ZSBzdWNjXCIpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1zZyA9IGF3YWl0IExvZ2luQVBJLmxvZ2luR2F0ZVNlcnZlciggdGhpcy5nYXRlSWQsIHRoaXMuZ2F0ZUtleSlcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGxheWVySUQgPSBtc2cuUGxheWVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luIGdhdGUgcmVzcG9uc2UuLlwiICtwbGF5ZXJJRCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NlbmVNYW5hZ2VyLkluc3RhbmNlKFNjZW5lTWFuYWdlcikubG9hZFNjZW5lKFNjZW5lRGVmLkhvbWVTY2VuZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0IGdhdGUgZXJyIFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3VpL1VJV2luZG93XCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi8uLi9ldmVudC9VSU1lc3NhZ2VcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlTWFuZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZU1hbmFnZXJcIjtcclxuaW1wb3J0IHsgVm9TZXJ2ZXIsIFZvU2VydmVySXRlbSB9IGZyb20gXCIuLi92by9Wb1NlcnZlclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlTZWxTZXJ2ZXJXaW4gZXh0ZW5kcyBVSVdpbmRvd3tcclxuXHJcbiAgICBAYmluZGVyKFwiYXJlYUxpc3RcIilcclxuICAgIHByaXZhdGUgYXJlYUxpc3Q6RmFpcnlHVUkuR0xpc3Q7XHJcbiAgICBAYmluZGVyKFwic2VydmVyTGlzdFwiKVxyXG4gICAgcHJpdmF0ZSBzZXJ2ZXJMaXN0OkZhaXJ5R1VJLkdMaXN0O1xyXG4gICAgQGJpbmRlcihcImJhY2tCdG5cIilcclxuICAgIHByaXZhdGUgYmFja0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcIm9rQnRuXCIpXHJcbiAgICBwcml2YXRlIG9rQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwidGl0bGVcIilcclxuICAgIHByaXZhdGUgdGl0bGU6RmFpcnlHVUkuR0xhYmVsO1xyXG5cclxuICAgIHByaXZhdGUgIGNsaWNrQXJlYUluZGV4Om51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlICBjbGlja1NlcnZlckluZGV4Om51bWJlciA9IDA7XHJcbiAgICBwcml2YXRlIHZvU2VydmVyOlZvU2VydmVyO1xyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmFja0J0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMub2tCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlcigpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLmNsaWNrQXJlYUluZGV4ID0gdGhpcy5hcmVhTGlzdC5HZXRDaGlsZEluZGV4KGV2ZW50LmRhdGEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm51bUl0ZW1zID0gdGhpcy52b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KHRoaXMuY2xpY2tBcmVhSW5kZXgrMSkubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLnNlcnZlckxpc3QuUmVmcmVzaFZpcnR1YWxMaXN0KCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5vbkNsaWNrSXRlbS5BZGQoKGV2ZW50OkZhaXJ5R1VJLkV2ZW50Q29udGV4dCk9PntcclxuXHJcbiAgICAgICAgICAgIHRoaXMuY2xpY2tTZXJ2ZXJJbmRleCA9IHRoaXMuc2VydmVyTGlzdC5HZXRDaGlsZEluZGV4KGV2ZW50LmRhdGEpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy50aXRsZS50ZXh0ID0gXCLlt7LpgInmi6nmnI3liqHlmajvvJpcIit0aGlzLmNsaWNrU2VydmVySW5kZXg7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgb25TZWxlY3RTZXJ2ZXIoKXtcclxuXHJcbiAgICAgICAgbGV0IHNlbEl0ZW06Vm9TZXJ2ZXJJdGVtID0gdGhpcy52b1NlcnZlci5zZXJ2ZXJNYXAuZ2V0KHRoaXMuY2xpY2tBcmVhSW5kZXgrMSlbdGhpcy5jbGlja1NlcnZlckluZGV4XTtcclxuXHJcbiAgICAgICAgVUlNZXNzYWdlTWFuZ2VyLkluc3RhbmNlKFVJTWVzc2FnZU1hbmdlcikuYnJvYWRjYXN0KFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NFTEVDVF9TRVJWRVIsXHJcbiAgICAgICAgICAgIHNlbEl0ZW1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbk9wZW4odm86Vm9TZXJ2ZXIpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25PcGVuKHZvKTtcclxuICAgICAgICB0aGlzLnZvU2VydmVyID0gdm87XHJcblxyXG4gICAgICAgIHRoaXMuYXJlYUxpc3QuU2V0VmlydHVhbCgpO1xyXG4gICAgICAgIHRoaXMuYXJlYUxpc3QuaXRlbVJlbmRlcmVyID0gKGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3QpPT57XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQXJlYUxpc3RJdGVtKGluZGV4LCBvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hcmVhTGlzdC5udW1JdGVtcyA9IHZvLmFyZWFNYXAuc2l6ZTtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0LlNldFZpcnR1YWwoKTtcclxuICAgICAgICB0aGlzLnNlcnZlckxpc3QuaXRlbVJlbmRlcmVyID0gKGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3QpPT57XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VydmVyTGlzdEl0ZW0oaW5kZXgsIG9iaik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnNlcnZlckxpc3QubnVtSXRlbXMgPSB2by5zZXJ2ZXJNYXAuZ2V0KHRoaXMuY2xpY2tBcmVhSW5kZXgrMSkubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyQXJlYUxpc3RJdGVtKGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3Qpe1xyXG5cclxuICAgICAgICBsZXQgYXJlYUJ0bjpGYWlyeUdVSS5HQnV0dG9uID0gb2JqLmFzQnV0dG9uO1xyXG4gICAgICAgIGFyZWFCdG4udGV4dCA9IHRoaXMudm9TZXJ2ZXIuYXJlYU1hcC5nZXQoaW5kZXgrMSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVuZGVyU2VydmVyTGlzdEl0ZW0oaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCl7XHJcbiAgICAgICAgbGV0IHNlcnZlckJ0bjpGYWlyeUdVSS5HQnV0dG9uID0gb2JqLmFzQnV0dG9uO1xyXG5cclxuICAgICAgICBzZXJ2ZXJCdG4udGV4dCA9IHRoaXMudm9TZXJ2ZXIuc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpW2luZGV4XS5zZXJ2ZXJOYW1lO1xyXG4gICAgICAgIC8vc2VydmVyQnRuLmljb24gPSBGYWlyeUdVSS5VSVBhY2thZ2UuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJcblxuXG5leHBvcnQgY2xhc3MgVm9TZXJ2ZXJJdGVte1xuXG4gICAgcHVibGljIGFyZWFJZDpudW1iZXI7XG4gICAgcHVibGljIHNlcnZlcklkOm51bWJlcjtcbiAgICBwdWJsaWMgc2VydmVyTmFtZTpzdHJpbmc7XG4gICAgcHVibGljIHNlcnZlclN0YXR1czpudW1iZXI7XG59XG5cbmV4cG9ydCAgY2xhc3MgVm9TZXJ2ZXJ7XG5cbiAgICBwdWJsaWMgc2VydmVyTWFwOiBNYXA8bnVtYmVyLCBBcnJheTxWb1NlcnZlckl0ZW0+PiA9IG5ldyBNYXA8bnVtYmVyLCBBcnJheTxWb1NlcnZlckl0ZW0+PigpO1xuICAgIHB1YmxpYyBhcmVhTWFwOk1hcDxudW1iZXIsc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLCBzdHJpbmc+KCk7XG59IiwiaW1wb3J0IHsgQmFzZVNjZW5lIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9zY2VuZS9CYXNlU2NlbmVcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgUHZlU2NlbmUgZXh0ZW5kcyBCYXNlU2NlbmV7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkVudGVyKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ29tcGxldGUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBwdWJsaWMgb25MZWF2ZSgpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xuaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xuaW1wb3J0IHsgU3RvcnlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9pbmsvU3RvcnlNYW5hZ2VyXCI7XG5pbXBvcnQgeyBTdG9yeU1lc3NhZ2VNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay9pbmsvU3RvcnlNZXNzYWdlTWFuYWdlclwiO1xuaW1wb3J0IHsgVUlNYW5hZ2VyIH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay91aS9VSU1hbmFnZXJcIjtcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVdpbmRvd1wiO1xuXG5leHBvcnQgY2xhc3MgVUlTdG9yeVdpbiBleHRlbmRzIFVJV2luZG93e1xuXG4gICAgQGJpbmRlcihcInNwZWFrZXJUeHRcIilcbiAgICBwcml2YXRlIG1fc3BlYWtlclR4dDpGYWlyeUdVSS5HUmljaFRleHRGaWVsZDtcbiAgICBAYmluZGVyKFwiYnRuTGlzdFwiKVxuICAgIHByaXZhdGUgbV9idG5MaXN0OkZhaXJ5R1VJLkdMaXN0O1xuXG4gICAgcHJpdmF0ZSBzaG91bGRDb250aW5lU3Rvcnk6Ym9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgb3B0aW9uc01hcDpNYXA8bnVtYmVyLHN0cmluZz4gPSBuZXcgTWFwPG51bWJlcixzdHJpbmc+KCk7XG4gICAgcHJpdmF0ZSBhbGxDaG9pY2VzOkNob2ljZVtdO1xuXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XG5cbiAgICAgICAgdGhpcy5tX2J0bkxpc3QuaXRlbVJlbmRlcmVyID0gKGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3QpPT57XG4gICAgICAgICAgICB0aGlzLnJlbmRlckJ0bkxpc3QoaW5kZXgsIG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1fYnRuTGlzdC5vbkNsaWNrSXRlbS5BZGQoKGV2ZW50OkZhaXJ5R1VJLkV2ZW50Q29udGV4dCk9PntcbiAgICAgICAgICAgICBsZXQgY2xpY2tJZDpudW1iZXIgPSB0aGlzLm1fYnRuTGlzdC5HZXRDaGlsZEluZGV4KGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgaWYodGhpcy5zaG91bGRDb250aW5lU3Rvcnkpe1xuICAgICAgICAgICAgICAgIFN0b3J5TWFuYWdlci5JbnN0YW5jZShTdG9yeU1hbmFnZXIpLmFkdmFuY2VTdG9yeSgpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcikuc2VsZWN0Q2hvaWNlKHRoaXMuYWxsQ2hvaWNlc1tjbGlja0lkXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG9uT3Blbih2bzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uT3Blbih2byk7XG5cbiAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DT05URU5UUkVBRFksXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PbkNvbnRlbnRSZWFkeVxuICAgICAgICApO1xuICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PbkNob2ljZXNQcmVzZW50ZWRcbiAgICAgICAgKTtcbiAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5hZGRMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05TVE9SWUZJTklTSEVELFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMuT25TdG9yeUZpbmlzaGVkXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm9wdGlvbnNNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcblxuICAgICAgICBTdG9yeU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNYW5hZ2VyKS5iZWdpblN0b3J5KFwic3RvcnkyXCIpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBPbkNvbnRlbnRSZWFkeShcbiAgICAgICAgc3BlYWtlckNvbnRlbnQ6c3RyaW5nLFxuICAgICAgICBzcGVha2VySWQ6c3RyaW5nLFxuICAgICAgICBjdXJyZW50VGFnczpzdHJpbmdbXSxcbiAgICAgICAgY3VycmVudENob2ljZXM6Q2hvaWNlW10pXG4gICAge1xuICAgICAgICB0aGlzLm1fc3BlYWtlclR4dC50ZXh0ID0gc3BlYWtlckNvbnRlbnQ7XG5cbiAgICAgICAgaWYoU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcikuY2FuQ29udGludWUpe1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLm1fYnRuTGlzdC5udW1JdGVtcyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZihjdXJyZW50Q2hvaWNlcy5sZW5ndGg+MCl7XG4gICAgICAgICAgICB0aGlzLmFsbENob2ljZXMgPSBjdXJyZW50Q2hvaWNlcztcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ29udGluZVN0b3J5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGxldCBsZW4gPSBjdXJyZW50Q2hvaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IobGV0IGk9MDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYXAuc2V0KGksIGN1cnJlbnRDaG9pY2VzW2ldLnRleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm1fYnRuTGlzdC5udW1JdGVtcyA9IGxlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVuZGVyQnRuTGlzdChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KXtcbiAgICAgICAgbGV0IGNvbnRpbnVlQnRuOkZhaXJ5R1VJLkdCdXR0b24gPSBvYmouYXNCdXR0b247XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLm9wdGlvbnNNYXAuc2l6ZT4wKXtcbiAgICAgICAgICAgIGNvbnRpbnVlQnRuLnRleHQgPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGluZGV4KTtcblxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnRpbnVlQnRuLnRleHQgPSBcIueCueWHu+e7p+e7rVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBPbkNob2ljZXNQcmVzZW50ZWQoY3VycmVudENob2ljZXM6Q2hvaWNlW10pe1xuICAgICAgXG4gICAgICAgIHRoaXMuc2hvdWxkQ29udGluZVN0b3J5ID0gZmFsc2U7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiLi4uLk9uQ2hvaWNlc1ByZXNlbnRlZC4uLi4uLlwiKVxuICAgIH1cblxuICAgIHByaXZhdGUgT25TdG9yeUZpbmlzaGVkKCk6dm9pZHtcblxuICAgICAgICBjb25zb2xlLmxvZyhcIlN0b3J5IEZpbmlzaGVkXCIpXG5cbiAgICAgICAgVUlNYW5hZ2VyLkluc3RhbmNlKFVJTWFuYWdlcikuY2xvc2VXaW5kb3coc3RvcnlVSS5VSVN0b3J5V2luLG51bGwpO1xuICAgIH1cblxuXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcikucmVtb3ZlTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgdGhpcy5PbkNvbnRlbnRSZWFkeVxuICAgICAgICApO1xuICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICB0aGlzLk9uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICApO1xuICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLk9uU3RvcnlGaW5pc2hlZFxuICAgICAgICApO1xuICAgIH1cbn0iLCJcclxuZXhwb3J0ICBjbGFzcyBHYW1lQ29uZmlne1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgZGVidWc6Ym9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyByZWFsbVNlcnZlcklQOnN0cmluZyA9IFwiMTI3LjAuMC4xXCI7IFxyXG4gICAgcHVibGljIHN0YXRpYyByZWFsbVNlcnZlclBvcnQ6bnVtYmVyID0gOTAwMTtcclxuXHJcbn0iLCJcclxuXHJcbmltcG9ydCB7U2luZ2xldG9ufSBmcm9tICcuLi9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvbic7XHJcblxyXG5leHBvcnQgY2xhc3MgU2luZ2xldG9uVGVzdCBleHRlbmRzIFNpbmdsZXRvbjxTaW5nbGV0b25UZXN0PntcclxuXHJcbiAgICBwcml2YXRlIG51bTpudW1iZXIgPSAwO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTaW5nbGV0b25UZXN0IGNhbGwgY29uc3RydWN0b3JcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZCgpIDogdm9pZCB7XHJcblxyXG4gICAgICAgIHRoaXMubnVtICs9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRlc3QoKSA6IG51bWJlcntcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtO1xyXG5cclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQge1RpbWVVdGlsfSBmcm9tICcuLi9mcmFtZXdvcmsvdXRpbC9UaW1lVXRpbCc7XHJcbmltcG9ydCB7U2luZ2xldG9uVGVzdH0gZnJvbSAnLi9TaW5nbGV0b25UZXN0JztcclxuaW1wb3J0IHtNZXNzZW5nZXJ9IGZyb20gJy4uL2ZyYW1ld29yay9jb21tb24vTWVzc2VuZ2VyJztcclxuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gJy4uL2ZyYW1ld29yay9jb21tb24vUmVzTWFuYWdlcic7XHJcbmltcG9ydCB7IFNraWxsQ29uZmlnVEIsIFNraWxsQ29uZmlnVFIgfSBmcm9tICcuLi9kYXRhL2V4Y2VsL1NraWxsQ29uZmlnJztcclxuaW1wb3J0IHsgUmVkSGludHNNZXNzYWdlTWFuYWdlciB9IGZyb20gJy4uL2ZyYW1ld29yay9yZWRoaW50cy9SZWRIaW50c01lc3NhZ2VNYW5hZ2VyJztcclxuaW1wb3J0IHsgZW51bVJlZEhpbnRzLCBSZWRIaW50c01hbmFnZXIgfSBmcm9tICcuLi9mcmFtZXdvcmsvcmVkaGludHMvUmVkSGludHNNYW5hZ2VyJztcclxuaW1wb3J0IHsgU3RvcnkgfSBmcm9tICdpbmtqcyc7XHJcbmltcG9ydCB7IG5pY2VfdHMgfSBmcm9tICcuLi9kYXRhL3BiL2dlbi9wYic7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVuaXRUZXN0e1xyXG4gICAgcHVibGljIHN0YXRpYyB0ZXN0VmFyOm51bWJlciA9IDEwMDAwO1xyXG5cclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGRvVGVzdCgpe1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlRpbWVVdGlsID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIFRpbWVVdGlsLnRlc3QoKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTaW5nbGV0b24gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgU2luZ2xldG9uVGVzdC5JbnN0YW5jZShTaW5nbGV0b25UZXN0KTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIj09PVwiKTtcclxuICAgICAgICBsZXQgdDE6IFNpbmdsZXRvblRlc3QgPSBTaW5nbGV0b25UZXN0Lkluc3RhbmNlKFNpbmdsZXRvblRlc3QpO1xyXG4gICAgICAgIGxldCB0MjogU2luZ2xldG9uVGVzdCA9IFNpbmdsZXRvblRlc3QuSW5zdGFuY2UoU2luZ2xldG9uVGVzdCk7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKHQxLnRlc3QoKSArIFwiIDogXCIgKyB0Mi50ZXN0KCkpO1xyXG4gICAgICAgIHQxLmFkZCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHQxLnRlc3QoKSArIFwiIDogXCIgKyB0Mi50ZXN0KCkpO1xyXG4gICAgICAgIHQyLmFkZCgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHQxLnRlc3QoKSArIFwiIDogXCIgKyB0Mi50ZXN0KCkpO1xyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNZXNzYWdlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcbiAgICAgICAgbGV0IG1lc3NlbmdlcjpNZXNzZW5nZXIgPSBuZXcgTWVzc2VuZ2VyKCk7XHJcbiAgICAgICAgbGV0IGxpc3RlbjpGdW5jdGlvbiA9IGZ1bmN0aW9uKGE6bnVtYmVyLCBiOnN0cmluZyl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBsaXN0ZW4gY2FsbDogJHthfSAsICR7Yn1gKVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbGlzdGVuMjpGdW5jdGlvbiA9IGZ1bmN0aW9uKGE6bnVtYmVyLCBiOnN0cmluZyl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBsaXN0ZW4gY2FsbDI6ICR7YX0gLCAke2J9YClcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCAgRVZFTlRfQ09ERTpudW1iZXIgPSAxMDA7XHJcbiAgICAgICAgbWVzc2VuZ2VyLmFkZExpc3RlbmVyKEVWRU5UX0NPREUsdGhpcywgbGlzdGVuKTtcclxuICAgICAgICBtZXNzZW5nZXIuYWRkTGlzdGVuZXIoRVZFTlRfQ09ERSx0aGlzLCBsaXN0ZW4yKTtcclxuICAgICAgICBtZXNzZW5nZXIuYnJvYWRjYXN0KEVWRU5UX0NPREUsIDk5OSxcIiBIZWxsb1wiKTtcclxuXHJcbiAgICAgICAgbWVzc2VuZ2VyLnJlbW92ZUxpc3RlbmVyKEVWRU5UX0NPREUsbGlzdGVuKTtcclxuICAgICAgICBtZXNzZW5nZXIuYnJvYWRjYXN0KEVWRU5UX0NPREUsIDk5OSxcIiBIZWxsb1wiKTtcclxuXHJcbiAgICAgICAgbWVzc2VuZ2VyLmNsZWFydXAoKTtcclxuICAgICAgICBtZXNzZW5nZXIuYnJvYWRjYXN0KEVWRU5UX0NPREUsIDk5OSxcIiBIZWxsb1wiKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVGltZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW50ZXIgdmFsLi5cIilcclxuICAgICAgICB9LDEwMDApO1xyXG4gICAgICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKT0+e1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcclxuICAgICAgICB9LDUwMDApOyBcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiUmVzb3VyY2VNYW5hZ2VyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgIC8vIGxldCBwcmVmYWIgPSBhd2FpdCBSZXNNYW5hZ2VyLkluc3RhbmNlKFJlc01hbmFnZXIpLmxvYWRQcmVmYWIoXCJNb2RlbHMvMTAwMS9DaGFyYWN0ZXIucHJlZmFiXCIpIDtcclxuICAgICAgICBcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHByZWZhYik7XHJcblxyXG4gICAgICAgIC8vbGV0IGluc3QgPSBDUy5Vbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKHByZWZhYik7XHJcbiAgICAgICAgLy9pbnN0Lm5hbWUgPSBcIlRlc3QgQ2hcIjtcclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwi5byV55So57G75Z6LID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIGxldCB0ZXN0TWFwOk1hcDxzdHJpbmcsQXJyYXk8bnVtYmVyPj4gPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGVzdE1hcC5zZXQoXCJrZXkxXCIgLG5ldyBBcnJheSgpKTtcclxuXHJcbiAgICAgICAgbGV0IGFycjE6QXJyYXk8bnVtYmVyPiA9IHRlc3RNYXAuZ2V0KFwia2V5MVwiKTtcclxuICAgICAgICBhcnIxLnB1c2goMTIpO1xyXG4gICAgICAgIGFycjEucHVzaCgzMzMpO1xyXG5cclxuICAgICAgICBsZXQgYXJyMjpBcnJheTxudW1iZXI+ID0gdGVzdE1hcC5nZXQoXCJrZXkxXCIpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGFycjIpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gTG9nZ2VyLmxvZyhcIkZhcml5R1VJID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIC8vICBsZXQgcGFnZTpVSV9Mb2dpblBhZ2UgPSBuZXcgVUlfTG9naW5QYWdlKCk7XHJcbiAgICAgICAgLy8gIENTLkZhaXJ5R1VJLkdSb290Lmluc3QuQWRkQ2hpbGQocGFnZS5fdWkpO1xyXG4gICAgICAgIC8vICBMb2dnZXIubG9nKHBhZ2UuX3VpKTtcclxuXHJcbiAgICAgICAgLy8gTG9nZ2VyLmxvZyhcIk1vZHVsZU1hbmFnZXIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcblxyXG4gICAgICAgIC8vIE1vZHVsZU1hbmFnZXIuSW5zdGFuY2UoTW9kdWxlTWFuYWdlcikuY3JlYXRlTW9kdWxlKE1vZHVsZURlZi5Mb2dpbk1vZHVsZSxcImNyZWF0ZSBsb2dpblwiKTtcclxuXHJcbiAgICAgICAgLy8gTW9kdWxlTWFuYWdlci5JbnN0YW5jZShNb2R1bGVNYW5hZ2VyKS5zZW5kTWVzc2FnZShNb2R1bGVEZWYuTG9naW5Nb2R1bGUsIFwidGVzdDFcIiwyMjMzKTtcclxuICAgICAgICAvLyBNb2R1bGVNYW5hZ2VyLkluc3RhbmNlKE1vZHVsZU1hbmFnZXIpLnNlbmRNZXNzYWdlKE1vZHVsZURlZi5Ib21lTW9kdWxlLCBcInRlc3QyXCIsMjIzMyk7XHJcbiAgICAgICAgLy8gTG9nZ2VyLmxvZyhcInRoZW4gY3JlYXRlIEhvbWVcIik7XHJcbiAgICAgICAgLy8gTW9kdWxlTWFuYWdlci5JbnN0YW5jZShNb2R1bGVNYW5hZ2VyKS5jcmVhdGVNb2R1bGUoTW9kdWxlRGVmLkhvbWVNb2R1bGUsXCJjcmVhdGUgbG9naW5cIik7XHJcbiAgICBcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlVJTWFuYWdlciA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcImV4Y2VsIGRhdGEgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XHJcbiAgICAgICAgbGV0IHNraWxsTWFwID0gU2tpbGxDb25maWdUQi5JbnN0YW5jZShTa2lsbENvbmZpZ1RCKS50cnM7XHJcbiAgICAgICAgbGV0IHNraWxsdHI6U2tpbGxDb25maWdUUiA9IHNraWxsTWFwLmdldCgxMDAzKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgJHtza2lsbHRyLl9OYW1lfSA6ICR7c2tpbGx0ci5fQXR0YWNrVHlwZX1gKVxyXG4gICAgICAgIGxldCBpbXBhY3R0eXBlID0gc2tpbGx0ci5fSW1wYWN0VHlwZTtcclxuICAgICAgICBjb25zb2xlLmxvZyhpbXBhY3R0eXBlKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcIlByb3RvYnVmID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBjMnJMb2dpbiA9IHtcclxuICAgICAgICAgICAgICAgIFwiQWNjb3VudFwiIDogXCJ0ZXN0XCIsXHJcbiAgICAgICAgICAgICAgICBcIlBhc3N3b3JkXCIgOiBcIjEyMzRcIlxyXG4gICAgICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8v6aqM6K+BXHJcbiAgICAgICAgICAgIGxldCB2MSA9IG5pY2VfdHMuQzJSX0xvZ2luLnZlcmlmeShjMnJMb2dpbik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidmVyaWZ5IHBiOiBcIisgdjEpO1xyXG5cclxuICAgICAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJSX0xvZ2luLmNyZWF0ZShjMnJMb2dpbilcclxuICAgICAgICAgICAgbXNnLkFjY291bnQgPSBcInRlc3QxXCJcclxuICAgICAgICAgICAgbXNnLlBhc3N3b3JkID0gXCIxMTIyXCJcclxuICAgICAgICAgICAgY29uc29sZS5sb2cobXNnKVxyXG5cclxuICAgICAgICAgICAgbGV0IGJ1ZiA9IG5pY2VfdHMuQzJSX0xvZ2luLmVuY29kZShtc2cpLmZpbmlzaCgpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGJ1ZilcclxuXHJcbiAgICAgICAgICAgIGxldCBkZV9idWYgPSBuaWNlX3RzLkMyUl9Mb2dpbi5kZWNvZGUoYnVmKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkZV9idWYuQWNjb3VudClcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGVfYnVmLlBhc3N3b3JkKVxyXG5cclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZXgpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVWludEFycmF5ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICBsZXQgIG9wY29kZV9hcnIgPSBuZXcgVWludDhBcnJheShbMjU3LDI1XSk7XHJcbiAgICAgICAgY29uc29sZS5sb2cob3Bjb2RlX2Fyci5zdWJhcnJheSgwLDEpKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhvcGNvZGVfYXJyLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGxldCBvcGNvZGVfYXJyMiA9IG5ldyBVaW50OEFycmF5KFszM10pO1xyXG5cclxuICAgICAgICAvL+WQiOW5tiBVaW50OEFycmF5XHJcbiAgICAgICAgbGV0IG1lcmdlX2FyciA9IG5ldyBVaW50OEFycmF5KG9wY29kZV9hcnIubGVuZ3RoICsgb3Bjb2RlX2FycjIubGVuZ3RoKTtcclxuICAgICAgICBtZXJnZV9hcnIuc2V0KG9wY29kZV9hcnIyKTtcclxuICAgICAgICBtZXJnZV9hcnIuc2V0KG9wY29kZV9hcnIsIG9wY29kZV9hcnIyLmxlbmd0aCk7XHJcbiAgICAgICAgY29uc29sZS5sb2cobWVyZ2VfYXJyLmxlbmd0aCk7XHJcbiAgICAgXHJcbiAgICAgICAgbGV0IG46bnVtYmVyID0gNTY3ODtcclxuICAgICAgICBsZXQgYnVmZmVyOlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcclxuXHJcbiAgICAgICAgLy8gPDwg5bem56e7ICA+PiDlj7Pnp7sgID4+PiDml6DnrKblj7flj7Pnp7tcclxuICAgICAgICAvL27ovax1aW50OEFycmF5XHJcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gMjQ7XHJcbiAgICAgICAgYnVmZmVyWzFdID0gbiA+Pj4gMTY7XHJcbiAgICAgICAgYnVmZmVyWzJdID0gbiA+Pj4gODtcclxuICAgICAgICBidWZmZXJbM10gPSBuICYgMHhmZjtcclxuXHJcblxyXG4gICAgICAgIC8vdW5pdDhBcnJheei9rG5cclxuICAgICAgICBuID0gYnVmZmVyWzBdIDw8IDI0IHwgYnVmZmVyWzFdIDw8IDE2IHwgYnVmZmVyWzJdIDw8IDggfCBidWZmZXJbM107XHJcbiAgICAgICAgY29uc29sZS5sb2cobik7XHJcblxyXG5cclxuICAgICAgICBuID0gMzAwO1xyXG4gICAgICAgIGxldCBidWZmZXIxOlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSgyKTtcclxuICAgICAgICBidWZmZXIxWzBdID0gbiA+Pj4gODtcclxuICAgICAgICBidWZmZXIxWzFdID0gbiAmIDB4ZmY7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGJ1ZmZlcjEpO1xyXG4gICAgICAgIG4gPSBidWZmZXIxWzBdPDw4IHwgYnVmZmVyMVsxXTtcclxuICAgICAgICBjb25zb2xlLmxvZyhuKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzbGVlcCA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVwiKTtcclxuICAgICAgICBhd2FpdCBUaW1lVXRpbC5zbGVlcCgxMDAwKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInNsZWVwIC4uZW5kXCIpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCJmbGF0YnVmZmVyID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG4gICAgICAgIC8vIHRyeXtcclxuICAgICAgICAvLyAgICAgbGV0IGJ5dGVzOkFycmF5QnVmZmVyID0gYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkVGV4dEJ5dGVzKFwiQ29uZmlnL2ZiL3VuaXRjb25maWcuYnl0ZXNcIilcclxuICAgICAgICAvLyAgICAgbGV0IHVuaXRCeXRlID0gbmV3IGZsYXRidWZmZXJzLkJ5dGVCdWZmZXIobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2codW5pdEJ5dGUpO1xyXG4gICAgICAgIC8vICAgICBsZXQgdW5pdGNvbmZpZzpmYi51bml0Y29uZmlnVEIgPSBmYi51bml0Y29uZmlnVEIuZ2V0Um9vdEFzdW5pdGNvbmZpZ1RCKHVuaXRCeXRlKVxyXG4gICAgICAgIC8vICAgICBjb25zb2xlLmxvZyh1bml0Y29uZmlnLnVuaXRjb25maWdUUlNMZW5ndGgoKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgXHJcbiAgICAgICAgLy8gICAgIGZvcihsZXQgaT0wOyBpPHVuaXRjb25maWcudW5pdGNvbmZpZ1RSU0xlbmd0aCgpOyBpKyspe1xyXG4gICAgICAgIC8vICAgICAgICAgbGV0IGEgPSAgdW5pdGNvbmZpZy51bml0Y29uZmlnVFJTKGkpO1xyXG4gICAgICAgIC8vICAgICAgICAgY29uc29sZS5sb2coYS5OYW1lKCkpO1xyXG4gICAgICAgIC8vICAgICB9XHJcblxyXG4gICAgICAgIC8vIH1jYXRjaChleCl7XHJcbiAgICAgICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xyXG4gICAgICAgIC8vIH1cclxuXHJcblxyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5rWL6K+V57qi54K557O757ufID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuICAgICAgICAgICAgUmVkSGludHNNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01lc3NhZ2VNYW5hZ2VyKS5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0LFxyXG4gICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWQgaGludHMgY2hhdC4uLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgUmVkSGludHNNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01lc3NhZ2VNYW5hZ2VyKS5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0X2ZhbWlseSxcclxuICAgICAgICAgICAgICAgIHRoaXMsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVkIGhpbnRzIGNoYXRfZmFtaWx5Li4uXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBSZWRIaW50c01lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWVzc2FnZU1hbmFnZXIpLmFkZExpc3RlbmVyKFxyXG4gICAgICAgICAgICAgICAgZW51bVJlZEhpbnRzLmNoYXRfc3lzdGVtLFxyXG4gICAgICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWQgaGludHMgY2hhdC4uLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIFJlZEhpbnRzTWFuYWdlci5JbnN0YW5jZShSZWRIaW50c01hbmFnZXIpLnNldFJlZEhpbnRPcGVuT3JDbG9zZShcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0X2ZhbWlseSwgdHJ1ZVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBsZXQgcl9jaGF0ID0gUmVkSGludHNNYW5hZ2VyLkluc3RhbmNlKFJlZEhpbnRzTWFuYWdlcikuY2hlY2tSZWRJc09wZW4oXHJcbiAgICAgICAgICAgICAgICBlbnVtUmVkSGludHMuY2hhdFxyXG4gICAgICAgICAgICApIDtcclxuICAgICAgICAgICAgbGV0IHJfY2hhdF9mYW1pbHkgPSBSZWRIaW50c01hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNYW5hZ2VyKS5jaGVja1JlZElzT3BlbihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0X2ZhbWlseVxyXG4gICAgICAgICAgICApIDtcclxuICAgICAgICAgICAgbGV0IHJfY2hhdF9zeXN0ZW0gPSBSZWRIaW50c01hbmFnZXIuSW5zdGFuY2UoUmVkSGludHNNYW5hZ2VyKS5jaGVja1JlZElzT3BlbihcclxuICAgICAgICAgICAgICAgIGVudW1SZWRIaW50cy5jaGF0X3N5c3RlbVxyXG4gICAgICAgICAgICApIDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocl9jaGF0LCByX2NoYXRfZmFtaWx5LCByX2NoYXRfc3lzdGVtKVxyXG5cclxuICAgICAgICB9Y2F0Y2goZXJyb3Ipe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcilcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW5rIFN0b3J5ID09PT09PT09PT09PT09PT09PT09PT09PT09PT09XCIpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciBqc29uID0gYXdhaXQgKGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFRleHRBc3NldChcIlN0b3J5L1Rlc3RTdG9yeS5qc29uXCIpKS50ZXh0O1xyXG4gICAgICAgICAgICBsZXQgc3RvcnkgPSBuZXcgU3RvcnkoanNvbik7XHJcbiAgICAgICAgICAgIHN0b3J5LkNob29zZVBhdGhTdHJpbmcoXCJzdG9yeTFcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHN0b3J5LkJpbmRFeHRlcm5hbEZ1bmN0aW9uKFwiR2V0Q2hhcmFjdGVyTmFtZVwiLCgpPT57XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJKdXN0aW4gVGVzdFwiO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICBzdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoXCJHZXRDaGFyYWN0ZXJOYW1lQnlNdXRpUGFyYW1zXCIsKGFyZ3M6W10pPT57XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhhcmdzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJUVFRUXCI7XHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzdG9yeS5Db250aW51ZSgpKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coc3RvcnkuQ29udGludWUoKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0b3J5LkNvbnRpbnVlKCkpO1xyXG4gICAgICAgIH1jYXRjaChlcnJvcil7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIFxyXG5cclxufVxyXG5cclxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiY3NoYXJwXCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInB1ZXJ0c1wiKTsiXSwic291cmNlUm9vdCI6IiJ9