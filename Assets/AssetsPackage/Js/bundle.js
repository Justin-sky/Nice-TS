/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/GameMain.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = asPromise;

/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */

/**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */
function asPromise(fn, ctx/*, varargs */) {
    var params  = new Array(arguments.length - 1),
        offset  = 0,
        index   = 2,
        pending = true;
    while (index < arguments.length)
        params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err/*, varargs */) {
            if (pending) {
                pending = false;
                if (err)
                    reject(err);
                else {
                    var params = new Array(arguments.length - 1),
                        offset = 0;
                    while (offset < params.length)
                        params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}


/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var base64 = exports;

/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */
base64.length = function length(string) {
    var p = string.length;
    if (!p)
        return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
    return Math.ceil(string.length * 3) / 4 - n;
};

// Base64 encoding table
var b64 = new Array(64);

// Base64 decoding table
var s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (var i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */
base64.encode = function encode(buffer, start, end) {
    var parts = null,
        chunk = [];
    var i = 0, // output index
        j = 0, // goto index
        t;     // temporary
    while (start < end) {
        var b = buffer[start++];
        switch (j) {
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1)
            chunk[i++] = 61;
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

var invalidEncoding = "invalid encoding";

/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */
base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, // goto index
        t;     // temporary
    for (var i = 0; i < string.length;) {
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1)
            break;
        if ((c = s64[c]) === undefined)
            throw Error(invalidEncoding);
        switch (j) {
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1)
        throw Error(invalidEncoding);
    return offset - start;
};

/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */
base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};


/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = EventEmitter;

/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */
function EventEmitter() {

    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */
    this._listeners = {};
}

/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn  : fn,
        ctx : ctx || this
    });
    return this;
};

/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined)
        this._listeners = {};
    else {
        if (fn === undefined)
            this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length;)
                if (listeners[i].fn === fn)
                    listeners.splice(i, 1);
                else
                    ++i;
        }
    }
    return this;
};

/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */
EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [],
            i = 1;
        for (; i < arguments.length;)
            args.push(arguments[i++]);
        for (i = 0; i < listeners.length;)
            listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};


/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = factory(factory);

/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */

/**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */

/**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

/**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */

// Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {

    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {

        var f32 = new Float32Array([ -0 ]),
            f8b = new Uint8Array(f32.buffer),
            le  = f8b[3] === 128;

        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }

        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos    ] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */
        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;

        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }

        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos    ];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }

        /* istanbul ignore next */
        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */
        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;

    // float: ieee754
    })(); else (function() {

        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0)
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val))
                writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) // +-Infinity
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) // denormal
                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2),
                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }

        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);

        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos),
                sign = (uint >> 31) * 2 + 1,
                exponent = uint >>> 23 & 255,
                mantissa = uint & 8388607;
            return exponent === 255
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 1.401298464324817e-45 * mantissa
                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }

        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);

    })();

    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {

        var f64 = new Float64Array([-0]),
            f8b = new Uint8Array(f64.buffer),
            le  = f8b[7] === 128;

        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }

        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos    ] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }

        /* istanbul ignore next */
        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */
        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;

        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos    ];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }

        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos    ];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }

        /* istanbul ignore next */
        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */
        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;

    // double: ieee754
    })(); else (function() {

        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
                val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) { // +-Infinity
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) { // denormal
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024)
                        exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }

        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);

        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0),
                hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1,
                exponent = hi >>> 20 & 2047,
                mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047
                ? mantissa
                ? NaN
                : sign * Infinity
                : exponent === 0 // denormal
                ? sign * 5e-324 * mantissa
                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }

        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);

    })();

    return exports;
}

// uint helpers

function writeUintLE(val, buf, pos) {
    buf[pos    ] =  val        & 255;
    buf[pos + 1] =  val >>> 8  & 255;
    buf[pos + 2] =  val >>> 16 & 255;
    buf[pos + 3] =  val >>> 24;
}

function writeUintBE(val, buf, pos) {
    buf[pos    ] =  val >>> 24;
    buf[pos + 1] =  val >>> 16 & 255;
    buf[pos + 2] =  val >>> 8  & 255;
    buf[pos + 3] =  val        & 255;
}

function readUintLE(buf, pos) {
    return (buf[pos    ]
          | buf[pos + 1] << 8
          | buf[pos + 2] << 16
          | buf[pos + 3] << 24) >>> 0;
}

function readUintBE(buf, pos) {
    return (buf[pos    ] << 24
          | buf[pos + 1] << 16
          | buf[pos + 2] << 8
          | buf[pos + 3]) >>> 0;
}


/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = inquire;

/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */
function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/,"re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length))
            return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}


/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = pool;

/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */

/**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */

/**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */
function pool(alloc, slice, size) {
    var SIZE   = size || 8192;
    var MAX    = SIZE >>> 1;
    var slab   = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX)
            return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) // align to 32 bit
            offset = (offset | 7) + 1;
        return buf;
    };
}


/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */
var utf8 = exports;

/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */
utf8.length = function utf8_length(string) {
    var len = 0,
        c = 0;
    for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
            len += 1;
        else if (c < 2048)
            len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else
            len += 3;
    }
    return len;
};

/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */
utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
        return "";
    var parts = null,
        chunk = [],
        i = 0, // char offset
        t;     // temporary
    while (start < end) {
        t = buffer[start++];
        if (t < 128)
            chunk[i++] = t;
        else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};

/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */
utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset,
        c1, // character 1
        c2; // character 2
    for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6       | 192;
            buffer[offset++] = c1       & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18      | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12      | 224;
            buffer[offset++] = c1 >> 6  & 63 | 128;
            buffer[offset++] = c1       & 63 | 128;
        }
    }
    return offset - start;
};


/***/ }),

/***/ "./node_modules/inkjs/engine/CallStack.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/CallStack.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.CallStack = void 0;
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class CallStack {
    constructor() {
        this._threadCounter = 0;
        this._startOfRoot = Pointer_1.Pointer.Null;
        if (arguments[0] instanceof Story_1.Story) {
            let storyContext = arguments[0];
            this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
            this.Reset();
        }
        else {
            let toCopy = arguments[0];
            this._threads = [];
            for (let otherThread of toCopy._threads) {
                this._threads.push(otherThread.Copy());
            }
            this._threadCounter = toCopy._threadCounter;
            this._startOfRoot = toCopy._startOfRoot;
        }
    }
    get elements() {
        return this.callStack;
    }
    get depth() {
        return this.elements.length;
    }
    get currentElement() {
        let thread = this._threads[this._threads.length - 1];
        let cs = thread.callstack;
        return cs[cs.length - 1];
    }
    get currentElementIndex() {
        return this.callStack.length - 1;
    }
    get currentThread() {
        return this._threads[this._threads.length - 1];
    }
    set currentThread(value) {
        Debug_1.Debug.Assert(this._threads.length == 1, "Shouldn't be directly setting the current thread when we have a stack of them");
        this._threads.length = 0;
        this._threads.push(value);
    }
    get canPop() {
        return this.callStack.length > 1;
    }
    Reset() {
        this._threads = [];
        this._threads.push(new CallStack.Thread());
        this._threads[0].callstack.push(new CallStack.Element(PushPop_1.PushPopType.Tunnel, this._startOfRoot));
    }
    SetJsonToken(jObject, storyContext) {
        this._threads.length = 0;
        // TODO: (List<object>) jObject ["threads"];
        let jThreads = jObject["threads"];
        for (let jThreadTok of jThreads) {
            // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;
            let jThreadObj = jThreadTok;
            let thread = new CallStack.Thread(jThreadObj, storyContext);
            this._threads.push(thread);
        }
        // TODO: (int)jObject ["threadCounter"];
        this._threadCounter = parseInt(jObject["threadCounter"]);
        this._startOfRoot = Pointer_1.Pointer.StartOf(storyContext.rootContentContainer);
    }
    WriteJson(w) {
        w.WriteObject((writer) => {
            writer.WritePropertyStart("threads");
            writer.WriteArrayStart();
            for (let thread of this._threads) {
                thread.WriteJson(writer);
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WritePropertyStart("threadCounter");
            writer.WriteInt(this._threadCounter);
            writer.WritePropertyEnd();
        });
    }
    PushThread() {
        let newThread = this.currentThread.Copy();
        this._threadCounter++;
        newThread.threadIndex = this._threadCounter;
        this._threads.push(newThread);
    }
    ForkThread() {
        let forkedThread = this.currentThread.Copy();
        this._threadCounter++;
        forkedThread.threadIndex = this._threadCounter;
        return forkedThread;
    }
    PopThread() {
        if (this.canPopThread) {
            this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()
        }
        else {
            throw new Error("Can't pop thread");
        }
    }
    get canPopThread() {
        return this._threads.length > 1 && !this.elementIsEvaluateFromGame;
    }
    get elementIsEvaluateFromGame() {
        return this.currentElement.type == PushPop_1.PushPopType.FunctionEvaluationFromGame;
    }
    Push(type, externalEvaluationStackHeight = 0, outputStreamLengthWithPushed = 0) {
        let element = new CallStack.Element(type, this.currentElement.currentPointer, false);
        element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;
        element.functionStartInOutputStream = outputStreamLengthWithPushed;
        this.callStack.push(element);
    }
    CanPop(type = null) {
        if (!this.canPop)
            return false;
        if (type == null)
            return true;
        return this.currentElement.type == type;
    }
    Pop(type = null) {
        if (this.CanPop(type)) {
            this.callStack.pop();
            return;
        }
        else {
            throw new Error("Mismatched push/pop in Callstack");
        }
    }
    GetTemporaryVariableWithName(name, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        let varValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (varValue.exists) {
            return varValue.result;
        }
        else {
            return null;
        }
    }
    SetTemporaryVariable(name, value, declareNew, contextIndex = -1) {
        if (contextIndex == -1)
            contextIndex = this.currentElementIndex + 1;
        let contextElement = this.callStack[contextIndex - 1];
        if (!declareNew && !contextElement.temporaryVariables.get(name)) {
            throw new StoryException_1.StoryException("Could not find temporary variable to set: " + name);
        }
        let oldValue = TryGetResult_1.tryGetValueFromMap(contextElement.temporaryVariables, name, null);
        if (oldValue.exists)
            Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        contextElement.temporaryVariables.set(name, value);
    }
    ContextForVariableNamed(name) {
        if (this.currentElement.temporaryVariables.get(name)) {
            return this.currentElementIndex + 1;
        }
        else {
            return 0;
        }
    }
    ThreadWithIndex(index) {
        let filtered = this._threads.filter((t) => {
            if (t.threadIndex == index)
                return t;
        });
        return filtered.length > 0 ? filtered[0] : null;
    }
    get callStack() {
        return this.currentThread.callstack;
    }
    get callStackTrace() {
        let sb = new StringBuilder_1.StringBuilder();
        for (let t = 0; t < this._threads.length; t++) {
            let thread = this._threads[t];
            let isCurrent = t == this._threads.length - 1;
            sb.AppendFormat("=== THREAD {0}/{1} {2}===\n", t + 1, this._threads.length, isCurrent ? "(current) " : "");
            for (let i = 0; i < thread.callstack.length; i++) {
                if (thread.callstack[i].type == PushPop_1.PushPopType.Function)
                    sb.Append("  [FUNCTION] ");
                else
                    sb.Append("  [TUNNEL] ");
                let pointer = thread.callstack[i].currentPointer;
                if (!pointer.isNull) {
                    sb.Append("<SOMEWHERE IN ");
                    if (pointer.container === null) {
                        return NullException_1.throwNullException("pointer.container");
                    }
                    sb.Append(pointer.container.path.toString());
                    sb.AppendLine(">");
                }
            }
        }
        return sb.toString();
    }
}
exports.CallStack = CallStack;
(function (CallStack) {
    class Element {
        constructor(type, pointer, inExpressionEvaluation = false) {
            this.evaluationStackHeightWhenPushed = 0;
            this.functionStartInOutputStream = 0;
            this.currentPointer = pointer.copy();
            this.inExpressionEvaluation = inExpressionEvaluation;
            this.temporaryVariables = new Map();
            this.type = type;
        }
        Copy() {
            let copy = new Element(this.type, this.currentPointer, this.inExpressionEvaluation);
            copy.temporaryVariables = new Map(this.temporaryVariables);
            copy.evaluationStackHeightWhenPushed = this.evaluationStackHeightWhenPushed;
            copy.functionStartInOutputStream = this.functionStartInOutputStream;
            return copy;
        }
    }
    CallStack.Element = Element;
    class Thread {
        constructor() {
            this.threadIndex = 0;
            this.previousPointer = Pointer_1.Pointer.Null;
            this.callstack = [];
            if (arguments[0] && arguments[1]) {
                let jThreadObj = arguments[0];
                let storyContext = arguments[1];
                // TODO: (int) jThreadObj['threadIndex'] can raise;
                this.threadIndex = parseInt(jThreadObj["threadIndex"]);
                let jThreadCallstack = jThreadObj["callstack"];
                for (let jElTok of jThreadCallstack) {
                    let jElementObj = jElTok;
                    // TODO: (int) jElementObj['type'] can raise;
                    let pushPopType = parseInt(jElementObj["type"]);
                    let pointer = Pointer_1.Pointer.Null;
                    let currentContainerPathStr;
                    // TODO: jElementObj.TryGetValue ("cPath", out currentContainerPathStrToken);
                    let currentContainerPathStrToken = jElementObj["cPath"];
                    if (typeof currentContainerPathStrToken !== "undefined") {
                        currentContainerPathStr = currentContainerPathStrToken.toString();
                        let threadPointerResult = storyContext.ContentAtPath(new Path_1.Path(currentContainerPathStr));
                        pointer.container = threadPointerResult.container;
                        pointer.index = parseInt(jElementObj["idx"]);
                        if (threadPointerResult.obj == null)
                            throw new Error("When loading state, internal story location couldn't be found: " +
                                currentContainerPathStr +
                                ". Has the story changed since this save data was created?");
                        else if (threadPointerResult.approximate) {
                            if (pointer.container === null) {
                                return NullException_1.throwNullException("pointer.container");
                            }
                            storyContext.Warning("When loading state, exact internal story location couldn't be found: '" +
                                currentContainerPathStr +
                                "', so it was approximated to '" +
                                pointer.container.path.toString() +
                                "' to recover. Has the story changed since this save data was created?");
                        }
                    }
                    let inExpressionEvaluation = !!jElementObj["exp"];
                    let el = new Element(pushPopType, pointer, inExpressionEvaluation);
                    let temps = jElementObj["temp"];
                    if (typeof temps !== "undefined") {
                        el.temporaryVariables = JsonSerialisation_1.JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);
                    }
                    else {
                        el.temporaryVariables.clear();
                    }
                    this.callstack.push(el);
                }
                let prevContentObjPath = jThreadObj["previousContentObject"];
                if (typeof prevContentObjPath !== "undefined") {
                    let prevPath = new Path_1.Path(prevContentObjPath.toString());
                    this.previousPointer = storyContext.PointerAtPath(prevPath);
                }
            }
        }
        Copy() {
            let copy = new Thread();
            copy.threadIndex = this.threadIndex;
            for (let e of this.callstack) {
                copy.callstack.push(e.Copy());
            }
            copy.previousPointer = this.previousPointer.copy();
            return copy;
        }
        WriteJson(writer) {
            writer.WriteObjectStart();
            writer.WritePropertyStart("callstack");
            writer.WriteArrayStart();
            for (let el of this.callstack) {
                writer.WriteObjectStart();
                if (!el.currentPointer.isNull) {
                    if (el.currentPointer.container === null) {
                        return NullException_1.throwNullException("el.currentPointer.container");
                    }
                    writer.WriteProperty("cPath", el.currentPointer.container.path.componentsString);
                    writer.WriteIntProperty("idx", el.currentPointer.index);
                }
                writer.WriteProperty("exp", el.inExpressionEvaluation);
                writer.WriteIntProperty("type", el.type);
                if (el.temporaryVariables.size > 0) {
                    writer.WritePropertyStart("temp");
                    JsonSerialisation_1.JsonSerialisation.WriteDictionaryRuntimeObjs(writer, el.temporaryVariables);
                    writer.WritePropertyEnd();
                }
                writer.WriteObjectEnd();
            }
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
            writer.WriteIntProperty("threadIndex", this.threadIndex);
            if (!this.previousPointer.isNull) {
                let resolvedPointer = this.previousPointer.Resolve();
                if (resolvedPointer === null) {
                    return NullException_1.throwNullException("this.previousPointer.Resolve()");
                }
                writer.WriteProperty("previousContentObject", resolvedPointer.path.toString());
            }
            writer.WriteObjectEnd();
        }
    }
    CallStack.Thread = Thread;
})(CallStack = exports.CallStack || (exports.CallStack = {}));
//# sourceMappingURL=CallStack.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Choice.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Choice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Choice = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Choice extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.text = "";
        this.index = 0;
        this.threadAtGeneration = null;
        this.sourcePath = "";
        this.targetPath = null;
        this.isInvisibleDefault = false;
        this.originalThreadIndex = 0;
    }
    get pathStringOnChoice() {
        if (this.targetPath === null)
            return NullException_1.throwNullException("Choice.targetPath");
        return this.targetPath.toString();
    }
    set pathStringOnChoice(value) {
        this.targetPath = new Path_1.Path(value);
    }
}
exports.Choice = Choice;
//# sourceMappingURL=Choice.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ChoicePoint.js":
/*!**************************************************!*\
  !*** ./node_modules/inkjs/engine/ChoicePoint.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoicePoint = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ChoicePoint extends Object_1.InkObject {
    constructor(onceOnly = true) {
        super();
        this._pathOnChoice = null;
        this.hasCondition = false;
        this.hasStartContent = false;
        this.hasChoiceOnlyContent = false;
        this.isInvisibleDefault = false;
        this.onceOnly = true;
        this.onceOnly = onceOnly;
    }
    get pathOnChoice() {
        if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {
            let choiceTargetObj = this.choiceTarget;
            if (choiceTargetObj) {
                this._pathOnChoice = choiceTargetObj.path;
            }
        }
        return this._pathOnChoice;
    }
    set pathOnChoice(value) {
        this._pathOnChoice = value;
    }
    get choiceTarget() {
        if (this._pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint._pathOnChoice");
        return this.ResolvePath(this._pathOnChoice).container;
    }
    get pathStringOnChoice() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        return this.CompactPathString(this.pathOnChoice);
    }
    set pathStringOnChoice(value) {
        this.pathOnChoice = new Path_1.Path(value);
    }
    get flags() {
        let flags = 0;
        if (this.hasCondition)
            flags |= 1;
        if (this.hasStartContent)
            flags |= 2;
        if (this.hasChoiceOnlyContent)
            flags |= 4;
        if (this.isInvisibleDefault)
            flags |= 8;
        if (this.onceOnly)
            flags |= 16;
        return flags;
    }
    set flags(value) {
        this.hasCondition = (value & 1) > 0;
        this.hasStartContent = (value & 2) > 0;
        this.hasChoiceOnlyContent = (value & 4) > 0;
        this.isInvisibleDefault = (value & 8) > 0;
        this.onceOnly = (value & 16) > 0;
    }
    toString() {
        if (this.pathOnChoice === null)
            return NullException_1.throwNullException("ChoicePoint.pathOnChoice");
        // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);
        let targetLineNum = null;
        let targetString = this.pathOnChoice.toString();
        if (targetLineNum != null) {
            targetString = " line " + targetLineNum + "(" + targetString + ")";
        }
        return "Choice: -> " + targetString;
    }
}
exports.ChoicePoint = ChoicePoint;
//# sourceMappingURL=ChoicePoint.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Container.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/Container.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const SearchResult_1 = __webpack_require__(/*! ./SearchResult */ "./node_modules/inkjs/engine/SearchResult.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
class Container extends Object_1.InkObject {
    constructor() {
        super(...arguments);
        this.name = "";
        this._content = [];
        this.namedContent = new Map();
        this.visitsShouldBeCounted = false;
        this.turnIndexShouldBeCounted = false;
        this.countingAtStartOnly = false;
        this._pathToFirstLeafContent = null;
    }
    get hasValidName() {
        return this.name != null && this.name.length > 0;
    }
    get content() {
        return this._content;
    }
    set content(value) {
        this.AddContent(value);
    }
    get namedOnlyContent() {
        let namedOnlyContentDict = new Map();
        for (let [key, value] of this.namedContent) {
            let inkObject = TypeAssertion_1.asOrThrows(value, Object_1.InkObject);
            namedOnlyContentDict.set(key, inkObject);
        }
        for (let c of this.content) {
            let named = TypeAssertion_1.asINamedContentOrNull(c);
            if (named != null && named.hasValidName) {
                namedOnlyContentDict.delete(named.name);
            }
        }
        if (namedOnlyContentDict.size == 0)
            namedOnlyContentDict = null;
        return namedOnlyContentDict;
    }
    set namedOnlyContent(value) {
        let existingNamedOnly = this.namedOnlyContent;
        if (existingNamedOnly != null) {
            for (let [key] of existingNamedOnly) {
                this.namedContent.delete(key);
            }
        }
        if (value == null)
            return;
        for (let [, val] of value) {
            let named = TypeAssertion_1.asINamedContentOrNull(val);
            if (named != null)
                this.AddToNamedContentOnly(named);
        }
    }
    get countFlags() {
        let flags = 0;
        if (this.visitsShouldBeCounted)
            flags |= Container.CountFlags.Visits;
        if (this.turnIndexShouldBeCounted)
            flags |= Container.CountFlags.Turns;
        if (this.countingAtStartOnly)
            flags |= Container.CountFlags.CountStartOnly;
        if (flags == Container.CountFlags.CountStartOnly) {
            flags = 0;
        }
        return flags;
    }
    set countFlags(value) {
        let flag = value;
        if ((flag & Container.CountFlags.Visits) > 0)
            this.visitsShouldBeCounted = true;
        if ((flag & Container.CountFlags.Turns) > 0)
            this.turnIndexShouldBeCounted = true;
        if ((flag & Container.CountFlags.CountStartOnly) > 0)
            this.countingAtStartOnly = true;
    }
    get pathToFirstLeafContent() {
        if (this._pathToFirstLeafContent == null)
            this._pathToFirstLeafContent = this.path.PathByAppendingPath(this.internalPathToFirstLeafContent);
        return this._pathToFirstLeafContent;
    }
    get internalPathToFirstLeafContent() {
        let components = [];
        let container = this;
        while (container instanceof Container) {
            if (container.content.length > 0) {
                components.push(new Path_1.Path.Component(0));
                container = container.content[0];
            }
        }
        return new Path_1.Path(components);
    }
    AddContent(contentObjOrList) {
        if (contentObjOrList instanceof Array) {
            let contentList = contentObjOrList;
            for (let c of contentList) {
                this.AddContent(c);
            }
        }
        else {
            let contentObj = contentObjOrList;
            this._content.push(contentObj);
            if (contentObj.parent) {
                throw new Error("content is already in " + contentObj.parent);
            }
            contentObj.parent = this;
            this.TryAddNamedContent(contentObj);
        }
    }
    TryAddNamedContent(contentObj) {
        let namedContentObj = TypeAssertion_1.asINamedContentOrNull(contentObj);
        if (namedContentObj != null && namedContentObj.hasValidName) {
            this.AddToNamedContentOnly(namedContentObj);
        }
    }
    AddToNamedContentOnly(namedContentObj) {
        Debug_1.Debug.AssertType(namedContentObj, Object_1.InkObject, "Can only add Runtime.Objects to a Runtime.Container");
        let runtimeObj = TypeAssertion_1.asOrThrows(namedContentObj, Object_1.InkObject);
        runtimeObj.parent = this;
        this.namedContent.set(namedContentObj.name, namedContentObj);
    }
    ContentAtPath(path, partialPathStart = 0, partialPathLength = -1) {
        if (partialPathLength == -1)
            partialPathLength = path.length;
        let result = new SearchResult_1.SearchResult();
        result.approximate = false;
        let currentContainer = this;
        let currentObj = this;
        for (let i = partialPathStart; i < partialPathLength; ++i) {
            let comp = path.GetComponent(i);
            if (currentContainer == null) {
                result.approximate = true;
                break;
            }
            let foundObj = currentContainer.ContentWithPathComponent(comp);
            if (foundObj == null) {
                result.approximate = true;
                break;
            }
            currentObj = foundObj;
            currentContainer = TypeAssertion_1.asOrNull(foundObj, Container);
        }
        result.obj = currentObj;
        return result;
    }
    InsertContent(contentObj, index) {
        this.content[index] = contentObj;
        if (contentObj.parent) {
            throw new Error("content is already in " + contentObj.parent);
        }
        contentObj.parent = this;
        this.TryAddNamedContent(contentObj);
    }
    AddContentsOfContainer(otherContainer) {
        this.content = this.content.concat(otherContainer.content);
        for (let obj of otherContainer.content) {
            obj.parent = this;
            this.TryAddNamedContent(obj);
        }
    }
    ContentWithPathComponent(component) {
        if (component.isIndex) {
            if (component.index >= 0 && component.index < this.content.length) {
                return this.content[component.index];
            }
            else {
                return null;
            }
        }
        else if (component.isParent) {
            return this.parent;
        }
        else {
            if (component.name === null) {
                return NullException_1.throwNullException("component.name");
            }
            let foundContent = TryGetResult_1.tryGetValueFromMap(this.namedContent, component.name, null);
            if (foundContent.exists) {
                return TypeAssertion_1.asOrThrows(foundContent.result, Object_1.InkObject);
            }
            else {
                return null;
            }
        }
    }
    BuildStringOfHierarchy() {
        let sb;
        if (arguments.length == 0) {
            sb = new StringBuilder_1.StringBuilder();
            this.BuildStringOfHierarchy(sb, 0, null);
            return sb.toString();
        }
        sb = arguments[0];
        let indentation = arguments[1];
        let pointedObj = arguments[2];
        function appendIndentation() {
            const spacesPerIndent = 4; // Truly const in the original code
            for (let i = 0; i < spacesPerIndent * indentation; ++i) {
                sb.Append(" ");
            }
        }
        appendIndentation();
        sb.Append("[");
        if (this.hasValidName) {
            sb.AppendFormat(" ({0})", this.name);
        }
        if (this == pointedObj) {
            sb.Append("  <---");
        }
        sb.AppendLine();
        indentation++;
        for (let i = 0; i < this.content.length; ++i) {
            let obj = this.content[i];
            if (obj instanceof Container) {
                let container = obj;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
            }
            else {
                appendIndentation();
                if (obj instanceof Value_1.StringValue) {
                    sb.Append('"');
                    sb.Append(obj.toString().replace("\n", "\\n"));
                    sb.Append('"');
                }
                else {
                    sb.Append(obj.toString());
                }
            }
            if (i != this.content.length - 1) {
                sb.Append(",");
            }
            if (!(obj instanceof Container) && obj == pointedObj) {
                sb.Append("  <---");
            }
            sb.AppendLine();
        }
        let onlyNamed = new Map();
        for (let [key, value] of this.namedContent) {
            if (this.content.indexOf(TypeAssertion_1.asOrThrows(value, Object_1.InkObject)) >= 0) {
                continue;
            }
            else {
                onlyNamed.set(key, value);
            }
        }
        if (onlyNamed.size > 0) {
            appendIndentation();
            sb.AppendLine("-- named: --");
            for (let [, value] of onlyNamed) {
                Debug_1.Debug.AssertType(value, Container, "Can only print out named Containers");
                let container = value;
                container.BuildStringOfHierarchy(sb, indentation, pointedObj);
                sb.AppendLine();
            }
        }
        indentation--;
        appendIndentation();
        sb.Append("]");
    }
}
exports.Container = Container;
(function (Container) {
    let CountFlags;
    (function (CountFlags) {
        CountFlags[CountFlags["Visits"] = 1] = "Visits";
        CountFlags[CountFlags["Turns"] = 2] = "Turns";
        CountFlags[CountFlags["CountStartOnly"] = 4] = "CountStartOnly";
    })(CountFlags = Container.CountFlags || (Container.CountFlags = {}));
})(Container = exports.Container || (exports.Container = {}));
//# sourceMappingURL=Container.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ControlCommand.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ControlCommand.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlCommand = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class ControlCommand extends Object_1.InkObject {
    constructor(commandType = ControlCommand.CommandType.NotSet) {
        super();
        this._commandType = commandType;
    }
    get commandType() {
        return this._commandType;
    }
    Copy() {
        return new ControlCommand(this.commandType);
    }
    static EvalStart() {
        return new ControlCommand(ControlCommand.CommandType.EvalStart);
    }
    static EvalOutput() {
        return new ControlCommand(ControlCommand.CommandType.EvalOutput);
    }
    static EvalEnd() {
        return new ControlCommand(ControlCommand.CommandType.EvalEnd);
    }
    static Duplicate() {
        return new ControlCommand(ControlCommand.CommandType.Duplicate);
    }
    static PopEvaluatedValue() {
        return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);
    }
    static PopFunction() {
        return new ControlCommand(ControlCommand.CommandType.PopFunction);
    }
    static PopTunnel() {
        return new ControlCommand(ControlCommand.CommandType.PopTunnel);
    }
    static BeginString() {
        return new ControlCommand(ControlCommand.CommandType.BeginString);
    }
    static EndString() {
        return new ControlCommand(ControlCommand.CommandType.EndString);
    }
    static NoOp() {
        return new ControlCommand(ControlCommand.CommandType.NoOp);
    }
    static ChoiceCount() {
        return new ControlCommand(ControlCommand.CommandType.ChoiceCount);
    }
    static Turns() {
        return new ControlCommand(ControlCommand.CommandType.Turns);
    }
    static TurnsSince() {
        return new ControlCommand(ControlCommand.CommandType.TurnsSince);
    }
    static ReadCount() {
        return new ControlCommand(ControlCommand.CommandType.ReadCount);
    }
    static Random() {
        return new ControlCommand(ControlCommand.CommandType.Random);
    }
    static SeedRandom() {
        return new ControlCommand(ControlCommand.CommandType.SeedRandom);
    }
    static VisitIndex() {
        return new ControlCommand(ControlCommand.CommandType.VisitIndex);
    }
    static SequenceShuffleIndex() {
        return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);
    }
    static StartThread() {
        return new ControlCommand(ControlCommand.CommandType.StartThread);
    }
    static Done() {
        return new ControlCommand(ControlCommand.CommandType.Done);
    }
    static End() {
        return new ControlCommand(ControlCommand.CommandType.End);
    }
    static ListFromInt() {
        return new ControlCommand(ControlCommand.CommandType.ListFromInt);
    }
    static ListRange() {
        return new ControlCommand(ControlCommand.CommandType.ListRange);
    }
    static ListRandom() {
        return new ControlCommand(ControlCommand.CommandType.ListRandom);
    }
    toString() {
        return this.commandType.toString();
    }
}
exports.ControlCommand = ControlCommand;
(function (ControlCommand) {
    let CommandType;
    (function (CommandType) {
        CommandType[CommandType["NotSet"] = -1] = "NotSet";
        CommandType[CommandType["EvalStart"] = 0] = "EvalStart";
        CommandType[CommandType["EvalOutput"] = 1] = "EvalOutput";
        CommandType[CommandType["EvalEnd"] = 2] = "EvalEnd";
        CommandType[CommandType["Duplicate"] = 3] = "Duplicate";
        CommandType[CommandType["PopEvaluatedValue"] = 4] = "PopEvaluatedValue";
        CommandType[CommandType["PopFunction"] = 5] = "PopFunction";
        CommandType[CommandType["PopTunnel"] = 6] = "PopTunnel";
        CommandType[CommandType["BeginString"] = 7] = "BeginString";
        CommandType[CommandType["EndString"] = 8] = "EndString";
        CommandType[CommandType["NoOp"] = 9] = "NoOp";
        CommandType[CommandType["ChoiceCount"] = 10] = "ChoiceCount";
        CommandType[CommandType["Turns"] = 11] = "Turns";
        CommandType[CommandType["TurnsSince"] = 12] = "TurnsSince";
        CommandType[CommandType["Random"] = 13] = "Random";
        CommandType[CommandType["SeedRandom"] = 14] = "SeedRandom";
        CommandType[CommandType["VisitIndex"] = 15] = "VisitIndex";
        CommandType[CommandType["SequenceShuffleIndex"] = 16] = "SequenceShuffleIndex";
        CommandType[CommandType["StartThread"] = 17] = "StartThread";
        CommandType[CommandType["Done"] = 18] = "Done";
        CommandType[CommandType["End"] = 19] = "End";
        CommandType[CommandType["ListFromInt"] = 20] = "ListFromInt";
        CommandType[CommandType["ListRange"] = 21] = "ListRange";
        CommandType[CommandType["ListRandom"] = 22] = "ListRandom";
        CommandType[CommandType["ReadCount"] = 23] = "ReadCount";
        CommandType[CommandType["TOTAL_VALUES"] = 24] = "TOTAL_VALUES";
    })(CommandType = ControlCommand.CommandType || (ControlCommand.CommandType = {}));
})(ControlCommand = exports.ControlCommand || (exports.ControlCommand = {}));
//# sourceMappingURL=ControlCommand.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Debug.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Debug.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Debug = void 0;
var Debug;
(function (Debug) {
    function AssertType(variable, type, message) {
        Assert(variable instanceof type, message);
    }
    Debug.AssertType = AssertType;
    function Assert(condition, message) {
        if (!condition) {
            if (typeof message !== "undefined") {
                console.warn(message);
            }
            if (console.trace) {
                console.trace();
            }
            throw new Error("");
        }
    }
    Debug.Assert = Assert;
})(Debug = exports.Debug || (exports.Debug = {}));
//# sourceMappingURL=Debug.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Divert.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Divert.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Divert = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class Divert extends Object_1.InkObject {
    constructor(stackPushType) {
        super();
        this._targetPath = null;
        this._targetPointer = Pointer_1.Pointer.Null;
        this.variableDivertName = null;
        this.pushesToStack = false;
        this.stackPushType = 0;
        this.isExternal = false;
        this.externalArgs = 0;
        this.isConditional = false;
        this.pushesToStack = false;
        if (typeof stackPushType !== "undefined") {
            this.pushesToStack = true;
            this.stackPushType = stackPushType;
        }
    }
    get targetPath() {
        if (this._targetPath != null && this._targetPath.isRelative) {
            let targetObj = this.targetPointer.Resolve();
            if (targetObj) {
                this._targetPath = targetObj.path;
            }
        }
        return this._targetPath;
    }
    set targetPath(value) {
        this._targetPath = value;
        this._targetPointer = Pointer_1.Pointer.Null;
    }
    get targetPointer() {
        if (this._targetPointer.isNull) {
            let targetObj = this.ResolvePath(this._targetPath).obj;
            if (this._targetPath === null)
                return NullException_1.throwNullException("this._targetPath");
            if (this._targetPath.lastComponent === null)
                return NullException_1.throwNullException("this._targetPath.lastComponent");
            if (this._targetPath.lastComponent.isIndex) {
                if (targetObj === null)
                    return NullException_1.throwNullException("targetObj");
                this._targetPointer.container =
                    targetObj.parent instanceof Container_1.Container ? targetObj.parent : null;
                this._targetPointer.index = this._targetPath.lastComponent.index;
            }
            else {
                this._targetPointer = Pointer_1.Pointer.StartOf(targetObj instanceof Container_1.Container ? targetObj : null);
            }
        }
        return this._targetPointer.copy();
    }
    get targetPathString() {
        if (this.targetPath == null)
            return null;
        return this.CompactPathString(this.targetPath);
    }
    set targetPathString(value) {
        if (value == null) {
            this.targetPath = null;
        }
        else {
            this.targetPath = new Path_1.Path(value);
        }
    }
    get hasVariableTarget() {
        return this.variableDivertName != null;
    }
    Equals(obj) {
        let otherDivert = obj;
        if (otherDivert instanceof Divert) {
            if (this.hasVariableTarget == otherDivert.hasVariableTarget) {
                if (this.hasVariableTarget) {
                    return this.variableDivertName == otherDivert.variableDivertName;
                }
                else {
                    if (this.targetPath === null)
                        return NullException_1.throwNullException("this.targetPath");
                    return this.targetPath.Equals(otherDivert.targetPath);
                }
            }
        }
        return false;
    }
    toString() {
        if (this.hasVariableTarget) {
            return "Divert(variable: " + this.variableDivertName + ")";
        }
        else if (this.targetPath == null) {
            return "Divert(null)";
        }
        else {
            let sb = new StringBuilder_1.StringBuilder();
            let targetStr = this.targetPath.toString();
            // int? targetLineNum = DebugLineNumberOfPath (targetPath);
            let targetLineNum = null;
            if (targetLineNum != null) {
                targetStr = "line " + targetLineNum;
            }
            sb.Append("Divert");
            if (this.isConditional)
                sb.Append("?");
            if (this.pushesToStack) {
                if (this.stackPushType == PushPop_1.PushPopType.Function) {
                    sb.Append(" function");
                }
                else {
                    sb.Append(" tunnel");
                }
            }
            sb.Append(" -> ");
            sb.Append(this.targetPathString);
            sb.Append(" (");
            sb.Append(targetStr);
            sb.Append(")");
            return sb.toString();
        }
    }
}
exports.Divert = Divert;
//# sourceMappingURL=Divert.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Glue.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Glue.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Glue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Glue extends Object_1.InkObject {
    toString() {
        return "Glue";
    }
}
exports.Glue = Glue;
//# sourceMappingURL=Glue.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/InkList.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/InkList.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkList = exports.InkListItem = void 0;
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
class InkListItem {
    constructor() {
        // InkListItem is a struct
        this.originName = null;
        this.itemName = null;
        if (typeof arguments[1] !== "undefined") {
            let originName = arguments[0];
            let itemName = arguments[1];
            this.originName = originName;
            this.itemName = itemName;
        }
        else if (arguments[0]) {
            let fullName = arguments[0];
            let nameParts = fullName.toString().split(".");
            this.originName = nameParts[0];
            this.itemName = nameParts[1];
        }
    }
    static get Null() {
        return new InkListItem(null, null);
    }
    get isNull() {
        return this.originName == null && this.itemName == null;
    }
    get fullName() {
        return ((this.originName !== null ? this.originName : "?") + "." + this.itemName);
    }
    toString() {
        return this.fullName;
    }
    Equals(obj) {
        if (obj instanceof InkListItem) {
            let otherItem = obj;
            return (otherItem.itemName == this.itemName &&
                otherItem.originName == this.originName);
        }
        return false;
    }
    // These methods did not exist in the original C# code. Their purpose is to
    // make `InkListItem` mimics the value-type semantics of the original
    // struct. Please refer to the end of this file, for a more in-depth
    // explanation.
    /**
     * Returns a shallow clone of the current instance.
     */
    copy() {
        return new InkListItem(this.originName, this.itemName);
    }
    /**
     * Returns a `SerializedInkListItem` representing the current
     * instance. The result is intended to be used as a key inside a Map.
     */
    serialized() {
        // We are simply using a JSON representation as a value-typed key.
        return JSON.stringify({
            originName: this.originName,
            itemName: this.itemName,
        });
    }
    /**
     * Reconstructs a `InkListItem` from the given SerializedInkListItem.
     */
    static fromSerializedKey(key) {
        let obj = JSON.parse(key);
        if (!InkListItem.isLikeInkListItem(obj))
            return InkListItem.Null;
        let inkListItem = obj;
        return new InkListItem(inkListItem.originName, inkListItem.itemName);
    }
    /**
     * Determines whether the given item is sufficiently `InkListItem`-like
     * to be used as a template when reconstructing the InkListItem.
     */
    static isLikeInkListItem(item) {
        if (typeof item !== "object")
            return false;
        if (!item.hasOwnProperty("originName") || !item.hasOwnProperty("itemName"))
            return false;
        if (typeof item.originName !== "string" && typeof item.originName !== null)
            return false;
        if (typeof item.itemName !== "string" && typeof item.itemName !== null)
            return false;
        return true;
    }
}
exports.InkListItem = InkListItem;
class InkList extends Map {
    constructor() {
        // Trying to be smart here, this emulates the constructor inheritance found
        // in the original code, but only if otherList is an InkList. IIFE FTW.
        super((() => {
            if (arguments[0] instanceof InkList) {
                return arguments[0];
            }
            else {
                return [];
            }
        })());
        this.origins = null;
        this._originNames = [];
        if (arguments[0] instanceof InkList) {
            let otherList = arguments[0];
            if (otherList._originNames) {
                this._originNames = otherList._originNames.slice();
            }
        }
        else if (typeof arguments[0] === "string") {
            let singleOriginListName = arguments[0];
            let originStory = arguments[1]; /* as Story */
            this.SetInitialOriginName(singleOriginListName);
            let def = originStory.listDefinitions.TryListGetDefinition(singleOriginListName, null);
            if (def.exists) {
                this.origins = [def.result];
            }
            else {
                throw new Error("InkList origin could not be found in story when constructing new list: " +
                    singleOriginListName);
            }
        }
        else if (typeof arguments[0] === "object" &&
            arguments[0].hasOwnProperty("Key") &&
            arguments[0].hasOwnProperty("Value")) {
            let singleElement = arguments[0];
            this.Add(singleElement.Key, singleElement.Value);
        }
    }
    AddItem(itemOrItemName) {
        if (itemOrItemName instanceof InkListItem) {
            let item = itemOrItemName;
            if (item.originName == null) {
                this.AddItem(item.itemName);
                return;
            }
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (origin.name == item.originName) {
                    let intVal = origin.TryGetValueForItem(item, 0);
                    if (intVal.exists) {
                        this.Add(item, intVal.result);
                        return;
                    }
                    else {
                        throw new Error("Could not add the item " +
                            item +
                            " to this list because it doesn't exist in the original list definition in ink.");
                    }
                }
            }
            throw new Error("Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.");
        }
        else {
            let itemName = itemOrItemName;
            let foundListDef = null;
            if (this.origins === null)
                return NullException_1.throwNullException("this.origins");
            for (let origin of this.origins) {
                if (itemName === null)
                    return NullException_1.throwNullException("itemName");
                if (origin.ContainsItemWithName(itemName)) {
                    if (foundListDef != null) {
                        throw new Error("Could not add the item " +
                            itemName +
                            " to this list because it could come from either " +
                            origin.name +
                            " or " +
                            foundListDef.name);
                    }
                    else {
                        foundListDef = origin;
                    }
                }
            }
            if (foundListDef == null)
                throw new Error("Could not add the item " +
                    itemName +
                    " to this list because it isn't known to any list definitions previously associated with this list.");
            let item = new InkListItem(foundListDef.name, itemName);
            let itemVal = foundListDef.ValueForItem(item);
            this.Add(item, itemVal);
        }
    }
    ContainsItemNamed(itemName) {
        for (let [key] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (item.itemName == itemName)
                return true;
        }
        return false;
    }
    ContainsKey(key) {
        return this.has(key.serialized());
    }
    Add(key, value) {
        let serializedKey = key.serialized();
        if (this.has(serializedKey)) {
            // Throw an exception to match the C# behavior.
            throw new Error(`The Map already contains an entry for ${key}`);
        }
        this.set(serializedKey, value);
    }
    Remove(key) {
        return this.delete(key.serialized());
    }
    get Count() {
        return this.size;
    }
    get originOfMaxItem() {
        if (this.origins == null)
            return null;
        let maxOriginName = this.maxItem.Key.originName;
        let result = null;
        this.origins.every((origin) => {
            if (origin.name == maxOriginName) {
                result = origin;
                return false;
            }
            else
                return true;
        });
        return result;
    }
    get originNames() {
        if (this.Count > 0) {
            if (this._originNames == null && this.Count > 0)
                this._originNames = [];
            else {
                if (!this._originNames)
                    this._originNames = [];
                this._originNames.length = 0;
            }
            for (let [key] of this) {
                let item = InkListItem.fromSerializedKey(key);
                if (item.originName === null)
                    return NullException_1.throwNullException("item.originName");
                this._originNames.push(item.originName);
            }
        }
        return this._originNames;
    }
    SetInitialOriginName(initialOriginName) {
        this._originNames = [initialOriginName];
    }
    SetInitialOriginNames(initialOriginNames) {
        if (initialOriginNames == null)
            this._originNames = null;
        else
            this._originNames = initialOriginNames.slice(); // store a copy
    }
    get maxItem() {
        let max = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (max.Key.isNull || value > max.Value)
                max = { Key: item, Value: value };
        }
        return max;
    }
    get minItem() {
        let min = {
            Key: InkListItem.Null,
            Value: 0,
        };
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            if (min.Key.isNull || value < min.Value) {
                min = { Key: item, Value: value };
            }
        }
        return min;
    }
    get inverse() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    if (!this.ContainsKey(item))
                        list.Add(item, value);
                }
            }
        }
        return list;
    }
    get all() {
        let list = new InkList();
        if (this.origins != null) {
            for (let origin of this.origins) {
                for (let [key, value] of origin.items) {
                    let item = InkListItem.fromSerializedKey(key);
                    list.set(item.serialized(), value);
                }
            }
        }
        return list;
    }
    Union(otherList) {
        let union = new InkList(this);
        for (let [key, value] of otherList) {
            union.set(key, value);
        }
        return union;
    }
    Intersect(otherList) {
        let intersection = new InkList();
        for (let [key, value] of this) {
            if (otherList.has(key))
                intersection.set(key, value);
        }
        return intersection;
    }
    Without(listToRemove) {
        let result = new InkList(this);
        for (let [key] of listToRemove) {
            result.delete(key);
        }
        return result;
    }
    Contains(otherList) {
        for (let [key] of otherList) {
            if (!this.has(key))
                return false;
        }
        return true;
    }
    GreaterThan(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return this.minItem.Value > otherList.maxItem.Value;
    }
    GreaterThanOrEquals(otherList) {
        if (this.Count == 0)
            return false;
        if (otherList.Count == 0)
            return true;
        return (this.minItem.Value >= otherList.minItem.Value &&
            this.maxItem.Value >= otherList.maxItem.Value);
    }
    LessThan(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return this.maxItem.Value < otherList.minItem.Value;
    }
    LessThanOrEquals(otherList) {
        if (otherList.Count == 0)
            return false;
        if (this.Count == 0)
            return true;
        return (this.maxItem.Value <= otherList.maxItem.Value &&
            this.minItem.Value <= otherList.minItem.Value);
    }
    MaxAsList() {
        if (this.Count > 0)
            return new InkList(this.maxItem);
        else
            return new InkList();
    }
    MinAsList() {
        if (this.Count > 0)
            return new InkList(this.minItem);
        else
            return new InkList();
    }
    ListWithSubRange(minBound, maxBound) {
        if (this.Count == 0)
            return new InkList();
        let ordered = this.orderedItems;
        let minValue = 0;
        let maxValue = Number.MAX_SAFE_INTEGER;
        if (Number.isInteger(minBound)) {
            minValue = minBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                minValue = minBound.minItem.Value;
        }
        if (Number.isInteger(maxBound)) {
            maxValue = maxBound;
        }
        else {
            if (minBound instanceof InkList && minBound.Count > 0)
                maxValue = maxBound.maxItem.Value;
        }
        let subList = new InkList();
        subList.SetInitialOriginNames(this.originNames);
        for (let item of ordered) {
            if (item.Value >= minValue && item.Value <= maxValue) {
                subList.Add(item.Key, item.Value);
            }
        }
        return subList;
    }
    Equals(otherInkList) {
        if (otherInkList instanceof InkList === false)
            return false;
        if (otherInkList.Count != this.Count)
            return false;
        for (let [key] of this) {
            if (!otherInkList.has(key))
                return false;
        }
        return true;
    }
    // GetHashCode not implemented
    get orderedItems() {
        // List<KeyValuePair<InkListItem, int>>
        let ordered = new Array();
        for (let [key, value] of this) {
            let item = InkListItem.fromSerializedKey(key);
            ordered.push({ Key: item, Value: value });
        }
        ordered.sort((x, y) => {
            if (x.Key.originName === null) {
                return NullException_1.throwNullException("x.Key.originName");
            }
            if (y.Key.originName === null) {
                return NullException_1.throwNullException("y.Key.originName");
            }
            if (x.Value == y.Value) {
                return x.Key.originName.localeCompare(y.Key.originName);
            }
            else {
                // TODO: refactor this bit into a numberCompareTo method?
                if (x.Value < y.Value)
                    return -1;
                return x.Value > y.Value ? 1 : 0;
            }
        });
        return ordered;
    }
    toString() {
        let ordered = this.orderedItems;
        let sb = new StringBuilder_1.StringBuilder();
        for (let i = 0; i < ordered.length; i++) {
            if (i > 0)
                sb.Append(", ");
            let item = ordered[i].Key;
            if (item.itemName === null)
                return NullException_1.throwNullException("item.itemName");
            sb.Append(item.itemName);
        }
        return sb.toString();
    }
    // casting a InkList to a Number, for somereason, actually gives a number.
    // This messes up the type detection when creating a Value from a InkList.
    // Returning NaN here prevents that.
    valueOf() {
        return NaN;
    }
}
exports.InkList = InkList;
//# sourceMappingURL=InkList.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/JsonSerialisation.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/JsonSerialisation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerialisation = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const ListDefinition_1 = __webpack_require__(/*! ./ListDefinition */ "./node_modules/inkjs/engine/ListDefinition.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class JsonSerialisation {
    static JArrayToRuntimeObjList(jArray, skipLast = false) {
        let count = jArray.length;
        if (skipLast)
            count--;
        let list = [];
        for (let i = 0; i < count; i++) {
            let jTok = jArray[i];
            let runtimeObj = this.JTokenToRuntimeObject(jTok);
            if (runtimeObj === null) {
                return NullException_1.throwNullException("runtimeObj");
            }
            list.push(runtimeObj);
        }
        return list;
    }
    static WriteDictionaryRuntimeObjs(writer, dictionary) {
        writer.WriteObjectStart();
        for (let [key, value] of dictionary) {
            writer.WritePropertyStart(key);
            this.WriteRuntimeObject(writer, value);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static WriteListRuntimeObjs(writer, list) {
        writer.WriteArrayStart();
        for (let value of list) {
            this.WriteRuntimeObject(writer, value);
        }
        writer.WriteArrayEnd();
    }
    static WriteIntDictionary(writer, dict) {
        writer.WriteObjectStart();
        for (let [key, value] of dict) {
            writer.WriteIntProperty(key, value);
        }
        writer.WriteObjectEnd();
    }
    static WriteRuntimeObject(writer, obj) {
        let container = TypeAssertion_1.asOrNull(obj, Container_1.Container);
        if (container) {
            this.WriteRuntimeContainer(writer, container);
            return;
        }
        let divert = TypeAssertion_1.asOrNull(obj, Divert_1.Divert);
        if (divert) {
            let divTypeKey = "->";
            if (divert.isExternal) {
                divTypeKey = "x()";
            }
            else if (divert.pushesToStack) {
                if (divert.stackPushType == PushPop_1.PushPopType.Function) {
                    divTypeKey = "f()";
                }
                else if (divert.stackPushType == PushPop_1.PushPopType.Tunnel) {
                    divTypeKey = "->t->";
                }
            }
            let targetStr;
            if (divert.hasVariableTarget) {
                targetStr = divert.variableDivertName;
            }
            else {
                targetStr = divert.targetPathString;
            }
            writer.WriteObjectStart();
            writer.WriteProperty(divTypeKey, targetStr);
            if (divert.hasVariableTarget) {
                writer.WriteProperty("var", true);
            }
            if (divert.isConditional) {
                writer.WriteProperty("c", true);
            }
            if (divert.externalArgs > 0) {
                writer.WriteIntProperty("exArgs", divert.externalArgs);
            }
            writer.WriteObjectEnd();
            return;
        }
        let choicePoint = TypeAssertion_1.asOrNull(obj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            writer.WriteObjectStart();
            writer.WriteProperty("*", choicePoint.pathStringOnChoice);
            writer.WriteIntProperty("flg", choicePoint.flags);
            writer.WriteObjectEnd();
            return;
        }
        let intVal = TypeAssertion_1.asOrNull(obj, Value_1.IntValue);
        if (intVal) {
            writer.WriteInt(intVal.value);
            return;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj, Value_1.FloatValue);
        if (floatVal) {
            writer.WriteFloat(floatVal.value);
            return;
        }
        let strVal = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (strVal) {
            if (strVal.isNewline) {
                writer.Write("\n", false);
            }
            else {
                writer.WriteStringStart();
                writer.WriteStringInner("^");
                writer.WriteStringInner(strVal.value);
                writer.WriteStringEnd();
            }
            return;
        }
        let listVal = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listVal) {
            this.WriteInkList(writer, listVal);
            return;
        }
        let divTargetVal = TypeAssertion_1.asOrNull(obj, Value_1.DivertTargetValue);
        if (divTargetVal) {
            writer.WriteObjectStart();
            if (divTargetVal.value === null) {
                return NullException_1.throwNullException("divTargetVal.value");
            }
            writer.WriteProperty("^->", divTargetVal.value.componentsString);
            writer.WriteObjectEnd();
            return;
        }
        let varPtrVal = TypeAssertion_1.asOrNull(obj, Value_1.VariablePointerValue);
        if (varPtrVal) {
            writer.WriteObjectStart();
            writer.WriteProperty("^var", varPtrVal.value);
            writer.WriteIntProperty("ci", varPtrVal.contextIndex);
            writer.WriteObjectEnd();
            return;
        }
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        if (glue) {
            writer.Write("<>");
            return;
        }
        let controlCmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
        if (controlCmd) {
            writer.Write(JsonSerialisation._controlCommandNames[controlCmd.commandType]);
            return;
        }
        let nativeFunc = TypeAssertion_1.asOrNull(obj, NativeFunctionCall_1.NativeFunctionCall);
        if (nativeFunc) {
            let name = nativeFunc.name;
            if (name == "^")
                name = "L^";
            writer.Write(name);
            return;
        }
        let varRef = TypeAssertion_1.asOrNull(obj, VariableReference_1.VariableReference);
        if (varRef) {
            writer.WriteObjectStart();
            let readCountPath = varRef.pathStringForCount;
            if (readCountPath != null) {
                writer.WriteProperty("CNT?", readCountPath);
            }
            else {
                writer.WriteProperty("VAR?", varRef.name);
            }
            writer.WriteObjectEnd();
            return;
        }
        let varAss = TypeAssertion_1.asOrNull(obj, VariableAssignment_1.VariableAssignment);
        if (varAss) {
            writer.WriteObjectStart();
            let key = varAss.isGlobal ? "VAR=" : "temp=";
            writer.WriteProperty(key, varAss.variableName);
            // Reassignment?
            if (!varAss.isNewDeclaration)
                writer.WriteProperty("re", true);
            writer.WriteObjectEnd();
            return;
        }
        let voidObj = TypeAssertion_1.asOrNull(obj, Void_1.Void);
        if (voidObj) {
            writer.Write("void");
            return;
        }
        let tag = TypeAssertion_1.asOrNull(obj, Tag_1.Tag);
        if (tag) {
            writer.WriteObjectStart();
            writer.WriteProperty("#", tag.text);
            writer.WriteObjectEnd();
            return;
        }
        let choice = TypeAssertion_1.asOrNull(obj, Choice_1.Choice);
        if (choice) {
            this.WriteChoice(writer, choice);
            return;
        }
        throw new Error("Failed to convert runtime object to Json token: " + obj);
    }
    static JObjectToDictionaryRuntimeObjs(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                let inkObject = this.JTokenToRuntimeObject(jObject[key]);
                if (inkObject === null) {
                    return NullException_1.throwNullException("inkObject");
                }
                dict.set(key, inkObject);
            }
        }
        return dict;
    }
    static JObjectToIntDictionary(jObject) {
        let dict = new Map();
        for (let key in jObject) {
            if (jObject.hasOwnProperty(key)) {
                dict.set(key, parseInt(jObject[key]));
            }
        }
        return dict;
    }
    static JTokenToRuntimeObject(token) {
        if (typeof token === "number" && !isNaN(token)) {
            return Value_1.Value.Create(token);
        }
        if (typeof token === "string") {
            let str = token.toString();
            // String value
            let firstChar = str[0];
            if (firstChar == "^")
                return new Value_1.StringValue(str.substring(1));
            else if (firstChar == "\n" && str.length == 1)
                return new Value_1.StringValue("\n");
            // Glue
            if (str == "<>")
                return new Glue_1.Glue();
            // Control commands (would looking up in a hash set be faster?)
            for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {
                let cmdName = JsonSerialisation._controlCommandNames[i];
                if (str == cmdName) {
                    return new ControlCommand_1.ControlCommand(i);
                }
            }
            // Native functions
            if (str == "L^")
                str = "^";
            if (NativeFunctionCall_1.NativeFunctionCall.CallExistsWithName(str))
                return NativeFunctionCall_1.NativeFunctionCall.CallWithName(str);
            // Pop
            if (str == "->->")
                return ControlCommand_1.ControlCommand.PopTunnel();
            else if (str == "~ret")
                return ControlCommand_1.ControlCommand.PopFunction();
            // Void
            if (str == "void")
                return new Void_1.Void();
        }
        if (typeof token === "object" && !Array.isArray(token)) {
            let obj = token;
            let propValue;
            // Divert target value to path
            if (obj["^->"]) {
                propValue = obj["^->"];
                return new Value_1.DivertTargetValue(new Path_1.Path(propValue.toString()));
            }
            // VariablePointerValue
            if (obj["^var"]) {
                propValue = obj["^var"];
                let varPtr = new Value_1.VariablePointerValue(propValue.toString());
                if ("ci" in obj) {
                    propValue = obj["ci"];
                    varPtr.contextIndex = parseInt(propValue);
                }
                return varPtr;
            }
            // Divert
            let isDivert = false;
            let pushesToStack = false;
            let divPushType = PushPop_1.PushPopType.Function;
            let external = false;
            if ((propValue = obj["->"])) {
                isDivert = true;
            }
            else if ((propValue = obj["f()"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Function;
            }
            else if ((propValue = obj["->t->"])) {
                isDivert = true;
                pushesToStack = true;
                divPushType = PushPop_1.PushPopType.Tunnel;
            }
            else if ((propValue = obj["x()"])) {
                isDivert = true;
                external = true;
                pushesToStack = false;
                divPushType = PushPop_1.PushPopType.Function;
            }
            if (isDivert) {
                let divert = new Divert_1.Divert();
                divert.pushesToStack = pushesToStack;
                divert.stackPushType = divPushType;
                divert.isExternal = external;
                let target = propValue.toString();
                if ((propValue = obj["var"]))
                    divert.variableDivertName = target;
                else
                    divert.targetPathString = target;
                divert.isConditional = !!obj["c"];
                if (external) {
                    if ((propValue = obj["exArgs"]))
                        divert.externalArgs = parseInt(propValue);
                }
                return divert;
            }
            // Choice
            if ((propValue = obj["*"])) {
                let choice = new ChoicePoint_1.ChoicePoint();
                choice.pathStringOnChoice = propValue.toString();
                if ((propValue = obj["flg"]))
                    choice.flags = parseInt(propValue);
                return choice;
            }
            // Variable reference
            if ((propValue = obj["VAR?"])) {
                return new VariableReference_1.VariableReference(propValue.toString());
            }
            else if ((propValue = obj["CNT?"])) {
                let readCountVarRef = new VariableReference_1.VariableReference();
                readCountVarRef.pathStringForCount = propValue.toString();
                return readCountVarRef;
            }
            // Variable assignment
            let isVarAss = false;
            let isGlobalVar = false;
            if ((propValue = obj["VAR="])) {
                isVarAss = true;
                isGlobalVar = true;
            }
            else if ((propValue = obj["temp="])) {
                isVarAss = true;
                isGlobalVar = false;
            }
            if (isVarAss) {
                let varName = propValue.toString();
                let isNewDecl = !obj["re"];
                let varAss = new VariableAssignment_1.VariableAssignment(varName, isNewDecl);
                varAss.isGlobal = isGlobalVar;
                return varAss;
            }
            if (obj["#"] !== undefined) {
                propValue = obj["#"];
                return new Tag_1.Tag(propValue.toString());
            }
            // List value
            if ((propValue = obj["list"])) {
                // var listContent = (Dictionary<string, object>)propValue;
                let listContent = propValue;
                let rawList = new InkList_1.InkList();
                if ((propValue = obj["origins"])) {
                    // var namesAsObjs = (List<object>)propValue;
                    let namesAsObjs = propValue;
                    // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());
                    rawList.SetInitialOriginNames(namesAsObjs);
                }
                for (let key in listContent) {
                    if (listContent.hasOwnProperty(key)) {
                        let nameToVal = listContent[key];
                        let item = new InkList_1.InkListItem(key);
                        let val = parseInt(nameToVal);
                        rawList.Add(item, val);
                    }
                }
                return new Value_1.ListValue(rawList);
            }
            if (obj["originalChoicePath"] != null)
                return this.JObjectToChoice(obj);
        }
        // Array is always a Runtime.Container
        if (Array.isArray(token)) {
            return this.JArrayToContainer(token);
        }
        if (token === null || token === undefined)
            return null;
        throw new Error("Failed to convert token to runtime object: " + JSON.stringify(token));
    }
    static WriteRuntimeContainer(writer, container, withoutName = false) {
        writer.WriteArrayStart();
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        for (let c of container.content)
            this.WriteRuntimeObject(writer, c);
        let namedOnlyContent = container.namedOnlyContent;
        let countFlags = container.countFlags;
        let hasNameProperty = container.name != null && !withoutName;
        let hasTerminator = namedOnlyContent != null || countFlags > 0 || hasNameProperty;
        if (hasTerminator) {
            writer.WriteObjectStart();
        }
        if (namedOnlyContent != null) {
            for (let [key, value] of namedOnlyContent) {
                let name = key;
                let namedContainer = TypeAssertion_1.asOrNull(value, Container_1.Container);
                writer.WritePropertyStart(name);
                this.WriteRuntimeContainer(writer, namedContainer, true);
                writer.WritePropertyEnd();
            }
        }
        if (hasNameProperty)
            writer.WriteProperty("#n", container.name);
        if (hasTerminator)
            writer.WriteObjectEnd();
        else
            writer.WriteNull();
        writer.WriteArrayEnd();
    }
    static JArrayToContainer(jArray) {
        let container = new Container_1.Container();
        container.content = this.JArrayToRuntimeObjList(jArray, true);
        let terminatingObj = jArray[jArray.length - 1];
        if (terminatingObj != null) {
            let namedOnlyContent = new Map();
            for (let key in terminatingObj) {
                if (key == "#f") {
                    container.countFlags = parseInt(terminatingObj[key]);
                }
                else if (key == "#n") {
                    container.name = terminatingObj[key].toString();
                }
                else {
                    let namedContentItem = this.JTokenToRuntimeObject(terminatingObj[key]);
                    // var namedSubContainer = namedContentItem as Container;
                    let namedSubContainer = TypeAssertion_1.asOrNull(namedContentItem, Container_1.Container);
                    if (namedSubContainer)
                        namedSubContainer.name = key;
                    namedOnlyContent.set(key, namedContentItem);
                }
            }
            container.namedOnlyContent = namedOnlyContent;
        }
        return container;
    }
    static JObjectToChoice(jObj) {
        let choice = new Choice_1.Choice();
        choice.text = jObj["text"].toString();
        choice.index = parseInt(jObj["index"]);
        choice.sourcePath = jObj["originalChoicePath"].toString();
        choice.originalThreadIndex = parseInt(jObj["originalThreadIndex"]);
        choice.pathStringOnChoice = jObj["targetPath"].toString();
        return choice;
    }
    static WriteChoice(writer, choice) {
        writer.WriteObjectStart();
        writer.WriteProperty("text", choice.text);
        writer.WriteIntProperty("index", choice.index);
        writer.WriteProperty("originalChoicePath", choice.sourcePath);
        writer.WriteIntProperty("originalThreadIndex", choice.originalThreadIndex);
        writer.WriteProperty("targetPath", choice.pathStringOnChoice);
        writer.WriteObjectEnd();
    }
    static WriteInkList(writer, listVal) {
        let rawList = listVal.value;
        if (rawList === null) {
            return NullException_1.throwNullException("rawList");
        }
        writer.WriteObjectStart();
        writer.WritePropertyStart("list");
        writer.WriteObjectStart();
        for (let [key, val] of rawList) {
            let item = InkList_1.InkListItem.fromSerializedKey(key);
            let itemVal = val;
            if (item.itemName === null) {
                return NullException_1.throwNullException("item.itemName");
            }
            writer.WritePropertyNameStart();
            writer.WritePropertyNameInner(item.originName ? item.originName : "?");
            writer.WritePropertyNameInner(".");
            writer.WritePropertyNameInner(item.itemName);
            writer.WritePropertyNameEnd();
            writer.Write(itemVal);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        writer.WritePropertyEnd();
        if (rawList.Count == 0 &&
            rawList.originNames != null &&
            rawList.originNames.length > 0) {
            writer.WritePropertyStart("origins");
            writer.WriteArrayStart();
            for (let name of rawList.originNames)
                writer.Write(name);
            writer.WriteArrayEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    static ListDefinitionsToJToken(origin) {
        let result = {};
        for (let def of origin.lists) {
            let listDefJson = {};
            for (let [key, val] of def.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                if (item.itemName === null) {
                    return NullException_1.throwNullException("item.itemName");
                }
                listDefJson[item.itemName] = val;
            }
            result[def.name] = listDefJson;
        }
        return result;
    }
    static JTokenToListDefinitions(obj) {
        // var defsObj = (Dictionary<string, object>)obj;
        let defsObj = obj;
        let allDefs = [];
        for (let key in defsObj) {
            if (defsObj.hasOwnProperty(key)) {
                let name = key.toString();
                // var listDefJson = (Dictionary<string, object>)kv.Value;
                let listDefJson = defsObj[key];
                // Cast (string, object) to (string, int) for items
                let items = new Map();
                for (let nameValueKey in listDefJson) {
                    if (defsObj.hasOwnProperty(key)) {
                        let nameValue = listDefJson[nameValueKey];
                        items.set(nameValueKey, parseInt(nameValue));
                    }
                }
                let def = new ListDefinition_1.ListDefinition(name, items);
                allDefs.push(def);
            }
        }
        return new ListDefinitionsOrigin_1.ListDefinitionsOrigin(allDefs);
    }
}
exports.JsonSerialisation = JsonSerialisation;
JsonSerialisation._controlCommandNames = (() => {
    let _controlCommandNames = [];
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalStart] = "ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalOutput] = "out";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EvalEnd] = "/ev";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Duplicate] = "du";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue] = "pop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopFunction] = "~ret";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.PopTunnel] = "->->";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.BeginString] = "str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.EndString] = "/str";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.NoOp] = "nop";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ChoiceCount] = "choiceCnt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Turns] = "turn";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.TurnsSince] = "turns";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ReadCount] = "readc";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Random] = "rnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SeedRandom] = "srnd";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.VisitIndex] = "visit";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex] =
        "seq";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.StartThread] = "thread";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.Done] = "done";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.End] = "end";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListFromInt] = "listInt";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRange] = "range";
    _controlCommandNames[ControlCommand_1.ControlCommand.CommandType.ListRandom] = "lrnd";
    for (let i = 0; i < ControlCommand_1.ControlCommand.CommandType.TOTAL_VALUES; ++i) {
        if (_controlCommandNames[i] == null)
            throw new Error("Control command not accounted for in serialisation");
    }
    return _controlCommandNames;
})();
//# sourceMappingURL=JsonSerialisation.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinition.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinition = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
class ListDefinition {
    constructor(name, items) {
        this._name = name || "";
        this._items = null;
        this._itemNameToValues = items || new Map();
    }
    get name() {
        return this._name;
    }
    get items() {
        if (this._items == null) {
            this._items = new Map();
            for (let [key, value] of this._itemNameToValues) {
                let item = new InkList_1.InkListItem(this.name, key);
                this._items.set(item.serialized(), value);
            }
        }
        return this._items;
    }
    ValueForItem(item) {
        if (!item.itemName)
            return 0;
        let intVal = this._itemNameToValues.get(item.itemName);
        if (typeof intVal !== "undefined")
            return intVal;
        else
            return 0;
    }
    ContainsItem(item) {
        if (!item.itemName)
            return false;
        if (item.originName != this.name)
            return false;
        return this._itemNameToValues.has(item.itemName);
    }
    ContainsItemWithName(itemName) {
        return this._itemNameToValues.has(itemName);
    }
    TryGetItemWithValue(val, 
    /* out */ item) {
        for (let [key, value] of this._itemNameToValues) {
            if (value == val) {
                item = new InkList_1.InkListItem(this.name, key);
                return { result: item, exists: true };
            }
        }
        item = InkList_1.InkListItem.Null;
        return { result: item, exists: false };
    }
    TryGetValueForItem(item, 
    /* out */ intVal) {
        if (!item.itemName)
            return { result: 0, exists: false };
        let value = this._itemNameToValues.get(item.itemName);
        if (!value)
            return { result: 0, exists: false };
        return { result: value, exists: true };
    }
}
exports.ListDefinition = ListDefinition;
//# sourceMappingURL=ListDefinition.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js":
/*!************************************************************!*\
  !*** ./node_modules/inkjs/engine/ListDefinitionsOrigin.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ListDefinitionsOrigin = void 0;
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class ListDefinitionsOrigin {
    constructor(lists) {
        this._lists = new Map();
        this._allUnambiguousListValueCache = new Map();
        for (let list of lists) {
            this._lists.set(list.name, list);
            for (let [key, val] of list.items) {
                let item = InkList_1.InkListItem.fromSerializedKey(key);
                let listValue = new Value_1.ListValue(item, val);
                if (!item.itemName) {
                    throw new Error("item.itemName is null or undefined.");
                }
                this._allUnambiguousListValueCache.set(item.itemName, listValue);
                this._allUnambiguousListValueCache.set(item.fullName, listValue);
            }
        }
    }
    get lists() {
        let listOfLists = [];
        for (let [, value] of this._lists) {
            listOfLists.push(value);
        }
        return listOfLists;
    }
    TryListGetDefinition(name, 
    /* out */ def) {
        if (name === null) {
            return { result: def, exists: false };
        }
        // initially, this function returns a boolean and the second parameter is an out.
        let definition = this._lists.get(name);
        if (!definition)
            return { result: def, exists: false };
        return { result: definition, exists: true };
    }
    FindSingleItemListWithName(name) {
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let val = this._allUnambiguousListValueCache.get(name);
        if (typeof val !== "undefined") {
            return val;
        }
        return null;
    }
}
exports.ListDefinitionsOrigin = ListDefinitionsOrigin;
//# sourceMappingURL=ListDefinitionsOrigin.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NativeFunctionCall.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/NativeFunctionCall.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.NativeFunctionCall = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class NativeFunctionCall extends Object_1.InkObject {
    constructor() {
        super();
        this._name = null;
        this._numberOfParameters = 0;
        this._prototype = null;
        this._isPrototype = false;
        this._operationFuncs = null;
        if (arguments.length === 0) {
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
        }
        else if (arguments.length === 1) {
            let name = arguments[0];
            NativeFunctionCall.GenerateNativeFunctionsIfNecessary();
            this.name = name;
        }
        else if (arguments.length === 2) {
            let name = arguments[0];
            let numberOfParameters = arguments[1];
            this._isPrototype = true;
            this.name = name;
            this.numberOfParameters = numberOfParameters;
        }
    }
    static CallWithName(functionName) {
        return new NativeFunctionCall(functionName);
    }
    static CallExistsWithName(functionName) {
        this.GenerateNativeFunctionsIfNecessary();
        return this._nativeFunctions.get(functionName);
    }
    get name() {
        if (this._name === null)
            return NullException_1.throwNullException("NativeFunctionCall._name");
        return this._name;
    }
    set name(value) {
        this._name = value;
        if (!this._isPrototype) {
            if (NativeFunctionCall._nativeFunctions === null)
                NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
            else
                this._prototype =
                    NativeFunctionCall._nativeFunctions.get(this._name) || null;
        }
    }
    get numberOfParameters() {
        if (this._prototype) {
            return this._prototype.numberOfParameters;
        }
        else {
            return this._numberOfParameters;
        }
    }
    set numberOfParameters(value) {
        this._numberOfParameters = value;
    }
    Call(parameters) {
        if (this._prototype) {
            return this._prototype.Call(parameters);
        }
        if (this.numberOfParameters != parameters.length) {
            throw new Error("Unexpected number of parameters");
        }
        let hasList = false;
        for (let p of parameters) {
            if (p instanceof Void_1.Void)
                throw new StoryException_1.StoryException('Attempting to perform operation on a void value. Did you forget to "return" a value from a function you called here?');
            if (p instanceof Value_1.ListValue)
                hasList = true;
        }
        if (parameters.length == 2 && hasList) {
            return this.CallBinaryListOperation(parameters);
        }
        let coercedParams = this.CoerceValuesToSingleType(parameters);
        let coercedType = coercedParams[0].valueType;
        if (coercedType == Value_1.ValueType.Int) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.Float) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.String) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.DivertTarget) {
            return this.CallType(coercedParams);
        }
        else if (coercedType == Value_1.ValueType.List) {
            return this.CallType(coercedParams);
        }
        return null;
    }
    CallType(parametersOfSingleType) {
        let param1 = TypeAssertion_1.asOrThrows(parametersOfSingleType[0], Value_1.Value);
        let valType = param1.valueType;
        let val1 = param1;
        let paramCount = parametersOfSingleType.length;
        if (paramCount == 2 || paramCount == 1) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let opForTypeObj = this._operationFuncs.get(valType);
            if (!opForTypeObj) {
                const key = Value_1.ValueType[valType];
                throw new StoryException_1.StoryException("Cannot perform operation " + this.name + " on " + key);
            }
            if (paramCount == 2) {
                let param2 = TypeAssertion_1.asOrThrows(parametersOfSingleType[1], Value_1.Value);
                let val2 = param2;
                let opForType = opForTypeObj;
                if (val1.value === null || val2.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call BinaryOp values");
                let resultVal = opForType(val1.value, val2.value);
                return Value_1.Value.Create(resultVal);
            }
            else {
                let opForType = opForTypeObj;
                if (val1.value === null)
                    return NullException_1.throwNullException("NativeFunctionCall.Call UnaryOp value");
                let resultVal = opForType(val1.value);
                // This code is different from upstream. Since JavaScript treats
                // integers and floats as the same numbers, it's impossible
                // to force an number to be either an integer or a float.
                //
                // It can be useful to force a specific number type
                // (especially for divisions), so the result of INT() & FLOAT()
                // is coerced to the the proper value type.
                //
                // Note that we also force all other unary operation to
                // return the same value type, although this is only
                // meaningful for numbers. See `Value.Create`.
                if (this.name === NativeFunctionCall.Int) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Int);
                }
                else if (this.name === NativeFunctionCall.Float) {
                    return Value_1.Value.Create(resultVal, Value_1.ValueType.Float);
                }
                else {
                    return Value_1.Value.Create(resultVal, param1.valueType);
                }
            }
        }
        else {
            throw new Error("Unexpected number of parameters to NativeFunctionCall: " +
                parametersOfSingleType.length);
        }
    }
    CallBinaryListOperation(parameters) {
        if ((this.name == "+" || this.name == "-") &&
            parameters[0] instanceof Value_1.ListValue &&
            parameters[1] instanceof Value_1.IntValue)
            return this.CallListIncrementOperation(parameters);
        let v1 = TypeAssertion_1.asOrThrows(parameters[0], Value_1.Value);
        let v2 = TypeAssertion_1.asOrThrows(parameters[1], Value_1.Value);
        if ((this.name == "&&" || this.name == "||") &&
            (v1.valueType != Value_1.ValueType.List || v2.valueType != Value_1.ValueType.List)) {
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let op = this._operationFuncs.get(Value_1.ValueType.Int);
            if (op === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallBinaryListOperation op");
            let result = op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0);
            return new Value_1.IntValue(result);
        }
        if (v1.valueType == Value_1.ValueType.List && v2.valueType == Value_1.ValueType.List)
            return this.CallType([v1, v2]);
        throw new StoryException_1.StoryException("Can not call use " +
            this.name +
            " operation on " +
            Value_1.ValueType[v1.valueType] +
            " and " +
            Value_1.ValueType[v2.valueType]);
    }
    CallListIncrementOperation(listIntParams) {
        let listVal = TypeAssertion_1.asOrThrows(listIntParams[0], Value_1.ListValue);
        let intVal = TypeAssertion_1.asOrThrows(listIntParams[1], Value_1.IntValue);
        let resultInkList = new InkList_1.InkList();
        if (listVal.value === null)
            return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value");
        for (let [listItemKey, listItemValue] of listVal.value) {
            let listItem = InkList_1.InkListItem.fromSerializedKey(listItemKey);
            if (this._operationFuncs === null)
                return NullException_1.throwNullException("NativeFunctionCall._operationFuncs");
            let intOp = this._operationFuncs.get(Value_1.ValueType.Int);
            if (intVal.value === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation intVal.value");
            let targetInt = intOp(listItemValue, intVal.value);
            let itemOrigin = null;
            if (listVal.value.origins === null)
                return NullException_1.throwNullException("NativeFunctionCall.CallListIncrementOperation listVal.value.origins");
            for (let origin of listVal.value.origins) {
                if (origin.name == listItem.originName) {
                    itemOrigin = origin;
                    break;
                }
            }
            if (itemOrigin != null) {
                let incrementedItem = itemOrigin.TryGetItemWithValue(targetInt, InkList_1.InkListItem.Null);
                if (incrementedItem.exists)
                    resultInkList.Add(incrementedItem.result, targetInt);
            }
        }
        return new Value_1.ListValue(resultInkList);
    }
    CoerceValuesToSingleType(parametersIn) {
        let valType = Value_1.ValueType.Int;
        let specialCaseList = null;
        for (let obj of parametersIn) {
            let val = TypeAssertion_1.asOrThrows(obj, Value_1.Value);
            if (val.valueType > valType) {
                valType = val.valueType;
            }
            if (val.valueType == Value_1.ValueType.List) {
                specialCaseList = TypeAssertion_1.asOrNull(val, Value_1.ListValue);
            }
        }
        let parametersOut = [];
        if (Value_1.ValueType[valType] == Value_1.ValueType[Value_1.ValueType.List]) {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                if (val.valueType == Value_1.ValueType.List) {
                    parametersOut.push(val);
                }
                else if (val.valueType == Value_1.ValueType.Int) {
                    let intVal = parseInt(val.valueObject);
                    specialCaseList = TypeAssertion_1.asOrThrows(specialCaseList, Value_1.ListValue);
                    if (specialCaseList.value === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value");
                    let list = specialCaseList.value.originOfMaxItem;
                    if (list === null)
                        return NullException_1.throwNullException("NativeFunctionCall.CoerceValuesToSingleType list");
                    let item = list.TryGetItemWithValue(intVal, InkList_1.InkListItem.Null);
                    if (item.exists) {
                        let castedValue = new Value_1.ListValue(item.result, intVal);
                        parametersOut.push(castedValue);
                    }
                    else
                        throw new StoryException_1.StoryException("Could not find List item with the value " +
                            intVal +
                            " in " +
                            list.name);
                }
                else {
                    const key = Value_1.ValueType[val.valueType];
                    throw new StoryException_1.StoryException("Cannot mix Lists and " + key + " values in this operation");
                }
            }
        }
        else {
            for (let inkObjectVal of parametersIn) {
                let val = TypeAssertion_1.asOrThrows(inkObjectVal, Value_1.Value);
                let castedValue = val.Cast(valType);
                parametersOut.push(castedValue);
            }
        }
        return parametersOut;
    }
    static Identity(t) {
        return t;
    }
    static GenerateNativeFunctionsIfNecessary() {
        if (this._nativeFunctions == null) {
            this._nativeFunctions = new Map();
            // Int operations
            this.AddIntBinaryOp(this.Add, (x, y) => x + y);
            this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));
            this.AddIntBinaryOp(this.Mod, (x, y) => x % y);
            this.AddIntUnaryOp(this.Negate, (x) => -x);
            this.AddIntBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddIntBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddIntBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => (x >= y ? 1 : 0));
            this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddIntBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddIntUnaryOp(this.Not, (x) => (x == 0 ? 1 : 0));
            this.AddIntBinaryOp(this.And, (x, y) => (x != 0 && y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Or, (x, y) => (x != 0 || y != 0 ? 1 : 0));
            this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);
            this.AddIntUnaryOp(this.Float, (x) => x);
            // Float operations
            this.AddFloatBinaryOp(this.Add, (x, y) => x + y);
            this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);
            this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);
            this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);
            this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);
            this.AddFloatUnaryOp(this.Negate, (x) => -x);
            this.AddFloatBinaryOp(this.Equal, (x, y) => (x == y ? 1 : 0));
            this.AddFloatBinaryOp(this.Greater, (x, y) => (x > y ? 1 : 0));
            this.AddFloatBinaryOp(this.Less, (x, y) => (x < y ? 1 : 0));
            this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y ? 1 : 0);
            this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => (x <= y ? 1 : 0));
            this.AddFloatBinaryOp(this.NotEquals, (x, y) => (x != y ? 1 : 0));
            this.AddFloatUnaryOp(this.Not, (x) => (x == 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.And, (x, y) => (x != 0.0 && y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Or, (x, y) => (x != 0.0 || y != 0.0 ? 1 : 0));
            this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));
            this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));
            this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));
            this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));
            this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));
            this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);
            // String operations
            this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat
            this.AddStringBinaryOp(this.Equal, (x, y) => (x === y ? 1 : 0));
            this.AddStringBinaryOp(this.NotEquals, (x, y) => (!(x === y) ? 1 : 0));
            this.AddStringBinaryOp(this.Has, (x, y) => (x.includes(y) ? 1 : 0));
            this.AddStringBinaryOp(this.Hasnt, (x, y) => (x.includes(y) ? 0 : 1));
            this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));
            this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));
            this.AddListBinaryOp(this.Has, (x, y) => (x.Contains(y) ? 1 : 0));
            this.AddListBinaryOp(this.Hasnt, (x, y) => (x.Contains(y) ? 0 : 1));
            this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));
            this.AddListBinaryOp(this.Equal, (x, y) => (x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.Greater, (x, y) => (x.GreaterThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.Less, (x, y) => (x.LessThan(y) ? 1 : 0));
            this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) => x.GreaterThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.LessThanOrEquals, (x, y) => x.LessThanOrEquals(y) ? 1 : 0);
            this.AddListBinaryOp(this.NotEquals, (x, y) => (!x.Equals(y) ? 1 : 0));
            this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0 ? 1 : 0);
            this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0 ? 1 : 0);
            this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));
            this.AddListUnaryOp(this.Invert, (x) => x.inverse);
            this.AddListUnaryOp(this.All, (x) => x.all);
            this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());
            this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());
            this.AddListUnaryOp(this.Count, (x) => x.Count);
            this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);
            let divertTargetsEqual = (d1, d2) => (d1.Equals(d2) ? 1 : 0);
            let divertTargetsNotEqual = (d1, d2) => d1.Equals(d2) ? 0 : 1;
            this.AddOpToNativeFunc(this.Equal, 2, Value_1.ValueType.DivertTarget, divertTargetsEqual);
            this.AddOpToNativeFunc(this.NotEquals, 2, Value_1.ValueType.DivertTarget, divertTargetsNotEqual);
        }
    }
    AddOpFuncForType(valType, op) {
        if (this._operationFuncs == null) {
            this._operationFuncs = new Map();
        }
        this._operationFuncs.set(valType, op);
    }
    static AddOpToNativeFunc(name, args, valType, op) {
        if (this._nativeFunctions === null)
            return NullException_1.throwNullException("NativeFunctionCall._nativeFunctions");
        let nativeFunc = this._nativeFunctions.get(name);
        if (!nativeFunc) {
            nativeFunc = new NativeFunctionCall(name, args);
            this._nativeFunctions.set(name, nativeFunc);
        }
        nativeFunc.AddOpFuncForType(valType, op);
    }
    static AddIntBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Int, op);
    }
    static AddIntUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Int, op);
    }
    static AddFloatBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.Float, op);
    }
    static AddFloatUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.Float, op);
    }
    static AddStringBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.String, op);
    }
    static AddListBinaryOp(name, op) {
        this.AddOpToNativeFunc(name, 2, Value_1.ValueType.List, op);
    }
    static AddListUnaryOp(name, op) {
        this.AddOpToNativeFunc(name, 1, Value_1.ValueType.List, op);
    }
    toString() {
        return 'Native "' + this.name + '"';
    }
}
exports.NativeFunctionCall = NativeFunctionCall;
NativeFunctionCall.Add = "+";
NativeFunctionCall.Subtract = "-";
NativeFunctionCall.Divide = "/";
NativeFunctionCall.Multiply = "*";
NativeFunctionCall.Mod = "%";
NativeFunctionCall.Negate = "_";
NativeFunctionCall.Equal = "==";
NativeFunctionCall.Greater = ">";
NativeFunctionCall.Less = "<";
NativeFunctionCall.GreaterThanOrEquals = ">=";
NativeFunctionCall.LessThanOrEquals = "<=";
NativeFunctionCall.NotEquals = "!=";
NativeFunctionCall.Not = "!";
NativeFunctionCall.And = "&&";
NativeFunctionCall.Or = "||";
NativeFunctionCall.Min = "MIN";
NativeFunctionCall.Max = "MAX";
NativeFunctionCall.Pow = "POW";
NativeFunctionCall.Floor = "FLOOR";
NativeFunctionCall.Ceiling = "CEILING";
NativeFunctionCall.Int = "INT";
NativeFunctionCall.Float = "FLOAT";
NativeFunctionCall.Has = "?";
NativeFunctionCall.Hasnt = "!?";
NativeFunctionCall.Intersect = "^";
NativeFunctionCall.ListMin = "LIST_MIN";
NativeFunctionCall.ListMax = "LIST_MAX";
NativeFunctionCall.All = "LIST_ALL";
NativeFunctionCall.Count = "LIST_COUNT";
NativeFunctionCall.ValueOfList = "LIST_VALUE";
NativeFunctionCall.Invert = "LIST_INVERT";
NativeFunctionCall._nativeFunctions = null;
//# sourceMappingURL=NativeFunctionCall.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/NullException.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/NullException.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.throwNullException = exports.NullException = void 0;
/**
 * In the original C# code, a SystemException would be thrown when passing
 * null to methods expected a valid instance. Javascript has no such
 * concept, but TypeScript will not allow `null` to be passed to methods
 * explicitely requiring a valid type.
 *
 * Whenever TypeScript complain about the possibility of a `null` value,
 * check the offending value and it it's null, throw this exception using
 * `throwNullException(name: string)`.
 */
class NullException extends Error {
}
exports.NullException = NullException;
/**
 * Throw a NullException.
 *
 * @param name a short description of the offending value (often its name within the code).
 */
function throwNullException(name) {
    throw new NullException(`${name} is null or undefined`);
}
exports.throwNullException = throwNullException;
//# sourceMappingURL=NullException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Object.js":
/*!*********************************************!*\
  !*** ./node_modules/inkjs/engine/Object.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.InkObject = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class InkObject {
    constructor() {
        this.parent = null;
        this._debugMetadata = null;
        this._path = null;
    }
    get debugMetadata() {
        if (this._debugMetadata === null) {
            if (this.parent) {
                return this.parent.debugMetadata;
            }
        }
        return this._debugMetadata;
    }
    set debugMetadata(value) {
        this._debugMetadata = value;
    }
    get ownDebugMetadata() {
        return this._debugMetadata;
    }
    DebugLineNumberOfPath(path) {
        if (path === null)
            return null;
        // Try to get a line number from debug metadata
        let root = this.rootContentContainer;
        if (root) {
            let targetContent = root.ContentAtPath(path).obj;
            if (targetContent) {
                let dm = targetContent.debugMetadata;
                if (dm !== null) {
                    return dm.startLineNumber;
                }
            }
        }
        return null;
    }
    get path() {
        if (this._path == null) {
            if (this.parent == null) {
                this._path = new Path_1.Path();
            }
            else {
                let comps = [];
                let child = this;
                let container = TypeAssertion_1.asOrNull(child.parent, Container_1.Container);
                while (container !== null) {
                    let namedChild = TypeAssertion_1.asINamedContentOrNull(child);
                    if (namedChild != null && namedChild.hasValidName) {
                        comps.unshift(new Path_1.Path.Component(namedChild.name));
                    }
                    else {
                        comps.unshift(new Path_1.Path.Component(container.content.indexOf(child)));
                    }
                    child = container;
                    container = TypeAssertion_1.asOrNull(container.parent, Container_1.Container);
                }
                this._path = new Path_1.Path(comps);
            }
        }
        return this._path;
    }
    ResolvePath(path) {
        if (path === null)
            return NullException_1.throwNullException("path");
        if (path.isRelative) {
            let nearestContainer = TypeAssertion_1.asOrNull(this, Container_1.Container);
            if (nearestContainer === null) {
                Debug_1.Debug.Assert(this.parent !== null, "Can't resolve relative path because we don't have a parent");
                nearestContainer = TypeAssertion_1.asOrNull(this.parent, Container_1.Container);
                Debug_1.Debug.Assert(nearestContainer !== null, "Expected parent to be a container");
                Debug_1.Debug.Assert(path.GetComponent(0).isParent);
                path = path.tail;
            }
            if (nearestContainer === null) {
                return NullException_1.throwNullException("nearestContainer");
            }
            return nearestContainer.ContentAtPath(path);
        }
        else {
            let contentContainer = this.rootContentContainer;
            if (contentContainer === null) {
                return NullException_1.throwNullException("contentContainer");
            }
            return contentContainer.ContentAtPath(path);
        }
    }
    ConvertPathToRelative(globalPath) {
        let ownPath = this.path;
        let minPathLength = Math.min(globalPath.length, ownPath.length);
        let lastSharedPathCompIndex = -1;
        for (let i = 0; i < minPathLength; ++i) {
            let ownComp = ownPath.GetComponent(i);
            let otherComp = globalPath.GetComponent(i);
            if (ownComp.Equals(otherComp)) {
                lastSharedPathCompIndex = i;
            }
            else {
                break;
            }
        }
        // No shared path components, so just use global path
        if (lastSharedPathCompIndex == -1)
            return globalPath;
        let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;
        let newPathComps = [];
        for (let up = 0; up < numUpwardsMoves; ++up)
            newPathComps.push(Path_1.Path.Component.ToParent());
        for (let down = lastSharedPathCompIndex + 1; down < globalPath.componentCount; ++down)
            newPathComps.push(globalPath.GetComponent(down));
        let relativePath = new Path_1.Path(newPathComps, true);
        return relativePath;
    }
    CompactPathString(otherPath) {
        let globalPathStr = null;
        let relativePathStr = null;
        if (otherPath.isRelative) {
            relativePathStr = otherPath.componentsString;
            globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;
        }
        else {
            let relativePath = this.ConvertPathToRelative(otherPath);
            relativePathStr = relativePath.componentsString;
            globalPathStr = otherPath.componentsString;
        }
        if (relativePathStr.length < globalPathStr.length)
            return relativePathStr;
        else
            return globalPathStr;
    }
    get rootContentContainer() {
        let ancestor = this;
        while (ancestor.parent) {
            ancestor = ancestor.parent;
        }
        return TypeAssertion_1.asOrNull(ancestor, Container_1.Container);
    }
    Copy() {
        throw Error("Not Implemented: Doesn't support copying");
    }
    // SetChild works slightly diferently in the js implementation.
    // Since we can't pass an objets property by reference, we instead pass
    // the object and the property string.
    // TODO: This method can probably be rewritten with type-safety in mind.
    SetChild(obj, prop, value) {
        if (obj[prop])
            obj[prop] = null;
        obj[prop] = value;
        if (obj[prop])
            obj[prop].parent = this;
    }
}
exports.InkObject = InkObject;
//# sourceMappingURL=Object.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PRNG.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/PRNG.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PRNG = void 0;
// Taken from https://gist.github.com/blixt/f17b47c62508be59987b
// Ink uses a seedable PRNG of which there is none in native javascript.
class PRNG {
    constructor(seed) {
        this.seed = seed % 2147483647;
        if (this.seed <= 0)
            this.seed += 2147483646;
    }
    next() {
        return (this.seed = (this.seed * 16807) % 2147483647);
    }
    nextFloat() {
        return (this.next() - 1) / 2147483646;
    }
}
exports.PRNG = PRNG;
//# sourceMappingURL=PRNG.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Path.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Path.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
class Path {
    constructor() {
        this._components = [];
        this._componentsString = null;
        this._isRelative = false;
        if (typeof arguments[0] == "string") {
            let componentsString = arguments[0];
            this.componentsString = componentsString;
        }
        else if (arguments[0] instanceof Path.Component &&
            arguments[1] instanceof Path) {
            let head = arguments[0];
            let tail = arguments[1];
            this._components.push(head);
            this._components = this._components.concat(tail._components);
        }
        else if (arguments[0] instanceof Array) {
            let head = arguments[0];
            let relative = !!arguments[1];
            this._components = this._components.concat(head);
            this._isRelative = relative;
        }
    }
    get isRelative() {
        return this._isRelative;
    }
    get componentCount() {
        return this._components.length;
    }
    get head() {
        if (this._components.length > 0) {
            return this._components[0];
        }
        else {
            return null;
        }
    }
    get tail() {
        if (this._components.length >= 2) {
            // careful, the original code uses length-1 here. This is because the second argument of
            // List.GetRange is a number of elements to extract, wherease Array.slice uses an index
            let tailComps = this._components.slice(1, this._components.length);
            return new Path(tailComps);
        }
        else {
            return Path.self;
        }
    }
    get length() {
        return this._components.length;
    }
    get lastComponent() {
        let lastComponentIdx = this._components.length - 1;
        if (lastComponentIdx >= 0) {
            return this._components[lastComponentIdx];
        }
        else {
            return null;
        }
    }
    get containsNamedComponent() {
        for (let i = 0, l = this._components.length; i < l; i++) {
            if (!this._components[i].isIndex) {
                return true;
            }
        }
        return false;
    }
    static get self() {
        let path = new Path();
        path._isRelative = true;
        return path;
    }
    GetComponent(index) {
        return this._components[index];
    }
    PathByAppendingPath(pathToAppend) {
        let p = new Path();
        let upwardMoves = 0;
        for (let i = 0; i < pathToAppend._components.length; ++i) {
            if (pathToAppend._components[i].isParent) {
                upwardMoves++;
            }
            else {
                break;
            }
        }
        for (let i = 0; i < this._components.length - upwardMoves; ++i) {
            p._components.push(this._components[i]);
        }
        for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {
            p._components.push(pathToAppend._components[i]);
        }
        return p;
    }
    get componentsString() {
        if (this._componentsString == null) {
            this._componentsString = this._components.join(".");
            if (this.isRelative)
                this._componentsString = "." + this._componentsString;
        }
        return this._componentsString;
    }
    set componentsString(value) {
        this._components.length = 0;
        this._componentsString = value;
        if (this._componentsString == null || this._componentsString == "")
            return;
        if (this._componentsString[0] == ".") {
            this._isRelative = true;
            this._componentsString = this._componentsString.substring(1);
        }
        let componentStrings = this._componentsString.split(".");
        for (let str of componentStrings) {
            // we need to distinguish between named components that start with a number, eg "42somewhere", and indexed components
            // the normal parseInt won't do for the detection because it's too relaxed.
            // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
            if (/^(\-|\+)?([0-9]+|Infinity)$/.test(str)) {
                this._components.push(new Path.Component(parseInt(str)));
            }
            else {
                this._components.push(new Path.Component(str));
            }
        }
    }
    toString() {
        return this.componentsString;
    }
    Equals(otherPath) {
        if (otherPath == null)
            return false;
        if (otherPath._components.length != this._components.length)
            return false;
        if (otherPath.isRelative != this.isRelative)
            return false;
        // the original code uses SequenceEqual here, so we need to iterate over the components manually.
        for (let i = 0, l = otherPath._components.length; i < l; i++) {
            // it's not quite clear whether this test should use Equals or a simple == operator,
            // see https://github.com/y-lohse/inkjs/issues/22
            if (!otherPath._components[i].Equals(this._components[i]))
                return false;
        }
        return true;
    }
    PathByAppendingComponent(c) {
        let p = new Path();
        p._components.push.apply(p._components, this._components);
        p._components.push(c);
        return p;
    }
}
exports.Path = Path;
Path.parentId = "^";
(function (Path) {
    class Component {
        constructor(indexOrName) {
            this.index = -1;
            this.name = null;
            if (typeof indexOrName == "string") {
                this.name = indexOrName;
            }
            else {
                this.index = indexOrName;
            }
        }
        get isIndex() {
            return this.index >= 0;
        }
        get isParent() {
            return this.name == Path.parentId;
        }
        static ToParent() {
            return new Component(Path.parentId);
        }
        toString() {
            if (this.isIndex) {
                return this.index.toString();
            }
            else {
                return this.name;
            }
        }
        Equals(otherComp) {
            if (otherComp != null && otherComp.isIndex == this.isIndex) {
                if (this.isIndex) {
                    return this.index == otherComp.index;
                }
                else {
                    return this.name == otherComp.name;
                }
            }
            return false;
        }
    }
    Path.Component = Component;
})(Path = exports.Path || (exports.Path = {}));
//# sourceMappingURL=Path.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Pointer.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/Pointer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Pointer = void 0;
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class Pointer {
    constructor() {
        this.container = null;
        this.index = -1;
        if (arguments.length === 2) {
            this.container = arguments[0];
            this.index = arguments[1];
        }
    }
    Resolve() {
        if (this.index < 0)
            return this.container;
        if (this.container == null)
            return null;
        if (this.container.content.length == 0)
            return this.container;
        if (this.index >= this.container.content.length)
            return null;
        return this.container.content[this.index];
    }
    get isNull() {
        return this.container == null;
    }
    get path() {
        if (this.isNull)
            return null;
        if (this.index >= 0)
            return this.container.path.PathByAppendingComponent(new Path_1.Path.Component(this.index));
        else
            return this.container.path;
    }
    toString() {
        if (!this.container)
            return "Ink Pointer (null)";
        return ("Ink Pointer -> " +
            this.container.path.toString() +
            " -- index " +
            this.index);
    }
    // This method does not exist in the original C# code, but is here to maintain the
    // value semantics of Pointer.
    copy() {
        return new Pointer(this.container, this.index);
    }
    static StartOf(container) {
        return new Pointer(container, 0);
    }
    static get Null() {
        return new Pointer(null, -1);
    }
}
exports.Pointer = Pointer;
//# sourceMappingURL=Pointer.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/PushPop.js":
/*!**********************************************!*\
  !*** ./node_modules/inkjs/engine/PushPop.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.PushPopType = void 0;
var PushPopType;
(function (PushPopType) {
    PushPopType[PushPopType["Tunnel"] = 0] = "Tunnel";
    PushPopType[PushPopType["Function"] = 1] = "Function";
    PushPopType[PushPopType["FunctionEvaluationFromGame"] = 2] = "FunctionEvaluationFromGame";
})(PushPopType = exports.PushPopType || (exports.PushPopType = {}));
//# sourceMappingURL=PushPop.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SearchResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/SearchResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchResult = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
class SearchResult {
    constructor() {
        this.obj = null;
        this.approximate = false;
    }
    get correctObj() {
        return this.approximate ? null : this.obj;
    }
    get container() {
        return this.obj instanceof Container_1.Container ? this.obj : null;
    }
    copy() {
        let searchResult = new SearchResult();
        searchResult.obj = this.obj;
        searchResult.approximate = this.approximate;
        return searchResult;
    }
}
exports.SearchResult = SearchResult;
//# sourceMappingURL=SearchResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/SimpleJson.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/SimpleJson.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.SimpleJson = void 0;
class SimpleJson {
    static TextToDictionary(text) {
        return new SimpleJson.Reader(text).ToDictionary();
    }
    static TextToArray(text) {
        return new SimpleJson.Reader(text).ToArray();
    }
}
exports.SimpleJson = SimpleJson;
(function (SimpleJson) {
    class Reader {
        constructor(text) {
            this._rootObject = JSON.parse(text);
        }
        ToDictionary() {
            return this._rootObject;
        }
        ToArray() {
            return this._rootObject;
        }
    }
    SimpleJson.Reader = Reader;
    // In C#, this class writes json tokens directly to a StringWriter or
    // another stream. Here, a temporary hierarchy is created in the form
    // of a javascript object, which is serialised in the `toString` method.
    // See individual methods and properties for more information.
    class Writer {
        constructor() {
            // In addition to `_stateStack` present in the original code,
            // this implementation of SimpleJson use two other stacks and two
            // temporary variables holding the current context.
            // Used to keep track of the current property name being built
            // with `WritePropertyNameStart`, `WritePropertyNameInner` and
            // `WritePropertyNameEnd`.
            this._currentPropertyName = null;
            // Used to keep track of the current string value being built
            // with `WriteStringStart`, `WriteStringInner` and
            // `WriteStringEnd`.
            this._currentString = null;
            this._stateStack = [];
            // Keep track of the current collection being built (either an array
            // or an object). For instance, at the '?' step during the hiarchy
            // creation, this hierarchy:
            // [3, {a: [b, ?]}] will have this corresponding stack:
            // (bottom) [Array, Object, Array] (top)
            this._collectionStack = [];
            // Keep track of the current property being assigned. For instance, at
            // the '?' step during the hiarchy creation, this hierarchy:
            // [3, {a: [b, {c: ?}]}] will have this corresponding stack:
            // (bottom) [a, c] (top)
            this._propertyNameStack = [];
            // Object containing the entire hiearchy.
            this._jsonObject = null;
        }
        WriteObject(inner) {
            this.WriteObjectStart();
            inner(this);
            this.WriteObjectEnd();
        }
        // Add a new object.
        WriteObjectStart() {
            this.StartNewObject(true);
            let newObject = {};
            if (this.state === SimpleJson.Writer.State.Property) {
                // This object is created as the value of a property,
                // inside an other object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This object is created as the child of an array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This object is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object));
        }
        WriteObjectEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Write a property name / value pair to the current object.
        WriteProperty(name, innerOrContent) {
            this.WritePropertyStart(name);
            if (arguments[1] instanceof Function) {
                let inner = arguments[1];
                inner(this);
            }
            else {
                let content = arguments[1];
                this.Write(content);
            }
            this.WritePropertyEnd();
        }
        // Int and Float are separate calls, since there both are
        // numbers in JavaScript, but need to be handled differently.
        WriteIntProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteInt(content);
            this.WritePropertyEnd();
        }
        WriteFloatProperty(name, content) {
            this.WritePropertyStart(name);
            this.WriteFloat(content);
            this.WritePropertyEnd();
        }
        // Prepare a new property name, which will be use to add the
        // new object when calling _addToCurrentObject() from a Write
        // method.
        WritePropertyStart(name) {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this._propertyNameStack.push(name);
            this.IncrementChildCount();
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
        }
        WritePropertyEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Property);
            this.Assert(this.childCount === 1);
            this._stateStack.pop();
        }
        // Prepare a new property name, except this time, the property name
        // will be created by concatenating all the strings passed to
        // WritePropertyNameInner.
        WritePropertyNameStart() {
            this.Assert(this.state === SimpleJson.Writer.State.Object);
            this.IncrementChildCount();
            this._currentPropertyName = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property));
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName));
        }
        WritePropertyNameEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._propertyNameStack.push(this._currentPropertyName);
            this._currentPropertyName = null;
            this._stateStack.pop();
        }
        WritePropertyNameInner(str) {
            this.Assert(this.state === SimpleJson.Writer.State.PropertyName);
            this.Assert(this._currentPropertyName !== null);
            this._currentPropertyName += str;
        }
        // Add a new array.
        WriteArrayStart() {
            this.StartNewObject(true);
            let newObject = [];
            if (this.state === SimpleJson.Writer.State.Property) {
                // This array is created as the value of a property,
                // inside an object.
                this.Assert(this.currentCollection !== null);
                this.Assert(this.currentPropertyName !== null);
                let propertyName = this._propertyNameStack.pop();
                this.currentCollection[propertyName] = newObject;
                this._collectionStack.push(newObject);
            }
            else if (this.state === SimpleJson.Writer.State.Array) {
                // This array is created as the child of another array.
                this.Assert(this.currentCollection !== null);
                this.currentCollection.push(newObject);
                this._collectionStack.push(newObject);
            }
            else {
                // This array is the root object.
                this.Assert(this.state === SimpleJson.Writer.State.None);
                this._jsonObject = newObject;
                this._collectionStack.push(newObject);
            }
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array));
        }
        WriteArrayEnd() {
            this.Assert(this.state === SimpleJson.Writer.State.Array);
            this._collectionStack.pop();
            this._stateStack.pop();
        }
        // Add the value to the appropriate collection (array / object), given the current
        // context.
        Write(value, escape = true) {
            if (value === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this.StartNewObject(false);
            this._addToCurrentObject(value);
        }
        WriteInt(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            // Math.floor is used as a precaution:
            //     1. to ensure that the value is written as an integer
            //        (without a fractional part -> 1 instead of 1.0), even
            //        though it should be the default behaviour of
            //        JSON.serialize;
            //     2. to ensure that if a floating number is passed
            //        accidentally, it's converted to an integer.
            //
            // This guarantees savegame compatibility with the reference
            // implementation.
            this._addToCurrentObject(Math.floor(value));
        }
        // Since JSON doesn't support NaN and Infinity, these values
        // are converted here.
        WriteFloat(value) {
            if (value === null) {
                return;
            }
            this.StartNewObject(false);
            if (value == Number.POSITIVE_INFINITY) {
                this._addToCurrentObject(3.4e38);
            }
            else if (value == Number.NEGATIVE_INFINITY) {
                this._addToCurrentObject(-3.4e38);
            }
            else if (isNaN(value)) {
                this._addToCurrentObject(0.0);
            }
            else {
                this._addToCurrentObject(value);
            }
        }
        WriteNull() {
            this.StartNewObject(false);
            this._addToCurrentObject(null);
        }
        // Prepare a string before adding it to the current collection in
        // WriteStringEnd(). The string will be a concatenation of all the
        // strings passed to WriteStringInner.
        WriteStringStart() {
            this.StartNewObject(false);
            this._currentString = "";
            this._stateStack.push(new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String));
        }
        WriteStringEnd() {
            this.Assert(this.state == SimpleJson.Writer.State.String);
            this._stateStack.pop();
            this._addToCurrentObject(this._currentString);
            this._currentString = null;
        }
        WriteStringInner(str, escape = true) {
            this.Assert(this.state === SimpleJson.Writer.State.String);
            if (str === null) {
                console.error("Warning: trying to write a null string");
                return;
            }
            this._currentString += str;
        }
        // Serialise the root object into a JSON string.
        ToString() {
            if (this._jsonObject === null) {
                return "";
            }
            return JSON.stringify(this._jsonObject);
        }
        // Prepare the state stack when adding new objects / values.
        StartNewObject(container) {
            if (container) {
                this.Assert(this.state === SimpleJson.Writer.State.None ||
                    this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            else {
                this.Assert(this.state === SimpleJson.Writer.State.Property ||
                    this.state === SimpleJson.Writer.State.Array);
            }
            if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(this.childCount === 0);
            }
            if (this.state === SimpleJson.Writer.State.Array ||
                this.state === SimpleJson.Writer.State.Property) {
                this.IncrementChildCount();
            }
        }
        // These getters peek all the different stacks.
        get state() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].type;
            }
            else {
                return SimpleJson.Writer.State.None;
            }
        }
        get childCount() {
            if (this._stateStack.length > 0) {
                return this._stateStack[this._stateStack.length - 1].childCount;
            }
            else {
                return 0;
            }
        }
        get currentCollection() {
            if (this._collectionStack.length > 0) {
                return this._collectionStack[this._collectionStack.length - 1];
            }
            else {
                return null;
            }
        }
        get currentPropertyName() {
            if (this._propertyNameStack.length > 0) {
                return this._propertyNameStack[this._propertyNameStack.length - 1];
            }
            else {
                return null;
            }
        }
        IncrementChildCount() {
            this.Assert(this._stateStack.length > 0);
            let currEl = this._stateStack.pop();
            currEl.childCount++;
            this._stateStack.push(currEl);
        }
        Assert(condition) {
            if (!condition)
                throw Error("Assert failed while writing JSON");
        }
        // This method did not exist in the original C# code. It adds
        // the given value to the current collection (used by Write methods).
        _addToCurrentObject(value) {
            this.Assert(this.currentCollection !== null);
            if (this.state === SimpleJson.Writer.State.Array) {
                this.Assert(Array.isArray(this.currentCollection));
                this.currentCollection.push(value);
            }
            else if (this.state === SimpleJson.Writer.State.Property) {
                this.Assert(!Array.isArray(this.currentCollection));
                this.Assert(this.currentPropertyName !== null);
                this.currentCollection[this.currentPropertyName] = value;
                this._propertyNameStack.pop();
            }
        }
    }
    SimpleJson.Writer = Writer;
    (function (Writer) {
        let State;
        (function (State) {
            State[State["None"] = 0] = "None";
            State[State["Object"] = 1] = "Object";
            State[State["Array"] = 2] = "Array";
            State[State["Property"] = 3] = "Property";
            State[State["PropertyName"] = 4] = "PropertyName";
            State[State["String"] = 5] = "String";
        })(State = Writer.State || (Writer.State = {}));
        class StateElement {
            constructor(type) {
                this.type = SimpleJson.Writer.State.None;
                this.childCount = 0;
                this.type = type;
            }
        }
        Writer.StateElement = StateElement;
    })(Writer = SimpleJson.Writer || (SimpleJson.Writer = {}));
})(SimpleJson = exports.SimpleJson || (exports.SimpleJson = {}));
//# sourceMappingURL=SimpleJson.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StatePatch.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StatePatch.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StatePatch = void 0;
class StatePatch {
    constructor() {
        this._changedVariables = new Set();
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        if (arguments.length === 1 && arguments[0] !== null) {
            let toCopy = arguments[0];
            this._globals = new Map(toCopy._globals);
            this._changedVariables = new Set(toCopy._changedVariables);
            this._visitCounts = new Map(toCopy._visitCounts);
            this._turnIndices = new Map(toCopy._turnIndices);
        }
        else {
            this._globals = new Map();
            this._changedVariables = new Set();
            this._visitCounts = new Map();
            this._turnIndices = new Map();
        }
    }
    get globals() {
        return this._globals;
    }
    get changedVariables() {
        return this._changedVariables;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    TryGetGlobal(name, /* out */ value) {
        if (name !== null && this._globals.has(name)) {
            return { result: this._globals.get(name), exists: true };
        }
        return { result: value, exists: false };
    }
    SetGlobal(name, value) {
        this._globals.set(name, value);
    }
    AddChangedVariable(name) {
        return this._changedVariables.add(name);
    }
    TryGetVisitCount(container, /* out */ count) {
        if (this._visitCounts.has(container)) {
            return { result: this._visitCounts.get(container), exists: true };
        }
        return { result: count, exists: false };
    }
    SetVisitCount(container, count) {
        this._visitCounts.set(container, count);
    }
    SetTurnIndex(container, index) {
        this._turnIndices.set(container, index);
    }
    TryGetTurnIndex(container, /* out */ index) {
        if (this._turnIndices.has(container)) {
            return { result: this._turnIndices.get(container), exists: true };
        }
        return { result: index, exists: false };
    }
}
exports.StatePatch = StatePatch;
//# sourceMappingURL=StatePatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StopWatch.js":
/*!************************************************!*\
  !*** ./node_modules/inkjs/engine/StopWatch.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Stopwatch = void 0;
// This is simple replacement of the Stopwatch class from the .NET Framework.
// The original class can count time with much more accuracy than the Javascript version.
// It might be worth considering using `window.performance` in the browser
// or `process.hrtime()` in node.
class Stopwatch {
    constructor() {
        this.startTime = undefined;
    }
    get ElapsedMilliseconds() {
        if (typeof this.startTime === "undefined") {
            return 0;
        }
        return new Date().getTime() - this.startTime;
    }
    Start() {
        this.startTime = new Date().getTime();
    }
    Stop() {
        this.startTime = undefined;
    }
}
exports.Stopwatch = Stopwatch;
//# sourceMappingURL=StopWatch.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Story.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Story.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Story = void 0;
const Container_1 = __webpack_require__(/*! ./Container */ "./node_modules/inkjs/engine/Container.js");
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const StoryState_1 = __webpack_require__(/*! ./StoryState */ "./node_modules/inkjs/engine/StoryState.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const ChoicePoint_1 = __webpack_require__(/*! ./ChoicePoint */ "./node_modules/inkjs/engine/ChoicePoint.js");
const Choice_1 = __webpack_require__(/*! ./Choice */ "./node_modules/inkjs/engine/Choice.js");
const Divert_1 = __webpack_require__(/*! ./Divert */ "./node_modules/inkjs/engine/Divert.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const VariableAssignment_1 = __webpack_require__(/*! ./VariableAssignment */ "./node_modules/inkjs/engine/VariableAssignment.js");
const VariableReference_1 = __webpack_require__(/*! ./VariableReference */ "./node_modules/inkjs/engine/VariableReference.js");
const NativeFunctionCall_1 = __webpack_require__(/*! ./NativeFunctionCall */ "./node_modules/inkjs/engine/NativeFunctionCall.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const ListDefinitionsOrigin_1 = __webpack_require__(/*! ./ListDefinitionsOrigin */ "./node_modules/inkjs/engine/ListDefinitionsOrigin.js");
const StopWatch_1 = __webpack_require__(/*! ./StopWatch */ "./node_modules/inkjs/engine/StopWatch.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
var InkList_2 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
Object.defineProperty(exports, "InkList", { enumerable: true, get: function () { return InkList_2.InkList; } });
if (!Number.isInteger) {
    Number.isInteger = function isInteger(nVal) {
        return (typeof nVal === "number" &&
            isFinite(nVal) &&
            nVal > -9007199254740992 &&
            nVal < 9007199254740992 &&
            Math.floor(nVal) === nVal);
    };
}
class Story extends Object_1.InkObject {
    constructor() {
        super();
        this.inkVersionMinimumCompatible = 18;
        this._prevContainers = [];
        this.allowExternalFunctionFallbacks = false;
        this._listDefinitions = null;
        this._variableObservers = null;
        this._hasValidatedExternals = false;
        this._temporaryEvaluationContainer = null;
        this._asyncContinueActive = false;
        this._stateSnapshotAtLastNewline = null;
        this._recursiveContinueCount = 0;
        this._asyncSaving = false;
        this._profiler = null; // TODO: Profiler
        // Discrimination between constructors
        let contentContainer;
        let lists = null;
        let json = null;
        if (arguments[0] instanceof Container_1.Container) {
            contentContainer = arguments[0];
            if (typeof arguments[1] !== "undefined") {
                lists = arguments[1];
            }
            // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
            this._mainContentContainer = contentContainer;
            // ------
        }
        else {
            if (typeof arguments[0] === "string") {
                let jsonString = arguments[0];
                json = SimpleJson_1.SimpleJson.TextToDictionary(jsonString);
            }
            else {
                json = arguments[0];
            }
        }
        // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)
        if (lists != null)
            this._listDefinitions = new ListDefinitionsOrigin_1.ListDefinitionsOrigin(lists);
        this._externals = new Map();
        // ------
        // ------ Story(string jsonString) : this((Container)null)
        if (json !== null) {
            let rootObject = json;
            let versionObj = rootObject["inkVersion"];
            if (versionObj == null)
                throw new Error("ink version number not found. Are you sure it's a valid .ink.json file?");
            let formatFromFile = parseInt(versionObj);
            if (formatFromFile > Story.inkVersionCurrent) {
                throw new Error("Version of ink used to build story was newer than the current version of the engine");
            }
            else if (formatFromFile < this.inkVersionMinimumCompatible) {
                throw new Error("Version of ink used to build story is too old to be loaded by this version of the engine");
            }
            else if (formatFromFile != Story.inkVersionCurrent) {
                console.warn("WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.");
            }
            let rootToken = rootObject["root"];
            if (rootToken == null)
                throw new Error("Root node for ink not found. Are you sure it's a valid .ink.json file?");
            let listDefsObj;
            if ((listDefsObj = rootObject["listDefs"])) {
                this._listDefinitions = JsonSerialisation_1.JsonSerialisation.JTokenToListDefinitions(listDefsObj);
            }
            this._mainContentContainer = TypeAssertion_1.asOrThrows(JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(rootToken), Container_1.Container);
            this.ResetState();
        }
        // ------
    }
    get currentChoices() {
        let choices = [];
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        for (let c of this._state.currentChoices) {
            if (!c.isInvisibleDefault) {
                c.index = choices.length;
                choices.push(c);
            }
        }
        return choices;
    }
    get currentText() {
        this.IfAsyncWeCant("call currentText since it's a work in progress");
        return this.state.currentText;
    }
    get currentTags() {
        this.IfAsyncWeCant("call currentTags since it's a work in progress");
        return this.state.currentTags;
    }
    get currentErrors() {
        return this.state.currentErrors;
    }
    get currentWarnings() {
        return this.state.currentWarnings;
    }
    get hasError() {
        return this.state.hasError;
    }
    get hasWarning() {
        return this.state.hasWarning;
    }
    get variablesState() {
        return this.state.variablesState;
    }
    get listDefinitions() {
        return this._listDefinitions;
    }
    get state() {
        return this._state;
    }
    // TODO: Implement Profiler
    StartProfiling() {
        /* */
    }
    EndProfiling() {
        /* */
    }
    // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.
    // Will only return a value if writer was not provided.
    ToJson(writer) {
        let shouldReturn = false;
        if (!writer) {
            shouldReturn = true;
            writer = new SimpleJson_1.SimpleJson.Writer();
        }
        writer.WriteObjectStart();
        writer.WriteIntProperty("inkVersion", Story.inkVersionCurrent);
        writer.WriteProperty("root", (w) => JsonSerialisation_1.JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer));
        if (this._listDefinitions != null) {
            writer.WritePropertyStart("listDefs");
            writer.WriteObjectStart();
            for (let def of this._listDefinitions.lists) {
                writer.WritePropertyStart(def.name);
                writer.WriteObjectStart();
                for (let [key, value] of def.items) {
                    let item = InkList_1.InkListItem.fromSerializedKey(key);
                    let val = value;
                    writer.WriteIntProperty(item.itemName, val);
                }
                writer.WriteObjectEnd();
                writer.WritePropertyEnd();
            }
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
        if (shouldReturn)
            return writer.ToString();
    }
    ResetState() {
        this.IfAsyncWeCant("ResetState");
        this._state = new StoryState_1.StoryState(this);
        this._state.variablesState.ObserveVariableChange(this.VariableStateDidChangeEvent.bind(this));
        this.ResetGlobals();
    }
    ResetErrors() {
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ResetErrors();
    }
    ResetCallstack() {
        this.IfAsyncWeCant("ResetCallstack");
        if (this._state === null) {
            return NullException_1.throwNullException("this._state");
        }
        this._state.ForceEnd();
    }
    ResetGlobals() {
        if (this._mainContentContainer.namedContent.get("global decl")) {
            let originalPointer = this.state.currentPointer.copy();
            this.ChoosePath(new Path_1.Path("global decl"), false);
            this.ContinueInternal();
            this.state.currentPointer = originalPointer;
        }
        this.state.variablesState.SnapshotDefaultGlobals();
    }
    Continue() {
        this.ContinueAsync(0);
        return this.currentText;
    }
    get canContinue() {
        return this.state.canContinue;
    }
    get asyncContinueComplete() {
        return !this._asyncContinueActive;
    }
    ContinueAsync(millisecsLimitAsync) {
        if (!this._hasValidatedExternals)
            this.ValidateExternalBindings();
        this.ContinueInternal(millisecsLimitAsync);
    }
    ContinueInternal(millisecsLimitAsync = 0) {
        if (this._profiler != null)
            this._profiler.PreContinue();
        let isAsyncTimeLimited = millisecsLimitAsync > 0;
        this._recursiveContinueCount++;
        if (!this._asyncContinueActive) {
            this._asyncContinueActive = isAsyncTimeLimited;
            if (!this.canContinue) {
                throw new StoryException_1.StoryException("Can't continue - should check canContinue before calling Continue");
            }
            this._state.didSafeExit = false;
            this._state.ResetOutput();
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = true;
        }
        let durationStopwatch = new StopWatch_1.Stopwatch();
        durationStopwatch.Start();
        let outputStreamEndsInNewline = false;
        do {
            try {
                outputStreamEndsInNewline = this.ContinueSingleStep();
            }
            catch (e) {
                if (!(e instanceof StoryException_1.StoryException))
                    throw e;
                this.AddError(e.message, undefined, e.useEndLineNumber);
                break;
            }
            if (outputStreamEndsInNewline)
                break;
            if (this._asyncContinueActive &&
                durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync) {
                break;
            }
        } while (this.canContinue);
        durationStopwatch.Stop();
        if (outputStreamEndsInNewline || !this.canContinue) {
            if (this._stateSnapshotAtLastNewline !== null) {
                this.RestoreStateSnapshot();
            }
            if (!this.canContinue) {
                if (this.state.callStack.canPopThread)
                    this.AddError("Thread available to pop, threads should always be flat by the end of evaluation?");
                if (this.state.generatedChoices.length == 0 &&
                    !this.state.didSafeExit &&
                    this._temporaryEvaluationContainer == null) {
                    if (this.state.callStack.CanPop(PushPop_1.PushPopType.Tunnel))
                        this.AddError("unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?");
                    else if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function))
                        this.AddError("unexpectedly reached end of content. Do you need a '~ return'?");
                    else if (!this.state.callStack.canPop)
                        this.AddError("ran out of content. Do you need a '-> DONE' or '-> END'?");
                    else
                        this.AddError("unexpectedly reached end of content for unknown reason. Please debug compiler!");
                }
            }
            this.state.didSafeExit = false;
            if (this._recursiveContinueCount == 1)
                this._state.variablesState.batchObservingVariableChanges = false;
            this._asyncContinueActive = false;
        }
        this._recursiveContinueCount--;
        if (this._profiler != null)
            this._profiler.PostContinue();
    }
    ContinueSingleStep() {
        if (this._profiler != null)
            this._profiler.PreStep();
        this.Step();
        if (this._profiler != null)
            this._profiler.PostStep();
        if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {
            this.TryFollowDefaultInvisibleChoice();
        }
        if (this._profiler != null)
            this._profiler.PreSnapshot();
        if (!this.state.inStringEvaluation) {
            if (this._stateSnapshotAtLastNewline !== null) {
                if (this._stateSnapshotAtLastNewline.currentTags === null) {
                    return NullException_1.throwNullException("this._stateAtLastNewline.currentTags");
                }
                if (this.state.currentTags === null) {
                    return NullException_1.throwNullException("this.state.currentTags");
                }
                let change = this.CalculateNewlineOutputStateChange(this._stateSnapshotAtLastNewline.currentText, this.state.currentText, this._stateSnapshotAtLastNewline.currentTags.length, this.state.currentTags.length);
                if (change == Story.OutputStateChange.ExtendedBeyondNewline) {
                    this.RestoreStateSnapshot();
                    return true;
                }
                else if (change == Story.OutputStateChange.NewlineRemoved) {
                    this.DiscardSnapshot();
                }
            }
            if (this.state.outputStreamEndsInNewline) {
                if (this.canContinue) {
                    if (this._stateSnapshotAtLastNewline == null)
                        this.StateSnapshot();
                }
                else {
                    this.DiscardSnapshot();
                }
            }
        }
        if (this._profiler != null)
            this._profiler.PostSnapshot();
        return false;
    }
    CalculateNewlineOutputStateChange(prevText, currText, prevTagCount, currTagCount) {
        if (prevText === null) {
            return NullException_1.throwNullException("prevText");
        }
        if (currText === null) {
            return NullException_1.throwNullException("currText");
        }
        let newlineStillExists = currText.length >= prevText.length &&
            currText.charAt(prevText.length - 1) == "\n";
        if (prevTagCount == currTagCount &&
            prevText.length == currText.length &&
            newlineStillExists)
            return Story.OutputStateChange.NoChange;
        if (!newlineStillExists) {
            return Story.OutputStateChange.NewlineRemoved;
        }
        if (currTagCount > prevTagCount)
            return Story.OutputStateChange.ExtendedBeyondNewline;
        for (let i = prevText.length; i < currText.length; i++) {
            let c = currText.charAt(i);
            if (c != " " && c != "\t") {
                return Story.OutputStateChange.ExtendedBeyondNewline;
            }
        }
        return Story.OutputStateChange.NoChange;
    }
    ContinueMaximally() {
        this.IfAsyncWeCant("ContinueMaximally");
        let sb = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            sb.Append(this.Continue());
        }
        return sb.toString();
    }
    ContentAtPath(path) {
        return this.mainContentContainer.ContentAtPath(path);
    }
    KnotContainerWithName(name) {
        let namedContainer = this.mainContentContainer.namedContent.get(name);
        if (namedContainer instanceof Container_1.Container)
            return namedContainer;
        else
            return null;
    }
    PointerAtPath(path) {
        if (path.length == 0)
            return Pointer_1.Pointer.Null;
        let p = new Pointer_1.Pointer();
        let pathLengthToUse = path.length;
        let result = null;
        if (path.lastComponent === null) {
            return NullException_1.throwNullException("path.lastComponent");
        }
        if (path.lastComponent.isIndex) {
            pathLengthToUse = path.length - 1;
            result = this.mainContentContainer.ContentAtPath(path, undefined, pathLengthToUse);
            p.container = result.container;
            p.index = path.lastComponent.index;
        }
        else {
            result = this.mainContentContainer.ContentAtPath(path);
            p.container = result.container;
            p.index = -1;
        }
        if (result.obj == null ||
            (result.obj == this.mainContentContainer && pathLengthToUse > 0)) {
            this.Error("Failed to find content at path '" +
                path +
                "', and no approximation of it was possible.");
        }
        else if (result.approximate)
            this.Warning("Failed to find content at path '" +
                path +
                "', so it was approximated to: '" +
                result.obj.path +
                "'.");
        return p;
    }
    StateSnapshot() {
        this._stateSnapshotAtLastNewline = this._state;
        this._state = this._state.CopyAndStartPatching();
    }
    RestoreStateSnapshot() {
        if (this._stateSnapshotAtLastNewline === null) {
            NullException_1.throwNullException("_stateSnapshotAtLastNewline");
        }
        this._stateSnapshotAtLastNewline.RestoreAfterPatch();
        this._state = this._stateSnapshotAtLastNewline;
        this._stateSnapshotAtLastNewline = null;
        if (!this._asyncSaving) {
            this._state.ApplyAnyPatch();
        }
    }
    DiscardSnapshot() {
        if (!this._asyncSaving)
            this._state.ApplyAnyPatch();
        this._stateSnapshotAtLastNewline = null;
    }
    CopyStateForBackgroundThreadSave() {
        this.IfAsyncWeCant("start saving on a background thread");
        if (this._asyncSaving)
            throw new Error("Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!");
        let stateToSave = this._state;
        this._state = this._state.CopyAndStartPatching();
        this._asyncSaving = true;
        return stateToSave;
    }
    BackgroundSaveComplete() {
        if (this._stateSnapshotAtLastNewline === null) {
            this._state.ApplyAnyPatch();
        }
        this._asyncSaving = false;
    }
    Step() {
        let shouldAddToStream = true;
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull) {
            return;
        }
        // Container containerToEnter = pointer.Resolve () as Container;
        let containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        while (containerToEnter) {
            this.VisitContainer(containerToEnter, true);
            // No content? the most we can do is step past it
            if (containerToEnter.content.length == 0) {
                break;
            }
            pointer = Pointer_1.Pointer.StartOf(containerToEnter);
            // containerToEnter = pointer.Resolve() as Container;
            containerToEnter = TypeAssertion_1.asOrNull(pointer.Resolve(), Container_1.Container);
        }
        this.state.currentPointer = pointer.copy();
        if (this._profiler != null)
            this._profiler.Step(this.state.callStack);
        // Is the current content object:
        //  - Normal content
        //  - Or a logic/flow statement - if so, do it
        // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot
        // that was diverted to rather than called as a function)
        let currentContentObj = pointer.Resolve();
        let isLogicOrFlowControl = this.PerformLogicAndFlowControl(currentContentObj);
        // Has flow been forced to end by flow control above?
        if (this.state.currentPointer.isNull) {
            return;
        }
        if (isLogicOrFlowControl) {
            shouldAddToStream = false;
        }
        // Choice with condition?
        // var choicePoint = currentContentObj as ChoicePoint;
        let choicePoint = TypeAssertion_1.asOrNull(currentContentObj, ChoicePoint_1.ChoicePoint);
        if (choicePoint) {
            let choice = this.ProcessChoice(choicePoint);
            if (choice) {
                this.state.generatedChoices.push(choice);
            }
            currentContentObj = null;
            shouldAddToStream = false;
        }
        // If the container has no content, then it will be
        // the "content" itself, but we skip over it.
        if (currentContentObj instanceof Container_1.Container) {
            shouldAddToStream = false;
        }
        // Content to add to evaluation stack or the output stream
        if (shouldAddToStream) {
            // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific
            // to our current (possibly temporary) context index. And make a copy of the pointer
            // so that we're not editing the original runtime object.
            // var varPointer = currentContentObj as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(currentContentObj, Value_1.VariablePointerValue);
            if (varPointer && varPointer.contextIndex == -1) {
                // Create new object so we're not overwriting the story's own data
                let contextIdx = this.state.callStack.ContextForVariableNamed(varPointer.variableName);
                currentContentObj = new Value_1.VariablePointerValue(varPointer.variableName, contextIdx);
            }
            // Expression evaluation content
            if (this.state.inExpressionEvaluation) {
                this.state.PushEvaluationStack(currentContentObj);
            }
            // Output stream content (i.e. not expression evaluation)
            else {
                this.state.PushToOutputStream(currentContentObj);
            }
        }
        // Increment the content pointer, following diverts if necessary
        this.NextContent();
        // Starting a thread should be done after the increment to the content pointer,
        // so that when returning from the thread, it returns to the content after this instruction.
        // var controlCmd = currentContentObj as ;
        let controlCmd = TypeAssertion_1.asOrNull(currentContentObj, ControlCommand_1.ControlCommand);
        if (controlCmd &&
            controlCmd.commandType == ControlCommand_1.ControlCommand.CommandType.StartThread) {
            this.state.callStack.PushThread();
        }
    }
    VisitContainer(container, atStart) {
        if (!container.countingAtStartOnly || atStart) {
            if (container.visitsShouldBeCounted)
                this.state.IncrementVisitCountForContainer(container);
            if (container.turnIndexShouldBeCounted)
                this.state.RecordTurnIndexVisitToContainer(container);
        }
    }
    VisitChangedContainersDueToDivert() {
        let previousPointer = this.state.previousPointer.copy();
        let pointer = this.state.currentPointer.copy();
        if (pointer.isNull || pointer.index == -1)
            return;
        this._prevContainers.length = 0;
        if (!previousPointer.isNull) {
            // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;
            let resolvedPreviousAncestor = previousPointer.Resolve();
            let prevAncestor = TypeAssertion_1.asOrNull(resolvedPreviousAncestor, Container_1.Container) ||
                TypeAssertion_1.asOrNull(previousPointer.container, Container_1.Container);
            while (prevAncestor) {
                this._prevContainers.push(prevAncestor);
                // prevAncestor = prevAncestor.parent as Container;
                prevAncestor = TypeAssertion_1.asOrNull(prevAncestor.parent, Container_1.Container);
            }
        }
        let currentChildOfContainer = pointer.Resolve();
        if (currentChildOfContainer == null)
            return;
        // Container currentContainerAncestor = currentChildOfContainer.parent as Container;
        let currentContainerAncestor = TypeAssertion_1.asOrNull(currentChildOfContainer.parent, Container_1.Container);
        while (currentContainerAncestor &&
            (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||
                currentContainerAncestor.countingAtStartOnly)) {
            // Check whether this ancestor container is being entered at the start,
            // by checking whether the child object is the first.
            let enteringAtStart = currentContainerAncestor.content.length > 0 &&
                currentChildOfContainer == currentContainerAncestor.content[0];
            // Mark a visit to this container
            this.VisitContainer(currentContainerAncestor, enteringAtStart);
            currentChildOfContainer = currentContainerAncestor;
            // currentContainerAncestor = currentContainerAncestor.parent as Container;
            currentContainerAncestor = TypeAssertion_1.asOrNull(currentContainerAncestor.parent, Container_1.Container);
        }
    }
    ProcessChoice(choicePoint) {
        let showChoice = true;
        // Don't create choice if choice point doesn't pass conditional
        if (choicePoint.hasCondition) {
            let conditionValue = this.state.PopEvaluationStack();
            if (!this.IsTruthy(conditionValue)) {
                showChoice = false;
            }
        }
        let startText = "";
        let choiceOnlyText = "";
        if (choicePoint.hasChoiceOnlyContent) {
            // var choiceOnlyStrVal = state.PopEvaluationStack () as StringValue;
            let choiceOnlyStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            choiceOnlyText = choiceOnlyStrVal.value || "";
        }
        if (choicePoint.hasStartContent) {
            // var startStrVal = state.PopEvaluationStack () as StringValue;
            let startStrVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
            startText = startStrVal.value || "";
        }
        // Don't create choice if player has already read this content
        if (choicePoint.onceOnly) {
            let visitCount = this.state.VisitCountForContainer(choicePoint.choiceTarget);
            if (visitCount > 0) {
                showChoice = false;
            }
        }
        // We go through the full process of creating the choice above so
        // that we consume the content for it, since otherwise it'll
        // be shown on the output stream.
        if (!showChoice) {
            return null;
        }
        let choice = new Choice_1.Choice();
        choice.targetPath = choicePoint.pathOnChoice;
        choice.sourcePath = choicePoint.path.toString();
        choice.isInvisibleDefault = choicePoint.isInvisibleDefault;
        choice.threadAtGeneration = this.state.callStack.ForkThread();
        choice.text = (startText + choiceOnlyText).replace(/^[ \t]+|[ \t]+$/g, "");
        return choice;
    }
    IsTruthy(obj) {
        let truthy = false;
        if (obj instanceof Value_1.Value) {
            let val = obj;
            if (val instanceof Value_1.DivertTargetValue) {
                let divTarget = val;
                this.Error("Shouldn't use a divert target (to " +
                    divTarget.targetPath +
                    ") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)");
                return false;
            }
            return val.isTruthy;
        }
        return truthy;
    }
    PerformLogicAndFlowControl(contentObj) {
        if (contentObj == null) {
            return false;
        }
        // Divert
        if (contentObj instanceof Divert_1.Divert) {
            let currentDivert = contentObj;
            if (currentDivert.isConditional) {
                let conditionValue = this.state.PopEvaluationStack();
                // False conditional? Cancel divert
                if (!this.IsTruthy(conditionValue))
                    return true;
            }
            if (currentDivert.hasVariableTarget) {
                let varName = currentDivert.variableDivertName;
                let varContents = this.state.variablesState.GetVariableWithName(varName);
                if (varContents == null) {
                    this.Error("Tried to divert using a target from a variable that could not be found (" +
                        varName +
                        ")");
                }
                else if (!(varContents instanceof Value_1.DivertTargetValue)) {
                    // var intContent = varContents as IntValue;
                    let intContent = TypeAssertion_1.asOrNull(varContents, Value_1.IntValue);
                    let errorMessage = "Tried to divert to a target from a variable, but the variable (" +
                        varName +
                        ") didn't contain a divert target, it ";
                    if (intContent instanceof Value_1.IntValue && intContent.value == 0) {
                        errorMessage += "was empty/null (the value 0).";
                    }
                    else {
                        errorMessage += "contained '" + varContents + "'.";
                    }
                    this.Error(errorMessage);
                }
                let target = TypeAssertion_1.asOrThrows(varContents, Value_1.DivertTargetValue);
                this.state.divertedPointer = this.PointerAtPath(target.targetPath);
            }
            else if (currentDivert.isExternal) {
                this.CallExternalFunction(currentDivert.targetPathString, currentDivert.externalArgs);
                return true;
            }
            else {
                this.state.divertedPointer = currentDivert.targetPointer.copy();
            }
            if (currentDivert.pushesToStack) {
                this.state.callStack.Push(currentDivert.stackPushType, undefined, this.state.outputStream.length);
            }
            if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {
                if (currentDivert &&
                    currentDivert.debugMetadata &&
                    currentDivert.debugMetadata.sourceName != null) {
                    this.Error("Divert target doesn't exist: " +
                        currentDivert.debugMetadata.sourceName);
                }
                else {
                    this.Error("Divert resolution failed: " + currentDivert);
                }
            }
            return true;
        }
        // Start/end an expression evaluation? Or print out the result?
        else if (contentObj instanceof ControlCommand_1.ControlCommand) {
            let evalCommand = contentObj;
            switch (evalCommand.commandType) {
                case ControlCommand_1.ControlCommand.CommandType.EvalStart:
                    this.Assert(this.state.inExpressionEvaluation === false, "Already in expression evaluation?");
                    this.state.inExpressionEvaluation = true;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalEnd:
                    this.Assert(this.state.inExpressionEvaluation === true, "Not in expression evaluation mode");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EvalOutput:
                    // If the expression turned out to be empty, there may not be anything on the stack
                    if (this.state.evaluationStack.length > 0) {
                        let output = this.state.PopEvaluationStack();
                        // Functions may evaluate to Void, in which case we skip output
                        if (!(output instanceof Void_1.Void)) {
                            // TODO: Should we really always blanket convert to string?
                            // It would be okay to have numbers in the output stream the
                            // only problem is when exporting text for viewing, it skips over numbers etc.
                            let text = new Value_1.StringValue(output.toString());
                            this.state.PushToOutputStream(text);
                        }
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.NoOp:
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Duplicate:
                    this.state.PushEvaluationStack(this.state.PeekEvaluationStack());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopEvaluatedValue:
                    this.state.PopEvaluationStack();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.PopFunction:
                case ControlCommand_1.ControlCommand.CommandType.PopTunnel:
                    let popType = evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.PopFunction
                        ? PushPop_1.PushPopType.Function
                        : PushPop_1.PushPopType.Tunnel;
                    let overrideTunnelReturnTarget = null;
                    if (popType == PushPop_1.PushPopType.Tunnel) {
                        let popped = this.state.PopEvaluationStack();
                        // overrideTunnelReturnTarget = popped as DivertTargetValue;
                        overrideTunnelReturnTarget = TypeAssertion_1.asOrNull(popped, Value_1.DivertTargetValue);
                        if (overrideTunnelReturnTarget === null) {
                            this.Assert(popped instanceof Void_1.Void, "Expected void if ->-> doesn't override target");
                        }
                    }
                    if (this.state.TryExitFunctionEvaluationFromGame()) {
                        break;
                    }
                    else if (this.state.callStack.currentElement.type != popType ||
                        !this.state.callStack.canPop) {
                        let names = new Map();
                        names.set(PushPop_1.PushPopType.Function, "function return statement (~ return)");
                        names.set(PushPop_1.PushPopType.Tunnel, "tunnel onwards statement (->->)");
                        let expected = names.get(this.state.callStack.currentElement.type);
                        if (!this.state.callStack.canPop) {
                            expected = "end of flow (-> END or choice)";
                        }
                        let errorMsg = "Found " + names.get(popType) + ", when expected " + expected;
                        this.Error(errorMsg);
                    }
                    else {
                        this.state.PopCallStack();
                        if (overrideTunnelReturnTarget)
                            this.state.divertedPointer = this.PointerAtPath(overrideTunnelReturnTarget.targetPath);
                    }
                    break;
                case ControlCommand_1.ControlCommand.CommandType.BeginString:
                    this.state.PushToOutputStream(evalCommand);
                    this.Assert(this.state.inExpressionEvaluation === true, "Expected to be in an expression when evaluating a string");
                    this.state.inExpressionEvaluation = false;
                    break;
                case ControlCommand_1.ControlCommand.CommandType.EndString:
                    let contentStackForString = [];
                    let outputCountConsumed = 0;
                    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
                        let obj = this.state.outputStream[i];
                        outputCountConsumed++;
                        // var command = obj as ControlCommand;
                        let command = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
                        if (command &&
                            command.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                            break;
                        }
                        if (obj instanceof Value_1.StringValue) {
                            contentStackForString.push(obj);
                        }
                    }
                    // Consume the content that was produced for this string
                    this.state.PopFromOutputStream(outputCountConsumed);
                    // The C# version uses a Stack for contentStackForString, but we're
                    // using a simple array, so we need to reverse it before using it
                    contentStackForString = contentStackForString.reverse();
                    // Build string out of the content we collected
                    let sb = new StringBuilder_1.StringBuilder();
                    for (let c of contentStackForString) {
                        sb.Append(c.toString());
                    }
                    // Return to expression evaluation (from content mode)
                    this.state.inExpressionEvaluation = true;
                    this.state.PushEvaluationStack(new Value_1.StringValue(sb.toString()));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ChoiceCount:
                    let choiceCount = this.state.generatedChoices.length;
                    this.state.PushEvaluationStack(new Value_1.IntValue(choiceCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Turns:
                    this.state.PushEvaluationStack(new Value_1.IntValue(this.state.currentTurnIndex + 1));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.TurnsSince:
                case ControlCommand_1.ControlCommand.CommandType.ReadCount:
                    let target = this.state.PopEvaluationStack();
                    if (!(target instanceof Value_1.DivertTargetValue)) {
                        let extraNote = "";
                        if (target instanceof Value_1.IntValue)
                            extraNote =
                                ". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?";
                        this.Error("TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw " +
                            target +
                            extraNote);
                        break;
                    }
                    // var divertTarget = target as DivertTargetValue;
                    let divertTarget = TypeAssertion_1.asOrThrows(target, Value_1.DivertTargetValue);
                    // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;
                    let container = TypeAssertion_1.asOrNull(this.ContentAtPath(divertTarget.targetPath).correctObj, Container_1.Container);
                    let eitherCount;
                    if (container != null) {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = this.state.TurnsSinceForContainer(container);
                        else
                            eitherCount = this.state.VisitCountForContainer(container);
                    }
                    else {
                        if (evalCommand.commandType == ControlCommand_1.ControlCommand.CommandType.TurnsSince)
                            eitherCount = -1;
                        else
                            eitherCount = 0;
                        this.Warning("Failed to find container for " +
                            evalCommand.toString() +
                            " lookup at " +
                            divertTarget.targetPath.toString());
                    }
                    this.state.PushEvaluationStack(new Value_1.IntValue(eitherCount));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Random: {
                    let maxInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    let minInt = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (minInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for minimum parameter of RANDOM(min, max)");
                    if (maxInt == null || minInt instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value for maximum parameter of RANDOM(min, max)");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (maxInt.value === null) {
                        return NullException_1.throwNullException("maxInt.value");
                    }
                    if (minInt.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    let randomRange = maxInt.value - minInt.value + 1;
                    if (randomRange <= 0)
                        this.Error("RANDOM was called with minimum as " +
                            minInt.value +
                            " and maximum as " +
                            maxInt.value +
                            ". The maximum must be larger");
                    let resultSeed = this.state.storySeed + this.state.previousRandom;
                    let random = new PRNG_1.PRNG(resultSeed);
                    let nextRandom = random.next();
                    let chosenValue = (nextRandom % randomRange) + minInt.value;
                    this.state.PushEvaluationStack(new Value_1.IntValue(chosenValue));
                    // Next random number (rather than keeping the Random object around)
                    this.state.previousRandom = nextRandom;
                    break;
                }
                case ControlCommand_1.ControlCommand.CommandType.SeedRandom:
                    let seed = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    if (seed == null || seed instanceof Value_1.IntValue === false)
                        return this.Error("Invalid value passed to SEED_RANDOM");
                    // Originally a primitive type, but here, can be null.
                    // TODO: Replace by default value?
                    if (seed.value === null) {
                        return NullException_1.throwNullException("minInt.value");
                    }
                    this.state.storySeed = seed.value;
                    this.state.previousRandom = 0;
                    this.state.PushEvaluationStack(new Void_1.Void());
                    break;
                case ControlCommand_1.ControlCommand.CommandType.VisitIndex:
                    let count = this.state.VisitCountForContainer(this.state.currentPointer.container) - 1; // index not count
                    this.state.PushEvaluationStack(new Value_1.IntValue(count));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.SequenceShuffleIndex:
                    let shuffleIndex = this.NextSequenceShuffleIndex();
                    this.state.PushEvaluationStack(new Value_1.IntValue(shuffleIndex));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.StartThread:
                    // Handled in main step function
                    break;
                case ControlCommand_1.ControlCommand.CommandType.Done:
                    // We may exist in the context of the initial
                    // act of creating the thread, or in the context of
                    // evaluating the content.
                    if (this.state.callStack.canPopThread) {
                        this.state.callStack.PopThread();
                    }
                    // In normal flow - allow safe exit without warning
                    else {
                        this.state.didSafeExit = true;
                        // Stop flow in current thread
                        this.state.currentPointer = Pointer_1.Pointer.Null;
                    }
                    break;
                // Force flow to end completely
                case ControlCommand_1.ControlCommand.CommandType.End:
                    this.state.ForceEnd();
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListFromInt:
                    // var intVal = state.PopEvaluationStack () as IntValue;
                    let intVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
                    // var listNameVal = state.PopEvaluationStack () as StringValue;
                    let listNameVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.StringValue);
                    if (intVal === null) {
                        throw new StoryException_1.StoryException("Passed non-integer when creating a list element from a numerical value.");
                    }
                    let generatedListValue = null;
                    if (this.listDefinitions === null) {
                        return NullException_1.throwNullException("this.listDefinitions");
                    }
                    let foundListDef = this.listDefinitions.TryListGetDefinition(listNameVal.value, null);
                    if (foundListDef.exists) {
                        // Originally a primitive type, but here, can be null.
                        // TODO: Replace by default value?
                        if (intVal.value === null) {
                            return NullException_1.throwNullException("minInt.value");
                        }
                        let foundItem = foundListDef.result.TryGetItemWithValue(intVal.value, InkList_1.InkListItem.Null);
                        if (foundItem.exists) {
                            generatedListValue = new Value_1.ListValue(foundItem.result, intVal.value);
                        }
                    }
                    else {
                        throw new StoryException_1.StoryException("Failed to find LIST called " + listNameVal.value);
                    }
                    if (generatedListValue == null)
                        generatedListValue = new Value_1.ListValue();
                    this.state.PushEvaluationStack(generatedListValue);
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRange:
                    let max = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    let min = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.Value);
                    // var targetList = state.PopEvaluationStack () as ListValue;
                    let targetList = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.ListValue);
                    if (targetList === null || min === null || max === null)
                        throw new StoryException_1.StoryException("Expected list, minimum and maximum for LIST_RANGE");
                    if (targetList.value === null) {
                        return NullException_1.throwNullException("targetList.value");
                    }
                    let result = targetList.value.ListWithSubRange(min.valueObject, max.valueObject);
                    this.state.PushEvaluationStack(new Value_1.ListValue(result));
                    break;
                case ControlCommand_1.ControlCommand.CommandType.ListRandom: {
                    let listVal = this.state.PopEvaluationStack();
                    if (listVal === null)
                        throw new StoryException_1.StoryException("Expected list for LIST_RANDOM");
                    let list = listVal.value;
                    let newList = null;
                    if (list === null) {
                        throw NullException_1.throwNullException("list");
                    }
                    if (list.Count == 0) {
                        newList = new InkList_1.InkList();
                    }
                    else {
                        // Generate a random index for the element to take
                        let resultSeed = this.state.storySeed + this.state.previousRandom;
                        let random = new PRNG_1.PRNG(resultSeed);
                        let nextRandom = random.next();
                        let listItemIndex = nextRandom % list.Count;
                        // This bit is a little different from the original
                        // C# code, since iterators do not work in the same way.
                        // First, we iterate listItemIndex - 1 times, calling next().
                        // The listItemIndex-th time is made outside of the loop,
                        // in order to retrieve the value.
                        let listEnumerator = list.entries();
                        for (let i = 0; i <= listItemIndex - 1; i++) {
                            listEnumerator.next();
                        }
                        let value = listEnumerator.next().value;
                        let randomItem = {
                            Key: InkList_1.InkListItem.fromSerializedKey(value[0]),
                            Value: value[1],
                        };
                        // Origin list is simply the origin of the one element
                        if (randomItem.Key.originName === null) {
                            return NullException_1.throwNullException("randomItem.Key.originName");
                        }
                        newList = new InkList_1.InkList(randomItem.Key.originName, this);
                        newList.Add(randomItem.Key, randomItem.Value);
                        this.state.previousRandom = nextRandom;
                    }
                    this.state.PushEvaluationStack(new Value_1.ListValue(newList));
                    break;
                }
                default:
                    this.Error("unhandled ControlCommand: " + evalCommand);
                    break;
            }
            return true;
        }
        // Variable assignment
        else if (contentObj instanceof VariableAssignment_1.VariableAssignment) {
            let varAss = contentObj;
            let assignedVal = this.state.PopEvaluationStack();
            this.state.variablesState.Assign(varAss, assignedVal);
            return true;
        }
        // Variable reference
        else if (contentObj instanceof VariableReference_1.VariableReference) {
            let varRef = contentObj;
            let foundValue = null;
            // Explicit read count value
            if (varRef.pathForCount != null) {
                let container = varRef.containerForCount;
                let count = this.state.VisitCountForContainer(container);
                foundValue = new Value_1.IntValue(count);
            }
            // Normal variable reference
            else {
                foundValue = this.state.variablesState.GetVariableWithName(varRef.name);
                if (foundValue == null) {
                    this.Warning("Variable not found: '" +
                        varRef.name +
                        "'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.");
                    foundValue = new Value_1.IntValue(0);
                }
            }
            this.state.PushEvaluationStack(foundValue);
            return true;
        }
        // Native function call
        else if (contentObj instanceof NativeFunctionCall_1.NativeFunctionCall) {
            let func = contentObj;
            let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);
            let result = func.Call(funcParams);
            this.state.PushEvaluationStack(result);
            return true;
        }
        // No control content, must be ordinary content
        return false;
    }
    ChoosePathString(path, resetCallstack = true, args = []) {
        this.IfAsyncWeCant("call ChoosePathString right now");
        if (resetCallstack) {
            this.ResetCallstack();
        }
        else {
            if (this.state.callStack.currentElement.type == PushPop_1.PushPopType.Function) {
                let funcDetail = "";
                let container = this.state.callStack.currentElement.currentPointer
                    .container;
                if (container != null) {
                    funcDetail = "(" + container.path.toString() + ") ";
                }
                throw new Error("Story was running a function " +
                    funcDetail +
                    "when you called ChoosePathString(" +
                    path +
                    ") - this is almost certainly not not what you want! Full stack trace: \n" +
                    this.state.callStack.callStackTrace);
            }
        }
        this.state.PassArgumentsToEvaluationStack(args);
        this.ChoosePath(new Path_1.Path(path));
    }
    IfAsyncWeCant(activityStr) {
        if (this._asyncContinueActive)
            throw new Error("Can't " +
                activityStr +
                ". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.");
    }
    ChoosePath(p, incrementingTurnIndex = true) {
        this.state.SetChosenPath(p, incrementingTurnIndex);
        // Take a note of newly visited containers for read counts etc
        this.VisitChangedContainersDueToDivert();
    }
    ChooseChoiceIndex(choiceIdx) {
        choiceIdx = choiceIdx;
        let choices = this.currentChoices;
        this.Assert(choiceIdx >= 0 && choiceIdx < choices.length, "choice out of range");
        let choiceToChoose = choices[choiceIdx];
        if (choiceToChoose.threadAtGeneration === null) {
            return NullException_1.throwNullException("choiceToChoose.threadAtGeneration");
        }
        if (choiceToChoose.targetPath === null) {
            return NullException_1.throwNullException("choiceToChoose.targetPath");
        }
        this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;
        this.ChoosePath(choiceToChoose.targetPath);
    }
    HasFunction(functionName) {
        try {
            return this.KnotContainerWithName(functionName) != null;
        }
        catch (e) {
            return false;
        }
    }
    EvaluateFunction(functionName, args = [], returnTextOutput = false) {
        // EvaluateFunction behaves slightly differently than the C# version.
        // In C#, you can pass a (second) parameter `out textOutput` to get the
        // text outputted by the function. This is not possible in js. Instead,
        // we maintain the regular signature (functionName, args), plus an
        // optional third parameter returnTextOutput. If set to true, we will
        // return both the textOutput and the returned value, as an object.
        this.IfAsyncWeCant("evaluate a function");
        if (functionName == null) {
            throw new Error("Function is null");
        }
        else if (functionName == "" || functionName.trim() == "") {
            throw new Error("Function is empty or white space.");
        }
        let funcContainer = this.KnotContainerWithName(functionName);
        if (funcContainer == null) {
            throw new Error("Function doesn't exist: '" + functionName + "'");
        }
        let outputStreamBefore = [];
        outputStreamBefore.push.apply(outputStreamBefore, this.state.outputStream);
        this._state.ResetOutput();
        this.state.StartFunctionEvaluationFromGame(funcContainer, args);
        // Evaluate the function, and collect the string output
        let stringOutput = new StringBuilder_1.StringBuilder();
        while (this.canContinue) {
            stringOutput.Append(this.Continue());
        }
        let textOutput = stringOutput.toString();
        this._state.ResetOutput(outputStreamBefore);
        let result = this.state.CompleteFunctionEvaluationFromGame();
        return returnTextOutput ? { returned: result, output: textOutput } : result;
    }
    EvaluateExpression(exprContainer) {
        let startCallStackHeight = this.state.callStack.elements.length;
        this.state.callStack.Push(PushPop_1.PushPopType.Tunnel);
        this._temporaryEvaluationContainer = exprContainer;
        this.state.GoToStart();
        let evalStackHeight = this.state.evaluationStack.length;
        this.Continue();
        this._temporaryEvaluationContainer = null;
        // Should have fallen off the end of the Container, which should
        // have auto-popped, but just in case we didn't for some reason,
        // manually pop to restore the state (including currentPath).
        if (this.state.callStack.elements.length > startCallStackHeight) {
            this.state.PopCallStack();
        }
        let endStackHeight = this.state.evaluationStack.length;
        if (endStackHeight > evalStackHeight) {
            return this.state.PopEvaluationStack();
        }
        else {
            return null;
        }
    }
    CallExternalFunction(funcName, numberOfArguments) {
        if (funcName === null) {
            return NullException_1.throwNullException("funcName");
        }
        let func = this._externals.get(funcName);
        let fallbackFunctionContainer = null;
        let foundExternal = typeof func !== "undefined";
        // Try to use fallback function?
        if (!foundExternal) {
            if (this.allowExternalFunctionFallbacks) {
                fallbackFunctionContainer = this.KnotContainerWithName(funcName);
                this.Assert(fallbackFunctionContainer !== null, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound, and fallback ink function could not be found.");
                // Divert direct into fallback function and we're done
                this.state.callStack.Push(PushPop_1.PushPopType.Function, undefined, this.state.outputStream.length);
                this.state.divertedPointer = Pointer_1.Pointer.StartOf(fallbackFunctionContainer);
                return;
            }
            else {
                this.Assert(false, "Trying to call EXTERNAL function '" +
                    funcName +
                    "' which has not been bound (and ink fallbacks disabled).");
            }
        }
        // Pop arguments
        let args = [];
        for (let i = 0; i < numberOfArguments; ++i) {
            // var poppedObj = state.PopEvaluationStack () as Value;
            let poppedObj = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.Value);
            let valueObj = poppedObj.valueObject;
            args.push(valueObj);
        }
        // Reverse arguments from the order they were popped,
        // so they're the right way round again.
        args.reverse();
        // Run the function!
        let funcResult = func(args);
        // Convert return value (if any) to the a type that the ink engine can use
        let returnObj = null;
        if (funcResult != null) {
            returnObj = Value_1.Value.Create(funcResult);
            this.Assert(returnObj !== null, "Could not create ink value from returned object of type " +
                typeof funcResult);
        }
        else {
            returnObj = new Void_1.Void();
        }
        this.state.PushEvaluationStack(returnObj);
    }
    BindExternalFunctionGeneral(funcName, func) {
        this.IfAsyncWeCant("bind an external function");
        this.Assert(!this._externals.has(funcName), "Function '" + funcName + "' has already been bound.");
        this._externals.set(funcName, func);
    }
    TryCoerce(value) {
        // We're skipping type coercition in this implementation. First of, js
        // is loosely typed, so it's not that important. Secondly, there is no
        // clean way (AFAIK) for the user to describe what type of parameters
        // they expect.
        return value;
    }
    BindExternalFunction(funcName, func) {
        this.Assert(func != null, "Can't bind a null function");
        this.BindExternalFunctionGeneral(funcName, (args) => {
            this.Assert(args.length >= func.length, "External function expected " + func.length + " arguments");
            let coercedArgs = [];
            for (let i = 0, l = args.length; i < l; i++) {
                coercedArgs[i] = this.TryCoerce(args[i]);
            }
            return func.apply(null, coercedArgs);
        });
    }
    UnbindExternalFunction(funcName) {
        this.IfAsyncWeCant("unbind an external a function");
        this.Assert(this._externals.has(funcName), "Function '" + funcName + "' has not been bound.");
        this._externals.delete(funcName);
    }
    ValidateExternalBindings() {
        let c = null;
        let o = null;
        let missingExternals = arguments[1] || new Set();
        if (arguments[0] instanceof Container_1.Container) {
            c = arguments[0];
        }
        if (arguments[0] instanceof Object_1.InkObject) {
            o = arguments[0];
        }
        if (c === null && o === null) {
            this.ValidateExternalBindings(this._mainContentContainer, missingExternals);
            this._hasValidatedExternals = true;
            // No problem! Validation complete
            if (missingExternals.size == 0) {
                this._hasValidatedExternals = true;
            }
            else {
                let message = "Error: Missing function binding for external";
                message += missingExternals.size > 1 ? "s" : "";
                message += ": '";
                message += Array.from(missingExternals).join("', '");
                message += "' ";
                message += this.allowExternalFunctionFallbacks
                    ? ", and no fallback ink function found."
                    : " (ink fallbacks disabled)";
                this.Error(message);
            }
        }
        else if (c != null) {
            for (let innerContent of c.content) {
                let container = innerContent;
                if (container == null || !container.hasValidName)
                    this.ValidateExternalBindings(innerContent, missingExternals);
            }
            for (let [, value] of c.namedContent) {
                this.ValidateExternalBindings(TypeAssertion_1.asOrNull(value, Object_1.InkObject), missingExternals);
            }
        }
        else if (o != null) {
            let divert = TypeAssertion_1.asOrNull(o, Divert_1.Divert);
            if (divert && divert.isExternal) {
                let name = divert.targetPathString;
                if (name === null) {
                    return NullException_1.throwNullException("name");
                }
                if (!this._externals.has(name)) {
                    if (this.allowExternalFunctionFallbacks) {
                        let fallbackFound = this.mainContentContainer.namedContent.has(name);
                        if (!fallbackFound) {
                            missingExternals.add(name);
                        }
                    }
                    else {
                        missingExternals.add(name);
                    }
                }
            }
        }
    }
    ObserveVariable(variableName, observer) {
        this.IfAsyncWeCant("observe a new variable");
        if (this._variableObservers === null)
            this._variableObservers = new Map();
        if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))
            throw new StoryException_1.StoryException("Cannot observe variable '" +
                variableName +
                "' because it wasn't declared in the ink story.");
        if (this._variableObservers.has(variableName)) {
            this._variableObservers.get(variableName).push(observer);
        }
        else {
            this._variableObservers.set(variableName, [observer]);
        }
    }
    ObserveVariables(variableNames, observers) {
        for (let i = 0, l = variableNames.length; i < l; i++) {
            this.ObserveVariable(variableNames[i], observers[i]);
        }
    }
    RemoveVariableObserver(observer, specificVariableName) {
        this.IfAsyncWeCant("remove a variable observer");
        if (this._variableObservers === null)
            return;
        if (typeof specificVariableName !== "undefined") {
            if (this._variableObservers.has(specificVariableName)) {
                let observers = this._variableObservers.get(specificVariableName);
                if (observer !== null) {
                    observers.splice(observers.indexOf(observer), 1);
                }
                else {
                    this._variableObservers.delete(specificVariableName);
                }
            }
        }
        else if (observer !== null) {
            let keys = this._variableObservers.keys();
            for (let varName of keys) {
                let observers = this._variableObservers.get(varName);
                observers.splice(observers.indexOf(observer), 1);
            }
        }
    }
    VariableStateDidChangeEvent(variableName, newValueObj) {
        if (this._variableObservers === null)
            return;
        let observers = this._variableObservers.get(variableName);
        if (typeof observers !== "undefined") {
            if (!(newValueObj instanceof Value_1.Value)) {
                throw new Error("Tried to get the value of a variable that isn't a standard type");
            }
            // var val = newValueObj as Value;
            let val = TypeAssertion_1.asOrThrows(newValueObj, Value_1.Value);
            for (let observer of observers) {
                observer(variableName, val.valueObject);
            }
        }
    }
    get globalTags() {
        return this.TagsAtStartOfFlowContainerWithPathString("");
    }
    TagsForContentAtPath(path) {
        return this.TagsAtStartOfFlowContainerWithPathString(path);
    }
    TagsAtStartOfFlowContainerWithPathString(pathString) {
        let path = new Path_1.Path(pathString);
        let flowContainer = this.ContentAtPath(path).container;
        if (flowContainer === null) {
            return NullException_1.throwNullException("flowContainer");
        }
        while (true) {
            let firstContent = flowContainer.content[0];
            if (firstContent instanceof Container_1.Container)
                flowContainer = firstContent;
            else
                break;
        }
        let tags = null;
        for (let c of flowContainer.content) {
            // var tag = c as Runtime.Tag;
            let tag = TypeAssertion_1.asOrNull(c, Tag_1.Tag);
            if (tag) {
                if (tags == null)
                    tags = [];
                tags.push(tag.text);
            }
            else
                break;
        }
        return tags;
    }
    BuildStringOfHierarchy() {
        let sb = new StringBuilder_1.StringBuilder();
        this.mainContentContainer.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    BuildStringOfContainer(container) {
        let sb = new StringBuilder_1.StringBuilder();
        container.BuildStringOfHierarchy(sb, 0, this.state.currentPointer.Resolve());
        return sb.toString();
    }
    NextContent() {
        this.state.previousPointer = this.state.currentPointer.copy();
        if (!this.state.divertedPointer.isNull) {
            this.state.currentPointer = this.state.divertedPointer.copy();
            this.state.divertedPointer = Pointer_1.Pointer.Null;
            this.VisitChangedContainersDueToDivert();
            if (!this.state.currentPointer.isNull) {
                return;
            }
        }
        let successfulPointerIncrement = this.IncrementContentPointer();
        if (!successfulPointerIncrement) {
            let didPop = false;
            if (this.state.callStack.CanPop(PushPop_1.PushPopType.Function)) {
                this.state.PopCallStack(PushPop_1.PushPopType.Function);
                if (this.state.inExpressionEvaluation) {
                    this.state.PushEvaluationStack(new Void_1.Void());
                }
                didPop = true;
            }
            else if (this.state.callStack.canPopThread) {
                this.state.callStack.PopThread();
                didPop = true;
            }
            else {
                this.state.TryExitFunctionEvaluationFromGame();
            }
            if (didPop && !this.state.currentPointer.isNull) {
                this.NextContent();
            }
        }
    }
    IncrementContentPointer() {
        let successfulIncrement = true;
        let pointer = this.state.callStack.currentElement.currentPointer.copy();
        pointer.index++;
        if (pointer.container === null) {
            return NullException_1.throwNullException("pointer.container");
        }
        while (pointer.index >= pointer.container.content.length) {
            successfulIncrement = false;
            // Container nextAncestor = pointer.container.parent as Container;
            let nextAncestor = TypeAssertion_1.asOrNull(pointer.container.parent, Container_1.Container);
            if (nextAncestor instanceof Container_1.Container === false) {
                break;
            }
            let indexInAncestor = nextAncestor.content.indexOf(pointer.container);
            if (indexInAncestor == -1) {
                break;
            }
            pointer = new Pointer_1.Pointer(nextAncestor, indexInAncestor);
            pointer.index++;
            successfulIncrement = true;
            if (pointer.container === null) {
                return NullException_1.throwNullException("pointer.container");
            }
        }
        if (!successfulIncrement)
            pointer = Pointer_1.Pointer.Null;
        this.state.callStack.currentElement.currentPointer = pointer.copy();
        return successfulIncrement;
    }
    TryFollowDefaultInvisibleChoice() {
        let allChoices = this._state.currentChoices;
        let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);
        if (invisibleChoices.length == 0 ||
            allChoices.length > invisibleChoices.length)
            return false;
        let choice = invisibleChoices[0];
        if (choice.targetPath === null) {
            return NullException_1.throwNullException("choice.targetPath");
        }
        if (choice.threadAtGeneration === null) {
            return NullException_1.throwNullException("choice.threadAtGeneration");
        }
        this.state.callStack.currentThread = choice.threadAtGeneration;
        this.ChoosePath(choice.targetPath, false);
        return true;
    }
    NextSequenceShuffleIndex() {
        // var numElementsIntVal = state.PopEvaluationStack () as IntValue;
        let numElementsIntVal = TypeAssertion_1.asOrNull(this.state.PopEvaluationStack(), Value_1.IntValue);
        if (!(numElementsIntVal instanceof Value_1.IntValue)) {
            this.Error("expected number of elements in sequence for shuffle index");
            return 0;
        }
        let seqContainer = this.state.currentPointer.container;
        if (seqContainer === null) {
            return NullException_1.throwNullException("seqContainer");
        }
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (numElementsIntVal.value === null) {
            return NullException_1.throwNullException("numElementsIntVal.value");
        }
        let numElements = numElementsIntVal.value;
        // var seqCountVal = state.PopEvaluationStack () as IntValue;
        let seqCountVal = TypeAssertion_1.asOrThrows(this.state.PopEvaluationStack(), Value_1.IntValue);
        let seqCount = seqCountVal.value;
        // Originally a primitive type, but here, can be null.
        // TODO: Replace by default value?
        if (seqCount === null) {
            return NullException_1.throwNullException("seqCount");
        }
        let loopIndex = seqCount / numElements;
        let iterationIndex = seqCount % numElements;
        let seqPathStr = seqContainer.path.toString();
        let sequenceHash = 0;
        for (let i = 0, l = seqPathStr.length; i < l; i++) {
            sequenceHash += seqPathStr.charCodeAt(i) || 0;
        }
        let randomSeed = sequenceHash + loopIndex + this.state.storySeed;
        let random = new PRNG_1.PRNG(Math.floor(randomSeed));
        let unpickedIndices = [];
        for (let i = 0; i < numElements; ++i) {
            unpickedIndices.push(i);
        }
        for (let i = 0; i <= iterationIndex; ++i) {
            let chosen = random.next() % unpickedIndices.length;
            let chosenIndex = unpickedIndices[chosen];
            unpickedIndices.splice(chosen, 1);
            if (i == iterationIndex) {
                return chosenIndex;
            }
        }
        throw new Error("Should never reach here");
    }
    Error(message, useEndLineNumber = false) {
        let e = new StoryException_1.StoryException(message);
        e.useEndLineNumber = useEndLineNumber;
        throw e;
    }
    Warning(message) {
        this.AddError(message, true);
    }
    AddError(message, isWarning = false, useEndLineNumber = false) {
        let dm = this.currentDebugMetadata;
        let errorTypeStr = isWarning ? "WARNING" : "ERROR";
        if (dm != null) {
            let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": '" +
                    dm.fileName +
                    "' line " +
                    lineNum +
                    ": " +
                    message;
        }
        else if (!this.state.currentPointer.isNull) {
            message =
                "RUNTIME " +
                    errorTypeStr +
                    ": (" +
                    this.state.currentPointer +
                    "): " +
                    message;
        }
        else {
            message = "RUNTIME " + errorTypeStr + ": " + message;
        }
        this.state.AddError(message, isWarning);
        // In a broken state don't need to know about any other errors.
        if (!isWarning)
            this.state.ForceEnd();
    }
    Assert(condition, message = null) {
        if (condition == false) {
            if (message == null) {
                message = "Story assert";
            }
            throw new Error(message + " " + this.currentDebugMetadata);
        }
    }
    get currentDebugMetadata() {
        let dm;
        let pointer = this.state.currentPointer;
        if (!pointer.isNull && pointer.Resolve() !== null) {
            dm = pointer.Resolve().debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {
            pointer = this.state.callStack.elements[i].currentPointer;
            if (!pointer.isNull && pointer.Resolve() !== null) {
                dm = pointer.Resolve().debugMetadata;
                if (dm !== null) {
                    return dm;
                }
            }
        }
        for (let i = this.state.outputStream.length - 1; i >= 0; --i) {
            let outputObj = this.state.outputStream[i];
            dm = outputObj.debugMetadata;
            if (dm !== null) {
                return dm;
            }
        }
        return null;
    }
    get mainContentContainer() {
        if (this._temporaryEvaluationContainer) {
            return this._temporaryEvaluationContainer;
        }
        else {
            return this._mainContentContainer;
        }
    }
}
exports.Story = Story;
Story.inkVersionCurrent = 19;
(function (Story) {
    let OutputStateChange;
    (function (OutputStateChange) {
        OutputStateChange[OutputStateChange["NoChange"] = 0] = "NoChange";
        OutputStateChange[OutputStateChange["ExtendedBeyondNewline"] = 1] = "ExtendedBeyondNewline";
        OutputStateChange[OutputStateChange["NewlineRemoved"] = 2] = "NewlineRemoved";
    })(OutputStateChange = Story.OutputStateChange || (Story.OutputStateChange = {}));
})(Story = exports.Story || (exports.Story = {}));
//# sourceMappingURL=Story.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryException.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryException.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryException = void 0;
class StoryException extends Error {
    constructor(message) {
        super(message);
        this.useEndLineNumber = false;
        this.message = message;
        this.name = "StoryException";
    }
}
exports.StoryException = StoryException;
//# sourceMappingURL=StoryException.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StoryState.js":
/*!*************************************************!*\
  !*** ./node_modules/inkjs/engine/StoryState.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StoryState = void 0;
const CallStack_1 = __webpack_require__(/*! ./CallStack */ "./node_modules/inkjs/engine/CallStack.js");
const VariablesState_1 = __webpack_require__(/*! ./VariablesState */ "./node_modules/inkjs/engine/VariablesState.js");
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const PushPop_1 = __webpack_require__(/*! ./PushPop */ "./node_modules/inkjs/engine/PushPop.js");
const Tag_1 = __webpack_require__(/*! ./Tag */ "./node_modules/inkjs/engine/Tag.js");
const Glue_1 = __webpack_require__(/*! ./Glue */ "./node_modules/inkjs/engine/Glue.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const ControlCommand_1 = __webpack_require__(/*! ./ControlCommand */ "./node_modules/inkjs/engine/ControlCommand.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const StringBuilder_1 = __webpack_require__(/*! ./StringBuilder */ "./node_modules/inkjs/engine/StringBuilder.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const PRNG_1 = __webpack_require__(/*! ./PRNG */ "./node_modules/inkjs/engine/PRNG.js");
const Void_1 = __webpack_require__(/*! ./Void */ "./node_modules/inkjs/engine/Void.js");
const Pointer_1 = __webpack_require__(/*! ./Pointer */ "./node_modules/inkjs/engine/Pointer.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const Debug_1 = __webpack_require__(/*! ./Debug */ "./node_modules/inkjs/engine/Debug.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
const Story_1 = __webpack_require__(/*! ./Story */ "./node_modules/inkjs/engine/Story.js");
const StatePatch_1 = __webpack_require__(/*! ./StatePatch */ "./node_modules/inkjs/engine/StatePatch.js");
const SimpleJson_1 = __webpack_require__(/*! ./SimpleJson */ "./node_modules/inkjs/engine/SimpleJson.js");
class StoryState {
    constructor(story) {
        this.kInkSaveStateVersion = 8;
        this.kMinCompatibleLoadVersion = 8;
        this._currentErrors = null;
        this._currentWarnings = null;
        this.divertedPointer = Pointer_1.Pointer.Null;
        this._currentTurnIndex = 0;
        this.storySeed = 0;
        this.previousRandom = 0;
        this.didSafeExit = false;
        this._currentText = null;
        this._currentTags = null;
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
        this._patch = null;
        this.story = story;
        this._outputStream = [];
        this.OutputStreamDirty();
        this._evaluationStack = [];
        this.callStack = new CallStack_1.CallStack(story);
        this._variablesState = new VariablesState_1.VariablesState(this.callStack, story.listDefinitions);
        this._visitCounts = new Map();
        this._turnIndices = new Map();
        this.currentTurnIndex = -1;
        let timeSeed = new Date().getTime();
        this.storySeed = new PRNG_1.PRNG(timeSeed).next() % 100;
        this.previousRandom = 0;
        this._currentChoices = [];
        this.GoToStart();
    }
    ToJson(indented = false) {
        let writer = new SimpleJson_1.SimpleJson.Writer();
        this.WriteJson(writer);
        return writer.ToString();
    }
    toJson(indented = false) {
        return this.ToJson(indented);
    }
    LoadJson(json) {
        let jObject = SimpleJson_1.SimpleJson.TextToDictionary(json);
        this.LoadJsonObj(jObject);
    }
    VisitCountAtPathString(pathString) {
        let visitCountOut;
        if (this._patch !== null) {
            let container = this.story.ContentAtPath(new Path_1.Path(pathString)).container;
            if (container === null)
                throw new Error("Content at path not found: " + pathString);
            visitCountOut = this._patch.TryGetVisitCount(container, 0);
            if (visitCountOut.exists)
                return visitCountOut.result;
        }
        visitCountOut = TryGetResult_1.tryGetValueFromMap(this._visitCounts, pathString, null);
        if (visitCountOut.exists)
            return visitCountOut.result;
        return 0;
    }
    VisitCountForContainer(container) {
        if (container === null) {
            return NullException_1.throwNullException("container");
        }
        if (!container.visitsShouldBeCounted) {
            this.story.Error("Read count for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
            return 0;
        }
        if (this._patch !== null) {
            let count = this._patch.TryGetVisitCount(container, 0);
            if (count.exists) {
                return count.result;
            }
        }
        let containerPathStr = container.path.toString();
        let count2 = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count2.exists) {
            return count2.result;
        }
        return 0;
    }
    IncrementVisitCountForContainer(container) {
        if (this._patch !== null) {
            let currCount = this.VisitCountForContainer(container);
            currCount++;
            this._patch.SetVisitCount(container, currCount);
            return;
        }
        let containerPathStr = container.path.toString();
        let count = TryGetResult_1.tryGetValueFromMap(this._visitCounts, containerPathStr, null);
        if (count.exists) {
            this._visitCounts.set(containerPathStr, count.result + 1);
        }
        else {
            this._visitCounts.set(containerPathStr, 1);
        }
    }
    RecordTurnIndexVisitToContainer(container) {
        if (this._patch !== null) {
            this._patch.SetTurnIndex(container, this.currentTurnIndex);
            return;
        }
        let containerPathStr = container.path.toString();
        this._turnIndices.set(containerPathStr, this.currentTurnIndex);
    }
    TurnsSinceForContainer(container) {
        if (!container.turnIndexShouldBeCounted) {
            this.story.Error("TURNS_SINCE() for target (" +
                container.name +
                " - on " +
                container.debugMetadata +
                ") unknown. The story may need to be compiled with countAllVisits flag (-c).");
        }
        if (this._patch !== null) {
            let index = this._patch.TryGetTurnIndex(container, 0);
            if (index.exists) {
                return this.currentTurnIndex - index.result;
            }
        }
        let containerPathStr = container.path.toString();
        let index2 = TryGetResult_1.tryGetValueFromMap(this._turnIndices, containerPathStr, 0);
        if (index2.exists) {
            return this.currentTurnIndex - index2.result;
        }
        else {
            return -1;
        }
    }
    get callstackDepth() {
        return this.callStack.depth;
    }
    get outputStream() {
        return this._outputStream;
    }
    get currentChoices() {
        // If we can continue generating text content rather than choices,
        // then we reflect the choice list as being empty, since choices
        // should always come at the end.
        if (this.canContinue)
            return [];
        return this._currentChoices;
    }
    get generatedChoices() {
        return this._currentChoices;
    }
    get currentErrors() {
        return this._currentErrors;
    }
    get currentWarnings() {
        return this._currentWarnings;
    }
    get variablesState() {
        return this._variablesState;
    }
    set variablesState(value) {
        this._variablesState = value;
    }
    get evaluationStack() {
        return this._evaluationStack;
    }
    get visitCounts() {
        return this._visitCounts;
    }
    get turnIndices() {
        return this._turnIndices;
    }
    get currentTurnIndex() {
        return this._currentTurnIndex;
    }
    set currentTurnIndex(value) {
        this._currentTurnIndex = value;
    }
    get currentPathString() {
        let pointer = this.currentPointer;
        if (pointer.isNull) {
            return null;
        }
        else {
            if (pointer.path === null) {
                return NullException_1.throwNullException("pointer.path");
            }
            return pointer.path.toString();
        }
    }
    get currentPointer() {
        return this.callStack.currentElement.currentPointer.copy();
    }
    set currentPointer(value) {
        this.callStack.currentElement.currentPointer = value.copy();
    }
    get previousPointer() {
        return this.callStack.currentThread.previousPointer.copy();
    }
    set previousPointer(value) {
        this.callStack.currentThread.previousPointer = value.copy();
    }
    get canContinue() {
        return !this.currentPointer.isNull && !this.hasError;
    }
    get hasError() {
        return this.currentErrors != null && this.currentErrors.length > 0;
    }
    get hasWarning() {
        return this.currentWarnings != null && this.currentWarnings.length > 0;
    }
    get currentText() {
        if (this._outputStreamTextDirty) {
            let sb = new StringBuilder_1.StringBuilder();
            for (let outputObj of this._outputStream) {
                // var textContent = outputObj as StringValue;
                let textContent = TypeAssertion_1.asOrNull(outputObj, Value_1.StringValue);
                if (textContent !== null) {
                    sb.Append(textContent.value);
                }
            }
            this._currentText = this.CleanOutputWhitespace(sb.toString());
            this._outputStreamTextDirty = false;
        }
        return this._currentText;
    }
    CleanOutputWhitespace(str) {
        let sb = new StringBuilder_1.StringBuilder();
        let currentWhitespaceStart = -1;
        let startOfLine = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charAt(i);
            let isInlineWhitespace = c == " " || c == "\t";
            if (isInlineWhitespace && currentWhitespaceStart == -1)
                currentWhitespaceStart = i;
            if (!isInlineWhitespace) {
                if (c != "\n" &&
                    currentWhitespaceStart > 0 &&
                    currentWhitespaceStart != startOfLine) {
                    sb.Append(" ");
                }
                currentWhitespaceStart = -1;
            }
            if (c == "\n")
                startOfLine = i + 1;
            if (!isInlineWhitespace)
                sb.Append(c);
        }
        return sb.toString();
    }
    get currentTags() {
        if (this._outputStreamTagsDirty) {
            this._currentTags = [];
            for (let outputObj of this._outputStream) {
                // var tag = outputObj as Tag;
                let tag = TypeAssertion_1.asOrNull(outputObj, Tag_1.Tag);
                if (tag !== null) {
                    this._currentTags.push(tag.text);
                }
            }
            this._outputStreamTagsDirty = false;
        }
        return this._currentTags;
    }
    get inExpressionEvaluation() {
        return this.callStack.currentElement.inExpressionEvaluation;
    }
    set inExpressionEvaluation(value) {
        this.callStack.currentElement.inExpressionEvaluation = value;
    }
    GoToStart() {
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(this.story.mainContentContainer);
    }
    CopyAndStartPatching() {
        let copy = new StoryState(this.story);
        copy._patch = new StatePatch_1.StatePatch(this._patch);
        copy.outputStream.push.apply(copy.outputStream, this._outputStream);
        copy.OutputStreamDirty();
        copy._currentChoices.push.apply(copy._currentChoices, this._currentChoices);
        if (this.hasError) {
            copy._currentErrors = [];
            copy._currentErrors.push.apply(copy._currentErrors, this.currentErrors || []);
        }
        if (this.hasWarning) {
            copy._currentWarnings = [];
            copy._currentWarnings.push.apply(copy._currentWarnings, this.currentWarnings || []);
        }
        copy.callStack = new CallStack_1.CallStack(this.callStack);
        copy.variablesState = this.variablesState;
        copy.variablesState.callStack = copy.callStack;
        copy.variablesState.patch = copy._patch;
        copy.evaluationStack.push.apply(copy.evaluationStack, this.evaluationStack);
        if (!this.divertedPointer.isNull)
            copy.divertedPointer = this.divertedPointer.copy();
        copy.previousPointer = this.previousPointer.copy();
        copy._visitCounts = this._visitCounts;
        copy._turnIndices = this._turnIndices;
        copy.currentTurnIndex = this.currentTurnIndex;
        copy.storySeed = this.storySeed;
        copy.previousRandom = this.previousRandom;
        copy.didSafeExit = this.didSafeExit;
        return copy;
    }
    RestoreAfterPatch() {
        this.variablesState.callStack = this.callStack;
        this.variablesState.patch = this._patch;
    }
    ApplyAnyPatch() {
        if (this._patch === null)
            return;
        this.variablesState.ApplyPatch();
        for (let [key, value] of this._patch.visitCounts)
            this.ApplyCountChanges(key, value, true);
        for (let [key, value] of this._patch.turnIndices)
            this.ApplyCountChanges(key, value, false);
        this._patch = null;
    }
    ApplyCountChanges(container, newCount, isVisit) {
        let counts = isVisit ? this._visitCounts : this._turnIndices;
        counts.set(container.path.toString(), newCount);
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        let hasChoiceThreads = false;
        for (let c of this._currentChoices) {
            if (c.threadAtGeneration === null) {
                return NullException_1.throwNullException("c.threadAtGeneration");
            }
            c.originalThreadIndex = c.threadAtGeneration.threadIndex;
            if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {
                if (!hasChoiceThreads) {
                    hasChoiceThreads = true;
                    writer.WritePropertyStart("choiceThreads");
                    writer.WriteObjectStart();
                }
                writer.WritePropertyStart(c.originalThreadIndex);
                c.threadAtGeneration.WriteJson(writer);
                writer.WritePropertyEnd();
            }
        }
        if (hasChoiceThreads) {
            writer.WriteObjectEnd();
            writer.WritePropertyEnd();
        }
        // In the following two calls, `WriteJson` is called inside an arrow
        // function to make sure `this` is correctly bound and passed down
        // the call hierarchy.
        writer.WriteProperty("callstackThreads", (w) => this.callStack.WriteJson(w));
        writer.WriteProperty("variablesState", (w) => this.variablesState.WriteJson(w));
        writer.WriteProperty("evalStack", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack));
        writer.WriteProperty("outputStream", (w) => JsonSerialisation_1.JsonSerialisation.WriteListRuntimeObjs(w, this._outputStream));
        writer.WriteProperty("currentChoices", (w) => {
            w.WriteArrayStart();
            for (let c of this._currentChoices)
                JsonSerialisation_1.JsonSerialisation.WriteChoice(w, c);
            w.WriteArrayEnd();
        });
        if (!this.divertedPointer.isNull) {
            if (this.divertedPointer.path === null) {
                return NullException_1.throwNullException("divertedPointer");
            }
            writer.WriteProperty("currentDivertTarget", this.divertedPointer.path.componentsString);
        }
        writer.WriteProperty("visitCounts", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._visitCounts));
        writer.WriteProperty("turnIndices", (w) => JsonSerialisation_1.JsonSerialisation.WriteIntDictionary(w, this._turnIndices));
        writer.WriteIntProperty("turnIdx", this.currentTurnIndex);
        writer.WriteIntProperty("storySeed", this.storySeed);
        writer.WriteIntProperty("previousRandom", this.previousRandom);
        writer.WriteIntProperty("inkSaveVersion", this.kInkSaveStateVersion);
        writer.WriteIntProperty("inkFormatVersion", Story_1.Story.inkVersionCurrent);
        writer.WriteObjectEnd();
    }
    LoadJsonObj(value) {
        let jObject = value;
        let jSaveVersion = jObject["inkSaveVersion"];
        if (jSaveVersion == null) {
            throw new StoryException_1.StoryException("ink save format incorrect, can't load.");
        }
        else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {
            throw new StoryException_1.StoryException("Ink save format isn't compatible with the current version (saw '" +
                jSaveVersion +
                "', but minimum is " +
                this.kMinCompatibleLoadVersion +
                "), so can't load.");
        }
        this.callStack.SetJsonToken(jObject["callstackThreads"], this.story);
        this.variablesState.SetJsonToken(jObject["variablesState"]);
        this._evaluationStack = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["evalStack"]);
        this._outputStream = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["outputStream"]);
        this.OutputStreamDirty();
        // currentChoices = Json.JArrayToRuntimeObjList<Choice>((JArray)jObject ["currentChoices"]);
        this._currentChoices = JsonSerialisation_1.JsonSerialisation.JArrayToRuntimeObjList(jObject["currentChoices"]);
        let currentDivertTargetPath = jObject["currentDivertTarget"];
        if (currentDivertTargetPath != null) {
            let divertPath = new Path_1.Path(currentDivertTargetPath.toString());
            this.divertedPointer = this.story.PointerAtPath(divertPath);
        }
        this._visitCounts = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["visitCounts"]);
        this._turnIndices = JsonSerialisation_1.JsonSerialisation.JObjectToIntDictionary(jObject["turnIndices"]);
        this.currentTurnIndex = parseInt(jObject["turnIdx"]);
        this.storySeed = parseInt(jObject["storySeed"]);
        this.previousRandom = parseInt(jObject["previousRandom"]);
        // var jChoiceThreads = jObject["choiceThreads"] as JObject;
        let jChoiceThreads = jObject["choiceThreads"];
        for (let c of this._currentChoices) {
            let foundActiveThread = this.callStack.ThreadWithIndex(c.originalThreadIndex);
            if (foundActiveThread != null) {
                c.threadAtGeneration = foundActiveThread.Copy();
            }
            else {
                let jSavedChoiceThread = jChoiceThreads[c.originalThreadIndex.toString()];
                c.threadAtGeneration = new CallStack_1.CallStack.Thread(jSavedChoiceThread, this.story);
            }
        }
    }
    ResetErrors() {
        this._currentErrors = null;
        this._currentWarnings = null;
    }
    ResetOutput(objs = null) {
        this._outputStream.length = 0;
        if (objs !== null)
            this._outputStream.push.apply(this._outputStream, objs);
        this.OutputStreamDirty();
    }
    PushToOutputStream(obj) {
        // var text = obj as StringValue;
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        if (text !== null) {
            let listText = this.TrySplittingHeadTailWhitespace(text);
            if (listText !== null) {
                for (let textObj of listText) {
                    this.PushToOutputStreamIndividual(textObj);
                }
                this.OutputStreamDirty();
                return;
            }
        }
        this.PushToOutputStreamIndividual(obj);
        this.OutputStreamDirty();
    }
    PopFromOutputStream(count) {
        this.outputStream.splice(this.outputStream.length - count, count);
        this.OutputStreamDirty();
    }
    TrySplittingHeadTailWhitespace(single) {
        let str = single.value;
        if (str === null) {
            return NullException_1.throwNullException("single.value");
        }
        let headFirstNewlineIdx = -1;
        let headLastNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (headFirstNewlineIdx == -1)
                    headFirstNewlineIdx = i;
                headLastNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        let tailLastNewlineIdx = -1;
        let tailFirstNewlineIdx = -1;
        for (let i = 0; i < str.length; ++i) {
            let c = str[i];
            if (c == "\n") {
                if (tailLastNewlineIdx == -1)
                    tailLastNewlineIdx = i;
                tailFirstNewlineIdx = i;
            }
            else if (c == " " || c == "\t")
                continue;
            else
                break;
        }
        // No splitting to be done?
        if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1)
            return null;
        let listTexts = [];
        let innerStrStart = 0;
        let innerStrEnd = str.length;
        if (headFirstNewlineIdx != -1) {
            if (headFirstNewlineIdx > 0) {
                let leadingSpaces = new Value_1.StringValue(str.substring(0, headFirstNewlineIdx));
                listTexts.push(leadingSpaces);
            }
            listTexts.push(new Value_1.StringValue("\n"));
            innerStrStart = headLastNewlineIdx + 1;
        }
        if (tailLastNewlineIdx != -1) {
            innerStrEnd = tailFirstNewlineIdx;
        }
        if (innerStrEnd > innerStrStart) {
            let innerStrText = str.substring(innerStrStart, innerStrEnd - innerStrStart);
            listTexts.push(new Value_1.StringValue(innerStrText));
        }
        if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {
            listTexts.push(new Value_1.StringValue("\n"));
            if (tailLastNewlineIdx < str.length - 1) {
                let numSpaces = str.length - tailLastNewlineIdx - 1;
                let trailingSpaces = new Value_1.StringValue(str.substring(tailLastNewlineIdx + 1, numSpaces));
                listTexts.push(trailingSpaces);
            }
        }
        return listTexts;
    }
    PushToOutputStreamIndividual(obj) {
        let glue = TypeAssertion_1.asOrNull(obj, Glue_1.Glue);
        let text = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
        let includeInOutput = true;
        if (glue) {
            this.TrimNewlinesFromOutputStream();
            includeInOutput = true;
        }
        else if (text) {
            let functionTrimIndex = -1;
            let currEl = this.callStack.currentElement;
            if (currEl.type == PushPop_1.PushPopType.Function) {
                functionTrimIndex = currEl.functionStartInOutputStream;
            }
            let glueTrimIndex = -1;
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let o = this._outputStream[i];
                let c = o instanceof ControlCommand_1.ControlCommand ? o : null;
                let g = o instanceof Glue_1.Glue ? o : null;
                if (g != null) {
                    glueTrimIndex = i;
                    break;
                }
                else if (c != null &&
                    c.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                    if (i >= functionTrimIndex) {
                        functionTrimIndex = -1;
                    }
                    break;
                }
            }
            let trimIndex = -1;
            if (glueTrimIndex != -1 && functionTrimIndex != -1)
                trimIndex = Math.min(functionTrimIndex, glueTrimIndex);
            else if (glueTrimIndex != -1)
                trimIndex = glueTrimIndex;
            else
                trimIndex = functionTrimIndex;
            if (trimIndex != -1) {
                if (text.isNewline) {
                    includeInOutput = false;
                }
                else if (text.isNonWhitespace) {
                    if (glueTrimIndex > -1)
                        this.RemoveExistingGlue();
                    if (functionTrimIndex > -1) {
                        let callStackElements = this.callStack.elements;
                        for (let i = callStackElements.length - 1; i >= 0; i--) {
                            let el = callStackElements[i];
                            if (el.type == PushPop_1.PushPopType.Function) {
                                el.functionStartInOutputStream = -1;
                            }
                            else {
                                break;
                            }
                        }
                    }
                }
            }
            else if (text.isNewline) {
                if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)
                    includeInOutput = false;
            }
        }
        if (includeInOutput) {
            if (obj === null) {
                return NullException_1.throwNullException("obj");
            }
            this._outputStream.push(obj);
            this.OutputStreamDirty();
        }
    }
    TrimNewlinesFromOutputStream() {
        let removeWhitespaceFrom = -1;
        let i = this._outputStream.length - 1;
        while (i >= 0) {
            let obj = this._outputStream[i];
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            if (cmd != null || (txt != null && txt.isNonWhitespace)) {
                break;
            }
            else if (txt != null && txt.isNewline) {
                removeWhitespaceFrom = i;
            }
            i--;
        }
        // Remove the whitespace
        if (removeWhitespaceFrom >= 0) {
            i = removeWhitespaceFrom;
            while (i < this._outputStream.length) {
                let text = TypeAssertion_1.asOrNull(this._outputStream[i], Value_1.StringValue);
                if (text) {
                    this._outputStream.splice(i, 1);
                }
                else {
                    i++;
                }
            }
        }
        this.OutputStreamDirty();
    }
    RemoveExistingGlue() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            let c = this._outputStream[i];
            if (c instanceof Glue_1.Glue) {
                this._outputStream.splice(i, 1);
            }
            else if (c instanceof ControlCommand_1.ControlCommand) {
                break;
            }
        }
        this.OutputStreamDirty();
    }
    get outputStreamEndsInNewline() {
        if (this._outputStream.length > 0) {
            for (let i = this._outputStream.length - 1; i >= 0; i--) {
                let obj = this._outputStream[i];
                if (obj instanceof ControlCommand_1.ControlCommand)
                    break;
                let text = this._outputStream[i];
                if (text instanceof Value_1.StringValue) {
                    if (text.isNewline)
                        return true;
                    else if (text.isNonWhitespace)
                        break;
                }
            }
        }
        return false;
    }
    get outputStreamContainsContent() {
        for (let i = 0; i < this._outputStream.length; i++) {
            if (this._outputStream[i] instanceof Value_1.StringValue)
                return true;
        }
        return false;
    }
    get inStringEvaluation() {
        for (let i = this._outputStream.length - 1; i >= 0; i--) {
            // var cmd = this._outputStream[i] as ControlCommand;
            let cmd = TypeAssertion_1.asOrNull(this._outputStream[i], ControlCommand_1.ControlCommand);
            if (cmd instanceof ControlCommand_1.ControlCommand &&
                cmd.commandType == ControlCommand_1.ControlCommand.CommandType.BeginString) {
                return true;
            }
        }
        return false;
    }
    PushEvaluationStack(obj) {
        // var listValue = obj as ListValue;
        let listValue = TypeAssertion_1.asOrNull(obj, Value_1.ListValue);
        if (listValue) {
            // Update origin when list is has something to indicate the list origin
            let rawList = listValue.value;
            if (rawList === null) {
                return NullException_1.throwNullException("rawList");
            }
            if (rawList.originNames != null) {
                if (!rawList.origins)
                    rawList.origins = [];
                rawList.origins.length = 0;
                for (let n of rawList.originNames) {
                    if (this.story.listDefinitions === null)
                        return NullException_1.throwNullException("StoryState.story.listDefinitions");
                    let def = this.story.listDefinitions.TryListGetDefinition(n, null);
                    if (def.result === null)
                        return NullException_1.throwNullException("StoryState def.result");
                    if (rawList.origins.indexOf(def.result) < 0)
                        rawList.origins.push(def.result);
                }
            }
        }
        if (obj === null) {
            return NullException_1.throwNullException("obj");
        }
        this.evaluationStack.push(obj);
    }
    PopEvaluationStack(numberOfObjects) {
        if (typeof numberOfObjects === "undefined") {
            let obj = this.evaluationStack.pop();
            return TypeAssertion_1.nullIfUndefined(obj);
        }
        else {
            if (numberOfObjects > this.evaluationStack.length) {
                throw new Error("trying to pop too many objects");
            }
            let popped = this.evaluationStack.splice(this.evaluationStack.length - numberOfObjects, numberOfObjects);
            return TypeAssertion_1.nullIfUndefined(popped);
        }
    }
    PeekEvaluationStack() {
        return this.evaluationStack[this.evaluationStack.length - 1];
    }
    ForceEnd() {
        this.callStack.Reset();
        this._currentChoices.length = 0;
        this.currentPointer = Pointer_1.Pointer.Null;
        this.previousPointer = Pointer_1.Pointer.Null;
        this.didSafeExit = true;
    }
    TrimWhitespaceFromFunctionEnd() {
        Debug_1.Debug.Assert(this.callStack.currentElement.type == PushPop_1.PushPopType.Function);
        let functionStartPoint = this.callStack.currentElement
            .functionStartInOutputStream;
        if (functionStartPoint == -1) {
            functionStartPoint = 0;
        }
        for (let i = this._outputStream.length - 1; i >= functionStartPoint; i--) {
            let obj = this._outputStream[i];
            let txt = TypeAssertion_1.asOrNull(obj, Value_1.StringValue);
            let cmd = TypeAssertion_1.asOrNull(obj, ControlCommand_1.ControlCommand);
            if (txt == null)
                continue;
            if (cmd)
                break;
            if (txt.isNewline || txt.isInlineWhitespace) {
                this._outputStream.splice(i, 1);
                this.OutputStreamDirty();
            }
            else {
                break;
            }
        }
    }
    PopCallStack(popType = null) {
        if (this.callStack.currentElement.type == PushPop_1.PushPopType.Function)
            this.TrimWhitespaceFromFunctionEnd();
        this.callStack.Pop(popType);
    }
    SetChosenPath(path, incrementingTurnIndex) {
        // Changing direction, assume we need to clear current set of choices
        this._currentChoices.length = 0;
        let newPointer = this.story.PointerAtPath(path);
        if (!newPointer.isNull && newPointer.index == -1)
            newPointer.index = 0;
        this.currentPointer = newPointer;
        if (incrementingTurnIndex) {
            this.currentTurnIndex++;
        }
    }
    StartFunctionEvaluationFromGame(funcContainer, args) {
        this.callStack.Push(PushPop_1.PushPopType.FunctionEvaluationFromGame, this.evaluationStack.length);
        this.callStack.currentElement.currentPointer = Pointer_1.Pointer.StartOf(funcContainer);
        this.PassArgumentsToEvaluationStack(args);
    }
    PassArgumentsToEvaluationStack(args) {
        // Pass arguments onto the evaluation stack
        if (args != null) {
            for (let i = 0; i < args.length; i++) {
                if (!(typeof args[i] === "number" || typeof args[i] === "string")) {
                    throw new Error("ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters  must be int, float or string");
                }
                this.PushEvaluationStack(Value_1.Value.Create(args[i]));
            }
        }
    }
    TryExitFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type ==
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            this.currentPointer = Pointer_1.Pointer.Null;
            this.didSafeExit = true;
            return true;
        }
        return false;
    }
    CompleteFunctionEvaluationFromGame() {
        if (this.callStack.currentElement.type !=
            PushPop_1.PushPopType.FunctionEvaluationFromGame) {
            throw new StoryException_1.StoryException("Expected external function evaluation to be complete. Stack trace: " +
                this.callStack.callStackTrace);
        }
        let originalEvaluationStackHeight = this.callStack.currentElement
            .evaluationStackHeightWhenPushed;
        let returnedObj = null;
        while (this.evaluationStack.length > originalEvaluationStackHeight) {
            let poppedObj = this.PopEvaluationStack();
            if (returnedObj === null)
                returnedObj = poppedObj;
        }
        this.PopCallStack(PushPop_1.PushPopType.FunctionEvaluationFromGame);
        if (returnedObj) {
            if (returnedObj instanceof Void_1.Void)
                return null;
            // Some kind of value, if not void
            // var returnVal = returnedObj as Runtime.Value;
            let returnVal = TypeAssertion_1.asOrThrows(returnedObj, Value_1.Value);
            // DivertTargets get returned as the string of components
            // (rather than a Path, which isn't public)
            if (returnVal.valueType == Value_1.ValueType.DivertTarget) {
                return returnVal.valueObject.toString();
            }
            // Other types can just have their exact object type:
            // int, float, string. VariablePointers get returned as strings.
            return returnVal.valueObject;
        }
        return null;
    }
    AddError(message, isWarning) {
        if (!isWarning) {
            if (this._currentErrors == null)
                this._currentErrors = [];
            this._currentErrors.push(message);
        }
        else {
            if (this._currentWarnings == null)
                this._currentWarnings = [];
            this._currentWarnings.push(message);
        }
    }
    OutputStreamDirty() {
        this._outputStreamTextDirty = true;
        this._outputStreamTagsDirty = true;
    }
}
exports.StoryState = StoryState;
//# sourceMappingURL=StoryState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/StringBuilder.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/StringBuilder.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.StringBuilder = void 0;
class StringBuilder {
    constructor(str) {
        str = typeof str !== "undefined" ? str.toString() : "";
        this.string = str;
    }
    get Length() {
        return this.string.length;
    }
    Append(str) {
        if (str !== null) {
            this.string += str;
        }
    }
    AppendLine(str) {
        if (typeof str !== "undefined")
            this.Append(str);
        this.string += "\n";
    }
    AppendFormat(format, ...args) {
        // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format
        this.string += format.replace(/{(\d+)}/g, (match, num) => typeof args[num] != "undefined" ? args[num] : match);
    }
    toString() {
        return this.string;
    }
}
exports.StringBuilder = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Tag.js":
/*!******************************************!*\
  !*** ./node_modules/inkjs/engine/Tag.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Tag extends Object_1.InkObject {
    constructor(tagText) {
        super();
        this.text = tagText.toString() || "";
    }
    toString() {
        return "# " + this.text;
    }
}
exports.Tag = Tag;
//# sourceMappingURL=Tag.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TryGetResult.js":
/*!***************************************************!*\
  !*** ./node_modules/inkjs/engine/TryGetResult.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseFloat = exports.tryParseInt = exports.tryGetValueFromMap = void 0;
function tryGetValueFromMap(map, key, 
/* out */ value) {
    if (map === null) {
        return { result: value, exists: false };
    }
    let val = map.get(key);
    if (typeof val === "undefined") {
        return { result: value, exists: false };
    }
    else {
        return { result: val, exists: true };
    }
}
exports.tryGetValueFromMap = tryGetValueFromMap;
function tryParseInt(value, 
/* out */ defaultValue = 0) {
    let val = parseInt(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseInt = tryParseInt;
function tryParseFloat(value, 
/* out */ defaultValue = 0) {
    let val = parseFloat(value);
    if (!Number.isNaN(val)) {
        return { result: val, exists: true };
    }
    else {
        return { result: defaultValue, exists: false };
    }
}
exports.tryParseFloat = tryParseFloat;
//# sourceMappingURL=TryGetResult.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/TypeAssertion.js":
/*!****************************************************!*\
  !*** ./node_modules/inkjs/engine/TypeAssertion.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.isEquatable = exports.nullIfUndefined = exports.asINamedContentOrNull = exports.asNumberOrThrows = exports.asOrThrows = exports.asOrNull = void 0;
function asOrNull(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        return null;
    }
}
exports.asOrNull = asOrNull;
function asOrThrows(obj, type) {
    if (obj instanceof type) {
        return unsafeTypeAssertion(obj, type);
    }
    else {
        throw new Error(`${obj} is not of type ${type}`);
    }
}
exports.asOrThrows = asOrThrows;
function asNumberOrThrows(obj) {
    if (typeof obj === "number") {
        return obj;
    }
    else {
        throw new Error(`${obj} is not a number`);
    }
}
exports.asNumberOrThrows = asNumberOrThrows;
// So here, in the reference implementation, contentObj is casted to an INamedContent
// but here we use js-style duck typing: if it implements the same props as the interface,
// we treat it as valid.
function asINamedContentOrNull(obj) {
    if (obj.hasValidName && obj.name) {
        return obj;
    }
    return null;
}
exports.asINamedContentOrNull = asINamedContentOrNull;
function nullIfUndefined(obj) {
    if (typeof obj === "undefined") {
        return null;
    }
    return obj;
}
exports.nullIfUndefined = nullIfUndefined;
function isEquatable(type) {
    return typeof type === "object" && typeof type.Equals === "function";
}
exports.isEquatable = isEquatable;
function unsafeTypeAssertion(obj, type) {
    return obj;
}
//# sourceMappingURL=TypeAssertion.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Value.js":
/*!********************************************!*\
  !*** ./node_modules/inkjs/engine/Value.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = exports.ListValue = exports.VariablePointerValue = exports.DivertTargetValue = exports.StringValue = exports.FloatValue = exports.IntValue = exports.Value = exports.AbstractValue = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
const InkList_1 = __webpack_require__(/*! ./InkList */ "./node_modules/inkjs/engine/InkList.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class AbstractValue extends Object_1.InkObject {
    static Create(val, preferredNumberType) {
        // This code doesn't exist in upstream and is simply here to enforce
        // the creation of the proper number value.
        // If `preferredNumberType` is not provided or if value doesn't match
        // `preferredNumberType`, this conditional does nothing.
        if (preferredNumberType) {
            if (preferredNumberType === ValueType.Int &&
                Number.isInteger(Number(val))) {
                return new IntValue(Number(val));
            }
            else if (preferredNumberType === ValueType.Float &&
                !isNaN(val)) {
                return new FloatValue(Number(val));
            }
        }
        // Implicitly convert bools into ints
        if (typeof val === "boolean") {
            let b = !!val;
            val = b ? 1 : 0;
        }
        // https://github.com/y-lohse/inkjs/issues/425
        // Changed condition sequence, because Number('') is
        // parsed to 0, which made setting string to empty
        // impossible
        if (typeof val === "string") {
            return new StringValue(String(val));
        }
        else if (Number.isInteger(Number(val))) {
            return new IntValue(Number(val));
        }
        else if (!isNaN(val)) {
            return new FloatValue(Number(val));
        }
        else if (val instanceof Path_1.Path) {
            return new DivertTargetValue(TypeAssertion_1.asOrThrows(val, Path_1.Path));
        }
        else if (val instanceof InkList_1.InkList) {
            return new ListValue(TypeAssertion_1.asOrThrows(val, InkList_1.InkList));
        }
        return null;
    }
    Copy() {
        return TypeAssertion_1.asOrThrows(AbstractValue.Create(this), Object_1.InkObject);
    }
    BadCastException(targetType) {
        return new StoryException_1.StoryException("Can't cast " +
            this.valueObject +
            " from " +
            this.valueType +
            " to " +
            targetType);
    }
}
exports.AbstractValue = AbstractValue;
class Value extends AbstractValue {
    constructor(val) {
        super();
        this.value = val;
    }
    get valueObject() {
        return this.value;
    }
    toString() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.toString();
    }
}
exports.Value = Value;
class IntValue extends Value {
    constructor(val) {
        super(val || 0);
    }
    get isTruthy() {
        return this.value != 0;
    }
    get valueType() {
        return ValueType.Int;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Float) {
            return new FloatValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.IntValue = IntValue;
class FloatValue extends Value {
    constructor(val) {
        super(val || 0.0);
    }
    get isTruthy() {
        return this.value != 0.0;
    }
    get valueType() {
        return ValueType.Float;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            return new IntValue(this.value);
        }
        if (newType == ValueType.String) {
            return new StringValue("" + this.value);
        }
        throw this.BadCastException(newType);
    }
}
exports.FloatValue = FloatValue;
class StringValue extends Value {
    constructor(val) {
        super(val || "");
        this._isNewline = this.value == "\n";
        this._isInlineWhitespace = true;
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (this.value.length > 0) {
            this.value.split("").every((c) => {
                if (c != " " && c != "\t") {
                    this._isInlineWhitespace = false;
                    return false;
                }
                return true;
            });
        }
    }
    get valueType() {
        return ValueType.String;
    }
    get isTruthy() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value.length > 0;
    }
    get isNewline() {
        return this._isNewline;
    }
    get isInlineWhitespace() {
        return this._isInlineWhitespace;
    }
    get isNonWhitespace() {
        return !this.isNewline && !this.isInlineWhitespace;
    }
    Cast(newType) {
        if (newType == this.valueType) {
            return this;
        }
        if (newType == ValueType.Int) {
            let parsedInt = TryGetResult_1.tryParseInt(this.value);
            if (parsedInt.exists) {
                return new IntValue(parsedInt.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        if (newType == ValueType.Float) {
            let parsedFloat = TryGetResult_1.tryParseFloat(this.value);
            if (parsedFloat.exists) {
                return new FloatValue(parsedFloat.result);
            }
            else {
                throw this.BadCastException(newType);
            }
        }
        throw this.BadCastException(newType);
    }
}
exports.StringValue = StringValue;
class DivertTargetValue extends Value {
    constructor(targetPath) {
        super(targetPath);
    }
    get valueType() {
        return ValueType.DivertTarget;
    }
    get targetPath() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set targetPath(value) {
        this.value = value;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a divert target");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "DivertTargetValue(" + this.targetPath + ")";
    }
}
exports.DivertTargetValue = DivertTargetValue;
class VariablePointerValue extends Value {
    constructor(variableName, contextIndex = -1) {
        super(variableName);
        this._contextIndex = contextIndex;
    }
    get contextIndex() {
        return this._contextIndex;
    }
    set contextIndex(value) {
        this._contextIndex = value;
    }
    get variableName() {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        return this.value;
    }
    set variableName(value) {
        this.value = value;
    }
    get valueType() {
        return ValueType.VariablePointer;
    }
    get isTruthy() {
        throw new Error("Shouldn't be checking the truthiness of a variable pointer");
    }
    Cast(newType) {
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    toString() {
        return "VariablePointerValue(" + this.variableName + ")";
    }
    Copy() {
        return new VariablePointerValue(this.variableName, this.contextIndex);
    }
}
exports.VariablePointerValue = VariablePointerValue;
class ListValue extends Value {
    get isTruthy() {
        if (this.value === null) {
            return NullException_1.throwNullException("this.value");
        }
        return this.value.Count > 0;
    }
    get valueType() {
        return ValueType.List;
    }
    Cast(newType) {
        if (this.value === null)
            return NullException_1.throwNullException("Value.value");
        if (newType == ValueType.Int) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new IntValue(0);
            else
                return new IntValue(max.Value);
        }
        else if (newType == ValueType.Float) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new FloatValue(0.0);
            else
                return new FloatValue(max.Value);
        }
        else if (newType == ValueType.String) {
            let max = this.value.maxItem;
            if (max.Key.isNull)
                return new StringValue("");
            else {
                return new StringValue(max.Key.toString());
            }
        }
        if (newType == this.valueType)
            return this;
        throw this.BadCastException(newType);
    }
    constructor(listOrSingleItem, singleValue) {
        super(null);
        if (!listOrSingleItem && !singleValue) {
            this.value = new InkList_1.InkList();
        }
        else if (listOrSingleItem instanceof InkList_1.InkList) {
            this.value = new InkList_1.InkList(listOrSingleItem);
        }
        else if (listOrSingleItem instanceof InkList_1.InkListItem &&
            typeof singleValue === "number") {
            this.value = new InkList_1.InkList({
                Key: listOrSingleItem,
                Value: singleValue,
            });
        }
    }
    static RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrNull(oldValue, ListValue);
        let newList = TypeAssertion_1.asOrNull(newValue, ListValue);
        if (newList && newList.value === null)
            return NullException_1.throwNullException("newList.value");
        if (oldList && oldList.value === null)
            return NullException_1.throwNullException("oldList.value");
        // When assigning the empty list, try to retain any initial origin names
        if (oldList && newList && newList.value.Count == 0)
            newList.value.SetInitialOriginNames(oldList.value.originNames);
    }
}
exports.ListValue = ListValue;
var ValueType;
(function (ValueType) {
    ValueType[ValueType["Int"] = 0] = "Int";
    ValueType[ValueType["Float"] = 1] = "Float";
    ValueType[ValueType["List"] = 2] = "List";
    ValueType[ValueType["String"] = 3] = "String";
    ValueType[ValueType["DivertTarget"] = 4] = "DivertTarget";
    ValueType[ValueType["VariablePointer"] = 5] = "VariablePointer";
})(ValueType = exports.ValueType || (exports.ValueType = {}));
//# sourceMappingURL=Value.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableAssignment.js":
/*!*********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableAssignment.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableAssignment = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class VariableAssignment extends Object_1.InkObject {
    constructor(variableName, isNewDeclaration) {
        super();
        this.variableName = variableName || null;
        this.isNewDeclaration = !!isNewDeclaration;
        this.isGlobal = false;
    }
    toString() {
        return "VarAssign to " + this.variableName;
    }
}
exports.VariableAssignment = VariableAssignment;
//# sourceMappingURL=VariableAssignment.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariableReference.js":
/*!********************************************************!*\
  !*** ./node_modules/inkjs/engine/VariableReference.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariableReference = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./node_modules/inkjs/engine/Path.js");
class VariableReference extends Object_1.InkObject {
    constructor(name = null) {
        super();
        this.pathForCount = null;
        this.name = name;
    }
    get containerForCount() {
        if (this.pathForCount === null)
            return null;
        return this.ResolvePath(this.pathForCount).container;
    }
    get pathStringForCount() {
        if (this.pathForCount === null)
            return null;
        return this.CompactPathString(this.pathForCount);
    }
    set pathStringForCount(value) {
        if (value === null)
            this.pathForCount = null;
        else
            this.pathForCount = new Path_1.Path(value);
    }
    toString() {
        if (this.name != null) {
            return "var(" + this.name + ")";
        }
        else {
            let pathStr = this.pathStringForCount;
            return "read_count(" + pathStr + ")";
        }
    }
}
exports.VariableReference = VariableReference;
//# sourceMappingURL=VariableReference.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/VariablesState.js":
/*!*****************************************************!*\
  !*** ./node_modules/inkjs/engine/VariablesState.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.VariablesState = void 0;
const Value_1 = __webpack_require__(/*! ./Value */ "./node_modules/inkjs/engine/Value.js");
const StoryException_1 = __webpack_require__(/*! ./StoryException */ "./node_modules/inkjs/engine/StoryException.js");
const JsonSerialisation_1 = __webpack_require__(/*! ./JsonSerialisation */ "./node_modules/inkjs/engine/JsonSerialisation.js");
const TypeAssertion_1 = __webpack_require__(/*! ./TypeAssertion */ "./node_modules/inkjs/engine/TypeAssertion.js");
const TryGetResult_1 = __webpack_require__(/*! ./TryGetResult */ "./node_modules/inkjs/engine/TryGetResult.js");
const NullException_1 = __webpack_require__(/*! ./NullException */ "./node_modules/inkjs/engine/NullException.js");
class VariablesState {
    constructor(callStack, listDefsOrigin) {
        // The way variableChangedEvent is a bit different than the reference implementation.
        // Originally it uses the C# += operator to add delegates, but in js we need to maintain
        // an actual collection of delegates (ie. callbacks) to register a new one, there is a
        // special ObserveVariableChange method below.
        this.variableChangedEventCallbacks = [];
        this.patch = null;
        this._batchObservingVariableChanges = false;
        this._defaultGlobalVariables = new Map();
        this._changedVariablesForBatchObs = new Set();
        this._globalVariables = new Map();
        this._callStack = callStack;
        this._listDefsOrigin = listDefsOrigin;
        // if es6 proxies are available, use them.
        try {
            // the proxy is used to allow direct manipulation of global variables.
            // It first tries to access the objects own property, and if none is
            // found it delegates the call to the $ method, defined below
            let p = new Proxy(this, {
                get(target, name) {
                    return name in target ? target[name] : target.$(name);
                },
                set(target, name, value) {
                    if (name in target)
                        target[name] = value;
                    else
                        target.$(name, value);
                    return true; // returning a falsy value make the trap fail
                },
            });
            return p;
        }
        catch (e) {
            // thr proxy object is not available in this context. we should warn the
            // dev but writting to the console feels a bit intrusive.
            // console.log("ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.");
        }
    }
    variableChangedEvent(variableName, newValue) {
        for (let callback of this.variableChangedEventCallbacks) {
            callback(variableName, newValue);
        }
    }
    get batchObservingVariableChanges() {
        return this._batchObservingVariableChanges;
    }
    set batchObservingVariableChanges(value) {
        this._batchObservingVariableChanges = value;
        if (value) {
            this._changedVariablesForBatchObs = new Set();
        }
        else {
            if (this._changedVariablesForBatchObs != null) {
                for (let variableName of this._changedVariablesForBatchObs) {
                    let currentValue = this._globalVariables.get(variableName);
                    if (!currentValue) {
                        NullException_1.throwNullException("currentValue");
                    }
                    else {
                        this.variableChangedEvent(variableName, currentValue);
                    }
                }
                this._changedVariablesForBatchObs = null;
            }
        }
    }
    get callStack() {
        return this._callStack;
    }
    set callStack(callStack) {
        this._callStack = callStack;
    }
    // the original code uses a magic getter and setter for global variables,
    // allowing things like variableState['varname]. This is not quite possible
    // in js without a Proxy, so it is replaced with this $ function.
    $(variableName, value) {
        if (typeof value === "undefined") {
            let varContents = null;
            if (this.patch !== null) {
                varContents = this.patch.TryGetGlobal(variableName, null);
                if (varContents.exists)
                    return varContents.result.valueObject;
            }
            varContents = this._globalVariables.get(variableName);
            if (typeof varContents === "undefined") {
                varContents = this._defaultGlobalVariables.get(variableName);
            }
            if (typeof varContents !== "undefined")
                return varContents.valueObject;
            else
                return null;
        }
        else {
            if (typeof this._defaultGlobalVariables.get(variableName) === "undefined")
                throw new StoryException_1.StoryException("Cannot assign to a variable (" +
                    variableName +
                    ") that hasn't been declared in the story");
            let val = Value_1.Value.Create(value);
            if (val == null) {
                if (value == null) {
                    throw new StoryException_1.StoryException("Cannot pass null to VariableState");
                }
                else {
                    throw new StoryException_1.StoryException("Invalid value passed to VariableState: " + value.toString());
                }
            }
            this.SetGlobal(variableName, val);
        }
    }
    ApplyPatch() {
        if (this.patch === null) {
            return NullException_1.throwNullException("this.patch");
        }
        for (let [namedVarKey, namedVarValue] of this.patch.globals) {
            this._globalVariables.set(namedVarKey, namedVarValue);
        }
        if (this._changedVariablesForBatchObs !== null) {
            for (let name of this.patch.changedVariables) {
                this._changedVariablesForBatchObs.add(name);
            }
        }
        this.patch = null;
    }
    SetJsonToken(jToken) {
        this._globalVariables.clear();
        for (let [varValKey, varValValue] of this._defaultGlobalVariables) {
            let loadedToken = jToken[varValKey];
            if (typeof loadedToken !== "undefined") {
                let tokenInkObject = JsonSerialisation_1.JsonSerialisation.JTokenToRuntimeObject(loadedToken);
                if (tokenInkObject === null) {
                    return NullException_1.throwNullException("tokenInkObject");
                }
                this._globalVariables.set(varValKey, tokenInkObject);
            }
            else {
                this._globalVariables.set(varValKey, varValValue);
            }
        }
    }
    WriteJson(writer) {
        writer.WriteObjectStart();
        for (let [keyValKey, keyValValue] of this._globalVariables) {
            let name = keyValKey;
            let val = keyValValue;
            if (VariablesState.dontSaveDefaultValues) {
                if (this._defaultGlobalVariables.has(name)) {
                    let defaultVal = this._defaultGlobalVariables.get(name);
                    if (this.RuntimeObjectsEqual(val, defaultVal))
                        continue;
                }
            }
            writer.WritePropertyStart(name);
            JsonSerialisation_1.JsonSerialisation.WriteRuntimeObject(writer, val);
            writer.WritePropertyEnd();
        }
        writer.WriteObjectEnd();
    }
    RuntimeObjectsEqual(obj1, obj2) {
        if (obj1 === null) {
            return NullException_1.throwNullException("obj1");
        }
        if (obj2 === null) {
            return NullException_1.throwNullException("obj2");
        }
        if (obj1.constructor !== obj2.constructor)
            return false;
        let intVal = TypeAssertion_1.asOrNull(obj1, Value_1.IntValue);
        if (intVal !== null) {
            return intVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.IntValue).value;
        }
        let floatVal = TypeAssertion_1.asOrNull(obj1, Value_1.FloatValue);
        if (floatVal !== null) {
            return floatVal.value === TypeAssertion_1.asOrThrows(obj2, Value_1.FloatValue).value;
        }
        let val1 = TypeAssertion_1.asOrNull(obj1, Value_1.Value);
        let val2 = TypeAssertion_1.asOrNull(obj2, Value_1.Value);
        if (val1 !== null && val2 !== null) {
            if (TypeAssertion_1.isEquatable(val1.valueObject) && TypeAssertion_1.isEquatable(val2.valueObject)) {
                return val1.valueObject.Equals(val2.valueObject);
            }
            else {
                return val1.valueObject === val2.valueObject;
            }
        }
        throw new Error("FastRoughDefinitelyEquals: Unsupported runtime object type: " +
            obj1.constructor.name);
    }
    GetVariableWithName(name, contextIndex = -1) {
        let varValue = this.GetRawVariableWithName(name, contextIndex);
        // var varPointer = varValue as VariablePointerValue;
        let varPointer = TypeAssertion_1.asOrNull(varValue, Value_1.VariablePointerValue);
        if (varPointer !== null) {
            varValue = this.ValueAtVariablePointer(varPointer);
        }
        return varValue;
    }
    TryGetDefaultVariableValue(name) {
        let val = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
        return val.exists ? val.result : null;
    }
    GlobalVariableExistsWithName(name) {
        return (this._globalVariables.has(name) ||
            (this._defaultGlobalVariables !== null &&
                this._defaultGlobalVariables.has(name)));
    }
    GetRawVariableWithName(name, contextIndex) {
        let varValue = null;
        if (contextIndex == 0 || contextIndex == -1) {
            let variableValue = null;
            if (this.patch !== null) {
                variableValue = this.patch.TryGetGlobal(name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            // this is a conditional assignment
            variableValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, name, null);
            if (variableValue.exists)
                return variableValue.result;
            if (this._defaultGlobalVariables !== null) {
                variableValue = TryGetResult_1.tryGetValueFromMap(this._defaultGlobalVariables, name, null);
                if (variableValue.exists)
                    return variableValue.result;
            }
            if (this._listDefsOrigin === null)
                return NullException_1.throwNullException("VariablesState._listDefsOrigin");
            let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);
            if (listItemValue)
                return listItemValue;
        }
        varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);
        return varValue;
    }
    ValueAtVariablePointer(pointer) {
        return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);
    }
    Assign(varAss, value) {
        let name = varAss.variableName;
        if (name === null) {
            return NullException_1.throwNullException("name");
        }
        let contextIndex = -1;
        let setGlobal = false;
        if (varAss.isNewDeclaration) {
            setGlobal = varAss.isGlobal;
        }
        else {
            setGlobal = this.GlobalVariableExistsWithName(name);
        }
        if (varAss.isNewDeclaration) {
            // var varPointer = value as VariablePointerValue;
            let varPointer = TypeAssertion_1.asOrNull(value, Value_1.VariablePointerValue);
            if (varPointer !== null) {
                let fullyResolvedVariablePointer = this.ResolveVariablePointer(varPointer);
                value = fullyResolvedVariablePointer;
            }
        }
        else {
            let existingPointer = null;
            do {
                // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;
                existingPointer = TypeAssertion_1.asOrNull(this.GetRawVariableWithName(name, contextIndex), Value_1.VariablePointerValue);
                if (existingPointer != null) {
                    name = existingPointer.variableName;
                    contextIndex = existingPointer.contextIndex;
                    setGlobal = contextIndex == 0;
                }
            } while (existingPointer != null);
        }
        if (setGlobal) {
            this.SetGlobal(name, value);
        }
        else {
            this._callStack.SetTemporaryVariable(name, value, varAss.isNewDeclaration, contextIndex);
        }
    }
    SnapshotDefaultGlobals() {
        this._defaultGlobalVariables = new Map(this._globalVariables);
    }
    RetainListOriginsForAssignment(oldValue, newValue) {
        let oldList = TypeAssertion_1.asOrThrows(oldValue, Value_1.ListValue);
        let newList = TypeAssertion_1.asOrThrows(newValue, Value_1.ListValue);
        if (oldList.value && newList.value && newList.value.Count == 0) {
            newList.value.SetInitialOriginNames(oldList.value.originNames);
        }
    }
    SetGlobal(variableName, value) {
        let oldValue = null;
        if (this.patch === null) {
            oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
        }
        if (this.patch !== null) {
            oldValue = this.patch.TryGetGlobal(variableName, null);
            if (!oldValue.exists) {
                oldValue = TryGetResult_1.tryGetValueFromMap(this._globalVariables, variableName, null);
            }
        }
        Value_1.ListValue.RetainListOriginsForAssignment(oldValue.result, value);
        if (variableName === null) {
            return NullException_1.throwNullException("variableName");
        }
        if (this.patch !== null) {
            this.patch.SetGlobal(variableName, value);
        }
        else {
            this._globalVariables.set(variableName, value);
        }
        // TODO: Not sure !== is equivalent to !value.Equals(oldValue)
        if (this.variableChangedEvent !== null &&
            oldValue !== null &&
            value !== oldValue.result) {
            if (this.batchObservingVariableChanges) {
                if (this._changedVariablesForBatchObs === null) {
                    return NullException_1.throwNullException("this._changedVariablesForBatchObs");
                }
                if (this.patch !== null) {
                    this.patch.AddChangedVariable(variableName);
                }
                else if (this._changedVariablesForBatchObs !== null) {
                    this._changedVariablesForBatchObs.add(variableName);
                }
            }
            else {
                this.variableChangedEvent(variableName, value);
            }
        }
    }
    ResolveVariablePointer(varPointer) {
        let contextIndex = varPointer.contextIndex;
        if (contextIndex == -1)
            contextIndex = this.GetContextIndexOfVariableNamed(varPointer.variableName);
        let valueOfVariablePointedTo = this.GetRawVariableWithName(varPointer.variableName, contextIndex);
        // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;
        let doubleRedirectionPointer = TypeAssertion_1.asOrNull(valueOfVariablePointedTo, Value_1.VariablePointerValue);
        if (doubleRedirectionPointer != null) {
            return doubleRedirectionPointer;
        }
        else {
            return new Value_1.VariablePointerValue(varPointer.variableName, contextIndex);
        }
    }
    GetContextIndexOfVariableNamed(varName) {
        if (this.GlobalVariableExistsWithName(varName))
            return 0;
        return this._callStack.currentElementIndex;
    }
    /**
     * This function is specific to the js version of ink. It allows to register a
     * callback that will be called when a variable changes. The original code uses
     * `state.variableChangedEvent += callback` instead.
     *
     * @param {function} callback
     */
    ObserveVariableChange(callback) {
        this.variableChangedEventCallbacks.push(callback);
    }
}
exports.VariablesState = VariablesState;
VariablesState.dontSaveDefaultValues = true;
//# sourceMappingURL=VariablesState.js.map

/***/ }),

/***/ "./node_modules/inkjs/engine/Void.js":
/*!*******************************************!*\
  !*** ./node_modules/inkjs/engine/Void.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Void = void 0;
const Object_1 = __webpack_require__(/*! ./Object */ "./node_modules/inkjs/engine/Object.js");
class Void extends Object_1.InkObject {
}
exports.Void = Void;
//# sourceMappingURL=Void.js.map

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
            if (divisor.isNegative())
                return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
        res = ZERO;
    } else {
        // The algorithm below has not been made for unsigned longs. It's therefore
        // required to take special care of the MSB prior to running it.
        if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
        if (divisor.gt(this))
            return UZERO;
        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
            return UONE;
        res = UZERO;
    }

    // Repeat the following until the remainder is less than other:  find a
    // floating-point that approximates remainder / other *from below*, add this
    // into the result, and subtract it from the remainder.  It is critical that
    // the approximate value is less than or equal to the real value so that the
    // remainder never becomes negative.
    rem = this;
    while (rem.gte(divisor)) {
        // Approximate the result of division. This may be a little greater or
        // smaller than the actual value.
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

        // We will tweak the approximate result by changing it in the 48-th digit or
        // the smallest non-fractional digit, whichever is larger.
        var log2 = Math.ceil(Math.log(approx) / Math.LN2),
            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

        // Decrease the approximation until it is smaller than the remainder.  Note
        // that if it is too large, the product overflows and is negative.
            approxRes = fromNumber(approx),
            approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
        }

        // We know the answer can't be zero... and actually, zero would cause
        // infinite recursion since we would make no progress.
        if (approxRes.isZero())
            approxRes = ONE;

        res = res.add(approxRes);
        rem = rem.sub(approxRem);
    }
    return res;
};

/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.div = LongPrototype.divide;

/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.modulo = function modulo(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);

    // use wasm support if present
    if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    return this.sub(this.div(divisor).mul(divisor));
};

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.mod = LongPrototype.modulo;

/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 */
LongPrototype.rem = LongPrototype.modulo;

/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 */
LongPrototype.not = function not() {
    return fromBits(~this.low, ~this.high, this.unsigned);
};

/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.and = function and(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};

/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.or = function or(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};

/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 */
LongPrototype.xor = function xor(other) {
    if (!isLong(other))
        other = fromValue(other);
    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftLeft = function shiftLeft(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
    else
        return fromBits(0, this.low << (numBits - 32), this.unsigned);
};

/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shl = LongPrototype.shiftLeft;

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRight = function shiftRight(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    if ((numBits &= 63) === 0)
        return this;
    else if (numBits < 32)
        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
    else
        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
};

/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr = LongPrototype.shiftRight;

/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
    if (isLong(numBits))
        numBits = numBits.toInt();
    numBits &= 63;
    if (numBits === 0)
        return this;
    else {
        var high = this.high;
        if (numBits < 32) {
            var low = this.low;
            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
        } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
        else
            return fromBits(high >>> (numBits - 32), 0, this.unsigned);
    }
};

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shru = LongPrototype.shiftRightUnsigned;

/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 */
LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;

/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 */
LongPrototype.toSigned = function toSigned() {
    if (!this.unsigned)
        return this;
    return fromBits(this.low, this.high, false);
};

/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 */
LongPrototype.toUnsigned = function toUnsigned() {
    if (this.unsigned)
        return this;
    return fromBits(this.low, this.high, true);
};

/**
 * Converts this Long to its byte representation.
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {!Array.<number>} Byte representation
 */
LongPrototype.toBytes = function toBytes(le) {
    return le ? this.toBytesLE() : this.toBytesBE();
};

/**
 * Converts this Long to its little endian byte representation.
 * @returns {!Array.<number>} Little endian byte representation
 */
LongPrototype.toBytesLE = function toBytesLE() {
    var hi = this.high,
        lo = this.low;
    return [
        lo        & 0xff,
        lo >>>  8 & 0xff,
        lo >>> 16 & 0xff,
        lo >>> 24       ,
        hi        & 0xff,
        hi >>>  8 & 0xff,
        hi >>> 16 & 0xff,
        hi >>> 24
    ];
};

/**
 * Converts this Long to its big endian byte representation.
 * @returns {!Array.<number>} Big endian byte representation
 */
LongPrototype.toBytesBE = function toBytesBE() {
    var hi = this.high,
        lo = this.low;
    return [
        hi >>> 24       ,
        hi >>> 16 & 0xff,
        hi >>>  8 & 0xff,
        hi        & 0xff,
        lo >>> 24       ,
        lo >>> 16 & 0xff,
        lo >>>  8 & 0xff,
        lo        & 0xff
    ];
};

/**
 * Creates a Long from its byte representation.
 * @param {!Array.<number>} bytes Byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @param {boolean=} le Whether little or big endian, defaults to big endian
 * @returns {Long} The corresponding Long value
 */
Long.fromBytes = function fromBytes(bytes, unsigned, le) {
    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
};

/**
 * Creates a Long from its little endian byte representation.
 * @param {!Array.<number>} bytes Little endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
    return new Long(
        bytes[0]       |
        bytes[1] <<  8 |
        bytes[2] << 16 |
        bytes[3] << 24,
        bytes[4]       |
        bytes[5] <<  8 |
        bytes[6] << 16 |
        bytes[7] << 24,
        unsigned
    );
};

/**
 * Creates a Long from its big endian byte representation.
 * @param {!Array.<number>} bytes Big endian byte representation
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {Long} The corresponding Long value
 */
Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
    return new Long(
        bytes[4] << 24 |
        bytes[5] << 16 |
        bytes[6] <<  8 |
        bytes[7],
        bytes[0] << 24 |
        bytes[1] << 16 |
        bytes[2] <<  8 |
        bytes[3],
        unsigned
    );
};


/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// minimal library entry point.


module.exports = __webpack_require__(/*! ./src/index-minimal */ "./node_modules/protobufjs/src/index-minimal.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var protobuf = exports;

/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */
protobuf.build = "minimal";

// Serialization
protobuf.Writer       = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
protobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ "./node_modules/protobufjs/src/writer_buffer.js");
protobuf.Reader       = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
protobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ "./node_modules/protobufjs/src/reader_buffer.js");

// Utility
protobuf.util         = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");
protobuf.rpc          = __webpack_require__(/*! ./rpc */ "./node_modules/protobufjs/src/rpc.js");
protobuf.roots        = __webpack_require__(/*! ./roots */ "./node_modules/protobufjs/src/roots.js");
protobuf.configure    = configure;

/* istanbul ignore next */
/**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */
function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}

// Set up buffer utility according to the environment
configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Reader;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferReader; // cyclic

var LongBits  = util.LongBits,
    utf8      = util.utf8;

/* istanbul ignore next */
function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}

/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */
function Reader(buffer) {

    /**
     * Read buffer.
     * @type {Uint8Array}
     */
    this.buf = buffer;

    /**
     * Read buffer position.
     * @type {number}
     */
    this.pos = 0;

    /**
     * Read buffer length.
     * @type {number}
     */
    this.len = buffer.length;
}

var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    }
    /* istanbul ignore next */
    : function create_array(buffer) {
        if (Array.isArray(buffer))
            return new Reader(buffer);
        throw Error("illegal buffer");
    };

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup(buffer) {
            return (Reader.create = function create_buffer(buffer) {
                return util.Buffer.isBuffer(buffer)
                    ? new BufferReader(buffer)
                    /* istanbul ignore next */
                    : create_array(buffer);
            })(buffer);
        }
        /* istanbul ignore next */
        : create_array;
};

/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */
Reader.create = create();

Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;

/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
})();

/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};

/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */
Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};

/* eslint-disable no-invalid-this */

function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
}

/* eslint-enable no-invalid-this */

/**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */
Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};

function readFixed32_end(buf, end) { // note that this uses `end`, not `pos`
    return (buf[end - 4]
          | buf[end - 3] << 8
          | buf[end - 2] << 16
          | buf[end - 1] << 24) >>> 0;
}

/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.fixed32 = function read_fixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4);
};

/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */
Reader.prototype.sfixed32 = function read_sfixed32() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    return readFixed32_end(this.buf, this.pos += 4) | 0;
};

/* eslint-disable no-invalid-this */

function readFixed64(/* this: Reader */) {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);

    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}

/* eslint-enable no-invalid-this */

/**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */

/**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.float = function read_float() {

    /* istanbul ignore if */
    if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};

/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */
Reader.prototype.double = function read_double() {

    /* istanbul ignore if */
    if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);

    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */
Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
};

/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */
Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};

/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */
Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
};

/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */
Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};

Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();

    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {

        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },

        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },

        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },

        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },

        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }

    });
};


/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferReader;

// extends Reader
var Reader = __webpack_require__(/*! ./reader */ "./node_modules/protobufjs/src/reader.js");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */
function BufferReader(buffer) {
    Reader.call(this, buffer);

    /**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */
}

BufferReader._configure = function () {
    /* istanbul ignore else */
    if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
};


/**
 * @override
 */
BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice
        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))
        : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};

/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */

BufferReader._configure();


/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = {};

/**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Streaming RPC helpers.
 * @namespace
 */
var rpc = exports;

/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */

/**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */

rpc.Service = __webpack_require__(/*! ./rpc/service */ "./node_modules/protobufjs/src/rpc/service.js");


/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Service;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;

/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */

/**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */

/**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */
function Service(rpcImpl, requestDelimited, responseDelimited) {

    if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");

    util.EventEmitter.call(this);

    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */
    this.rpcImpl = rpcImpl;

    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */
    this.requestDelimited = Boolean(requestDelimited);

    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */
    this.responseDelimited = Boolean(responseDelimited);
}

/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {

    if (!request)
        throw TypeError("request must be specified");

    var self = this;
    if (!callback)
        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);

    if (!self.rpcImpl) {
        setTimeout(function() { callback(Error("already ended")); }, 0);
        return undefined;
    }

    try {
        return self.rpcImpl(
            method,
            requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
            function rpcCallback(err, response) {

                if (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }

                if (response === null) {
                    self.end(/* endedByRPC */ true);
                    return undefined;
                }

                if (!(response instanceof responseCtor)) {
                    try {
                        response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                    } catch (err) {
                        self.emit("error", err, method);
                        return callback(err);
                    }
                }

                self.emit("data", response, method);
                return callback(null, response);
            }
        );
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() { callback(err); }, 0);
        return undefined;
    }
};

/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */
Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) // signal end to rpcImpl
            this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = LongBits;

var util = __webpack_require__(/*! ../util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */
function LongBits(lo, hi) {

    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.

    /**
     * Low bits.
     * @type {number}
     */
    this.lo = lo >>> 0;

    /**
     * High bits.
     * @type {number}
     */
    this.hi = hi >>> 0;
}

/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */
var zero = LongBits.zero = new LongBits(0, 0);

zero.toNumber = function() { return 0; };
zero.zzEncode = zero.zzDecode = function() { return this; };
zero.length = function() { return 1; };

/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */
var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";

/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
        return zero;
    var sign = value < 0;
    if (sign)
        value = -value;
    var lo = value >>> 0,
        hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
                hi = 0;
        }
    }
    return new LongBits(lo, hi);
};

/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */
LongBits.from = function from(value) {
    if (typeof value === "number")
        return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */
        if (util.Long)
            value = util.Long.fromString(value);
        else
            return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};

/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */
LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};

/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */
LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long
        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))
        /* istanbul ignore next */
        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
};

var charCodeAt = String.prototype.charCodeAt;

/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */
LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
        return zero;
    return new LongBits(
        ( charCodeAt.call(hash, 0)
        | charCodeAt.call(hash, 1) << 8
        | charCodeAt.call(hash, 2) << 16
        | charCodeAt.call(hash, 3) << 24) >>> 0
    ,
        ( charCodeAt.call(hash, 4)
        | charCodeAt.call(hash, 5) << 8
        | charCodeAt.call(hash, 6) << 16
        | charCodeAt.call(hash, 7) << 24) >>> 0
    );
};

/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */
LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(
        this.lo        & 255,
        this.lo >>> 8  & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24      ,
        this.hi        & 255,
        this.hi >>> 8  & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
    );
};

/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzEncode = function zzEncode() {
    var mask =   this.hi >> 31;
    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;
    return this;
};

/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */
LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;
    return this;
};

/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */
LongBits.prototype.length = function length() {
    var part0 =  this.lo,
        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
        part2 =  this.hi >>> 24;
    return part2 === 0
         ? part1 === 0
           ? part0 < 16384
             ? part0 < 128 ? 1 : 2
             : part0 < 2097152 ? 3 : 4
           : part1 < 16384
             ? part1 < 128 ? 5 : 6
             : part1 < 2097152 ? 7 : 8
         : part2 < 128 ? 9 : 10;
};


/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ "./node_modules/@protobufjs/aspromise/index.js");

// converts to / from base64 encoded strings
util.base64 = __webpack_require__(/*! @protobufjs/base64 */ "./node_modules/@protobufjs/base64/index.js");

// base class of rpc.Service
util.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ "./node_modules/@protobufjs/eventemitter/index.js");

// float handling accross browsers
util.float = __webpack_require__(/*! @protobufjs/float */ "./node_modules/@protobufjs/float/index.js");

// requires modules optionally and hides the call from bundlers
util.inquire = __webpack_require__(/*! @protobufjs/inquire */ "./node_modules/@protobufjs/inquire/index.js");

// converts to / from utf8 encoded strings
util.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ "./node_modules/@protobufjs/utf8/index.js");

// provides a node-like buffer pool in the browser
util.pool = __webpack_require__(/*! @protobufjs/pool */ "./node_modules/@protobufjs/pool/index.js");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = __webpack_require__(/*! ./longbits */ "./node_modules/protobufjs/src/util/longbits.js");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = Writer;

var util      = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};


/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = BufferWriter;

// extends Writer
var Writer = __webpack_require__(/*! ./writer */ "./node_modules/protobufjs/src/writer.js");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = __webpack_require__(/*! ./util/minimal */ "./node_modules/protobufjs/src/util/minimal.js");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

throw new Error("Module build failed: Error: ENOENT: no such file or directory, open 'C:\\Users\\Justin\\Documents\\u3dWorkspace\\NICE_Framework\\Nice-TS\\TsProj\\node_modules\\webpack\\buildin\\global.js'");

/***/ }),

/***/ "./src/GameMain.ts":
/*!*************************!*\
  !*** ./src/GameMain.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/ui/common */ "./src/data/ui/common.ts");





class GameMain {
    constructor() {
        csharp__WEBPACK_IMPORTED_MODULE_0__["JsManager"].Instance.JsOnApplicationQuit = () => this.onApplicationQuit();
        csharp__WEBPACK_IMPORTED_MODULE_0__["JsManager"].Instance.JsOnDispose = () => this.onDispose();
    }
    async start() {
        try {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game start in JS....");
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].StoryManager.initialize();
            //excel
            //ExcelManager.Instance(ExcelManager);
            //FairyGUI
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].ResManager.loadFairyGUIPackage(_data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].PackageName);
            //do Unit Test
            //UnitTest.doTest();
            //
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_1__["SceneDef"].LoginScene);
            //JSC#
            csharp__WEBPACK_IMPORTED_MODULE_0__["GameLaunch"].Instance.JsLuanchFinish();
        }
        catch (ex) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(ex);
        }
    }
    onApplicationQuit() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].GameObjectPool.cleanup(true);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game onApplicationQuit in JS....");
    }
    onDispose() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Game onDispose in JS....");
    }
}
new GameMain().start();


/***/ }),

/***/ "./src/data/pb/Opcode.ts":
/*!*******************************!*\
  !*** ./src/data/pb/Opcode.ts ***!
  \*******************************/
/*! exports provided: DecodeMsg, Opcode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecodeMsg", function() { return DecodeMsg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Opcode", function() { return Opcode; });
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_gen_pb__WEBPACK_IMPORTED_MODULE_0__);

class DecodeMsg {
}
class Opcode {
    static decode(opcode, msg) {
        let msgObj = this.map[opcode]["decode"](msg);
        let decodeMsg = new DecodeMsg();
        decodeMsg.rpcId = msgObj.RpcId;
        decodeMsg.msgObj = msgObj;
        return decodeMsg;
    }
    static encode(opcode, msg) {
        let buf = this.map[opcode]["encode"](msg).finish();
        return buf;
    }
}
Opcode.MSG_C2R_Login = 1000;
Opcode.MSG_R2C_Login = 1001;
Opcode.MSG_C2G_LoginGate = 1002;
Opcode.MSG_G2C_LoginGate = 1003;
Opcode.MSG_C2GS_Test = 2001;
Opcode.MSG_GS2C_Test = 2002;
Opcode.map = {
    1000: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.encode },
    1001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].R2C_Login.encode },
    1002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.encode },
    1003: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].G2C_LoginGate.encode },
    2001: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.encode },
    2002: { "decode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.decode, "encode": _gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].GS2C_Test.encode }
};


/***/ }),

/***/ "./src/data/pb/gen/pb.js":
/*!*******************************!*\
  !*** ./src/data/pb/gen/pb.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/


var $protobuf = __webpack_require__(/*! protobufjs/minimal */ "./node_modules/protobufjs/minimal.js");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

var Long = __webpack_require__(/*! long */ "./node_modules/long/src/long.js");
$protobuf.util.Long = Long;
$protobuf.configure();


// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.nice_ts = (function() {

    /**
     * Namespace nice_ts.
     * @exports nice_ts
     * @namespace
     */
    var nice_ts = {};

    nice_ts.C2R_Login = (function() {

        /**
         * Properties of a C2R_Login.
         * @memberof nice_ts
         * @interface IC2R_Login
         * @property {string|null} [Account] C2R_Login Account
         * @property {string|null} [Password] C2R_Login Password
         */

        /**
         * Constructs a new C2R_Login.
         * @memberof nice_ts
         * @classdesc Represents a C2R_Login.
         * @implements IC2R_Login
         * @constructor
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         */
        function C2R_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2R_Login Account.
         * @member {string} Account
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Account = "";

        /**
         * C2R_Login Password.
         * @member {string} Password
         * @memberof nice_ts.C2R_Login
         * @instance
         */
        C2R_Login.prototype.Password = "";

        /**
         * Creates a new C2R_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login=} [properties] Properties to set
         * @returns {nice_ts.C2R_Login} C2R_Login instance
         */
        C2R_Login.create = function create(properties) {
            return new C2R_Login(properties);
        };

        /**
         * Encodes the specified C2R_Login message. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && Object.hasOwnProperty.call(message, "Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && Object.hasOwnProperty.call(message, "Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified C2R_Login message, length delimited. Does not implicitly {@link nice_ts.C2R_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.IC2R_Login} message C2R_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2R_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2R_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2R_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2R_Login} C2R_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2R_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2R_Login message.
         * @function verify
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2R_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        /**
         * Creates a C2R_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2R_Login} C2R_Login
         */
        C2R_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2R_Login)
                return object;
            var message = new $root.nice_ts.C2R_Login();
            if (object.Account != null)
                message.Account = String(object.Account);
            if (object.Password != null)
                message.Password = String(object.Password);
            return message;
        };

        /**
         * Creates a plain object from a C2R_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2R_Login
         * @static
         * @param {nice_ts.C2R_Login} message C2R_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2R_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Account = "";
                object.Password = "";
            }
            if (message.Account != null && message.hasOwnProperty("Account"))
                object.Account = message.Account;
            if (message.Password != null && message.hasOwnProperty("Password"))
                object.Password = message.Password;
            return object;
        };

        /**
         * Converts this C2R_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.C2R_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2R_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2R_Login;
    })();

    nice_ts.R2C_Login = (function() {

        /**
         * Properties of a R2C_Login.
         * @memberof nice_ts
         * @interface IR2C_Login
         * @property {number|null} [Error] R2C_Login Error
         * @property {string|null} [Message] R2C_Login Message
         * @property {string|null} [Address] R2C_Login Address
         * @property {number|Long|null} [Key] R2C_Login Key
         * @property {number|Long|null} [GateId] R2C_Login GateId
         */

        /**
         * Constructs a new R2C_Login.
         * @memberof nice_ts
         * @classdesc Represents a R2C_Login.
         * @implements IR2C_Login
         * @constructor
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         */
        function R2C_Login(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * R2C_Login Error.
         * @member {number} Error
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Error = 0;

        /**
         * R2C_Login Message.
         * @member {string} Message
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Message = "";

        /**
         * R2C_Login Address.
         * @member {string} Address
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Address = "";

        /**
         * R2C_Login Key.
         * @member {number|Long} Key
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * R2C_Login GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.R2C_Login
         * @instance
         */
        R2C_Login.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new R2C_Login instance using the specified properties.
         * @function create
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login=} [properties] Properties to set
         * @returns {nice_ts.R2C_Login} R2C_Login instance
         */
        R2C_Login.create = function create(properties) {
            return new R2C_Login(properties);
        };

        /**
         * Encodes the specified R2C_Login message. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Address != null && Object.hasOwnProperty.call(message, "Address"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Address);
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.GateId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified R2C_Login message, length delimited. Does not implicitly {@link nice_ts.R2C_Login.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.IR2C_Login} message R2C_Login message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        R2C_Login.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.R2C_Login();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.Address = reader.string();
                    break;
                case 2:
                    message.Key = reader.int64();
                    break;
                case 3:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a R2C_Login message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.R2C_Login} R2C_Login
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        R2C_Login.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a R2C_Login message.
         * @function verify
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        R2C_Login.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.Address != null && message.hasOwnProperty("Address"))
                if (!$util.isString(message.Address))
                    return "Address: string expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a R2C_Login message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.R2C_Login} R2C_Login
         */
        R2C_Login.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.R2C_Login)
                return object;
            var message = new $root.nice_ts.R2C_Login();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.Address != null)
                message.Address = String(object.Address);
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a R2C_Login message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.R2C_Login
         * @static
         * @param {nice_ts.R2C_Login} message R2C_Login
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        R2C_Login.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.Address = "";
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.Address != null && message.hasOwnProperty("Address"))
                object.Address = message.Address;
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this R2C_Login to JSON.
         * @function toJSON
         * @memberof nice_ts.R2C_Login
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        R2C_Login.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return R2C_Login;
    })();

    nice_ts.C2G_LoginGate = (function() {

        /**
         * Properties of a C2G_LoginGate.
         * @memberof nice_ts
         * @interface IC2G_LoginGate
         * @property {number|Long|null} [Key] C2G_LoginGate Key
         * @property {number|Long|null} [GateId] C2G_LoginGate GateId
         */

        /**
         * Constructs a new C2G_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a C2G_LoginGate.
         * @implements IC2G_LoginGate
         * @constructor
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         */
        function C2G_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2G_LoginGate Key.
         * @member {number|Long} Key
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.Key = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * C2G_LoginGate GateId.
         * @member {number|Long} GateId
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         */
        C2G_LoginGate.prototype.GateId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new C2G_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate instance
         */
        C2G_LoginGate.create = function create(properties) {
            return new C2G_LoginGate(properties);
        };

        /**
         * Encodes the specified C2G_LoginGate message. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Key != null && Object.hasOwnProperty.call(message, "Key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.Key);
            if (message.GateId != null && Object.hasOwnProperty.call(message, "GateId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.GateId);
            return writer;
        };

        /**
         * Encodes the specified C2G_LoginGate message, length delimited. Does not implicitly {@link nice_ts.C2G_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.IC2G_LoginGate} message C2G_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2G_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2G_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Key = reader.int64();
                    break;
                case 2:
                    message.GateId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2G_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2G_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2G_LoginGate message.
         * @function verify
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2G_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (!$util.isInteger(message.Key) && !(message.Key && $util.isInteger(message.Key.low) && $util.isInteger(message.Key.high)))
                    return "Key: integer|Long expected";
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (!$util.isInteger(message.GateId) && !(message.GateId && $util.isInteger(message.GateId.low) && $util.isInteger(message.GateId.high)))
                    return "GateId: integer|Long expected";
            return null;
        };

        /**
         * Creates a C2G_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2G_LoginGate} C2G_LoginGate
         */
        C2G_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2G_LoginGate)
                return object;
            var message = new $root.nice_ts.C2G_LoginGate();
            if (object.Key != null)
                if ($util.Long)
                    (message.Key = $util.Long.fromValue(object.Key)).unsigned = false;
                else if (typeof object.Key === "string")
                    message.Key = parseInt(object.Key, 10);
                else if (typeof object.Key === "number")
                    message.Key = object.Key;
                else if (typeof object.Key === "object")
                    message.Key = new $util.LongBits(object.Key.low >>> 0, object.Key.high >>> 0).toNumber();
            if (object.GateId != null)
                if ($util.Long)
                    (message.GateId = $util.Long.fromValue(object.GateId)).unsigned = false;
                else if (typeof object.GateId === "string")
                    message.GateId = parseInt(object.GateId, 10);
                else if (typeof object.GateId === "number")
                    message.GateId = object.GateId;
                else if (typeof object.GateId === "object")
                    message.GateId = new $util.LongBits(object.GateId.low >>> 0, object.GateId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a C2G_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2G_LoginGate
         * @static
         * @param {nice_ts.C2G_LoginGate} message C2G_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2G_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.Key = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Key = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.GateId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.GateId = options.longs === String ? "0" : 0;
            }
            if (message.Key != null && message.hasOwnProperty("Key"))
                if (typeof message.Key === "number")
                    object.Key = options.longs === String ? String(message.Key) : message.Key;
                else
                    object.Key = options.longs === String ? $util.Long.prototype.toString.call(message.Key) : options.longs === Number ? new $util.LongBits(message.Key.low >>> 0, message.Key.high >>> 0).toNumber() : message.Key;
            if (message.GateId != null && message.hasOwnProperty("GateId"))
                if (typeof message.GateId === "number")
                    object.GateId = options.longs === String ? String(message.GateId) : message.GateId;
                else
                    object.GateId = options.longs === String ? $util.Long.prototype.toString.call(message.GateId) : options.longs === Number ? new $util.LongBits(message.GateId.low >>> 0, message.GateId.high >>> 0).toNumber() : message.GateId;
            return object;
        };

        /**
         * Converts this C2G_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.C2G_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2G_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2G_LoginGate;
    })();

    nice_ts.G2C_LoginGate = (function() {

        /**
         * Properties of a G2C_LoginGate.
         * @memberof nice_ts
         * @interface IG2C_LoginGate
         * @property {number|null} [Error] G2C_LoginGate Error
         * @property {string|null} [Message] G2C_LoginGate Message
         * @property {number|Long|null} [PlayerId] G2C_LoginGate PlayerId
         */

        /**
         * Constructs a new G2C_LoginGate.
         * @memberof nice_ts
         * @classdesc Represents a G2C_LoginGate.
         * @implements IG2C_LoginGate
         * @constructor
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         */
        function G2C_LoginGate(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2C_LoginGate Error.
         * @member {number} Error
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Error = 0;

        /**
         * G2C_LoginGate Message.
         * @member {string} Message
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.Message = "";

        /**
         * G2C_LoginGate PlayerId.
         * @member {number|Long} PlayerId
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         */
        G2C_LoginGate.prototype.PlayerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new G2C_LoginGate instance using the specified properties.
         * @function create
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate=} [properties] Properties to set
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate instance
         */
        G2C_LoginGate.create = function create(properties) {
            return new G2C_LoginGate(properties);
        };

        /**
         * Encodes the specified G2C_LoginGate message. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerId != null && Object.hasOwnProperty.call(message, "PlayerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.PlayerId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified G2C_LoginGate message, length delimited. Does not implicitly {@link nice_ts.G2C_LoginGate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.IG2C_LoginGate} message G2C_LoginGate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2C_LoginGate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.G2C_LoginGate();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.PlayerId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2C_LoginGate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2C_LoginGate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2C_LoginGate message.
         * @function verify
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2C_LoginGate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (!$util.isInteger(message.PlayerId) && !(message.PlayerId && $util.isInteger(message.PlayerId.low) && $util.isInteger(message.PlayerId.high)))
                    return "PlayerId: integer|Long expected";
            return null;
        };

        /**
         * Creates a G2C_LoginGate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.G2C_LoginGate} G2C_LoginGate
         */
        G2C_LoginGate.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.G2C_LoginGate)
                return object;
            var message = new $root.nice_ts.G2C_LoginGate();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.PlayerId != null)
                if ($util.Long)
                    (message.PlayerId = $util.Long.fromValue(object.PlayerId)).unsigned = false;
                else if (typeof object.PlayerId === "string")
                    message.PlayerId = parseInt(object.PlayerId, 10);
                else if (typeof object.PlayerId === "number")
                    message.PlayerId = object.PlayerId;
                else if (typeof object.PlayerId === "object")
                    message.PlayerId = new $util.LongBits(object.PlayerId.low >>> 0, object.PlayerId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a G2C_LoginGate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.G2C_LoginGate
         * @static
         * @param {nice_ts.G2C_LoginGate} message G2C_LoginGate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        G2C_LoginGate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.PlayerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PlayerId = options.longs === String ? "0" : 0;
                object.Error = 0;
                object.Message = "";
            }
            if (message.PlayerId != null && message.hasOwnProperty("PlayerId"))
                if (typeof message.PlayerId === "number")
                    object.PlayerId = options.longs === String ? String(message.PlayerId) : message.PlayerId;
                else
                    object.PlayerId = options.longs === String ? $util.Long.prototype.toString.call(message.PlayerId) : options.longs === Number ? new $util.LongBits(message.PlayerId.low >>> 0, message.PlayerId.high >>> 0).toNumber() : message.PlayerId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this G2C_LoginGate to JSON.
         * @function toJSON
         * @memberof nice_ts.G2C_LoginGate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        G2C_LoginGate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return G2C_LoginGate;
    })();

    nice_ts.C2GS_Test = (function() {

        /**
         * Properties of a C2GS_Test.
         * @memberof nice_ts
         * @interface IC2GS_Test
         * @property {number|null} [testID] C2GS_Test testID
         * @property {string|null} [testName] C2GS_Test testName
         */

        /**
         * Constructs a new C2GS_Test.
         * @memberof nice_ts
         * @classdesc Represents a C2GS_Test.
         * @implements IC2GS_Test
         * @constructor
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         */
        function C2GS_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2GS_Test testID.
         * @member {number} testID
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testID = 0;

        /**
         * C2GS_Test testName.
         * @member {string} testName
         * @memberof nice_ts.C2GS_Test
         * @instance
         */
        C2GS_Test.prototype.testName = "";

        /**
         * Creates a new C2GS_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test=} [properties] Properties to set
         * @returns {nice_ts.C2GS_Test} C2GS_Test instance
         */
        C2GS_Test.create = function create(properties) {
            return new C2GS_Test(properties);
        };

        /**
         * Encodes the specified C2GS_Test message. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testID != null && Object.hasOwnProperty.call(message, "testID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.testID);
            if (message.testName != null && Object.hasOwnProperty.call(message, "testName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.testName);
            return writer;
        };

        /**
         * Encodes the specified C2GS_Test message, length delimited. Does not implicitly {@link nice_ts.C2GS_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.IC2GS_Test} message C2GS_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2GS_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.C2GS_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.testID = reader.int32();
                    break;
                case 2:
                    message.testName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2GS_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2GS_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2GS_Test message.
         * @function verify
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2GS_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.testID != null && message.hasOwnProperty("testID"))
                if (!$util.isInteger(message.testID))
                    return "testID: integer expected";
            if (message.testName != null && message.hasOwnProperty("testName"))
                if (!$util.isString(message.testName))
                    return "testName: string expected";
            return null;
        };

        /**
         * Creates a C2GS_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.C2GS_Test} C2GS_Test
         */
        C2GS_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.C2GS_Test)
                return object;
            var message = new $root.nice_ts.C2GS_Test();
            if (object.testID != null)
                message.testID = object.testID | 0;
            if (object.testName != null)
                message.testName = String(object.testName);
            return message;
        };

        /**
         * Creates a plain object from a C2GS_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.C2GS_Test
         * @static
         * @param {nice_ts.C2GS_Test} message C2GS_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        C2GS_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testID = 0;
                object.testName = "";
            }
            if (message.testID != null && message.hasOwnProperty("testID"))
                object.testID = message.testID;
            if (message.testName != null && message.hasOwnProperty("testName"))
                object.testName = message.testName;
            return object;
        };

        /**
         * Converts this C2GS_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.C2GS_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        C2GS_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return C2GS_Test;
    })();

    nice_ts.GS2C_Test = (function() {

        /**
         * Properties of a GS2C_Test.
         * @memberof nice_ts
         * @interface IGS2C_Test
         * @property {number|null} [Error] GS2C_Test Error
         * @property {string|null} [Message] GS2C_Test Message
         * @property {string|null} [testResponse] GS2C_Test testResponse
         */

        /**
         * Constructs a new GS2C_Test.
         * @memberof nice_ts
         * @classdesc Represents a GS2C_Test.
         * @implements IGS2C_Test
         * @constructor
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         */
        function GS2C_Test(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GS2C_Test Error.
         * @member {number} Error
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Error = 0;

        /**
         * GS2C_Test Message.
         * @member {string} Message
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.Message = "";

        /**
         * GS2C_Test testResponse.
         * @member {string} testResponse
         * @memberof nice_ts.GS2C_Test
         * @instance
         */
        GS2C_Test.prototype.testResponse = "";

        /**
         * Creates a new GS2C_Test instance using the specified properties.
         * @function create
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test=} [properties] Properties to set
         * @returns {nice_ts.GS2C_Test} GS2C_Test instance
         */
        GS2C_Test.create = function create(properties) {
            return new GS2C_Test(properties);
        };

        /**
         * Encodes the specified GS2C_Test message. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.testResponse != null && Object.hasOwnProperty.call(message, "testResponse"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.testResponse);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 91, wireType 0 =*/728).int32(message.Error);
            if (message.Message != null && Object.hasOwnProperty.call(message, "Message"))
                writer.uint32(/* id 92, wireType 2 =*/738).string(message.Message);
            return writer;
        };

        /**
         * Encodes the specified GS2C_Test message, length delimited. Does not implicitly {@link nice_ts.GS2C_Test.verify|verify} messages.
         * @function encodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.IGS2C_Test} message GS2C_Test message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GS2C_Test.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer.
         * @function decode
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.nice_ts.GS2C_Test();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 91:
                    message.Error = reader.int32();
                    break;
                case 92:
                    message.Message = reader.string();
                    break;
                case 1:
                    message.testResponse = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GS2C_Test message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GS2C_Test.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GS2C_Test message.
         * @function verify
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GS2C_Test.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isInteger(message.Error))
                    return "Error: integer expected";
            if (message.Message != null && message.hasOwnProperty("Message"))
                if (!$util.isString(message.Message))
                    return "Message: string expected";
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                if (!$util.isString(message.testResponse))
                    return "testResponse: string expected";
            return null;
        };

        /**
         * Creates a GS2C_Test message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {nice_ts.GS2C_Test} GS2C_Test
         */
        GS2C_Test.fromObject = function fromObject(object) {
            if (object instanceof $root.nice_ts.GS2C_Test)
                return object;
            var message = new $root.nice_ts.GS2C_Test();
            if (object.Error != null)
                message.Error = object.Error | 0;
            if (object.Message != null)
                message.Message = String(object.Message);
            if (object.testResponse != null)
                message.testResponse = String(object.testResponse);
            return message;
        };

        /**
         * Creates a plain object from a GS2C_Test message. Also converts values to other types if specified.
         * @function toObject
         * @memberof nice_ts.GS2C_Test
         * @static
         * @param {nice_ts.GS2C_Test} message GS2C_Test
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GS2C_Test.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.testResponse = "";
                object.Error = 0;
                object.Message = "";
            }
            if (message.testResponse != null && message.hasOwnProperty("testResponse"))
                object.testResponse = message.testResponse;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Message != null && message.hasOwnProperty("Message"))
                object.Message = message.Message;
            return object;
        };

        /**
         * Converts this GS2C_Test to JSON.
         * @function toJSON
         * @memberof nice_ts.GS2C_Test
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GS2C_Test.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return GS2C_Test;
    })();

    return nice_ts;
})();

module.exports = $root;


/***/ }),

/***/ "./src/data/ui/combat.ts":
/*!*******************************!*\
  !*** ./src/data/ui/combat.ts ***!
  \*******************************/
/*! exports provided: combatUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combatUI", function() { return combatUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class combatUI {
}
combatUI.PackageName = "combat";
combatUI.PackageBytes = "combat_fui.bytes";
combatUI.UItest = "test";
combatUI.UICard = "Card";
combatUI.UICombatPage = "CombatPage";
combatUI.UIRoom = "Room";


/***/ }),

/***/ "./src/data/ui/common.ts":
/*!*******************************!*\
  !*** ./src/data/ui/common.ts ***!
  \*******************************/
/*! exports provided: commonUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commonUI", function() { return commonUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class commonUI {
}
commonUI.PackageName = "common";
commonUI.PackageBytes = "common_fui.bytes";
commonUI.UILoadingPage = "LoadingPage";
commonUI.UIUIGuideWin = "UIGuideWin";
commonUI.UIUINoticeWin = "UINoticeWin";


/***/ }),

/***/ "./src/data/ui/home.ts":
/*!*****************************!*\
  !*** ./src/data/ui/home.ts ***!
  \*****************************/
/*! exports provided: homeUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "homeUI", function() { return homeUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class homeUI {
}
homeUI.PackageName = "home";
homeUI.PackageBytes = "home_fui.bytes";
homeUI.UIHomePage = "HomePage";
homeUI.UILevelPage = "LevelPage";
homeUI.UIShopPage = "ShopPage";


/***/ }),

/***/ "./src/data/ui/login.ts":
/*!******************************!*\
  !*** ./src/data/ui/login.ts ***!
  \******************************/
/*! exports provided: loginUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loginUI", function() { return loginUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class loginUI {
}
loginUI.PackageName = "login";
loginUI.PackageBytes = "login_fui.bytes";
loginUI.UILoginPage = "LoginPage";
loginUI.UISelServerWin = "SelServerWin";
loginUI.UIAreaItem = "AreaItem";


/***/ }),

/***/ "./src/data/ui/story.ts":
/*!******************************!*\
  !*** ./src/data/ui/story.ts ***!
  \******************************/
/*! exports provided: storyUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "storyUI", function() { return storyUI; });
/** This is an automatically generated class by FairyGUI. Please do not modify it. **/
class storyUI {
}
storyUI.PackageName = "story";
storyUI.PackageBytes = "story_fui.bytes";
storyUI.UIStoryWin = "StoryWin";


/***/ }),

/***/ "./src/framework/common/GameObjectPool.ts":
/*!************************************************!*\
  !*** ./src/framework/common/GameObjectPool.ts ***!
  \************************************************/
/*! exports provided: GameObjectPool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameObjectPool", function() { return GameObjectPool; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



// -- GameObject
// -- 
// -- 1ResourcesManager
// -- 2GameObject(Asset)GameObjectInst
class GameObjectPool extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.__cacheTransRoot = null;
        this.__goPool = new Map();
        this.__instCache = new Map();
        let go = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Find("GameObjectCacheRoot");
        if (go == undefined) {
            go = new csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject("GameObjectCacheRoot");
            csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].Object.DontDestroyOnLoad(go);
        }
        this.__cacheTransRoot = go.transform;
    }
    //-- 
    checkHasCached(path) {
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            return true;
        }
        let pooledGo = this.__goPool.get(path);
        return pooledGo != undefined;
    }
    //-- GameObject
    cacheAndInstGameObject(path, go, inst_count = 1) {
        this.__goPool.set(path, go);
        if (inst_count > 0) {
            let cachedInst = this.__instCache.get(path);
            for (let i = 0; i < inst_count; i++) {
                let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(go);
                inst.transform.SetParent(this.__cacheTransRoot);
                inst.SetActive(false);
                cachedInst.push(inst);
            }
        }
    }
    //-- 
    tryGetFromCache(path) {
        if (!this.checkHasCached(path)) {
            return null;
        }
        let cachedInst = this.__instCache.get(path);
        if (cachedInst != undefined && cachedInst.length > 0) {
            let inst = cachedInst.pop();
            return inst;
        }
        let pooledGo = this.__goPool.get(path);
        if (pooledGo != undefined) {
            let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(pooledGo);
            return inst;
        }
        return null;
    }
    //
    async preLoadGameObjectAsync(path, inst_count, callback, ...params) {
        if (this.checkHasCached(path)) {
            if (callback != null) {
                callback(params);
            }
            return;
        }
        let go = await _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).loadPrefab(path);
        if (go != undefined) {
            this.cacheAndInstGameObject(path, go, inst_count);
        }
        if (callback != null) {
            callback(params);
        }
    }
    //-- 
    async getGameObjectAsync(path, callback, ...params) {
        let inst = this.tryGetFromCache(path);
        if (inst == null) {
            await this.preLoadGameObjectAsync(path, 1, callback, params);
        }
        inst = this.tryGetFromCache(path);
        inst.SetActive(true);
    }
    //-- 
    recycleGameObject(path, inst) {
        inst.transform.SetParent(this.__cacheTransRoot);
        inst.SetActive(false);
        let cachedInst = this.__instCache.get(path) || new Array();
        cachedInst.push(inst);
        this.__instCache.set(path, cachedInst);
    }
    //-- 
    cleanup(includePooledGo = false) {
        this.__instCache.forEach((values, key) => {
            for (let inst of values) {
                if (inst != null) {
                    csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Destroy(inst);
                }
            }
        });
        this.__instCache.clear();
        if (includePooledGo) {
            this.__goPool.forEach((go, key) => {
                if (go != null) {
                    _ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]).releaseAddressGO(go);
                }
            });
            this.__goPool.clear();
        }
    }
}


/***/ }),

/***/ "./src/framework/common/Messenger.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Messenger.ts ***!
  \*******************************************/
/*! exports provided: MesObj, Messenger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MesObj", function() { return MesObj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Messenger", function() { return Messenger; });
class MesObj {
}
class Messenger {
    constructor() {
        this.listenerMap = new Map();
    }
    addListener(e_type, e_obj, e_listner) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) == "undefined") {
            msgObj = new MesObj();
            msgObj.obj = e_obj;
            msgObj.listeners = new Array();
        }
        msgObj.listeners.push(e_listner);
        this.listenerMap.set(e_type, msgObj);
    }
    getListener(e_type) {
        return this.listenerMap.get(e_type);
    }
    broadcast(e_type, ...params) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let l of msgObj.listeners) {
                l.apply(msgObj.obj, params);
            }
        }
    }
    removeListenerByType(e_type) {
        this.listenerMap.delete(e_type);
    }
    removeListener(e_type, e_listener) {
        let msgObj = this.listenerMap.get(e_type);
        if (typeof (msgObj) != "undefined") {
            for (let i = 0; i < msgObj.listeners.length; i++) {
                if (msgObj.listeners[i] == e_listener) {
                    msgObj.listeners.splice(i, 1);
                }
            }
        }
    }
    clearup() {
        this.listenerMap.clear();
    }
}


/***/ }),

/***/ "./src/framework/common/NiceDecorator.ts":
/*!***********************************************!*\
  !*** ./src/framework/common/NiceDecorator.ts ***!
  \***********************************************/
/*! exports provided: binder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binder", function() { return binder; });
// FairyGUI  
function binder(name) {
    return function (target, key) {
        target["binders"] = target["binders"] || {};
        target["binders"][key] = name;
    };
}


/***/ }),

/***/ "./src/framework/common/ResManager.ts":
/*!********************************************!*\
  !*** ./src/framework/common/ResManager.ts ***!
  \********************************************/
/*! exports provided: ResManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ResManager", function() { return ResManager; });
/* harmony import */ var _Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class ResManager extends _Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this._pkgMap = new Map();
    }
    async loadFairyGUIPackage(packageName) {
        try {
            let count = this._pkgMap.get(packageName);
            if (count == null || count < 1) {
                //
                let address = packageName + "_fui.bytes";
                let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadFairyGUIPackage(address, packageName);
                await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
                this._pkgMap.set(packageName, 1);
            }
            else {
                this._pkgMap.set(packageName, count + 1);
            }
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load fairyGUI :${packageName} : ${ex}`);
        }
    }
    releaseFairyGUIPackage(packageName) {
        let count = this._pkgMap.get(packageName);
        if (count != null && count > 1) {
            this._pkgMap.set(packageName, count - 1);
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log(`release fagui package:${packageName}`);
            this._pkgMap.delete(packageName);
            csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseFGUIPackage(packageName);
        }
    }
    async loadScene(sceneName, mode = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].SceneManagement.LoadSceneMode.Single) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadScene(sceneName, mode, (progress) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("load scene: " + progress);
            });
            let scenInstance = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return scenInstance;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load Scene :${sceneName} : ${ex}`);
            return null;
        }
    }
    async unloadScene(sceneInstance) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadScene(sceneInstance);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Unload scene  : ${ex}`);
            return null;
        }
    }
    unloadSceneByName(sceneName) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.UnloadSceneByName(sceneName);
    }
    async loadPrefab(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadPrefab(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load prefab :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextAsset(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextAsset(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load textasset :${address} : ${ex}`);
            return null;
        }
    }
    async loadTextBytes(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadTextBytes(address);
            let bytes = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return bytes;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`LoadTextBytes :${address} : ${ex}`);
        }
    }
    async loadSprite(address) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.LoadSprite(address);
            let go = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return go;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Load sprite :${address} : ${ex}`);
            return null;
        }
    }
    releaseAddressGO(go) {
        csharp__WEBPACK_IMPORTED_MODULE_2__["NiceTS"].ResourceManager.ReleaseAddressGO(go);
    }
}


/***/ }),

/***/ "./src/framework/common/Singleton.ts":
/*!*******************************************!*\
  !*** ./src/framework/common/Singleton.ts ***!
  \*******************************************/
/*! exports provided: Singleton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Singleton", function() { return Singleton; });
class Singleton {
    static Instance(c) {
        if (this.instance == null) {
            this.instance = new c();
        }
        return this.instance;
    }
}
Singleton.instance = null;


/***/ }),

/***/ "./src/framework/ink/InkStateInspector.ts":
/*!************************************************!*\
  !*** ./src/framework/ink/InkStateInspector.ts ***!
  \************************************************/
/*! exports provided: InkStateInspector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkStateInspector", function() { return InkStateInspector; });
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");

class InkStateInspector {
    BindInkMethods(inkStory) {
        //3
        this.bindInkMethodOnce(inkStory, "GetCharacterName", this.getCharacterName);
        //3 
        this.bindInkMethodOnceGeneral(inkStory, "GetCharacterNameByMutiParams", this.getCharacterNameMutiParams);
    }
    getCharacterName() {
        return "Justin Test Puerts";
    }
    getCharacterNameMutiParams(p1, p2, p3) {
        return "Justin Muti Params";
    }
    bindInkMethodOnce(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunction(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    bindInkMethodOnceGeneral(inkStory, funcName, func) {
        try {
            inkStory.BindExternalFunctionGeneral(funcName, func);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
    unbindInkMethod(inkStory, funcName) {
        try {
            inkStory.UnbindExternalFunction(funcName);
        }
        catch (err) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].warn(err);
        }
    }
}


/***/ }),

/***/ "./src/framework/ink/InkWriter.ts":
/*!****************************************!*\
  !*** ./src/framework/ink/InkWriter.ts ***!
  \****************************************/
/*! exports provided: InkWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InkWriter", function() { return InkWriter; });
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! inkjs/engine/Story */ "./node_modules/inkjs/engine/Story.js");
/* harmony import */ var inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkStateInspector */ "./src/framework/ink/InkStateInspector.ts");
/* harmony import */ var _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");




class InkWriter {
    constructor(storyJson) {
        this._allInkCommands = new Map();
        this.setupInkCommands();
        this.createStroy(storyJson);
        this.load();
    }
    load() {
        let storyState = "";
        if (storyState != null && storyState != "") {
            this._currentStory.state.LoadJson(storyState);
        }
    }
    createStroy(json) {
        this._currentStory = new inkjs_engine_Story__WEBPACK_IMPORTED_MODULE_0__["Story"](json);
    }
    beginStory(knotName) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
            return;
        }
        this._currentStory.ChoosePathString(knotName, true);
        let inkState = new _InkStateInspector__WEBPACK_IMPORTED_MODULE_2__["InkStateInspector"]();
        inkState.BindInkMethods(this._currentStory);
        this.advanceStory();
    }
    giveReward() {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].log("give reward...");
        return true;
    }
    setupInkCommands() {
        this._allInkCommands.set("GIVE_REWARD", this.giveReward);
    }
    handleCommand(command, args) {
        if (this._allInkCommands.has(command)) {
            return this._allInkCommands.get(command)(args);
        }
        _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].error("Could not find InkCommand with name:" + command);
        return true;
    }
    parseCommandName(text) {
        let num = text.indexOf(InkWriter.COMMAND_PREFIX);
        let num2 = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num2 == -1) {
            num2 = text.length;
        }
        let length = num2 - (num + InkWriter.COMMAND_PREFIX.length);
        return text.substr(num + InkWriter.COMMAND_PREFIX.length, length).trim();
    }
    parseCommandArgs(text) {
        let num = text.indexOf(InkWriter.COMMAND_DELIMITER);
        if (num == -1) {
            return [];
        }
        let length = text.length - (num + 1);
        let list = text.substr(num + 1, length).
            trim().
            split(InkWriter.COMMAND_ARG_DELIMITER);
        for (let i = 0; i < list.length; i++) {
            list[i] = list[i].trim();
        }
        return list;
    }
    extractSpeaker(line) {
        if (line.startsWith(InkWriter.COMMAND_PREFIX)) {
            return ["0", line.trim()];
        }
        let array = line.split(':', 2);
        if (array.length > 1) {
            let speakID = array[0].trim();
            let speakContent = array[1].trim();
            return [speakID, speakContent];
        }
        return ["0", line.trim()];
    }
    saveCurrentStory() {
        let currState = this._currentStory.state.toJson();
        //TODO
    }
    canContinue() {
        return this._currentStory.canContinue;
    }
    advanceStory() {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to AdvanceStory in InkWriter when no story has been created");
        }
        else if (this._currentStory.canContinue) {
            let text = this._currentStory.Continue().trim();
            if (text == "") {
                this.advanceStory();
                return;
            }
            let speakID;
            let speakContent;
            [speakID, speakContent] = this.extractSpeaker(text);
            let commandName = null;
            let args = null;
            if (speakContent.startsWith(InkWriter.COMMAND_PREFIX)) {
                commandName = this.parseCommandName(speakContent);
                args = this.parseCommandArgs(speakContent);
                if (commandName != null && commandName != "") {
                    if (this.handleCommand(commandName, args)) {
                        this.advanceStory();
                    }
                }
            }
            else {
                //OnContentReady
                _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastContentReady(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCONTENTREADY, speakContent, speakID, this._currentStory.currentTags, this._currentStory.currentChoices);
            }
        }
        else if (this._currentStory.currentChoices.length > 0) {
            //OnChoicesPresented
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastChoicesPresented(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONCHOICESPRESENTED, this._currentStory.currentChoices);
        }
        else {
            //OnStoryFinished
            _StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]).broadcastStoryFinished(_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].ONSTORYFINISHED);
        }
    }
    selectChoice(choiceIndex) {
        if (this._currentStory == null) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].warn("Trying to ChooseChoice in InkWriter when no story has begun");
            return;
        }
        this._currentStory.ChooseChoiceIndex(choiceIndex);
        this.advanceStory();
    }
    getVariable(variableName) {
        return this._currentStory.variablesState.GetVariableWithName(variableName);
    }
    setVariable(variableName, value) {
        this._currentStory.variablesState.$(variableName, value);
    }
}
InkWriter.DEBUG_STORY_ID = "DEBUG_STORY";
InkWriter.COMMAND_PREFIX = ">>>";
InkWriter.COMMAND_DELIMITER = ":";
InkWriter.COMMAND_ARG_DELIMITER = ',';


/***/ }),

/***/ "./src/framework/ink/StoryManager.ts":
/*!*******************************************!*\
  !*** ./src/framework/ink/StoryManager.ts ***!
  \*******************************************/
/*! exports provided: StoryManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryManager", function() { return StoryManager; });
/* harmony import */ var _common_ResManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _InkWriter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InkWriter */ "./src/framework/ink/InkWriter.ts");



class StoryManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super();
        this.storyAddress = "Story/TestStory.json";
    }
    get inkWriter() {
        return this._inkWriter;
    }
    async initialize() {
        if (this._inkWriter == null) {
            var json = (await _common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"].Instance(_common_ResManager__WEBPACK_IMPORTED_MODULE_0__["ResManager"]).loadTextAsset(this.storyAddress)).text;
            this._inkWriter = new _InkWriter__WEBPACK_IMPORTED_MODULE_2__["InkWriter"](json);
        }
    }
    beginStory(knotName) {
        this._inkWriter.beginStory(knotName);
    }
    canContinue() {
        return this._inkWriter.canContinue;
    }
    advanceStory() {
        this._inkWriter.advanceStory();
    }
    selectChoice(choice) {
        this._inkWriter.selectChoice(choice.index);
    }
    loadCurrent() {
        if (this._inkWriter != null)
            this._inkWriter.load();
    }
    getVariable(variableName) {
        return this._inkWriter.getVariable(variableName);
    }
    setVariable(variableName, value) {
        this.inkWriter.setVariable(variableName, value);
    }
}


/***/ }),

/***/ "./src/framework/ink/StoryMessageManager.ts":
/*!**************************************************!*\
  !*** ./src/framework/ink/StoryMessageManager.ts ***!
  \**************************************************/
/*! exports provided: StoryMessageManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StoryMessageManager", function() { return StoryMessageManager; });
/* harmony import */ var _common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");


class StoryMessageManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.storyMessage = new _common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.storyMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.storyMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.storyMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.storyMessage.clearup();
    }
    broadcastContentReady(msgCode, speakerContent, speakerId, currentTags, currentChoices) {
        this.storyMessage.broadcast(msgCode, speakerContent, speakerId, currentTags, currentChoices);
    }
    broadcastChoicesPresented(mesgCode, currentChoices) {
        this.storyMessage.broadcast(mesgCode, currentChoices);
    }
    broadcastStoryFinished(mesgCode) {
        this.storyMessage.broadcast(mesgCode);
    }
}
StoryMessageManager.ONCONTENTREADY = 1001;
StoryMessageManager.ONCHOICESPRESENTED = 1002;
StoryMessageManager.ONSTORYFINISHED = 1003;


/***/ }),

/***/ "./src/framework/logger/Logger.ts":
/*!****************************************!*\
  !*** ./src/framework/logger/Logger.ts ***!
  \****************************************/
/*! exports provided: Logger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");


var LogType;
(function (LogType) {
    LogType[LogType["Error"] = 0] = "Error";
    LogType[LogType["Assert"] = 1] = "Assert";
    LogType[LogType["Warning"] = 2] = "Warning";
    LogType[LogType["Log"] = 3] = "Log";
    LogType[LogType["Exception"] = 4] = "Exception";
})(LogType || (LogType = {}));
class Logger {
    static getPrintStack(type, showStack, ...args) {
        let message = '';
        for (let i = 0; i < args.length; i++) {
            const element = args[i];
            if (typeof element === 'object' && Logger.LOG_OBJECT_TO_JSON) {
                message += JSON.stringify(element);
            }
            else {
                message += element;
            }
            if (i < args.length - 1) {
                message += ' ';
            }
        }
        if (showStack || csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Application.isEditor) {
            var stacks = new Error().stack.split('\n');
            for (let i = 3; i < stacks.length; i++) {
                const line = stacks[i];
                message += '\n';
                message += line;
            }
        }
        if (!Logger.unity_log_target) {
            Logger.unity_log_target = new csharp__WEBPACK_IMPORTED_MODULE_0__["UnityEngine"].Object();
        }
        return message;
    }
    static log(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /**
     * Outputs a warning message to the Logger.
     * @param message  list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static warn(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Warning, true, args);
        console.warn(msg);
    }
    /**
     * Outputs an error message to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
     */
    static error(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Error, true, args);
        console.error(msg);
    }
    /** Outputs a stack trace to the Logger.
     * @param message A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
    */
    static trace(...args) {
        if (!_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].debug)
            return;
        let msg = Logger.getPrintStack(LogType.Log, true, args);
        console.log(msg);
    }
    /** Log JavaScript Objects as JSON format */
    static LOG_OBJECT_TO_JSON(...args) {
        return false;
    }
}
Logger.unity_log_target = null;


/***/ }),

/***/ "./src/framework/net/GameSession.ts":
/*!******************************************!*\
  !*** ./src/framework/net/GameSession.ts ***!
  \******************************************/
/*! exports provided: MsgPack, GameSession */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MsgPack", function() { return MsgPack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameSession", function() { return GameSession; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MessageParser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MessageParser */ "./src/framework/net/MessageParser.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");






class MsgPack {
    constructor() {
        this.retryTimes = 0;
    }
}
class GameSession extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.id = 0; //session ID
        this.reSendInterval = 10000; //10
        this.timeoutInterval = 5000; //5
        this.maxReSendTimes = 5; //
        this._rpcId = 1;
        this.requestCallback = new Map();
        this.listeners = new Map();
        //ID, 
        this._serverId = -1;
        this._serverType = 1;
    }
    get rpcId() {
        return ++this._rpcId;
    }
    //address-> ip:port
    connectChannel(address, connCaback) {
        this.channel = csharp__WEBPACK_IMPORTED_MODULE_3__["NiceTS"].TService.Instance.GetChannel();
        this.channel.errorCallback = (channel, code) => {
            if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_2__["NetErrorCode"].ERR_SocketConnSucc) {
                this.timeoutIimer = setInterval(() => {
                    this.checkTimeoutMsg();
                }, this.timeoutInterval);
            }
            connCaback(channel, code);
        };
        this.channel.readCallback = (buffer) => {
            this.onReceive(buffer);
        };
        this.channel.Connect(address);
        return this;
    }
    //
    listen(opcode, callback) {
        this.listeners.set(opcode, callback);
    }
    //protoubf
    // rpc_id[4] - opcode[2] - server_id[2] - server_type[1] - 
    send(opcode, rpcid, message, callBack) {
        //
        let rpcBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeInt(rpcid); //4
        let opcodeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(opcode); //2
        let serveridBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeShort(this._serverId); //2
        let servertypeBuf = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].encodeByte(this._serverType); //1
        let sendArray = new Uint8Array(4 + 2 + 2 + 1 + message.length);
        sendArray.set(rpcBuf);
        sendArray.set(opcodeBuf, 4);
        sendArray.set(serveridBuf, 4 + 2);
        sendArray.set(servertypeBuf, 4 + 2 + 2);
        sendArray.set(message, 4 + 2 + 2 + 1);
        if (callBack != null) {
            let msgPack = new MsgPack();
            msgPack.sendTime = new Date().getTime();
            msgPack.callback = callBack;
            msgPack.bytes = sendArray;
            this.requestCallback.set(rpcid, msgPack);
        }
        // for(let i in sendArray){
        //     Logger.log("TS -- send array: "+i);
        // }
        //Logger.log("send array: "+sendArray);
        this.channel.Send(sendArray);
    }
    reSend(bytes) {
        this.channel.Send(bytes);
    }
    onReceive(buffer) {
        let msgBuf = new Uint8Array(buffer);
        let rpcid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeInt(msgBuf.subarray(0, 4));
        let opcode = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(4, 6));
        let serverid = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeShort(msgBuf.subarray(6, 8));
        let servertype = _MessageParser__WEBPACK_IMPORTED_MODULE_4__["MessageParser"].decodeByte(msgBuf.subarray(8, 9));
        this._serverId = serverid;
        this._serverType = servertype;
        let msgBytes = msgBuf.subarray(9);
        try {
            let decodeMsg = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].decode(opcode, msgBytes);
            if (rpcid == undefined || !this.requestCallback.has(rpcid)) {
                //
                if (this.listeners.has(opcode)) {
                    let listen = this.listeners.get(opcode);
                    listen(decodeMsg.msgObj);
                }
            }
            else {
                let msgPack = this.requestCallback.get(rpcid);
                msgPack.callback(decodeMsg.msgObj);
                this.requestCallback.delete(rpcid);
            }
        }
        catch (e) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].error("parse msg error, opcode:" + opcode);
        }
    }
    checkTimeoutMsg() {
        let currTime = new Date().getTime();
        this.requestCallback.forEach((value, key) => {
            if (value.retryTimes >= this.maxReSendTimes) {
                //
                _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`Message resend too more, opcode:${key}, lastsend:${value.sendTime}`);
                this.requestCallback.delete(key);
            }
            else {
                if ((currTime - value.sendTime) >= this.reSendInterval) {
                    value.retryTimes++;
                    value.sendTime = currTime;
                    //
                    this.reSend(value.bytes);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].log(`resend message:, opcode:${key}, retry times:${value.retryTimes}`);
                }
            }
        });
    }
    disconnect() {
        clearInterval(this.timeoutIimer);
        this.channel.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/net/HttpManager.ts":
/*!******************************************!*\
  !*** ./src/framework/net/HttpManager.ts ***!
  \******************************************/
/*! exports provided: HttpManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HttpManager", function() { return HttpManager; });
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! puerts */ "puerts");
/* harmony import */ var puerts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(puerts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");




class HttpManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    constructor() {
        super();
    }
    async get(url) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Get(url);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Get error :${url} : ${ex}`);
            return null;
        }
    }
    async post(url, form) {
        try {
            let task = csharp__WEBPACK_IMPORTED_MODULE_0__["NiceTS"].HttpManager.Post(url, form);
            let txt = await Object(puerts__WEBPACK_IMPORTED_MODULE_1__["$promise"])(task);
            return txt;
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error(`Post error :${url} : ${ex}`);
            return null;
        }
    }
}


/***/ }),

/***/ "./src/framework/net/MessageParser.ts":
/*!********************************************!*\
  !*** ./src/framework/net/MessageParser.ts ***!
  \********************************************/
/*! exports provided: MessageParser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessageParser", function() { return MessageParser; });
class MessageParser {
    static encodeInt(n) {
        let buffer = new Uint8Array(4);
        buffer[0] = n >>> 24;
        buffer[1] = n >>> 16;
        buffer[2] = n >>> 8;
        buffer[3] = n & 0xff;
        return buffer;
    }
    static decodeInt(buffer) {
        let n = buffer[0] << 24 | buffer[1] << 16 | buffer[2] << 8 | buffer[3];
        return n;
    }
    static encodeShort(n) {
        let buffer = new Uint8Array(2);
        buffer[0] = n >>> 8;
        buffer[1] = n & 0xff;
        return buffer;
    }
    static decodeShort(buffer) {
        let n = buffer[0] << 8 | buffer[1];
        return n;
    }
    static encodeByte(n) {
        let buffer = new Uint8Array(1);
        buffer[0] = n & 0xff;
        return buffer;
    }
    static decodeByte(buffer) {
        let n = buffer[0];
        return n;
    }
}


/***/ }),

/***/ "./src/framework/net/NetErrorCode.ts":
/*!*******************************************!*\
  !*** ./src/framework/net/NetErrorCode.ts ***!
  \*******************************************/
/*! exports provided: NetErrorCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NetErrorCode", function() { return NetErrorCode; });
class NetErrorCode {
}
NetErrorCode.ERR_SocketConnSucc = 100000;
NetErrorCode.ERR_ConnectGateKeyError = 100006;
NetErrorCode.ERR_PeerDisconnect = 102008;
NetErrorCode.ERR_SocketCantSend = 102009;
NetErrorCode.ERR_SocketError = 102010;
NetErrorCode.ERR_SocketConnError = 102011;


/***/ }),

/***/ "./src/framework/net/SessionManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/net/SessionManager.ts ***!
  \*********************************************/
/*! exports provided: SessionManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SessionManager", function() { return SessionManager; });
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./NetErrorCode */ "./src/framework/net/NetErrorCode.ts");






class SessionManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_2__["Singleton"] {
    get realmRpcID() {
        return this.sessionReam.rpcId;
    }
    get gateRpcID() {
        return this.sessionGate.rpcId;
    }
    async connectRealmServer() {
        let promise = new Promise(resove => {
            this.sessionReam = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(_global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerIP + ":" + _global_GameConfig__WEBPACK_IMPORTED_MODULE_1__["GameConfig"].realmServerPort, (channel, code) => {
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionReam.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("login reamserver err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectRealmServer() {
        this.sessionReam.disconnect();
        this.sessionReam = null;
    }
    async sendRealmMsg(opcode, msg) {
        let rpcID = this.sessionReam.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionReam.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
    async connectGateServer(address) {
        let promise = new Promise(resove => {
            this.sessionGate = _GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]).connectChannel(address, (channel, code) => {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("login Gate Server: " + code);
                if (code == _NetErrorCode__WEBPACK_IMPORTED_MODULE_5__["NetErrorCode"].ERR_SocketConnSucc) {
                    this.sessionGate.id = channel.Id;
                    resove(true);
                }
                else {
                    resove(false);
                    _logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].error("gate server err, code: " + code + ",id:" + channel.Id);
                }
            });
        });
        return promise;
    }
    disconnectGateServer() {
        this.sessionGate.disconnect();
        this.sessionGate = null;
    }
    async sendGateMsg(opcode, msg) {
        let rpcID = this.sessionGate.rpcId;
        let promise = new Promise((resove) => {
            let buf = _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_0__["Opcode"].encode(opcode, msg);
            this.sessionGate.send(opcode, rpcID, buf, (response) => {
                resove(response);
            });
        });
        return promise;
    }
}


/***/ }),

/***/ "./src/framework/scene/BaseScene.ts":
/*!******************************************!*\
  !*** ./src/framework/scene/BaseScene.ts ***!
  \******************************************/
/*! exports provided: BaseScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseScene", function() { return BaseScene; });
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");

class BaseScene {
    constructor() {
        this.finishCount = 0;
        this.totalCount = 0;
        this.preloadPrefab = new Map();
        this.finishCount = 0;
    }
    addPreloadPrefab(address, instCount) {
        if (!this.preloadPrefab.has(address)) {
            this.preloadPrefab.set(address, instCount);
            return;
        }
        this.preloadPrefab.set(address, this.preloadPrefab.get(address) + instCount);
    }
    setSceneInstance(sceneInstance) {
        this.sceneInstance = sceneInstance;
    }
    async loadAssetsAsync() {
        this.totalCount = this.preloadPrefab.size;
        let premises = [];
        this.preloadPrefab.forEach((value, key) => {
            let premise = _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.preLoadGameObjectAsync(key, value, () => {
                this.finishCount++;
            });
            premises.push(premise);
        });
        await Promise.all(premises);
    }
    onDestroy() {
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].GameObjectPool.cleanup(true);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_0__["S"].ResManager.unloadScene(this.sceneInstance);
        this.preloadPrefab.clear();
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneDef.ts":
/*!*****************************************!*\
  !*** ./src/framework/scene/SceneDef.ts ***!
  \*****************************************/
/*! exports provided: SceneDef */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneDef", function() { return SceneDef; });
class SceneDef {
}
SceneDef.LoadingScene = "LoadingScene";
SceneDef.LaunchScene = "LaunchScene";
SceneDef.HomeScene = "HomeScene";
SceneDef.LoginScene = "LoginScene";
SceneDef.PveScene = "PveScene";


/***/ }),

/***/ "./src/framework/scene/SceneFactory.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneFactory.ts ***!
  \*********************************************/
/*! exports provided: SceneFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneFactory", function() { return SceneFactory; });
/* harmony import */ var _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/pve/scene/PveScene */ "./src/game/module/pve/scene/PveScene.ts");
/* harmony import */ var _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/scene/HomeScene */ "./src/game/module/home/scene/HomeScene.ts");
/* harmony import */ var _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../game/module/login/scene/LoginScene */ "./src/game/module/login/scene/LoginScene.ts");
/* harmony import */ var _SceneDef__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SceneDef */ "./src/framework/scene/SceneDef.ts");




class SceneFactory {
    static createScene(sceneName) {
        let scene = null;
        switch (sceneName) {
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].LoginScene:
                scene = new _game_module_login_scene_LoginScene__WEBPACK_IMPORTED_MODULE_2__["LoginScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].HomeScene:
                scene = new _game_module_home_scene_HomeScene__WEBPACK_IMPORTED_MODULE_1__["HomeScene"]();
                break;
            case _SceneDef__WEBPACK_IMPORTED_MODULE_3__["SceneDef"].PveScene:
                scene = new _game_module_pve_scene_PveScene__WEBPACK_IMPORTED_MODULE_0__["PveScene"]();
                break;
        }
        return scene;
    }
}


/***/ }),

/***/ "./src/framework/scene/SceneManager.ts":
/*!*********************************************!*\
  !*** ./src/framework/scene/SceneManager.ts ***!
  \*********************************************/
/*! exports provided: SceneManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneManager", function() { return SceneManager; });
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _SceneFactory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SceneFactory */ "./src/framework/scene/SceneFactory.ts");






class SceneManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_3__["Singleton"] {
    constructor() {
        super();
        this.currentScene = null;
    }
    async loadScene(scene) {
        try {
            //Loading
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
            //
            if (this.currentScene) {
                this.currentScene.onLeave();
                this.currentScene.onDestroy();
            }
            //
            let sceneInstance = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].ResManager.loadScene(scene);
            //
            this.currentScene = _SceneFactory__WEBPACK_IMPORTED_MODULE_5__["SceneFactory"].createScene(scene);
            this.currentScene.setSceneInstance(sceneInstance);
            this.currentScene.onEnter();
            //Timer
            let progressInterval = setInterval(() => {
                let progress = this.currentScene.finishCount / this.currentScene.totalCount;
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("progress:" + progress + " = " + this.currentScene.finishCount + " = " + this.currentScene.totalCount);
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIMessageManger.broadcast(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_1__["UIMessage"].MSG_SCENE_PROGRESS, progress * 100);
            }, 100);
            //
            await this.currentScene.loadAssetsAsync();
            //
            clearInterval(progressInterval);
            this.currentScene.onComplete();
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.closeLoading(_data_ui_common__WEBPACK_IMPORTED_MODULE_0__["commonUI"].UILoadingPage);
        }
        catch (ex) {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("load scene excep:" + ex);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIDefine.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIDefine.ts ***!
  \**************************************/
/*! exports provided: UITypeDef, UILayerDef, UIComDefs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UITypeDef", function() { return UITypeDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILayerDef", function() { return UILayerDef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIComDefs", function() { return UIComDefs; });
var UITypeDef;
(function (UITypeDef) {
    UITypeDef[UITypeDef["Unkown"] = 0] = "Unkown";
    UITypeDef[UITypeDef["Page"] = 1] = "Page";
    UITypeDef[UITypeDef["Window"] = 2] = "Window";
    UITypeDef[UITypeDef["Widget"] = 3] = "Widget";
    UITypeDef[UITypeDef["Loading"] = 4] = "Loading";
})(UITypeDef || (UITypeDef = {}));
class UILayerDef {
    static getDefaultLayer(type) {
        switch (type) {
            case UITypeDef.Loading: return this.Loading;
            case UITypeDef.Widget: return this.Widget;
            case UITypeDef.Window: return this.NormalWindow;
            case UITypeDef.Page: return this.Page;
            case UITypeDef.Unkown: return this.Unkown;
            default: return this.Unkown;
        }
    }
}
UILayerDef.Background = 0;
UILayerDef.Page = 1000;
UILayerDef.NormalWindow = 2000;
UILayerDef.TopWindow = 3000;
UILayerDef.Widget = 4000;
UILayerDef.Loading = 5000;
UILayerDef.Unkown = 9999;
class UIComDefs {
}
UIComDefs.BackBtn = "back_btn";
UIComDefs.WindowCloseBtn = "win_close_btn";


/***/ }),

/***/ "./src/framework/ui/UIFactory.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIFactory.ts ***!
  \***************************************/
/*! exports provided: UIFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIFactory", function() { return UIFactory; });
/* harmony import */ var _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../game/module/login/ui/UILoginPage */ "./src/game/module/login/ui/UILoginPage.ts");
/* harmony import */ var _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../game/module/home/ui/UIHomePage */ "./src/game/module/home/ui/UIHomePage.ts");
/* harmony import */ var _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./UILib/UILoading */ "./src/framework/ui/UILib/UILoading.ts");
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UILib/UIMsgBox */ "./src/framework/ui/UILib/UIMsgBox.ts");
/* harmony import */ var _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../game/module/login/ui/UISelServerWin */ "./src/game/module/login/ui/UISelServerWin.ts");
/* harmony import */ var _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../game/module/home/ui/UIShopPage */ "./src/game/module/home/ui/UIShopPage.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../game/module/story/UIStoryWin */ "./src/game/module/story/UIStoryWin.ts");
/* harmony import */ var _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../data/ui/combat */ "./src/data/ui/combat.ts");
/* harmony import */ var _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../game/module/guide/UIGuideWin */ "./src/game/module/guide/UIGuideWin.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");














const CS = __webpack_require__(/*! csharp */ "csharp");
class UIFactory {
    static createUI(pkg, name) {
        _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].log(`create UI: ${pkg}:${name}`);
        let comp = CS.FairyGUI.UIPackage.CreateObject(pkg, name).asCom;
        let ui = this.uiCache.get(name);
        if (!ui) {
            switch (pkg) {
                case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].PackageName:
                    switch (name) {
                        //common
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUINoticeWin:
                            ui = new _UILib_UIMsgBox__WEBPACK_IMPORTED_MODULE_6__["UIMsgBox"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UILoadingPage:
                            ui = new _UILib_UILoading__WEBPACK_IMPORTED_MODULE_2__["UILoading"]();
                            break;
                        case _data_ui_common__WEBPACK_IMPORTED_MODULE_4__["commonUI"].UIUIGuideWin:
                            ui = new _game_module_guide_UIGuideWin__WEBPACK_IMPORTED_MODULE_12__["UIGuideWin"]();
                    }
                    break;
                case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName:
                    switch (name) {
                        //login
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UILoginPage:
                            ui = new _game_module_login_ui_UILoginPage__WEBPACK_IMPORTED_MODULE_0__["UILoginPage"]();
                            break;
                        case _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin:
                            ui = new _game_module_login_ui_UISelServerWin__WEBPACK_IMPORTED_MODULE_7__["UISelServerWin"]();
                            break;
                    }
                    break;
                case _data_ui_combat__WEBPACK_IMPORTED_MODULE_11__["combatUI"].PackageName:
                    break;
                case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].PackageName:
                    switch (name) {
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIHomePage:
                            ui = new _game_module_home_ui_UIHomePage__WEBPACK_IMPORTED_MODULE_1__["UIHomePage"]();
                            break;
                        case _data_ui_home__WEBPACK_IMPORTED_MODULE_5__["homeUI"].UIShopPage:
                            ui = new _game_module_home_ui_UIShopPage__WEBPACK_IMPORTED_MODULE_8__["UIShopPage"]();
                            break;
                    }
                    break;
                case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].PackageName:
                    switch (name) {
                        case _data_ui_story__WEBPACK_IMPORTED_MODULE_9__["storyUI"].UIStoryWin:
                            ui = new _game_module_story_UIStoryWin__WEBPACK_IMPORTED_MODULE_10__["UIStoryWin"]();
                            break;
                    }
                    break;
            }
            this.uiCache.set(name, ui);
        }
        if (ui != null) {
            ui.fui = comp;
            ui.name = name;
            ui.pkgName = pkg;
            //FairyGUI
            ui.bindAll(ui);
            ui.awake();
        }
        else {
            _logger_Logger__WEBPACK_IMPORTED_MODULE_13__["Logger"].error(`not create ui: ${pkg}-${name}`);
        }
        return ui;
    }
}
UIFactory.uiCache = new Map();


/***/ }),

/***/ "./src/framework/ui/UILib/UILoading.ts":
/*!*********************************************!*\
  !*** ./src/framework/ui/UILib/UILoading.ts ***!
  \*********************************************/
/*! exports provided: UILoading */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoading", function() { return UILoading; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../game/event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};





class UILoading extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    onAwake() {
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Loading;
    }
    onShow(arg) {
        this.progressLoading.value = 0;
        this.progressLoading.visible = true;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.addListener(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS, this, (progress) => {
            this.progressLoading.TweenValue(progress, 0.1);
        });
    }
    onClose(arg) {
        this.progressLoading.visible = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_4__["S"].UIMessageManger.removeListenerByCode(_game_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SCENE_PROGRESS);
    }
}
__decorate([
    Object(_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_2__["binder"])("loading_pregress")
], UILoading.prototype, "progressLoading", void 0);


/***/ }),

/***/ "./src/framework/ui/UILib/UIMsgBox.ts":
/*!********************************************!*\
  !*** ./src/framework/ui/UILib/UIMsgBox.ts ***!
  \********************************************/
/*! exports provided: UIMsgBoxArg, UIMsgBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBoxArg", function() { return UIMsgBoxArg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMsgBox", function() { return UIMsgBox; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


// 
class UIMsgBoxArg {
    constructor() {
        this.title = "";
        this.content = "";
        this.btnText = ""; //"||"
    }
}
class UIMsgBox extends _UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.bindAll(this);
    }
    onShow(arg) {
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("msgTxt")
], UIMsgBox.prototype, "m_txt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("okBtn")
], UIMsgBox.prototype, "m_okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("cancelBtn")
], UIMsgBox.prototype, "m_cancelBtn", void 0);


/***/ }),

/***/ "./src/framework/ui/UIManager.ts":
/*!***************************************!*\
  !*** ./src/framework/ui/UIManager.ts ***!
  \***************************************/
/*! exports provided: UIPageTrack, UIManager */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPageTrack", function() { return UIPageTrack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIManager", function() { return UIManager; });
/* harmony import */ var _common_Singleton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../common/Singleton */ "./src/framework/common/Singleton.ts");
/* harmony import */ var _UIFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIFactory */ "./src/framework/ui/UIFactory.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _logger_Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../logger/Logger */ "./src/framework/logger/Logger.ts");





class UIPageTrack {
}
class UIManager extends _common_Singleton__WEBPACK_IMPORTED_MODULE_0__["Singleton"] {
    constructor() {
        super();
        this.m_pageTrackStack = new Array();
        this.m_listLoadedPanel = new Array();
    }
    distroyAllLoadedPanel() {
        for (let i = this.m_listLoadedPanel.length - 1; i >= 0; i--) {
            let panel = this.m_listLoadedPanel[i];
            if (panel.isOpen) {
                panel.close();
            }
            //
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.releaseFairyGUIPackage(panel.pkgName);
            panel.dispose();
        }
        this.m_listLoadedPanel.length = 0;
    }
    clean() {
        this.distroyAllLoadedPanel();
        this.m_pageTrackStack.length = 0;
        this.m_listLoadedPanel.length = 0;
    }
    async open(pkg, name, arg) {
        let ui = this.getUI(name);
        if (ui == null) {
            // package
            await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].ResManager.loadFairyGUIPackage(pkg);
            ui = _UIFactory__WEBPACK_IMPORTED_MODULE_1__["UIFactory"].createUI(pkg, name);
            this.m_listLoadedPanel.push(ui);
        }
        if (ui != null) {
            // ###  ui as any 
            ui._internalOpen(arg);
        }
        return ui;
    }
    getUI(name) {
        for (const panel of this.m_listLoadedPanel) {
            if (panel.name == name) {
                _logger_Logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].log("find panel in cache: " + name);
                return panel;
            }
        }
        return null;
    }
    //,,
    openPageInScene(pkg, page, arg) {
        this.openPageWorker(pkg, page, arg);
    }
    //==========================================================UILoading
    //Loading
    openLoading(pkg, name, arg) {
        this.openPageInScene(pkg, name, arg);
    }
    //Loading
    closeLoading(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================Page
    openPageWorker(pkg, page, arg) {
        this.m_currentPage = new UIPageTrack();
        this.m_currentPage.pkg = pkg;
        this.m_currentPage.name = page;
        this.m_currentPage.arg = arg;
        this.distroyAllLoadedPanel();
        this.open(pkg, page, arg);
    }
    //, ,Widiget
    openPage(pkg, name, arg) {
        if (this.m_currentPage != undefined && this.m_currentPage.name != name) {
            this.m_pageTrackStack.push(this.m_currentPage);
        }
        this.openPageWorker(pkg, name, arg);
    }
    //
    goBackPage() {
        if (this.m_pageTrackStack.length > 0) {
            let track = this.m_pageTrackStack.pop();
            this.openPageWorker(track.pkg, track.name, track.arg);
        }
        else {
            this.enterMainPage();
        }
    }
    //
    enterMainPage() {
        this.m_pageTrackStack.length = 0;
        this.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_2__["homeUI"].UIHomePage, null);
    }
    //==========================================================UIWindow
    //
    async openWindow(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //
    closeWindow(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
    //==========================================================UIWidget
    //Widiget
    async openWidget(pkg, name, arg) {
        let ui = await this.open(pkg, name, arg);
        return ui;
    }
    //uWidiget
    closeWidget(name, arg) {
        let ui = this.getUI(name);
        if (ui != null) {
            ui.close(arg);
        }
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPage.ts":
/*!************************************!*\
  !*** ./src/framework/ui/UIPage.ts ***!
  \************************************/
/*! exports provided: UIPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPage", function() { return UIPage; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");



class UIPage extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Page;
    }
    onAwake() {
        this.m_btnGoBack = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].BackBtn);
        if (this.m_btnGoBack != undefined) {
            this.m_btnGoBack.onClick.Add(() => {
                this.onBtnGoBack();
            });
        }
    }
    onShow(vo) {
    }
    onClose(arg) {
    }
    onBtnGoBack() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.goBackPage();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIPanel.ts":
/*!*************************************!*\
  !*** ./src/framework/ui/UIPanel.ts ***!
  \*************************************/
/*! exports provided: UIPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIPanel", function() { return UIPanel; });
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_1__);


class UIPanel {
    constructor() {
        this.m_layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].Unkown;
    }
    set name(v) {
        this._name = v;
    }
    get name() {
        return this._name;
    }
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UITypeDef"].Unkown;
    }
    get layer() {
        return this.m_layer;
    }
    set layer(v) {
        this.m_layer = v;
    }
    get isOpen() {
        return this.fui.visible;
    }
    onUpdate() { }
    awake() {
        this.onAwake();
    }
    //FairyGUI
    bindAll(target) {
        for (let k in target["binders"]) {
            let fguiName = this["binders"][k];
            this[k] = this.fui.GetChild(fguiName);
        }
    }
    update() {
        this.onUpdate();
    }
    /**
     * UI Manager 
     * @param arg
     */
    _internalOpen(arg) {
        this.layer = _UIDefine__WEBPACK_IMPORTED_MODULE_0__["UILayerDef"].getDefaultLayer(this.uiType);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.AddChild(this.fui);
        this.onShow(arg);
    }
    close(arg = null) {
        this.onClose(arg);
        csharp__WEBPACK_IMPORTED_MODULE_1__["FairyGUI"].GRoot.inst.RemoveChild(this.fui);
    }
    dispose() {
        this.fui.Dispose();
    }
}


/***/ }),

/***/ "./src/framework/ui/UIWindow.ts":
/*!**************************************!*\
  !*** ./src/framework/ui/UIWindow.ts ***!
  \**************************************/
/*! exports provided: UIWindow */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIWindow", function() { return UIWindow; });
/* harmony import */ var _UIPanel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./UIPanel */ "./src/framework/ui/UIPanel.ts");
/* harmony import */ var _UIDefine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UIDefine */ "./src/framework/ui/UIDefine.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);



class UIWindow extends _UIPanel__WEBPACK_IMPORTED_MODULE_0__["UIPanel"] {
    get uiType() {
        return _UIDefine__WEBPACK_IMPORTED_MODULE_1__["UITypeDef"].Window;
    }
    onAwake() {
        this.m_btnClose = this.fui.GetChild(_UIDefine__WEBPACK_IMPORTED_MODULE_1__["UIComDefs"].WindowCloseBtn);
    }
    onShow(arg) {
        this.fui.x = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.width / 2 - this.fui.width / 2;
        this.fui.y = csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GRoot.inst.height / 2 - this.fui.height / 2;
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Add(this.onBtnClose);
        }
    }
    onClose(arg) {
        if (this.m_btnClose != undefined) {
            this.m_btnClose.onClick.Remove(this.onBtnClose);
        }
    }
    onBtnClose() {
        this.close(0);
    }
}


/***/ }),

/***/ "./src/game/api/LoginAPI.ts":
/*!**********************************!*\
  !*** ./src/game/api/LoginAPI.ts ***!
  \**********************************/
/*! exports provided: LoginAPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginAPI", function() { return LoginAPI; });
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../data/pb/gen/pb */ "./src/data/pb/gen/pb.js");
/* harmony import */ var _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../global/GameConfig */ "./src/global/GameConfig.ts");




class LoginAPI {
    static async benchmarkTest() {
        for (let i = 1; i < 2; i++) {
            let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2GS_Test.create();
            msg.testID = i;
            msg.testName = "benchmark test";
            let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2GS_Test, msg);
            let test = response;
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].log("code: " + test.Error + ",msg:" + test.Message + ",res:" + test.testResponse);
        }
    }
    static async loginRealmServer(account, password) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2R_Login.create();
        msg.Account = account;
        msg.Password = password;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendRealmMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2R_Login, msg);
        return response;
    }
    static async loginGateServer(gateId, gateKey) {
        let msg = _data_pb_gen_pb__WEBPACK_IMPORTED_MODULE_0__["nice_ts"].C2G_LoginGate.create();
        msg.GateId = gateId;
        msg.Key = gateKey;
        let response = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_3__["S"].SessionManager.sendGateMsg(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_1__["Opcode"].MSG_C2G_LoginGate, msg);
        return response;
    }
}


/***/ }),

/***/ "./src/game/event/UIMessage.ts":
/*!*************************************!*\
  !*** ./src/game/event/UIMessage.ts ***!
  \*************************************/
/*! exports provided: UIMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessage", function() { return UIMessage; });
class UIMessage {
}
UIMessage.MSG_SELECT_SERVER = 1000;
UIMessage.MSG_SCENE_PROGRESS = 1001;


/***/ }),

/***/ "./src/game/event/UIMessageManager.ts":
/*!********************************************!*\
  !*** ./src/game/event/UIMessageManager.ts ***!
  \********************************************/
/*! exports provided: UIMessageManger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIMessageManger", function() { return UIMessageManger; });
/* harmony import */ var _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/common/Messenger */ "./src/framework/common/Messenger.ts");
/* harmony import */ var _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../framework/common/Singleton */ "./src/framework/common/Singleton.ts");


class UIMessageManger extends _framework_common_Singleton__WEBPACK_IMPORTED_MODULE_1__["Singleton"] {
    constructor() {
        super(...arguments);
        this.uiMessage = new _framework_common_Messenger__WEBPACK_IMPORTED_MODULE_0__["Messenger"]();
    }
    addListener(msgCode, obj, listener) {
        this.uiMessage.addListener(msgCode, obj, listener);
    }
    removeListener(msgCode, listener) {
        this.uiMessage.removeListener(msgCode, listener);
    }
    removeListenerByCode(msgCode) {
        this.uiMessage.removeListenerByType(msgCode);
    }
    clearup() {
        this.uiMessage.clearup();
    }
    broadcast(msgCode, params) {
        this.uiMessage.broadcast(msgCode, params);
    }
}


/***/ }),

/***/ "./src/game/module/guide/UIGuideWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/guide/UIGuideWin.ts ***!
  \*********************************************/
/*! exports provided: UIGuideWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIGuideWin", function() { return UIGuideWin; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


class UIGuideWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    onAwake() {
        super.onAwake();
        this.m_focus.alpha = 0.2;
        this.m_focus.SetXY(520, 550);
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("focus")
], UIGuideWin.prototype, "m_focus", void 0);


/***/ }),

/***/ "./src/game/module/home/scene/HomeScene.ts":
/*!*************************************************!*\
  !*** ./src/game/module/home/scene/HomeScene.ts ***!
  \*************************************************/
/*! exports provided: HomeScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HomeScene", function() { return HomeScene; });
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../vo/VoHome */ "./src/game/module/home/vo/VoHome.ts");




class HomeScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
        let vo = new _vo_VoHome__WEBPACK_IMPORTED_MODULE_3__["VoHome"]();
        vo.name = "Justin";
        vo.hp = 1200;
        vo.mp = 3300;
        vo.money = 666;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_0__["homeUI"].UIHomePage, vo);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/home/ui/UIHomePage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIHomePage.ts ***!
  \***********************************************/
/*! exports provided: UIHomePage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIHomePage", function() { return UIHomePage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _data_ui_home__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/home */ "./src/data/ui/home.ts");
/* harmony import */ var _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../api/LoginAPI */ "./src/game/api/LoginAPI.ts");
/* harmony import */ var _data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../data/pb/Opcode */ "./src/data/pb/Opcode.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};








class UIHomePage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
        this.m_chatBtn.onClick.Add(() => {
            this.onchatBtn();
        });
        this.m_bagBtn.onClick.Add(() => {
            this.onbagBtn();
        });
        this.m_shopBtn.onClick.Add(() => {
            this.onshopBtn();
        });
        this.m_levelBtn.onClick.Add(() => {
            this.onlevelBtn();
        });
    }
    onShow(vo) {
        super.onShow(vo);
        this.m_nameLbl.text = vo.name;
        this.m_mpLbl.text = vo.mp.toString();
        this.m_hpLbl.text = vo.hp.toString();
        this.m_moneyLbl.text = vo.money.toString();
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].GameSession.listen(_data_pb_Opcode__WEBPACK_IMPORTED_MODULE_5__["Opcode"].MSG_GS2C_Test, function (msg) {
            _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("" + msg.testResponse);
        });
    }
    onClose(arg) {
        super.onClose(arg);
    }
    onchatBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_2__["commonUI"].UIUINoticeWin, null);
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on chat...");
    }
    onbagBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on bag ..");
        //benchmark test
        _api_LoginAPI__WEBPACK_IMPORTED_MODULE_4__["LoginAPI"].benchmarkTest();
    }
    onshopBtn() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_6__["S"].UIManager.openPage(_data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].PackageName, _data_ui_home__WEBPACK_IMPORTED_MODULE_3__["homeUI"].UIShopPage);
    }
    onlevelBtn() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_7__["Logger"].log("on level...");
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("chatBtn")
], UIHomePage.prototype, "m_chatBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("bagBtn")
], UIHomePage.prototype, "m_bagBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("shopBtn")
], UIHomePage.prototype, "m_shopBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("levelBtn")
], UIHomePage.prototype, "m_levelBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("nameTxt")
], UIHomePage.prototype, "m_nameLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hpTxt")
], UIHomePage.prototype, "m_hpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("mpTxt")
], UIHomePage.prototype, "m_mpLbl", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("moneyTxt")
], UIHomePage.prototype, "m_moneyLbl", void 0);


/***/ }),

/***/ "./src/game/module/home/ui/UIShopPage.ts":
/*!***********************************************!*\
  !*** ./src/game/module/home/ui/UIShopPage.ts ***!
  \***********************************************/
/*! exports provided: UIShopPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIShopPage", function() { return UIShopPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");

class UIShopPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    onAwake() {
        super.onAwake();
    }
    onShow(vo) {
        super.onShow(vo);
    }
    onClose(arg) {
        super.onClose(arg);
    }
}


/***/ }),

/***/ "./src/game/module/home/vo/VoHome.ts":
/*!*******************************************!*\
  !*** ./src/game/module/home/vo/VoHome.ts ***!
  \*******************************************/
/*! exports provided: VoHome */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoHome", function() { return VoHome; });
class VoHome {
}


/***/ }),

/***/ "./src/game/module/login/scene/LoginScene.ts":
/*!***************************************************!*\
  !*** ./src/game/module/login/scene/LoginScene.ts ***!
  \***************************************************/
/*! exports provided: LoginScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoginScene", function() { return LoginScene; });
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");



class LoginScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_1__["BaseScene"] {
    onEnter() {
    }
    onComplete() {
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIManager.openPageInScene(_data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_0__["loginUI"].UILoginPage, null);
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/login/ui/UILoginPage.ts":
/*!*************************************************!*\
  !*** ./src/game/module/login/ui/UILoginPage.ts ***!
  \*************************************************/
/*! exports provided: UILoginPage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UILoginPage", function() { return UILoginPage; });
/* harmony import */ var _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/ui/UIPage */ "./src/framework/ui/UIPage.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csharp */ "csharp");
/* harmony import */ var csharp__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(csharp__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_ui_login__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../data/ui/login */ "./src/data/ui/login.ts");
/* harmony import */ var _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../vo/VoServer */ "./src/game/module/login/vo/VoServer.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
/* harmony import */ var _framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../framework/scene/SceneDef */ "./src/framework/scene/SceneDef.ts");
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _data_ui_common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../../data/ui/common */ "./src/data/ui/common.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};











class UILoginPage extends _framework_ui_UIPage__WEBPACK_IMPORTED_MODULE_0__["UIPage"] {
    constructor() {
        super(...arguments);
        this._effectGo = null;
    }
    async onAwake() {
        super.onAwake();
        this.m_loginBtn.onClick.Add(() => {
            this.onLoginClick();
        });
        this.m_storyBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].PackageName, _data_ui_story__WEBPACK_IMPORTED_MODULE_7__["storyUI"].UIStoryWin, null);
        });
        this.m_newGuideBtn.onClick.Add(() => {
            _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].PackageName, _data_ui_common__WEBPACK_IMPORTED_MODULE_8__["commonUI"].UIUIGuideWin, null);
        });
        this.m_selserverBtn.onClick.Add(() => {
            this.openSelServerWin();
        });
        // let connected = await S.SessionManager.connectRealmServer();
        // this.m_loginBtn.enabled = connected;
        // Logger.log("connect ream server: "+connected)
    }
    onSelectServer(serverItem) {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(" server selected: " + serverItem.serverName);
        this.m_selserverBtn.text = serverItem.serverName;
    }
    async onShow(vo) {
        super.onShow(vo);
        //
        this._effectGo = await _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.loadPrefab("Effect/Prefab/UI/ef_ui_pet_rank_yellow_test.prefab");
        let inst = csharp__WEBPACK_IMPORTED_MODULE_2__["UnityEngine"].GameObject.Instantiate(this._effectGo);
        let wrapper = new csharp__WEBPACK_IMPORTED_MODULE_2__["FairyGUI"].GoWrapper(inst);
        this.m_holder.SetNativeObject(wrapper);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.addListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this, this.onSelectServer);
    }
    onClose(arg) {
        super.onClose(arg);
        //
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].ResManager.releaseAddressGO(this._effectGo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIMessageManger.removeListener(_event_UIMessage__WEBPACK_IMPORTED_MODULE_5__["UIMessage"].MSG_SELECT_SERVER, this.onSelectServer);
    }
    openSelServerWin() {
        // 
        let voServer = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServer"]();
        for (let i = 1; i < 10; i++) {
            voServer.areaMap.set(i, "" + i);
            voServer.serverMap.set(i, new Array());
            for (let j = 1; j < 20; j++) {
                let voServerItem = new _vo_VoServer__WEBPACK_IMPORTED_MODULE_4__["VoServerItem"]();
                voServerItem.areaId = i;
                voServerItem.serverId = j;
                voServerItem.serverName = "" + i + ":" + j;
                voServerItem.serverStatus = Math.floor(Math.random() * 3 + 1);
                voServer.serverMap.get(i).push(voServerItem);
            }
        }
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].UIManager.openWindow(_data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].PackageName, _data_ui_login__WEBPACK_IMPORTED_MODULE_3__["loginUI"].UISelServerWin, voServer);
    }
    async onLoginClick() {
        let account = this.m_account.text;
        let password = this.m_password.text;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_10__["Logger"].log(`account:${account} - password: ${password}`);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_9__["S"].SceneManager.loadScene(_framework_scene_SceneDef__WEBPACK_IMPORTED_MODULE_6__["SceneDef"].HomeScene);
        // if(account != "" && password != ""){
        //     let msg = await LoginAPI.loginRealmServer(account, password)
        //     this.gateId = msg.GateId;
        //     this.gateKey = msg.Key;
        //     Logger.log("login ream succ, gate addr:"+msg.Address + ",key:"+msg.Key);
        //     S.SessionManager.disconnectRealmServer();
        //     //
        //     let connected = await S.SessionManager.connectGateServer(msg.Address);
        //     if(connected){
        //         Logger.log("connect gate succ")
        //         let msg = await LoginAPI.loginGateServer( this.gateId, this.gateKey)
        //         let playerID = msg.PlayerId;
        //         Logger.log("login gate response.." +playerID);
        //         S.SceneManager.loadScene(SceneDef.HomeScene);
        //     }else{
        //     Logger.log("connect gate err ")
        //     }
        //  }
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("account")
], UILoginPage.prototype, "m_account", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("password")
], UILoginPage.prototype, "m_password", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("selserverBtn")
], UILoginPage.prototype, "m_selserverBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("loginBtn")
], UILoginPage.prototype, "m_loginBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("storyBtn")
], UILoginPage.prototype, "m_storyBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("newGuideBtn")
], UILoginPage.prototype, "m_newGuideBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("hold")
], UILoginPage.prototype, "m_holder", void 0);


/***/ }),

/***/ "./src/game/module/login/ui/UISelServerWin.ts":
/*!****************************************************!*\
  !*** ./src/game/module/login/ui/UISelServerWin.ts ***!
  \****************************************************/
/*! exports provided: UISelServerWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UISelServerWin", function() { return UISelServerWin; });
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../global/GameConfig */ "./src/global/GameConfig.ts");
/* harmony import */ var _event_UIMessage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../event/UIMessage */ "./src/game/event/UIMessage.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




class UISelServerWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_1__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.clickAreaIndex = 0;
        this.clickServerIndex = 0;
    }
    onAwake() {
        super.onAwake();
        this.backBtn.onClick.Add(() => {
            this.close();
        });
        this.okBtn.onClick.Add(() => {
            this.onSelectServer();
        });
        this.areaList.onClickItem.Add((event) => {
            this.clickAreaIndex = this.areaList.GetChildIndex(event.data);
            this.serverList.numItems = this.voServer.serverMap.get(this.clickAreaIndex + 1).length;
            this.serverList.RefreshVirtualList();
        });
        this.serverList.onClickItem.Add((event) => {
            this.clickServerIndex = this.serverList.GetChildIndex(event.data);
            this.title.text = "" + this.clickServerIndex;
        });
    }
    onSelectServer() {
        let selItem = this.voServer.serverMap.get(this.clickAreaIndex + 1)[this.clickServerIndex];
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_2__["S"].UIMessageManger.broadcast(_event_UIMessage__WEBPACK_IMPORTED_MODULE_3__["UIMessage"].MSG_SELECT_SERVER, selItem);
        this.close();
    }
    onShow(vo) {
        super.onShow(vo);
        this.voServer = vo;
        this.areaList.SetVirtual();
        this.areaList.itemRenderer = (index, obj) => {
            this.renderAreaListItem(index, obj);
        };
        this.areaList.numItems = vo.areaMap.size;
        this.serverList.SetVirtual();
        this.serverList.itemRenderer = (index, obj) => {
            this.renderServerListItem(index, obj);
        };
        this.serverList.numItems = vo.serverMap.get(this.clickAreaIndex + 1).length;
    }
    renderAreaListItem(index, obj) {
        let areaBtn = obj.asButton;
        areaBtn.text = this.voServer.areaMap.get(index + 1);
    }
    renderServerListItem(index, obj) {
        let serverBtn = obj.asButton;
        serverBtn.text = this.voServer.serverMap.get(this.clickAreaIndex + 1)[index].serverName;
        //serverBtn.icon = FairyGUI.UIPackage.
    }
    onClose(arg) {
        super.onClose(arg);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("areaList")
], UISelServerWin.prototype, "areaList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("serverList")
], UISelServerWin.prototype, "serverList", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("backBtn")
], UISelServerWin.prototype, "backBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("okBtn")
], UISelServerWin.prototype, "okBtn", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_0__["binder"])("title")
], UISelServerWin.prototype, "title", void 0);


/***/ }),

/***/ "./src/game/module/login/vo/VoServer.ts":
/*!**********************************************!*\
  !*** ./src/game/module/login/vo/VoServer.ts ***!
  \**********************************************/
/*! exports provided: VoServerItem, VoServer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServerItem", function() { return VoServerItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoServer", function() { return VoServer; });
class VoServerItem {
}
class VoServer {
    constructor() {
        this.serverMap = new Map();
        this.areaMap = new Map();
    }
}


/***/ }),

/***/ "./src/game/module/pve/scene/PveScene.ts":
/*!***********************************************!*\
  !*** ./src/game/module/pve/scene/PveScene.ts ***!
  \***********************************************/
/*! exports provided: PveScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PveScene", function() { return PveScene; });
/* harmony import */ var _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/scene/BaseScene */ "./src/framework/scene/BaseScene.ts");

class PveScene extends _framework_scene_BaseScene__WEBPACK_IMPORTED_MODULE_0__["BaseScene"] {
    constructor() {
        super();
    }
    onEnter() {
    }
    onComplete() {
    }
    onLeave() {
    }
}


/***/ }),

/***/ "./src/game/module/story/UIStoryWin.ts":
/*!*********************************************!*\
  !*** ./src/game/module/story/UIStoryWin.ts ***!
  \*********************************************/
/*! exports provided: UIStoryWin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UIStoryWin", function() { return UIStoryWin; });
/* harmony import */ var _data_ui_story__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../data/ui/story */ "./src/data/ui/story.ts");
/* harmony import */ var _framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/common/NiceDecorator */ "./src/framework/common/NiceDecorator.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../framework/logger/Logger */ "./src/framework/logger/Logger.ts");
/* harmony import */ var _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../framework/ui/UIWindow */ "./src/framework/ui/UIWindow.ts");
/* harmony import */ var _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../global/GameConfig */ "./src/global/GameConfig.ts");
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






class UIStoryWin extends _framework_ui_UIWindow__WEBPACK_IMPORTED_MODULE_4__["UIWindow"] {
    constructor() {
        super(...arguments);
        this.shouldContineStory = false;
        this.optionsMap = new Map();
    }
    onAwake() {
        super.onAwake();
        this.m_btnList.itemRenderer = (index, obj) => {
            this.renderBtnList(index, obj);
        };
        this.m_btnList.onClickItem.Add((event) => {
            let clickId = this.m_btnList.GetChildIndex(event.data);
            if (this.shouldContineStory) {
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.advanceStory();
            }
            else {
                this.optionsMap.clear();
                _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.selectChoice(this.allChoices[clickId]);
            }
        });
    }
    onShow(vo) {
        super.onShow(vo);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.addListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this, this.OnStoryFinished);
        this.optionsMap.clear();
        this.shouldContineStory = false;
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.beginStory("story2");
    }
    OnContentReady(speakerContent, speakerId, currentTags, currentChoices) {
        this.m_speakerTxt.text = speakerContent;
        if (_global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryManager.canContinue) {
            this.shouldContineStory = true;
            this.m_btnList.numItems = 1;
        }
        if (currentChoices.length > 0) {
            this.allChoices = currentChoices;
            this.shouldContineStory = false;
            let len = currentChoices.length;
            for (let i = 0; i < len; i++) {
                this.optionsMap.set(i, currentChoices[i].text);
            }
            this.m_btnList.numItems = len;
        }
    }
    renderBtnList(index, obj) {
        let continueBtn = obj.asButton;
        if (this.optionsMap.size > 0) {
            continueBtn.text = this.optionsMap.get(index);
        }
        else {
            continueBtn.text = "";
        }
    }
    OnChoicesPresented(currentChoices) {
        this.shouldContineStory = false;
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("....OnChoicesPresented......");
    }
    OnStoryFinished() {
        _framework_logger_Logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].log("Story Finished");
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].UIManager.closeWindow(_data_ui_story__WEBPACK_IMPORTED_MODULE_0__["storyUI"].UIStoryWin, null);
    }
    onClose(arg) {
        super.onClose(arg);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCONTENTREADY, this.OnContentReady);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONCHOICESPRESENTED, this.OnChoicesPresented);
        _global_GameConfig__WEBPACK_IMPORTED_MODULE_5__["S"].StoryMessageManager.removeListener(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_2__["StoryMessageManager"].ONSTORYFINISHED, this.OnStoryFinished);
    }
}
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("speakerTxt")
], UIStoryWin.prototype, "m_speakerTxt", void 0);
__decorate([
    Object(_framework_common_NiceDecorator__WEBPACK_IMPORTED_MODULE_1__["binder"])("btnList")
], UIStoryWin.prototype, "m_btnList", void 0);


/***/ }),

/***/ "./src/global/GameConfig.ts":
/*!**********************************!*\
  !*** ./src/global/GameConfig.ts ***!
  \**********************************/
/*! exports provided: GameConfig, S */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GameConfig", function() { return GameConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return S; });
/* harmony import */ var _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/common/GameObjectPool */ "./src/framework/common/GameObjectPool.ts");
/* harmony import */ var _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/common/ResManager */ "./src/framework/common/ResManager.ts");
/* harmony import */ var _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/ink/StoryManager */ "./src/framework/ink/StoryManager.ts");
/* harmony import */ var _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../framework/ink/StoryMessageManager */ "./src/framework/ink/StoryMessageManager.ts");
/* harmony import */ var _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../framework/net/GameSession */ "./src/framework/net/GameSession.ts");
/* harmony import */ var _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../framework/net/HttpManager */ "./src/framework/net/HttpManager.ts");
/* harmony import */ var _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../framework/net/SessionManager */ "./src/framework/net/SessionManager.ts");
/* harmony import */ var _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../framework/scene/SceneManager */ "./src/framework/scene/SceneManager.ts");
/* harmony import */ var _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../framework/ui/UIManager */ "./src/framework/ui/UIManager.ts");
/* harmony import */ var _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../game/event/UIMessageManager */ "./src/game/event/UIMessageManager.ts");










class GameConfig {
}
GameConfig.debug = true;
GameConfig.realmServerIP = "127.0.0.1";
GameConfig.realmServerPort = 9001;
class S {
}
S.UIManager = _framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"].Instance(_framework_ui_UIManager__WEBPACK_IMPORTED_MODULE_8__["UIManager"]);
S.UIMessageManger = _game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"].Instance(_game_event_UIMessageManager__WEBPACK_IMPORTED_MODULE_9__["UIMessageManger"]);
S.SceneManager = _framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"].Instance(_framework_scene_SceneManager__WEBPACK_IMPORTED_MODULE_7__["SceneManager"]);
S.GameObjectPool = _framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"].Instance(_framework_common_GameObjectPool__WEBPACK_IMPORTED_MODULE_0__["GameObjectPool"]);
S.ResManager = _framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"].Instance(_framework_common_ResManager__WEBPACK_IMPORTED_MODULE_1__["ResManager"]);
S.StoryManager = _framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"].Instance(_framework_ink_StoryManager__WEBPACK_IMPORTED_MODULE_2__["StoryManager"]);
S.SessionManager = _framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"].Instance(_framework_net_SessionManager__WEBPACK_IMPORTED_MODULE_6__["SessionManager"]);
S.GameSession = _framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"].Instance(_framework_net_GameSession__WEBPACK_IMPORTED_MODULE_4__["GameSession"]);
S.StoryMessageManager = _framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"].Instance(_framework_ink_StoryMessageManager__WEBPACK_IMPORTED_MODULE_3__["StoryMessageManager"]);
S.HttpManager = _framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"].Instance(_framework_net_HttpManager__WEBPACK_IMPORTED_MODULE_5__["HttpManager"]);


/***/ }),

/***/ "csharp":
/*!*************************!*\
  !*** external "csharp" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("csharp");

/***/ }),

/***/ "puerts":
/*!*************************!*\
  !*** external "puerts" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = require("puerts");

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2FzcHJvbWlzZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHByb3RvYnVmanMvYmFzZTY0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9ldmVudGVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwcm90b2J1ZmpzL2Zsb2F0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9pbnF1aXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy9wb29sL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcHJvdG9idWZqcy91dGY4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2FsbFN0YWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2hvaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvQ2hvaWNlUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Db250cm9sQ29tbWFuZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0RlYnVnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvRGl2ZXJ0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvR2x1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0lua0xpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Kc29uU2VyaWFsaXNhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL0xpc3REZWZpbml0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTGlzdERlZmluaXRpb25zT3JpZ2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTmF0aXZlRnVuY3Rpb25DYWxsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvTnVsbEV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL09iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1BSTkcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9QYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvUG9pbnRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1B1c2hQb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TZWFyY2hSZXN1bHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TaW1wbGVKc29uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RhdGVQYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3BXYXRjaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1N0b3J5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RvcnlFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9TdG9yeVN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvU3RyaW5nQnVpbGRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1RhZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1RyeUdldFJlc3VsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1R5cGVBc3NlcnRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9WYWx1ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhcmlhYmxlQXNzaWdubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5ranMvZW5naW5lL1ZhcmlhYmxlUmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbmtqcy9lbmdpbmUvVmFyaWFibGVzU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lua2pzL2VuZ2luZS9Wb2lkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb25nL3NyYy9sb25nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL21pbmltYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2luZGV4LW1pbmltYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbG9uZ2JpdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3V0aWwvbWluaW1hbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzIiwid2VicGFjazovLy8uL3NyYy9HYW1lTWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS9wYi9PcGNvZGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvcGIvZ2VuL3BiLmpzIiwid2VicGFjazovLy8uL3NyYy9kYXRhL3VpL2NvbWJhdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9jb21tb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2RhdGEvdWkvaG9tZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9sb2dpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZGF0YS91aS9zdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9HYW1lT2JqZWN0UG9vbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtTdGF0ZUluc3BlY3Rvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2luay9JbmtXcml0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbmsvU3RvcnlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW5rL1N0b3J5TWVzc2FnZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbmV0L0dhbWVTZXNzaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbmV0L0h0dHBNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbmV0L01lc3NhZ2VQYXJzZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9uZXQvTmV0RXJyb3JDb2RlLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvbmV0L1Nlc3Npb25NYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWYudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZUZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9zY2VuZS9TY2VuZU1hbmFnZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay91aS9VSURlZmluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJRmFjdG9yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTG9hZGluZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJTGliL1VJTXNnQm94LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlNYW5hZ2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvdWkvVUlQYW5lbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3VpL1VJV2luZG93LnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL2FwaS9Mb2dpbkFQSS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9ldmVudC9VSU1lc3NhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvZXZlbnQvVUlNZXNzYWdlTWFuYWdlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvZ3VpZGUvVUlHdWlkZVdpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS9zY2VuZS9Ib21lU2NlbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2hvbWUvdWkvVUlIb21lUGFnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvaG9tZS91aS9VSVNob3BQYWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9ob21lL3ZvL1ZvSG9tZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vc2NlbmUvTG9naW5TY2VuZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlMb2dpblBhZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dhbWUvbW9kdWxlL2xvZ2luL3VpL1VJU2VsU2VydmVyV2luLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9sb2dpbi92by9Wb1NlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2FtZS9tb2R1bGUvcHZlL3NjZW5lL1B2ZVNjZW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9nYW1lL21vZHVsZS9zdG9yeS9VSVN0b3J5V2luLnRzIiwid2VicGFjazovLy8uL3NyYy9nbG9iYWwvR2FtZUNvbmZpZy50cyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJjc2hhcnBcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwdWVydHNcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZhO0FBQ2I7O0FBRUE7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0EsVUFBVTtBQUNWLFdBQVcsV0FBVztBQUN0QixXQUFXLEtBQUs7QUFDaEIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsRUFBRTtBQUNiLFdBQVcsS0FBSztBQUNoQixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0EseUNBQXlDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUNuRCwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLElBQUk7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtREFBbUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUE4RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw2Qzs7Ozs7Ozs7Ozs7O0FDN2tCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMseURBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLDBDOzs7Ozs7Ozs7Ozs7QUNoRWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHlEQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHFEQUFTO0FBQ2pDLHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUQ7Ozs7Ozs7Ozs7OztBQ3JEYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscURBQVM7QUFDakMseUJBQXlCLG1CQUFPLENBQUMsdUVBQWtCO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyx5REFBVztBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDakQsd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx3QkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtCQUErQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMERBQTBEO0FBQzNELGlDOzs7Ozs7Ozs7Ozs7QUMvVWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7Ozs7Ozs7QUNoQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLHVEQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxtREFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDdENhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxxREFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyx1RUFBa0I7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsNkVBQXFCO0FBQ3pELHdCQUF3QixtQkFBTyxDQUFDLHFFQUFpQjtBQUNqRCx1QkFBdUIsbUJBQU8sQ0FBQyxtRUFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMscUVBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7Ozs7Ozs7Ozs7O0FDaFhhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1REFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxnQzs7Ozs7Ozs7Ozs7QUNQQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELGNBQWM7O0FBRW5FO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixhQUFhLE1BQU07QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQiw4Q0FBOEM7QUFDL0UsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQiw4Q0FBOEM7QUFDL0UsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7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QUFVLEdBQUcsdUVBQVUsQ0FBQyxRQUFRLENBQUMsdUVBQVUsQ0FBQyxDQUFDO0FBQzdDLGNBQVksR0FBRyx3RUFBWSxDQUFDLFFBQVEsQ0FBQyx3RUFBWSxDQUFDLENBQUM7QUFDbkQsZ0JBQWMsR0FBRyw0RUFBYyxDQUFDLFFBQVEsQ0FBQyw0RUFBYyxDQUFDLENBQUM7QUFDekQsYUFBVyxHQUFHLHNFQUFXLENBQUMsUUFBUSxDQUFDLHNFQUFXLENBQUMsQ0FBQztBQUNoRCxxQkFBbUIsR0FBRyxzRkFBbUIsQ0FBQyxRQUFRLENBQUMsc0ZBQW1CLENBQUMsQ0FBQztBQUN4RSxhQUFXLEdBQUcsc0VBQVcsQ0FBQyxRQUFRLENBQUMsc0VBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUM5QmxFLG1DOzs7Ozs7Ozs7OztBQ0FBLG1DIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL0dhbWVNYWluLnRzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gYXNQcm9taXNlO1xyXG5cclxuLyoqXHJcbiAqIENhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIHV0aWwuYXNQcm9taXNlfS5cclxuICogQHR5cGVkZWYgYXNQcm9taXNlQ2FsbGJhY2tcclxuICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnlcclxuICogQHBhcmFtIHsuLi4qfSBwYXJhbXMgQWRkaXRpb25hbCBhcmd1bWVudHNcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHByb21pc2UgZnJvbSBhIG5vZGUtc3R5bGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7YXNQcm9taXNlQ2FsbGJhY2t9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcclxuICogQHBhcmFtIHsqfSBjdHggRnVuY3Rpb24gY29udGV4dFxyXG4gKiBAcGFyYW0gey4uLip9IHBhcmFtcyBGdW5jdGlvbiBhcmd1bWVudHNcclxuICogQHJldHVybnMge1Byb21pc2U8Kj59IFByb21pc2lmaWVkIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBhc1Byb21pc2UoZm4sIGN0eC8qLCB2YXJhcmdzICovKSB7XHJcbiAgICB2YXIgcGFyYW1zICA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSksXHJcbiAgICAgICAgb2Zmc2V0ICA9IDAsXHJcbiAgICAgICAgaW5kZXggICA9IDIsXHJcbiAgICAgICAgcGVuZGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxyXG4gICAgICAgIHBhcmFtc1tvZmZzZXQrK10gPSBhcmd1bWVudHNbaW5kZXgrK107XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgcGFyYW1zW29mZnNldF0gPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIvKiwgdmFyYXJncyAqLykge1xyXG4gICAgICAgICAgICBpZiAocGVuZGluZykge1xyXG4gICAgICAgICAgICAgICAgcGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycilcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBwYXJhbXMubGVuZ3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb2Zmc2V0KytdID0gYXJndW1lbnRzW29mZnNldF07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZS5hcHBseShudWxsLCBwYXJhbXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmbi5hcHBseShjdHggfHwgbnVsbCwgcGFyYW1zKTtcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgaWYgKHBlbmRpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBlbmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIGJhc2U2NCBpbXBsZW1lbnRhdGlvbiBmb3IgbnVtYmVyIGFycmF5cy5cclxuICogQG1lbWJlcm9mIHV0aWxcclxuICogQG5hbWVzcGFjZVxyXG4gKi9cclxudmFyIGJhc2U2NCA9IGV4cG9ydHM7XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgYnl0ZSBsZW5ndGggb2YgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQmFzZTY0IGVuY29kZWQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IEJ5dGUgbGVuZ3RoXHJcbiAqL1xyXG5iYXNlNjQubGVuZ3RoID0gZnVuY3Rpb24gbGVuZ3RoKHN0cmluZykge1xyXG4gICAgdmFyIHAgPSBzdHJpbmcubGVuZ3RoO1xyXG4gICAgaWYgKCFwKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIG4gPSAwO1xyXG4gICAgd2hpbGUgKC0tcCAlIDQgPiAxICYmIHN0cmluZy5jaGFyQXQocCkgPT09IFwiPVwiKVxyXG4gICAgICAgICsrbjtcclxuICAgIHJldHVybiBNYXRoLmNlaWwoc3RyaW5nLmxlbmd0aCAqIDMpIC8gNCAtIG47XHJcbn07XHJcblxyXG4vLyBCYXNlNjQgZW5jb2RpbmcgdGFibGVcclxudmFyIGI2NCA9IG5ldyBBcnJheSg2NCk7XHJcblxyXG4vLyBCYXNlNjQgZGVjb2RpbmcgdGFibGVcclxudmFyIHM2NCA9IG5ldyBBcnJheSgxMjMpO1xyXG5cclxuLy8gNjUuLjkwLCA5Ny4uMTIyLCA0OC4uNTcsIDQzLCA0N1xyXG5mb3IgKHZhciBpID0gMDsgaSA8IDY0OylcclxuICAgIHM2NFtiNjRbaV0gPSBpIDwgMjYgPyBpICsgNjUgOiBpIDwgNTIgPyBpICsgNzEgOiBpIDwgNjIgPyBpIC0gNCA6IGkgLSA1OSB8IDQzXSA9IGkrKztcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGVzIGEgYnVmZmVyIHRvIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEJhc2U2NCBlbmNvZGVkIHN0cmluZ1xyXG4gKi9cclxuYmFzZTY0LmVuY29kZSA9IGZ1bmN0aW9uIGVuY29kZShidWZmZXIsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXTtcclxuICAgIHZhciBpID0gMCwgLy8gb3V0cHV0IGluZGV4XHJcbiAgICAgICAgaiA9IDAsIC8vIGdvdG8gaW5kZXhcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB2YXIgYiA9IGJ1ZmZlcltzdGFydCsrXTtcclxuICAgICAgICBzd2l0Y2ggKGopIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgY2h1bmtbaSsrXSA9IGI2NFtiID4+IDJdO1xyXG4gICAgICAgICAgICAgICAgdCA9IChiICYgMykgPDwgNDtcclxuICAgICAgICAgICAgICAgIGogPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNF07XHJcbiAgICAgICAgICAgICAgICB0ID0gKGIgJiAxNSkgPDwgMjtcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGNodW5rW2krK10gPSBiNjRbdCB8IGIgPj4gNl07XHJcbiAgICAgICAgICAgICAgICBjaHVua1tpKytdID0gYjY0W2IgJiA2M107XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA+IDgxOTEpIHtcclxuICAgICAgICAgICAgKHBhcnRzIHx8IChwYXJ0cyA9IFtdKSkucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY2h1bmspKTtcclxuICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGopIHtcclxuICAgICAgICBjaHVua1tpKytdID0gYjY0W3RdO1xyXG4gICAgICAgIGNodW5rW2krK10gPSA2MTtcclxuICAgICAgICBpZiAoaiA9PT0gMSlcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9IDYxO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhcnRzKSB7XHJcbiAgICAgICAgaWYgKGkpXHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKSk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rLnNsaWNlKDAsIGkpKTtcclxufTtcclxuXHJcbnZhciBpbnZhbGlkRW5jb2RpbmcgPSBcImludmFsaWQgZW5jb2RpbmdcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWNvZGVzIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFNvdXJjZSBzdHJpbmdcclxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZmZXIgRGVzdGluYXRpb24gYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgRGVzdGluYXRpb24gb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWJlciBvZiBieXRlcyB3cml0dGVuXHJcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBlbmNvZGluZyBpcyBpbnZhbGlkXHJcbiAqL1xyXG5iYXNlNjQuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgYnVmZmVyLCBvZmZzZXQpIHtcclxuICAgIHZhciBzdGFydCA9IG9mZnNldDtcclxuICAgIHZhciBqID0gMCwgLy8gZ290byBpbmRleFxyXG4gICAgICAgIHQ7ICAgICAvLyB0ZW1wb3JhcnlcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDspIHtcclxuICAgICAgICB2YXIgYyA9IHN0cmluZy5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGMgPT09IDYxICYmIGogPiAxKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBpZiAoKGMgPSBzNjRbY10pID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICAgICAgc3dpdGNoIChqKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IHQgPDwgMiB8IChjICYgNDgpID4+IDQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gYztcclxuICAgICAgICAgICAgICAgIGogPSAyO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSAodCAmIDE1KSA8PCA0IHwgKGMgJiA2MCkgPj4gMjtcclxuICAgICAgICAgICAgICAgIHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgaiA9IDM7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9ICh0ICYgMykgPDwgNiB8IGM7XHJcbiAgICAgICAgICAgICAgICBqID0gMDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChqID09PSAxKVxyXG4gICAgICAgIHRocm93IEVycm9yKGludmFsaWRFbmNvZGluZyk7XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBzdHJpbmcgYXBwZWFycyB0byBiZSBiYXNlNjQgZW5jb2RlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBTdHJpbmcgdG8gdGVzdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHByb2JhYmx5IGJhc2U2NCBlbmNvZGVkLCBvdGhlcndpc2UgZmFsc2VcclxuICovXHJcbmJhc2U2NC50ZXN0ID0gZnVuY3Rpb24gdGVzdChzdHJpbmcpIHtcclxuICAgIHJldHVybiAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC8udGVzdChzdHJpbmcpO1xyXG59O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogQ29uc3RydWN0cyBhIG5ldyBldmVudCBlbWl0dGVyIGluc3RhbmNlLlxyXG4gKiBAY2xhc3NkZXNjIEEgbWluaW1hbCBldmVudCBlbWl0dGVyLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxyXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBldnQgRXZlbnQgbmFtZVxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBMaXN0ZW5lclxyXG4gKiBAcGFyYW0geyp9IFtjdHhdIExpc3RlbmVyIGNvbnRleHRcclxuICogQHJldHVybnMge3V0aWwuRXZlbnRFbWl0dGVyfSBgdGhpc2BcclxuICovXHJcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldnQsIGZuLCBjdHgpIHtcclxuICAgICh0aGlzLl9saXN0ZW5lcnNbZXZ0XSB8fCAodGhpcy5fbGlzdGVuZXJzW2V2dF0gPSBbXSkpLnB1c2goe1xyXG4gICAgICAgIGZuICA6IGZuLFxyXG4gICAgICAgIGN0eCA6IGN0eCB8fCB0aGlzXHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgb3IgYW55IG1hdGNoaW5nIGxpc3RlbmVycyBpZiBhcmd1bWVudHMgYXJlIG9taXR0ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXZ0XSBFdmVudCBuYW1lLiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgaWYgb21pdHRlZC5cclxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZuXSBMaXN0ZW5lciB0byByZW1vdmUuIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBvZiBgZXZ0YCBpZiBvbWl0dGVkLlxyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiBvZmYoZXZ0LCBmbikge1xyXG4gICAgaWYgKGV2dCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKGZuID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldnRdID0gW107XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0uZm4gPT09IGZuKVxyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKytpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXRzIGFuIGV2ZW50IGJ5IGNhbGxpbmcgaXRzIGxpc3RlbmVycyB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZ0IEV2ZW50IG5hbWVcclxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7dXRpbC5FdmVudEVtaXR0ZXJ9IGB0aGlzYFxyXG4gKi9cclxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcclxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZ0XTtcclxuICAgIGlmIChsaXN0ZW5lcnMpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLFxyXG4gICAgICAgICAgICBpID0gMTtcclxuICAgICAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7KVxyXG4gICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOylcclxuICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpKytdLmN0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoZmFjdG9yeSk7XHJcblxyXG4vKipcclxuICogUmVhZHMgLyB3cml0ZXMgZmxvYXRzIC8gZG91YmxlcyBmcm9tIC8gdG8gYnVmZmVycy5cclxuICogQG5hbWUgdXRpbC5mbG9hdFxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFdyaXRlcyBhIDMyIGJpdCBmbG9hdCB0byBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQud3JpdGVGbG9hdExFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSAzMiBiaXQgZmxvYXQgdG8gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LndyaXRlRmxvYXRCRVxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBUYXJnZXQgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGFyZ2V0IGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcblxyXG4vKipcclxuICogUmVhZHMgYSAzMiBiaXQgZmxvYXQgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZEZsb2F0TEVcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFNvdXJjZSBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBTb3VyY2UgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFJlYWRzIGEgMzIgYml0IGZsb2F0IGZyb20gYSBidWZmZXIgdXNpbmcgYmlnIGVuZGlhbiBieXRlIG9yZGVyLlxyXG4gKiBAbmFtZSB1dGlsLmZsb2F0LnJlYWRGbG9hdEJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGxpdHRsZSBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBXcml0ZXMgYSA2NCBiaXQgZG91YmxlIHRvIGEgYnVmZmVyIHVzaW5nIGJpZyBlbmRpYW4gYnl0ZSBvcmRlci5cclxuICogQG5hbWUgdXRpbC5mbG9hdC53cml0ZURvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsIFZhbHVlIHRvIHdyaXRlXHJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRhcmdldCBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUYXJnZXQgYnVmZmVyIG9mZnNldFxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBsaXR0bGUgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUxFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBhIDY0IGJpdCBkb3VibGUgZnJvbSBhIGJ1ZmZlciB1c2luZyBiaWcgZW5kaWFuIGJ5dGUgb3JkZXIuXHJcbiAqIEBuYW1lIHV0aWwuZmxvYXQucmVhZERvdWJsZUJFXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgU291cmNlIGJ1ZmZlciBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxyXG4gKi9cclxuXHJcbi8vIEZhY3RvcnkgZnVuY3Rpb24gZm9yIHRoZSBwdXJwb3NlIG9mIG5vZGUtYmFzZWQgdGVzdGluZyBpbiBtb2RpZmllZCBnbG9iYWwgZW52aXJvbm1lbnRzXHJcbmZ1bmN0aW9uIGZhY3RvcnkoZXhwb3J0cykge1xyXG5cclxuICAgIC8vIGZsb2F0OiB0eXBlZCBhcnJheVxyXG4gICAgaWYgKHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgdmFyIGYzMiA9IG5ldyBGbG9hdDMyQXJyYXkoWyAtMCBdKSxcclxuICAgICAgICAgICAgZjhiID0gbmV3IFVpbnQ4QXJyYXkoZjMyLmJ1ZmZlciksXHJcbiAgICAgICAgICAgIGxlICA9IGY4YlszXSA9PT0gMTI4O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiB3cml0ZUZsb2F0X2YzMl9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmMzJbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfZjMyX3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGYzMlswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzNdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4YlsxXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRmxvYXRMRSA9IGxlID8gd3JpdGVGbG9hdF9mMzJfY3B5IDogd3JpdGVGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSBsZSA/IHdyaXRlRmxvYXRfZjMyX3JldiA6IHdyaXRlRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gcmVhZEZsb2F0X2YzMl9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsxXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICByZXR1cm4gZjMyWzBdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gbGUgPyByZWFkRmxvYXRfZjMyX2NweSA6IHJlYWRGbG9hdF9mMzJfcmV2O1xyXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRmxvYXRCRSA9IGxlID8gcmVhZEZsb2F0X2YzMl9yZXYgOiByZWFkRmxvYXRfZjMyX2NweTtcclxuXHJcbiAgICAvLyBmbG9hdDogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRmxvYXRfaWVlZTc1NCh3cml0ZVVpbnQsIHZhbCwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWwgPCAwID8gMSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChzaWduKVxyXG4gICAgICAgICAgICAgICAgdmFsID0gLXZhbDtcclxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgxIC8gdmFsID4gMCA/IC8qIHBvc2l0aXZlICovIDAgOiAvKiBuZWdhdGl2ZSAwICovIDIxNDc0ODM2NDgsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQzMjg5MzQ0LCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+IDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpIC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IDIxMzkwOTUwNDApID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA8IDEuMTc1NDk0MzUwODIyMjg3NWUtMzgpIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoKHNpZ24gPDwgMzEgfCBNYXRoLnJvdW5kKHZhbCAvIDEuNDAxMjk4NDY0MzI0ODE3ZS00NSkpID4+PiAwLCBidWYsIHBvcyk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gTWF0aC5yb3VuZCh2YWwgKiBNYXRoLnBvdygyLCAtZXhwb25lbnQpICogODM4ODYwOCkgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgZXhwb25lbnQgKyAxMjcgPDwgMjMgfCBtYW50aXNzYSkgPj4+IDAsIGJ1ZiwgcG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0TEUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRMRSk7XHJcbiAgICAgICAgZXhwb3J0cy53cml0ZUZsb2F0QkUgPSB3cml0ZUZsb2F0X2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWRGbG9hdF9pZWVlNzU0KHJlYWRVaW50LCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICB2YXIgdWludCA9IHJlYWRVaW50KGJ1ZiwgcG9zKSxcclxuICAgICAgICAgICAgICAgIHNpZ24gPSAodWludCA+PiAzMSkgKiAyICsgMSxcclxuICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gdWludCA+Pj4gMjMgJiAyNTUsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHVpbnQgJiA4Mzg4NjA3O1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDI1NVxyXG4gICAgICAgICAgICAgICAgPyBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgPyBOYU5cclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIEluZmluaXR5XHJcbiAgICAgICAgICAgICAgICA6IGV4cG9uZW50ID09PSAwIC8vIGRlbm9ybWFsXHJcbiAgICAgICAgICAgICAgICA/IHNpZ24gKiAxLjQwMTI5ODQ2NDMyNDgxN2UtNDUgKiBtYW50aXNzYVxyXG4gICAgICAgICAgICAgICAgOiBzaWduICogTWF0aC5wb3coMiwgZXhwb25lbnQgLSAxNTApICogKG1hbnRpc3NhICsgODM4ODYwOCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdExFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludExFKTtcclxuICAgICAgICBleHBvcnRzLnJlYWRGbG9hdEJFID0gcmVhZEZsb2F0X2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIC8vIGRvdWJsZTogdHlwZWQgYXJyYXlcclxuICAgIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHZhciBmNjQgPSBuZXcgRmxvYXQ2NEFycmF5KFstMF0pLFxyXG4gICAgICAgICAgICBmOGIgPSBuZXcgVWludDhBcnJheShmNjQuYnVmZmVyKSxcclxuICAgICAgICAgICAgbGUgID0gZjhiWzddID09PSAxMjg7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2Y2NF9jcHkodmFsLCBidWYsIHBvcykge1xyXG4gICAgICAgICAgICBmNjRbMF0gPSB2YWw7XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgICAgXSA9IGY4YlswXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDFdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMl0gPSBmOGJbMl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAzXSA9IGY4YlszXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDRdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNV0gPSBmOGJbNV07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA2XSA9IGY4Yls2XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDddID0gZjhiWzddO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gd3JpdGVEb3VibGVfZjY0X3Jldih2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIGY2NFswXSA9IHZhbDtcclxuICAgICAgICAgICAgYnVmW3BvcyAgICBdID0gZjhiWzddO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgMV0gPSBmOGJbNl07XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyAyXSA9IGY4Yls1XTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDNdID0gZjhiWzRdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgNF0gPSBmOGJbM107XHJcbiAgICAgICAgICAgIGJ1Zltwb3MgKyA1XSA9IGY4YlsyXTtcclxuICAgICAgICAgICAgYnVmW3BvcyArIDZdID0gZjhiWzFdO1xyXG4gICAgICAgICAgICBidWZbcG9zICsgN10gPSBmOGJbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVMRSA9IGxlID8gd3JpdGVEb3VibGVfZjY0X2NweSA6IHdyaXRlRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlQkUgPSBsZSA/IHdyaXRlRG91YmxlX2Y2NF9yZXYgOiB3cml0ZURvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9jcHkoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzBdID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbMV0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzNdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbNF0gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzZdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbN10gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiByZWFkRG91YmxlX2Y2NF9yZXYoYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgZjhiWzddID0gYnVmW3BvcyAgICBdO1xyXG4gICAgICAgICAgICBmOGJbNl0gPSBidWZbcG9zICsgMV07XHJcbiAgICAgICAgICAgIGY4Yls1XSA9IGJ1Zltwb3MgKyAyXTtcclxuICAgICAgICAgICAgZjhiWzRdID0gYnVmW3BvcyArIDNdO1xyXG4gICAgICAgICAgICBmOGJbM10gPSBidWZbcG9zICsgNF07XHJcbiAgICAgICAgICAgIGY4YlsyXSA9IGJ1Zltwb3MgKyA1XTtcclxuICAgICAgICAgICAgZjhiWzFdID0gYnVmW3BvcyArIDZdO1xyXG4gICAgICAgICAgICBmOGJbMF0gPSBidWZbcG9zICsgN107XHJcbiAgICAgICAgICAgIHJldHVybiBmNjRbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gbGUgPyByZWFkRG91YmxlX2Y2NF9jcHkgOiByZWFkRG91YmxlX2Y2NF9yZXY7XHJcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICBleHBvcnRzLnJlYWREb3VibGVCRSA9IGxlID8gcmVhZERvdWJsZV9mNjRfcmV2IDogcmVhZERvdWJsZV9mNjRfY3B5O1xyXG5cclxuICAgIC8vIGRvdWJsZTogaWVlZTc1NFxyXG4gICAgfSkoKTsgZWxzZSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlRG91YmxlX2llZWU3NTQod3JpdGVVaW50LCBvZmYwLCBvZmYxLCB2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gdmFsIDwgMCA/IDEgOiAwO1xyXG4gICAgICAgICAgICBpZiAoc2lnbilcclxuICAgICAgICAgICAgICAgIHZhbCA9IC12YWw7XHJcbiAgICAgICAgICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KDEgLyB2YWwgPiAwID8gLyogcG9zaXRpdmUgKi8gMCA6IC8qIG5lZ2F0aXZlIDAgKi8gMjE0NzQ4MzY0OCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc05hTih2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICB3cml0ZVVpbnQoMCwgYnVmLCBwb3MgKyBvZmYwKTtcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgyMTQ2OTU5MzYwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCA+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KSB7IC8vICstSW5maW5pdHlcclxuICAgICAgICAgICAgICAgIHdyaXRlVWludCgwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgMjE0NjQzNTA3MikgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFudGlzc2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMi4yMjUwNzM4NTg1MDcyMDE0ZS0zMDgpIHsgLy8gZGVub3JtYWxcclxuICAgICAgICAgICAgICAgICAgICBtYW50aXNzYSA9IHZhbCAvIDVlLTMyNDtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgPj4+IDAsIGJ1ZiwgcG9zICsgb2ZmMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVVaW50KChzaWduIDw8IDMxIHwgbWFudGlzc2EgLyA0Mjk0OTY3Mjk2KSA+Pj4gMCwgYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50ID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWwpIC8gTWF0aC5MTjIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA9PT0gMTAyNClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSAxMDIzO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbnRpc3NhID0gdmFsICogTWF0aC5wb3coMiwgLWV4cG9uZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVVpbnQobWFudGlzc2EgKiA0NTAzNTk5NjI3MzcwNDk2ID4+PiAwLCBidWYsIHBvcyArIG9mZjApO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVWludCgoc2lnbiA8PCAzMSB8IGV4cG9uZW50ICsgMTAyMyA8PCAyMCB8IG1hbnRpc3NhICogMTA0ODU3NiAmIDEwNDg1NzUpID4+PiAwLCBidWYsIHBvcyArIG9mZjEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBleHBvcnRzLndyaXRlRG91YmxlTEUgPSB3cml0ZURvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgd3JpdGVVaW50TEUsIDAsIDQpO1xyXG4gICAgICAgIGV4cG9ydHMud3JpdGVEb3VibGVCRSA9IHdyaXRlRG91YmxlX2llZWU3NTQuYmluZChudWxsLCB3cml0ZVVpbnRCRSwgNCwgMCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHJlYWREb3VibGVfaWVlZTc1NChyZWFkVWludCwgb2ZmMCwgb2ZmMSwgYnVmLCBwb3MpIHtcclxuICAgICAgICAgICAgdmFyIGxvID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYwKSxcclxuICAgICAgICAgICAgICAgIGhpID0gcmVhZFVpbnQoYnVmLCBwb3MgKyBvZmYxKTtcclxuICAgICAgICAgICAgdmFyIHNpZ24gPSAoaGkgPj4gMzEpICogMiArIDEsXHJcbiAgICAgICAgICAgICAgICBleHBvbmVudCA9IGhpID4+PiAyMCAmIDIwNDcsXHJcbiAgICAgICAgICAgICAgICBtYW50aXNzYSA9IDQyOTQ5NjcyOTYgKiAoaGkgJiAxMDQ4NTc1KSArIGxvO1xyXG4gICAgICAgICAgICByZXR1cm4gZXhwb25lbnQgPT09IDIwNDdcclxuICAgICAgICAgICAgICAgID8gbWFudGlzc2FcclxuICAgICAgICAgICAgICAgID8gTmFOXHJcbiAgICAgICAgICAgICAgICA6IHNpZ24gKiBJbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgOiBleHBvbmVudCA9PT0gMCAvLyBkZW5vcm1hbFxyXG4gICAgICAgICAgICAgICAgPyBzaWduICogNWUtMzI0ICogbWFudGlzc2FcclxuICAgICAgICAgICAgICAgIDogc2lnbiAqIE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTA3NSkgKiAobWFudGlzc2EgKyA0NTAzNTk5NjI3MzcwNDk2KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVhZERvdWJsZUxFID0gcmVhZERvdWJsZV9pZWVlNzU0LmJpbmQobnVsbCwgcmVhZFVpbnRMRSwgMCwgNCk7XHJcbiAgICAgICAgZXhwb3J0cy5yZWFkRG91YmxlQkUgPSByZWFkRG91YmxlX2llZWU3NTQuYmluZChudWxsLCByZWFkVWludEJFLCA0LCAwKTtcclxuXHJcbiAgICB9KSgpO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG59XHJcblxyXG4vLyB1aW50IGhlbHBlcnNcclxuXHJcbmZ1bmN0aW9uIHdyaXRlVWludExFKHZhbCwgYnVmLCBwb3MpIHtcclxuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDFdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAmIDI1NTtcclxuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZVVpbnRCRSh2YWwsIGJ1ZiwgcG9zKSB7XHJcbiAgICBidWZbcG9zICAgIF0gPSAgdmFsID4+PiAyNDtcclxuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDE2ICYgMjU1O1xyXG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gOCAgJiAyNTU7XHJcbiAgICBidWZbcG9zICsgM10gPSAgdmFsICAgICAgICAmIDI1NTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZFVpbnRMRShidWYsIHBvcykge1xyXG4gICAgcmV0dXJuIChidWZbcG9zICAgIF1cclxuICAgICAgICAgIHwgYnVmW3BvcyArIDFdIDw8IDhcclxuICAgICAgICAgIHwgYnVmW3BvcyArIDJdIDw8IDE2XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAzXSA8PCAyNCkgPj4+IDA7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRVaW50QkUoYnVmLCBwb3MpIHtcclxuICAgIHJldHVybiAoYnVmW3BvcyAgICBdIDw8IDI0XHJcbiAgICAgICAgICB8IGJ1Zltwb3MgKyAxXSA8PCAxNlxyXG4gICAgICAgICAgfCBidWZbcG9zICsgMl0gPDwgOFxyXG4gICAgICAgICAgfCBidWZbcG9zICsgM10pID4+PiAwO1xyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5tb2R1bGUuZXhwb3J0cyA9IGlucXVpcmU7XHJcblxyXG4vKipcclxuICogUmVxdWlyZXMgYSBtb2R1bGUgb25seSBpZiBhdmFpbGFibGUuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lIE1vZHVsZSB0byByZXF1aXJlXHJcbiAqIEByZXR1cm5zIHs/T2JqZWN0fSBSZXF1aXJlZCBtb2R1bGUgaWYgYXZhaWxhYmxlIGFuZCBub3QgZW1wdHksIG90aGVyd2lzZSBgbnVsbGBcclxuICovXHJcbmZ1bmN0aW9uIGlucXVpcmUobW9kdWxlTmFtZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB2YXIgbW9kID0gZXZhbChcInF1aXJlXCIucmVwbGFjZSgvXi8sXCJyZVwiKSkobW9kdWxlTmFtZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxyXG4gICAgICAgIGlmIChtb2QgJiYgKG1vZC5sZW5ndGggfHwgT2JqZWN0LmtleXMobW9kKS5sZW5ndGgpKVxyXG4gICAgICAgICAgICByZXR1cm4gbW9kO1xyXG4gICAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbm1vZHVsZS5leHBvcnRzID0gcG9vbDtcclxuXHJcbi8qKlxyXG4gKiBBbiBhbGxvY2F0b3IgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbEFsbG9jYXRvclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcclxuICovXHJcblxyXG4vKipcclxuICogQSBzbGljZXIgYXMgdXNlZCBieSB7QGxpbmsgdXRpbC5wb29sfS5cclxuICogQHR5cGVkZWYgUG9vbFNsaWNlclxyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBvZmZzZXRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgb2Zmc2V0XHJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXIgc2xpY2VcclxuICogQHRoaXMge1VpbnQ4QXJyYXl9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEEgZ2VuZXJhbCBwdXJwb3NlIGJ1ZmZlciBwb29sLlxyXG4gKiBAbWVtYmVyb2YgdXRpbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtQb29sQWxsb2NhdG9yfSBhbGxvYyBBbGxvY2F0b3JcclxuICogQHBhcmFtIHtQb29sU2xpY2VyfSBzbGljZSBTbGljZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTgxOTJdIFNsYWIgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UG9vbEFsbG9jYXRvcn0gUG9vbGVkIGFsbG9jYXRvclxyXG4gKi9cclxuZnVuY3Rpb24gcG9vbChhbGxvYywgc2xpY2UsIHNpemUpIHtcclxuICAgIHZhciBTSVpFICAgPSBzaXplIHx8IDgxOTI7XHJcbiAgICB2YXIgTUFYICAgID0gU0laRSA+Pj4gMTtcclxuICAgIHZhciBzbGFiICAgPSBudWxsO1xyXG4gICAgdmFyIG9mZnNldCA9IFNJWkU7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcG9vbF9hbGxvYyhzaXplKSB7XHJcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiBNQVgpXHJcbiAgICAgICAgICAgIHJldHVybiBhbGxvYyhzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICsgc2l6ZSA+IFNJWkUpIHtcclxuICAgICAgICAgICAgc2xhYiA9IGFsbG9jKFNJWkUpO1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmID0gc2xpY2UuY2FsbChzbGFiLCBvZmZzZXQsIG9mZnNldCArPSBzaXplKTtcclxuICAgICAgICBpZiAob2Zmc2V0ICYgNykgLy8gYWxpZ24gdG8gMzIgYml0XHJcbiAgICAgICAgICAgIG9mZnNldCA9IChvZmZzZXQgfCA3KSArIDE7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZjtcclxuICAgIH07XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vKipcclxuICogQSBtaW5pbWFsIFVURjggaW1wbGVtZW50YXRpb24gZm9yIG51bWJlciBhcnJheXMuXHJcbiAqIEBtZW1iZXJvZiB1dGlsXHJcbiAqIEBuYW1lc3BhY2VcclxuICovXHJcbnZhciB1dGY4ID0gZXhwb3J0cztcclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBVVEY4IGJ5dGUgbGVuZ3RoIG9mIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFN0cmluZ1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBCeXRlIGxlbmd0aFxyXG4gKi9cclxudXRmOC5sZW5ndGggPSBmdW5jdGlvbiB1dGY4X2xlbmd0aChzdHJpbmcpIHtcclxuICAgIHZhciBsZW4gPSAwLFxyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcbiAgICAgICAgaWYgKGMgPCAxMjgpXHJcbiAgICAgICAgICAgIGxlbiArPSAxO1xyXG4gICAgICAgIGVsc2UgaWYgKGMgPCAyMDQ4KVxyXG4gICAgICAgICAgICBsZW4gKz0gMjtcclxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4RkMwMCkgPT09IDB4RDgwMCAmJiAoc3RyaW5nLmNoYXJDb2RlQXQoaSArIDEpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgbGVuICs9IDQ7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIGxlbiArPSAzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxlbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZWFkcyBVVEY4IGJ5dGVzIGFzIGEgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBTb3VyY2UgYnVmZmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTb3VyY2Ugc3RhcnRcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBTb3VyY2UgZW5kXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFN0cmluZyByZWFkXHJcbiAqL1xyXG51dGY4LnJlYWQgPSBmdW5jdGlvbiB1dGY4X3JlYWQoYnVmZmVyLCBzdGFydCwgZW5kKSB7XHJcbiAgICB2YXIgbGVuID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAobGVuIDwgMSlcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIHZhciBwYXJ0cyA9IG51bGwsXHJcbiAgICAgICAgY2h1bmsgPSBbXSxcclxuICAgICAgICBpID0gMCwgLy8gY2hhciBvZmZzZXRcclxuICAgICAgICB0OyAgICAgLy8gdGVtcG9yYXJ5XHJcbiAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICB0ID0gYnVmZmVyW3N0YXJ0KytdO1xyXG4gICAgICAgIGlmICh0IDwgMTI4KVxyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gdDtcclxuICAgICAgICBlbHNlIGlmICh0ID4gMTkxICYmIHQgPCAyMjQpXHJcbiAgICAgICAgICAgIGNodW5rW2krK10gPSAodCAmIDMxKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgZWxzZSBpZiAodCA+IDIzOSAmJiB0IDwgMzY1KSB7XHJcbiAgICAgICAgICAgIHQgPSAoKHQgJiA3KSA8PCAxOCB8IChidWZmZXJbc3RhcnQrK10gJiA2MykgPDwgMTIgfCAoYnVmZmVyW3N0YXJ0KytdICYgNjMpIDw8IDYgfCBidWZmZXJbc3RhcnQrK10gJiA2MykgLSAweDEwMDAwO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEODAwICsgKHQgPj4gMTApO1xyXG4gICAgICAgICAgICBjaHVua1tpKytdID0gMHhEQzAwICsgKHQgJiAxMDIzKTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgY2h1bmtbaSsrXSA9ICh0ICYgMTUpIDw8IDEyIHwgKGJ1ZmZlcltzdGFydCsrXSAmIDYzKSA8PCA2IHwgYnVmZmVyW3N0YXJ0KytdICYgNjM7XHJcbiAgICAgICAgaWYgKGkgPiA4MTkxKSB7XHJcbiAgICAgICAgICAgIChwYXJ0cyB8fCAocGFydHMgPSBbXSkpLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNodW5rKSk7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXJ0cykge1xyXG4gICAgICAgIGlmIChpKVxyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSkpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjaHVuay5zbGljZSgwLCBpKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogV3JpdGVzIGEgc3RyaW5nIGFzIFVURjggYnl0ZXMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgU291cmNlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBEZXN0aW5hdGlvbiBidWZmZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCBEZXN0aW5hdGlvbiBvZmZzZXRcclxuICogQHJldHVybnMge251bWJlcn0gQnl0ZXMgd3JpdHRlblxyXG4gKi9cclxudXRmOC53cml0ZSA9IGZ1bmN0aW9uIHV0Zjhfd3JpdGUoc3RyaW5nLCBidWZmZXIsIG9mZnNldCkge1xyXG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0LFxyXG4gICAgICAgIGMxLCAvLyBjaGFyYWN0ZXIgMVxyXG4gICAgICAgIGMyOyAvLyBjaGFyYWN0ZXIgMlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG4gICAgICAgIGlmIChjMSA8IDEyOCkge1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChjMSA8IDIwNDgpIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDYgICAgICAgfCAxOTI7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSAgICAgICAmIDYzIHwgMTI4O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoKGMxICYgMHhGQzAwKSA9PT0gMHhEODAwICYmICgoYzIgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSkpICYgMHhGQzAwKSA9PT0gMHhEQzAwKSB7XHJcbiAgICAgICAgICAgIGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzRkYpIDw8IDEwKSArIChjMiAmIDB4MDNGRik7XHJcbiAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDE4ICAgICAgfCAyNDA7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiAxMiAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgPj4gNiAgJiA2MyB8IDEyODtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxICAgICAgICYgNjMgfCAxMjg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCsrXSA9IGMxID4+IDEyICAgICAgfCAyMjQ7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBjMSA+PiA2ICAmIDYzIHwgMTI4O1xyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gYzEgICAgICAgJiA2MyB8IDEyODtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2Zmc2V0IC0gc3RhcnQ7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsU3RhY2sgPSB2b2lkIDA7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFN0b3J5XzEgPSByZXF1aXJlKFwiLi9TdG9yeVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL1N0cmluZ0J1aWxkZXJcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgQ2FsbFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFN0b3J5XzEuU3RvcnkpIHtcbiAgICAgICAgICAgIGxldCBzdG9yeUNvbnRleHQgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2Yoc3RvcnlDb250ZXh0LnJvb3RDb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB0b0NvcHkgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLl90aHJlYWRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBvdGhlclRocmVhZCBvZiB0b0NvcHkuX3RocmVhZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2gob3RoZXJUaHJlYWQuQ29weSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIgPSB0b0NvcHkuX3RocmVhZENvdW50ZXI7XG4gICAgICAgICAgICB0aGlzLl9zdGFydE9mUm9vdCA9IHRvQ29weS5fc3RhcnRPZlJvb3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2s7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEVsZW1lbnQoKSB7XG4gICAgICAgIGxldCB0aHJlYWQgPSB0aGlzLl90aHJlYWRzW3RoaXMuX3RocmVhZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBjcyA9IHRocmVhZC5jYWxsc3RhY2s7XG4gICAgICAgIHJldHVybiBjc1tjcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFbGVtZW50SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFRocmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RocmVhZHNbdGhpcy5fdGhyZWFkcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRUaHJlYWQodmFsdWUpIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5fdGhyZWFkcy5sZW5ndGggPT0gMSwgXCJTaG91bGRuJ3QgYmUgZGlyZWN0bHkgc2V0dGluZyB0aGUgY3VycmVudCB0aHJlYWQgd2hlbiB3ZSBoYXZlIGEgc3RhY2sgb2YgdGhlbVwiKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl90aHJlYWRzLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBnZXQgY2FuUG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2subGVuZ3RoID4gMTtcbiAgICB9XG4gICAgUmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3RocmVhZHMgPSBbXTtcbiAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKG5ldyBDYWxsU3RhY2suVGhyZWFkKCkpO1xuICAgICAgICB0aGlzLl90aHJlYWRzWzBdLmNhbGxzdGFjay5wdXNoKG5ldyBDYWxsU3RhY2suRWxlbWVudChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsLCB0aGlzLl9zdGFydE9mUm9vdCkpO1xuICAgIH1cbiAgICBTZXRKc29uVG9rZW4oak9iamVjdCwgc3RvcnlDb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3RocmVhZHMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gVE9ETzogKExpc3Q8b2JqZWN0Pikgak9iamVjdCBbXCJ0aHJlYWRzXCJdO1xuICAgICAgICBsZXQgalRocmVhZHMgPSBqT2JqZWN0W1widGhyZWFkc1wiXTtcbiAgICAgICAgZm9yIChsZXQgalRocmVhZFRvayBvZiBqVGhyZWFkcykge1xuICAgICAgICAgICAgLy8gVE9ETzogdmFyIGpUaHJlYWRPYmogPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4palRocmVhZFRvaztcbiAgICAgICAgICAgIGxldCBqVGhyZWFkT2JqID0galRocmVhZFRvaztcbiAgICAgICAgICAgIGxldCB0aHJlYWQgPSBuZXcgQ2FsbFN0YWNrLlRocmVhZChqVGhyZWFkT2JqLCBzdG9yeUNvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5fdGhyZWFkcy5wdXNoKHRocmVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogKGludClqT2JqZWN0IFtcInRocmVhZENvdW50ZXJcIl07XG4gICAgICAgIHRoaXMuX3RocmVhZENvdW50ZXIgPSBwYXJzZUludChqT2JqZWN0W1widGhyZWFkQ291bnRlclwiXSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0T2ZSb290ID0gUG9pbnRlcl8xLlBvaW50ZXIuU3RhcnRPZihzdG9yeUNvbnRleHQucm9vdENvbnRlbnRDb250YWluZXIpO1xuICAgIH1cbiAgICBXcml0ZUpzb24odykge1xuICAgICAgICB3LldyaXRlT2JqZWN0KCh3cml0ZXIpID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRzXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgdGhyZWFkIG9mIHRoaXMuX3RocmVhZHMpIHtcbiAgICAgICAgICAgICAgICB0aHJlYWQuV3JpdGVKc29uKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJ0aHJlYWRDb3VudGVyXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50KHRoaXMuX3RocmVhZENvdW50ZXIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFB1c2hUaHJlYWQoKSB7XG4gICAgICAgIGxldCBuZXdUaHJlYWQgPSB0aGlzLmN1cnJlbnRUaHJlYWQuQ29weSgpO1xuICAgICAgICB0aGlzLl90aHJlYWRDb3VudGVyKys7XG4gICAgICAgIG5ld1RocmVhZC50aHJlYWRJbmRleCA9IHRoaXMuX3RocmVhZENvdW50ZXI7XG4gICAgICAgIHRoaXMuX3RocmVhZHMucHVzaChuZXdUaHJlYWQpO1xuICAgIH1cbiAgICBGb3JrVGhyZWFkKCkge1xuICAgICAgICBsZXQgZm9ya2VkVGhyZWFkID0gdGhpcy5jdXJyZW50VGhyZWFkLkNvcHkoKTtcbiAgICAgICAgdGhpcy5fdGhyZWFkQ291bnRlcisrO1xuICAgICAgICBmb3JrZWRUaHJlYWQudGhyZWFkSW5kZXggPSB0aGlzLl90aHJlYWRDb3VudGVyO1xuICAgICAgICByZXR1cm4gZm9ya2VkVGhyZWFkO1xuICAgIH1cbiAgICBQb3BUaHJlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyZWFkcy5zcGxpY2UodGhpcy5fdGhyZWFkcy5pbmRleE9mKHRoaXMuY3VycmVudFRocmVhZCksIDEpOyAvLyBzaG91bGQgYmUgZXF1aXZhbGVudCB0byBhIHBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwb3AgdGhyZWFkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjYW5Qb3BUaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aHJlYWRzLmxlbmd0aCA+IDEgJiYgIXRoaXMuZWxlbWVudElzRXZhbHVhdGVGcm9tR2FtZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50LnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uRXZhbHVhdGlvbkZyb21HYW1lO1xuICAgIH1cbiAgICBQdXNoKHR5cGUsIGV4dGVybmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0ID0gMCwgb3V0cHV0U3RyZWFtTGVuZ3RoV2l0aFB1c2hlZCA9IDApIHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBuZXcgQ2FsbFN0YWNrLkVsZW1lbnQodHlwZSwgdGhpcy5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciwgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQgPSBleHRlcm5hbEV2YWx1YXRpb25TdGFja0hlaWdodDtcbiAgICAgICAgZWxlbWVudC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW0gPSBvdXRwdXRTdHJlYW1MZW5ndGhXaXRoUHVzaGVkO1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICBDYW5Qb3AodHlwZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblBvcClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC50eXBlID09IHR5cGU7XG4gICAgfVxuICAgIFBvcCh0eXBlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5DYW5Qb3AodHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBwdXNoL3BvcCBpbiBDYWxsc3RhY2tcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgR2V0VGVtcG9yYXJ5VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXggPSAtMSkge1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IC0xKVxuICAgICAgICAgICAgY29udGV4dEluZGV4ID0gdGhpcy5jdXJyZW50RWxlbWVudEluZGV4ICsgMTtcbiAgICAgICAgbGV0IGNvbnRleHRFbGVtZW50ID0gdGhpcy5jYWxsU3RhY2tbY29udGV4dEluZGV4IC0gMV07XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcChjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICBpZiAodmFyVmFsdWUuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFyVmFsdWUucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2V0VGVtcG9yYXJ5VmFyaWFibGUobmFtZSwgdmFsdWUsIGRlY2xhcmVOZXcsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICBsZXQgY29udGV4dEVsZW1lbnQgPSB0aGlzLmNhbGxTdGFja1tjb250ZXh0SW5kZXggLSAxXTtcbiAgICAgICAgaWYgKCFkZWNsYXJlTmV3ICYmICFjb250ZXh0RWxlbWVudC50ZW1wb3JhcnlWYXJpYWJsZXMuZ2V0KG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNvdWxkIG5vdCBmaW5kIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBzZXQ6IFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9sZFZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgIGlmIChvbGRWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICBWYWx1ZV8xLkxpc3RWYWx1ZS5SZXRhaW5MaXN0T3JpZ2luc0ZvckFzc2lnbm1lbnQob2xkVmFsdWUucmVzdWx0LCB2YWx1ZSk7XG4gICAgICAgIGNvbnRleHRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBDb250ZXh0Rm9yVmFyaWFibGVOYW1lZChuYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFbGVtZW50LnRlbXBvcmFyeVZhcmlhYmxlcy5nZXQobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRFbGVtZW50SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGhyZWFkV2l0aEluZGV4KGluZGV4KSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZCA9IHRoaXMuX3RocmVhZHMuZmlsdGVyKCh0KSA9PiB7XG4gICAgICAgICAgICBpZiAodC50aHJlYWRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZC5sZW5ndGggPiAwID8gZmlsdGVyZWRbMF0gOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VGhyZWFkLmNhbGxzdGFjaztcbiAgICB9XG4gICAgZ2V0IGNhbGxTdGFja1RyYWNlKCkge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLl90aHJlYWRzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICBsZXQgdGhyZWFkID0gdGhpcy5fdGhyZWFkc1t0XTtcbiAgICAgICAgICAgIGxldCBpc0N1cnJlbnQgPSB0ID09IHRoaXMuX3RocmVhZHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHNiLkFwcGVuZEZvcm1hdChcIj09PSBUSFJFQUQgezB9L3sxfSB7Mn09PT1cXG5cIiwgdCArIDEsIHRoaXMuX3RocmVhZHMubGVuZ3RoLCBpc0N1cnJlbnQgPyBcIihjdXJyZW50KSBcIiA6IFwiXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aHJlYWQuY2FsbHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRocmVhZC5jYWxsc3RhY2tbaV0udHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiAgW0ZVTkNUSU9OXSBcIik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgIFtUVU5ORUxdIFwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IHRocmVhZC5jYWxsc3RhY2tbaV0uY3VycmVudFBvaW50ZXI7XG4gICAgICAgICAgICAgICAgaWYgKCFwb2ludGVyLmlzTnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCI8U09NRVdIRVJFIElOIFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChwb2ludGVyLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmRMaW5lKFwiPlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DYWxsU3RhY2sgPSBDYWxsU3RhY2s7XG4oZnVuY3Rpb24gKENhbGxTdGFjaykge1xuICAgIGNsYXNzIEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0eXBlLCBwb2ludGVyLCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuZXZhbHVhdGlvblN0YWNrSGVpZ2h0V2hlblB1c2hlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IDA7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQb2ludGVyID0gcG9pbnRlci5jb3B5KCk7XG4gICAgICAgICAgICB0aGlzLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSBpbkV4cHJlc3Npb25FdmFsdWF0aW9uO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlWYXJpYWJsZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIENvcHkoKSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBFbGVtZW50KHRoaXMudHlwZSwgdGhpcy5jdXJyZW50UG9pbnRlciwgdGhpcy5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgIGNvcHkudGVtcG9yYXJ5VmFyaWFibGVzID0gbmV3IE1hcCh0aGlzLnRlbXBvcmFyeVZhcmlhYmxlcyk7XG4gICAgICAgICAgICBjb3B5LmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQgPSB0aGlzLmV2YWx1YXRpb25TdGFja0hlaWdodFdoZW5QdXNoZWQ7XG4gICAgICAgICAgICBjb3B5LmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IHRoaXMuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbFN0YWNrLkVsZW1lbnQgPSBFbGVtZW50O1xuICAgIGNsYXNzIFRocmVhZCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy50aHJlYWRJbmRleCA9IDA7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICB0aGlzLmNhbGxzdGFjayA9IFtdO1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgalRocmVhZE9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBsZXQgc3RvcnlDb250ZXh0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IChpbnQpIGpUaHJlYWRPYmpbJ3RocmVhZEluZGV4J10gY2FuIHJhaXNlO1xuICAgICAgICAgICAgICAgIHRoaXMudGhyZWFkSW5kZXggPSBwYXJzZUludChqVGhyZWFkT2JqW1widGhyZWFkSW5kZXhcIl0pO1xuICAgICAgICAgICAgICAgIGxldCBqVGhyZWFkQ2FsbHN0YWNrID0galRocmVhZE9ialtcImNhbGxzdGFja1wiXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqRWxUb2sgb2YgalRocmVhZENhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgakVsZW1lbnRPYmogPSBqRWxUb2s7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IChpbnQpIGpFbGVtZW50T2JqWyd0eXBlJ10gY2FuIHJhaXNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHVzaFBvcFR5cGUgPSBwYXJzZUludChqRWxlbWVudE9ialtcInR5cGVcIl0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50Q29udGFpbmVyUGF0aFN0cjtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogakVsZW1lbnRPYmouVHJ5R2V0VmFsdWUgKFwiY1BhdGhcIiwgb3V0IGN1cnJlbnRDb250YWluZXJQYXRoU3RyVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbiA9IGpFbGVtZW50T2JqW1wiY1BhdGhcIl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudENvbnRhaW5lclBhdGhTdHJUb2tlbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgPSBjdXJyZW50Q29udGFpbmVyUGF0aFN0clRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGhyZWFkUG9pbnRlclJlc3VsdCA9IHN0b3J5Q29udGV4dC5Db250ZW50QXRQYXRoKG5ldyBQYXRoXzEuUGF0aChjdXJyZW50Q29udGFpbmVyUGF0aFN0cikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5jb250YWluZXIgPSB0aHJlYWRQb2ludGVyUmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuaW5kZXggPSBwYXJzZUludChqRWxlbWVudE9ialtcImlkeFwiXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhyZWFkUG9pbnRlclJlc3VsdC5vYmogPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIGxvYWRpbmcgc3RhdGUsIGludGVybmFsIHN0b3J5IGxvY2F0aW9uIGNvdWxkbid0IGJlIGZvdW5kOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJQYXRoU3RyICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aHJlYWRQb2ludGVyUmVzdWx0LmFwcHJveGltYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3J5Q29udGV4dC5XYXJuaW5nKFwiV2hlbiBsb2FkaW5nIHN0YXRlLCBleGFjdCBpbnRlcm5hbCBzdG9yeSBsb2NhdGlvbiBjb3VsZG4ndCBiZSBmb3VuZDogJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lclBhdGhTdHIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG8gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5jb250YWluZXIucGF0aC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCInIHRvIHJlY292ZXIuIEhhcyB0aGUgc3RvcnkgY2hhbmdlZCBzaW5jZSB0aGlzIHNhdmUgZGF0YSB3YXMgY3JlYXRlZD9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSAhIWpFbGVtZW50T2JqW1wiZXhwXCJdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZWwgPSBuZXcgRWxlbWVudChwdXNoUG9wVHlwZSwgcG9pbnRlciwgaW5FeHByZXNzaW9uRXZhbHVhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wcyA9IGpFbGVtZW50T2JqW1widGVtcFwiXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZW1wcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwudGVtcG9yYXJ5VmFyaWFibGVzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianModGVtcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwudGVtcG9yYXJ5VmFyaWFibGVzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsc3RhY2sucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwcmV2Q29udGVudE9ialBhdGggPSBqVGhyZWFkT2JqW1wicHJldmlvdXNDb250ZW50T2JqZWN0XCJdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldkNvbnRlbnRPYmpQYXRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcmV2UGF0aCA9IG5ldyBQYXRoXzEuUGF0aChwcmV2Q29udGVudE9ialBhdGgudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNQb2ludGVyID0gc3RvcnlDb250ZXh0LlBvaW50ZXJBdFBhdGgocHJldlBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBDb3B5KCkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgVGhyZWFkKCk7XG4gICAgICAgICAgICBjb3B5LnRocmVhZEluZGV4ID0gdGhpcy50aHJlYWRJbmRleDtcbiAgICAgICAgICAgIGZvciAobGV0IGUgb2YgdGhpcy5jYWxsc3RhY2spIHtcbiAgICAgICAgICAgICAgICBjb3B5LmNhbGxzdGFjay5wdXNoKGUuQ29weSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvcHkucHJldmlvdXNQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVKc29uKHdyaXRlcikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjYWxsc3RhY2tcIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmNhbGxzdGFjaykge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmN1cnJlbnRQb2ludGVyLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjUGF0aFwiLCBlbC5jdXJyZW50UG9pbnRlci5jb250YWluZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpZHhcIiwgZWwuY3VycmVudFBvaW50ZXIuaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImV4cFwiLCBlbC5pbkV4cHJlc3Npb25FdmFsdWF0aW9uKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInR5cGVcIiwgZWwudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnRlbXBvcmFyeVZhcmlhYmxlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwidGVtcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh3cml0ZXIsIGVsLnRlbXBvcmFyeVZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInRocmVhZEluZGV4XCIsIHRoaXMudGhyZWFkSW5kZXgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzb2x2ZWRQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnByZXZpb3VzUG9pbnRlci5SZXNvbHZlKClcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwicHJldmlvdXNDb250ZW50T2JqZWN0XCIsIHJlc29sdmVkUG9pbnRlci5wYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2FsbFN0YWNrLlRocmVhZCA9IFRocmVhZDtcbn0pKENhbGxTdGFjayA9IGV4cG9ydHMuQ2FsbFN0YWNrIHx8IChleHBvcnRzLkNhbGxTdGFjayA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWxsU3RhY2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNob2ljZSA9IHZvaWQgMDtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBDaG9pY2UgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnRleHQgPSBcIlwiO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy50aHJlYWRBdEdlbmVyYXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNvdXJjZVBhdGggPSBcIlwiO1xuICAgICAgICB0aGlzLnRhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVGhyZWFkSW5kZXggPSAwO1xuICAgIH1cbiAgICBnZXQgcGF0aFN0cmluZ09uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy50YXJnZXRQYXRoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2UudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXQgcGF0aFN0cmluZ09uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaG9pY2UgPSBDaG9pY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DaG9pY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNob2ljZVBvaW50ID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIENob2ljZVBvaW50IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihvbmNlT25seSA9IHRydWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fcGF0aE9uQ2hvaWNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNDb25kaXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNTdGFydENvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDaG9pY2VPbmx5Q29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW52aXNpYmxlRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbmNlT25seSA9IG9uY2VPbmx5O1xuICAgIH1cbiAgICBnZXQgcGF0aE9uQ2hvaWNlKCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aE9uQ2hvaWNlICE9IG51bGwgJiYgdGhpcy5fcGF0aE9uQ2hvaWNlLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCBjaG9pY2VUYXJnZXRPYmogPSB0aGlzLmNob2ljZVRhcmdldDtcbiAgICAgICAgICAgIGlmIChjaG9pY2VUYXJnZXRPYmopIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXRoT25DaG9pY2UgPSBjaG9pY2VUYXJnZXRPYmoucGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGF0aE9uQ2hvaWNlO1xuICAgIH1cbiAgICBzZXQgcGF0aE9uQ2hvaWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3BhdGhPbkNob2ljZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY2hvaWNlVGFyZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fcGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5fcGF0aE9uQ2hvaWNlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLl9wYXRoT25DaG9pY2UpLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IHBhdGhTdHJpbmdPbkNob2ljZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aE9uQ2hvaWNlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJDaG9pY2VQb2ludC5wYXRoT25DaG9pY2VcIik7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aE9uQ2hvaWNlKTtcbiAgICB9XG4gICAgc2V0IHBhdGhTdHJpbmdPbkNob2ljZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhdGhPbkNob2ljZSA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29uZGl0aW9uKVxuICAgICAgICAgICAgZmxhZ3MgfD0gMTtcbiAgICAgICAgaWYgKHRoaXMuaGFzU3RhcnRDb250ZW50KVxuICAgICAgICAgICAgZmxhZ3MgfD0gMjtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQpXG4gICAgICAgICAgICBmbGFncyB8PSA0O1xuICAgICAgICBpZiAodGhpcy5pc0ludmlzaWJsZURlZmF1bHQpXG4gICAgICAgICAgICBmbGFncyB8PSA4O1xuICAgICAgICBpZiAodGhpcy5vbmNlT25seSlcbiAgICAgICAgICAgIGZsYWdzIHw9IDE2O1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgfVxuICAgIHNldCBmbGFncyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhc0NvbmRpdGlvbiA9ICh2YWx1ZSAmIDEpID4gMDtcbiAgICAgICAgdGhpcy5oYXNTdGFydENvbnRlbnQgPSAodmFsdWUgJiAyKSA+IDA7XG4gICAgICAgIHRoaXMuaGFzQ2hvaWNlT25seUNvbnRlbnQgPSAodmFsdWUgJiA0KSA+IDA7XG4gICAgICAgIHRoaXMuaXNJbnZpc2libGVEZWZhdWx0ID0gKHZhbHVlICYgOCkgPiAwO1xuICAgICAgICB0aGlzLm9uY2VPbmx5ID0gKHZhbHVlICYgMTYpID4gMDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhdGhPbkNob2ljZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiQ2hvaWNlUG9pbnQucGF0aE9uQ2hvaWNlXCIpO1xuICAgICAgICAvLyBpbnQ/IHRhcmdldExpbmVOdW0gPSBEZWJ1Z0xpbmVOdW1iZXJPZlBhdGggKHBhdGhPbkNob2ljZSk7XG4gICAgICAgIGxldCB0YXJnZXRMaW5lTnVtID0gbnVsbDtcbiAgICAgICAgbGV0IHRhcmdldFN0cmluZyA9IHRoaXMucGF0aE9uQ2hvaWNlLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0YXJnZXRMaW5lTnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRhcmdldFN0cmluZyA9IFwiIGxpbmUgXCIgKyB0YXJnZXRMaW5lTnVtICsgXCIoXCIgKyB0YXJnZXRTdHJpbmcgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJDaG9pY2U6IC0+IFwiICsgdGFyZ2V0U3RyaW5nO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hvaWNlUG9pbnQgPSBDaG9pY2VQb2ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNob2ljZVBvaW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250YWluZXIgPSB2b2lkIDA7XG5jb25zdCBWYWx1ZV8xID0gcmVxdWlyZShcIi4vVmFsdWVcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgU2VhcmNoUmVzdWx0XzEgPSByZXF1aXJlKFwiLi9TZWFyY2hSZXN1bHRcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLm5hbWVkQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50dXJuSW5kZXhTaG91bGRCZUNvdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgaGFzVmFsaWROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICE9IG51bGwgJiYgdGhpcy5uYW1lLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5BZGRDb250ZW50KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IG5hbWVkT25seUNvbnRlbnQoKSB7XG4gICAgICAgIGxldCBuYW1lZE9ubHlDb250ZW50RGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMubmFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgaW5rT2JqZWN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsdWUsIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdC5zZXQoa2V5LCBpbmtPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBsZXQgbmFtZWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNJTmFtZWRDb250ZW50T3JOdWxsKGMpO1xuICAgICAgICAgICAgaWYgKG5hbWVkICE9IG51bGwgJiYgbmFtZWQuaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICAgICAgbmFtZWRPbmx5Q29udGVudERpY3QuZGVsZXRlKG5hbWVkLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lZE9ubHlDb250ZW50RGljdC5zaXplID09IDApXG4gICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50RGljdCA9IG51bGw7XG4gICAgICAgIHJldHVybiBuYW1lZE9ubHlDb250ZW50RGljdDtcbiAgICB9XG4gICAgc2V0IG5hbWVkT25seUNvbnRlbnQodmFsdWUpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nTmFtZWRPbmx5ID0gdGhpcy5uYW1lZE9ubHlDb250ZW50O1xuICAgICAgICBpZiAoZXhpc3RpbmdOYW1lZE9ubHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgZXhpc3RpbmdOYW1lZE9ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWVkQ29udGVudC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgWywgdmFsXSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG5hbWVkID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbCh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWVkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5BZGRUb05hbWVkQ29udGVudE9ubHkobmFtZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb3VudEZsYWdzKCkge1xuICAgICAgICBsZXQgZmxhZ3MgPSAwO1xuICAgICAgICBpZiAodGhpcy52aXNpdHNTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICBmbGFncyB8PSBDb250YWluZXIuQ291bnRGbGFncy5WaXNpdHM7XG4gICAgICAgIGlmICh0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgIGZsYWdzIHw9IENvbnRhaW5lci5Db3VudEZsYWdzLlR1cm5zO1xuICAgICAgICBpZiAodGhpcy5jb3VudGluZ0F0U3RhcnRPbmx5KVxuICAgICAgICAgICAgZmxhZ3MgfD0gQ29udGFpbmVyLkNvdW50RmxhZ3MuQ291bnRTdGFydE9ubHk7XG4gICAgICAgIGlmIChmbGFncyA9PSBDb250YWluZXIuQ291bnRGbGFncy5Db3VudFN0YXJ0T25seSkge1xuICAgICAgICAgICAgZmxhZ3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICB9XG4gICAgc2V0IGNvdW50RmxhZ3ModmFsdWUpIHtcbiAgICAgICAgbGV0IGZsYWcgPSB2YWx1ZTtcbiAgICAgICAgaWYgKChmbGFnICYgQ29udGFpbmVyLkNvdW50RmxhZ3MuVmlzaXRzKSA+IDApXG4gICAgICAgICAgICB0aGlzLnZpc2l0c1Nob3VsZEJlQ291bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICgoZmxhZyAmIENvbnRhaW5lci5Db3VudEZsYWdzLlR1cm5zKSA+IDApXG4gICAgICAgICAgICB0aGlzLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCA9IHRydWU7XG4gICAgICAgIGlmICgoZmxhZyAmIENvbnRhaW5lci5Db3VudEZsYWdzLkNvdW50U3RhcnRPbmx5KSA+IDApXG4gICAgICAgICAgICB0aGlzLmNvdW50aW5nQXRTdGFydE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgcGF0aFRvRmlyc3RMZWFmQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3BhdGhUb0ZpcnN0TGVhZkNvbnRlbnQgPSB0aGlzLnBhdGguUGF0aEJ5QXBwZW5kaW5nUGF0aCh0aGlzLmludGVybmFsUGF0aFRvRmlyc3RMZWFmQ29udGVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoVG9GaXJzdExlYWZDb250ZW50O1xuICAgIH1cbiAgICBnZXQgaW50ZXJuYWxQYXRoVG9GaXJzdExlYWZDb250ZW50KCkge1xuICAgICAgICBsZXQgY29tcG9uZW50cyA9IFtdO1xuICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2gobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudCgwKSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLmNvbnRlbnRbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoXzEuUGF0aChjb21wb25lbnRzKTtcbiAgICB9XG4gICAgQWRkQ29udGVudChjb250ZW50T2JqT3JMaXN0KSB7XG4gICAgICAgIGlmIChjb250ZW50T2JqT3JMaXN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50TGlzdCA9IGNvbnRlbnRPYmpPckxpc3Q7XG4gICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRlbnRMaXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5BZGRDb250ZW50KGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPYmogPSBjb250ZW50T2JqT3JMaXN0O1xuICAgICAgICAgICAgdGhpcy5fY29udGVudC5wdXNoKGNvbnRlbnRPYmopO1xuICAgICAgICAgICAgaWYgKGNvbnRlbnRPYmoucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiICsgY29udGVudE9iai5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudE9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJ5QWRkTmFtZWRDb250ZW50KGNvbnRlbnRPYmopIHtcbiAgICAgICAgbGV0IG5hbWVkQ29udGVudE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc0lOYW1lZENvbnRlbnRPck51bGwoY29udGVudE9iaik7XG4gICAgICAgIGlmIChuYW1lZENvbnRlbnRPYmogIT0gbnVsbCAmJiBuYW1lZENvbnRlbnRPYmouaGFzVmFsaWROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLkFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZENvbnRlbnRPYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZFRvTmFtZWRDb250ZW50T25seShuYW1lZENvbnRlbnRPYmopIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnRUeXBlKG5hbWVkQ29udGVudE9iaiwgT2JqZWN0XzEuSW5rT2JqZWN0LCBcIkNhbiBvbmx5IGFkZCBSdW50aW1lLk9iamVjdHMgdG8gYSBSdW50aW1lLkNvbnRhaW5lclwiKTtcbiAgICAgICAgbGV0IHJ1bnRpbWVPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuYW1lZENvbnRlbnRPYmosIE9iamVjdF8xLklua09iamVjdCk7XG4gICAgICAgIHJ1bnRpbWVPYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5uYW1lZENvbnRlbnQuc2V0KG5hbWVkQ29udGVudE9iai5uYW1lLCBuYW1lZENvbnRlbnRPYmopO1xuICAgIH1cbiAgICBDb250ZW50QXRQYXRoKHBhdGgsIHBhcnRpYWxQYXRoU3RhcnQgPSAwLCBwYXJ0aWFsUGF0aExlbmd0aCA9IC0xKSB7XG4gICAgICAgIGlmIChwYXJ0aWFsUGF0aExlbmd0aCA9PSAtMSlcbiAgICAgICAgICAgIHBhcnRpYWxQYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgU2VhcmNoUmVzdWx0XzEuU2VhcmNoUmVzdWx0KCk7XG4gICAgICAgIHJlc3VsdC5hcHByb3hpbWF0ZSA9IGZhbHNlO1xuICAgICAgICBsZXQgY3VycmVudENvbnRhaW5lciA9IHRoaXM7XG4gICAgICAgIGxldCBjdXJyZW50T2JqID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhcnRpYWxQYXRoU3RhcnQ7IGkgPCBwYXJ0aWFsUGF0aExlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY29tcCA9IHBhdGguR2V0Q29tcG9uZW50KGkpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHByb3hpbWF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmRPYmogPSBjdXJyZW50Q29udGFpbmVyLkNvbnRlbnRXaXRoUGF0aENvbXBvbmVudChjb21wKTtcbiAgICAgICAgICAgIGlmIChmb3VuZE9iaiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFwcHJveGltYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRPYmogPSBmb3VuZE9iajtcbiAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoZm91bmRPYmosIENvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm9iaiA9IGN1cnJlbnRPYmo7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEluc2VydENvbnRlbnQoY29udGVudE9iaiwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W2luZGV4XSA9IGNvbnRlbnRPYmo7XG4gICAgICAgIGlmIChjb250ZW50T2JqLnBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29udGVudCBpcyBhbHJlYWR5IGluIFwiICsgY29udGVudE9iai5wYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnRPYmoucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQoY29udGVudE9iaik7XG4gICAgfVxuICAgIEFkZENvbnRlbnRzT2ZDb250YWluZXIob3RoZXJDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LmNvbmNhdChvdGhlckNvbnRhaW5lci5jb250ZW50KTtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIG90aGVyQ29udGFpbmVyLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIG9iai5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5UcnlBZGROYW1lZENvbnRlbnQob2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb250ZW50V2l0aFBhdGhDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjb21wb25lbnQuaXNJbmRleCkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5pbmRleCA+PSAwICYmIGNvbXBvbmVudC5pbmRleCA8IHRoaXMuY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50W2NvbXBvbmVudC5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wb25lbnQuaXNQYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQubmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY29tcG9uZW50Lm5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm91bmRDb250ZW50ID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMubmFtZWRDb250ZW50LCBjb21wb25lbnQubmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAoZm91bmRDb250ZW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhmb3VuZENvbnRlbnQucmVzdWx0LCBPYmplY3RfMS5JbmtPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgQnVpbGRTdHJpbmdPZkhpZXJhcmNoeSgpIHtcbiAgICAgICAgbGV0IHNiO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgdGhpcy5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCAwLCBudWxsKTtcbiAgICAgICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHNiID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBsZXQgaW5kZW50YXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGxldCBwb2ludGVkT2JqID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmRJbmRlbnRhdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwYWNlc1BlckluZGVudCA9IDQ7IC8vIFRydWx5IGNvbnN0IGluIHRoZSBvcmlnaW5hbCBjb2RlXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYWNlc1BlckluZGVudCAqIGluZGVudGF0aW9uOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgIHNiLkFwcGVuZChcIltcIik7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbGlkTmFtZSkge1xuICAgICAgICAgICAgc2IuQXBwZW5kRm9ybWF0KFwiICh7MH0pXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMgPT0gcG9pbnRlZE9iaikge1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiICA8LS0tXCIpO1xuICAgICAgICB9XG4gICAgICAgIHNiLkFwcGVuZExpbmUoKTtcbiAgICAgICAgaW5kZW50YXRpb24rKztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IG9iajtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgaW5kZW50YXRpb24sIHBvaW50ZWRPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChvYmoudG9TdHJpbmcoKS5yZXBsYWNlKFwiXFxuXCIsIFwiXFxcXG5cIikpO1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQoJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzYi5BcHBlbmQob2JqLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICE9IHRoaXMuY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcikgJiYgb2JqID09IHBvaW50ZWRPYmopIHtcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCIgIDwtLS1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYi5BcHBlbmRMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9ubHlOYW1lZCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMubmFtZWRDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LmluZGV4T2YoVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsdWUsIE9iamVjdF8xLklua09iamVjdCkpID49IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ubHlOYW1lZC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9ubHlOYW1lZC5zaXplID4gMCkge1xuICAgICAgICAgICAgYXBwZW5kSW5kZW50YXRpb24oKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZExpbmUoXCItLSBuYW1lZDogLS1cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBbLCB2YWx1ZV0gb2Ygb25seU5hbWVkKSB7XG4gICAgICAgICAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnRUeXBlKHZhbHVlLCBDb250YWluZXIsIFwiQ2FuIG9ubHkgcHJpbnQgb3V0IG5hbWVkIENvbnRhaW5lcnNcIik7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5CdWlsZFN0cmluZ09mSGllcmFyY2h5KHNiLCBpbmRlbnRhdGlvbiwgcG9pbnRlZE9iaik7XG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kTGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGVudGF0aW9uLS07XG4gICAgICAgIGFwcGVuZEluZGVudGF0aW9uKCk7XG4gICAgICAgIHNiLkFwcGVuZChcIl1cIik7XG4gICAgfVxufVxuZXhwb3J0cy5Db250YWluZXIgPSBDb250YWluZXI7XG4oZnVuY3Rpb24gKENvbnRhaW5lcikge1xuICAgIGxldCBDb3VudEZsYWdzO1xuICAgIChmdW5jdGlvbiAoQ291bnRGbGFncykge1xuICAgICAgICBDb3VudEZsYWdzW0NvdW50RmxhZ3NbXCJWaXNpdHNcIl0gPSAxXSA9IFwiVmlzaXRzXCI7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIlR1cm5zXCJdID0gMl0gPSBcIlR1cm5zXCI7XG4gICAgICAgIENvdW50RmxhZ3NbQ291bnRGbGFnc1tcIkNvdW50U3RhcnRPbmx5XCJdID0gNF0gPSBcIkNvdW50U3RhcnRPbmx5XCI7XG4gICAgfSkoQ291bnRGbGFncyA9IENvbnRhaW5lci5Db3VudEZsYWdzIHx8IChDb250YWluZXIuQ291bnRGbGFncyA9IHt9KSk7XG59KShDb250YWluZXIgPSBleHBvcnRzLkNvbnRhaW5lciB8fCAoZXhwb3J0cy5Db250YWluZXIgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGFpbmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cm9sQ29tbWFuZCA9IHZvaWQgMDtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY2xhc3MgQ29udHJvbENvbW1hbmQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1hbmRUeXBlID0gQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm90U2V0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NvbW1hbmRUeXBlID0gY29tbWFuZFR5cGU7XG4gICAgfVxuICAgIGdldCBjb21tYW5kVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRUeXBlO1xuICAgIH1cbiAgICBDb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKHRoaXMuY29tbWFuZFR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgRXZhbFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxTdGFydCk7XG4gICAgfVxuICAgIHN0YXRpYyBFdmFsT3V0cHV0KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxPdXRwdXQpO1xuICAgIH1cbiAgICBzdGF0aWMgRXZhbEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsRW5kKTtcbiAgICB9XG4gICAgc3RhdGljIER1cGxpY2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGUpO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wRXZhbHVhdGVkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb24pO1xuICAgIH1cbiAgICBzdGF0aWMgUG9wVHVubmVsKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcFR1bm5lbCk7XG4gICAgfVxuICAgIHN0YXRpYyBCZWdpblN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZyk7XG4gICAgfVxuICAgIHN0YXRpYyBFbmRTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kU3RyaW5nKTtcbiAgICB9XG4gICAgc3RhdGljIE5vT3AoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTm9PcCk7XG4gICAgfVxuICAgIHN0YXRpYyBDaG9pY2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5DaG9pY2VDb3VudCk7XG4gICAgfVxuICAgIHN0YXRpYyBUdXJucygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJucyk7XG4gICAgfVxuICAgIHN0YXRpYyBUdXJuc1NpbmNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgUmVhZENvdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJlYWRDb3VudCk7XG4gICAgfVxuICAgIHN0YXRpYyBSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tKTtcbiAgICB9XG4gICAgc3RhdGljIFNlZWRSYW5kb20oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbSk7XG4gICAgfVxuICAgIHN0YXRpYyBWaXNpdEluZGV4KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU2VxdWVuY2VTaHVmZmxlSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU3RhcnRUaHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQpO1xuICAgIH1cbiAgICBzdGF0aWMgRG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lKTtcbiAgICB9XG4gICAgc3RhdGljIEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cm9sQ29tbWFuZChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmQpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdEZyb21JbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJvbENvbW1hbmQoQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdFJhbmdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5nZSk7XG4gICAgfVxuICAgIHN0YXRpYyBMaXN0UmFuZG9tKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kKENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb20pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZFR5cGUudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyb2xDb21tYW5kID0gQ29udHJvbENvbW1hbmQ7XG4oZnVuY3Rpb24gKENvbnRyb2xDb21tYW5kKSB7XG4gICAgbGV0IENvbW1hbmRUeXBlO1xuICAgIChmdW5jdGlvbiAoQ29tbWFuZFR5cGUpIHtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJOb3RTZXRcIl0gPSAtMV0gPSBcIk5vdFNldFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkV2YWxTdGFydFwiXSA9IDBdID0gXCJFdmFsU3RhcnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFdmFsT3V0cHV0XCJdID0gMV0gPSBcIkV2YWxPdXRwdXRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFdmFsRW5kXCJdID0gMl0gPSBcIkV2YWxFbmRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJEdXBsaWNhdGVcIl0gPSAzXSA9IFwiRHVwbGljYXRlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUG9wRXZhbHVhdGVkVmFsdWVcIl0gPSA0XSA9IFwiUG9wRXZhbHVhdGVkVmFsdWVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJQb3BGdW5jdGlvblwiXSA9IDVdID0gXCJQb3BGdW5jdGlvblwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlBvcFR1bm5lbFwiXSA9IDZdID0gXCJQb3BUdW5uZWxcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJCZWdpblN0cmluZ1wiXSA9IDddID0gXCJCZWdpblN0cmluZ1wiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkVuZFN0cmluZ1wiXSA9IDhdID0gXCJFbmRTdHJpbmdcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJOb09wXCJdID0gOV0gPSBcIk5vT3BcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJDaG9pY2VDb3VudFwiXSA9IDEwXSA9IFwiQ2hvaWNlQ291bnRcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUdXJuc1wiXSA9IDExXSA9IFwiVHVybnNcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJUdXJuc1NpbmNlXCJdID0gMTJdID0gXCJUdXJuc1NpbmNlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiUmFuZG9tXCJdID0gMTNdID0gXCJSYW5kb21cIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJTZWVkUmFuZG9tXCJdID0gMTRdID0gXCJTZWVkUmFuZG9tXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVmlzaXRJbmRleFwiXSA9IDE1XSA9IFwiVmlzaXRJbmRleFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlNlcXVlbmNlU2h1ZmZsZUluZGV4XCJdID0gMTZdID0gXCJTZXF1ZW5jZVNodWZmbGVJbmRleFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlN0YXJ0VGhyZWFkXCJdID0gMTddID0gXCJTdGFydFRocmVhZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkRvbmVcIl0gPSAxOF0gPSBcIkRvbmVcIjtcbiAgICAgICAgQ29tbWFuZFR5cGVbQ29tbWFuZFR5cGVbXCJFbmRcIl0gPSAxOV0gPSBcIkVuZFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkxpc3RGcm9tSW50XCJdID0gMjBdID0gXCJMaXN0RnJvbUludFwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIkxpc3RSYW5nZVwiXSA9IDIxXSA9IFwiTGlzdFJhbmdlXCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiTGlzdFJhbmRvbVwiXSA9IDIyXSA9IFwiTGlzdFJhbmRvbVwiO1xuICAgICAgICBDb21tYW5kVHlwZVtDb21tYW5kVHlwZVtcIlJlYWRDb3VudFwiXSA9IDIzXSA9IFwiUmVhZENvdW50XCI7XG4gICAgICAgIENvbW1hbmRUeXBlW0NvbW1hbmRUeXBlW1wiVE9UQUxfVkFMVUVTXCJdID0gMjRdID0gXCJUT1RBTF9WQUxVRVNcIjtcbiAgICB9KShDb21tYW5kVHlwZSA9IENvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlIHx8IChDb250cm9sQ29tbWFuZC5Db21tYW5kVHlwZSA9IHt9KSk7XG59KShDb250cm9sQ29tbWFuZCA9IGV4cG9ydHMuQ29udHJvbENvbW1hbmQgfHwgKGV4cG9ydHMuQ29udHJvbENvbW1hbmQgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbENvbW1hbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRlYnVnID0gdm9pZCAwO1xudmFyIERlYnVnO1xuKGZ1bmN0aW9uIChEZWJ1Zykge1xuICAgIGZ1bmN0aW9uIEFzc2VydFR5cGUodmFyaWFibGUsIHR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgQXNzZXJ0KHZhcmlhYmxlIGluc3RhbmNlb2YgdHlwZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIERlYnVnLkFzc2VydFR5cGUgPSBBc3NlcnRUeXBlO1xuICAgIGZ1bmN0aW9uIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERlYnVnLkFzc2VydCA9IEFzc2VydDtcbn0pKERlYnVnID0gZXhwb3J0cy5EZWJ1ZyB8fCAoZXhwb3J0cy5EZWJ1ZyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWJ1Zy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGl2ZXJ0ID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY2xhc3MgRGl2ZXJ0IGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihzdGFja1B1c2hUeXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RhcmdldFBhdGggPSBudWxsO1xuICAgICAgICB0aGlzLl90YXJnZXRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgdGhpcy52YXJpYWJsZURpdmVydE5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFja1B1c2hUeXBlID0gMDtcbiAgICAgICAgdGhpcy5pc0V4dGVybmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxBcmdzID0gMDtcbiAgICAgICAgdGhpcy5pc0NvbmRpdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHN0YWNrUHVzaFR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaGVzVG9TdGFjayA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0YWNrUHVzaFR5cGUgPSBzdGFja1B1c2hUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0YXJnZXRQYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aCAhPSBudWxsICYmIHRoaXMuX3RhcmdldFBhdGguaXNSZWxhdGl2ZSkge1xuICAgICAgICAgICAgbGV0IHRhcmdldE9iaiA9IHRoaXMudGFyZ2V0UG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0T2JqKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UGF0aCA9IHRhcmdldE9iai5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQYXRoO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0UGF0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90YXJnZXRQYXRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgIH1cbiAgICBnZXQgdGFyZ2V0UG9pbnRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0T2JqID0gdGhpcy5SZXNvbHZlUGF0aCh0aGlzLl90YXJnZXRQYXRoKS5vYmo7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3RhcmdldFBhdGhcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50ID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fdGFyZ2V0UGF0aC5sYXN0Q29tcG9uZW50XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldE9iaiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0YXJnZXRPYmpcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlci5jb250YWluZXIgPVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRPYmoucGFyZW50IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyID8gdGFyZ2V0T2JqLnBhcmVudCA6IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9pbnRlci5pbmRleCA9IHRoaXMuX3RhcmdldFBhdGgubGFzdENvbXBvbmVudC5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKHRhcmdldE9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA/IHRhcmdldE9iaiA6IG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQb2ludGVyLmNvcHkoKTtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGhTdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldFBhdGggPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5Db21wYWN0UGF0aFN0cmluZyh0aGlzLnRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBzZXQgdGFyZ2V0UGF0aFN0cmluZyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRQYXRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGhhc1ZhcmlhYmxlVGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZURpdmVydE5hbWUgIT0gbnVsbDtcbiAgICB9XG4gICAgRXF1YWxzKG9iaikge1xuICAgICAgICBsZXQgb3RoZXJEaXZlcnQgPSBvYmo7XG4gICAgICAgIGlmIChvdGhlckRpdmVydCBpbnN0YW5jZW9mIERpdmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQgPT0gb3RoZXJEaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNWYXJpYWJsZVRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YXJpYWJsZURpdmVydE5hbWUgPT0gb3RoZXJEaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy50YXJnZXRQYXRoXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRQYXRoLkVxdWFscyhvdGhlckRpdmVydC50YXJnZXRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkRpdmVydCh2YXJpYWJsZTogXCIgKyB0aGlzLnZhcmlhYmxlRGl2ZXJ0TmFtZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0UGF0aCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJEaXZlcnQobnVsbClcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgbGV0IHRhcmdldFN0ciA9IHRoaXMudGFyZ2V0UGF0aC50b1N0cmluZygpO1xuICAgICAgICAgICAgLy8gaW50PyB0YXJnZXRMaW5lTnVtID0gRGVidWdMaW5lTnVtYmVyT2ZQYXRoICh0YXJnZXRQYXRoKTtcbiAgICAgICAgICAgIGxldCB0YXJnZXRMaW5lTnVtID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRMaW5lTnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBcImxpbmUgXCIgKyB0YXJnZXRMaW5lTnVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuQXBwZW5kKFwiRGl2ZXJ0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25kaXRpb25hbClcbiAgICAgICAgICAgICAgICBzYi5BcHBlbmQoXCI/XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YWNrUHVzaFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiB0dW5uZWxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2IuQXBwZW5kKFwiIC0+IFwiKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZCh0aGlzLnRhcmdldFBhdGhTdHJpbmcpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKFwiIChcIik7XG4gICAgICAgICAgICBzYi5BcHBlbmQodGFyZ2V0U3RyKTtcbiAgICAgICAgICAgIHNiLkFwcGVuZChcIilcIik7XG4gICAgICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRGl2ZXJ0ID0gRGl2ZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGl2ZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HbHVlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBHbHVlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiR2x1ZVwiO1xuICAgIH1cbn1cbmV4cG9ydHMuR2x1ZSA9IEdsdWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HbHVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbmtMaXN0ID0gZXhwb3J0cy5JbmtMaXN0SXRlbSA9IHZvaWQgMDtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY2xhc3MgSW5rTGlzdEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBJbmtMaXN0SXRlbSBpcyBhIHN0cnVjdFxuICAgICAgICB0aGlzLm9yaWdpbk5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLml0ZW1OYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvcmlnaW5OYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgbGV0IGl0ZW1OYW1lID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5OYW1lID0gb3JpZ2luTmFtZTtcbiAgICAgICAgICAgIHRoaXMuaXRlbU5hbWUgPSBpdGVtTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgIGxldCBmdWxsTmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCBuYW1lUGFydHMgPSBmdWxsTmFtZS50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luTmFtZSA9IG5hbWVQYXJ0c1swXTtcbiAgICAgICAgICAgIHRoaXMuaXRlbU5hbWUgPSBuYW1lUGFydHNbMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBOdWxsKCkge1xuICAgICAgICByZXR1cm4gbmV3IElua0xpc3RJdGVtKG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBnZXQgaXNOdWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW5OYW1lID09IG51bGwgJiYgdGhpcy5pdGVtTmFtZSA9PSBudWxsO1xuICAgIH1cbiAgICBnZXQgZnVsbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMub3JpZ2luTmFtZSAhPT0gbnVsbCA/IHRoaXMub3JpZ2luTmFtZSA6IFwiP1wiKSArIFwiLlwiICsgdGhpcy5pdGVtTmFtZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mdWxsTmFtZTtcbiAgICB9XG4gICAgRXF1YWxzKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgSW5rTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBvdGhlckl0ZW0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gKG90aGVySXRlbS5pdGVtTmFtZSA9PSB0aGlzLml0ZW1OYW1lICYmXG4gICAgICAgICAgICAgICAgb3RoZXJJdGVtLm9yaWdpbk5hbWUgPT0gdGhpcy5vcmlnaW5OYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRoZXNlIG1ldGhvZHMgZGlkIG5vdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgQyMgY29kZS4gVGhlaXIgcHVycG9zZSBpcyB0b1xuICAgIC8vIG1ha2UgYElua0xpc3RJdGVtYCBtaW1pY3MgdGhlIHZhbHVlLXR5cGUgc2VtYW50aWNzIG9mIHRoZSBvcmlnaW5hbFxuICAgIC8vIHN0cnVjdC4gUGxlYXNlIHJlZmVyIHRvIHRoZSBlbmQgb2YgdGhpcyBmaWxlLCBmb3IgYSBtb3JlIGluLWRlcHRoXG4gICAgLy8gZXhwbGFuYXRpb24uXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNoYWxsb3cgY2xvbmUgb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0SXRlbSh0aGlzLm9yaWdpbk5hbWUsIHRoaXMuaXRlbU5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYFNlcmlhbGl6ZWRJbmtMaXN0SXRlbWAgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50XG4gICAgICogaW5zdGFuY2UuIFRoZSByZXN1bHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIGtleSBpbnNpZGUgYSBNYXAuXG4gICAgICovXG4gICAgc2VyaWFsaXplZCgpIHtcbiAgICAgICAgLy8gV2UgYXJlIHNpbXBseSB1c2luZyBhIEpTT04gcmVwcmVzZW50YXRpb24gYXMgYSB2YWx1ZS10eXBlZCBrZXkuXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBvcmlnaW5OYW1lOiB0aGlzLm9yaWdpbk5hbWUsXG4gICAgICAgICAgICBpdGVtTmFtZTogdGhpcy5pdGVtTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29uc3RydWN0cyBhIGBJbmtMaXN0SXRlbWAgZnJvbSB0aGUgZ2l2ZW4gU2VyaWFsaXplZElua0xpc3RJdGVtLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2VyaWFsaXplZEtleShrZXkpIHtcbiAgICAgICAgbGV0IG9iaiA9IEpTT04ucGFyc2Uoa2V5KTtcbiAgICAgICAgaWYgKCFJbmtMaXN0SXRlbS5pc0xpa2VJbmtMaXN0SXRlbShvYmopKVxuICAgICAgICAgICAgcmV0dXJuIElua0xpc3RJdGVtLk51bGw7XG4gICAgICAgIGxldCBpbmtMaXN0SXRlbSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0SXRlbShpbmtMaXN0SXRlbS5vcmlnaW5OYW1lLCBpbmtMaXN0SXRlbS5pdGVtTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gaXRlbSBpcyBzdWZmaWNpZW50bHkgYElua0xpc3RJdGVtYC1saWtlXG4gICAgICogdG8gYmUgdXNlZCBhcyBhIHRlbXBsYXRlIHdoZW4gcmVjb25zdHJ1Y3RpbmcgdGhlIElua0xpc3RJdGVtLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0xpa2VJbmtMaXN0SXRlbShpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFpdGVtLmhhc093blByb3BlcnR5KFwib3JpZ2luTmFtZVwiKSB8fCAhaXRlbS5oYXNPd25Qcm9wZXJ0eShcIml0ZW1OYW1lXCIpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0ub3JpZ2luTmFtZSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbS5vcmlnaW5OYW1lICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uaXRlbU5hbWUgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGl0ZW0uaXRlbU5hbWUgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5rTGlzdEl0ZW0gPSBJbmtMaXN0SXRlbTtcbmNsYXNzIElua0xpc3QgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBUcnlpbmcgdG8gYmUgc21hcnQgaGVyZSwgdGhpcyBlbXVsYXRlcyB0aGUgY29uc3RydWN0b3IgaW5oZXJpdGFuY2UgZm91bmRcbiAgICAgICAgLy8gaW4gdGhlIG9yaWdpbmFsIGNvZGUsIGJ1dCBvbmx5IGlmIG90aGVyTGlzdCBpcyBhbiBJbmtMaXN0LiBJSUZFIEZUVy5cbiAgICAgICAgc3VwZXIoKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBJbmtMaXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSk7XG4gICAgICAgIHRoaXMub3JpZ2lucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX29yaWdpbk5hbWVzID0gW107XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBJbmtMaXN0KSB7XG4gICAgICAgICAgICBsZXQgb3RoZXJMaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKG90aGVyTGlzdC5fb3JpZ2luTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IG90aGVyTGlzdC5fb3JpZ2luTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgc2luZ2xlT3JpZ2luTGlzdE5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgb3JpZ2luU3RvcnkgPSBhcmd1bWVudHNbMV07IC8qIGFzIFN0b3J5ICovXG4gICAgICAgICAgICB0aGlzLlNldEluaXRpYWxPcmlnaW5OYW1lKHNpbmdsZU9yaWdpbkxpc3ROYW1lKTtcbiAgICAgICAgICAgIGxldCBkZWYgPSBvcmlnaW5TdG9yeS5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24oc2luZ2xlT3JpZ2luTGlzdE5hbWUsIG51bGwpO1xuICAgICAgICAgICAgaWYgKGRlZi5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbnMgPSBbZGVmLnJlc3VsdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmtMaXN0IG9yaWdpbiBjb3VsZCBub3QgYmUgZm91bmQgaW4gc3Rvcnkgd2hlbiBjb25zdHJ1Y3RpbmcgbmV3IGxpc3Q6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlT3JpZ2luTGlzdE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGFyZ3VtZW50c1swXS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSAmJlxuICAgICAgICAgICAgYXJndW1lbnRzWzBdLmhhc093blByb3BlcnR5KFwiVmFsdWVcIikpIHtcbiAgICAgICAgICAgIGxldCBzaW5nbGVFbGVtZW50ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5BZGQoc2luZ2xlRWxlbWVudC5LZXksIHNpbmdsZUVsZW1lbnQuVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZEl0ZW0oaXRlbU9ySXRlbU5hbWUpIHtcbiAgICAgICAgaWYgKGl0ZW1Pckl0ZW1OYW1lIGluc3RhbmNlb2YgSW5rTGlzdEl0ZW0pIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gaXRlbU9ySXRlbU5hbWU7XG4gICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW5OYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZEl0ZW0oaXRlbS5pdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLm5hbWUgPT0gaXRlbS5vcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRWYWwgPSBvcmlnaW4uVHJ5R2V0VmFsdWVGb3JJdGVtKGl0ZW0sIDApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50VmFsLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGQoaXRlbSwgaW50VmFsLnJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiB0byB0aGlzIGxpc3QgYmVjYXVzZSBpdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBsaXN0IGRlZmluaXRpb24gaW4gaW5rLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBhZGQgaXRlbSB0byBsaXN0IGJlY2F1c2UgdGhlIGl0ZW0gd2FzIGZyb20gYSBuZXcgbGlzdCBkZWZpbml0aW9uIHRoYXQgd2Fzbid0IHByZXZpb3VzbHkga25vd24gdG8gdGhpcyBsaXN0LiBPbmx5IGl0ZW1zIGZyb20gcHJldmlvdXNseSBrbm93biBsaXN0cyBjYW4gYmUgdXNlZCwgc28gdGhhdCB0aGUgaW50IHZhbHVlIGNhbiBiZSBmb3VuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaXRlbU5hbWUgPSBpdGVtT3JJdGVtTmFtZTtcbiAgICAgICAgICAgIGxldCBmb3VuZExpc3REZWYgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbU5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbU5hbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbi5Db250YWluc0l0ZW1XaXRoTmFtZShpdGVtTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kTGlzdERlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgYWRkIHRoZSBpdGVtIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgY291bGQgY29tZSBmcm9tIGVpdGhlciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIG9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZExpc3REZWYubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZExpc3REZWYgPSBvcmlnaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGFkZCB0aGUgaXRlbSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1OYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCIgdG8gdGhpcyBsaXN0IGJlY2F1c2UgaXQgaXNuJ3Qga25vd24gdG8gYW55IGxpc3QgZGVmaW5pdGlvbnMgcHJldmlvdXNseSBhc3NvY2lhdGVkIHdpdGggdGhpcyBsaXN0LlwiKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RJdGVtKGZvdW5kTGlzdERlZi5uYW1lLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICBsZXQgaXRlbVZhbCA9IGZvdW5kTGlzdERlZi5WYWx1ZUZvckl0ZW0oaXRlbSk7XG4gICAgICAgICAgICB0aGlzLkFkZChpdGVtLCBpdGVtVmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb250YWluc0l0ZW1OYW1lZChpdGVtTmFtZSkge1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PSBpdGVtTmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENvbnRhaW5zS2V5KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXMoa2V5LnNlcmlhbGl6ZWQoKSk7XG4gICAgfVxuICAgIEFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkS2V5ID0ga2V5LnNlcmlhbGl6ZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzKHNlcmlhbGl6ZWRLZXkpKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBhbiBleGNlcHRpb24gdG8gbWF0Y2ggdGhlIEMjIGJlaGF2aW9yLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgTWFwIGFscmVhZHkgY29udGFpbnMgYW4gZW50cnkgZm9yICR7a2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHNlcmlhbGl6ZWRLZXksIHZhbHVlKTtcbiAgICB9XG4gICAgUmVtb3ZlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5LnNlcmlhbGl6ZWQoKSk7XG4gICAgfVxuICAgIGdldCBDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9XG4gICAgZ2V0IG9yaWdpbk9mTWF4SXRlbSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2lucyA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXhPcmlnaW5OYW1lID0gdGhpcy5tYXhJdGVtLktleS5vcmlnaW5OYW1lO1xuICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5zLmV2ZXJ5KChvcmlnaW4pID0+IHtcbiAgICAgICAgICAgIGlmIChvcmlnaW4ubmFtZSA9PSBtYXhPcmlnaW5OYW1lKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGdldCBvcmlnaW5OYW1lcygpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luTmFtZXMgPT0gbnVsbCAmJiB0aGlzLkNvdW50ID4gMClcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtdO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vcmlnaW5OYW1lcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgW2tleV0gb2YgdGhpcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5vcmlnaW5OYW1lID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIml0ZW0ub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcy5wdXNoKGl0ZW0ub3JpZ2luTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbk5hbWVzO1xuICAgIH1cbiAgICBTZXRJbml0aWFsT3JpZ2luTmFtZShpbml0aWFsT3JpZ2luTmFtZSkge1xuICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IFtpbml0aWFsT3JpZ2luTmFtZV07XG4gICAgfVxuICAgIFNldEluaXRpYWxPcmlnaW5OYW1lcyhpbml0aWFsT3JpZ2luTmFtZXMpIHtcbiAgICAgICAgaWYgKGluaXRpYWxPcmlnaW5OYW1lcyA9PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luTmFtZXMgPSBudWxsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5OYW1lcyA9IGluaXRpYWxPcmlnaW5OYW1lcy5zbGljZSgpOyAvLyBzdG9yZSBhIGNvcHlcbiAgICB9XG4gICAgZ2V0IG1heEl0ZW0oKSB7XG4gICAgICAgIGxldCBtYXggPSB7XG4gICAgICAgICAgICBLZXk6IElua0xpc3RJdGVtLk51bGwsXG4gICAgICAgICAgICBWYWx1ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbCB8fCB2YWx1ZSA+IG1heC5WYWx1ZSlcbiAgICAgICAgICAgICAgICBtYXggPSB7IEtleTogaXRlbSwgVmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IG1pbkl0ZW0oKSB7XG4gICAgICAgIGxldCBtaW4gPSB7XG4gICAgICAgICAgICBLZXk6IElua0xpc3RJdGVtLk51bGwsXG4gICAgICAgICAgICBWYWx1ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgIGlmIChtaW4uS2V5LmlzTnVsbCB8fCB2YWx1ZSA8IG1pbi5WYWx1ZSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IHsgS2V5OiBpdGVtLCBWYWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgaW52ZXJzZSgpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3JpZ2luLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLkNvbnRhaW5zS2V5KGl0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdC5BZGQoaXRlbSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgZ2V0IGFsbCgpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5zICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiB0aGlzLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2Ygb3JpZ2luLml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5zZXQoaXRlbS5zZXJpYWxpemVkKCksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIFVuaW9uKG90aGVyTGlzdCkge1xuICAgICAgICBsZXQgdW5pb24gPSBuZXcgSW5rTGlzdCh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIG90aGVyTGlzdCkge1xuICAgICAgICAgICAgdW5pb24uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlvbjtcbiAgICB9XG4gICAgSW50ZXJzZWN0KG90aGVyTGlzdCkge1xuICAgICAgICBsZXQgaW50ZXJzZWN0aW9uID0gbmV3IElua0xpc3QoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChvdGhlckxpc3QuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICBXaXRob3V0KGxpc3RUb1JlbW92ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IElua0xpc3QodGhpcyk7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIGxpc3RUb1JlbW92ZSkge1xuICAgICAgICAgICAgcmVzdWx0LmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvbnRhaW5zKG90aGVyTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBba2V5XSBvZiBvdGhlckxpc3QpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIEdyZWF0ZXJUaGFuKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluSXRlbS5WYWx1ZSA+IG90aGVyTGlzdC5tYXhJdGVtLlZhbHVlO1xuICAgIH1cbiAgICBHcmVhdGVyVGhhbk9yRXF1YWxzKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5Db3VudCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1pbkl0ZW0uVmFsdWUgPj0gb3RoZXJMaXN0Lm1pbkl0ZW0uVmFsdWUgJiZcbiAgICAgICAgICAgIHRoaXMubWF4SXRlbS5WYWx1ZSA+PSBvdGhlckxpc3QubWF4SXRlbS5WYWx1ZSk7XG4gICAgfVxuICAgIExlc3NUaGFuKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4SXRlbS5WYWx1ZSA8IG90aGVyTGlzdC5taW5JdGVtLlZhbHVlO1xuICAgIH1cbiAgICBMZXNzVGhhbk9yRXF1YWxzKG90aGVyTGlzdCkge1xuICAgICAgICBpZiAob3RoZXJMaXN0LkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1heEl0ZW0uVmFsdWUgPD0gb3RoZXJMaXN0Lm1heEl0ZW0uVmFsdWUgJiZcbiAgICAgICAgICAgIHRoaXMubWluSXRlbS5WYWx1ZSA8PSBvdGhlckxpc3QubWluSXRlbS5WYWx1ZSk7XG4gICAgfVxuICAgIE1heEFzTGlzdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbmtMaXN0KHRoaXMubWF4SXRlbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgIH1cbiAgICBNaW5Bc0xpc3QoKSB7XG4gICAgICAgIGlmICh0aGlzLkNvdW50ID4gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCh0aGlzLm1pbkl0ZW0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IElua0xpc3QoKTtcbiAgICB9XG4gICAgTGlzdFdpdGhTdWJSYW5nZShtaW5Cb3VuZCwgbWF4Qm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuQ291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5rTGlzdCgpO1xuICAgICAgICBsZXQgb3JkZXJlZCA9IHRoaXMub3JkZXJlZEl0ZW1zO1xuICAgICAgICBsZXQgbWluVmFsdWUgPSAwO1xuICAgICAgICBsZXQgbWF4VmFsdWUgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIobWluQm91bmQpKSB7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IG1pbkJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1pbkJvdW5kIGluc3RhbmNlb2YgSW5rTGlzdCAmJiBtaW5Cb3VuZC5Db3VudCA+IDApXG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSBtaW5Cb3VuZC5taW5JdGVtLlZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG1heEJvdW5kKSkge1xuICAgICAgICAgICAgbWF4VmFsdWUgPSBtYXhCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtaW5Cb3VuZCBpbnN0YW5jZW9mIElua0xpc3QgJiYgbWluQm91bmQuQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gbWF4Qm91bmQubWF4SXRlbS5WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3ViTGlzdCA9IG5ldyBJbmtMaXN0KCk7XG4gICAgICAgIHN1Ykxpc3QuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKHRoaXMub3JpZ2luTmFtZXMpO1xuICAgICAgICBmb3IgKGxldCBpdGVtIG9mIG9yZGVyZWQpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLlZhbHVlID49IG1pblZhbHVlICYmIGl0ZW0uVmFsdWUgPD0gbWF4VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzdWJMaXN0LkFkZChpdGVtLktleSwgaXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Ykxpc3Q7XG4gICAgfVxuICAgIEVxdWFscyhvdGhlcklua0xpc3QpIHtcbiAgICAgICAgaWYgKG90aGVySW5rTGlzdCBpbnN0YW5jZW9mIElua0xpc3QgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJJbmtMaXN0LkNvdW50ICE9IHRoaXMuQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IFtrZXldIG9mIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICghb3RoZXJJbmtMaXN0LmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gR2V0SGFzaENvZGUgbm90IGltcGxlbWVudGVkXG4gICAgZ2V0IG9yZGVyZWRJdGVtcygpIHtcbiAgICAgICAgLy8gTGlzdDxLZXlWYWx1ZVBhaXI8SW5rTGlzdEl0ZW0sIGludD4+XG4gICAgICAgIGxldCBvcmRlcmVkID0gbmV3IEFycmF5KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICBvcmRlcmVkLnB1c2goeyBLZXk6IGl0ZW0sIFZhbHVlOiB2YWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBvcmRlcmVkLnNvcnQoKHgsIHkpID0+IHtcbiAgICAgICAgICAgIGlmICh4LktleS5vcmlnaW5OYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ4LktleS5vcmlnaW5OYW1lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHkuS2V5Lm9yaWdpbk5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInkuS2V5Lm9yaWdpbk5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeC5WYWx1ZSA9PSB5LlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHguS2V5Lm9yaWdpbk5hbWUubG9jYWxlQ29tcGFyZSh5LktleS5vcmlnaW5OYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRoaXMgYml0IGludG8gYSBudW1iZXJDb21wYXJlVG8gbWV0aG9kP1xuICAgICAgICAgICAgICAgIGlmICh4LlZhbHVlIDwgeS5WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIHJldHVybiB4LlZhbHVlID4geS5WYWx1ZSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG9yZGVyZWQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgb3JkZXJlZCA9IHRoaXMub3JkZXJlZEl0ZW1zO1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcmRlcmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICAgICAgc2IuQXBwZW5kKFwiLCBcIik7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG9yZGVyZWRbaV0uS2V5O1xuICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgc2IuQXBwZW5kKGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzYi50b1N0cmluZygpO1xuICAgIH1cbiAgICAvLyBjYXN0aW5nIGEgSW5rTGlzdCB0byBhIE51bWJlciwgZm9yIHNvbWVyZWFzb24sIGFjdHVhbGx5IGdpdmVzIGEgbnVtYmVyLlxuICAgIC8vIFRoaXMgbWVzc2VzIHVwIHRoZSB0eXBlIGRldGVjdGlvbiB3aGVuIGNyZWF0aW5nIGEgVmFsdWUgZnJvbSBhIElua0xpc3QuXG4gICAgLy8gUmV0dXJuaW5nIE5hTiBoZXJlIHByZXZlbnRzIHRoYXQuXG4gICAgdmFsdWVPZigpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG59XG5leHBvcnRzLklua0xpc3QgPSBJbmtMaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5rTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNvblNlcmlhbGlzYXRpb24gPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IEdsdWVfMSA9IHJlcXVpcmUoXCIuL0dsdWVcIik7XG5jb25zdCBDb250cm9sQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29udHJvbENvbW1hbmRcIik7XG5jb25zdCBQdXNoUG9wXzEgPSByZXF1aXJlKFwiLi9QdXNoUG9wXCIpO1xuY29uc3QgRGl2ZXJ0XzEgPSByZXF1aXJlKFwiLi9EaXZlcnRcIik7XG5jb25zdCBDaG9pY2VQb2ludF8xID0gcmVxdWlyZShcIi4vQ2hvaWNlUG9pbnRcIik7XG5jb25zdCBWYXJpYWJsZVJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVSZWZlcmVuY2VcIik7XG5jb25zdCBWYXJpYWJsZUFzc2lnbm1lbnRfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlQXNzaWdubWVudFwiKTtcbmNvbnN0IE5hdGl2ZUZ1bmN0aW9uQ2FsbF8xID0gcmVxdWlyZShcIi4vTmF0aXZlRnVuY3Rpb25DYWxsXCIpO1xuY29uc3QgVm9pZF8xID0gcmVxdWlyZShcIi4vVm9pZFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENob2ljZV8xID0gcmVxdWlyZShcIi4vQ2hvaWNlXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25fMSA9IHJlcXVpcmUoXCIuL0xpc3REZWZpbml0aW9uXCIpO1xuY29uc3QgTGlzdERlZmluaXRpb25zT3JpZ2luXzEgPSByZXF1aXJlKFwiLi9MaXN0RGVmaW5pdGlvbnNPcmlnaW5cIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBKc29uU2VyaWFsaXNhdGlvbiB7XG4gICAgc3RhdGljIEpBcnJheVRvUnVudGltZU9iakxpc3QoakFycmF5LCBza2lwTGFzdCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBjb3VudCA9IGpBcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChza2lwTGFzdClcbiAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgIGxldCBsaXN0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGpUb2sgPSBqQXJyYXlbaV07XG4gICAgICAgICAgICBsZXQgcnVudGltZU9iaiA9IHRoaXMuSlRva2VuVG9SdW50aW1lT2JqZWN0KGpUb2spO1xuICAgICAgICAgICAgaWYgKHJ1bnRpbWVPYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInJ1bnRpbWVPYmpcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2gocnVudGltZU9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZURpY3Rpb25hcnlSdW50aW1lT2Jqcyh3cml0ZXIsIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGRpY3Rpb25hcnkpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgdmFsdWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlTGlzdFJ1bnRpbWVPYmpzKHdyaXRlciwgbGlzdCkge1xuICAgICAgICB3cml0ZXIuV3JpdGVBcnJheVN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGxpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVSdW50aW1lT2JqZWN0KHdyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUludERpY3Rpb25hcnkod3JpdGVyLCBkaWN0KSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkaWN0KSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIFdyaXRlUnVudGltZU9iamVjdCh3cml0ZXIsIG9iaikge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBjb250YWluZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXZlcnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBEaXZlcnRfMS5EaXZlcnQpO1xuICAgICAgICBpZiAoZGl2ZXJ0KSB7XG4gICAgICAgICAgICBsZXQgZGl2VHlwZUtleSA9IFwiLT5cIjtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcIngoKVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2ZXJ0LnB1c2hlc1RvU3RhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoZGl2ZXJ0LnN0YWNrUHVzaFR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcImYoKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkaXZlcnQuc3RhY2tQdXNoVHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdlR5cGVLZXkgPSBcIi0+dC0+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRhcmdldFN0cjtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRTdHIgPSBkaXZlcnQudmFyaWFibGVEaXZlcnROYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0U3RyID0gZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoZGl2VHlwZUtleSwgdGFyZ2V0U3RyKTtcbiAgICAgICAgICAgIGlmIChkaXZlcnQuaGFzVmFyaWFibGVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZhclwiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXZlcnQuaXNDb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY1wiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXZlcnQuZXh0ZXJuYWxBcmdzID4gMCkge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwiZXhBcmdzXCIsIGRpdmVydC5leHRlcm5hbEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZVBvaW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgQ2hvaWNlUG9pbnRfMS5DaG9pY2VQb2ludCk7XG4gICAgICAgIGlmIChjaG9pY2VQb2ludCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiKlwiLCBjaG9pY2VQb2ludC5wYXRoU3RyaW5nT25DaG9pY2UpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJmbGdcIiwgY2hvaWNlUG9pbnQuZmxhZ3MpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBpZiAoaW50VmFsKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnQoaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmxvYXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkZsb2F0VmFsdWUpO1xuICAgICAgICBpZiAoZmxvYXRWYWwpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUZsb2F0KGZsb2F0VmFsLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgIGlmIChzdHJWYWwpIHtcbiAgICAgICAgICAgIGlmIChzdHJWYWwuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlKFwiXFxuXCIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ1N0YXJ0KCk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nSW5uZXIoXCJeXCIpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVN0cmluZ0lubmVyKHN0clZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlU3RyaW5nRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpc3RWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGlmIChsaXN0VmFsKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlSW5rTGlzdCh3cml0ZXIsIGxpc3RWYWwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkaXZUYXJnZXRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgaWYgKGRpdlRhcmdldFZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGlmIChkaXZUYXJnZXRWYWwudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImRpdlRhcmdldFZhbC52YWx1ZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiXi0+XCIsIGRpdlRhcmdldFZhbC52YWx1ZS5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YXJQdHJWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKHZhclB0clZhbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiXnZhclwiLCB2YXJQdHJWYWwudmFsdWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJjaVwiLCB2YXJQdHJWYWwuY29udGV4dEluZGV4KTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgR2x1ZV8xLkdsdWUpO1xuICAgICAgICBpZiAoZ2x1ZSkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKFwiPD5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRyb2xDbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgaWYgKGNvbnRyb2xDbWQpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZShKc29uU2VyaWFsaXNhdGlvbi5fY29udHJvbENvbW1hbmROYW1lc1tjb250cm9sQ21kLmNvbW1hbmRUeXBlXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hdGl2ZUZ1bmMgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwpO1xuICAgICAgICBpZiAobmF0aXZlRnVuYykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBuYXRpdmVGdW5jLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcIl5cIilcbiAgICAgICAgICAgICAgICBuYW1lID0gXCJMXlwiO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YXJSZWYgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKTtcbiAgICAgICAgaWYgKHZhclJlZikge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGxldCByZWFkQ291bnRQYXRoID0gdmFyUmVmLnBhdGhTdHJpbmdGb3JDb3VudDtcbiAgICAgICAgICAgIGlmIChyZWFkQ291bnRQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIkNOVD9cIiwgcmVhZENvdW50UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIlZBUj9cIiwgdmFyUmVmLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhckFzcyA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhcmlhYmxlQXNzaWdubWVudF8xLlZhcmlhYmxlQXNzaWdubWVudCk7XG4gICAgICAgIGlmICh2YXJBc3MpIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgICAgICBsZXQga2V5ID0gdmFyQXNzLmlzR2xvYmFsID8gXCJWQVI9XCIgOiBcInRlbXA9XCI7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShrZXksIHZhckFzcy52YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgLy8gUmVhc3NpZ25tZW50P1xuICAgICAgICAgICAgaWYgKCF2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbilcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInJlXCIsIHRydWUpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZvaWRPYmogPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWb2lkXzEuVm9pZCk7XG4gICAgICAgIGlmICh2b2lkT2JqKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGUoXCJ2b2lkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBUYWdfMS5UYWcpO1xuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIjXCIsIHRhZy50ZXh0KTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaG9pY2UgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDaG9pY2VfMS5DaG9pY2UpO1xuICAgICAgICBpZiAoY2hvaWNlKSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlQ2hvaWNlKHdyaXRlciwgY2hvaWNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY29udmVydCBydW50aW1lIG9iamVjdCB0byBKc29uIHRva2VuOiBcIiArIG9iaik7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9EaWN0aW9uYXJ5UnVudGltZU9ianMoak9iamVjdCkge1xuICAgICAgICBsZXQgZGljdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGpPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChqT2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5rT2JqZWN0ID0gdGhpcy5KVG9rZW5Ub1J1bnRpbWVPYmplY3Qoak9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5rT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaW5rT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaWN0LnNldChrZXksIGlua09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfVxuICAgIHN0YXRpYyBKT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3QpIHtcbiAgICAgICAgbGV0IGRpY3QgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBqT2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoak9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGljdC5zZXQoa2V5LCBwYXJzZUludChqT2JqZWN0W2tleV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGljdDtcbiAgICB9XG4gICAgc3RhdGljIEpUb2tlblRvUnVudGltZU9iamVjdCh0b2tlbikge1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSBcIm51bWJlclwiICYmICFpc05hTih0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRva2VuLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBTdHJpbmcgdmFsdWVcbiAgICAgICAgICAgIGxldCBmaXJzdENoYXIgPSBzdHJbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09IFwiXlwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzdHIuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0Q2hhciA9PSBcIlxcblwiICYmIHN0ci5sZW5ndGggPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIik7XG4gICAgICAgICAgICAvLyBHbHVlXG4gICAgICAgICAgICBpZiAoc3RyID09IFwiPD5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEdsdWVfMS5HbHVlKCk7XG4gICAgICAgICAgICAvLyBDb250cm9sIGNvbW1hbmRzICh3b3VsZCBsb29raW5nIHVwIGluIGEgaGFzaCBzZXQgYmUgZmFzdGVyPylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSnNvblNlcmlhbGlzYXRpb24uX2NvbnRyb2xDb21tYW5kTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgY21kTmFtZSA9IEpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzdHIgPT0gY21kTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTmF0aXZlIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHN0ciA9PSBcIkxeXCIpXG4gICAgICAgICAgICAgICAgc3RyID0gXCJeXCI7XG4gICAgICAgICAgICBpZiAoTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxFeGlzdHNXaXRoTmFtZShzdHIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBOYXRpdmVGdW5jdGlvbkNhbGxfMS5OYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbFdpdGhOYW1lKHN0cik7XG4gICAgICAgICAgICAvLyBQb3BcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCItPi0+XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuUG9wVHVubmVsKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChzdHIgPT0gXCJ+cmV0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuUG9wRnVuY3Rpb24oKTtcbiAgICAgICAgICAgIC8vIFZvaWRcbiAgICAgICAgICAgIGlmIChzdHIgPT0gXCJ2b2lkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWb2lkXzEuVm9pZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdG9rZW47XG4gICAgICAgICAgICBsZXQgcHJvcFZhbHVlO1xuICAgICAgICAgICAgLy8gRGl2ZXJ0IHRhcmdldCB2YWx1ZSB0byBwYXRoXG4gICAgICAgICAgICBpZiAob2JqW1wiXi0+XCJdKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gb2JqW1wiXi0+XCJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZShuZXcgUGF0aF8xLlBhdGgocHJvcFZhbHVlLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFZhcmlhYmxlUG9pbnRlclZhbHVlXG4gICAgICAgICAgICBpZiAob2JqW1wiXnZhclwiXSkge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSA9IG9ialtcIl52YXJcIl07XG4gICAgICAgICAgICAgICAgbGV0IHZhclB0ciA9IG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoXCJjaVwiIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCJjaVwiXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyUHRyLmNvbnRleHRJbmRleCA9IHBhcnNlSW50KHByb3BWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YXJQdHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEaXZlcnRcbiAgICAgICAgICAgIGxldCBpc0RpdmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIGxldCBleHRlcm5hbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCItPlwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZigpXCJdKSkge1xuICAgICAgICAgICAgICAgIGlzRGl2ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwdXNoZXNUb1N0YWNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCItPnQtPlwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHVzaGVzVG9TdGFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGl2UHVzaFR5cGUgPSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIngoKVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc0RpdmVydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHB1c2hlc1RvU3RhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkaXZQdXNoVHlwZSA9IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpdmVydCkge1xuICAgICAgICAgICAgICAgIGxldCBkaXZlcnQgPSBuZXcgRGl2ZXJ0XzEuRGl2ZXJ0KCk7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LnB1c2hlc1RvU3RhY2sgPSBwdXNoZXNUb1N0YWNrO1xuICAgICAgICAgICAgICAgIGRpdmVydC5zdGFja1B1c2hUeXBlID0gZGl2UHVzaFR5cGU7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LmlzRXh0ZXJuYWwgPSBleHRlcm5hbDtcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcHJvcFZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJ2YXJcIl0pKVxuICAgICAgICAgICAgICAgICAgICBkaXZlcnQudmFyaWFibGVEaXZlcnROYW1lID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmcgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgZGl2ZXJ0LmlzQ29uZGl0aW9uYWwgPSAhIW9ialtcImNcIl07XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZXhBcmdzXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVydC5leHRlcm5hbEFyZ3MgPSBwYXJzZUludChwcm9wVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2ZXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hvaWNlXG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIipcIl0pKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KCk7XG4gICAgICAgICAgICAgICAgY2hvaWNlLnBhdGhTdHJpbmdPbkNob2ljZSA9IHByb3BWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiZmxnXCJdKSlcbiAgICAgICAgICAgICAgICAgICAgY2hvaWNlLmZsYWdzID0gcGFyc2VJbnQocHJvcFZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGUgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAoKHByb3BWYWx1ZSA9IG9ialtcIlZBUj9cIl0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWYXJpYWJsZVJlZmVyZW5jZV8xLlZhcmlhYmxlUmVmZXJlbmNlKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChwcm9wVmFsdWUgPSBvYmpbXCJDTlQ/XCJdKSkge1xuICAgICAgICAgICAgICAgIGxldCByZWFkQ291bnRWYXJSZWYgPSBuZXcgVmFyaWFibGVSZWZlcmVuY2VfMS5WYXJpYWJsZVJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIHJlYWRDb3VudFZhclJlZi5wYXRoU3RyaW5nRm9yQ291bnQgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZENvdW50VmFyUmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFyaWFibGUgYXNzaWdubWVudFxuICAgICAgICAgICAgbGV0IGlzVmFyQXNzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaXNHbG9iYWxWYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wiVkFSPVwiXSkpIHtcbiAgICAgICAgICAgICAgICBpc1ZhckFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaXNHbG9iYWxWYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKHByb3BWYWx1ZSA9IG9ialtcInRlbXA9XCJdKSkge1xuICAgICAgICAgICAgICAgIGlzVmFyQXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpc0dsb2JhbFZhciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFyQXNzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhck5hbWUgPSBwcm9wVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgaXNOZXdEZWNsID0gIW9ialtcInJlXCJdO1xuICAgICAgICAgICAgICAgIGxldCB2YXJBc3MgPSBuZXcgVmFyaWFibGVBc3NpZ25tZW50XzEuVmFyaWFibGVBc3NpZ25tZW50KHZhck5hbWUsIGlzTmV3RGVjbCk7XG4gICAgICAgICAgICAgICAgdmFyQXNzLmlzR2xvYmFsID0gaXNHbG9iYWxWYXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhckFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmpbXCIjXCJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBvYmpbXCIjXCJdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGFnXzEuVGFnKHByb3BWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExpc3QgdmFsdWVcbiAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wibGlzdFwiXSkpIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgbGlzdENvbnRlbnQgPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pcHJvcFZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBsaXN0Q29udGVudCA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICBsZXQgcmF3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICAgICAgICAgIGlmICgocHJvcFZhbHVlID0gb2JqW1wib3JpZ2luc1wiXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIG5hbWVzQXNPYmpzID0gKExpc3Q8b2JqZWN0Pilwcm9wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lc0FzT2JqcyA9IHByb3BWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmF3TGlzdC5TZXRJbml0aWFsT3JpZ2luTmFtZXMobmFtZXNBc09ianMuQ2FzdDxzdHJpbmc+KCkuVG9MaXN0KCkpO1xuICAgICAgICAgICAgICAgICAgICByYXdMaXN0LlNldEluaXRpYWxPcmlnaW5OYW1lcyhuYW1lc0FzT2Jqcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBsaXN0Q29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdENvbnRlbnQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVUb1ZhbCA9IGxpc3RDb250ZW50W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0oa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBwYXJzZUludChuYW1lVG9WYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5BZGQoaXRlbSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJhd0xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ialtcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiXSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkpPYmplY3RUb0Nob2ljZShvYmopO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5IGlzIGFsd2F5cyBhIFJ1bnRpbWUuQ29udGFpbmVyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSkFycmF5VG9Db250YWluZXIodG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbCB8fCB0b2tlbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjb252ZXJ0IHRva2VuIHRvIHJ1bnRpbWUgb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBjb250YWluZXIsIHdpdGhvdXROYW1lID0gZmFsc2UpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNvbnRhaW5lclwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRhaW5lci5jb250ZW50KVxuICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCBjKTtcbiAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnQgPSBjb250YWluZXIubmFtZWRPbmx5Q29udGVudDtcbiAgICAgICAgbGV0IGNvdW50RmxhZ3MgPSBjb250YWluZXIuY291bnRGbGFncztcbiAgICAgICAgbGV0IGhhc05hbWVQcm9wZXJ0eSA9IGNvbnRhaW5lci5uYW1lICE9IG51bGwgJiYgIXdpdGhvdXROYW1lO1xuICAgICAgICBsZXQgaGFzVGVybWluYXRvciA9IG5hbWVkT25seUNvbnRlbnQgIT0gbnVsbCB8fCBjb3VudEZsYWdzID4gMCB8fCBoYXNOYW1lUHJvcGVydHk7XG4gICAgICAgIGlmIChoYXNUZXJtaW5hdG9yKSB7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lZE9ubHlDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBuYW1lZE9ubHlDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXk7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWVkQ29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Xcml0ZVJ1bnRpbWVDb250YWluZXIod3JpdGVyLCBuYW1lZENvbnRhaW5lciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzTmFtZVByb3BlcnR5KVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCIjblwiLCBjb250YWluZXIubmFtZSk7XG4gICAgICAgIGlmIChoYXNUZXJtaW5hdG9yKVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZU51bGwoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlFbmQoKTtcbiAgICB9XG4gICAgc3RhdGljIEpBcnJheVRvQ29udGFpbmVyKGpBcnJheSkge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICBjb250YWluZXIuY29udGVudCA9IHRoaXMuSkFycmF5VG9SdW50aW1lT2JqTGlzdChqQXJyYXksIHRydWUpO1xuICAgICAgICBsZXQgdGVybWluYXRpbmdPYmogPSBqQXJyYXlbakFycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGVybWluYXRpbmdPYmogIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IG5hbWVkT25seUNvbnRlbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGVybWluYXRpbmdPYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiI2ZcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuY291bnRGbGFncyA9IHBhcnNlSW50KHRlcm1pbmF0aW5nT2JqW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChrZXkgPT0gXCIjblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lID0gdGVybWluYXRpbmdPYmpba2V5XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVkQ29udGVudEl0ZW0gPSB0aGlzLkpUb2tlblRvUnVudGltZU9iamVjdCh0ZXJtaW5hdGluZ09ialtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIG5hbWVkU3ViQ29udGFpbmVyID0gbmFtZWRDb250ZW50SXRlbSBhcyBDb250YWluZXI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lZFN1YkNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChuYW1lZENvbnRlbnRJdGVtLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZWRTdWJDb250YWluZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lZFN1YkNvbnRhaW5lci5uYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBuYW1lZE9ubHlDb250ZW50LnNldChrZXksIG5hbWVkQ29udGVudEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lZE9ubHlDb250ZW50ID0gbmFtZWRPbmx5Q29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICBzdGF0aWMgSk9iamVjdFRvQ2hvaWNlKGpPYmopIHtcbiAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VfMS5DaG9pY2UoKTtcbiAgICAgICAgY2hvaWNlLnRleHQgPSBqT2JqW1widGV4dFwiXS50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2UuaW5kZXggPSBwYXJzZUludChqT2JqW1wiaW5kZXhcIl0pO1xuICAgICAgICBjaG9pY2Uuc291cmNlUGF0aCA9IGpPYmpbXCJvcmlnaW5hbENob2ljZVBhdGhcIl0udG9TdHJpbmcoKTtcbiAgICAgICAgY2hvaWNlLm9yaWdpbmFsVGhyZWFkSW5kZXggPSBwYXJzZUludChqT2JqW1wib3JpZ2luYWxUaHJlYWRJbmRleFwiXSk7XG4gICAgICAgIGNob2ljZS5wYXRoU3RyaW5nT25DaG9pY2UgPSBqT2JqW1widGFyZ2V0UGF0aFwiXS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gY2hvaWNlO1xuICAgIH1cbiAgICBzdGF0aWMgV3JpdGVDaG9pY2Uod3JpdGVyLCBjaG9pY2UpIHtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ0ZXh0XCIsIGNob2ljZS50ZXh0KTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJpbmRleFwiLCBjaG9pY2UuaW5kZXgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIm9yaWdpbmFsQ2hvaWNlUGF0aFwiLCBjaG9pY2Uuc291cmNlUGF0aCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZUludFByb3BlcnR5KFwib3JpZ2luYWxUaHJlYWRJbmRleFwiLCBjaG9pY2Uub3JpZ2luYWxUaHJlYWRJbmRleCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwidGFyZ2V0UGF0aFwiLCBjaG9pY2UucGF0aFN0cmluZ09uQ2hvaWNlKTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgfVxuICAgIHN0YXRpYyBXcml0ZUlua0xpc3Qod3JpdGVyLCBsaXN0VmFsKSB7XG4gICAgICAgIGxldCByYXdMaXN0ID0gbGlzdFZhbC52YWx1ZTtcbiAgICAgICAgaWYgKHJhd0xpc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmF3TGlzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KFwibGlzdFwiKTtcbiAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsXSBvZiByYXdMaXN0KSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IElua0xpc3RfMS5JbmtMaXN0SXRlbS5mcm9tU2VyaWFsaXplZEtleShrZXkpO1xuICAgICAgICAgICAgbGV0IGl0ZW1WYWwgPSB2YWw7XG4gICAgICAgICAgICBpZiAoaXRlbS5pdGVtTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiaXRlbS5pdGVtTmFtZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZVN0YXJ0KCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihpdGVtLm9yaWdpbk5hbWUgPyBpdGVtLm9yaWdpbk5hbWUgOiBcIj9cIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihcIi5cIik7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5TmFtZUVuZCgpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlKGl0ZW1WYWwpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgaWYgKHJhd0xpc3QuQ291bnQgPT0gMCAmJlxuICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5OYW1lcyAhPSBudWxsICYmXG4gICAgICAgICAgICByYXdMaXN0Lm9yaWdpbk5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJvcmlnaW5zXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlQXJyYXlTdGFydCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiByYXdMaXN0Lm9yaWdpbk5hbWVzKVxuICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZShuYW1lKTtcbiAgICAgICAgICAgIHdyaXRlci5Xcml0ZUFycmF5RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgTGlzdERlZmluaXRpb25zVG9KVG9rZW4ob3JpZ2luKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmIG9mIG9yaWdpbi5saXN0cykge1xuICAgICAgICAgICAgbGV0IGxpc3REZWZKc29uID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGRlZi5pdGVtcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbU5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJpdGVtLml0ZW1OYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0RGVmSnNvbltpdGVtLml0ZW1OYW1lXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtkZWYubmFtZV0gPSBsaXN0RGVmSnNvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgSlRva2VuVG9MaXN0RGVmaW5pdGlvbnMob2JqKSB7XG4gICAgICAgIC8vIHZhciBkZWZzT2JqID0gKERpY3Rpb25hcnk8c3RyaW5nLCBvYmplY3Q+KW9iajtcbiAgICAgICAgbGV0IGRlZnNPYmogPSBvYmo7XG4gICAgICAgIGxldCBhbGxEZWZzID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBkZWZzT2JqKSB7XG4gICAgICAgICAgICBpZiAoZGVmc09iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBrZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAvLyB2YXIgbGlzdERlZkpzb24gPSAoRGljdGlvbmFyeTxzdHJpbmcsIG9iamVjdD4pa3YuVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3REZWZKc29uID0gZGVmc09ialtrZXldO1xuICAgICAgICAgICAgICAgIC8vIENhc3QgKHN0cmluZywgb2JqZWN0KSB0byAoc3RyaW5nLCBpbnQpIGZvciBpdGVtc1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lVmFsdWVLZXkgaW4gbGlzdERlZkpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZnNPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5hbWVWYWx1ZSA9IGxpc3REZWZKc29uW25hbWVWYWx1ZUtleV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXQobmFtZVZhbHVlS2V5LCBwYXJzZUludChuYW1lVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVmID0gbmV3IExpc3REZWZpbml0aW9uXzEuTGlzdERlZmluaXRpb24obmFtZSwgaXRlbXMpO1xuICAgICAgICAgICAgICAgIGFsbERlZnMucHVzaChkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGlzdERlZmluaXRpb25zT3JpZ2luXzEuTGlzdERlZmluaXRpb25zT3JpZ2luKGFsbERlZnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNvblNlcmlhbGlzYXRpb24gPSBKc29uU2VyaWFsaXNhdGlvbjtcbkpzb25TZXJpYWxpc2F0aW9uLl9jb250cm9sQ29tbWFuZE5hbWVzID0gKCgpID0+IHtcbiAgICBsZXQgX2NvbnRyb2xDb21tYW5kTmFtZXMgPSBbXTtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxTdGFydF0gPSBcImV2XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsT3V0cHV0XSA9IFwib3V0XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FdmFsRW5kXSA9IFwiL2V2XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5EdXBsaWNhdGVdID0gXCJkdVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWVdID0gXCJwb3BcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlBvcEZ1bmN0aW9uXSA9IFwifnJldFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsXSA9IFwiLT4tPlwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmddID0gXCJzdHJcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZFN0cmluZ10gPSBcIi9zdHJcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLk5vT3BdID0gXCJub3BcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkNob2ljZUNvdW50XSA9IFwiY2hvaWNlQ250XCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc10gPSBcInR1cm5cIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2VdID0gXCJ0dXJuc1wiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmVhZENvdW50XSA9IFwicmVhZGNcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJhbmRvbV0gPSBcInJuZFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VlZFJhbmRvbV0gPSBcInNybmRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlZpc2l0SW5kZXhdID0gXCJ2aXNpdFwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU2VxdWVuY2VTaHVmZmxlSW5kZXhdID1cbiAgICAgICAgXCJzZXFcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkXSA9IFwidGhyZWFkXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lXSA9IFwiZG9uZVwiO1xuICAgIF9jb250cm9sQ29tbWFuZE5hbWVzW0NvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRW5kXSA9IFwiZW5kXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0RnJvbUludF0gPSBcImxpc3RJbnRcIjtcbiAgICBfY29udHJvbENvbW1hbmROYW1lc1tDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5nZV0gPSBcInJhbmdlXCI7XG4gICAgX2NvbnRyb2xDb21tYW5kTmFtZXNbQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5MaXN0UmFuZG9tXSA9IFwibHJuZFwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UT1RBTF9WQUxVRVM7ICsraSkge1xuICAgICAgICBpZiAoX2NvbnRyb2xDb21tYW5kTmFtZXNbaV0gPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRyb2wgY29tbWFuZCBub3QgYWNjb3VudGVkIGZvciBpbiBzZXJpYWxpc2F0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnRyb2xDb21tYW5kTmFtZXM7XG59KSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SnNvblNlcmlhbGlzYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxpc3REZWZpbml0aW9uID0gdm9pZCAwO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNsYXNzIExpc3REZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBpdGVtcykge1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMgPSBpdGVtcyB8fCBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICBpZiAodGhpcy5faXRlbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5faXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IElua0xpc3RfMS5JbmtMaXN0SXRlbSh0aGlzLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXMuc2V0KGl0ZW0uc2VyaWFsaXplZCgpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zO1xuICAgIH1cbiAgICBWYWx1ZUZvckl0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgbGV0IGludFZhbCA9IHRoaXMuX2l0ZW1OYW1lVG9WYWx1ZXMuZ2V0KGl0ZW0uaXRlbU5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIGludFZhbCAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBpbnRWYWw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBDb250YWluc0l0ZW0oaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uaXRlbU5hbWUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChpdGVtLm9yaWdpbk5hbWUgIT0gdGhpcy5uYW1lKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbU5hbWVUb1ZhbHVlcy5oYXMoaXRlbS5pdGVtTmFtZSk7XG4gICAgfVxuICAgIENvbnRhaW5zSXRlbVdpdGhOYW1lKGl0ZW1OYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmhhcyhpdGVtTmFtZSk7XG4gICAgfVxuICAgIFRyeUdldEl0ZW1XaXRoVmFsdWUodmFsLCBcbiAgICAvKiBvdXQgKi8gaXRlbSkge1xuICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5faXRlbU5hbWVUb1ZhbHVlcykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IHZhbCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBuZXcgSW5rTGlzdF8xLklua0xpc3RJdGVtKHRoaXMubmFtZSwga2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGl0ZW0sIGV4aXN0czogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uTnVsbDtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpdGVtLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFRyeUdldFZhbHVlRm9ySXRlbShpdGVtLCBcbiAgICAvKiBvdXQgKi8gaW50VmFsKSB7XG4gICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSlcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogMCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLl9pdGVtTmFtZVRvVmFsdWVzLmdldChpdGVtLml0ZW1OYW1lKTtcbiAgICAgICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogMCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICByZXR1cm4geyByZXN1bHQ6IHZhbHVlLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3REZWZpbml0aW9uID0gTGlzdERlZmluaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0RGVmaW5pdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlzdERlZmluaXRpb25zT3JpZ2luID0gdm9pZCAwO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBMaXN0RGVmaW5pdGlvbnNPcmlnaW4ge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RzKSB7XG4gICAgICAgIHRoaXMuX2xpc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBsaXN0IG9mIGxpc3RzKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0cy5zZXQobGlzdC5uYW1lLCBsaXN0KTtcbiAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbF0gb2YgbGlzdC5pdGVtcykge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGtleSk7XG4gICAgICAgICAgICAgICAgbGV0IGxpc3RWYWx1ZSA9IG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShpdGVtLCB2YWwpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5pdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpdGVtLml0ZW1OYW1lIGlzIG51bGwgb3IgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fYWxsVW5hbWJpZ3VvdXNMaXN0VmFsdWVDYWNoZS5zZXQoaXRlbS5pdGVtTmFtZSwgbGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLnNldChpdGVtLmZ1bGxOYW1lLCBsaXN0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBsaXN0cygpIHtcbiAgICAgICAgbGV0IGxpc3RPZkxpc3RzID0gW107XG4gICAgICAgIGZvciAobGV0IFssIHZhbHVlXSBvZiB0aGlzLl9saXN0cykge1xuICAgICAgICAgICAgbGlzdE9mTGlzdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RPZkxpc3RzO1xuICAgIH1cbiAgICBUcnlMaXN0R2V0RGVmaW5pdGlvbihuYW1lLCBcbiAgICAvKiBvdXQgKi8gZGVmKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGRlZiwgZXhpc3RzOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGluaXRpYWxseSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm9vbGVhbiBhbmQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgYW4gb3V0LlxuICAgICAgICBsZXQgZGVmaW5pdGlvbiA9IHRoaXMuX2xpc3RzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWYsIGV4aXN0czogZmFsc2UgfTtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBkZWZpbml0aW9uLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgRmluZFNpbmdsZUl0ZW1MaXN0V2l0aE5hbWUobmFtZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwgPSB0aGlzLl9hbGxVbmFtYmlndW91c0xpc3RWYWx1ZUNhY2hlLmdldChuYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0RGVmaW5pdGlvbnNPcmlnaW4gPSBMaXN0RGVmaW5pdGlvbnNPcmlnaW47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaXN0RGVmaW5pdGlvbnNPcmlnaW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hdGl2ZUZ1bmN0aW9uQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBJbmtMaXN0XzEgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNsYXNzIE5hdGl2ZUZ1bmN0aW9uQ2FsbCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnMgPSAwO1xuICAgICAgICB0aGlzLl9wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1Byb3RvdHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25GdW5jcyA9IG51bGw7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgTmF0aXZlRnVuY3Rpb25DYWxsLkdlbmVyYXRlTmF0aXZlRnVuY3Rpb25zSWZOZWNlc3NhcnkoKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICBsZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5faXNQcm90b3R5cGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZQYXJhbWV0ZXJzID0gbnVtYmVyT2ZQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBDYWxsV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmF0aXZlRnVuY3Rpb25DYWxsKGZ1bmN0aW9uTmFtZSk7XG4gICAgfVxuICAgIHN0YXRpYyBDYWxsRXhpc3RzV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMuR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF0aXZlRnVuY3Rpb25zLmdldChmdW5jdGlvbk5hbWUpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hbWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmFtZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Byb3RvdHlwZSkge1xuICAgICAgICAgICAgaWYgKE5hdGl2ZUZ1bmN0aW9uQ2FsbC5fbmF0aXZlRnVuY3Rpb25zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b3R5cGUgPVxuICAgICAgICAgICAgICAgICAgICBOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9ucy5nZXQodGhpcy5fbmFtZSkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbnVtYmVyT2ZQYXJhbWV0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvdG90eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvdG90eXBlLm51bWJlck9mUGFyYW1ldGVycztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IG51bWJlck9mUGFyYW1ldGVycyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9udW1iZXJPZlBhcmFtZXRlcnMgPSB2YWx1ZTtcbiAgICB9XG4gICAgQ2FsbChwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b3R5cGUuQ2FsbChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5udW1iZXJPZlBhcmFtZXRlcnMgIT0gcGFyYW1ldGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhc0xpc3QgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBvZiBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFZvaWRfMS5Wb2lkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKCdBdHRlbXB0aW5nIHRvIHBlcmZvcm0gb3BlcmF0aW9uIG9uIGEgdm9pZCB2YWx1ZS4gRGlkIHlvdSBmb3JnZXQgdG8gXCJyZXR1cm5cIiBhIHZhbHVlIGZyb20gYSBmdW5jdGlvbiB5b3UgY2FsbGVkIGhlcmU/Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFZhbHVlXzEuTGlzdFZhbHVlKVxuICAgICAgICAgICAgICAgIGhhc0xpc3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCA9PSAyICYmIGhhc0xpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb2VyY2VkUGFyYW1zID0gdGhpcy5Db2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUocGFyYW1ldGVycyk7XG4gICAgICAgIGxldCBjb2VyY2VkVHlwZSA9IGNvZXJjZWRQYXJhbXNbMF0udmFsdWVUeXBlO1xuICAgICAgICBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoY29lcmNlZFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29lcmNlZFR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DYWxsVHlwZShjb2VyY2VkUGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2VyY2VkVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5EaXZlcnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZXJjZWRUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxUeXBlKGNvZXJjZWRQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBDYWxsVHlwZShwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlKSB7XG4gICAgICAgIGxldCBwYXJhbTEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlWzBdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgbGV0IHZhbFR5cGUgPSBwYXJhbTEudmFsdWVUeXBlO1xuICAgICAgICBsZXQgdmFsMSA9IHBhcmFtMTtcbiAgICAgICAgbGV0IHBhcmFtQ291bnQgPSBwYXJhbWV0ZXJzT2ZTaW5nbGVUeXBlLmxlbmd0aDtcbiAgICAgICAgaWYgKHBhcmFtQ291bnQgPT0gMiB8fCBwYXJhbUNvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7XG4gICAgICAgICAgICBsZXQgb3BGb3JUeXBlT2JqID0gdGhpcy5fb3BlcmF0aW9uRnVuY3MuZ2V0KHZhbFR5cGUpO1xuICAgICAgICAgICAgaWYgKCFvcEZvclR5cGVPYmopIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBWYWx1ZV8xLlZhbHVlVHlwZVt2YWxUeXBlXTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBwZXJmb3JtIG9wZXJhdGlvbiBcIiArIHRoaXMubmFtZSArIFwiIG9uIFwiICsga2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbUNvdW50ID09IDIpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFyYW0yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc09mU2luZ2xlVHlwZVsxXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbDIgPSBwYXJhbTI7XG4gICAgICAgICAgICAgICAgbGV0IG9wRm9yVHlwZSA9IG9wRm9yVHlwZU9iajtcbiAgICAgICAgICAgICAgICBpZiAodmFsMS52YWx1ZSA9PT0gbnVsbCB8fCB2YWwyLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5DYWxsIEJpbmFyeU9wIHZhbHVlc1wiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0VmFsID0gb3BGb3JUeXBlKHZhbDEudmFsdWUsIHZhbDIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wRm9yVHlwZSA9IG9wRm9yVHlwZU9iajtcbiAgICAgICAgICAgICAgICBpZiAodmFsMS52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbCBVbmFyeU9wIHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRWYWwgPSBvcEZvclR5cGUodmFsMS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjb2RlIGlzIGRpZmZlcmVudCBmcm9tIHVwc3RyZWFtLiBTaW5jZSBKYXZhU2NyaXB0IHRyZWF0c1xuICAgICAgICAgICAgICAgIC8vIGludGVnZXJzIGFuZCBmbG9hdHMgYXMgdGhlIHNhbWUgbnVtYmVycywgaXQncyBpbXBvc3NpYmxlXG4gICAgICAgICAgICAgICAgLy8gdG8gZm9yY2UgYW4gbnVtYmVyIHRvIGJlIGVpdGhlciBhbiBpbnRlZ2VyIG9yIGEgZmxvYXQuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJdCBjYW4gYmUgdXNlZnVsIHRvIGZvcmNlIGEgc3BlY2lmaWMgbnVtYmVyIHR5cGVcbiAgICAgICAgICAgICAgICAvLyAoZXNwZWNpYWxseSBmb3IgZGl2aXNpb25zKSwgc28gdGhlIHJlc3VsdCBvZiBJTlQoKSAmIEZMT0FUKClcbiAgICAgICAgICAgICAgICAvLyBpcyBjb2VyY2VkIHRvIHRoZSB0aGUgcHJvcGVyIHZhbHVlIHR5cGUuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2UgYWxzbyBmb3JjZSBhbGwgb3RoZXIgdW5hcnkgb3BlcmF0aW9uIHRvXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBzYW1lIHZhbHVlIHR5cGUsIGFsdGhvdWdoIHRoaXMgaXMgb25seVxuICAgICAgICAgICAgICAgIC8vIG1lYW5pbmdmdWwgZm9yIG51bWJlcnMuIFNlZSBgVmFsdWUuQ3JlYXRlYC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uYW1lID09PSBOYXRpdmVGdW5jdGlvbkNhbGwuSW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIFZhbHVlXzEuVmFsdWVUeXBlLkludCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gTmF0aXZlRnVuY3Rpb25DYWxsLkZsb2F0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIFZhbHVlXzEuVmFsdWVUeXBlLkZsb2F0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShyZXN1bHRWYWwsIHBhcmFtMS52YWx1ZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbnVtYmVyIG9mIHBhcmFtZXRlcnMgdG8gTmF0aXZlRnVuY3Rpb25DYWxsOiBcIiArXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc09mU2luZ2xlVHlwZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIENhbGxCaW5hcnlMaXN0T3BlcmF0aW9uKHBhcmFtZXRlcnMpIHtcbiAgICAgICAgaWYgKCh0aGlzLm5hbWUgPT0gXCIrXCIgfHwgdGhpcy5uYW1lID09IFwiLVwiKSAmJlxuICAgICAgICAgICAgcGFyYW1ldGVyc1swXSBpbnN0YW5jZW9mIFZhbHVlXzEuTGlzdFZhbHVlICYmXG4gICAgICAgICAgICBwYXJhbWV0ZXJzWzFdIGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uKHBhcmFtZXRlcnMpO1xuICAgICAgICBsZXQgdjEgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhwYXJhbWV0ZXJzWzBdLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgbGV0IHYyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MocGFyYW1ldGVyc1sxXSwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgIGlmICgodGhpcy5uYW1lID09IFwiJiZcIiB8fCB0aGlzLm5hbWUgPT0gXCJ8fFwiKSAmJlxuICAgICAgICAgICAgKHYxLnZhbHVlVHlwZSAhPSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0IHx8IHYyLnZhbHVlVHlwZSAhPSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLl9vcGVyYXRpb25GdW5jc1wiKTtcbiAgICAgICAgICAgIGxldCBvcCA9IHRoaXMuX29wZXJhdGlvbkZ1bmNzLmdldChWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpO1xuICAgICAgICAgICAgaWYgKG9wID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxCaW5hcnlMaXN0T3BlcmF0aW9uIG9wXCIpO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG9wKHYxLmlzVHJ1dGh5ID8gMSA6IDAsIHYyLmlzVHJ1dGh5ID8gMSA6IDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLkludFZhbHVlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYxLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0ICYmIHYyLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQ2FsbFR5cGUoW3YxLCB2Ml0pO1xuICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbiBub3QgY2FsbCB1c2UgXCIgK1xuICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgIFwiIG9wZXJhdGlvbiBvbiBcIiArXG4gICAgICAgICAgICBWYWx1ZV8xLlZhbHVlVHlwZVt2MS52YWx1ZVR5cGVdICtcbiAgICAgICAgICAgIFwiIGFuZCBcIiArXG4gICAgICAgICAgICBWYWx1ZV8xLlZhbHVlVHlwZVt2Mi52YWx1ZVR5cGVdKTtcbiAgICB9XG4gICAgQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24obGlzdEludFBhcmFtcykge1xuICAgICAgICBsZXQgbGlzdFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGxpc3RJbnRQYXJhbXNbMF0sIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGxpc3RJbnRQYXJhbXNbMV0sIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICBsZXQgcmVzdWx0SW5rTGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICBpZiAobGlzdFZhbC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWVcIik7XG4gICAgICAgIGZvciAobGV0IFtsaXN0SXRlbUtleSwgbGlzdEl0ZW1WYWx1ZV0gb2YgbGlzdFZhbC52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IGxpc3RJdGVtID0gSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KGxpc3RJdGVtS2V5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25GdW5jcyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIk5hdGl2ZUZ1bmN0aW9uQ2FsbC5fb3BlcmF0aW9uRnVuY3NcIik7XG4gICAgICAgICAgICBsZXQgaW50T3AgPSB0aGlzLl9vcGVyYXRpb25GdW5jcy5nZXQoVmFsdWVfMS5WYWx1ZVR5cGUuSW50KTtcbiAgICAgICAgICAgIGlmIChpbnRWYWwudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ2FsbExpc3RJbmNyZW1lbnRPcGVyYXRpb24gaW50VmFsLnZhbHVlXCIpO1xuICAgICAgICAgICAgbGV0IHRhcmdldEludCA9IGludE9wKGxpc3RJdGVtVmFsdWUsIGludFZhbC52YWx1ZSk7XG4gICAgICAgICAgICBsZXQgaXRlbU9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGlzdFZhbC52YWx1ZS5vcmlnaW5zID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNhbGxMaXN0SW5jcmVtZW50T3BlcmF0aW9uIGxpc3RWYWwudmFsdWUub3JpZ2luc1wiKTtcbiAgICAgICAgICAgIGZvciAobGV0IG9yaWdpbiBvZiBsaXN0VmFsLnZhbHVlLm9yaWdpbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luLm5hbWUgPT0gbGlzdEl0ZW0ub3JpZ2luTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbU9yaWdpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluY3JlbWVudGVkSXRlbSA9IGl0ZW1PcmlnaW4uVHJ5R2V0SXRlbVdpdGhWYWx1ZSh0YXJnZXRJbnQsIElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jcmVtZW50ZWRJdGVtLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0SW5rTGlzdC5BZGQoaW5jcmVtZW50ZWRJdGVtLnJlc3VsdCwgdGFyZ2V0SW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKHJlc3VsdElua0xpc3QpO1xuICAgIH1cbiAgICBDb2VyY2VWYWx1ZXNUb1NpbmdsZVR5cGUocGFyYW1ldGVyc0luKSB7XG4gICAgICAgIGxldCB2YWxUeXBlID0gVmFsdWVfMS5WYWx1ZVR5cGUuSW50O1xuICAgICAgICBsZXQgc3BlY2lhbENhc2VMaXN0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgb2JqIG9mIHBhcmFtZXRlcnNJbikge1xuICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsLnZhbHVlVHlwZSA+IHZhbFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YWxUeXBlID0gdmFsLnZhbHVlVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsQ2FzZUxpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtZXRlcnNPdXQgPSBbXTtcbiAgICAgICAgaWYgKFZhbHVlXzEuVmFsdWVUeXBlW3ZhbFR5cGVdID09IFZhbHVlXzEuVmFsdWVUeXBlW1ZhbHVlXzEuVmFsdWVUeXBlLkxpc3RdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbmtPYmplY3RWYWwgb2YgcGFyYW1ldGVyc0luKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKGlua09iamVjdFZhbCwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbC52YWx1ZVR5cGUgPT0gVmFsdWVfMS5WYWx1ZVR5cGUuTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT3V0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsLnZhbHVlVHlwZSA9PSBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludFZhbCA9IHBhcnNlSW50KHZhbC52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNwZWNpYWxDYXNlTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHNwZWNpYWxDYXNlTGlzdCwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENhc2VMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuQ29lcmNlVmFsdWVzVG9TaW5nbGVUeXBlIHNwZWNpYWxDYXNlTGlzdC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3QgPSBzcGVjaWFsQ2FzZUxpc3QudmFsdWUub3JpZ2luT2ZNYXhJdGVtO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiTmF0aXZlRnVuY3Rpb25DYWxsLkNvZXJjZVZhbHVlc1RvU2luZ2xlVHlwZSBsaXN0XCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IGxpc3QuVHJ5R2V0SXRlbVdpdGhWYWx1ZShpbnRWYWwsIElua0xpc3RfMS5JbmtMaXN0SXRlbS5OdWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FzdGVkVmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoaXRlbS5yZXN1bHQsIGludFZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzT3V0LnB1c2goY2FzdGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ291bGQgbm90IGZpbmQgTGlzdCBpdGVtIHdpdGggdGhlIHZhbHVlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRWYWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gVmFsdWVfMS5WYWx1ZVR5cGVbdmFsLnZhbHVlVHlwZV07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IG1peCBMaXN0cyBhbmQgXCIgKyBrZXkgKyBcIiB2YWx1ZXMgaW4gdGhpcyBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5rT2JqZWN0VmFsIG9mIHBhcmFtZXRlcnNJbikge1xuICAgICAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhpbmtPYmplY3RWYWwsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBjYXN0ZWRWYWx1ZSA9IHZhbC5DYXN0KHZhbFR5cGUpO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNPdXQucHVzaChjYXN0ZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNPdXQ7XG4gICAgfVxuICAgIHN0YXRpYyBJZGVudGl0eSh0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH1cbiAgICBzdGF0aWMgR2VuZXJhdGVOYXRpdmVGdW5jdGlvbnNJZk5lY2Vzc2FyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUZ1bmN0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9uYXRpdmVGdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBJbnQgb3BlcmF0aW9uc1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwgKHgsIHkpID0+IHggLSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NdWx0aXBseSwgKHgsIHkpID0+IHggKiB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5EaXZpZGUsICh4LCB5KSA9PiBNYXRoLmZsb29yKHggLyB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTW9kLCAoeCwgeSkgPT4geCAlIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuTmVnYXRlLCAoeCkgPT4gLXgpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkVxdWFsLCAoeCwgeSkgPT4gKHggPT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4ID4geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTGVzcywgKHgsIHkpID0+ICh4IDwgeSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuR3JlYXRlclRoYW5PckVxdWFscywgKHgsIHkpID0+ICh4ID49IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiAoeCA8PSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoeCAhPSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLk5vdCwgKHgpID0+ICh4ID09IDAgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+ICh4ICE9IDAgJiYgeSAhPSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+ICh4ICE9IDAgfHwgeSAhPSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50QmluYXJ5T3AodGhpcy5NYXgsICh4LCB5KSA9PiBNYXRoLm1heCh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEludEJpbmFyeU9wKHRoaXMuTWluLCAoeCwgeSkgPT4gTWF0aC5taW4oeCwgeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRCaW5hcnlPcCh0aGlzLlBvdywgKHgsIHkpID0+IE1hdGgucG93KHgsIHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb29yLCBOYXRpdmVGdW5jdGlvbkNhbGwuSWRlbnRpdHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRJbnRVbmFyeU9wKHRoaXMuQ2VpbGluZywgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkludCwgTmF0aXZlRnVuY3Rpb25DYWxsLklkZW50aXR5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkSW50VW5hcnlPcCh0aGlzLkZsb2F0LCAoeCkgPT4geCk7XG4gICAgICAgICAgICAvLyBGbG9hdCBvcGVyYXRpb25zXG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5BZGQsICh4LCB5KSA9PiB4ICsgeSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5TdWJ0cmFjdCwgKHgsIHkpID0+IHggLSB5KTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLk11bHRpcGx5LCAoeCwgeSkgPT4geCAqIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuRGl2aWRlLCAoeCwgeSkgPT4geCAvIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuTW9kLCAoeCwgeSkgPT4geCAlIHkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5OZWdhdGUsICh4KSA9PiAteCk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4ID09IHkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdEJpbmFyeU9wKHRoaXMuR3JlYXRlciwgKHgsIHkpID0+ICh4ID4geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzLCAoeCwgeSkgPT4gKHggPCB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4ID49IHkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5MZXNzVGhhbk9yRXF1YWxzLCAoeCwgeSkgPT4gKHggPD0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Ob3RFcXVhbHMsICh4LCB5KSA9PiAoeCAhPSB5ID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuTm90LCAoeCkgPT4gKHggPT0gMC4wID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRCaW5hcnlPcCh0aGlzLkFuZCwgKHgsIHkpID0+ICh4ICE9IDAuMCAmJiB5ICE9IDAuMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5PciwgKHgsIHkpID0+ICh4ICE9IDAuMCB8fCB5ICE9IDAuMCA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NYXgsICh4LCB5KSA9PiBNYXRoLm1heCh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5NaW4sICh4LCB5KSA9PiBNYXRoLm1pbih4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0QmluYXJ5T3AodGhpcy5Qb3csICh4LCB5KSA9PiBNYXRoLnBvdyh4LCB5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkZsb29yLCAoeCkgPT4gTWF0aC5mbG9vcih4KSk7XG4gICAgICAgICAgICB0aGlzLkFkZEZsb2F0VW5hcnlPcCh0aGlzLkNlaWxpbmcsICh4KSA9PiBNYXRoLmNlaWwoeCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRGbG9hdFVuYXJ5T3AodGhpcy5JbnQsICh4KSA9PiBNYXRoLmZsb29yKHgpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkRmxvYXRVbmFyeU9wKHRoaXMuRmxvYXQsIE5hdGl2ZUZ1bmN0aW9uQ2FsbC5JZGVudGl0eSk7XG4gICAgICAgICAgICAvLyBTdHJpbmcgb3BlcmF0aW9uc1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkFkZCwgKHgsIHkpID0+IHggKyB5KTsgLy8gY29uY2F0XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuRXF1YWwsICh4LCB5KSA9PiAoeCA9PT0geSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZFN0cmluZ0JpbmFyeU9wKHRoaXMuTm90RXF1YWxzLCAoeCwgeSkgPT4gKCEoeCA9PT0geSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRTdHJpbmdCaW5hcnlPcCh0aGlzLkhhcywgKHgsIHkpID0+ICh4LmluY2x1ZGVzKHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkU3RyaW5nQmluYXJ5T3AodGhpcy5IYXNudCwgKHgsIHkpID0+ICh4LmluY2x1ZGVzKHkpID8gMCA6IDEpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuQWRkLCAoeCwgeSkgPT4geC5Vbmlvbih5KSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLlN1YnRyYWN0LCAoeCwgeSkgPT4geC5XaXRob3V0KHkpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSGFzLCAoeCwgeSkgPT4gKHguQ29udGFpbnMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5IYXNudCwgKHgsIHkpID0+ICh4LkNvbnRhaW5zKHkpID8gMCA6IDEpKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuSW50ZXJzZWN0LCAoeCwgeSkgPT4geC5JbnRlcnNlY3QoeSkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5FcXVhbCwgKHgsIHkpID0+ICh4LkVxdWFscyh5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXIsICh4LCB5KSA9PiAoeC5HcmVhdGVyVGhhbih5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3MsICh4LCB5KSA9PiAoeC5MZXNzVGhhbih5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkdyZWF0ZXJUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4LkdyZWF0ZXJUaGFuT3JFcXVhbHMoeSkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLkxlc3NUaGFuT3JFcXVhbHMsICh4LCB5KSA9PiB4Lkxlc3NUaGFuT3JFcXVhbHMoeSkgPyAxIDogMCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RCaW5hcnlPcCh0aGlzLk5vdEVxdWFscywgKHgsIHkpID0+ICgheC5FcXVhbHMoeSkgPyAxIDogMCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0QmluYXJ5T3AodGhpcy5BbmQsICh4LCB5KSA9PiB4LkNvdW50ID4gMCAmJiB5LkNvdW50ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdEJpbmFyeU9wKHRoaXMuT3IsICh4LCB5KSA9PiB4LkNvdW50ID4gMCB8fCB5LkNvdW50ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5Ob3QsICh4KSA9PiAoeC5Db3VudCA9PSAwID8gMSA6IDApKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5JbnZlcnQsICh4KSA9PiB4LmludmVyc2UpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkFsbCwgKHgpID0+IHguYWxsKTtcbiAgICAgICAgICAgIHRoaXMuQWRkTGlzdFVuYXJ5T3AodGhpcy5MaXN0TWluLCAoeCkgPT4geC5NaW5Bc0xpc3QoKSk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuTGlzdE1heCwgKHgpID0+IHguTWF4QXNMaXN0KCkpO1xuICAgICAgICAgICAgdGhpcy5BZGRMaXN0VW5hcnlPcCh0aGlzLkNvdW50LCAoeCkgPT4geC5Db3VudCk7XG4gICAgICAgICAgICB0aGlzLkFkZExpc3RVbmFyeU9wKHRoaXMuVmFsdWVPZkxpc3QsICh4KSA9PiB4Lm1heEl0ZW0uVmFsdWUpO1xuICAgICAgICAgICAgbGV0IGRpdmVydFRhcmdldHNFcXVhbCA9IChkMSwgZDIpID0+IChkMS5FcXVhbHMoZDIpID8gMSA6IDApO1xuICAgICAgICAgICAgbGV0IGRpdmVydFRhcmdldHNOb3RFcXVhbCA9IChkMSwgZDIpID0+IGQxLkVxdWFscyhkMikgPyAwIDogMTtcbiAgICAgICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmModGhpcy5FcXVhbCwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0LCBkaXZlcnRUYXJnZXRzRXF1YWwpO1xuICAgICAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyh0aGlzLk5vdEVxdWFscywgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuRGl2ZXJ0VGFyZ2V0LCBkaXZlcnRUYXJnZXRzTm90RXF1YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFkZE9wRnVuY0ZvclR5cGUodmFsVHlwZSwgb3ApIHtcbiAgICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkZ1bmNzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbkZ1bmNzLnNldCh2YWxUeXBlLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCBhcmdzLCB2YWxUeXBlLCBvcCkge1xuICAgICAgICBpZiAodGhpcy5fbmF0aXZlRnVuY3Rpb25zID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJOYXRpdmVGdW5jdGlvbkNhbGwuX25hdGl2ZUZ1bmN0aW9uc1wiKTtcbiAgICAgICAgbGV0IG5hdGl2ZUZ1bmMgPSB0aGlzLl9uYXRpdmVGdW5jdGlvbnMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIW5hdGl2ZUZ1bmMpIHtcbiAgICAgICAgICAgIG5hdGl2ZUZ1bmMgPSBuZXcgTmF0aXZlRnVuY3Rpb25DYWxsKG5hbWUsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5fbmF0aXZlRnVuY3Rpb25zLnNldChuYW1lLCBuYXRpdmVGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBuYXRpdmVGdW5jLkFkZE9wRnVuY0ZvclR5cGUodmFsVHlwZSwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkSW50QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEludFVuYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAxLCBWYWx1ZV8xLlZhbHVlVHlwZS5JbnQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZEZsb2F0QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5GbG9hdCwgb3ApO1xuICAgIH1cbiAgICBzdGF0aWMgQWRkRmxvYXRVbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMSwgVmFsdWVfMS5WYWx1ZVR5cGUuRmxvYXQsIG9wKTtcbiAgICB9XG4gICAgc3RhdGljIEFkZFN0cmluZ0JpbmFyeU9wKG5hbWUsIG9wKSB7XG4gICAgICAgIHRoaXMuQWRkT3BUb05hdGl2ZUZ1bmMobmFtZSwgMiwgVmFsdWVfMS5WYWx1ZVR5cGUuU3RyaW5nLCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRMaXN0QmluYXJ5T3AobmFtZSwgb3ApIHtcbiAgICAgICAgdGhpcy5BZGRPcFRvTmF0aXZlRnVuYyhuYW1lLCAyLCBWYWx1ZV8xLlZhbHVlVHlwZS5MaXN0LCBvcCk7XG4gICAgfVxuICAgIHN0YXRpYyBBZGRMaXN0VW5hcnlPcChuYW1lLCBvcCkge1xuICAgICAgICB0aGlzLkFkZE9wVG9OYXRpdmVGdW5jKG5hbWUsIDEsIFZhbHVlXzEuVmFsdWVUeXBlLkxpc3QsIG9wKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnTmF0aXZlIFwiJyArIHRoaXMubmFtZSArICdcIic7XG4gICAgfVxufVxuZXhwb3J0cy5OYXRpdmVGdW5jdGlvbkNhbGwgPSBOYXRpdmVGdW5jdGlvbkNhbGw7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQWRkID0gXCIrXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuU3VidHJhY3QgPSBcIi1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5EaXZpZGUgPSBcIi9cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NdWx0aXBseSA9IFwiKlwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk1vZCA9IFwiJVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5lZ2F0ZSA9IFwiX1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkVxdWFsID0gXCI9PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkdyZWF0ZXIgPSBcIj5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MZXNzID0gXCI8XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuR3JlYXRlclRoYW5PckVxdWFscyA9IFwiPj1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MZXNzVGhhbk9yRXF1YWxzID0gXCI8PVwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLk5vdEVxdWFscyA9IFwiIT1cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Ob3QgPSBcIiFcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5BbmQgPSBcIiYmXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuT3IgPSBcInx8XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTWluID0gXCJNSU5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5NYXggPSBcIk1BWFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLlBvdyA9IFwiUE9XXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRmxvb3IgPSBcIkZMT09SXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuQ2VpbGluZyA9IFwiQ0VJTElOR1wiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkludCA9IFwiSU5UXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuRmxvYXQgPSBcIkZMT0FUXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSGFzID0gXCI/XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSGFzbnQgPSBcIiE/XCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW50ZXJzZWN0ID0gXCJeXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuTGlzdE1pbiA9IFwiTElTVF9NSU5cIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5MaXN0TWF4ID0gXCJMSVNUX01BWFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLkFsbCA9IFwiTElTVF9BTExcIjtcbk5hdGl2ZUZ1bmN0aW9uQ2FsbC5Db3VudCA9IFwiTElTVF9DT1VOVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLlZhbHVlT2ZMaXN0ID0gXCJMSVNUX1ZBTFVFXCI7XG5OYXRpdmVGdW5jdGlvbkNhbGwuSW52ZXJ0ID0gXCJMSVNUX0lOVkVSVFwiO1xuTmF0aXZlRnVuY3Rpb25DYWxsLl9uYXRpdmVGdW5jdGlvbnMgPSBudWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmF0aXZlRnVuY3Rpb25DYWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aHJvd051bGxFeGNlcHRpb24gPSBleHBvcnRzLk51bGxFeGNlcHRpb24gPSB2b2lkIDA7XG4vKipcbiAqIEluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLCBhIFN5c3RlbUV4Y2VwdGlvbiB3b3VsZCBiZSB0aHJvd24gd2hlbiBwYXNzaW5nXG4gKiBudWxsIHRvIG1ldGhvZHMgZXhwZWN0ZWQgYSB2YWxpZCBpbnN0YW5jZS4gSmF2YXNjcmlwdCBoYXMgbm8gc3VjaFxuICogY29uY2VwdCwgYnV0IFR5cGVTY3JpcHQgd2lsbCBub3QgYWxsb3cgYG51bGxgIHRvIGJlIHBhc3NlZCB0byBtZXRob2RzXG4gKiBleHBsaWNpdGVseSByZXF1aXJpbmcgYSB2YWxpZCB0eXBlLlxuICpcbiAqIFdoZW5ldmVyIFR5cGVTY3JpcHQgY29tcGxhaW4gYWJvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIGEgYG51bGxgIHZhbHVlLFxuICogY2hlY2sgdGhlIG9mZmVuZGluZyB2YWx1ZSBhbmQgaXQgaXQncyBudWxsLCB0aHJvdyB0aGlzIGV4Y2VwdGlvbiB1c2luZ1xuICogYHRocm93TnVsbEV4Y2VwdGlvbihuYW1lOiBzdHJpbmcpYC5cbiAqL1xuY2xhc3MgTnVsbEV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbn1cbmV4cG9ydHMuTnVsbEV4Y2VwdGlvbiA9IE51bGxFeGNlcHRpb247XG4vKipcbiAqIFRocm93IGEgTnVsbEV4Y2VwdGlvbi5cbiAqXG4gKiBAcGFyYW0gbmFtZSBhIHNob3J0IGRlc2NyaXB0aW9uIG9mIHRoZSBvZmZlbmRpbmcgdmFsdWUgKG9mdGVuIGl0cyBuYW1lIHdpdGhpbiB0aGUgY29kZSkuXG4gKi9cbmZ1bmN0aW9uIHRocm93TnVsbEV4Y2VwdGlvbihuYW1lKSB7XG4gICAgdGhyb3cgbmV3IE51bGxFeGNlcHRpb24oYCR7bmFtZX0gaXMgbnVsbCBvciB1bmRlZmluZWRgKTtcbn1cbmV4cG9ydHMudGhyb3dOdWxsRXhjZXB0aW9uID0gdGhyb3dOdWxsRXhjZXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVsbEV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5rT2JqZWN0ID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgVHlwZUFzc2VydGlvbl8xID0gcmVxdWlyZShcIi4vVHlwZUFzc2VydGlvblwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBJbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RlYnVnTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGRlYnVnTWV0YWRhdGEoKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWJ1Z01ldGFkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVidWdNZXRhZGF0YTtcbiAgICB9XG4gICAgc2V0IGRlYnVnTWV0YWRhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVidWdNZXRhZGF0YSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgb3duRGVidWdNZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlYnVnTWV0YWRhdGE7XG4gICAgfVxuICAgIERlYnVnTGluZU51bWJlck9mUGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIFRyeSB0byBnZXQgYSBsaW5lIG51bWJlciBmcm9tIGRlYnVnIG1ldGFkYXRhXG4gICAgICAgIGxldCByb290ID0gdGhpcy5yb290Q29udGVudENvbnRhaW5lcjtcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGxldCB0YXJnZXRDb250ZW50ID0gcm9vdC5Db250ZW50QXRQYXRoKHBhdGgpLm9iajtcbiAgICAgICAgICAgIGlmICh0YXJnZXRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGRtID0gdGFyZ2V0Q29udGVudC5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG0uc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aCA9IG5ldyBQYXRoXzEuUGF0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbXBzID0gW107XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcztcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGNoaWxkLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29udGFpbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lZENoaWxkID0gVHlwZUFzc2VydGlvbl8xLmFzSU5hbWVkQ29udGVudE9yTnVsbChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lZENoaWxkICE9IG51bGwgJiYgbmFtZWRDaGlsZC5oYXNWYWxpZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBzLnVuc2hpZnQobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudChuYW1lZENoaWxkLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBzLnVuc2hpZnQobmV3IFBhdGhfMS5QYXRoLkNvbXBvbmVudChjb250YWluZXIuY29udGVudC5pbmRleE9mKGNoaWxkKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY29udGFpbmVyLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcGF0aCA9IG5ldyBQYXRoXzEuUGF0aChjb21wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgfVxuICAgIFJlc29sdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgaWYgKHBhdGggPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBhdGhcIik7XG4gICAgICAgIGlmIChwYXRoLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0Q29udGFpbmVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAobmVhcmVzdENvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIERlYnVnXzEuRGVidWcuQXNzZXJ0KHRoaXMucGFyZW50ICE9PSBudWxsLCBcIkNhbid0IHJlc29sdmUgcmVsYXRpdmUgcGF0aCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYSBwYXJlbnRcIik7XG4gICAgICAgICAgICAgICAgbmVhcmVzdENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLnBhcmVudCwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydChuZWFyZXN0Q29udGFpbmVyICE9PSBudWxsLCBcIkV4cGVjdGVkIHBhcmVudCB0byBiZSBhIGNvbnRhaW5lclwiKTtcbiAgICAgICAgICAgICAgICBEZWJ1Z18xLkRlYnVnLkFzc2VydChwYXRoLkdldENvbXBvbmVudCgwKS5pc1BhcmVudCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGgudGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZWFyZXN0Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuZWFyZXN0Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5lYXJlc3RDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50Q29udGFpbmVyID0gdGhpcy5yb290Q29udGVudENvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChjb250ZW50Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb250ZW50Q29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRDb250YWluZXIuQ29udGVudEF0UGF0aChwYXRoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDb252ZXJ0UGF0aFRvUmVsYXRpdmUoZ2xvYmFsUGF0aCkge1xuICAgICAgICBsZXQgb3duUGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgbGV0IG1pblBhdGhMZW5ndGggPSBNYXRoLm1pbihnbG9iYWxQYXRoLmxlbmd0aCwgb3duUGF0aC5sZW5ndGgpO1xuICAgICAgICBsZXQgbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5QYXRoTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBvd25Db21wID0gb3duUGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBsZXQgb3RoZXJDb21wID0gZ2xvYmFsUGF0aC5HZXRDb21wb25lbnQoaSk7XG4gICAgICAgICAgICBpZiAob3duQ29tcC5FcXVhbHMob3RoZXJDb21wKSkge1xuICAgICAgICAgICAgICAgIGxhc3RTaGFyZWRQYXRoQ29tcEluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHNoYXJlZCBwYXRoIGNvbXBvbmVudHMsIHNvIGp1c3QgdXNlIGdsb2JhbCBwYXRoXG4gICAgICAgIGlmIChsYXN0U2hhcmVkUGF0aENvbXBJbmRleCA9PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQYXRoO1xuICAgICAgICBsZXQgbnVtVXB3YXJkc01vdmVzID0gb3duUGF0aC5jb21wb25lbnRDb3VudCAtIDEgLSBsYXN0U2hhcmVkUGF0aENvbXBJbmRleDtcbiAgICAgICAgbGV0IG5ld1BhdGhDb21wcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB1cCA9IDA7IHVwIDwgbnVtVXB3YXJkc01vdmVzOyArK3VwKVxuICAgICAgICAgICAgbmV3UGF0aENvbXBzLnB1c2goUGF0aF8xLlBhdGguQ29tcG9uZW50LlRvUGFyZW50KCkpO1xuICAgICAgICBmb3IgKGxldCBkb3duID0gbGFzdFNoYXJlZFBhdGhDb21wSW5kZXggKyAxOyBkb3duIDwgZ2xvYmFsUGF0aC5jb21wb25lbnRDb3VudDsgKytkb3duKVxuICAgICAgICAgICAgbmV3UGF0aENvbXBzLnB1c2goZ2xvYmFsUGF0aC5HZXRDb21wb25lbnQoZG93bikpO1xuICAgICAgICBsZXQgcmVsYXRpdmVQYXRoID0gbmV3IFBhdGhfMS5QYXRoKG5ld1BhdGhDb21wcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGg7XG4gICAgfVxuICAgIENvbXBhY3RQYXRoU3RyaW5nKG90aGVyUGF0aCkge1xuICAgICAgICBsZXQgZ2xvYmFsUGF0aFN0ciA9IG51bGw7XG4gICAgICAgIGxldCByZWxhdGl2ZVBhdGhTdHIgPSBudWxsO1xuICAgICAgICBpZiAob3RoZXJQYXRoLmlzUmVsYXRpdmUpIHtcbiAgICAgICAgICAgIHJlbGF0aXZlUGF0aFN0ciA9IG90aGVyUGF0aC5jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICAgICAgZ2xvYmFsUGF0aFN0ciA9IHRoaXMucGF0aC5QYXRoQnlBcHBlbmRpbmdQYXRoKG90aGVyUGF0aCkuY29tcG9uZW50c1N0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZVBhdGggPSB0aGlzLkNvbnZlcnRQYXRoVG9SZWxhdGl2ZShvdGhlclBhdGgpO1xuICAgICAgICAgICAgcmVsYXRpdmVQYXRoU3RyID0gcmVsYXRpdmVQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgICAgICBnbG9iYWxQYXRoU3RyID0gb3RoZXJQYXRoLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbGF0aXZlUGF0aFN0ci5sZW5ndGggPCBnbG9iYWxQYXRoU3RyLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZVBhdGhTdHI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxQYXRoU3RyO1xuICAgIH1cbiAgICBnZXQgcm9vdENvbnRlbnRDb250YWluZXIoKSB7XG4gICAgICAgIGxldCBhbmNlc3RvciA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvci5wYXJlbnQpIHtcbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoYW5jZXN0b3IsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTm90IEltcGxlbWVudGVkOiBEb2Vzbid0IHN1cHBvcnQgY29weWluZ1wiKTtcbiAgICB9XG4gICAgLy8gU2V0Q2hpbGQgd29ya3Mgc2xpZ2h0bHkgZGlmZXJlbnRseSBpbiB0aGUganMgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gU2luY2Ugd2UgY2FuJ3QgcGFzcyBhbiBvYmpldHMgcHJvcGVydHkgYnkgcmVmZXJlbmNlLCB3ZSBpbnN0ZWFkIHBhc3NcbiAgICAvLyB0aGUgb2JqZWN0IGFuZCB0aGUgcHJvcGVydHkgc3RyaW5nLlxuICAgIC8vIFRPRE86IFRoaXMgbWV0aG9kIGNhbiBwcm9iYWJseSBiZSByZXdyaXR0ZW4gd2l0aCB0eXBlLXNhZmV0eSBpbiBtaW5kLlxuICAgIFNldENoaWxkKG9iaiwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG9ialtwcm9wXSlcbiAgICAgICAgICAgIG9ialtwcm9wXSA9IG51bGw7XG4gICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xuICAgICAgICBpZiAob2JqW3Byb3BdKVxuICAgICAgICAgICAgb2JqW3Byb3BdLnBhcmVudCA9IHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5JbmtPYmplY3QgPSBJbmtPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBSTkcgPSB2b2lkIDA7XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2JsaXh0L2YxN2I0N2M2MjUwOGJlNTk5ODdiXG4vLyBJbmsgdXNlcyBhIHNlZWRhYmxlIFBSTkcgb2Ygd2hpY2ggdGhlcmUgaXMgbm9uZSBpbiBuYXRpdmUgamF2YXNjcmlwdC5cbmNsYXNzIFBSTkcge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZCAlIDIxNDc0ODM2NDc7XG4gICAgICAgIGlmICh0aGlzLnNlZWQgPD0gMClcbiAgICAgICAgICAgIHRoaXMuc2VlZCArPSAyMTQ3NDgzNjQ2O1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuc2VlZCA9ICh0aGlzLnNlZWQgKiAxNjgwNykgJSAyMTQ3NDgzNjQ3KTtcbiAgICB9XG4gICAgbmV4dEZsb2F0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubmV4dCgpIC0gMSkgLyAyMTQ3NDgzNjQ2O1xuICAgIH1cbn1cbmV4cG9ydHMuUFJORyA9IFBSTkc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QUk5HLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoID0gdm9pZCAwO1xuY2xhc3MgUGF0aCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1N0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzUmVsYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudHNTdHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNTdHJpbmcgPSBjb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFBhdGguQ29tcG9uZW50ICYmXG4gICAgICAgICAgICBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCB0YWlsID0gYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGhlYWQpO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuY29uY2F0KHRhaWwuX2NvbXBvbmVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBsZXQgaGVhZCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGxldCByZWxhdGl2ZSA9ICEhYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuY29uY2F0KGhlYWQpO1xuICAgICAgICAgICAgdGhpcy5faXNSZWxhdGl2ZSA9IHJlbGF0aXZlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1JlbGF0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNSZWxhdGl2ZTtcbiAgICB9XG4gICAgZ2V0IGNvbXBvbmVudENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBoZWFkKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0YWlsKCkge1xuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50cy5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgLy8gY2FyZWZ1bCwgdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBsZW5ndGgtMSBoZXJlLiBUaGlzIGlzIGJlY2F1c2UgdGhlIHNlY29uZCBhcmd1bWVudCBvZlxuICAgICAgICAgICAgLy8gTGlzdC5HZXRSYW5nZSBpcyBhIG51bWJlciBvZiBlbGVtZW50cyB0byBleHRyYWN0LCB3aGVyZWFzZSBBcnJheS5zbGljZSB1c2VzIGFuIGluZGV4XG4gICAgICAgICAgICBsZXQgdGFpbENvbXBzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgxLCB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGgodGFpbENvbXBzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXRoLnNlbGY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgbGFzdENvbXBvbmVudCgpIHtcbiAgICAgICAgbGV0IGxhc3RDb21wb25lbnRJZHggPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0Q29tcG9uZW50SWR4ID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2xhc3RDb21wb25lbnRJZHhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5zTmFtZWRDb21wb25lbnQoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50c1tpXS5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHNlbGYoKSB7XG4gICAgICAgIGxldCBwYXRoID0gbmV3IFBhdGgoKTtcbiAgICAgICAgcGF0aC5faXNSZWxhdGl2ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBHZXRDb21wb25lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdO1xuICAgIH1cbiAgICBQYXRoQnlBcHBlbmRpbmdQYXRoKHBhdGhUb0FwcGVuZCkge1xuICAgICAgICBsZXQgcCA9IG5ldyBQYXRoKCk7XG4gICAgICAgIGxldCB1cHdhcmRNb3ZlcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aFRvQXBwZW5kLl9jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvQXBwZW5kLl9jb21wb25lbnRzW2ldLmlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdXB3YXJkTW92ZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fY29tcG9uZW50cy5sZW5ndGggLSB1cHdhcmRNb3ZlczsgKytpKSB7XG4gICAgICAgICAgICBwLl9jb21wb25lbnRzLnB1c2godGhpcy5fY29tcG9uZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHVwd2FyZE1vdmVzOyBpIDwgcGF0aFRvQXBwZW5kLl9jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwLl9jb21wb25lbnRzLnB1c2gocGF0aFRvQXBwZW5kLl9jb21wb25lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZ2V0IGNvbXBvbmVudHNTdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzU3RyaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB0aGlzLl9jb21wb25lbnRzLmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZWxhdGl2ZSlcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzU3RyaW5nID0gXCIuXCIgKyB0aGlzLl9jb21wb25lbnRzU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzU3RyaW5nO1xuICAgIH1cbiAgICBzZXQgY29tcG9uZW50c1N0cmluZyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPT0gbnVsbCB8fCB0aGlzLl9jb21wb25lbnRzU3RyaW5nID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9jb21wb25lbnRzU3RyaW5nWzBdID09IFwiLlwiKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1JlbGF0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNTdHJpbmcgPSB0aGlzLl9jb21wb25lbnRzU3RyaW5nLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29tcG9uZW50U3RyaW5ncyA9IHRoaXMuX2NvbXBvbmVudHNTdHJpbmcuc3BsaXQoXCIuXCIpO1xuICAgICAgICBmb3IgKGxldCBzdHIgb2YgY29tcG9uZW50U3RyaW5ncykge1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIG5hbWVkIGNvbXBvbmVudHMgdGhhdCBzdGFydCB3aXRoIGEgbnVtYmVyLCBlZyBcIjQyc29tZXdoZXJlXCIsIGFuZCBpbmRleGVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIHRoZSBub3JtYWwgcGFyc2VJbnQgd29uJ3QgZG8gZm9yIHRoZSBkZXRlY3Rpb24gYmVjYXVzZSBpdCdzIHRvbyByZWxheGVkLlxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3BhcnNlSW50XG4gICAgICAgICAgICBpZiAoL14oXFwtfFxcKyk/KFswLTldK3xJbmZpbml0eSkkLy50ZXN0KHN0cikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzLnB1c2gobmV3IFBhdGguQ29tcG9uZW50KHBhcnNlSW50KHN0cikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHMucHVzaChuZXcgUGF0aC5Db21wb25lbnQoc3RyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHNTdHJpbmc7XG4gICAgfVxuICAgIEVxdWFscyhvdGhlclBhdGgpIHtcbiAgICAgICAgaWYgKG90aGVyUGF0aCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAob3RoZXJQYXRoLl9jb21wb25lbnRzLmxlbmd0aCAhPSB0aGlzLl9jb21wb25lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG90aGVyUGF0aC5pc1JlbGF0aXZlICE9IHRoaXMuaXNSZWxhdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gdGhlIG9yaWdpbmFsIGNvZGUgdXNlcyBTZXF1ZW5jZUVxdWFsIGhlcmUsIHNvIHdlIG5lZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZSBjb21wb25lbnRzIG1hbnVhbGx5LlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IG90aGVyUGF0aC5fY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGl0J3Mgbm90IHF1aXRlIGNsZWFyIHdoZXRoZXIgdGhpcyB0ZXN0IHNob3VsZCB1c2UgRXF1YWxzIG9yIGEgc2ltcGxlID09IG9wZXJhdG9yLFxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95LWxvaHNlL2lua2pzL2lzc3Vlcy8yMlxuICAgICAgICAgICAgaWYgKCFvdGhlclBhdGguX2NvbXBvbmVudHNbaV0uRXF1YWxzKHRoaXMuX2NvbXBvbmVudHNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgUGF0aEJ5QXBwZW5kaW5nQ29tcG9uZW50KGMpIHtcbiAgICAgICAgbGV0IHAgPSBuZXcgUGF0aCgpO1xuICAgICAgICBwLl9jb21wb25lbnRzLnB1c2guYXBwbHkocC5fY29tcG9uZW50cywgdGhpcy5fY29tcG9uZW50cyk7XG4gICAgICAgIHAuX2NvbXBvbmVudHMucHVzaChjKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoID0gUGF0aDtcblBhdGgucGFyZW50SWQgPSBcIl5cIjtcbihmdW5jdGlvbiAoUGF0aCkge1xuICAgIGNsYXNzIENvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGluZGV4T3JOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleE9yTmFtZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gaW5kZXhPck5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXhPck5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGlzSW5kZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA+PSAwO1xuICAgICAgICB9XG4gICAgICAgIGdldCBpc1BhcmVudCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT0gUGF0aC5wYXJlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgVG9QYXJlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudChQYXRoLnBhcmVudElkKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBFcXVhbHMob3RoZXJDb21wKSB7XG4gICAgICAgICAgICBpZiAob3RoZXJDb21wICE9IG51bGwgJiYgb3RoZXJDb21wLmlzSW5kZXggPT0gdGhpcy5pc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PSBvdGhlckNvbXAuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09IG90aGVyQ29tcC5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXRoLkNvbXBvbmVudCA9IENvbXBvbmVudDtcbn0pKFBhdGggPSBleHBvcnRzLlBhdGggfHwgKGV4cG9ydHMuUGF0aCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2ludGVyID0gdm9pZCAwO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNsYXNzIFBvaW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNvbHZlKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLmNvbnRhaW5lci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIuY29udGVudFt0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgZ2V0IGlzTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyID09IG51bGw7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy5pc051bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPj0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5wYXRoLlBhdGhCeUFwcGVuZGluZ0NvbXBvbmVudChuZXcgUGF0aF8xLlBhdGguQ29tcG9uZW50KHRoaXMuaW5kZXgpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyLnBhdGg7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuIFwiSW5rIFBvaW50ZXIgKG51bGwpXCI7XG4gICAgICAgIHJldHVybiAoXCJJbmsgUG9pbnRlciAtPiBcIiArXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCkgK1xuICAgICAgICAgICAgXCIgLS0gaW5kZXggXCIgK1xuICAgICAgICAgICAgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IGV4aXN0IGluIHRoZSBvcmlnaW5hbCBDIyBjb2RlLCBidXQgaXMgaGVyZSB0byBtYWludGFpbiB0aGVcbiAgICAvLyB2YWx1ZSBzZW1hbnRpY3Mgb2YgUG9pbnRlci5cbiAgICBjb3B5KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50ZXIodGhpcy5jb250YWluZXIsIHRoaXMuaW5kZXgpO1xuICAgIH1cbiAgICBzdGF0aWMgU3RhcnRPZihjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludGVyKGNvbnRhaW5lciwgMCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTnVsbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludGVyKG51bGwsIC0xKTtcbiAgICB9XG59XG5leHBvcnRzLlBvaW50ZXIgPSBQb2ludGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9pbnRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVzaFBvcFR5cGUgPSB2b2lkIDA7XG52YXIgUHVzaFBvcFR5cGU7XG4oZnVuY3Rpb24gKFB1c2hQb3BUeXBlKSB7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJUdW5uZWxcIl0gPSAwXSA9IFwiVHVubmVsXCI7XG4gICAgUHVzaFBvcFR5cGVbUHVzaFBvcFR5cGVbXCJGdW5jdGlvblwiXSA9IDFdID0gXCJGdW5jdGlvblwiO1xuICAgIFB1c2hQb3BUeXBlW1B1c2hQb3BUeXBlW1wiRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWVcIl0gPSAyXSA9IFwiRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWVcIjtcbn0pKFB1c2hQb3BUeXBlID0gZXhwb3J0cy5QdXNoUG9wVHlwZSB8fCAoZXhwb3J0cy5QdXNoUG9wVHlwZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QdXNoUG9wLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZWFyY2hSZXN1bHQgPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNsYXNzIFNlYXJjaFJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub2JqID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHByb3hpbWF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgY29ycmVjdE9iaigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwcm94aW1hdGUgPyBudWxsIDogdGhpcy5vYmo7XG4gICAgfVxuICAgIGdldCBjb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iaiBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA/IHRoaXMub2JqIDogbnVsbDtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgbGV0IHNlYXJjaFJlc3VsdCA9IG5ldyBTZWFyY2hSZXN1bHQoKTtcbiAgICAgICAgc2VhcmNoUmVzdWx0Lm9iaiA9IHRoaXMub2JqO1xuICAgICAgICBzZWFyY2hSZXN1bHQuYXBwcm94aW1hdGUgPSB0aGlzLmFwcHJveGltYXRlO1xuICAgICAgICByZXR1cm4gc2VhcmNoUmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU2VhcmNoUmVzdWx0ID0gU2VhcmNoUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VhcmNoUmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVKc29uID0gdm9pZCAwO1xuY2xhc3MgU2ltcGxlSnNvbiB7XG4gICAgc3RhdGljIFRleHRUb0RpY3Rpb25hcnkodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUpzb24uUmVhZGVyKHRleHQpLlRvRGljdGlvbmFyeSgpO1xuICAgIH1cbiAgICBzdGF0aWMgVGV4dFRvQXJyYXkodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpbXBsZUpzb24uUmVhZGVyKHRleHQpLlRvQXJyYXkoKTtcbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZUpzb24gPSBTaW1wbGVKc29uO1xuKGZ1bmN0aW9uIChTaW1wbGVKc29uKSB7XG4gICAgY2xhc3MgUmVhZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICAgICAgdGhpcy5fcm9vdE9iamVjdCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgVG9EaWN0aW9uYXJ5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3RPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgVG9BcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290T2JqZWN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIFNpbXBsZUpzb24uUmVhZGVyID0gUmVhZGVyO1xuICAgIC8vIEluIEMjLCB0aGlzIGNsYXNzIHdyaXRlcyBqc29uIHRva2VucyBkaXJlY3RseSB0byBhIFN0cmluZ1dyaXRlciBvclxuICAgIC8vIGFub3RoZXIgc3RyZWFtLiBIZXJlLCBhIHRlbXBvcmFyeSBoaWVyYXJjaHkgaXMgY3JlYXRlZCBpbiB0aGUgZm9ybVxuICAgIC8vIG9mIGEgamF2YXNjcmlwdCBvYmplY3QsIHdoaWNoIGlzIHNlcmlhbGlzZWQgaW4gdGhlIGB0b1N0cmluZ2AgbWV0aG9kLlxuICAgIC8vIFNlZSBpbmRpdmlkdWFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgY2xhc3MgV3JpdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAvLyBJbiBhZGRpdGlvbiB0byBgX3N0YXRlU3RhY2tgIHByZXNlbnQgaW4gdGhlIG9yaWdpbmFsIGNvZGUsXG4gICAgICAgICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIG9mIFNpbXBsZUpzb24gdXNlIHR3byBvdGhlciBzdGFja3MgYW5kIHR3b1xuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IHZhcmlhYmxlcyBob2xkaW5nIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAgICAvLyBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkgbmFtZSBiZWluZyBidWlsdFxuICAgICAgICAgICAgLy8gd2l0aCBgV3JpdGVQcm9wZXJ0eU5hbWVTdGFydGAsIGBXcml0ZVByb3BlcnR5TmFtZUlubmVyYCBhbmRcbiAgICAgICAgICAgIC8vIGBXcml0ZVByb3BlcnR5TmFtZUVuZGAuXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIC8vIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY3VycmVudCBzdHJpbmcgdmFsdWUgYmVpbmcgYnVpbHRcbiAgICAgICAgICAgIC8vIHdpdGggYFdyaXRlU3RyaW5nU3RhcnRgLCBgV3JpdGVTdHJpbmdJbm5lcmAgYW5kXG4gICAgICAgICAgICAvLyBgV3JpdGVTdHJpbmdFbmRgLlxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrID0gW107XG4gICAgICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24gYmVpbmcgYnVpbHQgKGVpdGhlciBhbiBhcnJheVxuICAgICAgICAgICAgLy8gb3IgYW4gb2JqZWN0KS4gRm9yIGluc3RhbmNlLCBhdCB0aGUgJz8nIHN0ZXAgZHVyaW5nIHRoZSBoaWFyY2h5XG4gICAgICAgICAgICAvLyBjcmVhdGlvbiwgdGhpcyBoaWVyYXJjaHk6XG4gICAgICAgICAgICAvLyBbMywge2E6IFtiLCA/XX1dIHdpbGwgaGF2ZSB0aGlzIGNvcnJlc3BvbmRpbmcgc3RhY2s6XG4gICAgICAgICAgICAvLyAoYm90dG9tKSBbQXJyYXksIE9iamVjdCwgQXJyYXldICh0b3ApXG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sgPSBbXTtcbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgcHJvcGVydHkgYmVpbmcgYXNzaWduZWQuIEZvciBpbnN0YW5jZSwgYXRcbiAgICAgICAgICAgIC8vIHRoZSAnPycgc3RlcCBkdXJpbmcgdGhlIGhpYXJjaHkgY3JlYXRpb24sIHRoaXMgaGllcmFyY2h5OlxuICAgICAgICAgICAgLy8gWzMsIHthOiBbYiwge2M6ID99XX1dIHdpbGwgaGF2ZSB0aGlzIGNvcnJlc3BvbmRpbmcgc3RhY2s6XG4gICAgICAgICAgICAvLyAoYm90dG9tKSBbYSwgY10gKHRvcClcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrID0gW107XG4gICAgICAgICAgICAvLyBPYmplY3QgY29udGFpbmluZyB0aGUgZW50aXJlIGhpZWFyY2h5LlxuICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVPYmplY3QoaW5uZXIpIHtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgaW5uZXIodGhpcyk7XG4gICAgICAgICAgICB0aGlzLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgbmV3IG9iamVjdC5cbiAgICAgICAgV3JpdGVPYmplY3RTdGFydCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QodHJ1ZSk7XG4gICAgICAgICAgICBsZXQgbmV3T2JqZWN0ID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyBjcmVhdGVkIGFzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBhbiBvdGhlciBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcGVydHlOYW1lID0gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbltwcm9wZXJ0eU5hbWVdID0gbmV3T2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5BcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgb2JqZWN0IGlzIGNyZWF0ZWQgYXMgdGhlIGNoaWxkIG9mIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb24ucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9iamVjdCBpcyB0aGUgcm9vdCBvYmplY3QuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fanNvbk9iamVjdCA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuT2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVPYmplY3RFbmQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXcml0ZSBhIHByb3BlcnR5IG5hbWUgLyB2YWx1ZSBwYWlyIHRvIHRoZSBjdXJyZW50IG9iamVjdC5cbiAgICAgICAgV3JpdGVQcm9wZXJ0eShuYW1lLCBpbm5lck9yQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaW5uZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY29udGVudCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLldyaXRlKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW50IGFuZCBGbG9hdCBhcmUgc2VwYXJhdGUgY2FsbHMsIHNpbmNlIHRoZXJlIGJvdGggYXJlXG4gICAgICAgIC8vIG51bWJlcnMgaW4gSmF2YVNjcmlwdCwgYnV0IG5lZWQgdG8gYmUgaGFuZGxlZCBkaWZmZXJlbnRseS5cbiAgICAgICAgV3JpdGVJbnRQcm9wZXJ0eShuYW1lLCBjb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlTdGFydChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuV3JpdGVJbnQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUZsb2F0UHJvcGVydHkobmFtZSwgY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5Xcml0ZVByb3BlcnR5U3RhcnQobmFtZSk7XG4gICAgICAgICAgICB0aGlzLldyaXRlRmxvYXQoY29udGVudCk7XG4gICAgICAgICAgICB0aGlzLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVwYXJlIGEgbmV3IHByb3BlcnR5IG5hbWUsIHdoaWNoIHdpbGwgYmUgdXNlIHRvIGFkZCB0aGVcbiAgICAgICAgLy8gbmV3IG9iamVjdCB3aGVuIGNhbGxpbmcgX2FkZFRvQ3VycmVudE9iamVjdCgpIGZyb20gYSBXcml0ZVxuICAgICAgICAvLyBtZXRob2QuXG4gICAgICAgIFdyaXRlUHJvcGVydHlTdGFydChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydHlOYW1lU3RhY2sucHVzaChuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKG5ldyBTaW1wbGVKc29uLldyaXRlci5TdGF0ZUVsZW1lbnQoU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5RW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpO1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jaGlsZENvdW50ID09PSAxKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJlcGFyZSBhIG5ldyBwcm9wZXJ0eSBuYW1lLCBleGNlcHQgdGhpcyB0aW1lLCB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAvLyB3aWxsIGJlIGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyBhbGwgdGhlIHN0cmluZ3MgcGFzc2VkIHRvXG4gICAgICAgIC8vIFdyaXRlUHJvcGVydHlOYW1lSW5uZXIuXG4gICAgICAgIFdyaXRlUHJvcGVydHlOYW1lU3RhcnQoKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5PYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5JbmNyZW1lbnRDaGlsZENvdW50KCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5KSk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2gobmV3IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlRWxlbWVudChTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZVByb3BlcnR5TmFtZUVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnB1c2godGhpcy5fY3VycmVudFByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVQcm9wZXJ0eU5hbWVJbm5lcihzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLl9jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9wZXJ0eU5hbWUgKz0gc3RyO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBhIG5ldyBhcnJheS5cbiAgICAgICAgV3JpdGVBcnJheVN0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdCh0cnVlKTtcbiAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgY3JlYXRlZCBhcyB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudENvbGxlY3Rpb24gIT09IG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY3VycmVudFByb3BlcnR5TmFtZSAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgbGV0IHByb3BlcnR5TmFtZSA9IHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbGxlY3Rpb25bcHJvcGVydHlOYW1lXSA9IG5ld09iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uU3RhY2sucHVzaChuZXdPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFycmF5IGlzIGNyZWF0ZWQgYXMgdGhlIGNoaWxkIG9mIGFub3RoZXIgYXJyYXkuXG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29sbGVjdGlvbi5wdXNoKG5ld09iamVjdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdGhlIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2pzb25PYmplY3QgPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblN0YWNrLnB1c2gobmV3T2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGVBcnJheUVuZCgpIHtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSB0byB0aGUgYXBwcm9wcmlhdGUgY29sbGVjdGlvbiAoYXJyYXkgLyBvYmplY3QpLCBnaXZlbiB0aGUgY3VycmVudFxuICAgICAgICAvLyBjb250ZXh0LlxuICAgICAgICBXcml0ZSh2YWx1ZSwgZXNjYXBlID0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHRyeWluZyB0byB3cml0ZSBhIG51bGwgc3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0ZUludCh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIGlzIHVzZWQgYXMgYSBwcmVjYXV0aW9uOlxuICAgICAgICAgICAgLy8gICAgIDEuIHRvIGVuc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyB3cml0dGVuIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAgIC8vICAgICAgICAod2l0aG91dCBhIGZyYWN0aW9uYWwgcGFydCAtPiAxIGluc3RlYWQgb2YgMS4wKSwgZXZlblxuICAgICAgICAgICAgLy8gICAgICAgIHRob3VnaCBpdCBzaG91bGQgYmUgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mXG4gICAgICAgICAgICAvLyAgICAgICAgSlNPTi5zZXJpYWxpemU7XG4gICAgICAgICAgICAvLyAgICAgMi4gdG8gZW5zdXJlIHRoYXQgaWYgYSBmbG9hdGluZyBudW1iZXIgaXMgcGFzc2VkXG4gICAgICAgICAgICAvLyAgICAgICAgYWNjaWRlbnRhbGx5LCBpdCdzIGNvbnZlcnRlZCB0byBhbiBpbnRlZ2VyLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyBzYXZlZ2FtZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgLy8gaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QoTWF0aC5mbG9vcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIEpTT04gZG9lc24ndCBzdXBwb3J0IE5hTiBhbmQgSW5maW5pdHksIHRoZXNlIHZhbHVlc1xuICAgICAgICAvLyBhcmUgY29udmVydGVkIGhlcmUuXG4gICAgICAgIFdyaXRlRmxvYXQodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCgzLjRlMzgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KC0zLjRlMzgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KDAuMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRUb0N1cnJlbnRPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFdyaXRlTnVsbCgpIHtcbiAgICAgICAgICAgIHRoaXMuU3RhcnROZXdPYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fYWRkVG9DdXJyZW50T2JqZWN0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgYSBzdHJpbmcgYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgY3VycmVudCBjb2xsZWN0aW9uIGluXG4gICAgICAgIC8vIFdyaXRlU3RyaW5nRW5kKCkuIFRoZSBzdHJpbmcgd2lsbCBiZSBhIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRoZVxuICAgICAgICAvLyBzdHJpbmdzIHBhc3NlZCB0byBXcml0ZVN0cmluZ0lubmVyLlxuICAgICAgICBXcml0ZVN0cmluZ1N0YXJ0KCkge1xuICAgICAgICAgICAgdGhpcy5TdGFydE5ld09iamVjdChmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChuZXcgU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGVFbGVtZW50KFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlU3RyaW5nRW5kKCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5zdGF0ZSA9PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5TdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvQ3VycmVudE9iamVjdCh0aGlzLl9jdXJyZW50U3RyaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdHJpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRlU3RyaW5nSW5uZXIoc3RyLCBlc2NhcGUgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5TdHJpbmcpO1xuICAgICAgICAgICAgaWYgKHN0ciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB0cnlpbmcgdG8gd3JpdGUgYSBudWxsIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RyaW5nICs9IHN0cjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXJpYWxpc2UgdGhlIHJvb3Qgb2JqZWN0IGludG8gYSBKU09OIHN0cmluZy5cbiAgICAgICAgVG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fanNvbk9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb25PYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByZXBhcmUgdGhlIHN0YXRlIHN0YWNrIHdoZW4gYWRkaW5nIG5ldyBvYmplY3RzIC8gdmFsdWVzLlxuICAgICAgICBTdGFydE5ld09iamVjdChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Ob25lIHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLlByb3BlcnR5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLkFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuY2hpbGRDb3VudCA9PT0gMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTaW1wbGVKc29uLldyaXRlci5TdGF0ZS5Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuSW5jcmVtZW50Q2hpbGRDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIGdldHRlcnMgcGVlayBhbGwgdGhlIGRpZmZlcmVudCBzdGFja3MuXG4gICAgICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCAtIDFdLnR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgY2hpbGRDb3VudCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGVTdGFja1t0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCAtIDFdLmNoaWxkQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgY3VycmVudENvbGxlY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvblN0YWNrW3RoaXMuX2NvbGxlY3Rpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBjdXJyZW50UHJvcGVydHlOYW1lKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnR5TmFtZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydHlOYW1lU3RhY2tbdGhpcy5fcHJvcGVydHlOYW1lU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBJbmNyZW1lbnRDaGlsZENvdW50KCkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5fc3RhdGVTdGFjay5sZW5ndGggPiAwKTtcbiAgICAgICAgICAgIGxldCBjdXJyRWwgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgY3VyckVsLmNoaWxkQ291bnQrKztcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlU3RhY2sucHVzaChjdXJyRWwpO1xuICAgICAgICB9XG4gICAgICAgIEFzc2VydChjb25kaXRpb24pIHtcbiAgICAgICAgICAgIGlmICghY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQXNzZXJ0IGZhaWxlZCB3aGlsZSB3cml0aW5nIEpTT05cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBtZXRob2QgZGlkIG5vdCBleGlzdCBpbiB0aGUgb3JpZ2luYWwgQyMgY29kZS4gSXQgYWRkc1xuICAgICAgICAvLyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlvbiAodXNlZCBieSBXcml0ZSBtZXRob2RzKS5cbiAgICAgICAgX2FkZFRvQ3VycmVudE9iamVjdCh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50Q29sbGVjdGlvbiAhPT0gbnVsbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydChBcnJheS5pc0FycmF5KHRoaXMuY3VycmVudENvbGxlY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gU2ltcGxlSnNvbi5Xcml0ZXIuU3RhdGUuUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCghQXJyYXkuaXNBcnJheSh0aGlzLmN1cnJlbnRDb2xsZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQodGhpcy5jdXJyZW50UHJvcGVydHlOYW1lICE9PSBudWxsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb2xsZWN0aW9uW3RoaXMuY3VycmVudFByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wZXJ0eU5hbWVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBTaW1wbGVKc29uLldyaXRlciA9IFdyaXRlcjtcbiAgICAoZnVuY3Rpb24gKFdyaXRlcikge1xuICAgICAgICBsZXQgU3RhdGU7XG4gICAgICAgIChmdW5jdGlvbiAoU3RhdGUpIHtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgICAgICAgICBTdGF0ZVtTdGF0ZVtcIk9iamVjdFwiXSA9IDFdID0gXCJPYmplY3RcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiQXJyYXlcIl0gPSAyXSA9IFwiQXJyYXlcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUHJvcGVydHlcIl0gPSAzXSA9IFwiUHJvcGVydHlcIjtcbiAgICAgICAgICAgIFN0YXRlW1N0YXRlW1wiUHJvcGVydHlOYW1lXCJdID0gNF0gPSBcIlByb3BlcnR5TmFtZVwiO1xuICAgICAgICAgICAgU3RhdGVbU3RhdGVbXCJTdHJpbmdcIl0gPSA1XSA9IFwiU3RyaW5nXCI7XG4gICAgICAgIH0pKFN0YXRlID0gV3JpdGVyLlN0YXRlIHx8IChXcml0ZXIuU3RhdGUgPSB7fSkpO1xuICAgICAgICBjbGFzcyBTdGF0ZUVsZW1lbnQge1xuICAgICAgICAgICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFNpbXBsZUpzb24uV3JpdGVyLlN0YXRlLk5vbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZENvdW50ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFdyaXRlci5TdGF0ZUVsZW1lbnQgPSBTdGF0ZUVsZW1lbnQ7XG4gICAgfSkoV3JpdGVyID0gU2ltcGxlSnNvbi5Xcml0ZXIgfHwgKFNpbXBsZUpzb24uV3JpdGVyID0ge30pKTtcbn0pKFNpbXBsZUpzb24gPSBleHBvcnRzLlNpbXBsZUpzb24gfHwgKGV4cG9ydHMuU2ltcGxlSnNvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TaW1wbGVKc29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGF0ZVBhdGNoID0gdm9pZCAwO1xuY2xhc3MgU3RhdGVQYXRjaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgYXJndW1lbnRzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgdG9Db3B5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFscyA9IG5ldyBNYXAodG9Db3B5Ll9nbG9iYWxzKTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXMgPSBuZXcgU2V0KHRvQ29weS5fY2hhbmdlZFZhcmlhYmxlcyk7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cyA9IG5ldyBNYXAodG9Db3B5Ll92aXNpdENvdW50cyk7XG4gICAgICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAodG9Db3B5Ll90dXJuSW5kaWNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5fdHVybkluZGljZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGdsb2JhbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxzO1xuICAgIH1cbiAgICBnZXQgY2hhbmdlZFZhcmlhYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXM7XG4gICAgfVxuICAgIGdldCB2aXNpdENvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgIH1cbiAgICBnZXQgdHVybkluZGljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90dXJuSW5kaWNlcztcbiAgICB9XG4gICAgVHJ5R2V0R2xvYmFsKG5hbWUsIC8qIG91dCAqLyB2YWx1ZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCAmJiB0aGlzLl9nbG9iYWxzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl9nbG9iYWxzLmdldChuYW1lKSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBTZXRHbG9iYWwobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFscy5zZXQobmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBBZGRDaGFuZ2VkVmFyaWFibGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZFZhcmlhYmxlcy5hZGQobmFtZSk7XG4gICAgfVxuICAgIFRyeUdldFZpc2l0Q291bnQoY29udGFpbmVyLCAvKiBvdXQgKi8gY291bnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2l0Q291bnRzLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRoaXMuX3Zpc2l0Q291bnRzLmdldChjb250YWluZXIpLCBleGlzdHM6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGNvdW50LCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxuICAgIFNldFZpc2l0Q291bnQoY29udGFpbmVyLCBjb3VudCkge1xuICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyLCBjb3VudCk7XG4gICAgfVxuICAgIFNldFR1cm5JbmRleChjb250YWluZXIsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzLnNldChjb250YWluZXIsIGluZGV4KTtcbiAgICB9XG4gICAgVHJ5R2V0VHVybkluZGV4KGNvbnRhaW5lciwgLyogb3V0ICovIGluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl90dXJuSW5kaWNlcy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0aGlzLl90dXJuSW5kaWNlcy5nZXQoY29udGFpbmVyKSwgZXhpc3RzOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBpbmRleCwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdGVQYXRjaCA9IFN0YXRlUGF0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZVBhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdG9wd2F0Y2ggPSB2b2lkIDA7XG4vLyBUaGlzIGlzIHNpbXBsZSByZXBsYWNlbWVudCBvZiB0aGUgU3RvcHdhdGNoIGNsYXNzIGZyb20gdGhlIC5ORVQgRnJhbWV3b3JrLlxuLy8gVGhlIG9yaWdpbmFsIGNsYXNzIGNhbiBjb3VudCB0aW1lIHdpdGggbXVjaCBtb3JlIGFjY3VyYWN5IHRoYW4gdGhlIEphdmFzY3JpcHQgdmVyc2lvbi5cbi8vIEl0IG1pZ2h0IGJlIHdvcnRoIGNvbnNpZGVyaW5nIHVzaW5nIGB3aW5kb3cucGVyZm9ybWFuY2VgIGluIHRoZSBicm93c2VyXG4vLyBvciBgcHJvY2Vzcy5ocnRpbWUoKWAgaW4gbm9kZS5cbmNsYXNzIFN0b3B3YXRjaCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgRWxhcHNlZE1pbGxpc2Vjb25kcygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN0YXJ0VGltZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5zdGFydFRpbWU7XG4gICAgfVxuICAgIFN0YXJ0KCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBTdG9wKCkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0b3B3YXRjaCA9IFN0b3B3YXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3BXYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnkgPSB2b2lkIDA7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IE9iamVjdF8xID0gcmVxdWlyZShcIi4vT2JqZWN0XCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgU3RvcnlTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RvcnlTdGF0ZVwiKTtcbmNvbnN0IENvbnRyb2xDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db250cm9sQ29tbWFuZFwiKTtcbmNvbnN0IFB1c2hQb3BfMSA9IHJlcXVpcmUoXCIuL1B1c2hQb3BcIik7XG5jb25zdCBDaG9pY2VQb2ludF8xID0gcmVxdWlyZShcIi4vQ2hvaWNlUG9pbnRcIik7XG5jb25zdCBDaG9pY2VfMSA9IHJlcXVpcmUoXCIuL0Nob2ljZVwiKTtcbmNvbnN0IERpdmVydF8xID0gcmVxdWlyZShcIi4vRGl2ZXJ0XCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgUGF0aF8xID0gcmVxdWlyZShcIi4vUGF0aFwiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBUYWdfMSA9IHJlcXVpcmUoXCIuL1RhZ1wiKTtcbmNvbnN0IFZhcmlhYmxlQXNzaWdubWVudF8xID0gcmVxdWlyZShcIi4vVmFyaWFibGVBc3NpZ25tZW50XCIpO1xuY29uc3QgVmFyaWFibGVSZWZlcmVuY2VfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlUmVmZXJlbmNlXCIpO1xuY29uc3QgTmF0aXZlRnVuY3Rpb25DYWxsXzEgPSByZXF1aXJlKFwiLi9OYXRpdmVGdW5jdGlvbkNhbGxcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBQUk5HXzEgPSByZXF1aXJlKFwiLi9QUk5HXCIpO1xuY29uc3QgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vU3RyaW5nQnVpbGRlclwiKTtcbmNvbnN0IExpc3REZWZpbml0aW9uc09yaWdpbl8xID0gcmVxdWlyZShcIi4vTGlzdERlZmluaXRpb25zT3JpZ2luXCIpO1xuY29uc3QgU3RvcFdhdGNoXzEgPSByZXF1aXJlKFwiLi9TdG9wV2F0Y2hcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBOdWxsRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9OdWxsRXhjZXB0aW9uXCIpO1xuY29uc3QgU2ltcGxlSnNvbl8xID0gcmVxdWlyZShcIi4vU2ltcGxlSnNvblwiKTtcbnZhciBJbmtMaXN0XzIgPSByZXF1aXJlKFwiLi9JbmtMaXN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5rTGlzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gSW5rTGlzdF8yLklua0xpc3Q7IH0gfSk7XG5pZiAoIU51bWJlci5pc0ludGVnZXIpIHtcbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gaXNJbnRlZ2VyKG5WYWwpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgblZhbCA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICAgICAgaXNGaW5pdGUoblZhbCkgJiZcbiAgICAgICAgICAgIG5WYWwgPiAtOTAwNzE5OTI1NDc0MDk5MiAmJlxuICAgICAgICAgICAgblZhbCA8IDkwMDcxOTkyNTQ3NDA5OTIgJiZcbiAgICAgICAgICAgIE1hdGguZmxvb3IoblZhbCkgPT09IG5WYWwpO1xuICAgIH07XG59XG5jbGFzcyBTdG9yeSBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5rVmVyc2lvbk1pbmltdW1Db21wYXRpYmxlID0gMTg7XG4gICAgICAgIHRoaXMuX3ByZXZDb250YWluZXJzID0gW107XG4gICAgICAgIHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xpc3REZWZpbml0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Byb2ZpbGVyID0gbnVsbDsgLy8gVE9ETzogUHJvZmlsZXJcbiAgICAgICAgLy8gRGlzY3JpbWluYXRpb24gYmV0d2VlbiBjb25zdHJ1Y3RvcnNcbiAgICAgICAgbGV0IGNvbnRlbnRDb250YWluZXI7XG4gICAgICAgIGxldCBsaXN0cyA9IG51bGw7XG4gICAgICAgIGxldCBqc29uID0gbnVsbDtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGVudENvbnRhaW5lciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzFdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbGlzdHMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0tLS0gU3RvcnkgKENvbnRhaW5lciBjb250ZW50Q29udGFpbmVyLCBMaXN0PFJ1bnRpbWUuTGlzdERlZmluaXRpb24+IGxpc3RzID0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyID0gY29udGVudENvbnRhaW5lcjtcbiAgICAgICAgICAgIC8vIC0tLS0tLVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQganNvblN0cmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgICBqc29uID0gU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uVGV4dFRvRGljdGlvbmFyeShqc29uU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGpzb24gPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tIFN0b3J5IChDb250YWluZXIgY29udGVudENvbnRhaW5lciwgTGlzdDxSdW50aW1lLkxpc3REZWZpbml0aW9uPiBsaXN0cyA9IG51bGwpXG4gICAgICAgIGlmIChsaXN0cyAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gbmV3IExpc3REZWZpbml0aW9uc09yaWdpbl8xLkxpc3REZWZpbml0aW9uc09yaWdpbihsaXN0cyk7XG4gICAgICAgIHRoaXMuX2V4dGVybmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gLS0tLS0tXG4gICAgICAgIC8vIC0tLS0tLSBTdG9yeShzdHJpbmcganNvblN0cmluZykgOiB0aGlzKChDb250YWluZXIpbnVsbClcbiAgICAgICAgaWYgKGpzb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByb290T2JqZWN0ID0ganNvbjtcbiAgICAgICAgICAgIGxldCB2ZXJzaW9uT2JqID0gcm9vdE9iamVjdFtcImlua1ZlcnNpb25cIl07XG4gICAgICAgICAgICBpZiAodmVyc2lvbk9iaiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluayB2ZXJzaW9uIG51bWJlciBub3QgZm91bmQuIEFyZSB5b3Ugc3VyZSBpdCdzIGEgdmFsaWQgLmluay5qc29uIGZpbGU/XCIpO1xuICAgICAgICAgICAgbGV0IGZvcm1hdEZyb21GaWxlID0gcGFyc2VJbnQodmVyc2lvbk9iaik7XG4gICAgICAgICAgICBpZiAoZm9ybWF0RnJvbUZpbGUgPiBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3Rvcnkgd2FzIG5ld2VyIHRoYW4gdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgZW5naW5lXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0RnJvbUZpbGUgPCB0aGlzLmlua1ZlcnNpb25NaW5pbXVtQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgaXMgdG9vIG9sZCB0byBiZSBsb2FkZWQgYnkgdGhpcyB2ZXJzaW9uIG9mIHRoZSBlbmdpbmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmb3JtYXRGcm9tRmlsZSAhPSBTdG9yeS5pbmtWZXJzaW9uQ3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IFZlcnNpb24gb2YgaW5rIHVzZWQgdG8gYnVpbGQgc3RvcnkgZG9lc24ndCBtYXRjaCBjdXJyZW50IHZlcnNpb24gb2YgZW5naW5lLiBOb24tY3JpdGljYWwsIGJ1dCByZWNvbW1lbmQgc3luY2hyb25pc2luZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcm9vdFRva2VuID0gcm9vdE9iamVjdFtcInJvb3RcIl07XG4gICAgICAgICAgICBpZiAocm9vdFRva2VuID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vdCBub2RlIGZvciBpbmsgbm90IGZvdW5kLiBBcmUgeW91IHN1cmUgaXQncyBhIHZhbGlkIC5pbmsuanNvbiBmaWxlP1wiKTtcbiAgICAgICAgICAgIGxldCBsaXN0RGVmc09iajtcbiAgICAgICAgICAgIGlmICgobGlzdERlZnNPYmogPSByb290T2JqZWN0W1wibGlzdERlZnNcIl0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdERlZmluaXRpb25zID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub0xpc3REZWZpbml0aW9ucyhsaXN0RGVmc09iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9tYWluQ29udGVudENvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSlRva2VuVG9SdW50aW1lT2JqZWN0KHJvb3RUb2tlbiksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLlJlc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS1cbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDaG9pY2VzKCkge1xuICAgICAgICBsZXQgY2hvaWNlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYyBvZiB0aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcykge1xuICAgICAgICAgICAgaWYgKCFjLmlzSW52aXNpYmxlRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIGMuaW5kZXggPSBjaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaG9pY2VzLnB1c2goYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNob2ljZXM7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGV4dCgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGV4dCBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFRleHQ7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFncygpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiY2FsbCBjdXJyZW50VGFncyBzaW5jZSBpdCdzIGEgd29yayBpbiBwcm9ncmVzc1wiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuY3VycmVudFRhZ3M7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50RXJyb3JzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jdXJyZW50V2FybmluZ3M7XG4gICAgfVxuICAgIGdldCBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaGFzRXJyb3I7XG4gICAgfVxuICAgIGdldCBoYXNXYXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5oYXNXYXJuaW5nO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVzU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlO1xuICAgIH1cbiAgICBnZXQgbGlzdERlZmluaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdERlZmluaXRpb25zO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gVE9ETzogSW1wbGVtZW50IFByb2ZpbGVyXG4gICAgU3RhcnRQcm9maWxpbmcoKSB7XG4gICAgICAgIC8qICovXG4gICAgfVxuICAgIEVuZFByb2ZpbGluZygpIHtcbiAgICAgICAgLyogKi9cbiAgICB9XG4gICAgLy8gTWVyZ2UgdG9nZXRoZXIgYHB1YmxpYyBzdHJpbmcgVG9Kc29uKClgIGFuZCBgdm9pZCBUb0pzb24oU2ltcGxlSnNvbi5Xcml0ZXIgd3JpdGVyKWAuXG4gICAgLy8gV2lsbCBvbmx5IHJldHVybiBhIHZhbHVlIGlmIHdyaXRlciB3YXMgbm90IHByb3ZpZGVkLlxuICAgIFRvSnNvbih3cml0ZXIpIHtcbiAgICAgICAgbGV0IHNob3VsZFJldHVybiA9IGZhbHNlO1xuICAgICAgICBpZiAoIXdyaXRlcikge1xuICAgICAgICAgICAgc2hvdWxkUmV0dXJuID0gdHJ1ZTtcbiAgICAgICAgICAgIHdyaXRlciA9IG5ldyBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5Xcml0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua1ZlcnNpb25cIiwgU3RvcnkuaW5rVmVyc2lvbkN1cnJlbnQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInJvb3RcIiwgKHcpID0+IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uV3JpdGVSdW50aW1lQ29udGFpbmVyKHcsIHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyKSk7XG4gICAgICAgIGlmICh0aGlzLl9saXN0RGVmaW5pdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlTdGFydChcImxpc3REZWZzXCIpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRlZiBvZiB0aGlzLl9saXN0RGVmaW5pdGlvbnMubGlzdHMpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KGRlZi5uYW1lKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBkZWYuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSBJbmtMaXN0XzEuSW5rTGlzdEl0ZW0uZnJvbVNlcmlhbGl6ZWRLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShpdGVtLml0ZW1OYW1lLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgICAgICBpZiAoc2hvdWxkUmV0dXJuKVxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlci5Ub1N0cmluZygpO1xuICAgIH1cbiAgICBSZXNldFN0YXRlKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldFN0YXRlXCIpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTdG9yeVN0YXRlXzEuU3RvcnlTdGF0ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RhdGUudmFyaWFibGVzU3RhdGUuT2JzZXJ2ZVZhcmlhYmxlQ2hhbmdlKHRoaXMuVmFyaWFibGVTdGF0ZURpZENoYW5nZUV2ZW50LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLlJlc2V0R2xvYmFscygpO1xuICAgIH1cbiAgICBSZXNldEVycm9ycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0RXJyb3JzKCk7XG4gICAgfVxuICAgIFJlc2V0Q2FsbHN0YWNrKCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJSZXNldENhbGxzdGFja1wiKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX3N0YXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlLkZvcmNlRW5kKCk7XG4gICAgfVxuICAgIFJlc2V0R2xvYmFscygpIHtcbiAgICAgICAgaWYgKHRoaXMuX21haW5Db250ZW50Q29udGFpbmVyLm5hbWVkQ29udGVudC5nZXQoXCJnbG9iYWwgZGVjbFwiKSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsUG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5DaG9vc2VQYXRoKG5ldyBQYXRoXzEuUGF0aChcImdsb2JhbCBkZWNsXCIpLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLkNvbnRpbnVlSW50ZXJuYWwoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIgPSBvcmlnaW5hbFBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5TbmFwc2hvdERlZmF1bHRHbG9iYWxzKCk7XG4gICAgfVxuICAgIENvbnRpbnVlKCkge1xuICAgICAgICB0aGlzLkNvbnRpbnVlQXN5bmMoMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUZXh0O1xuICAgIH1cbiAgICBnZXQgY2FuQ29udGludWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNhbkNvbnRpbnVlO1xuICAgIH1cbiAgICBnZXQgYXN5bmNDb250aW51ZUNvbXBsZXRlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmU7XG4gICAgfVxuICAgIENvbnRpbnVlQXN5bmMobWlsbGlzZWNzTGltaXRBc3luYykge1xuICAgICAgICBpZiAoIXRoaXMuX2hhc1ZhbGlkYXRlZEV4dGVybmFscylcbiAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuQ29udGludWVJbnRlcm5hbChtaWxsaXNlY3NMaW1pdEFzeW5jKTtcbiAgICB9XG4gICAgQ29udGludWVJbnRlcm5hbChtaWxsaXNlY3NMaW1pdEFzeW5jID0gMCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlByZUNvbnRpbnVlKCk7XG4gICAgICAgIGxldCBpc0FzeW5jVGltZUxpbWl0ZWQgPSBtaWxsaXNlY3NMaW1pdEFzeW5jID4gMDtcbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCsrO1xuICAgICAgICBpZiAoIXRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jQ29udGludWVBY3RpdmUgPSBpc0FzeW5jVGltZUxpbWl0ZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbid0IGNvbnRpbnVlIC0gc2hvdWxkIGNoZWNrIGNhbkNvbnRpbnVlIGJlZm9yZSBjYWxsaW5nIENvbnRpbnVlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUuZGlkU2FmZUV4aXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHVyYXRpb25TdG9wd2F0Y2ggPSBuZXcgU3RvcFdhdGNoXzEuU3RvcHdhdGNoKCk7XG4gICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLlN0YXJ0KCk7XG4gICAgICAgIGxldCBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSA9IHRoaXMuQ29udGludWVTaW5nbGVTdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKGUubWVzc2FnZSwgdW5kZWZpbmVkLCBlLnVzZUVuZExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHB1dFN0cmVhbUVuZHNJbk5ld2xpbmUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSAmJlxuICAgICAgICAgICAgICAgIGR1cmF0aW9uU3RvcHdhdGNoLkVsYXBzZWRNaWxsaXNlY29uZHMgPiBtaWxsaXNlY3NMaW1pdEFzeW5jKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuY2FuQ29udGludWUpO1xuICAgICAgICBkdXJhdGlvblN0b3B3YXRjaC5TdG9wKCk7XG4gICAgICAgIGlmIChvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lIHx8ICF0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlc3RvcmVTdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wVGhyZWFkKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFkZEVycm9yKFwiVGhyZWFkIGF2YWlsYWJsZSB0byBwb3AsIHRocmVhZHMgc2hvdWxkIGFsd2F5cyBiZSBmbGF0IGJ5IHRoZSBlbmQgb2YgZXZhbHVhdGlvbj9cIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZ2VuZXJhdGVkQ2hvaWNlcy5sZW5ndGggPT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5kaWRTYWZlRXhpdCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wb3JhcnlFdmFsdWF0aW9uQ29udGFpbmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLkNhblBvcChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnLT4tPicgdG8gcmV0dXJuIGZyb20gYSB0dW5uZWw/XCIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5DYW5Qb3AoUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJ1bmV4cGVjdGVkbHkgcmVhY2hlZCBlbmQgb2YgY29udGVudC4gRG8geW91IG5lZWQgYSAnfiByZXR1cm4nP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuQWRkRXJyb3IoXCJyYW4gb3V0IG9mIGNvbnRlbnQuIERvIHlvdSBuZWVkIGEgJy0+IERPTkUnIG9yICctPiBFTkQnP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5BZGRFcnJvcihcInVuZXhwZWN0ZWRseSByZWFjaGVkIGVuZCBvZiBjb250ZW50IGZvciB1bmtub3duIHJlYXNvbi4gUGxlYXNlIGRlYnVnIGNvbXBpbGVyIVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpZFNhZmVFeGl0ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudCA9PSAxKVxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlLnZhcmlhYmxlc1N0YXRlLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9hc3luY0NvbnRpbnVlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVjdXJzaXZlQ29udGludWVDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RDb250aW51ZSgpO1xuICAgIH1cbiAgICBDb250aW51ZVNpbmdsZVN0ZXAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlU3RlcCgpO1xuICAgICAgICB0aGlzLlN0ZXAoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Byb2ZpbGVyICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLl9wcm9maWxlci5Qb3N0U3RlcCgpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuQ29udGludWUgJiYgIXRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRJc0V2YWx1YXRlRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuVHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wcm9maWxlciAhPSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fcHJvZmlsZXIuUHJlU25hcHNob3QoKTtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmluU3RyaW5nRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5fc3RhdGVBdExhc3ROZXdsaW5lLmN1cnJlbnRUYWdzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50VGFncyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuc3RhdGUuY3VycmVudFRhZ3NcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaGFuZ2UgPSB0aGlzLkNhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZSh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZS5jdXJyZW50VGV4dCwgdGhpcy5zdGF0ZS5jdXJyZW50VGV4dCwgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUuY3VycmVudFRhZ3MubGVuZ3RoLCB0aGlzLnN0YXRlLmN1cnJlbnRUYWdzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZSA9PSBTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZS5FeHRlbmRlZEJleW9uZE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5SZXN0b3JlU3RhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhbmdlID09IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRGlzY2FyZFNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtRW5kc0luTmV3bGluZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZVNuYXBzaG90QXRMYXN0TmV3bGluZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5TdGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkRpc2NhcmRTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlBvc3RTbmFwc2hvdCgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENhbGN1bGF0ZU5ld2xpbmVPdXRwdXRTdGF0ZUNoYW5nZShwcmV2VGV4dCwgY3VyclRleHQsIHByZXZUYWdDb3VudCwgY3VyclRhZ0NvdW50KSB7XG4gICAgICAgIGlmIChwcmV2VGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJwcmV2VGV4dFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VyclRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY3VyclRleHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld2xpbmVTdGlsbEV4aXN0cyA9IGN1cnJUZXh0Lmxlbmd0aCA+PSBwcmV2VGV4dC5sZW5ndGggJiZcbiAgICAgICAgICAgIGN1cnJUZXh0LmNoYXJBdChwcmV2VGV4dC5sZW5ndGggLSAxKSA9PSBcIlxcblwiO1xuICAgICAgICBpZiAocHJldlRhZ0NvdW50ID09IGN1cnJUYWdDb3VudCAmJlxuICAgICAgICAgICAgcHJldlRleHQubGVuZ3RoID09IGN1cnJUZXh0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgbmV3bGluZVN0aWxsRXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5vQ2hhbmdlO1xuICAgICAgICBpZiAoIW5ld2xpbmVTdGlsbEV4aXN0cykge1xuICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLk5ld2xpbmVSZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyVGFnQ291bnQgPiBwcmV2VGFnQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuRXh0ZW5kZWRCZXlvbmROZXdsaW5lO1xuICAgICAgICBmb3IgKGxldCBpID0gcHJldlRleHQubGVuZ3RoOyBpIDwgY3VyclRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gY3VyclRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgIT0gXCIgXCIgJiYgYyAhPSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlLkV4dGVuZGVkQmV5b25kTmV3bGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RvcnkuT3V0cHV0U3RhdGVDaGFuZ2UuTm9DaGFuZ2U7XG4gICAgfVxuICAgIENvbnRpbnVlTWF4aW1hbGx5KCkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJDb250aW51ZU1heGltYWxseVwiKTtcbiAgICAgICAgbGV0IHNiID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBzYi5BcHBlbmQodGhpcy5Db250aW51ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgQ29udGVudEF0UGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgfVxuICAgIEtub3RDb250YWluZXJXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIGxldCBuYW1lZENvbnRhaW5lciA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmdldChuYW1lKTtcbiAgICAgICAgaWYgKG5hbWVkQ29udGFpbmVyIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWVkQ29udGFpbmVyO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgUG9pbnRlckF0UGF0aChwYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIGxldCBwID0gbmV3IFBvaW50ZXJfMS5Qb2ludGVyKCk7XG4gICAgICAgIGxldCBwYXRoTGVuZ3RoVG9Vc2UgPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChwYXRoLmxhc3RDb21wb25lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicGF0aC5sYXN0Q29tcG9uZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxhc3RDb21wb25lbnQuaXNJbmRleCkge1xuICAgICAgICAgICAgcGF0aExlbmd0aFRvVXNlID0gcGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lci5Db250ZW50QXRQYXRoKHBhdGgsIHVuZGVmaW5lZCwgcGF0aExlbmd0aFRvVXNlKTtcbiAgICAgICAgICAgIHAuY29udGFpbmVyID0gcmVzdWx0LmNvbnRhaW5lcjtcbiAgICAgICAgICAgIHAuaW5kZXggPSBwYXRoLmxhc3RDb21wb25lbnQuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkNvbnRlbnRBdFBhdGgocGF0aCk7XG4gICAgICAgICAgICBwLmNvbnRhaW5lciA9IHJlc3VsdC5jb250YWluZXI7XG4gICAgICAgICAgICBwLmluZGV4ID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5vYmogPT0gbnVsbCB8fFxuICAgICAgICAgICAgKHJlc3VsdC5vYmogPT0gdGhpcy5tYWluQ29udGVudENvbnRhaW5lciAmJiBwYXRoTGVuZ3RoVG9Vc2UgPiAwKSkge1xuICAgICAgICAgICAgdGhpcy5FcnJvcihcIkZhaWxlZCB0byBmaW5kIGNvbnRlbnQgYXQgcGF0aCAnXCIgK1xuICAgICAgICAgICAgICAgIHBhdGggK1xuICAgICAgICAgICAgICAgIFwiJywgYW5kIG5vIGFwcHJveGltYXRpb24gb2YgaXQgd2FzIHBvc3NpYmxlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHQuYXBwcm94aW1hdGUpXG4gICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250ZW50IGF0IHBhdGggJ1wiICtcbiAgICAgICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICAgICBcIicsIHNvIGl0IHdhcyBhcHByb3hpbWF0ZWQgdG86ICdcIiArXG4gICAgICAgICAgICAgICAgcmVzdWx0Lm9iai5wYXRoICtcbiAgICAgICAgICAgICAgICBcIicuXCIpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgU3RhdGVTbmFwc2hvdCgpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9zdGF0ZS5Db3B5QW5kU3RhcnRQYXRjaGluZygpO1xuICAgIH1cbiAgICBSZXN0b3JlU3RhdGVTbmFwc2hvdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID09PSBudWxsKSB7XG4gICAgICAgICAgICBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lLlJlc3RvcmVBZnRlclBhdGNoKCk7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmU7XG4gICAgICAgIHRoaXMuX3N0YXRlU25hcHNob3RBdExhc3ROZXdsaW5lID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY1NhdmluZykge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUuQXBwbHlBbnlQYXRjaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIERpc2NhcmRTbmFwc2hvdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hc3luY1NhdmluZylcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKTtcbiAgICAgICAgdGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPSBudWxsO1xuICAgIH1cbiAgICBDb3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSgpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwic3RhcnQgc2F2aW5nIG9uIGEgYmFja2dyb3VuZCB0aHJlYWRcIik7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY1NhdmluZylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0b3J5IGlzIGFscmVhZHkgaW4gYmFja2dyb3VuZCBzYXZpbmcgbW9kZSwgY2FuJ3QgY2FsbCBDb3B5U3RhdGVGb3JCYWNrZ3JvdW5kVGhyZWFkU2F2ZSBhZ2FpbiFcIik7XG4gICAgICAgIGxldCBzdGF0ZVRvU2F2ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLkNvcHlBbmRTdGFydFBhdGNoaW5nKCk7XG4gICAgICAgIHRoaXMuX2FzeW5jU2F2aW5nID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN0YXRlVG9TYXZlO1xuICAgIH1cbiAgICBCYWNrZ3JvdW5kU2F2ZUNvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5fc3RhdGVTbmFwc2hvdEF0TGFzdE5ld2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLkFwcGx5QW55UGF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hc3luY1NhdmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBTdGVwKCkge1xuICAgICAgICBsZXQgc2hvdWxkQWRkVG9TdHJlYW0gPSB0cnVlO1xuICAgICAgICBsZXQgcG9pbnRlciA9IHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAocG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb250YWluZXIgY29udGFpbmVyVG9FbnRlciA9IHBvaW50ZXIuUmVzb2x2ZSAoKSBhcyBDb250YWluZXI7XG4gICAgICAgIGxldCBjb250YWluZXJUb0VudGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHBvaW50ZXIuUmVzb2x2ZSgpLCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB3aGlsZSAoY29udGFpbmVyVG9FbnRlcikge1xuICAgICAgICAgICAgdGhpcy5WaXNpdENvbnRhaW5lcihjb250YWluZXJUb0VudGVyLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIE5vIGNvbnRlbnQ/IHRoZSBtb3N0IHdlIGNhbiBkbyBpcyBzdGVwIHBhc3QgaXRcbiAgICAgICAgICAgIGlmIChjb250YWluZXJUb0VudGVyLmNvbnRlbnQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKGNvbnRhaW5lclRvRW50ZXIpO1xuICAgICAgICAgICAgLy8gY29udGFpbmVyVG9FbnRlciA9IHBvaW50ZXIuUmVzb2x2ZSgpIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRhaW5lclRvRW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5SZXNvbHZlKCksIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciA9IHBvaW50ZXIuY29weSgpO1xuICAgICAgICBpZiAodGhpcy5fcHJvZmlsZXIgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX3Byb2ZpbGVyLlN0ZXAodGhpcy5zdGF0ZS5jYWxsU3RhY2spO1xuICAgICAgICAvLyBJcyB0aGUgY3VycmVudCBjb250ZW50IG9iamVjdDpcbiAgICAgICAgLy8gIC0gTm9ybWFsIGNvbnRlbnRcbiAgICAgICAgLy8gIC0gT3IgYSBsb2dpYy9mbG93IHN0YXRlbWVudCAtIGlmIHNvLCBkbyBpdFxuICAgICAgICAvLyBTdG9wIGZsb3cgaWYgd2UgaGl0IGEgc3RhY2sgcG9wIHdoZW4gd2UncmUgdW5hYmxlIHRvIHBvcCAoZS5nLiByZXR1cm4vZG9uZSBzdGF0ZW1lbnQgaW4ga25vdFxuICAgICAgICAvLyB0aGF0IHdhcyBkaXZlcnRlZCB0byByYXRoZXIgdGhhbiBjYWxsZWQgYXMgYSBmdW5jdGlvbilcbiAgICAgICAgbGV0IGN1cnJlbnRDb250ZW50T2JqID0gcG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgIGxldCBpc0xvZ2ljT3JGbG93Q29udHJvbCA9IHRoaXMuUGVyZm9ybUxvZ2ljQW5kRmxvd0NvbnRyb2woY3VycmVudENvbnRlbnRPYmopO1xuICAgICAgICAvLyBIYXMgZmxvdyBiZWVuIGZvcmNlZCB0byBlbmQgYnkgZmxvdyBjb250cm9sIGFib3ZlP1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMb2dpY09yRmxvd0NvbnRyb2wpIHtcbiAgICAgICAgICAgIHNob3VsZEFkZFRvU3RyZWFtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hvaWNlIHdpdGggY29uZGl0aW9uP1xuICAgICAgICAvLyB2YXIgY2hvaWNlUG9pbnQgPSBjdXJyZW50Q29udGVudE9iaiBhcyBDaG9pY2VQb2ludDtcbiAgICAgICAgbGV0IGNob2ljZVBvaW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250ZW50T2JqLCBDaG9pY2VQb2ludF8xLkNob2ljZVBvaW50KTtcbiAgICAgICAgaWYgKGNob2ljZVBvaW50KSB7XG4gICAgICAgICAgICBsZXQgY2hvaWNlID0gdGhpcy5Qcm9jZXNzQ2hvaWNlKGNob2ljZVBvaW50KTtcbiAgICAgICAgICAgIGlmIChjaG9pY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmdlbmVyYXRlZENob2ljZXMucHVzaChjaG9pY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRlbnRPYmogPSBudWxsO1xuICAgICAgICAgICAgc2hvdWxkQWRkVG9TdHJlYW0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBubyBjb250ZW50LCB0aGVuIGl0IHdpbGwgYmVcbiAgICAgICAgLy8gdGhlIFwiY29udGVudFwiIGl0c2VsZiwgYnV0IHdlIHNraXAgb3ZlciBpdC5cbiAgICAgICAgaWYgKGN1cnJlbnRDb250ZW50T2JqIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBzaG91bGRBZGRUb1N0cmVhbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRlbnQgdG8gYWRkIHRvIGV2YWx1YXRpb24gc3RhY2sgb3IgdGhlIG91dHB1dCBzdHJlYW1cbiAgICAgICAgaWYgKHNob3VsZEFkZFRvU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBwdXNoaW5nIGEgdmFyaWFibGUgcG9pbnRlciBvbnRvIHRoZSBldmFsdWF0aW9uIHN0YWNrLCBlbnN1cmUgdGhhdCBpdCdzIHNwZWNpZmljXG4gICAgICAgICAgICAvLyB0byBvdXIgY3VycmVudCAocG9zc2libHkgdGVtcG9yYXJ5KSBjb250ZXh0IGluZGV4LiBBbmQgbWFrZSBhIGNvcHkgb2YgdGhlIHBvaW50ZXJcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UncmUgbm90IGVkaXRpbmcgdGhlIG9yaWdpbmFsIHJ1bnRpbWUgb2JqZWN0LlxuICAgICAgICAgICAgLy8gdmFyIHZhclBvaW50ZXIgPSBjdXJyZW50Q29udGVudE9iaiBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGN1cnJlbnRDb250ZW50T2JqLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YXJQb2ludGVyICYmIHZhclBvaW50ZXIuY29udGV4dEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5ldyBvYmplY3Qgc28gd2UncmUgbm90IG92ZXJ3cml0aW5nIHRoZSBzdG9yeSdzIG93biBkYXRhXG4gICAgICAgICAgICAgICAgbGV0IGNvbnRleHRJZHggPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5Db250ZXh0Rm9yVmFyaWFibGVOYW1lZCh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRlbnRPYmogPSBuZXcgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSwgY29udGV4dElkeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFeHByZXNzaW9uIGV2YWx1YXRpb24gY29udGVudFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhjdXJyZW50Q29udGVudE9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPdXRwdXQgc3RyZWFtIGNvbnRlbnQgKGkuZS4gbm90IGV4cHJlc3Npb24gZXZhbHVhdGlvbilcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKGN1cnJlbnRDb250ZW50T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIGNvbnRlbnQgcG9pbnRlciwgZm9sbG93aW5nIGRpdmVydHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuTmV4dENvbnRlbnQoKTtcbiAgICAgICAgLy8gU3RhcnRpbmcgYSB0aHJlYWQgc2hvdWxkIGJlIGRvbmUgYWZ0ZXIgdGhlIGluY3JlbWVudCB0byB0aGUgY29udGVudCBwb2ludGVyLFxuICAgICAgICAvLyBzbyB0aGF0IHdoZW4gcmV0dXJuaW5nIGZyb20gdGhlIHRocmVhZCwgaXQgcmV0dXJucyB0byB0aGUgY29udGVudCBhZnRlciB0aGlzIGluc3RydWN0aW9uLlxuICAgICAgICAvLyB2YXIgY29udHJvbENtZCA9IGN1cnJlbnRDb250ZW50T2JqIGFzIDtcbiAgICAgICAgbGV0IGNvbnRyb2xDbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwoY3VycmVudENvbnRlbnRPYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICBpZiAoY29udHJvbENtZCAmJlxuICAgICAgICAgICAgY29udHJvbENtZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlN0YXJ0VGhyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5QdXNoVGhyZWFkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmlzaXRDb250YWluZXIoY29udGFpbmVyLCBhdFN0YXJ0KSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLmNvdW50aW5nQXRTdGFydE9ubHkgfHwgYXRTdGFydCkge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci52aXNpdHNTaG91bGRCZUNvdW50ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5JbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZClcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlJlY29yZFR1cm5JbmRleFZpc2l0VG9Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBWaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKSB7XG4gICAgICAgIGxldCBwcmV2aW91c1BvaW50ZXIgPSB0aGlzLnN0YXRlLnByZXZpb3VzUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmIChwb2ludGVyLmlzTnVsbCB8fCBwb2ludGVyLmluZGV4ID09IC0xKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9wcmV2Q29udGFpbmVycy5sZW5ndGggPSAwO1xuICAgICAgICBpZiAoIXByZXZpb3VzUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIC8vIENvbnRhaW5lciBwcmV2QW5jZXN0b3IgPSBwcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpIGFzIENvbnRhaW5lciA/PyBwcmV2aW91c1BvaW50ZXIuY29udGFpbmVyIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFByZXZpb3VzQW5jZXN0b3IgPSBwcmV2aW91c1BvaW50ZXIuUmVzb2x2ZSgpO1xuICAgICAgICAgICAgbGV0IHByZXZBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChyZXNvbHZlZFByZXZpb3VzQW5jZXN0b3IsIENvbnRhaW5lcl8xLkNvbnRhaW5lcikgfHxcbiAgICAgICAgICAgICAgICBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocHJldmlvdXNQb2ludGVyLmNvbnRhaW5lciwgQ29udGFpbmVyXzEuQ29udGFpbmVyKTtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2QW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmV2Q29udGFpbmVycy5wdXNoKHByZXZBbmNlc3Rvcik7XG4gICAgICAgICAgICAgICAgLy8gcHJldkFuY2VzdG9yID0gcHJldkFuY2VzdG9yLnBhcmVudCBhcyBDb250YWluZXI7XG4gICAgICAgICAgICAgICAgcHJldkFuY2VzdG9yID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHByZXZBbmNlc3Rvci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRDaGlsZE9mQ29udGFpbmVyID0gcG9pbnRlci5SZXNvbHZlKCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hpbGRPZkNvbnRhaW5lciA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBDb250YWluZXIgY3VycmVudENvbnRhaW5lckFuY2VzdG9yID0gY3VycmVudENoaWxkT2ZDb250YWluZXIucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q2hpbGRPZkNvbnRhaW5lci5wYXJlbnQsIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgJiZcbiAgICAgICAgICAgICh0aGlzLl9wcmV2Q29udGFpbmVycy5pbmRleE9mKGN1cnJlbnRDb250YWluZXJBbmNlc3RvcikgPCAwIHx8XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lckFuY2VzdG9yLmNvdW50aW5nQXRTdGFydE9ubHkpKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoaXMgYW5jZXN0b3IgY29udGFpbmVyIGlzIGJlaW5nIGVudGVyZWQgYXQgdGhlIHN0YXJ0LFxuICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgd2hldGhlciB0aGUgY2hpbGQgb2JqZWN0IGlzIHRoZSBmaXJzdC5cbiAgICAgICAgICAgIGxldCBlbnRlcmluZ0F0U3RhcnQgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IuY29udGVudC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgY3VycmVudENoaWxkT2ZDb250YWluZXIgPT0gY3VycmVudENvbnRhaW5lckFuY2VzdG9yLmNvbnRlbnRbMF07XG4gICAgICAgICAgICAvLyBNYXJrIGEgdmlzaXQgdG8gdGhpcyBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuVmlzaXRDb250YWluZXIoY3VycmVudENvbnRhaW5lckFuY2VzdG9yLCBlbnRlcmluZ0F0U3RhcnQpO1xuICAgICAgICAgICAgY3VycmVudENoaWxkT2ZDb250YWluZXIgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3I7XG4gICAgICAgICAgICAvLyBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IgPSBjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGN1cnJlbnRDb250YWluZXJBbmNlc3RvciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChjdXJyZW50Q29udGFpbmVyQW5jZXN0b3IucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByb2Nlc3NDaG9pY2UoY2hvaWNlUG9pbnQpIHtcbiAgICAgICAgbGV0IHNob3dDaG9pY2UgPSB0cnVlO1xuICAgICAgICAvLyBEb24ndCBjcmVhdGUgY2hvaWNlIGlmIGNob2ljZSBwb2ludCBkb2Vzbid0IHBhc3MgY29uZGl0aW9uYWxcbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc0NvbmRpdGlvbikge1xuICAgICAgICAgICAgbGV0IGNvbmRpdGlvblZhbHVlID0gdGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5Jc1RydXRoeShjb25kaXRpb25WYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzaG93Q2hvaWNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0VGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCBjaG9pY2VPbmx5VGV4dCA9IFwiXCI7XG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5oYXNDaG9pY2VPbmx5Q29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIGNob2ljZU9ubHlTdHJWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICBsZXQgY2hvaWNlT25seVN0clZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgY2hvaWNlT25seVRleHQgPSBjaG9pY2VPbmx5U3RyVmFsLnZhbHVlIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNob2ljZVBvaW50Lmhhc1N0YXJ0Q29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIHN0YXJ0U3RyVmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFN0cmluZ1ZhbHVlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0U3RyVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBzdGFydFRleHQgPSBzdGFydFN0clZhbC52YWx1ZSB8fCBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGNyZWF0ZSBjaG9pY2UgaWYgcGxheWVyIGhhcyBhbHJlYWR5IHJlYWQgdGhpcyBjb250ZW50XG4gICAgICAgIGlmIChjaG9pY2VQb2ludC5vbmNlT25seSkge1xuICAgICAgICAgICAgbGV0IHZpc2l0Q291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY2hvaWNlUG9pbnQuY2hvaWNlVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICh2aXNpdENvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIHNob3dDaG9pY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBnbyB0aHJvdWdoIHRoZSBmdWxsIHByb2Nlc3Mgb2YgY3JlYXRpbmcgdGhlIGNob2ljZSBhYm92ZSBzb1xuICAgICAgICAvLyB0aGF0IHdlIGNvbnN1bWUgdGhlIGNvbnRlbnQgZm9yIGl0LCBzaW5jZSBvdGhlcndpc2UgaXQnbGxcbiAgICAgICAgLy8gYmUgc2hvd24gb24gdGhlIG91dHB1dCBzdHJlYW0uXG4gICAgICAgIGlmICghc2hvd0Nob2ljZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNob2ljZSA9IG5ldyBDaG9pY2VfMS5DaG9pY2UoKTtcbiAgICAgICAgY2hvaWNlLnRhcmdldFBhdGggPSBjaG9pY2VQb2ludC5wYXRoT25DaG9pY2U7XG4gICAgICAgIGNob2ljZS5zb3VyY2VQYXRoID0gY2hvaWNlUG9pbnQucGF0aC50b1N0cmluZygpO1xuICAgICAgICBjaG9pY2UuaXNJbnZpc2libGVEZWZhdWx0ID0gY2hvaWNlUG9pbnQuaXNJbnZpc2libGVEZWZhdWx0O1xuICAgICAgICBjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suRm9ya1RocmVhZCgpO1xuICAgICAgICBjaG9pY2UudGV4dCA9IChzdGFydFRleHQgKyBjaG9pY2VPbmx5VGV4dCkucmVwbGFjZSgvXlsgXFx0XSt8WyBcXHRdKyQvZywgXCJcIik7XG4gICAgICAgIHJldHVybiBjaG9pY2U7XG4gICAgfVxuICAgIElzVHJ1dGh5KG9iaikge1xuICAgICAgICBsZXQgdHJ1dGh5ID0gZmFsc2U7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgdmFsID0gb2JqO1xuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGl2VGFyZ2V0ID0gdmFsO1xuICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJTaG91bGRuJ3QgdXNlIGEgZGl2ZXJ0IHRhcmdldCAodG8gXCIgK1xuICAgICAgICAgICAgICAgICAgICBkaXZUYXJnZXQudGFyZ2V0UGF0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSBhcyBhIGNvbmRpdGlvbmFsIHZhbHVlLiBEaWQgeW91IGludGVuZCBhIGZ1bmN0aW9uIGNhbGwgJ2xpa2VUaGlzKCknIG9yIGEgcmVhZCBjb3VudCBjaGVjayAnbGlrZVRoaXMnPyAobm8gYXJyb3dzKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsLmlzVHJ1dGh5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnV0aHk7XG4gICAgfVxuICAgIFBlcmZvcm1Mb2dpY0FuZEZsb3dDb250cm9sKGNvbnRlbnRPYmopIHtcbiAgICAgICAgaWYgKGNvbnRlbnRPYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpdmVydFxuICAgICAgICBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIERpdmVydF8xLkRpdmVydCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREaXZlcnQgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQuaXNDb25kaXRpb25hbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb25kaXRpb25WYWx1ZSA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgLy8gRmFsc2UgY29uZGl0aW9uYWw/IENhbmNlbCBkaXZlcnRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuSXNUcnV0aHkoY29uZGl0aW9uVmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0Lmhhc1ZhcmlhYmxlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhck5hbWUgPSBjdXJyZW50RGl2ZXJ0LnZhcmlhYmxlRGl2ZXJ0TmFtZTtcbiAgICAgICAgICAgICAgICBsZXQgdmFyQ29udGVudHMgPSB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodmFyTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5FcnJvcihcIlRyaWVkIHRvIGRpdmVydCB1c2luZyBhIHRhcmdldCBmcm9tIGEgdmFyaWFibGUgdGhhdCBjb3VsZCBub3QgYmUgZm91bmQgKFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhck5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghKHZhckNvbnRlbnRzIGluc3RhbmNlb2YgVmFsdWVfMS5EaXZlcnRUYXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGludENvbnRlbnQgPSB2YXJDb250ZW50cyBhcyBJbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludENvbnRlbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFyQ29udGVudHMsIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJUcmllZCB0byBkaXZlcnQgdG8gYSB0YXJnZXQgZnJvbSBhIHZhcmlhYmxlLCBidXQgdGhlIHZhcmlhYmxlIChcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiKSBkaWRuJ3QgY29udGFpbiBhIGRpdmVydCB0YXJnZXQsIGl0IFwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50Q29udGVudCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgJiYgaW50Q29udGVudC52YWx1ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gXCJ3YXMgZW1wdHkvbnVsbCAodGhlIHZhbHVlIDApLlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiY29udGFpbmVkICdcIiArIHZhckNvbnRlbnRzICsgXCInLlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHZhckNvbnRlbnRzLCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IHRoaXMuUG9pbnRlckF0UGF0aCh0YXJnZXQudGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50RGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkNhbGxFeHRlcm5hbEZ1bmN0aW9uKGN1cnJlbnREaXZlcnQudGFyZ2V0UGF0aFN0cmluZywgY3VycmVudERpdmVydC5leHRlcm5hbEFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSBjdXJyZW50RGl2ZXJ0LnRhcmdldFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnREaXZlcnQucHVzaGVzVG9TdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlB1c2goY3VycmVudERpdmVydC5zdGFja1B1c2hUeXBlLCB1bmRlZmluZWQsIHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsICYmICFjdXJyZW50RGl2ZXJ0LmlzRXh0ZXJuYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudERpdmVydCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudERpdmVydC5kZWJ1Z01ldGFkYXRhLnNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiRGl2ZXJ0IHRhcmdldCBkb2Vzbid0IGV4aXN0OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RGl2ZXJ0LmRlYnVnTWV0YWRhdGEuc291cmNlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKFwiRGl2ZXJ0IHJlc29sdXRpb24gZmFpbGVkOiBcIiArIGN1cnJlbnREaXZlcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0L2VuZCBhbiBleHByZXNzaW9uIGV2YWx1YXRpb24/IE9yIHByaW50IG91dCB0aGUgcmVzdWx0P1xuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZCkge1xuICAgICAgICAgICAgbGV0IGV2YWxDb21tYW5kID0gY29udGVudE9iajtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZhbENvbW1hbmQuY29tbWFuZFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbFN0YXJ0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLkFzc2VydCh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPT09IGZhbHNlLCBcIkFscmVhZHkgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uP1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkV2YWxFbmQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gdHJ1ZSwgXCJOb3QgaW4gZXhwcmVzc2lvbiBldmFsdWF0aW9uIG1vZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRXZhbE91dHB1dDpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGV4cHJlc3Npb24gdHVybmVkIG91dCB0byBiZSBlbXB0eSwgdGhlcmUgbWF5IG5vdCBiZSBhbnl0aGluZyBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXZhbHVhdGlvblN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvdXRwdXQgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb25zIG1heSBldmFsdWF0ZSB0byBWb2lkLCBpbiB3aGljaCBjYXNlIHdlIHNraXAgb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvdXRwdXQgaW5zdGFuY2VvZiBWb2lkXzEuVm9pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgd2UgcmVhbGx5IGFsd2F5cyBibGFua2V0IGNvbnZlcnQgdG8gc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IHdvdWxkIGJlIG9rYXkgdG8gaGF2ZSBudW1iZXJzIGluIHRoZSBvdXRwdXQgc3RyZWFtIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcHJvYmxlbSBpcyB3aGVuIGV4cG9ydGluZyB0ZXh0IGZvciB2aWV3aW5nLCBpdCBza2lwcyBvdmVyIG51bWJlcnMgZXRjLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUob3V0cHV0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaFRvT3V0cHV0U3RyZWFtKHRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Ob09wOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuRHVwbGljYXRlOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sodGhpcy5zdGF0ZS5QZWVrRXZhbHVhdGlvblN0YWNrKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRXZhbHVhdGVkVmFsdWU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Qb3BGdW5jdGlvbjpcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wVHVubmVsOlxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9wVHlwZSA9IGV2YWxDb21tYW5kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUG9wRnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgID8gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWw7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3BUeXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3BwZWQgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQgPSBwb3BwZWQgYXMgRGl2ZXJ0VGFyZ2V0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZVR1bm5lbFJldHVyblRhcmdldCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChwb3BwZWQsIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlVHVubmVsUmV0dXJuVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQocG9wcGVkIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQsIFwiRXhwZWN0ZWQgdm9pZCBpZiAtPi0+IGRvZXNuJ3Qgb3ZlcnJpZGUgdGFyZ2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlICE9IHBvcFR5cGUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuYW1lcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzLnNldChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24sIFwiZnVuY3Rpb24gcmV0dXJuIHN0YXRlbWVudCAofiByZXR1cm4pXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXMuc2V0KFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5UdW5uZWwsIFwidHVubmVsIG9ud2FyZHMgc3RhdGVtZW50ICgtPi0+KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBleHBlY3RlZCA9IG5hbWVzLmdldCh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FuUG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBcImVuZCBvZiBmbG93ICgtPiBFTkQgb3IgY2hvaWNlKVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVycm9yTXNnID0gXCJGb3VuZCBcIiArIG5hbWVzLmdldChwb3BUeXBlKSArIFwiLCB3aGVuIGV4cGVjdGVkIFwiICsgZXhwZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLkVycm9yKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUG9wQ2FsbFN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLlBvaW50ZXJBdFBhdGgob3ZlcnJpZGVUdW5uZWxSZXR1cm5UYXJnZXQudGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hUb091dHB1dFN0cmVhbShldmFsQ29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9PT0gdHJ1ZSwgXCJFeHBlY3RlZCB0byBiZSBpbiBhbiBleHByZXNzaW9uIHdoZW4gZXZhbHVhdGluZyBhIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbkV4cHJlc3Npb25FdmFsdWF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5FbmRTdHJpbmc6XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50U3RhY2tGb3JTdHJpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG91dHB1dENvdW50Q29uc3VtZWQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dENvdW50Q29uc3VtZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21tYW5kID0gb2JqIGFzIENvbnRyb2xDb21tYW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkJlZ2luU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgVmFsdWVfMS5TdHJpbmdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdGFja0ZvclN0cmluZy5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3VtZSB0aGUgY29udGVudCB0aGF0IHdhcyBwcm9kdWNlZCBmb3IgdGhpcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BGcm9tT3V0cHV0U3RyZWFtKG91dHB1dENvdW50Q29uc3VtZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgQyMgdmVyc2lvbiB1c2VzIGEgU3RhY2sgZm9yIGNvbnRlbnRTdGFja0ZvclN0cmluZywgYnV0IHdlJ3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzaW5nIGEgc2ltcGxlIGFycmF5LCBzbyB3ZSBuZWVkIHRvIHJldmVyc2UgaXQgYmVmb3JlIHVzaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTdGFja0ZvclN0cmluZyA9IGNvbnRlbnRTdGFja0ZvclN0cmluZy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkIHN0cmluZyBvdXQgb2YgdGhlIGNvbnRlbnQgd2UgY29sbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGNvbnRlbnRTdGFja0ZvclN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2IuQXBwZW5kKGMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRvIGV4cHJlc3Npb24gZXZhbHVhdGlvbiAoZnJvbSBjb250ZW50IG1vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaW5FeHByZXNzaW9uRXZhbHVhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzYi50b1N0cmluZygpKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5DaG9pY2VDb3VudDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNob2ljZUNvdW50ID0gdGhpcy5zdGF0ZS5nZW5lcmF0ZWRDaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGNob2ljZUNvdW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuczpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKHRoaXMuc3RhdGUuY3VycmVudFR1cm5JbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2U6XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlJlYWRDb3VudDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIFZhbHVlXzEuRGl2ZXJ0VGFyZ2V0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXh0cmFOb3RlID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhTm90ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiLiBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgcmVhZCBjb3VudCAoJ2tub3RfbmFtZScpIGluc3RlYWQgb2YgYSB0YXJnZXQgKCctPiBrbm90X25hbWUnKT9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJUVVJOU19TSU5DRSAvIFJFQURfQ09VTlQgZXhwZWN0ZWQgYSBkaXZlcnQgdGFyZ2V0IChrbm90LCBzdGl0Y2gsIGxhYmVsIG5hbWUpLCBidXQgc2F3IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhTm90ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgZGl2ZXJ0VGFyZ2V0ID0gdGFyZ2V0IGFzIERpdmVydFRhcmdldFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGl2ZXJ0VGFyZ2V0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGFyZ2V0LCBWYWx1ZV8xLkRpdmVydFRhcmdldFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFyIGNvbnRhaW5lciA9IENvbnRlbnRBdFBhdGggKGRpdmVydFRhcmdldC50YXJnZXRQYXRoKS5jb3JyZWN0T2JqIGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLkNvbnRlbnRBdFBhdGgoZGl2ZXJ0VGFyZ2V0LnRhcmdldFBhdGgpLmNvcnJlY3RPYmosIENvbnRhaW5lcl8xLkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlaXRoZXJDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbENvbW1hbmQuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5UdXJuc1NpbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVpdGhlckNvdW50ID0gdGhpcy5zdGF0ZS5UdXJuc1NpbmNlRm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSB0aGlzLnN0YXRlLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmFsQ29tbWFuZC5jb21tYW5kVHlwZSA9PSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlR1cm5zU2luY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWl0aGVyQ291bnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlaXRoZXJDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLldhcm5pbmcoXCJGYWlsZWQgdG8gZmluZCBjb250YWluZXIgZm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsQ29tbWFuZC50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBsb29rdXAgYXQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpdmVydFRhcmdldC50YXJnZXRQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhuZXcgVmFsdWVfMS5JbnRWYWx1ZShlaXRoZXJDb3VudCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuUmFuZG9tOiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhJbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW5JbnQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5JbnQgPT0gbnVsbCB8fCBtaW5JbnQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgbWluaW11bSBwYXJhbWV0ZXIgb2YgUkFORE9NKG1pbiwgbWF4KVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heEludCA9PSBudWxsIHx8IG1pbkludCBpbnN0YW5jZW9mIFZhbHVlXzEuSW50VmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBtYXhpbXVtIHBhcmFtZXRlciBvZiBSQU5ET00obWluLCBtYXgpXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBPcmlnaW5hbGx5IGEgcHJpbWl0aXZlIHR5cGUsIGJ1dCBoZXJlLCBjYW4gYmUgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSBieSBkZWZhdWx0IHZhbHVlP1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4SW50LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1heEludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWluSW50LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFuZG9tUmFuZ2UgPSBtYXhJbnQudmFsdWUgLSBtaW5JbnQudmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmFuZG9tUmFuZ2UgPD0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJSQU5ET00gd2FzIGNhbGxlZCB3aXRoIG1pbmltdW0gYXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkludC52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgYW5kIG1heGltdW0gYXMgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heEludC52YWx1ZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIuIFRoZSBtYXhpbXVtIG11c3QgYmUgbGFyZ2VyXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0U2VlZCA9IHRoaXMuc3RhdGUuc3RvcnlTZWVkICsgdGhpcy5zdGF0ZS5wcmV2aW91c1JhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhyZXN1bHRTZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHRSYW5kb20gPSByYW5kb20ubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hvc2VuVmFsdWUgPSAobmV4dFJhbmRvbSAlIHJhbmRvbVJhbmdlKSArIG1pbkludC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKGNob3NlblZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5leHQgcmFuZG9tIG51bWJlciAocmF0aGVyIHRoYW4ga2VlcGluZyB0aGUgUmFuZG9tIG9iamVjdCBhcm91bmQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSBuZXh0UmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlZWRSYW5kb206XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWVkID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuSW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlZCA9PSBudWxsIHx8IHNlZWQgaW5zdGFuY2VvZiBWYWx1ZV8xLkludFZhbHVlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkVycm9yKFwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gU0VFRF9SQU5ET01cIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVkLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm1pbkludC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0b3J5U2VlZCA9IHNlZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZvaWRfMS5Wb2lkKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuVmlzaXRJbmRleDpcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuY29udGFpbmVyKSAtIDE7IC8vIGluZGV4IG5vdCBjb3VudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuSW50VmFsdWUoY291bnQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLlNlcXVlbmNlU2h1ZmZsZUluZGV4OlxuICAgICAgICAgICAgICAgICAgICBsZXQgc2h1ZmZsZUluZGV4ID0gdGhpcy5OZXh0U2VxdWVuY2VTaHVmZmxlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkludFZhbHVlKHNodWZmbGVJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuU3RhcnRUaHJlYWQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgaW4gbWFpbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5Eb25lOlxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgZXhpc3QgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0IG9mIGNyZWF0aW5nIHRoZSB0aHJlYWQsIG9yIGluIHRoZSBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2YWx1YXRpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jYW5Qb3BUaHJlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG5vcm1hbCBmbG93IC0gYWxsb3cgc2FmZSBleGl0IHdpdGhvdXQgd2FybmluZ1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuZGlkU2FmZUV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBmbG93IGluIGN1cnJlbnQgdGhyZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gUG9pbnRlcl8xLlBvaW50ZXIuTnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAvLyBGb3JjZSBmbG93IHRvIGVuZCBjb21wbGV0ZWx5XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkVuZDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5Gb3JjZUVuZCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdEZyb21JbnQ6XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBpbnRWYWwgPSBzdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2sgKCkgYXMgSW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBsaXN0TmFtZVZhbCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3ROYW1lVmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiUGFzc2VkIG5vbi1pbnRlZ2VyIHdoZW4gY3JlYXRpbmcgYSBsaXN0IGVsZW1lbnQgZnJvbSBhIG51bWVyaWNhbCB2YWx1ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGdlbmVyYXRlZExpc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpc3REZWZpbml0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLmxpc3REZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRMaXN0RGVmID0gdGhpcy5saXN0RGVmaW5pdGlvbnMuVHJ5TGlzdEdldERlZmluaXRpb24obGlzdE5hbWVWYWwudmFsdWUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRMaXN0RGVmLmV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luYWxseSBhIHByaW1pdGl2ZSB0eXBlLCBidXQgaGVyZSwgY2FuIGJlIG51bGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50VmFsLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJtaW5JbnQudmFsdWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRJdGVtID0gZm91bmRMaXN0RGVmLnJlc3VsdC5UcnlHZXRJdGVtV2l0aFZhbHVlKGludFZhbC52YWx1ZSwgSW5rTGlzdF8xLklua0xpc3RJdGVtLk51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kSXRlbS5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRMaXN0VmFsdWUgPSBuZXcgVmFsdWVfMS5MaXN0VmFsdWUoZm91bmRJdGVtLnJlc3VsdCwgaW50VmFsLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRmFpbGVkIHRvIGZpbmQgTElTVCBjYWxsZWQgXCIgKyBsaXN0TmFtZVZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRlZExpc3RWYWx1ZSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkTGlzdFZhbHVlID0gbmV3IFZhbHVlXzEuTGlzdFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuUHVzaEV2YWx1YXRpb25TdGFjayhnZW5lcmF0ZWRMaXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuTGlzdFJhbmdlOlxuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyB2YXIgdGFyZ2V0TGlzdCA9IHN0YXRlLlBvcEV2YWx1YXRpb25TdGFjayAoKSBhcyBMaXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXRMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldExpc3QgPT09IG51bGwgfHwgbWluID09PSBudWxsIHx8IG1heCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgbGlzdCwgbWluaW11bSBhbmQgbWF4aW11bSBmb3IgTElTVF9SQU5HRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldExpc3QudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGFyZ2V0TGlzdC52YWx1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGFyZ2V0TGlzdC52YWx1ZS5MaXN0V2l0aFN1YlJhbmdlKG1pbi52YWx1ZU9iamVjdCwgbWF4LnZhbHVlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWYWx1ZV8xLkxpc3RWYWx1ZShyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kLkNvbW1hbmRUeXBlLkxpc3RSYW5kb206IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RWYWwgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdFZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgbGlzdCBmb3IgTElTVF9SQU5ET01cIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsaXN0ID0gbGlzdFZhbC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xpc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImxpc3RcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3QuQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGlzdCA9IG5ldyBJbmtMaXN0XzEuSW5rTGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSByYW5kb20gaW5kZXggZm9yIHRoZSBlbGVtZW50IHRvIHRha2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHRTZWVkID0gdGhpcy5zdGF0ZS5zdG9yeVNlZWQgKyB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmRvbSA9IG5ldyBQUk5HXzEuUFJORyhyZXN1bHRTZWVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXh0UmFuZG9tID0gcmFuZG9tLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0SXRlbUluZGV4ID0gbmV4dFJhbmRvbSAlIGxpc3QuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGJpdCBpcyBhIGxpdHRsZSBkaWZmZXJlbnQgZnJvbSB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEMjIGNvZGUsIHNpbmNlIGl0ZXJhdG9ycyBkbyBub3Qgd29yayBpbiB0aGUgc2FtZSB3YXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCwgd2UgaXRlcmF0ZSBsaXN0SXRlbUluZGV4IC0gMSB0aW1lcywgY2FsbGluZyBuZXh0KCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGlzdEl0ZW1JbmRleC10aCB0aW1lIGlzIG1hZGUgb3V0c2lkZSBvZiB0aGUgbG9vcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIHRvIHJldHJpZXZlIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaXN0RW51bWVyYXRvciA9IGxpc3QuZW50cmllcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGlzdEl0ZW1JbmRleCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RFbnVtZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGxpc3RFbnVtZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByYW5kb21JdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEtleTogSW5rTGlzdF8xLklua0xpc3RJdGVtLmZyb21TZXJpYWxpemVkS2V5KHZhbHVlWzBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZTogdmFsdWVbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3JpZ2luIGxpc3QgaXMgc2ltcGx5IHRoZSBvcmlnaW4gb2YgdGhlIG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xpc3QgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QocmFuZG9tSXRlbS5LZXkub3JpZ2luTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdMaXN0LkFkZChyYW5kb21JdGVtLktleSwgcmFuZG9tSXRlbS5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnByZXZpb3VzUmFuZG9tID0gbmV4dFJhbmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2sobmV3IFZhbHVlXzEuTGlzdFZhbHVlKG5ld0xpc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJ1bmhhbmRsZWQgQ29udHJvbENvbW1hbmQ6IFwiICsgZXZhbENvbW1hbmQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhcmlhYmxlIGFzc2lnbm1lbnRcbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIFZhcmlhYmxlQXNzaWdubWVudF8xLlZhcmlhYmxlQXNzaWdubWVudCkge1xuICAgICAgICAgICAgbGV0IHZhckFzcyA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgYXNzaWduZWRWYWwgPSB0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5Bc3NpZ24odmFyQXNzLCBhc3NpZ25lZFZhbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBWYXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgZWxzZSBpZiAoY29udGVudE9iaiBpbnN0YW5jZW9mIFZhcmlhYmxlUmVmZXJlbmNlXzEuVmFyaWFibGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgIGxldCB2YXJSZWYgPSBjb250ZW50T2JqO1xuICAgICAgICAgICAgbGV0IGZvdW5kVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgLy8gRXhwbGljaXQgcmVhZCBjb3VudCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHZhclJlZi5wYXRoRm9yQ291bnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB2YXJSZWYuY29udGFpbmVyRm9yQ291bnQ7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5zdGF0ZS5WaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgZm91bmRWYWx1ZSA9IG5ldyBWYWx1ZV8xLkludFZhbHVlKGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbCB2YXJpYWJsZSByZWZlcmVuY2VcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kVmFsdWUgPSB0aGlzLnN0YXRlLnZhcmlhYmxlc1N0YXRlLkdldFZhcmlhYmxlV2l0aE5hbWUodmFyUmVmLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5XYXJuaW5nKFwiVmFyaWFibGUgbm90IGZvdW5kOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyUmVmLm5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCInLiBVc2luZyBkZWZhdWx0IHZhbHVlIG9mIDAgKGZhbHNlKS4gVGhpcyBjYW4gaGFwcGVuIHdpdGggdGVtcG9yYXJ5IHZhcmlhYmxlcyBpZiB0aGUgZGVjbGFyYXRpb24gaGFzbid0IHlldCBiZWVuIGhpdC4gR2xvYmFscyBhcmUgYWx3YXlzIGdpdmVuIGEgZGVmYXVsdCB2YWx1ZSBvbiBsb2FkIGlmIGEgdmFsdWUgZG9lc24ndCBleGlzdCBpbiB0aGUgc2F2ZSBzdGF0ZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kVmFsdWUgPSBuZXcgVmFsdWVfMS5JbnRWYWx1ZSgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2soZm91bmRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOYXRpdmUgZnVuY3Rpb24gY2FsbFxuICAgICAgICBlbHNlIGlmIChjb250ZW50T2JqIGluc3RhbmNlb2YgTmF0aXZlRnVuY3Rpb25DYWxsXzEuTmF0aXZlRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBsZXQgZnVuYyA9IGNvbnRlbnRPYmo7XG4gICAgICAgICAgICBsZXQgZnVuY1BhcmFtcyA9IHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKGZ1bmMubnVtYmVyT2ZQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBmdW5jLkNhbGwoZnVuY1BhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2socmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGNvbnRyb2wgY29udGVudCwgbXVzdCBiZSBvcmRpbmFyeSBjb250ZW50XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgQ2hvb3NlUGF0aFN0cmluZyhwYXRoLCByZXNldENhbGxzdGFjayA9IHRydWUsIGFyZ3MgPSBbXSkge1xuICAgICAgICB0aGlzLklmQXN5bmNXZUNhbnQoXCJjYWxsIENob29zZVBhdGhTdHJpbmcgcmlnaHQgbm93XCIpO1xuICAgICAgICBpZiAocmVzZXRDYWxsc3RhY2spIHtcbiAgICAgICAgICAgIHRoaXMuUmVzZXRDYWxsc3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09IFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBmdW5jRGV0YWlsID0gXCJcIjtcbiAgICAgICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLmNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY0RldGFpbCA9IFwiKFwiICsgY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKSArIFwiKSBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Rvcnkgd2FzIHJ1bm5pbmcgYSBmdW5jdGlvbiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNEZXRhaWwgK1xuICAgICAgICAgICAgICAgICAgICBcIndoZW4geW91IGNhbGxlZCBDaG9vc2VQYXRoU3RyaW5nKFwiICtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgICAgIFwiKSAtIHRoaXMgaXMgYWxtb3N0IGNlcnRhaW5seSBub3Qgbm90IHdoYXQgeW91IHdhbnQhIEZ1bGwgc3RhY2sgdHJhY2U6IFxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suY2FsbFN0YWNrVHJhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpO1xuICAgICAgICB0aGlzLkNob29zZVBhdGgobmV3IFBhdGhfMS5QYXRoKHBhdGgpKTtcbiAgICB9XG4gICAgSWZBc3luY1dlQ2FudChhY3Rpdml0eVN0cikge1xuICAgICAgICBpZiAodGhpcy5fYXN5bmNDb250aW51ZUFjdGl2ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IFwiICtcbiAgICAgICAgICAgICAgICBhY3Rpdml0eVN0ciArXG4gICAgICAgICAgICAgICAgXCIuIFN0b3J5IGlzIGluIHRoZSBtaWRkbGUgb2YgYSBDb250aW51ZUFzeW5jKCkuIE1ha2UgbW9yZSBDb250aW51ZUFzeW5jKCkgY2FsbHMgb3IgYSBzaW5nbGUgQ29udGludWUoKSBjYWxsIGJlZm9yZWhhbmQuXCIpO1xuICAgIH1cbiAgICBDaG9vc2VQYXRoKHAsIGluY3JlbWVudGluZ1R1cm5JbmRleCA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5TZXRDaG9zZW5QYXRoKHAsIGluY3JlbWVudGluZ1R1cm5JbmRleCk7XG4gICAgICAgIC8vIFRha2UgYSBub3RlIG9mIG5ld2x5IHZpc2l0ZWQgY29udGFpbmVycyBmb3IgcmVhZCBjb3VudHMgZXRjXG4gICAgICAgIHRoaXMuVmlzaXRDaGFuZ2VkQ29udGFpbmVyc0R1ZVRvRGl2ZXJ0KCk7XG4gICAgfVxuICAgIENob29zZUNob2ljZUluZGV4KGNob2ljZUlkeCkge1xuICAgICAgICBjaG9pY2VJZHggPSBjaG9pY2VJZHg7XG4gICAgICAgIGxldCBjaG9pY2VzID0gdGhpcy5jdXJyZW50Q2hvaWNlcztcbiAgICAgICAgdGhpcy5Bc3NlcnQoY2hvaWNlSWR4ID49IDAgJiYgY2hvaWNlSWR4IDwgY2hvaWNlcy5sZW5ndGgsIFwiY2hvaWNlIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgbGV0IGNob2ljZVRvQ2hvb3NlID0gY2hvaWNlc1tjaG9pY2VJZHhdO1xuICAgICAgICBpZiAoY2hvaWNlVG9DaG9vc2UudGhyZWFkQXRHZW5lcmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImNob2ljZVRvQ2hvb3NlLnRocmVhZEF0R2VuZXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlVG9DaG9vc2UudGFyZ2V0UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQgPSBjaG9pY2VUb0Nob29zZS50aHJlYWRBdEdlbmVyYXRpb247XG4gICAgICAgIHRoaXMuQ2hvb3NlUGF0aChjaG9pY2VUb0Nob29zZS50YXJnZXRQYXRoKTtcbiAgICB9XG4gICAgSGFzRnVuY3Rpb24oZnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY3Rpb25OYW1lKSAhPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRXZhbHVhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGFyZ3MgPSBbXSwgcmV0dXJuVGV4dE91dHB1dCA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEV2YWx1YXRlRnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSB0aGFuIHRoZSBDIyB2ZXJzaW9uLlxuICAgICAgICAvLyBJbiBDIywgeW91IGNhbiBwYXNzIGEgKHNlY29uZCkgcGFyYW1ldGVyIGBvdXQgdGV4dE91dHB1dGAgdG8gZ2V0IHRoZVxuICAgICAgICAvLyB0ZXh0IG91dHB1dHRlZCBieSB0aGUgZnVuY3Rpb24uIFRoaXMgaXMgbm90IHBvc3NpYmxlIGluIGpzLiBJbnN0ZWFkLFxuICAgICAgICAvLyB3ZSBtYWludGFpbiB0aGUgcmVndWxhciBzaWduYXR1cmUgKGZ1bmN0aW9uTmFtZSwgYXJncyksIHBsdXMgYW5cbiAgICAgICAgLy8gb3B0aW9uYWwgdGhpcmQgcGFyYW1ldGVyIHJldHVyblRleHRPdXRwdXQuIElmIHNldCB0byB0cnVlLCB3ZSB3aWxsXG4gICAgICAgIC8vIHJldHVybiBib3RoIHRoZSB0ZXh0T3V0cHV0IGFuZCB0aGUgcmV0dXJuZWQgdmFsdWUsIGFzIGFuIG9iamVjdC5cbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwiZXZhbHVhdGUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uTmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBpcyBudWxsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSA9PSBcIlwiIHx8IGZ1bmN0aW9uTmFtZS50cmltKCkgPT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgZW1wdHkgb3Igd2hpdGUgc3BhY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdW5jQ29udGFpbmVyID0gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY3Rpb25OYW1lKTtcbiAgICAgICAgaWYgKGZ1bmNDb250YWluZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gZG9lc24ndCBleGlzdDogJ1wiICsgZnVuY3Rpb25OYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvdXRwdXRTdHJlYW1CZWZvcmUgPSBbXTtcbiAgICAgICAgb3V0cHV0U3RyZWFtQmVmb3JlLnB1c2guYXBwbHkob3V0cHV0U3RyZWFtQmVmb3JlLCB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbSk7XG4gICAgICAgIHRoaXMuX3N0YXRlLlJlc2V0T3V0cHV0KCk7XG4gICAgICAgIHRoaXMuc3RhdGUuU3RhcnRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZShmdW5jQ29udGFpbmVyLCBhcmdzKTtcbiAgICAgICAgLy8gRXZhbHVhdGUgdGhlIGZ1bmN0aW9uLCBhbmQgY29sbGVjdCB0aGUgc3RyaW5nIG91dHB1dFxuICAgICAgICBsZXQgc3RyaW5nT3V0cHV0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5TdHJpbmdCdWlsZGVyKCk7XG4gICAgICAgIHdoaWxlICh0aGlzLmNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgICBzdHJpbmdPdXRwdXQuQXBwZW5kKHRoaXMuQ29udGludWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHRPdXRwdXQgPSBzdHJpbmdPdXRwdXQudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fc3RhdGUuUmVzZXRPdXRwdXQob3V0cHV0U3RyZWFtQmVmb3JlKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3RhdGUuQ29tcGxldGVGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVGV4dE91dHB1dCA/IHsgcmV0dXJuZWQ6IHJlc3VsdCwgb3V0cHV0OiB0ZXh0T3V0cHV0IH0gOiByZXN1bHQ7XG4gICAgfVxuICAgIEV2YWx1YXRlRXhwcmVzc2lvbihleHByQ29udGFpbmVyKSB7XG4gICAgICAgIGxldCBzdGFydENhbGxTdGFja0hlaWdodCA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuVHVubmVsKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IGV4cHJDb250YWluZXI7XG4gICAgICAgIHRoaXMuc3RhdGUuR29Ub1N0YXJ0KCk7XG4gICAgICAgIGxldCBldmFsU3RhY2tIZWlnaHQgPSB0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIHRoaXMuQ29udGludWUoKTtcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGZhbGxlbiBvZmYgdGhlIGVuZCBvZiB0aGUgQ29udGFpbmVyLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhdXRvLXBvcHBlZCwgYnV0IGp1c3QgaW4gY2FzZSB3ZSBkaWRuJ3QgZm9yIHNvbWUgcmVhc29uLFxuICAgICAgICAvLyBtYW51YWxseSBwb3AgdG8gcmVzdG9yZSB0aGUgc3RhdGUgKGluY2x1ZGluZyBjdXJyZW50UGF0aCkuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNhbGxTdGFjay5lbGVtZW50cy5sZW5ndGggPiBzdGFydENhbGxTdGFja0hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5Qb3BDYWxsU3RhY2soKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kU3RhY2tIZWlnaHQgPSB0aGlzLnN0YXRlLmV2YWx1YXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChlbmRTdGFja0hlaWdodCA+IGV2YWxTdGFja0hlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBDYWxsRXh0ZXJuYWxGdW5jdGlvbihmdW5jTmFtZSwgbnVtYmVyT2ZBcmd1bWVudHMpIHtcbiAgICAgICAgaWYgKGZ1bmNOYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImZ1bmNOYW1lXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmdW5jID0gdGhpcy5fZXh0ZXJuYWxzLmdldChmdW5jTmFtZSk7XG4gICAgICAgIGxldCBmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgbGV0IGZvdW5kRXh0ZXJuYWwgPSB0eXBlb2YgZnVuYyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgLy8gVHJ5IHRvIHVzZSBmYWxsYmFjayBmdW5jdGlvbj9cbiAgICAgICAgaWYgKCFmb3VuZEV4dGVybmFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja0Z1bmN0aW9uQ29udGFpbmVyID0gdGhpcy5Lbm90Q29udGFpbmVyV2l0aE5hbWUoZnVuY05hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuQXNzZXJ0KGZhbGxiYWNrRnVuY3Rpb25Db250YWluZXIgIT09IG51bGwsIFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kLCBhbmQgZmFsbGJhY2sgaW5rIGZ1bmN0aW9uIGNvdWxkIG5vdCBiZSBmb3VuZC5cIik7XG4gICAgICAgICAgICAgICAgLy8gRGl2ZXJ0IGRpcmVjdCBpbnRvIGZhbGxiYWNrIGZ1bmN0aW9uIGFuZCB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jYWxsU3RhY2suUHVzaChQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24sIHVuZGVmaW5lZCwgdGhpcy5zdGF0ZS5vdXRwdXRTdHJlYW0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YoZmFsbGJhY2tGdW5jdGlvbkNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5Bc3NlcnQoZmFsc2UsIFwiVHJ5aW5nIHRvIGNhbGwgRVhURVJOQUwgZnVuY3Rpb24gJ1wiICtcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIicgd2hpY2ggaGFzIG5vdCBiZWVuIGJvdW5kIChhbmQgaW5rIGZhbGxiYWNrcyBkaXNhYmxlZCkuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBvcCBhcmd1bWVudHNcbiAgICAgICAgbGV0IGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkFyZ3VtZW50czsgKytpKSB7XG4gICAgICAgICAgICAvLyB2YXIgcG9wcGVkT2JqID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIFZhbHVlO1xuICAgICAgICAgICAgbGV0IHBvcHBlZE9iaiA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKHRoaXMuc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrKCksIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICAgICAgbGV0IHZhbHVlT2JqID0gcG9wcGVkT2JqLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgYXJncy5wdXNoKHZhbHVlT2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXZlcnNlIGFyZ3VtZW50cyBmcm9tIHRoZSBvcmRlciB0aGV5IHdlcmUgcG9wcGVkLFxuICAgICAgICAvLyBzbyB0aGV5J3JlIHRoZSByaWdodCB3YXkgcm91bmQgYWdhaW4uXG4gICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICAvLyBSdW4gdGhlIGZ1bmN0aW9uIVxuICAgICAgICBsZXQgZnVuY1Jlc3VsdCA9IGZ1bmMoYXJncyk7XG4gICAgICAgIC8vIENvbnZlcnQgcmV0dXJuIHZhbHVlIChpZiBhbnkpIHRvIHRoZSBhIHR5cGUgdGhhdCB0aGUgaW5rIGVuZ2luZSBjYW4gdXNlXG4gICAgICAgIGxldCByZXR1cm5PYmogPSBudWxsO1xuICAgICAgICBpZiAoZnVuY1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5PYmogPSBWYWx1ZV8xLlZhbHVlLkNyZWF0ZShmdW5jUmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMuQXNzZXJ0KHJldHVybk9iaiAhPT0gbnVsbCwgXCJDb3VsZCBub3QgY3JlYXRlIGluayB2YWx1ZSBmcm9tIHJldHVybmVkIG9iamVjdCBvZiB0eXBlIFwiICtcbiAgICAgICAgICAgICAgICB0eXBlb2YgZnVuY1Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5PYmogPSBuZXcgVm9pZF8xLlZvaWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLlB1c2hFdmFsdWF0aW9uU3RhY2socmV0dXJuT2JqKTtcbiAgICB9XG4gICAgQmluZEV4dGVybmFsRnVuY3Rpb25HZW5lcmFsKGZ1bmNOYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcImJpbmQgYW4gZXh0ZXJuYWwgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuQXNzZXJ0KCF0aGlzLl9leHRlcm5hbHMuaGFzKGZ1bmNOYW1lKSwgXCJGdW5jdGlvbiAnXCIgKyBmdW5jTmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kLlwiKTtcbiAgICAgICAgdGhpcy5fZXh0ZXJuYWxzLnNldChmdW5jTmFtZSwgZnVuYyk7XG4gICAgfVxuICAgIFRyeUNvZXJjZSh2YWx1ZSkge1xuICAgICAgICAvLyBXZSdyZSBza2lwcGluZyB0eXBlIGNvZXJjaXRpb24gaW4gdGhpcyBpbXBsZW1lbnRhdGlvbi4gRmlyc3Qgb2YsIGpzXG4gICAgICAgIC8vIGlzIGxvb3NlbHkgdHlwZWQsIHNvIGl0J3Mgbm90IHRoYXQgaW1wb3J0YW50LiBTZWNvbmRseSwgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gY2xlYW4gd2F5IChBRkFJSykgZm9yIHRoZSB1c2VyIHRvIGRlc2NyaWJlIHdoYXQgdHlwZSBvZiBwYXJhbWV0ZXJzXG4gICAgICAgIC8vIHRoZXkgZXhwZWN0LlxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIEJpbmRFeHRlcm5hbEZ1bmN0aW9uKGZ1bmNOYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuQXNzZXJ0KGZ1bmMgIT0gbnVsbCwgXCJDYW4ndCBiaW5kIGEgbnVsbCBmdW5jdGlvblwiKTtcbiAgICAgICAgdGhpcy5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLkFzc2VydChhcmdzLmxlbmd0aCA+PSBmdW5jLmxlbmd0aCwgXCJFeHRlcm5hbCBmdW5jdGlvbiBleHBlY3RlZCBcIiArIGZ1bmMubGVuZ3RoICsgXCIgYXJndW1lbnRzXCIpO1xuICAgICAgICAgICAgbGV0IGNvZXJjZWRBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFyZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29lcmNlZEFyZ3NbaV0gPSB0aGlzLlRyeUNvZXJjZShhcmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGNvZXJjZWRBcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFVuYmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwidW5iaW5kIGFuIGV4dGVybmFsIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuQXNzZXJ0KHRoaXMuX2V4dGVybmFscy5oYXMoZnVuY05hbWUpLCBcIkZ1bmN0aW9uICdcIiArIGZ1bmNOYW1lICsgXCInIGhhcyBub3QgYmVlbiBib3VuZC5cIik7XG4gICAgICAgIHRoaXMuX2V4dGVybmFscy5kZWxldGUoZnVuY05hbWUpO1xuICAgIH1cbiAgICBWYWxpZGF0ZUV4dGVybmFsQmluZGluZ3MoKSB7XG4gICAgICAgIGxldCBjID0gbnVsbDtcbiAgICAgICAgbGV0IG8gPSBudWxsO1xuICAgICAgICBsZXQgbWlzc2luZ0V4dGVybmFscyA9IGFyZ3VtZW50c1sxXSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb250YWluZXJfMS5Db250YWluZXIpIHtcbiAgICAgICAgICAgIGMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdF8xLklua09iamVjdCkge1xuICAgICAgICAgICAgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA9PT0gbnVsbCAmJiBvID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyh0aGlzLl9tYWluQ29udGVudENvbnRhaW5lciwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB0aGlzLl9oYXNWYWxpZGF0ZWRFeHRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgLy8gTm8gcHJvYmxlbSEgVmFsaWRhdGlvbiBjb21wbGV0ZVxuICAgICAgICAgICAgaWYgKG1pc3NpbmdFeHRlcm5hbHMuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVmFsaWRhdGVkRXh0ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJFcnJvcjogTWlzc2luZyBmdW5jdGlvbiBiaW5kaW5nIGZvciBleHRlcm5hbFwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gbWlzc2luZ0V4dGVybmFscy5zaXplID4gMSA/IFwic1wiIDogXCJcIjtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiOiAnXCI7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBBcnJheS5mcm9tKG1pc3NpbmdFeHRlcm5hbHMpLmpvaW4oXCInLCAnXCIpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCInIFwiO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gdGhpcy5hbGxvd0V4dGVybmFsRnVuY3Rpb25GYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgICAgPyBcIiwgYW5kIG5vIGZhbGxiYWNrIGluayBmdW5jdGlvbiBmb3VuZC5cIlxuICAgICAgICAgICAgICAgICAgICA6IFwiIChpbmsgZmFsbGJhY2tzIGRpc2FibGVkKVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpbm5lckNvbnRlbnQgb2YgYy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnRhaW5lciA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbmVyID09IG51bGwgfHwgIWNvbnRhaW5lci5oYXNWYWxpZE5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVmFsaWRhdGVFeHRlcm5hbEJpbmRpbmdzKGlubmVyQ29udGVudCwgbWlzc2luZ0V4dGVybmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBbLCB2YWx1ZV0gb2YgYy5uYW1lZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlZhbGlkYXRlRXh0ZXJuYWxCaW5kaW5ncyhUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWUsIE9iamVjdF8xLklua09iamVjdCksIG1pc3NpbmdFeHRlcm5hbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGRpdmVydCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvLCBEaXZlcnRfMS5EaXZlcnQpO1xuICAgICAgICAgICAgaWYgKGRpdmVydCAmJiBkaXZlcnQuaXNFeHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZGl2ZXJ0LnRhcmdldFBhdGhTdHJpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuYW1lXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2V4dGVybmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dFeHRlcm5hbEZ1bmN0aW9uRmFsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmFsbGJhY2tGb3VuZCA9IHRoaXMubWFpbkNvbnRlbnRDb250YWluZXIubmFtZWRDb250ZW50LmhhcyhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZmFsbGJhY2tGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmdFeHRlcm5hbHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlzc2luZ0V4dGVybmFscy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JzZXJ2ZVZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5JZkFzeW5jV2VDYW50KFwib2JzZXJ2ZSBhIG5ldyB2YXJpYWJsZVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzID09PSBudWxsKVxuICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS52YXJpYWJsZXNTdGF0ZS5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKHZhcmlhYmxlTmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBvYnNlcnZlIHZhcmlhYmxlICdcIiArXG4gICAgICAgICAgICAgICAgdmFyaWFibGVOYW1lICtcbiAgICAgICAgICAgICAgICBcIicgYmVjYXVzZSBpdCB3YXNuJ3QgZGVjbGFyZWQgaW4gdGhlIGluayBzdG9yeS5cIik7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXModmFyaWFibGVOYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fdmFyaWFibGVPYnNlcnZlcnMuZ2V0KHZhcmlhYmxlTmFtZSkucHVzaChvYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5zZXQodmFyaWFibGVOYW1lLCBbb2JzZXJ2ZXJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZlVmFyaWFibGVzKHZhcmlhYmxlTmFtZXMsIG9ic2VydmVycykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHZhcmlhYmxlTmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLk9ic2VydmVWYXJpYWJsZSh2YXJpYWJsZU5hbWVzW2ldLCBvYnNlcnZlcnNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlbW92ZVZhcmlhYmxlT2JzZXJ2ZXIob2JzZXJ2ZXIsIHNwZWNpZmljVmFyaWFibGVOYW1lKSB7XG4gICAgICAgIHRoaXMuSWZBc3luY1dlQ2FudChcInJlbW92ZSBhIHZhcmlhYmxlIG9ic2VydmVyXCIpO1xuICAgICAgICBpZiAodGhpcy5fdmFyaWFibGVPYnNlcnZlcnMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0eXBlb2Ygc3BlY2lmaWNWYXJpYWJsZU5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycy5oYXMoc3BlY2lmaWNWYXJpYWJsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldChzcGVjaWZpY1ZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uob2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmRlbGV0ZShzcGVjaWZpY1ZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmtleXMoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHZhck5hbWUgb2Yga2V5cykge1xuICAgICAgICAgICAgICAgIGxldCBvYnNlcnZlcnMgPSB0aGlzLl92YXJpYWJsZU9ic2VydmVycy5nZXQodmFyTmFtZSk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShvYnNlcnZlcnMuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFZhcmlhYmxlU3RhdGVEaWRDaGFuZ2VFdmVudCh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlT2JqKSB7XG4gICAgICAgIGlmICh0aGlzLl92YXJpYWJsZU9ic2VydmVycyA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IG9ic2VydmVycyA9IHRoaXMuX3ZhcmlhYmxlT2JzZXJ2ZXJzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICBpZiAodHlwZW9mIG9ic2VydmVycyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgaWYgKCEobmV3VmFsdWVPYmogaW5zdGFuY2VvZiBWYWx1ZV8xLlZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyaWVkIHRvIGdldCB0aGUgdmFsdWUgb2YgYSB2YXJpYWJsZSB0aGF0IGlzbid0IGEgc3RhbmRhcmQgdHlwZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhciB2YWwgPSBuZXdWYWx1ZU9iaiBhcyBWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhuZXdWYWx1ZU9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcih2YXJpYWJsZU5hbWUsIHZhbC52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGdsb2JhbFRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlRhZ3NBdFN0YXJ0T2ZGbG93Q29udGFpbmVyV2l0aFBhdGhTdHJpbmcoXCJcIik7XG4gICAgfVxuICAgIFRhZ3NGb3JDb250ZW50QXRQYXRoKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhwYXRoKTtcbiAgICB9XG4gICAgVGFnc0F0U3RhcnRPZkZsb3dDb250YWluZXJXaXRoUGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gICAgICAgIGxldCBwYXRoID0gbmV3IFBhdGhfMS5QYXRoKHBhdGhTdHJpbmcpO1xuICAgICAgICBsZXQgZmxvd0NvbnRhaW5lciA9IHRoaXMuQ29udGVudEF0UGF0aChwYXRoKS5jb250YWluZXI7XG4gICAgICAgIGlmIChmbG93Q29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImZsb3dDb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdENvbnRlbnQgPSBmbG93Q29udGFpbmVyLmNvbnRlbnRbMF07XG4gICAgICAgICAgICBpZiAoZmlyc3RDb250ZW50IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKVxuICAgICAgICAgICAgICAgIGZsb3dDb250YWluZXIgPSBmaXJzdENvbnRlbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhZ3MgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBjIG9mIGZsb3dDb250YWluZXIuY29udGVudCkge1xuICAgICAgICAgICAgLy8gdmFyIHRhZyA9IGMgYXMgUnVudGltZS5UYWc7XG4gICAgICAgICAgICBsZXQgdGFnID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKGMsIFRhZ18xLlRhZyk7XG4gICAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZ3MgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICAgICAgICAgIHRhZ3MucHVzaCh0YWcudGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfVxuICAgIEJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICB0aGlzLm1haW5Db250ZW50Q29udGFpbmVyLkJ1aWxkU3RyaW5nT2ZIaWVyYXJjaHkoc2IsIDAsIHRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuUmVzb2x2ZSgpKTtcbiAgICAgICAgcmV0dXJuIHNiLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIEJ1aWxkU3RyaW5nT2ZDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGxldCBzYiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuU3RyaW5nQnVpbGRlcigpO1xuICAgICAgICBjb250YWluZXIuQnVpbGRTdHJpbmdPZkhpZXJhcmNoeShzYiwgMCwgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5SZXNvbHZlKCkpO1xuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgTmV4dENvbnRlbnQoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucHJldmlvdXNQb2ludGVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyID0gdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIuY29weSgpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXZlcnRlZFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgdGhpcy5WaXNpdENoYW5nZWRDb250YWluZXJzRHVlVG9EaXZlcnQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1Y2Nlc3NmdWxQb2ludGVySW5jcmVtZW50ID0gdGhpcy5JbmNyZW1lbnRDb250ZW50UG9pbnRlcigpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3NmdWxQb2ludGVySW5jcmVtZW50KSB7XG4gICAgICAgICAgICBsZXQgZGlkUG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jYWxsU3RhY2suQ2FuUG9wKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlBvcENhbGxTdGFjayhQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRXhwcmVzc2lvbkV2YWx1YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5QdXNoRXZhbHVhdGlvblN0YWNrKG5ldyBWb2lkXzEuVm9pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlkUG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUuY2FsbFN0YWNrLmNhblBvcFRocmVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLlBvcFRocmVhZCgpO1xuICAgICAgICAgICAgICAgIGRpZFBvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLlRyeUV4aXRGdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpZFBvcCAmJiAhdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLk5leHRDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSW5jcmVtZW50Q29udGVudFBvaW50ZXIoKSB7XG4gICAgICAgIGxldCBzdWNjZXNzZnVsSW5jcmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlci5jb3B5KCk7XG4gICAgICAgIHBvaW50ZXIuaW5kZXgrKztcbiAgICAgICAgaWYgKHBvaW50ZXIuY29udGFpbmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChwb2ludGVyLmluZGV4ID49IHBvaW50ZXIuY29udGFpbmVyLmNvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdWNjZXNzZnVsSW5jcmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBDb250YWluZXIgbmV4dEFuY2VzdG9yID0gcG9pbnRlci5jb250YWluZXIucGFyZW50IGFzIENvbnRhaW5lcjtcbiAgICAgICAgICAgIGxldCBuZXh0QW5jZXN0b3IgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwocG9pbnRlci5jb250YWluZXIucGFyZW50LCBDb250YWluZXJfMS5Db250YWluZXIpO1xuICAgICAgICAgICAgaWYgKG5leHRBbmNlc3RvciBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbmRleEluQW5jZXN0b3IgPSBuZXh0QW5jZXN0b3IuY29udGVudC5pbmRleE9mKHBvaW50ZXIuY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmIChpbmRleEluQW5jZXN0b3IgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50ZXIgPSBuZXcgUG9pbnRlcl8xLlBvaW50ZXIobmV4dEFuY2VzdG9yLCBpbmRleEluQW5jZXN0b3IpO1xuICAgICAgICAgICAgcG9pbnRlci5pbmRleCsrO1xuICAgICAgICAgICAgc3VjY2Vzc2Z1bEluY3JlbWVudCA9IHRydWU7XG4gICAgICAgICAgICBpZiAocG9pbnRlci5jb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInBvaW50ZXIuY29udGFpbmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc3VjY2Vzc2Z1bEluY3JlbWVudClcbiAgICAgICAgICAgIHBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnN0YXRlLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IHBvaW50ZXIuY29weSgpO1xuICAgICAgICByZXR1cm4gc3VjY2Vzc2Z1bEluY3JlbWVudDtcbiAgICB9XG4gICAgVHJ5Rm9sbG93RGVmYXVsdEludmlzaWJsZUNob2ljZSgpIHtcbiAgICAgICAgbGV0IGFsbENob2ljZXMgPSB0aGlzLl9zdGF0ZS5jdXJyZW50Q2hvaWNlcztcbiAgICAgICAgbGV0IGludmlzaWJsZUNob2ljZXMgPSBhbGxDaG9pY2VzLmZpbHRlcigoYykgPT4gYy5pc0ludmlzaWJsZURlZmF1bHQpO1xuICAgICAgICBpZiAoaW52aXNpYmxlQ2hvaWNlcy5sZW5ndGggPT0gMCB8fFxuICAgICAgICAgICAgYWxsQ2hvaWNlcy5sZW5ndGggPiBpbnZpc2libGVDaG9pY2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNob2ljZSA9IGludmlzaWJsZUNob2ljZXNbMF07XG4gICAgICAgIGlmIChjaG9pY2UudGFyZ2V0UGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2UudGFyZ2V0UGF0aFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hvaWNlLnRocmVhZEF0R2VuZXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQgPSBjaG9pY2UudGhyZWFkQXRHZW5lcmF0aW9uO1xuICAgICAgICB0aGlzLkNob29zZVBhdGgoY2hvaWNlLnRhcmdldFBhdGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIE5leHRTZXF1ZW5jZVNodWZmbGVJbmRleCgpIHtcbiAgICAgICAgLy8gdmFyIG51bUVsZW1lbnRzSW50VmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIEludFZhbHVlO1xuICAgICAgICBsZXQgbnVtRWxlbWVudHNJbnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5zdGF0ZS5Qb3BFdmFsdWF0aW9uU3RhY2soKSwgVmFsdWVfMS5JbnRWYWx1ZSk7XG4gICAgICAgIGlmICghKG51bUVsZW1lbnRzSW50VmFsIGluc3RhbmNlb2YgVmFsdWVfMS5JbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuRXJyb3IoXCJleHBlY3RlZCBudW1iZXIgb2YgZWxlbWVudHMgaW4gc2VxdWVuY2UgZm9yIHNodWZmbGUgaW5kZXhcIik7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VxQ29udGFpbmVyID0gdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlci5jb250YWluZXI7XG4gICAgICAgIGlmIChzZXFDb250YWluZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwic2VxQ29udGFpbmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgIGlmIChudW1FbGVtZW50c0ludFZhbC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJudW1FbGVtZW50c0ludFZhbC52YWx1ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbnVtRWxlbWVudHMgPSBudW1FbGVtZW50c0ludFZhbC52YWx1ZTtcbiAgICAgICAgLy8gdmFyIHNlcUNvdW50VmFsID0gc3RhdGUuUG9wRXZhbHVhdGlvblN0YWNrICgpIGFzIEludFZhbHVlO1xuICAgICAgICBsZXQgc2VxQ291bnRWYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh0aGlzLnN0YXRlLlBvcEV2YWx1YXRpb25TdGFjaygpLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgbGV0IHNlcUNvdW50ID0gc2VxQ291bnRWYWwudmFsdWU7XG4gICAgICAgIC8vIE9yaWdpbmFsbHkgYSBwcmltaXRpdmUgdHlwZSwgYnV0IGhlcmUsIGNhbiBiZSBudWxsLlxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIGJ5IGRlZmF1bHQgdmFsdWU/XG4gICAgICAgIGlmIChzZXFDb3VudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJzZXFDb3VudFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9vcEluZGV4ID0gc2VxQ291bnQgLyBudW1FbGVtZW50cztcbiAgICAgICAgbGV0IGl0ZXJhdGlvbkluZGV4ID0gc2VxQ291bnQgJSBudW1FbGVtZW50cztcbiAgICAgICAgbGV0IHNlcVBhdGhTdHIgPSBzZXFDb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgc2VxdWVuY2VIYXNoID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBzZXFQYXRoU3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgc2VxdWVuY2VIYXNoICs9IHNlcVBhdGhTdHIuY2hhckNvZGVBdChpKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5kb21TZWVkID0gc2VxdWVuY2VIYXNoICsgbG9vcEluZGV4ICsgdGhpcy5zdGF0ZS5zdG9yeVNlZWQ7XG4gICAgICAgIGxldCByYW5kb20gPSBuZXcgUFJOR18xLlBSTkcoTWF0aC5mbG9vcihyYW5kb21TZWVkKSk7XG4gICAgICAgIGxldCB1bnBpY2tlZEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGVtZW50czsgKytpKSB7XG4gICAgICAgICAgICB1bnBpY2tlZEluZGljZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBpdGVyYXRpb25JbmRleDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgY2hvc2VuID0gcmFuZG9tLm5leHQoKSAlIHVucGlja2VkSW5kaWNlcy5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgY2hvc2VuSW5kZXggPSB1bnBpY2tlZEluZGljZXNbY2hvc2VuXTtcbiAgICAgICAgICAgIHVucGlja2VkSW5kaWNlcy5zcGxpY2UoY2hvc2VuLCAxKTtcbiAgICAgICAgICAgIGlmIChpID09IGl0ZXJhdGlvbkluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNob3NlbkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaCBoZXJlXCIpO1xuICAgIH1cbiAgICBFcnJvcihtZXNzYWdlLCB1c2VFbmRMaW5lTnVtYmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGUgPSBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihtZXNzYWdlKTtcbiAgICAgICAgZS51c2VFbmRMaW5lTnVtYmVyID0gdXNlRW5kTGluZU51bWJlcjtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgV2FybmluZyhtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuQWRkRXJyb3IobWVzc2FnZSwgdHJ1ZSk7XG4gICAgfVxuICAgIEFkZEVycm9yKG1lc3NhZ2UsIGlzV2FybmluZyA9IGZhbHNlLCB1c2VFbmRMaW5lTnVtYmVyID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGRtID0gdGhpcy5jdXJyZW50RGVidWdNZXRhZGF0YTtcbiAgICAgICAgbGV0IGVycm9yVHlwZVN0ciA9IGlzV2FybmluZyA/IFwiV0FSTklOR1wiIDogXCJFUlJPUlwiO1xuICAgICAgICBpZiAoZG0gIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGxpbmVOdW0gPSB1c2VFbmRMaW5lTnVtYmVyID8gZG0uZW5kTGluZU51bWJlciA6IGRtLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIG1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIFwiUlVOVElNRSBcIiArXG4gICAgICAgICAgICAgICAgICAgIGVycm9yVHlwZVN0ciArXG4gICAgICAgICAgICAgICAgICAgIFwiOiAnXCIgK1xuICAgICAgICAgICAgICAgICAgICBkbS5maWxlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiJyBsaW5lIFwiICtcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bSArXG4gICAgICAgICAgICAgICAgICAgIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhdGUuY3VycmVudFBvaW50ZXIuaXNOdWxsKSB7XG4gICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICBcIlJVTlRJTUUgXCIgK1xuICAgICAgICAgICAgICAgICAgICBlcnJvclR5cGVTdHIgK1xuICAgICAgICAgICAgICAgICAgICBcIjogKFwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50UG9pbnRlciArXG4gICAgICAgICAgICAgICAgICAgIFwiKTogXCIgK1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiUlVOVElNRSBcIiArIGVycm9yVHlwZVN0ciArIFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5BZGRFcnJvcihtZXNzYWdlLCBpc1dhcm5pbmcpO1xuICAgICAgICAvLyBJbiBhIGJyb2tlbiBzdGF0ZSBkb24ndCBuZWVkIHRvIGtub3cgYWJvdXQgYW55IG90aGVyIGVycm9ycy5cbiAgICAgICAgaWYgKCFpc1dhcm5pbmcpXG4gICAgICAgICAgICB0aGlzLnN0YXRlLkZvcmNlRW5kKCk7XG4gICAgfVxuICAgIEFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UgPSBudWxsKSB7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJTdG9yeSBhc3NlcnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlICsgXCIgXCIgKyB0aGlzLmN1cnJlbnREZWJ1Z01ldGFkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VycmVudERlYnVnTWV0YWRhdGEoKSB7XG4gICAgICAgIGxldCBkbTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnN0YXRlLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsICYmIHBvaW50ZXIuUmVzb2x2ZSgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkbSA9IHBvaW50ZXIuUmVzb2x2ZSgpLmRlYnVnTWV0YWRhdGE7XG4gICAgICAgICAgICBpZiAoZG0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGUuY2FsbFN0YWNrLmVsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBwb2ludGVyID0gdGhpcy5zdGF0ZS5jYWxsU3RhY2suZWxlbWVudHNbaV0uY3VycmVudFBvaW50ZXI7XG4gICAgICAgICAgICBpZiAoIXBvaW50ZXIuaXNOdWxsICYmIHBvaW50ZXIuUmVzb2x2ZSgpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZG0gPSBwb2ludGVyLlJlc29sdmUoKS5kZWJ1Z01ldGFkYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLm91dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgbGV0IG91dHB1dE9iaiA9IHRoaXMuc3RhdGUub3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgZG0gPSBvdXRwdXRPYmouZGVidWdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChkbSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1haW5Db250ZW50Q29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fdGVtcG9yYXJ5RXZhbHVhdGlvbkNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RlbXBvcmFyeUV2YWx1YXRpb25Db250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFpbkNvbnRlbnRDb250YWluZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlN0b3J5ID0gU3Rvcnk7XG5TdG9yeS5pbmtWZXJzaW9uQ3VycmVudCA9IDE5O1xuKGZ1bmN0aW9uIChTdG9yeSkge1xuICAgIGxldCBPdXRwdXRTdGF0ZUNoYW5nZTtcbiAgICAoZnVuY3Rpb24gKE91dHB1dFN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIE91dHB1dFN0YXRlQ2hhbmdlW091dHB1dFN0YXRlQ2hhbmdlW1wiTm9DaGFuZ2VcIl0gPSAwXSA9IFwiTm9DaGFuZ2VcIjtcbiAgICAgICAgT3V0cHV0U3RhdGVDaGFuZ2VbT3V0cHV0U3RhdGVDaGFuZ2VbXCJFeHRlbmRlZEJleW9uZE5ld2xpbmVcIl0gPSAxXSA9IFwiRXh0ZW5kZWRCZXlvbmROZXdsaW5lXCI7XG4gICAgICAgIE91dHB1dFN0YXRlQ2hhbmdlW091dHB1dFN0YXRlQ2hhbmdlW1wiTmV3bGluZVJlbW92ZWRcIl0gPSAyXSA9IFwiTmV3bGluZVJlbW92ZWRcIjtcbiAgICB9KShPdXRwdXRTdGF0ZUNoYW5nZSA9IFN0b3J5Lk91dHB1dFN0YXRlQ2hhbmdlIHx8IChTdG9yeS5PdXRwdXRTdGF0ZUNoYW5nZSA9IHt9KSk7XG59KShTdG9yeSA9IGV4cG9ydHMuU3RvcnkgfHwgKGV4cG9ydHMuU3RvcnkgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3J5RXhjZXB0aW9uID0gdm9pZCAwO1xuY2xhc3MgU3RvcnlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy51c2VFbmRMaW5lTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiU3RvcnlFeGNlcHRpb25cIjtcbiAgICB9XG59XG5leHBvcnRzLlN0b3J5RXhjZXB0aW9uID0gU3RvcnlFeGNlcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yeUV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RvcnlTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IENhbGxTdGFja18xID0gcmVxdWlyZShcIi4vQ2FsbFN0YWNrXCIpO1xuY29uc3QgVmFyaWFibGVzU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1ZhcmlhYmxlc1N0YXRlXCIpO1xuY29uc3QgVmFsdWVfMSA9IHJlcXVpcmUoXCIuL1ZhbHVlXCIpO1xuY29uc3QgUHVzaFBvcF8xID0gcmVxdWlyZShcIi4vUHVzaFBvcFwiKTtcbmNvbnN0IFRhZ18xID0gcmVxdWlyZShcIi4vVGFnXCIpO1xuY29uc3QgR2x1ZV8xID0gcmVxdWlyZShcIi4vR2x1ZVwiKTtcbmNvbnN0IFBhdGhfMSA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5jb25zdCBDb250cm9sQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29udHJvbENvbW1hbmRcIik7XG5jb25zdCBTdG9yeUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vU3RvcnlFeGNlcHRpb25cIik7XG5jb25zdCBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdCdWlsZGVyXCIpO1xuY29uc3QgSnNvblNlcmlhbGlzYXRpb25fMSA9IHJlcXVpcmUoXCIuL0pzb25TZXJpYWxpc2F0aW9uXCIpO1xuY29uc3QgUFJOR18xID0gcmVxdWlyZShcIi4vUFJOR1wiKTtcbmNvbnN0IFZvaWRfMSA9IHJlcXVpcmUoXCIuL1ZvaWRcIik7XG5jb25zdCBQb2ludGVyXzEgPSByZXF1aXJlKFwiLi9Qb2ludGVyXCIpO1xuY29uc3QgVHJ5R2V0UmVzdWx0XzEgPSByZXF1aXJlKFwiLi9UcnlHZXRSZXN1bHRcIik7XG5jb25zdCBUeXBlQXNzZXJ0aW9uXzEgPSByZXF1aXJlKFwiLi9UeXBlQXNzZXJ0aW9uXCIpO1xuY29uc3QgRGVidWdfMSA9IHJlcXVpcmUoXCIuL0RlYnVnXCIpO1xuY29uc3QgTnVsbEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vTnVsbEV4Y2VwdGlvblwiKTtcbmNvbnN0IFN0b3J5XzEgPSByZXF1aXJlKFwiLi9TdG9yeVwiKTtcbmNvbnN0IFN0YXRlUGF0Y2hfMSA9IHJlcXVpcmUoXCIuL1N0YXRlUGF0Y2hcIik7XG5jb25zdCBTaW1wbGVKc29uXzEgPSByZXF1aXJlKFwiLi9TaW1wbGVKc29uXCIpO1xuY2xhc3MgU3RvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RvcnkpIHtcbiAgICAgICAgdGhpcy5rSW5rU2F2ZVN0YXRlVmVyc2lvbiA9IDg7XG4gICAgICAgIHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbiA9IDg7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRFcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50V2FybmluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmRpdmVydGVkUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUdXJuSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNSYW5kb20gPSAwO1xuICAgICAgICB0aGlzLmRpZFNhZmVFeGl0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UZXh0RGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW1UYWdzRGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXRjaCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcnkgPSBzdG9yeTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0gW107XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgdGhpcy5fZXZhbHVhdGlvblN0YWNrID0gW107XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjayhzdG9yeSk7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1N0YXRlID0gbmV3IFZhcmlhYmxlc1N0YXRlXzEuVmFyaWFibGVzU3RhdGUodGhpcy5jYWxsU3RhY2ssIHN0b3J5Lmxpc3REZWZpbml0aW9ucyk7XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl90dXJuSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VHVybkluZGV4ID0gLTE7XG4gICAgICAgIGxldCB0aW1lU2VlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLnN0b3J5U2VlZCA9IG5ldyBQUk5HXzEuUFJORyh0aW1lU2VlZCkubmV4dCgpICUgMTAwO1xuICAgICAgICB0aGlzLnByZXZpb3VzUmFuZG9tID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMgPSBbXTtcbiAgICAgICAgdGhpcy5Hb1RvU3RhcnQoKTtcbiAgICB9XG4gICAgVG9Kc29uKGluZGVudGVkID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHdyaXRlciA9IG5ldyBTaW1wbGVKc29uXzEuU2ltcGxlSnNvbi5Xcml0ZXIoKTtcbiAgICAgICAgdGhpcy5Xcml0ZUpzb24od3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlci5Ub1N0cmluZygpO1xuICAgIH1cbiAgICB0b0pzb24oaW5kZW50ZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5Ub0pzb24oaW5kZW50ZWQpO1xuICAgIH1cbiAgICBMb2FkSnNvbihqc29uKSB7XG4gICAgICAgIGxldCBqT2JqZWN0ID0gU2ltcGxlSnNvbl8xLlNpbXBsZUpzb24uVGV4dFRvRGljdGlvbmFyeShqc29uKTtcbiAgICAgICAgdGhpcy5Mb2FkSnNvbk9iaihqT2JqZWN0KTtcbiAgICB9XG4gICAgVmlzaXRDb3VudEF0UGF0aFN0cmluZyhwYXRoU3RyaW5nKSB7XG4gICAgICAgIGxldCB2aXNpdENvdW50T3V0O1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLnN0b3J5LkNvbnRlbnRBdFBhdGgobmV3IFBhdGhfMS5QYXRoKHBhdGhTdHJpbmcpKS5jb250YWluZXI7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRlbnQgYXQgcGF0aCBub3QgZm91bmQ6IFwiICsgcGF0aFN0cmluZyk7XG4gICAgICAgICAgICB2aXNpdENvdW50T3V0ID0gdGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKHZpc2l0Q291bnRPdXQuZXhpc3RzKVxuICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdENvdW50T3V0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdENvdW50T3V0ID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3Zpc2l0Q291bnRzLCBwYXRoU3RyaW5nLCBudWxsKTtcbiAgICAgICAgaWYgKHZpc2l0Q291bnRPdXQuZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0Q291bnRPdXQucmVzdWx0O1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgVmlzaXRDb3VudEZvckNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJjb250YWluZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250YWluZXIudmlzaXRzU2hvdWxkQmVDb3VudGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3J5LkVycm9yKFwiUmVhZCBjb3VudCBmb3IgdGFyZ2V0IChcIiArXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiIC0gb24gXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5kZWJ1Z01ldGFkYXRhICtcbiAgICAgICAgICAgICAgICBcIikgdW5rbm93bi4gVGhlIHN0b3J5IG1heSBuZWVkIHRvIGJlIGNvbXBpbGVkIHdpdGggY291bnRBbGxWaXNpdHMgZmxhZyAoLWMpLlwiKTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5fcGF0Y2guVHJ5R2V0VmlzaXRDb3VudChjb250YWluZXIsIDApO1xuICAgICAgICAgICAgaWYgKGNvdW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb3VudC5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgY291bnQyID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX3Zpc2l0Q291bnRzLCBjb250YWluZXJQYXRoU3RyLCBudWxsKTtcbiAgICAgICAgaWYgKGNvdW50Mi5leGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDIucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBJbmNyZW1lbnRWaXNpdENvdW50Rm9yQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgICBpZiAodGhpcy5fcGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjdXJyQ291bnQgPSB0aGlzLlZpc2l0Q291bnRGb3JDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGN1cnJDb3VudCsrO1xuICAgICAgICAgICAgdGhpcy5fcGF0Y2guU2V0VmlzaXRDb3VudChjb250YWluZXIsIGN1cnJDb3VudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRhaW5lclBhdGhTdHIgPSBjb250YWluZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICBsZXQgY291bnQgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fdmlzaXRDb3VudHMsIGNvbnRhaW5lclBhdGhTdHIsIG51bGwpO1xuICAgICAgICBpZiAoY291bnQuZXhpc3RzKSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyUGF0aFN0ciwgY291bnQucmVzdWx0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92aXNpdENvdW50cy5zZXQoY29udGFpbmVyUGF0aFN0ciwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmVjb3JkVHVybkluZGV4VmlzaXRUb0NvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXRjaC5TZXRUdXJuSW5kZXgoY29udGFpbmVyLCB0aGlzLmN1cnJlbnRUdXJuSW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5fdHVybkluZGljZXMuc2V0KGNvbnRhaW5lclBhdGhTdHIsIHRoaXMuY3VycmVudFR1cm5JbmRleCk7XG4gICAgfVxuICAgIFR1cm5zU2luY2VGb3JDb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIGlmICghY29udGFpbmVyLnR1cm5JbmRleFNob3VsZEJlQ291bnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9yeS5FcnJvcihcIlRVUk5TX1NJTkNFKCkgZm9yIHRhcmdldCAoXCIgK1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5uYW1lICtcbiAgICAgICAgICAgICAgICBcIiAtIG9uIFwiICtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuZGVidWdNZXRhZGF0YSArXG4gICAgICAgICAgICAgICAgXCIpIHVua25vd24uIFRoZSBzdG9yeSBtYXkgbmVlZCB0byBiZSBjb21waWxlZCB3aXRoIGNvdW50QWxsVmlzaXRzIGZsYWcgKC1jKS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl9wYXRjaC5UcnlHZXRUdXJuSW5kZXgoY29udGFpbmVyLCAwKTtcbiAgICAgICAgICAgIGlmIChpbmRleC5leGlzdHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VHVybkluZGV4IC0gaW5kZXgucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250YWluZXJQYXRoU3RyID0gY29udGFpbmVyLnBhdGgudG9TdHJpbmcoKTtcbiAgICAgICAgbGV0IGluZGV4MiA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl90dXJuSW5kaWNlcywgY29udGFpbmVyUGF0aFN0ciwgMCk7XG4gICAgICAgIGlmIChpbmRleDIuZXhpc3RzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VHVybkluZGV4IC0gaW5kZXgyLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FsbHN0YWNrRGVwdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxTdGFjay5kZXB0aDtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX291dHB1dFN0cmVhbTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRDaG9pY2VzKCkge1xuICAgICAgICAvLyBJZiB3ZSBjYW4gY29udGludWUgZ2VuZXJhdGluZyB0ZXh0IGNvbnRlbnQgcmF0aGVyIHRoYW4gY2hvaWNlcyxcbiAgICAgICAgLy8gdGhlbiB3ZSByZWZsZWN0IHRoZSBjaG9pY2UgbGlzdCBhcyBiZWluZyBlbXB0eSwgc2luY2UgY2hvaWNlc1xuICAgICAgICAvLyBzaG91bGQgYWx3YXlzIGNvbWUgYXQgdGhlIGVuZC5cbiAgICAgICAgaWYgKHRoaXMuY2FuQ29udGludWUpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGdlbmVyYXRlZENob2ljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hvaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRFcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50RXJyb3JzO1xuICAgIH1cbiAgICBnZXQgY3VycmVudFdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFdhcm5pbmdzO1xuICAgIH1cbiAgICBnZXQgdmFyaWFibGVzU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YXJpYWJsZXNTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHZhcmlhYmxlc1N0YXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhcmlhYmxlc1N0YXRlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBldmFsdWF0aW9uU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0aW9uU3RhY2s7XG4gICAgfVxuICAgIGdldCB2aXNpdENvdW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgIH1cbiAgICBnZXQgdHVybkluZGljZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90dXJuSW5kaWNlcztcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUdXJuSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHVybkluZGV4O1xuICAgIH1cbiAgICBzZXQgY3VycmVudFR1cm5JbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VHVybkluZGV4ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UGF0aFN0cmluZygpIHtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLmN1cnJlbnRQb2ludGVyO1xuICAgICAgICBpZiAocG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBvaW50ZXIucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicG9pbnRlci5wYXRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXIucGF0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9pbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyLmNvcHkoKTtcbiAgICB9XG4gICAgc2V0IGN1cnJlbnRQb2ludGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmN1cnJlbnRQb2ludGVyID0gdmFsdWUuY29weSgpO1xuICAgIH1cbiAgICBnZXQgcHJldmlvdXNQb2ludGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsU3RhY2suY3VycmVudFRocmVhZC5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgIH1cbiAgICBzZXQgcHJldmlvdXNQb2ludGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRUaHJlYWQucHJldmlvdXNQb2ludGVyID0gdmFsdWUuY29weSgpO1xuICAgIH1cbiAgICBnZXQgY2FuQ29udGludWUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jdXJyZW50UG9pbnRlci5pc051bGwgJiYgIXRoaXMuaGFzRXJyb3I7XG4gICAgfVxuICAgIGdldCBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEVycm9ycyAhPSBudWxsICYmIHRoaXMuY3VycmVudEVycm9ycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgaGFzV2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFdhcm5pbmdzICE9IG51bGwgJiYgdGhpcy5jdXJyZW50V2FybmluZ3MubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtVGV4dERpcnR5KSB7XG4gICAgICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IG91dHB1dE9iaiBvZiB0aGlzLl9vdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAvLyB2YXIgdGV4dENvbnRlbnQgPSBvdXRwdXRPYmogYXMgU3RyaW5nVmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IHRleHRDb250ZW50ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG91dHB1dE9iaiwgVmFsdWVfMS5TdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZCh0ZXh0Q29udGVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRleHQgPSB0aGlzLkNsZWFuT3V0cHV0V2hpdGVzcGFjZShzYi50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGV4dDtcbiAgICB9XG4gICAgQ2xlYW5PdXRwdXRXaGl0ZXNwYWNlKHN0cikge1xuICAgICAgICBsZXQgc2IgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLlN0cmluZ0J1aWxkZXIoKTtcbiAgICAgICAgbGV0IGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0T2ZMaW5lID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGxldCBpc0lubGluZVdoaXRlc3BhY2UgPSBjID09IFwiIFwiIHx8IGMgPT0gXCJcXHRcIjtcbiAgICAgICAgICAgIGlmIChpc0lubGluZVdoaXRlc3BhY2UgJiYgY3VycmVudFdoaXRlc3BhY2VTdGFydCA9PSAtMSlcbiAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGlmICghaXNJbmxpbmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMgIT0gXCJcXG5cIiAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50V2hpdGVzcGFjZVN0YXJ0ICE9IHN0YXJ0T2ZMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNiLkFwcGVuZChcIiBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRXaGl0ZXNwYWNlU3RhcnQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09IFwiXFxuXCIpXG4gICAgICAgICAgICAgICAgc3RhcnRPZkxpbmUgPSBpICsgMTtcbiAgICAgICAgICAgIGlmICghaXNJbmxpbmVXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgIHNiLkFwcGVuZChjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2IudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRUYWdzKCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGFncyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgb3V0cHV0T2JqIG9mIHRoaXMuX291dHB1dFN0cmVhbSkge1xuICAgICAgICAgICAgICAgIC8vIHZhciB0YWcgPSBvdXRwdXRPYmogYXMgVGFnO1xuICAgICAgICAgICAgICAgIGxldCB0YWcgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob3V0cHV0T2JqLCBUYWdfMS5UYWcpO1xuICAgICAgICAgICAgICAgIGlmICh0YWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRhZ3MucHVzaCh0YWcudGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtVGFnc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUYWdzO1xuICAgIH1cbiAgICBnZXQgaW5FeHByZXNzaW9uRXZhbHVhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb247XG4gICAgfVxuICAgIHNldCBpbkV4cHJlc3Npb25FdmFsdWF0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLmN1cnJlbnRFbGVtZW50LmluRXhwcmVzc2lvbkV2YWx1YXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgR29Ub1N0YXJ0KCkge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC5jdXJyZW50UG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLlN0YXJ0T2YodGhpcy5zdG9yeS5tYWluQ29udGVudENvbnRhaW5lcik7XG4gICAgfVxuICAgIENvcHlBbmRTdGFydFBhdGNoaW5nKCkge1xuICAgICAgICBsZXQgY29weSA9IG5ldyBTdG9yeVN0YXRlKHRoaXMuc3RvcnkpO1xuICAgICAgICBjb3B5Ll9wYXRjaCA9IG5ldyBTdGF0ZVBhdGNoXzEuU3RhdGVQYXRjaCh0aGlzLl9wYXRjaCk7XG4gICAgICAgIGNvcHkub3V0cHV0U3RyZWFtLnB1c2guYXBwbHkoY29weS5vdXRwdXRTdHJlYW0sIHRoaXMuX291dHB1dFN0cmVhbSk7XG4gICAgICAgIGNvcHkuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgY29weS5fY3VycmVudENob2ljZXMucHVzaC5hcHBseShjb3B5Ll9jdXJyZW50Q2hvaWNlcywgdGhpcy5fY3VycmVudENob2ljZXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgY29weS5fY3VycmVudEVycm9ycyA9IFtdO1xuICAgICAgICAgICAgY29weS5fY3VycmVudEVycm9ycy5wdXNoLmFwcGx5KGNvcHkuX2N1cnJlbnRFcnJvcnMsIHRoaXMuY3VycmVudEVycm9ycyB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzV2FybmluZykge1xuICAgICAgICAgICAgY29weS5fY3VycmVudFdhcm5pbmdzID0gW107XG4gICAgICAgICAgICBjb3B5Ll9jdXJyZW50V2FybmluZ3MucHVzaC5hcHBseShjb3B5Ll9jdXJyZW50V2FybmluZ3MsIHRoaXMuY3VycmVudFdhcm5pbmdzIHx8IFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb3B5LmNhbGxTdGFjayA9IG5ldyBDYWxsU3RhY2tfMS5DYWxsU3RhY2sodGhpcy5jYWxsU3RhY2spO1xuICAgICAgICBjb3B5LnZhcmlhYmxlc1N0YXRlID0gdGhpcy52YXJpYWJsZXNTdGF0ZTtcbiAgICAgICAgY29weS52YXJpYWJsZXNTdGF0ZS5jYWxsU3RhY2sgPSBjb3B5LmNhbGxTdGFjaztcbiAgICAgICAgY29weS52YXJpYWJsZXNTdGF0ZS5wYXRjaCA9IGNvcHkuX3BhdGNoO1xuICAgICAgICBjb3B5LmV2YWx1YXRpb25TdGFjay5wdXNoLmFwcGx5KGNvcHkuZXZhbHVhdGlvblN0YWNrLCB0aGlzLmV2YWx1YXRpb25TdGFjayk7XG4gICAgICAgIGlmICghdGhpcy5kaXZlcnRlZFBvaW50ZXIuaXNOdWxsKVxuICAgICAgICAgICAgY29weS5kaXZlcnRlZFBvaW50ZXIgPSB0aGlzLmRpdmVydGVkUG9pbnRlci5jb3B5KCk7XG4gICAgICAgIGNvcHkucHJldmlvdXNQb2ludGVyID0gdGhpcy5wcmV2aW91c1BvaW50ZXIuY29weSgpO1xuICAgICAgICBjb3B5Ll92aXNpdENvdW50cyA9IHRoaXMuX3Zpc2l0Q291bnRzO1xuICAgICAgICBjb3B5Ll90dXJuSW5kaWNlcyA9IHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgICAgICBjb3B5LmN1cnJlbnRUdXJuSW5kZXggPSB0aGlzLmN1cnJlbnRUdXJuSW5kZXg7XG4gICAgICAgIGNvcHkuc3RvcnlTZWVkID0gdGhpcy5zdG9yeVNlZWQ7XG4gICAgICAgIGNvcHkucHJldmlvdXNSYW5kb20gPSB0aGlzLnByZXZpb3VzUmFuZG9tO1xuICAgICAgICBjb3B5LmRpZFNhZmVFeGl0ID0gdGhpcy5kaWRTYWZlRXhpdDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIFJlc3RvcmVBZnRlclBhdGNoKCkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLmNhbGxTdGFjayA9IHRoaXMuY2FsbFN0YWNrO1xuICAgICAgICB0aGlzLnZhcmlhYmxlc1N0YXRlLnBhdGNoID0gdGhpcy5fcGF0Y2g7XG4gICAgfVxuICAgIEFwcGx5QW55UGF0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXRjaCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy52YXJpYWJsZXNTdGF0ZS5BcHBseVBhdGNoKCk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9wYXRjaC52aXNpdENvdW50cylcbiAgICAgICAgICAgIHRoaXMuQXBwbHlDb3VudENoYW5nZXMoa2V5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiB0aGlzLl9wYXRjaC50dXJuSW5kaWNlcylcbiAgICAgICAgICAgIHRoaXMuQXBwbHlDb3VudENoYW5nZXMoa2V5LCB2YWx1ZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9wYXRjaCA9IG51bGw7XG4gICAgfVxuICAgIEFwcGx5Q291bnRDaGFuZ2VzKGNvbnRhaW5lciwgbmV3Q291bnQsIGlzVmlzaXQpIHtcbiAgICAgICAgbGV0IGNvdW50cyA9IGlzVmlzaXQgPyB0aGlzLl92aXNpdENvdW50cyA6IHRoaXMuX3R1cm5JbmRpY2VzO1xuICAgICAgICBjb3VudHMuc2V0KGNvbnRhaW5lci5wYXRoLnRvU3RyaW5nKCksIG5ld0NvdW50KTtcbiAgICB9XG4gICAgV3JpdGVKc29uKHdyaXRlcikge1xuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICBsZXQgaGFzQ2hvaWNlVGhyZWFkcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBpZiAoYy50aHJlYWRBdEdlbmVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcImMudGhyZWFkQXRHZW5lcmF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5vcmlnaW5hbFRocmVhZEluZGV4ID0gYy50aHJlYWRBdEdlbmVyYXRpb24udGhyZWFkSW5kZXg7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suVGhyZWFkV2l0aEluZGV4KGMub3JpZ2luYWxUaHJlYWRJbmRleCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc0Nob2ljZVRocmVhZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hvaWNlVGhyZWFkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5U3RhcnQoXCJjaG9pY2VUaHJlYWRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RTdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KGMub3JpZ2luYWxUaHJlYWRJbmRleCk7XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24uV3JpdGVKc29uKHdyaXRlcik7XG4gICAgICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQ2hvaWNlVGhyZWFkcykge1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlT2JqZWN0RW5kKCk7XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBmb2xsb3dpbmcgdHdvIGNhbGxzLCBgV3JpdGVKc29uYCBpcyBjYWxsZWQgaW5zaWRlIGFuIGFycm93XG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIG1ha2Ugc3VyZSBgdGhpc2AgaXMgY29ycmVjdGx5IGJvdW5kIGFuZCBwYXNzZWQgZG93blxuICAgICAgICAvLyB0aGUgY2FsbCBoaWVyYXJjaHkuXG4gICAgICAgIHdyaXRlci5Xcml0ZVByb3BlcnR5KFwiY2FsbHN0YWNrVGhyZWFkc1wiLCAodykgPT4gdGhpcy5jYWxsU3RhY2suV3JpdGVKc29uKHcpKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJ2YXJpYWJsZXNTdGF0ZVwiLCAodykgPT4gdGhpcy52YXJpYWJsZXNTdGF0ZS5Xcml0ZUpzb24odykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImV2YWxTdGFja1wiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh3LCB0aGlzLmV2YWx1YXRpb25TdGFjaykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcIm91dHB1dFN0cmVhbVwiLCAodykgPT4gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUxpc3RSdW50aW1lT2Jqcyh3LCB0aGlzLl9vdXRwdXRTdHJlYW0pKTtcbiAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHkoXCJjdXJyZW50Q2hvaWNlc1wiLCAodykgPT4ge1xuICAgICAgICAgICAgdy5Xcml0ZUFycmF5U3RhcnQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5fY3VycmVudENob2ljZXMpXG4gICAgICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZUNob2ljZSh3LCBjKTtcbiAgICAgICAgICAgIHcuV3JpdGVBcnJheUVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdmVydGVkUG9pbnRlci5pc051bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpdmVydGVkUG9pbnRlci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJkaXZlcnRlZFBvaW50ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcImN1cnJlbnREaXZlcnRUYXJnZXRcIiwgdGhpcy5kaXZlcnRlZFBvaW50ZXIucGF0aC5jb21wb25lbnRzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInZpc2l0Q291bnRzXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlSW50RGljdGlvbmFyeSh3LCB0aGlzLl92aXNpdENvdW50cykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eShcInR1cm5JbmRpY2VzXCIsICh3KSA9PiBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLldyaXRlSW50RGljdGlvbmFyeSh3LCB0aGlzLl90dXJuSW5kaWNlcykpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInR1cm5JZHhcIiwgdGhpcy5jdXJyZW50VHVybkluZGV4KTtcbiAgICAgICAgd3JpdGVyLldyaXRlSW50UHJvcGVydHkoXCJzdG9yeVNlZWRcIiwgdGhpcy5zdG9yeVNlZWQpO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcInByZXZpb3VzUmFuZG9tXCIsIHRoaXMucHJldmlvdXNSYW5kb20pO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua1NhdmVWZXJzaW9uXCIsIHRoaXMua0lua1NhdmVTdGF0ZVZlcnNpb24pO1xuICAgICAgICB3cml0ZXIuV3JpdGVJbnRQcm9wZXJ0eShcImlua0Zvcm1hdFZlcnNpb25cIiwgU3RvcnlfMS5TdG9yeS5pbmtWZXJzaW9uQ3VycmVudCk7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdEVuZCgpO1xuICAgIH1cbiAgICBMb2FkSnNvbk9iaih2YWx1ZSkge1xuICAgICAgICBsZXQgak9iamVjdCA9IHZhbHVlO1xuICAgICAgICBsZXQgalNhdmVWZXJzaW9uID0gak9iamVjdFtcImlua1NhdmVWZXJzaW9uXCJdO1xuICAgICAgICBpZiAoalNhdmVWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiaW5rIHNhdmUgZm9ybWF0IGluY29ycmVjdCwgY2FuJ3QgbG9hZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VJbnQoalNhdmVWZXJzaW9uKSA8IHRoaXMua01pbkNvbXBhdGlibGVMb2FkVmVyc2lvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3J5RXhjZXB0aW9uXzEuU3RvcnlFeGNlcHRpb24oXCJJbmsgc2F2ZSBmb3JtYXQgaXNuJ3QgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gKHNhdyAnXCIgK1xuICAgICAgICAgICAgICAgIGpTYXZlVmVyc2lvbiArXG4gICAgICAgICAgICAgICAgXCInLCBidXQgbWluaW11bSBpcyBcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5rTWluQ29tcGF0aWJsZUxvYWRWZXJzaW9uICtcbiAgICAgICAgICAgICAgICBcIiksIHNvIGNhbid0IGxvYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlNldEpzb25Ub2tlbihqT2JqZWN0W1wiY2FsbHN0YWNrVGhyZWFkc1wiXSwgdGhpcy5zdG9yeSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVzU3RhdGUuU2V0SnNvblRva2VuKGpPYmplY3RbXCJ2YXJpYWJsZXNTdGF0ZVwiXSk7XG4gICAgICAgIHRoaXMuX2V2YWx1YXRpb25TdGFjayA9IEpzb25TZXJpYWxpc2F0aW9uXzEuSnNvblNlcmlhbGlzYXRpb24uSkFycmF5VG9SdW50aW1lT2JqTGlzdChqT2JqZWN0W1wiZXZhbFN0YWNrXCJdKTtcbiAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0KGpPYmplY3RbXCJvdXRwdXRTdHJlYW1cIl0pO1xuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgICAgIC8vIGN1cnJlbnRDaG9pY2VzID0gSnNvbi5KQXJyYXlUb1J1bnRpbWVPYmpMaXN0PENob2ljZT4oKEpBcnJheSlqT2JqZWN0IFtcImN1cnJlbnRDaG9pY2VzXCJdKTtcbiAgICAgICAgdGhpcy5fY3VycmVudENob2ljZXMgPSBKc29uU2VyaWFsaXNhdGlvbl8xLkpzb25TZXJpYWxpc2F0aW9uLkpBcnJheVRvUnVudGltZU9iakxpc3Qoak9iamVjdFtcImN1cnJlbnRDaG9pY2VzXCJdKTtcbiAgICAgICAgbGV0IGN1cnJlbnREaXZlcnRUYXJnZXRQYXRoID0gak9iamVjdFtcImN1cnJlbnREaXZlcnRUYXJnZXRcIl07XG4gICAgICAgIGlmIChjdXJyZW50RGl2ZXJ0VGFyZ2V0UGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGl2ZXJ0UGF0aCA9IG5ldyBQYXRoXzEuUGF0aChjdXJyZW50RGl2ZXJ0VGFyZ2V0UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMuZGl2ZXJ0ZWRQb2ludGVyID0gdGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKGRpdmVydFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Zpc2l0Q291bnRzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3RbXCJ2aXNpdENvdW50c1wiXSk7XG4gICAgICAgIHRoaXMuX3R1cm5JbmRpY2VzID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KT2JqZWN0VG9JbnREaWN0aW9uYXJ5KGpPYmplY3RbXCJ0dXJuSW5kaWNlc1wiXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFR1cm5JbmRleCA9IHBhcnNlSW50KGpPYmplY3RbXCJ0dXJuSWR4XCJdKTtcbiAgICAgICAgdGhpcy5zdG9yeVNlZWQgPSBwYXJzZUludChqT2JqZWN0W1wic3RvcnlTZWVkXCJdKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1JhbmRvbSA9IHBhcnNlSW50KGpPYmplY3RbXCJwcmV2aW91c1JhbmRvbVwiXSk7XG4gICAgICAgIC8vIHZhciBqQ2hvaWNlVGhyZWFkcyA9IGpPYmplY3RbXCJjaG9pY2VUaHJlYWRzXCJdIGFzIEpPYmplY3Q7XG4gICAgICAgIGxldCBqQ2hvaWNlVGhyZWFkcyA9IGpPYmplY3RbXCJjaG9pY2VUaHJlYWRzXCJdO1xuICAgICAgICBmb3IgKGxldCBjIG9mIHRoaXMuX2N1cnJlbnRDaG9pY2VzKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRBY3RpdmVUaHJlYWQgPSB0aGlzLmNhbGxTdGFjay5UaHJlYWRXaXRoSW5kZXgoYy5vcmlnaW5hbFRocmVhZEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZEFjdGl2ZVRocmVhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYy50aHJlYWRBdEdlbmVyYXRpb24gPSBmb3VuZEFjdGl2ZVRocmVhZC5Db3B5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgalNhdmVkQ2hvaWNlVGhyZWFkID0gakNob2ljZVRocmVhZHNbYy5vcmlnaW5hbFRocmVhZEluZGV4LnRvU3RyaW5nKCldO1xuICAgICAgICAgICAgICAgIGMudGhyZWFkQXRHZW5lcmF0aW9uID0gbmV3IENhbGxTdGFja18xLkNhbGxTdGFjay5UaHJlYWQoalNhdmVkQ2hvaWNlVGhyZWFkLCB0aGlzLnN0b3J5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXNldEVycm9ycygpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IG51bGw7XG4gICAgfVxuICAgIFJlc2V0T3V0cHV0KG9ianMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggPSAwO1xuICAgICAgICBpZiAob2JqcyAhPT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5wdXNoLmFwcGx5KHRoaXMuX291dHB1dFN0cmVhbSwgb2Jqcyk7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUHVzaFRvT3V0cHV0U3RyZWFtKG9iaikge1xuICAgICAgICAvLyB2YXIgdGV4dCA9IG9iaiBhcyBTdHJpbmdWYWx1ZTtcbiAgICAgICAgbGV0IHRleHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgaWYgKHRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBsaXN0VGV4dCA9IHRoaXMuVHJ5U3BsaXR0aW5nSGVhZFRhaWxXaGl0ZXNwYWNlKHRleHQpO1xuICAgICAgICAgICAgaWYgKGxpc3RUZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGV4dE9iaiBvZiBsaXN0VGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlB1c2hUb091dHB1dFN0cmVhbUluZGl2aWR1YWwodGV4dE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5QdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKG9iaik7XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUG9wRnJvbU91dHB1dFN0cmVhbShjb3VudCkge1xuICAgICAgICB0aGlzLm91dHB1dFN0cmVhbS5zcGxpY2UodGhpcy5vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gY291bnQsIGNvdW50KTtcbiAgICAgICAgdGhpcy5PdXRwdXRTdHJlYW1EaXJ0eSgpO1xuICAgIH1cbiAgICBUcnlTcGxpdHRpbmdIZWFkVGFpbFdoaXRlc3BhY2Uoc2luZ2xlKSB7XG4gICAgICAgIGxldCBzdHIgPSBzaW5nbGUudmFsdWU7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwic2luZ2xlLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoZWFkRmlyc3ROZXdsaW5lSWR4ID0gLTE7XG4gICAgICAgIGxldCBoZWFkTGFzdE5ld2xpbmVJZHggPSAtMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBjID0gc3RyW2ldO1xuICAgICAgICAgICAgaWYgKGMgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBoZWFkRmlyc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICBoZWFkTGFzdE5ld2xpbmVJZHggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PSBcIiBcIiB8fCBjID09IFwiXFx0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhaWxMYXN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBsZXQgdGFpbEZpcnN0TmV3bGluZUlkeCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGMgPSBzdHJbaV07XG4gICAgICAgICAgICBpZiAoYyA9PSBcIlxcblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGFpbExhc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICB0YWlsRmlyc3ROZXdsaW5lSWR4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT0gXCIgXCIgfHwgYyA9PSBcIlxcdFwiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHNwbGl0dGluZyB0byBiZSBkb25lP1xuICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCA9PSAtMSAmJiB0YWlsTGFzdE5ld2xpbmVJZHggPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGxpc3RUZXh0cyA9IFtdO1xuICAgICAgICBsZXQgaW5uZXJTdHJTdGFydCA9IDA7XG4gICAgICAgIGxldCBpbm5lclN0ckVuZCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGlmIChoZWFkRmlyc3ROZXdsaW5lSWR4ICE9IC0xKSB7XG4gICAgICAgICAgICBpZiAoaGVhZEZpcnN0TmV3bGluZUlkeCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVhZGluZ1NwYWNlcyA9IG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKHN0ci5zdWJzdHJpbmcoMCwgaGVhZEZpcnN0TmV3bGluZUlkeCkpO1xuICAgICAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKGxlYWRpbmdTcGFjZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdFRleHRzLnB1c2gobmV3IFZhbHVlXzEuU3RyaW5nVmFsdWUoXCJcXG5cIikpO1xuICAgICAgICAgICAgaW5uZXJTdHJTdGFydCA9IGhlYWRMYXN0TmV3bGluZUlkeCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhaWxMYXN0TmV3bGluZUlkeCAhPSAtMSkge1xuICAgICAgICAgICAgaW5uZXJTdHJFbmQgPSB0YWlsRmlyc3ROZXdsaW5lSWR4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbm5lclN0ckVuZCA+IGlubmVyU3RyU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBpbm5lclN0clRleHQgPSBzdHIuc3Vic3RyaW5nKGlubmVyU3RyU3RhcnQsIGlubmVyU3RyRW5kIC0gaW5uZXJTdHJTdGFydCk7XG4gICAgICAgICAgICBsaXN0VGV4dHMucHVzaChuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShpbm5lclN0clRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFpbExhc3ROZXdsaW5lSWR4ICE9IC0xICYmIHRhaWxGaXJzdE5ld2xpbmVJZHggPiBoZWFkTGFzdE5ld2xpbmVJZHgpIHtcbiAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKG5ldyBWYWx1ZV8xLlN0cmluZ1ZhbHVlKFwiXFxuXCIpKTtcbiAgICAgICAgICAgIGlmICh0YWlsTGFzdE5ld2xpbmVJZHggPCBzdHIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGxldCBudW1TcGFjZXMgPSBzdHIubGVuZ3RoIC0gdGFpbExhc3ROZXdsaW5lSWR4IC0gMTtcbiAgICAgICAgICAgICAgICBsZXQgdHJhaWxpbmdTcGFjZXMgPSBuZXcgVmFsdWVfMS5TdHJpbmdWYWx1ZShzdHIuc3Vic3RyaW5nKHRhaWxMYXN0TmV3bGluZUlkeCArIDEsIG51bVNwYWNlcykpO1xuICAgICAgICAgICAgICAgIGxpc3RUZXh0cy5wdXNoKHRyYWlsaW5nU3BhY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdFRleHRzO1xuICAgIH1cbiAgICBQdXNoVG9PdXRwdXRTdHJlYW1JbmRpdmlkdWFsKG9iaikge1xuICAgICAgICBsZXQgZ2x1ZSA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIEdsdWVfMS5HbHVlKTtcbiAgICAgICAgbGV0IHRleHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgbGV0IGluY2x1ZGVJbk91dHB1dCA9IHRydWU7XG4gICAgICAgIGlmIChnbHVlKSB7XG4gICAgICAgICAgICB0aGlzLlRyaW1OZXdsaW5lc0Zyb21PdXRwdXRTdHJlYW0oKTtcbiAgICAgICAgICAgIGluY2x1ZGVJbk91dHB1dCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dCkge1xuICAgICAgICAgICAgbGV0IGZ1bmN0aW9uVHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZXQgY3VyckVsID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoY3VyckVsLnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25UcmltSW5kZXggPSBjdXJyRWwuZnVuY3Rpb25TdGFydEluT3V0cHV0U3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdsdWVUcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbyA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICBsZXQgYyA9IG8gaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kID8gbyA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGcgPSBvIGluc3RhbmNlb2YgR2x1ZV8xLkdsdWUgPyBvIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsdWVUcmltSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIGMuY29tbWFuZFR5cGUgPT0gQ29udHJvbENvbW1hbmRfMS5Db250cm9sQ29tbWFuZC5Db21tYW5kVHlwZS5CZWdpblN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+PSBmdW5jdGlvblRyaW1JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25UcmltSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJpbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBpZiAoZ2x1ZVRyaW1JbmRleCAhPSAtMSAmJiBmdW5jdGlvblRyaW1JbmRleCAhPSAtMSlcbiAgICAgICAgICAgICAgICB0cmltSW5kZXggPSBNYXRoLm1pbihmdW5jdGlvblRyaW1JbmRleCwgZ2x1ZVRyaW1JbmRleCk7XG4gICAgICAgICAgICBlbHNlIGlmIChnbHVlVHJpbUluZGV4ICE9IC0xKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRleCA9IGdsdWVUcmltSW5kZXg7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdHJpbUluZGV4ID0gZnVuY3Rpb25UcmltSW5kZXg7XG4gICAgICAgICAgICBpZiAodHJpbUluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRleHQuaXNOZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVJbk91dHB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0ZXh0LmlzTm9uV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2x1ZVRyaW1JbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5SZW1vdmVFeGlzdGluZ0dsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uVHJpbUluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjYWxsU3RhY2tFbGVtZW50cyA9IHRoaXMuY2FsbFN0YWNrLmVsZW1lbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNhbGxTdGFja0VsZW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVsID0gY2FsbFN0YWNrRWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLnR5cGUgPT0gUHVzaFBvcF8xLlB1c2hQb3BUeXBlLkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmZ1bmN0aW9uU3RhcnRJbk91dHB1dFN0cmVhbSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGV4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lIHx8ICF0aGlzLm91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudClcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZUluT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluY2x1ZGVJbk91dHB1dCkge1xuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3V0cHV0U3RyZWFtLnB1c2gob2JqKTtcbiAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBUcmltTmV3bGluZXNGcm9tT3V0cHV0U3RyZWFtKCkge1xuICAgICAgICBsZXQgcmVtb3ZlV2hpdGVzcGFjZUZyb20gPSAtMTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICAgICAgbGV0IG9iaiA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGxldCBjbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgIGxldCB0eHQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2JqLCBWYWx1ZV8xLlN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbWQgIT0gbnVsbCB8fCAodHh0ICE9IG51bGwgJiYgdHh0LmlzTm9uV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4dCAhPSBudWxsICYmIHR4dC5pc05ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVXaGl0ZXNwYWNlRnJvbSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSB3aGl0ZXNwYWNlXG4gICAgICAgIGlmIChyZW1vdmVXaGl0ZXNwYWNlRnJvbSA+PSAwKSB7XG4gICAgICAgICAgICBpID0gcmVtb3ZlV2hpdGVzcGFjZUZyb207XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh0aGlzLl9vdXRwdXRTdHJlYW1baV0sIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX291dHB1dFN0cmVhbS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICB9XG4gICAgUmVtb3ZlRXhpc3RpbmdHbHVlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgYyA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgR2x1ZV8xLkdsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyBpbnN0YW5jZW9mIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLk91dHB1dFN0cmVhbURpcnR5KCk7XG4gICAgfVxuICAgIGdldCBvdXRwdXRTdHJlYW1FbmRzSW5OZXdsaW5lKCkge1xuICAgICAgICBpZiAodGhpcy5fb3V0cHV0U3RyZWFtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX291dHB1dFN0cmVhbVtpXTtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCBpbnN0YW5jZW9mIFZhbHVlXzEuU3RyaW5nVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQuaXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRleHQuaXNOb25XaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IG91dHB1dFN0cmVhbUNvbnRhaW5zQ29udGVudCgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9vdXRwdXRTdHJlYW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vdXRwdXRTdHJlYW1baV0gaW5zdGFuY2VvZiBWYWx1ZV8xLlN0cmluZ1ZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGluU3RyaW5nRXZhbHVhdGlvbigpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gdmFyIGNtZCA9IHRoaXMuX291dHB1dFN0cmVhbVtpXSBhcyBDb250cm9sQ29tbWFuZDtcbiAgICAgICAgICAgIGxldCBjbWQgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5fb3V0cHV0U3RyZWFtW2ldLCBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kKTtcbiAgICAgICAgICAgIGlmIChjbWQgaW5zdGFuY2VvZiBDb250cm9sQ29tbWFuZF8xLkNvbnRyb2xDb21tYW5kICYmXG4gICAgICAgICAgICAgICAgY21kLmNvbW1hbmRUeXBlID09IENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQuQ29tbWFuZFR5cGUuQmVnaW5TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFB1c2hFdmFsdWF0aW9uU3RhY2sob2JqKSB7XG4gICAgICAgIC8vIHZhciBsaXN0VmFsdWUgPSBvYmogYXMgTGlzdFZhbHVlO1xuICAgICAgICBsZXQgbGlzdFZhbHVlID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iaiwgVmFsdWVfMS5MaXN0VmFsdWUpO1xuICAgICAgICBpZiAobGlzdFZhbHVlKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgb3JpZ2luIHdoZW4gbGlzdCBpcyBoYXMgc29tZXRoaW5nIHRvIGluZGljYXRlIHRoZSBsaXN0IG9yaWdpblxuICAgICAgICAgICAgbGV0IHJhd0xpc3QgPSBsaXN0VmFsdWUudmFsdWU7XG4gICAgICAgICAgICBpZiAocmF3TGlzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwicmF3TGlzdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyYXdMaXN0Lm9yaWdpbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJhd0xpc3Qub3JpZ2lucylcbiAgICAgICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zID0gW107XG4gICAgICAgICAgICAgICAgcmF3TGlzdC5vcmlnaW5zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgbiBvZiByYXdMaXN0Lm9yaWdpbk5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiU3RvcnlTdGF0ZS5zdG9yeS5saXN0RGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWYgPSB0aGlzLnN0b3J5Lmxpc3REZWZpbml0aW9ucy5UcnlMaXN0R2V0RGVmaW5pdGlvbihuLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5yZXN1bHQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlN0b3J5U3RhdGUgZGVmLnJlc3VsdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0xpc3Qub3JpZ2lucy5pbmRleE9mKGRlZi5yZXN1bHQpIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0xpc3Qub3JpZ2lucy5wdXNoKGRlZi5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9ialwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2YWx1YXRpb25TdGFjay5wdXNoKG9iaik7XG4gICAgfVxuICAgIFBvcEV2YWx1YXRpb25TdGFjayhudW1iZXJPZk9iamVjdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBudW1iZXJPZk9iamVjdHMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBvYmogPSB0aGlzLmV2YWx1YXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEubnVsbElmVW5kZWZpbmVkKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVtYmVyT2ZPYmplY3RzID4gdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5aW5nIHRvIHBvcCB0b28gbWFueSBvYmplY3RzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBvcHBlZCA9IHRoaXMuZXZhbHVhdGlvblN0YWNrLnNwbGljZSh0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggLSBudW1iZXJPZk9iamVjdHMsIG51bWJlck9mT2JqZWN0cyk7XG4gICAgICAgICAgICByZXR1cm4gVHlwZUFzc2VydGlvbl8xLm51bGxJZlVuZGVmaW5lZChwb3BwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBlZWtFdmFsdWF0aW9uU3RhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV2YWx1YXRpb25TdGFja1t0aGlzLmV2YWx1YXRpb25TdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgRm9yY2VFbmQoKSB7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlJlc2V0KCk7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzUG9pbnRlciA9IFBvaW50ZXJfMS5Qb2ludGVyLk51bGw7XG4gICAgICAgIHRoaXMuZGlkU2FmZUV4aXQgPSB0cnVlO1xuICAgIH1cbiAgICBUcmltV2hpdGVzcGFjZUZyb21GdW5jdGlvbkVuZCgpIHtcbiAgICAgICAgRGVidWdfMS5EZWJ1Zy5Bc3NlcnQodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pO1xuICAgICAgICBsZXQgZnVuY3Rpb25TdGFydFBvaW50ID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnRcbiAgICAgICAgICAgIC5mdW5jdGlvblN0YXJ0SW5PdXRwdXRTdHJlYW07XG4gICAgICAgIGlmIChmdW5jdGlvblN0YXJ0UG9pbnQgPT0gLTEpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uU3RhcnRQb2ludCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX291dHB1dFN0cmVhbS5sZW5ndGggLSAxOyBpID49IGZ1bmN0aW9uU3RhcnRQb2ludDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgb2JqID0gdGhpcy5fb3V0cHV0U3RyZWFtW2ldO1xuICAgICAgICAgICAgbGV0IHR4dCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIFZhbHVlXzEuU3RyaW5nVmFsdWUpO1xuICAgICAgICAgICAgbGV0IGNtZCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmosIENvbnRyb2xDb21tYW5kXzEuQ29udHJvbENvbW1hbmQpO1xuICAgICAgICAgICAgaWYgKHR4dCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNtZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGlmICh0eHQuaXNOZXdsaW5lIHx8IHR4dC5pc0lubGluZVdoaXRlc3BhY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vdXRwdXRTdHJlYW0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuT3V0cHV0U3RyZWFtRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFBvcENhbGxTdGFjayhwb3BUeXBlID0gbnVsbCkge1xuICAgICAgICBpZiAodGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQudHlwZSA9PSBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb24pXG4gICAgICAgICAgICB0aGlzLlRyaW1XaGl0ZXNwYWNlRnJvbUZ1bmN0aW9uRW5kKCk7XG4gICAgICAgIHRoaXMuY2FsbFN0YWNrLlBvcChwb3BUeXBlKTtcbiAgICB9XG4gICAgU2V0Q2hvc2VuUGF0aChwYXRoLCBpbmNyZW1lbnRpbmdUdXJuSW5kZXgpIHtcbiAgICAgICAgLy8gQ2hhbmdpbmcgZGlyZWN0aW9uLCBhc3N1bWUgd2UgbmVlZCB0byBjbGVhciBjdXJyZW50IHNldCBvZiBjaG9pY2VzXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDaG9pY2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGxldCBuZXdQb2ludGVyID0gdGhpcy5zdG9yeS5Qb2ludGVyQXRQYXRoKHBhdGgpO1xuICAgICAgICBpZiAoIW5ld1BvaW50ZXIuaXNOdWxsICYmIG5ld1BvaW50ZXIuaW5kZXggPT0gLTEpXG4gICAgICAgICAgICBuZXdQb2ludGVyLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50UG9pbnRlciA9IG5ld1BvaW50ZXI7XG4gICAgICAgIGlmIChpbmNyZW1lbnRpbmdUdXJuSW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFR1cm5JbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0YXJ0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoZnVuY0NvbnRhaW5lciwgYXJncykge1xuICAgICAgICB0aGlzLmNhbGxTdGFjay5QdXNoKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSwgdGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnQuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5TdGFydE9mKGZ1bmNDb250YWluZXIpO1xuICAgICAgICB0aGlzLlBhc3NBcmd1bWVudHNUb0V2YWx1YXRpb25TdGFjayhhcmdzKTtcbiAgICB9XG4gICAgUGFzc0FyZ3VtZW50c1RvRXZhbHVhdGlvblN0YWNrKGFyZ3MpIHtcbiAgICAgICAgLy8gUGFzcyBhcmd1bWVudHMgb250byB0aGUgZXZhbHVhdGlvbiBzdGFja1xuICAgICAgICBpZiAoYXJncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgYXJnc1tpXSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYXJnc1tpXSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5rIGFyZ3VtZW50cyB3aGVuIGNhbGxpbmcgRXZhbHVhdGVGdW5jdGlvbiAvIENob29zZVBhdGhTdHJpbmdXaXRoUGFyYW1ldGVycyAgbXVzdCBiZSBpbnQsIGZsb2F0IG9yIHN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5QdXNoRXZhbHVhdGlvblN0YWNrKFZhbHVlXzEuVmFsdWUuQ3JlYXRlKGFyZ3NbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBUcnlFeGl0RnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlID09XG4gICAgICAgICAgICBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBvaW50ZXIgPSBQb2ludGVyXzEuUG9pbnRlci5OdWxsO1xuICAgICAgICAgICAgdGhpcy5kaWRTYWZlRXhpdCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIENvbXBsZXRlRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbGxTdGFjay5jdXJyZW50RWxlbWVudC50eXBlICE9XG4gICAgICAgICAgICBQdXNoUG9wXzEuUHVzaFBvcFR5cGUuRnVuY3Rpb25FdmFsdWF0aW9uRnJvbUdhbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiRXhwZWN0ZWQgZXh0ZXJuYWwgZnVuY3Rpb24gZXZhbHVhdGlvbiB0byBiZSBjb21wbGV0ZS4gU3RhY2sgdHJhY2U6IFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxTdGFjay5jYWxsU3RhY2tUcmFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9yaWdpbmFsRXZhbHVhdGlvblN0YWNrSGVpZ2h0ID0gdGhpcy5jYWxsU3RhY2suY3VycmVudEVsZW1lbnRcbiAgICAgICAgICAgIC5ldmFsdWF0aW9uU3RhY2tIZWlnaHRXaGVuUHVzaGVkO1xuICAgICAgICBsZXQgcmV0dXJuZWRPYmogPSBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5ldmFsdWF0aW9uU3RhY2subGVuZ3RoID4gb3JpZ2luYWxFdmFsdWF0aW9uU3RhY2tIZWlnaHQpIHtcbiAgICAgICAgICAgIGxldCBwb3BwZWRPYmogPSB0aGlzLlBvcEV2YWx1YXRpb25TdGFjaygpO1xuICAgICAgICAgICAgaWYgKHJldHVybmVkT2JqID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybmVkT2JqID0gcG9wcGVkT2JqO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuUG9wQ2FsbFN0YWNrKFB1c2hQb3BfMS5QdXNoUG9wVHlwZS5GdW5jdGlvbkV2YWx1YXRpb25Gcm9tR2FtZSk7XG4gICAgICAgIGlmIChyZXR1cm5lZE9iaikge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkT2JqIGluc3RhbmNlb2YgVm9pZF8xLlZvaWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAvLyBTb21lIGtpbmQgb2YgdmFsdWUsIGlmIG5vdCB2b2lkXG4gICAgICAgICAgICAvLyB2YXIgcmV0dXJuVmFsID0gcmV0dXJuZWRPYmogYXMgUnVudGltZS5WYWx1ZTtcbiAgICAgICAgICAgIGxldCByZXR1cm5WYWwgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhyZXR1cm5lZE9iaiwgVmFsdWVfMS5WYWx1ZSk7XG4gICAgICAgICAgICAvLyBEaXZlcnRUYXJnZXRzIGdldCByZXR1cm5lZCBhcyB0aGUgc3RyaW5nIG9mIGNvbXBvbmVudHNcbiAgICAgICAgICAgIC8vIChyYXRoZXIgdGhhbiBhIFBhdGgsIHdoaWNoIGlzbid0IHB1YmxpYylcbiAgICAgICAgICAgIGlmIChyZXR1cm5WYWwudmFsdWVUeXBlID09IFZhbHVlXzEuVmFsdWVUeXBlLkRpdmVydFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5WYWwudmFsdWVPYmplY3QudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyIHR5cGVzIGNhbiBqdXN0IGhhdmUgdGhlaXIgZXhhY3Qgb2JqZWN0IHR5cGU6XG4gICAgICAgICAgICAvLyBpbnQsIGZsb2F0LCBzdHJpbmcuIFZhcmlhYmxlUG9pbnRlcnMgZ2V0IHJldHVybmVkIGFzIHN0cmluZ3MuXG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsLnZhbHVlT2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBBZGRFcnJvcihtZXNzYWdlLCBpc1dhcm5pbmcpIHtcbiAgICAgICAgaWYgKCFpc1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50RXJyb3JzID09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudEVycm9ycy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRXYXJuaW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY3VycmVudFdhcm5pbmdzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT3V0cHV0U3RyZWFtRGlydHkoKSB7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRleHREaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuX291dHB1dFN0cmVhbVRhZ3NEaXJ0eSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yeVN0YXRlID0gU3RvcnlTdGF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0b3J5U3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmluZ0J1aWxkZXIgPSB2b2lkIDA7XG5jbGFzcyBTdHJpbmdCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHIpIHtcbiAgICAgICAgc3RyID0gdHlwZW9mIHN0ciAhPT0gXCJ1bmRlZmluZWRcIiA/IHN0ci50b1N0cmluZygpIDogXCJcIjtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHI7XG4gICAgfVxuICAgIGdldCBMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5sZW5ndGg7XG4gICAgfVxuICAgIEFwcGVuZChzdHIpIHtcbiAgICAgICAgaWYgKHN0ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmcgKz0gc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFwcGVuZExpbmUoc3RyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgdGhpcy5BcHBlbmQoc3RyKTtcbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gXCJcXG5cIjtcbiAgICB9XG4gICAgQXBwZW5kRm9ybWF0KGZvcm1hdCwgLi4uYXJncykge1xuICAgICAgICAvLyB0YWtlbiBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjEwNDA2L2phdmFzY3JpcHQtZXF1aXZhbGVudC10by1wcmludGYtc3RyaW5nLWZvcm1hdFxuICAgICAgICB0aGlzLnN0cmluZyArPSBmb3JtYXQucmVwbGFjZSgveyhcXGQrKX0vZywgKG1hdGNoLCBudW0pID0+IHR5cGVvZiBhcmdzW251bV0gIT0gXCJ1bmRlZmluZWRcIiA/IGFyZ3NbbnVtXSA6IG1hdGNoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmluZztcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ0J1aWxkZXIgPSBTdHJpbmdCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nQnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVGFnID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jbGFzcyBUYWcgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHRhZ1RleHQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGFnVGV4dC50b1N0cmluZygpIHx8IFwiXCI7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCIjIFwiICsgdGhpcy50ZXh0O1xuICAgIH1cbn1cbmV4cG9ydHMuVGFnID0gVGFnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGFnLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50cnlQYXJzZUZsb2F0ID0gZXhwb3J0cy50cnlQYXJzZUludCA9IGV4cG9ydHMudHJ5R2V0VmFsdWVGcm9tTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24gdHJ5R2V0VmFsdWVGcm9tTWFwKG1hcCwga2V5LCBcbi8qIG91dCAqLyB2YWx1ZSkge1xuICAgIGlmIChtYXAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB2YWx1ZSwgZXhpc3RzOiBmYWxzZSB9O1xuICAgIH1cbiAgICBsZXQgdmFsID0gbWFwLmdldChrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsdWUsIGV4aXN0czogZmFsc2UgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG59XG5leHBvcnRzLnRyeUdldFZhbHVlRnJvbU1hcCA9IHRyeUdldFZhbHVlRnJvbU1hcDtcbmZ1bmN0aW9uIHRyeVBhcnNlSW50KHZhbHVlLCBcbi8qIG91dCAqLyBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gICAgbGV0IHZhbCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmYXVsdFZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy50cnlQYXJzZUludCA9IHRyeVBhcnNlSW50O1xuZnVuY3Rpb24gdHJ5UGFyc2VGbG9hdCh2YWx1ZSwgXG4vKiBvdXQgKi8gZGVmYXVsdFZhbHVlID0gMCkge1xuICAgIGxldCB2YWwgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICBpZiAoIU51bWJlci5pc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogdmFsLCBleGlzdHM6IHRydWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHJlc3VsdDogZGVmYXVsdFZhbHVlLCBleGlzdHM6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0cy50cnlQYXJzZUZsb2F0ID0gdHJ5UGFyc2VGbG9hdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyeUdldFJlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNFcXVhdGFibGUgPSBleHBvcnRzLm51bGxJZlVuZGVmaW5lZCA9IGV4cG9ydHMuYXNJTmFtZWRDb250ZW50T3JOdWxsID0gZXhwb3J0cy5hc051bWJlck9yVGhyb3dzID0gZXhwb3J0cy5hc09yVGhyb3dzID0gZXhwb3J0cy5hc09yTnVsbCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGFzT3JOdWxsKG9iaiwgdHlwZSkge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmFzT3JOdWxsID0gYXNPck51bGw7XG5mdW5jdGlvbiBhc09yVGhyb3dzKG9iaiwgdHlwZSkge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiB0eXBlKSB7XG4gICAgICAgIHJldHVybiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b2JqfSBpcyBub3Qgb2YgdHlwZSAke3R5cGV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5hc09yVGhyb3dzID0gYXNPclRocm93cztcbmZ1bmN0aW9uIGFzTnVtYmVyT3JUaHJvd3Mob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtvYmp9IGlzIG5vdCBhIG51bWJlcmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNOdW1iZXJPclRocm93cyA9IGFzTnVtYmVyT3JUaHJvd3M7XG4vLyBTbyBoZXJlLCBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLCBjb250ZW50T2JqIGlzIGNhc3RlZCB0byBhbiBJTmFtZWRDb250ZW50XG4vLyBidXQgaGVyZSB3ZSB1c2UganMtc3R5bGUgZHVjayB0eXBpbmc6IGlmIGl0IGltcGxlbWVudHMgdGhlIHNhbWUgcHJvcHMgYXMgdGhlIGludGVyZmFjZSxcbi8vIHdlIHRyZWF0IGl0IGFzIHZhbGlkLlxuZnVuY3Rpb24gYXNJTmFtZWRDb250ZW50T3JOdWxsKG9iaikge1xuICAgIGlmIChvYmouaGFzVmFsaWROYW1lICYmIG9iai5uYW1lKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5hc0lOYW1lZENvbnRlbnRPck51bGwgPSBhc0lOYW1lZENvbnRlbnRPck51bGw7XG5mdW5jdGlvbiBudWxsSWZVbmRlZmluZWQob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5leHBvcnRzLm51bGxJZlVuZGVmaW5lZCA9IG51bGxJZlVuZGVmaW5lZDtcbmZ1bmN0aW9uIGlzRXF1YXRhYmxlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHR5cGUuRXF1YWxzID09PSBcImZ1bmN0aW9uXCI7XG59XG5leHBvcnRzLmlzRXF1YXRhYmxlID0gaXNFcXVhdGFibGU7XG5mdW5jdGlvbiB1bnNhZmVUeXBlQXNzZXJ0aW9uKG9iaiwgdHlwZSkge1xuICAgIHJldHVybiBvYmo7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UeXBlQXNzZXJ0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYWx1ZVR5cGUgPSBleHBvcnRzLkxpc3RWYWx1ZSA9IGV4cG9ydHMuVmFyaWFibGVQb2ludGVyVmFsdWUgPSBleHBvcnRzLkRpdmVydFRhcmdldFZhbHVlID0gZXhwb3J0cy5TdHJpbmdWYWx1ZSA9IGV4cG9ydHMuRmxvYXRWYWx1ZSA9IGV4cG9ydHMuSW50VmFsdWUgPSBleHBvcnRzLlZhbHVlID0gZXhwb3J0cy5BYnN0cmFjdFZhbHVlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY29uc3QgSW5rTGlzdF8xID0gcmVxdWlyZShcIi4vSW5rTGlzdFwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBBYnN0cmFjdFZhbHVlIGV4dGVuZHMgT2JqZWN0XzEuSW5rT2JqZWN0IHtcbiAgICBzdGF0aWMgQ3JlYXRlKHZhbCwgcHJlZmVycmVkTnVtYmVyVHlwZSkge1xuICAgICAgICAvLyBUaGlzIGNvZGUgZG9lc24ndCBleGlzdCBpbiB1cHN0cmVhbSBhbmQgaXMgc2ltcGx5IGhlcmUgdG8gZW5mb3JjZVxuICAgICAgICAvLyB0aGUgY3JlYXRpb24gb2YgdGhlIHByb3BlciBudW1iZXIgdmFsdWUuXG4gICAgICAgIC8vIElmIGBwcmVmZXJyZWROdW1iZXJUeXBlYCBpcyBub3QgcHJvdmlkZWQgb3IgaWYgdmFsdWUgZG9lc24ndCBtYXRjaFxuICAgICAgICAvLyBgcHJlZmVycmVkTnVtYmVyVHlwZWAsIHRoaXMgY29uZGl0aW9uYWwgZG9lcyBub3RoaW5nLlxuICAgICAgICBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSkge1xuICAgICAgICAgICAgaWYgKHByZWZlcnJlZE51bWJlclR5cGUgPT09IFZhbHVlVHlwZS5JbnQgJiZcbiAgICAgICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlZmVycmVkTnVtYmVyVHlwZSA9PT0gVmFsdWVUeXBlLkZsb2F0ICYmXG4gICAgICAgICAgICAgICAgIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0VmFsdWUoTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEltcGxpY2l0bHkgY29udmVydCBib29scyBpbnRvIGludHNcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBsZXQgYiA9ICEhdmFsO1xuICAgICAgICAgICAgdmFsID0gYiA/IDEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95LWxvaHNlL2lua2pzL2lzc3Vlcy80MjVcbiAgICAgICAgLy8gQ2hhbmdlZCBjb25kaXRpb24gc2VxdWVuY2UsIGJlY2F1c2UgTnVtYmVyKCcnKSBpc1xuICAgICAgICAvLyBwYXJzZWQgdG8gMCwgd2hpY2ggbWFkZSBzZXR0aW5nIHN0cmluZyB0byBlbXB0eVxuICAgICAgICAvLyBpbXBvc3NpYmxlXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFN0cmluZyh2YWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih2YWwpKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShOdW1iZXIodmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgUGF0aF8xLlBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGl2ZXJ0VGFyZ2V0VmFsdWUoVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3ModmFsLCBQYXRoXzEuUGF0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIElua0xpc3RfMS5JbmtMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpc3RWYWx1ZShUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyh2YWwsIElua0xpc3RfMS5JbmtMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhBYnN0cmFjdFZhbHVlLkNyZWF0ZSh0aGlzKSwgT2JqZWN0XzEuSW5rT2JqZWN0KTtcbiAgICB9XG4gICAgQmFkQ2FzdEV4Y2VwdGlvbih0YXJnZXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbid0IGNhc3QgXCIgK1xuICAgICAgICAgICAgdGhpcy52YWx1ZU9iamVjdCArXG4gICAgICAgICAgICBcIiBmcm9tIFwiICtcbiAgICAgICAgICAgIHRoaXMudmFsdWVUeXBlICtcbiAgICAgICAgICAgIFwiIHRvIFwiICtcbiAgICAgICAgICAgIHRhcmdldFR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWJzdHJhY3RWYWx1ZSA9IEFic3RyYWN0VmFsdWU7XG5jbGFzcyBWYWx1ZSBleHRlbmRzIEFic3RyYWN0VmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgIH1cbiAgICBnZXQgdmFsdWVPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsdWUgPSBWYWx1ZTtcbmNsYXNzIEludFZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgMCk7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT0gMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5JbnQ7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFsdWUudmFsdWVcIik7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuRmxvYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIgKyB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRWYWx1ZSA9IEludFZhbHVlO1xuY2xhc3MgRmxvYXRWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgc3VwZXIodmFsIHx8IDAuMCk7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgIT0gMC4wO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkZsb2F0O1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIgKyB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdFZhbHVlID0gRmxvYXRWYWx1ZTtcbmNsYXNzIFN0cmluZ1ZhbHVlIGV4dGVuZHMgVmFsdWUge1xuICAgIGNvbnN0cnVjdG9yKHZhbCkge1xuICAgICAgICBzdXBlcih2YWwgfHwgXCJcIik7XG4gICAgICAgIHRoaXMuX2lzTmV3bGluZSA9IHRoaXMudmFsdWUgPT0gXCJcXG5cIjtcbiAgICAgICAgdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnNwbGl0KFwiXCIpLmV2ZXJ5KChjKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGMgIT0gXCIgXCIgJiYgYyAhPSBcIlxcdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzSW5saW5lV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5TdHJpbmc7XG4gICAgfVxuICAgIGdldCBpc1RydXRoeSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBnZXQgaXNOZXdsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNOZXdsaW5lO1xuICAgIH1cbiAgICBnZXQgaXNJbmxpbmVXaGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNJbmxpbmVXaGl0ZXNwYWNlO1xuICAgIH1cbiAgICBnZXQgaXNOb25XaGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNOZXdsaW5lICYmICF0aGlzLmlzSW5saW5lV2hpdGVzcGFjZTtcbiAgICB9XG4gICAgQ2FzdChuZXdUeXBlKSB7XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkSW50ID0gVHJ5R2V0UmVzdWx0XzEudHJ5UGFyc2VJbnQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW50LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUocGFyc2VkSW50LnJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkRmxvYXQgPSBUcnlHZXRSZXN1bHRfMS50cnlQYXJzZUZsb2F0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZEZsb2F0LmV4aXN0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShwYXJzZWRGbG9hdC5yZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG59XG5leHBvcnRzLlN0cmluZ1ZhbHVlID0gU3RyaW5nVmFsdWU7XG5jbGFzcyBEaXZlcnRUYXJnZXRWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRQYXRoKSB7XG4gICAgICAgIHN1cGVyKHRhcmdldFBhdGgpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVUeXBlKCkge1xuICAgICAgICByZXR1cm4gVmFsdWVUeXBlLkRpdmVydFRhcmdldDtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBhdGgoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJWYWx1ZS52YWx1ZVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHNldCB0YXJnZXRQYXRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGRuJ3QgYmUgY2hlY2tpbmcgdGhlIHRydXRoaW5lc3Mgb2YgYSBkaXZlcnQgdGFyZ2V0XCIpO1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKG5ld1R5cGUgPT0gdGhpcy52YWx1ZVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhyb3cgdGhpcy5CYWRDYXN0RXhjZXB0aW9uKG5ld1R5cGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiRGl2ZXJ0VGFyZ2V0VmFsdWUoXCIgKyB0aGlzLnRhcmdldFBhdGggKyBcIilcIjtcbiAgICB9XG59XG5leHBvcnRzLkRpdmVydFRhcmdldFZhbHVlID0gRGl2ZXJ0VGFyZ2V0VmFsdWU7XG5jbGFzcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZSBleHRlbmRzIFZhbHVlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIHN1cGVyKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmRleCA9IGNvbnRleHRJbmRleDtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRJbmRleDtcbiAgICB9XG4gICAgc2V0IGNvbnRleHRJbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0SW5kZXggPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHZhcmlhYmxlTmFtZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhcmlhYmxlTmFtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiBWYWx1ZVR5cGUuVmFyaWFibGVQb2ludGVyO1xuICAgIH1cbiAgICBnZXQgaXNUcnV0aHkoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZG4ndCBiZSBjaGVja2luZyB0aGUgdHJ1dGhpbmVzcyBvZiBhIHZhcmlhYmxlIHBvaW50ZXJcIik7XG4gICAgfVxuICAgIENhc3QobmV3VHlwZSkge1xuICAgICAgICBpZiAobmV3VHlwZSA9PSB0aGlzLnZhbHVlVHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB0aHJvdyB0aGlzLkJhZENhc3RFeGNlcHRpb24obmV3VHlwZSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJWYXJpYWJsZVBvaW50ZXJWYWx1ZShcIiArIHRoaXMudmFyaWFibGVOYW1lICsgXCIpXCI7XG4gICAgfVxuICAgIENvcHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmFyaWFibGVQb2ludGVyVmFsdWUodGhpcy52YXJpYWJsZU5hbWUsIHRoaXMuY29udGV4dEluZGV4KTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlUG9pbnRlclZhbHVlID0gVmFyaWFibGVQb2ludGVyVmFsdWU7XG5jbGFzcyBMaXN0VmFsdWUgZXh0ZW5kcyBWYWx1ZSB7XG4gICAgZ2V0IGlzVHJ1dGh5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ0aGlzLnZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLkNvdW50ID4gMDtcbiAgICB9XG4gICAgZ2V0IHZhbHVlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZhbHVlVHlwZS5MaXN0O1xuICAgIH1cbiAgICBDYXN0KG5ld1R5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIlZhbHVlLnZhbHVlXCIpO1xuICAgICAgICBpZiAobmV3VHlwZSA9PSBWYWx1ZVR5cGUuSW50KSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50VmFsdWUoMCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRWYWx1ZShtYXguVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLkZsb2F0KSB7XG4gICAgICAgICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXhJdGVtO1xuICAgICAgICAgICAgaWYgKG1heC5LZXkuaXNOdWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZSgwLjApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXRWYWx1ZShtYXguVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1R5cGUgPT0gVmFsdWVUeXBlLlN0cmluZykge1xuICAgICAgICAgICAgbGV0IG1heCA9IHRoaXMudmFsdWUubWF4SXRlbTtcbiAgICAgICAgICAgIGlmIChtYXguS2V5LmlzTnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ1ZhbHVlKFwiXCIpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdWYWx1ZShtYXguS2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeXBlID09IHRoaXMudmFsdWVUeXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRocm93IHRoaXMuQmFkQ2FzdEV4Y2VwdGlvbihuZXdUeXBlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGlzdE9yU2luZ2xlSXRlbSwgc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgc3VwZXIobnVsbCk7XG4gICAgICAgIGlmICghbGlzdE9yU2luZ2xlSXRlbSAmJiAhc2luZ2xlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaXN0T3JTaW5nbGVJdGVtIGluc3RhbmNlb2YgSW5rTGlzdF8xLklua0xpc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBuZXcgSW5rTGlzdF8xLklua0xpc3QobGlzdE9yU2luZ2xlSXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlzdE9yU2luZ2xlSXRlbSBpbnN0YW5jZW9mIElua0xpc3RfMS5JbmtMaXN0SXRlbSAmJlxuICAgICAgICAgICAgdHlwZW9mIHNpbmdsZVZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3IElua0xpc3RfMS5JbmtMaXN0KHtcbiAgICAgICAgICAgICAgICBLZXk6IGxpc3RPclNpbmdsZUl0ZW0sXG4gICAgICAgICAgICAgICAgVmFsdWU6IHNpbmdsZVZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIFJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgbGV0IG9sZExpc3QgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwob2xkVmFsdWUsIExpc3RWYWx1ZSk7XG4gICAgICAgIGxldCBuZXdMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG5ld1ZhbHVlLCBMaXN0VmFsdWUpO1xuICAgICAgICBpZiAobmV3TGlzdCAmJiBuZXdMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJuZXdMaXN0LnZhbHVlXCIpO1xuICAgICAgICBpZiAob2xkTGlzdCAmJiBvbGRMaXN0LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJvbGRMaXN0LnZhbHVlXCIpO1xuICAgICAgICAvLyBXaGVuIGFzc2lnbmluZyB0aGUgZW1wdHkgbGlzdCwgdHJ5IHRvIHJldGFpbiBhbnkgaW5pdGlhbCBvcmlnaW4gbmFtZXNcbiAgICAgICAgaWYgKG9sZExpc3QgJiYgbmV3TGlzdCAmJiBuZXdMaXN0LnZhbHVlLkNvdW50ID09IDApXG4gICAgICAgICAgICBuZXdMaXN0LnZhbHVlLlNldEluaXRpYWxPcmlnaW5OYW1lcyhvbGRMaXN0LnZhbHVlLm9yaWdpbk5hbWVzKTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RWYWx1ZSA9IExpc3RWYWx1ZTtcbnZhciBWYWx1ZVR5cGU7XG4oZnVuY3Rpb24gKFZhbHVlVHlwZSkge1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJJbnRcIl0gPSAwXSA9IFwiSW50XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkZsb2F0XCJdID0gMV0gPSBcIkZsb2F0XCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkxpc3RcIl0gPSAyXSA9IFwiTGlzdFwiO1xuICAgIFZhbHVlVHlwZVtWYWx1ZVR5cGVbXCJTdHJpbmdcIl0gPSAzXSA9IFwiU3RyaW5nXCI7XG4gICAgVmFsdWVUeXBlW1ZhbHVlVHlwZVtcIkRpdmVydFRhcmdldFwiXSA9IDRdID0gXCJEaXZlcnRUYXJnZXRcIjtcbiAgICBWYWx1ZVR5cGVbVmFsdWVUeXBlW1wiVmFyaWFibGVQb2ludGVyXCJdID0gNV0gPSBcIlZhcmlhYmxlUG9pbnRlclwiO1xufSkoVmFsdWVUeXBlID0gZXhwb3J0cy5WYWx1ZVR5cGUgfHwgKGV4cG9ydHMuVmFsdWVUeXBlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhbHVlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZUFzc2lnbm1lbnQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFZhcmlhYmxlQXNzaWdubWVudCBleHRlbmRzIE9iamVjdF8xLklua09iamVjdCB7XG4gICAgY29uc3RydWN0b3IodmFyaWFibGVOYW1lLCBpc05ld0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lID0gdmFyaWFibGVOYW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuaXNOZXdEZWNsYXJhdGlvbiA9ICEhaXNOZXdEZWNsYXJhdGlvbjtcbiAgICAgICAgdGhpcy5pc0dsb2JhbCA9IGZhbHNlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiVmFyQXNzaWduIHRvIFwiICsgdGhpcy52YXJpYWJsZU5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYWJsZUFzc2lnbm1lbnQgPSBWYXJpYWJsZUFzc2lnbm1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WYXJpYWJsZUFzc2lnbm1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZhcmlhYmxlUmVmZXJlbmNlID0gdm9pZCAwO1xuY29uc3QgT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9PYmplY3RcIik7XG5jb25zdCBQYXRoXzEgPSByZXF1aXJlKFwiLi9QYXRoXCIpO1xuY2xhc3MgVmFyaWFibGVSZWZlcmVuY2UgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgZ2V0IGNvbnRhaW5lckZvckNvdW50KCkge1xuICAgICAgICBpZiAodGhpcy5wYXRoRm9yQ291bnQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuUmVzb2x2ZVBhdGgodGhpcy5wYXRoRm9yQ291bnQpLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgZ2V0IHBhdGhTdHJpbmdGb3JDb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0aEZvckNvdW50ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzLkNvbXBhY3RQYXRoU3RyaW5nKHRoaXMucGF0aEZvckNvdW50KTtcbiAgICB9XG4gICAgc2V0IHBhdGhTdHJpbmdGb3JDb3VudCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICB0aGlzLnBhdGhGb3JDb3VudCA9IG51bGw7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMucGF0aEZvckNvdW50ID0gbmV3IFBhdGhfMS5QYXRoKHZhbHVlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwidmFyKFwiICsgdGhpcy5uYW1lICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcGF0aFN0ciA9IHRoaXMucGF0aFN0cmluZ0ZvckNvdW50O1xuICAgICAgICAgICAgcmV0dXJuIFwicmVhZF9jb3VudChcIiArIHBhdGhTdHIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVmFyaWFibGVSZWZlcmVuY2UgPSBWYXJpYWJsZVJlZmVyZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZhcmlhYmxlUmVmZXJlbmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5WYXJpYWJsZXNTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IFZhbHVlXzEgPSByZXF1aXJlKFwiLi9WYWx1ZVwiKTtcbmNvbnN0IFN0b3J5RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9TdG9yeUV4Y2VwdGlvblwiKTtcbmNvbnN0IEpzb25TZXJpYWxpc2F0aW9uXzEgPSByZXF1aXJlKFwiLi9Kc29uU2VyaWFsaXNhdGlvblwiKTtcbmNvbnN0IFR5cGVBc3NlcnRpb25fMSA9IHJlcXVpcmUoXCIuL1R5cGVBc3NlcnRpb25cIik7XG5jb25zdCBUcnlHZXRSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL1RyeUdldFJlc3VsdFwiKTtcbmNvbnN0IE51bGxFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL051bGxFeGNlcHRpb25cIik7XG5jbGFzcyBWYXJpYWJsZXNTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbFN0YWNrLCBsaXN0RGVmc09yaWdpbikge1xuICAgICAgICAvLyBUaGUgd2F5IHZhcmlhYmxlQ2hhbmdlZEV2ZW50IGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHRoZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIE9yaWdpbmFsbHkgaXQgdXNlcyB0aGUgQyMgKz0gb3BlcmF0b3IgdG8gYWRkIGRlbGVnYXRlcywgYnV0IGluIGpzIHdlIG5lZWQgdG8gbWFpbnRhaW5cbiAgICAgICAgLy8gYW4gYWN0dWFsIGNvbGxlY3Rpb24gb2YgZGVsZWdhdGVzIChpZS4gY2FsbGJhY2tzKSB0byByZWdpc3RlciBhIG5ldyBvbmUsIHRoZXJlIGlzIGFcbiAgICAgICAgLy8gc3BlY2lhbCBPYnNlcnZlVmFyaWFibGVDaGFuZ2UgbWV0aG9kIGJlbG93LlxuICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50Q2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMucGF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLl9iYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FsbFN0YWNrID0gY2FsbFN0YWNrO1xuICAgICAgICB0aGlzLl9saXN0RGVmc09yaWdpbiA9IGxpc3REZWZzT3JpZ2luO1xuICAgICAgICAvLyBpZiBlczYgcHJveGllcyBhcmUgYXZhaWxhYmxlLCB1c2UgdGhlbS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRoZSBwcm94eSBpcyB1c2VkIHRvIGFsbG93IGRpcmVjdCBtYW5pcHVsYXRpb24gb2YgZ2xvYmFsIHZhcmlhYmxlcy5cbiAgICAgICAgICAgIC8vIEl0IGZpcnN0IHRyaWVzIHRvIGFjY2VzcyB0aGUgb2JqZWN0cyBvd24gcHJvcGVydHksIGFuZCBpZiBub25lIGlzXG4gICAgICAgICAgICAvLyBmb3VuZCBpdCBkZWxlZ2F0ZXMgdGhlIGNhbGwgdG8gdGhlICQgbWV0aG9kLCBkZWZpbmVkIGJlbG93XG4gICAgICAgICAgICBsZXQgcCA9IG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSBpbiB0YXJnZXQgPyB0YXJnZXRbbmFtZV0gOiB0YXJnZXQuJChuYW1lKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIHRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuJChuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyByZXR1cm5pbmcgYSBmYWxzeSB2YWx1ZSBtYWtlIHRoZSB0cmFwIGZhaWxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gdGhyIHByb3h5IG9iamVjdCBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgY29udGV4dC4gd2Ugc2hvdWxkIHdhcm4gdGhlXG4gICAgICAgICAgICAvLyBkZXYgYnV0IHdyaXR0aW5nIHRvIHRoZSBjb25zb2xlIGZlZWxzIGEgYml0IGludHJ1c2l2ZS5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRVM2IFByb3h5IG5vdCBhdmFpbGFibGUgLSBkaXJlY3QgbWFuaXB1bGF0aW9uIG9mIGdsb2JhbCB2YXJpYWJsZXMgY2FuJ3Qgd29yaywgdXNlICQoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXJpYWJsZUNoYW5nZWRFdmVudCh2YXJpYWJsZU5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIHRoaXMudmFyaWFibGVDaGFuZ2VkRXZlbnRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHZhcmlhYmxlTmFtZSwgbmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBiYXRjaE9ic2VydmluZ1ZhcmlhYmxlQ2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzO1xuICAgIH1cbiAgICBzZXQgYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hPYnNlcnZpbmdWYXJpYWJsZUNoYW5nZXMgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2YXJpYWJsZU5hbWUgb2YgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyZW50VmFsdWUgPSB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuZ2V0KHZhcmlhYmxlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiY3VycmVudFZhbHVlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCh2YXJpYWJsZU5hbWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY2FsbFN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FsbFN0YWNrO1xuICAgIH1cbiAgICBzZXQgY2FsbFN0YWNrKGNhbGxTdGFjaykge1xuICAgICAgICB0aGlzLl9jYWxsU3RhY2sgPSBjYWxsU3RhY2s7XG4gICAgfVxuICAgIC8vIHRoZSBvcmlnaW5hbCBjb2RlIHVzZXMgYSBtYWdpYyBnZXR0ZXIgYW5kIHNldHRlciBmb3IgZ2xvYmFsIHZhcmlhYmxlcyxcbiAgICAvLyBhbGxvd2luZyB0aGluZ3MgbGlrZSB2YXJpYWJsZVN0YXRlWyd2YXJuYW1lXS4gVGhpcyBpcyBub3QgcXVpdGUgcG9zc2libGVcbiAgICAvLyBpbiBqcyB3aXRob3V0IGEgUHJveHksIHNvIGl0IGlzIHJlcGxhY2VkIHdpdGggdGhpcyAkIGZ1bmN0aW9uLlxuICAgICQodmFyaWFibGVOYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgdmFyQ29udGVudHMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJDb250ZW50cyA9IHRoaXMucGF0Y2guVHJ5R2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhckNvbnRlbnRzLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbnRlbnRzLnJlc3VsdC52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5fZ2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YXJDb250ZW50cyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhckNvbnRlbnRzID0gdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcy5nZXQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFyQ29udGVudHMgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhckNvbnRlbnRzLnZhbHVlT2JqZWN0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmdldCh2YXJpYWJsZU5hbWUpID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiQ2Fubm90IGFzc2lnbiB0byBhIHZhcmlhYmxlIChcIiArXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgIFwiKSB0aGF0IGhhc24ndCBiZWVuIGRlY2xhcmVkIGluIHRoZSBzdG9yeVwiKTtcbiAgICAgICAgICAgIGxldCB2YWwgPSBWYWx1ZV8xLlZhbHVlLkNyZWF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3RvcnlFeGNlcHRpb25fMS5TdG9yeUV4Y2VwdGlvbihcIkNhbm5vdCBwYXNzIG51bGwgdG8gVmFyaWFibGVTdGF0ZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yeUV4Y2VwdGlvbl8xLlN0b3J5RXhjZXB0aW9uKFwiSW52YWxpZCB2YWx1ZSBwYXNzZWQgdG8gVmFyaWFibGVTdGF0ZTogXCIgKyB2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLlNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXBwbHlQYXRjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwidGhpcy5wYXRjaFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBbbmFtZWRWYXJLZXksIG5hbWVkVmFyVmFsdWVdIG9mIHRoaXMucGF0Y2guZ2xvYmFscykge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldChuYW1lZFZhcktleSwgbmFtZWRWYXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgbmFtZSBvZiB0aGlzLnBhdGNoLmNoYW5nZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VkVmFyaWFibGVzRm9yQmF0Y2hPYnMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2ggPSBudWxsO1xuICAgIH1cbiAgICBTZXRKc29uVG9rZW4oalRva2VuKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFZhcmlhYmxlcy5jbGVhcigpO1xuICAgICAgICBmb3IgKGxldCBbdmFyVmFsS2V5LCB2YXJWYWxWYWx1ZV0gb2YgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGV0IGxvYWRlZFRva2VuID0galRva2VuW3ZhclZhbEtleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlZFRva2VuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuSW5rT2JqZWN0ID0gSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5KVG9rZW5Ub1J1bnRpbWVPYmplY3QobG9hZGVkVG9rZW4pO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbklua09iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRva2VuSW5rT2JqZWN0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9nbG9iYWxWYXJpYWJsZXMuc2V0KHZhclZhbEtleSwgdG9rZW5JbmtPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh2YXJWYWxLZXksIHZhclZhbFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBXcml0ZUpzb24od3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5Xcml0ZU9iamVjdFN0YXJ0KCk7XG4gICAgICAgIGZvciAobGV0IFtrZXlWYWxLZXksIGtleVZhbFZhbHVlXSBvZiB0aGlzLl9nbG9iYWxWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0ga2V5VmFsS2V5O1xuICAgICAgICAgICAgbGV0IHZhbCA9IGtleVZhbFZhbHVlO1xuICAgICAgICAgICAgaWYgKFZhcmlhYmxlc1N0YXRlLmRvbnRTYXZlRGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdFZhbCA9IHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5SdW50aW1lT2JqZWN0c0VxdWFsKHZhbCwgZGVmYXVsdFZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZXIuV3JpdGVQcm9wZXJ0eVN0YXJ0KG5hbWUpO1xuICAgICAgICAgICAgSnNvblNlcmlhbGlzYXRpb25fMS5Kc29uU2VyaWFsaXNhdGlvbi5Xcml0ZVJ1bnRpbWVPYmplY3Qod3JpdGVyLCB2YWwpO1xuICAgICAgICAgICAgd3JpdGVyLldyaXRlUHJvcGVydHlFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuV3JpdGVPYmplY3RFbmQoKTtcbiAgICB9XG4gICAgUnVudGltZU9iamVjdHNFcXVhbChvYmoxLCBvYmoyKSB7XG4gICAgICAgIGlmIChvYmoxID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm9iajFcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iajIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwib2JqMlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGludFZhbCA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoxLCBWYWx1ZV8xLkludFZhbHVlKTtcbiAgICAgICAgaWYgKGludFZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGludFZhbC52YWx1ZSA9PT0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3Mob2JqMiwgVmFsdWVfMS5JbnRWYWx1ZSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZsb2F0VmFsID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuRmxvYXRWYWx1ZSk7XG4gICAgICAgIGlmIChmbG9hdFZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsb2F0VmFsLnZhbHVlID09PSBUeXBlQXNzZXJ0aW9uXzEuYXNPclRocm93cyhvYmoyLCBWYWx1ZV8xLkZsb2F0VmFsdWUpLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWwxID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKG9iajEsIFZhbHVlXzEuVmFsdWUpO1xuICAgICAgICBsZXQgdmFsMiA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbChvYmoyLCBWYWx1ZV8xLlZhbHVlKTtcbiAgICAgICAgaWYgKHZhbDEgIT09IG51bGwgJiYgdmFsMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKFR5cGVBc3NlcnRpb25fMS5pc0VxdWF0YWJsZSh2YWwxLnZhbHVlT2JqZWN0KSAmJiBUeXBlQXNzZXJ0aW9uXzEuaXNFcXVhdGFibGUodmFsMi52YWx1ZU9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMS52YWx1ZU9iamVjdC5FcXVhbHModmFsMi52YWx1ZU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsMS52YWx1ZU9iamVjdCA9PT0gdmFsMi52YWx1ZU9iamVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYXN0Um91Z2hEZWZpbml0ZWx5RXF1YWxzOiBVbnN1cHBvcnRlZCBydW50aW1lIG9iamVjdCB0eXBlOiBcIiArXG4gICAgICAgICAgICBvYmoxLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH1cbiAgICBHZXRWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCA9IC0xKSB7XG4gICAgICAgIGxldCB2YXJWYWx1ZSA9IHRoaXMuR2V0UmF3VmFyaWFibGVXaXRoTmFtZShuYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICAvLyB2YXIgdmFyUG9pbnRlciA9IHZhclZhbHVlIGFzIFZhcmlhYmxlUG9pbnRlclZhbHVlO1xuICAgICAgICBsZXQgdmFyUG9pbnRlciA9IFR5cGVBc3NlcnRpb25fMS5hc09yTnVsbCh2YXJWYWx1ZSwgVmFsdWVfMS5WYXJpYWJsZVBvaW50ZXJWYWx1ZSk7XG4gICAgICAgIGlmICh2YXJQb2ludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXJWYWx1ZSA9IHRoaXMuVmFsdWVBdFZhcmlhYmxlUG9pbnRlcih2YXJQb2ludGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyVmFsdWU7XG4gICAgfVxuICAgIFRyeUdldERlZmF1bHRWYXJpYWJsZVZhbHVlKG5hbWUpIHtcbiAgICAgICAgbGV0IHZhbCA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLCBuYW1lLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHZhbC5leGlzdHMgPyB2YWwucmVzdWx0IDogbnVsbDtcbiAgICB9XG4gICAgR2xvYmFsVmFyaWFibGVFeGlzdHNXaXRoTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSB8fFxuICAgICAgICAgICAgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZhdWx0R2xvYmFsVmFyaWFibGVzLmhhcyhuYW1lKSkpO1xuICAgIH1cbiAgICBHZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCkge1xuICAgICAgICBsZXQgdmFyVmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29udGV4dEluZGV4ID09IDAgfHwgY29udGV4dEluZGV4ID09IC0xKSB7XG4gICAgICAgICAgICBsZXQgdmFyaWFibGVWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhcmlhYmxlVmFsdWUgPSB0aGlzLnBhdGNoLlRyeUdldEdsb2JhbChuYW1lLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWFibGVWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YXJpYWJsZVZhbHVlLnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBjb25kaXRpb25hbCBhc3NpZ25tZW50XG4gICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2dsb2JhbFZhcmlhYmxlcywgbmFtZSwgbnVsbCk7XG4gICAgICAgICAgICBpZiAodmFyaWFibGVWYWx1ZS5leGlzdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZVZhbHVlID0gVHJ5R2V0UmVzdWx0XzEudHJ5R2V0VmFsdWVGcm9tTWFwKHRoaXMuX2RlZmF1bHRHbG9iYWxWYXJpYWJsZXMsIG5hbWUsIG51bGwpO1xuICAgICAgICAgICAgICAgIGlmICh2YXJpYWJsZVZhbHVlLmV4aXN0cylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhcmlhYmxlVmFsdWUucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3REZWZzT3JpZ2luID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBOdWxsRXhjZXB0aW9uXzEudGhyb3dOdWxsRXhjZXB0aW9uKFwiVmFyaWFibGVzU3RhdGUuX2xpc3REZWZzT3JpZ2luXCIpO1xuICAgICAgICAgICAgbGV0IGxpc3RJdGVtVmFsdWUgPSB0aGlzLl9saXN0RGVmc09yaWdpbi5GaW5kU2luZ2xlSXRlbUxpc3RXaXRoTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChsaXN0SXRlbVZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0SXRlbVZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhclZhbHVlID0gdGhpcy5fY2FsbFN0YWNrLkdldFRlbXBvcmFyeVZhcmlhYmxlV2l0aE5hbWUobmFtZSwgY29udGV4dEluZGV4KTtcbiAgICAgICAgcmV0dXJuIHZhclZhbHVlO1xuICAgIH1cbiAgICBWYWx1ZUF0VmFyaWFibGVQb2ludGVyKHBvaW50ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuR2V0VmFyaWFibGVXaXRoTmFtZShwb2ludGVyLnZhcmlhYmxlTmFtZSwgcG9pbnRlci5jb250ZXh0SW5kZXgpO1xuICAgIH1cbiAgICBBc3NpZ24odmFyQXNzLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbmFtZSA9IHZhckFzcy52YXJpYWJsZU5hbWU7XG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcIm5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRleHRJbmRleCA9IC0xO1xuICAgICAgICBsZXQgc2V0R2xvYmFsID0gZmFsc2U7XG4gICAgICAgIGlmICh2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgc2V0R2xvYmFsID0gdmFyQXNzLmlzR2xvYmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0R2xvYmFsID0gdGhpcy5HbG9iYWxWYXJpYWJsZUV4aXN0c1dpdGhOYW1lKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJBc3MuaXNOZXdEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgLy8gdmFyIHZhclBvaW50ZXIgPSB2YWx1ZSBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgIGxldCB2YXJQb2ludGVyID0gVHlwZUFzc2VydGlvbl8xLmFzT3JOdWxsKHZhbHVlLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YXJQb2ludGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZ1bGx5UmVzb2x2ZWRWYXJpYWJsZVBvaW50ZXIgPSB0aGlzLlJlc29sdmVWYXJpYWJsZVBvaW50ZXIodmFyUG9pbnRlcik7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmdWxseVJlc29sdmVkVmFyaWFibGVQb2ludGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGV4aXN0aW5nUG9pbnRlciA9IG51bGw7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmdQb2ludGVyID0gR2V0UmF3VmFyaWFibGVXaXRoTmFtZSAobmFtZSwgY29udGV4dEluZGV4KSBhcyBWYXJpYWJsZVBvaW50ZXJWYWx1ZTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1BvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodGhpcy5HZXRSYXdWYXJpYWJsZVdpdGhOYW1lKG5hbWUsIGNvbnRleHRJbmRleCksIFZhbHVlXzEuVmFyaWFibGVQb2ludGVyVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1BvaW50ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gZXhpc3RpbmdQb2ludGVyLnZhcmlhYmxlTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dEluZGV4ID0gZXhpc3RpbmdQb2ludGVyLmNvbnRleHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgc2V0R2xvYmFsID0gY29udGV4dEluZGV4ID09IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoZXhpc3RpbmdQb2ludGVyICE9IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXRHbG9iYWwpIHtcbiAgICAgICAgICAgIHRoaXMuU2V0R2xvYmFsKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxTdGFjay5TZXRUZW1wb3JhcnlWYXJpYWJsZShuYW1lLCB2YWx1ZSwgdmFyQXNzLmlzTmV3RGVjbGFyYXRpb24sIGNvbnRleHRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU25hcHNob3REZWZhdWx0R2xvYmFscygpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEdsb2JhbFZhcmlhYmxlcyA9IG5ldyBNYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzKTtcbiAgICB9XG4gICAgUmV0YWluTGlzdE9yaWdpbnNGb3JBc3NpZ25tZW50KG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBsZXQgb2xkTGlzdCA9IFR5cGVBc3NlcnRpb25fMS5hc09yVGhyb3dzKG9sZFZhbHVlLCBWYWx1ZV8xLkxpc3RWYWx1ZSk7XG4gICAgICAgIGxldCBuZXdMaXN0ID0gVHlwZUFzc2VydGlvbl8xLmFzT3JUaHJvd3MobmV3VmFsdWUsIFZhbHVlXzEuTGlzdFZhbHVlKTtcbiAgICAgICAgaWYgKG9sZExpc3QudmFsdWUgJiYgbmV3TGlzdC52YWx1ZSAmJiBuZXdMaXN0LnZhbHVlLkNvdW50ID09IDApIHtcbiAgICAgICAgICAgIG5ld0xpc3QudmFsdWUuU2V0SW5pdGlhbE9yaWdpbk5hbWVzKG9sZExpc3QudmFsdWUub3JpZ2luTmFtZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNldEdsb2JhbCh2YXJpYWJsZU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBhdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IFRyeUdldFJlc3VsdF8xLnRyeUdldFZhbHVlRnJvbU1hcCh0aGlzLl9nbG9iYWxWYXJpYWJsZXMsIHZhcmlhYmxlTmFtZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9sZFZhbHVlID0gdGhpcy5wYXRjaC5UcnlHZXRHbG9iYWwodmFyaWFibGVOYW1lLCBudWxsKTtcbiAgICAgICAgICAgIGlmICghb2xkVmFsdWUuZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBUcnlHZXRSZXN1bHRfMS50cnlHZXRWYWx1ZUZyb21NYXAodGhpcy5fZ2xvYmFsVmFyaWFibGVzLCB2YXJpYWJsZU5hbWUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFZhbHVlXzEuTGlzdFZhbHVlLlJldGFpbkxpc3RPcmlnaW5zRm9yQXNzaWdubWVudChvbGRWYWx1ZS5yZXN1bHQsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhcmlhYmxlTmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bGxFeGNlcHRpb25fMS50aHJvd051bGxFeGNlcHRpb24oXCJ2YXJpYWJsZU5hbWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGF0Y2guU2V0R2xvYmFsKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsVmFyaWFibGVzLnNldCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBOb3Qgc3VyZSAhPT0gaXMgZXF1aXZhbGVudCB0byAhdmFsdWUuRXF1YWxzKG9sZFZhbHVlKVxuICAgICAgICBpZiAodGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgb2xkVmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHZhbHVlICE9PSBvbGRWYWx1ZS5yZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoT2JzZXJ2aW5nVmFyaWFibGVDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTnVsbEV4Y2VwdGlvbl8xLnRocm93TnVsbEV4Y2VwdGlvbihcInRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9ic1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRjaC5BZGRDaGFuZ2VkVmFyaWFibGUodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fY2hhbmdlZFZhcmlhYmxlc0ZvckJhdGNoT2JzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWRWYXJpYWJsZXNGb3JCYXRjaE9icy5hZGQodmFyaWFibGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhcmlhYmxlQ2hhbmdlZEV2ZW50KHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmVWYXJpYWJsZVBvaW50ZXIodmFyUG9pbnRlcikge1xuICAgICAgICBsZXQgY29udGV4dEluZGV4ID0gdmFyUG9pbnRlci5jb250ZXh0SW5kZXg7XG4gICAgICAgIGlmIChjb250ZXh0SW5kZXggPT0gLTEpXG4gICAgICAgICAgICBjb250ZXh0SW5kZXggPSB0aGlzLkdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh2YXJQb2ludGVyLnZhcmlhYmxlTmFtZSk7XG4gICAgICAgIGxldCB2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8gPSB0aGlzLkdldFJhd1ZhcmlhYmxlV2l0aE5hbWUodmFyUG9pbnRlci52YXJpYWJsZU5hbWUsIGNvbnRleHRJbmRleCk7XG4gICAgICAgIC8vIHZhciBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXIgPSB2YWx1ZU9mVmFyaWFibGVQb2ludGVkVG8gYXMgVmFyaWFibGVQb2ludGVyVmFsdWU7XG4gICAgICAgIGxldCBkb3VibGVSZWRpcmVjdGlvblBvaW50ZXIgPSBUeXBlQXNzZXJ0aW9uXzEuYXNPck51bGwodmFsdWVPZlZhcmlhYmxlUG9pbnRlZFRvLCBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKTtcbiAgICAgICAgaWYgKGRvdWJsZVJlZGlyZWN0aW9uUG9pbnRlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZG91YmxlUmVkaXJlY3Rpb25Qb2ludGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWYWx1ZV8xLlZhcmlhYmxlUG9pbnRlclZhbHVlKHZhclBvaW50ZXIudmFyaWFibGVOYW1lLCBjb250ZXh0SW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEdldENvbnRleHRJbmRleE9mVmFyaWFibGVOYW1lZCh2YXJOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLkdsb2JhbFZhcmlhYmxlRXhpc3RzV2l0aE5hbWUodmFyTmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGxTdGFjay5jdXJyZW50RWxlbWVudEluZGV4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHNwZWNpZmljIHRvIHRoZSBqcyB2ZXJzaW9uIG9mIGluay4gSXQgYWxsb3dzIHRvIHJlZ2lzdGVyIGFcbiAgICAgKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gYSB2YXJpYWJsZSBjaGFuZ2VzLiBUaGUgb3JpZ2luYWwgY29kZSB1c2VzXG4gICAgICogYHN0YXRlLnZhcmlhYmxlQ2hhbmdlZEV2ZW50ICs9IGNhbGxiYWNrYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBPYnNlcnZlVmFyaWFibGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZUNoYW5nZWRFdmVudENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhYmxlc1N0YXRlID0gVmFyaWFibGVzU3RhdGU7XG5WYXJpYWJsZXNTdGF0ZS5kb250U2F2ZURlZmF1bHRWYWx1ZXMgPSB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFyaWFibGVzU3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZvaWQgPSB2b2lkIDA7XG5jb25zdCBPYmplY3RfMSA9IHJlcXVpcmUoXCIuL09iamVjdFwiKTtcbmNsYXNzIFZvaWQgZXh0ZW5kcyBPYmplY3RfMS5JbmtPYmplY3Qge1xufVxuZXhwb3J0cy5Wb2lkID0gVm9pZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvaWQuanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSBMb25nO1xyXG5cclxuLyoqXHJcbiAqIHdhc20gb3B0aW1pemF0aW9ucywgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXHJcbiAqL1xyXG52YXIgd2FzbSA9IG51bGw7XHJcblxyXG50cnkge1xyXG4gIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbXHJcbiAgICAwLCA5NywgMTE1LCAxMDksIDEsIDAsIDAsIDAsIDEsIDEzLCAyLCA5NiwgMCwgMSwgMTI3LCA5NiwgNCwgMTI3LCAxMjcsIDEyNywgMTI3LCAxLCAxMjcsIDMsIDcsIDYsIDAsIDEsIDEsIDEsIDEsIDEsIDYsIDYsIDEsIDEyNywgMSwgNjUsIDAsIDExLCA3LCA1MCwgNiwgMywgMTA5LCAxMTcsIDEwOCwgMCwgMSwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNSwgMCwgMiwgNSwgMTAwLCAxMDUsIDExOCwgOTUsIDExNywgMCwgMywgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNSwgMCwgNCwgNSwgMTE0LCAxMDEsIDEwOSwgOTUsIDExNywgMCwgNSwgOCwgMTAzLCAxMDEsIDExNiwgOTUsIDEwNCwgMTA1LCAxMDMsIDEwNCwgMCwgMCwgMTAsIDE5MSwgMSwgNiwgNCwgMCwgMzUsIDAsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjYsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNywgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjksIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEzMCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMVxyXG4gIF0pKSwge30pLmV4cG9ydHM7XHJcbn0gY2F0Y2ggKGUpIHtcclxuICAvLyBubyB3YXNtIHN1cHBvcnQgOihcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXHJcbiAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxyXG4gKiBAZXhwb3J0cyBMb25nXHJcbiAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XHJcbn1cclxuXHJcbi8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXHJcbi8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXHJcbi8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxyXG4vLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXHJcbi8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XHJcbi8vIG9yIGNoYW5nZSBpbiBzaWduLlxyXG4vL1xyXG4vLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXHJcbi8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxyXG4vLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcclxuLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xyXG4vLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXHJcbi8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cclxuLy9cclxuLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXHJcbi8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXHJcblxyXG4vKipcclxuICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxyXG4gKiBAdHlwZSB7Ym9vbGVhbn1cclxuICogQGNvbnN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5Mb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExvbmcucHJvdG90eXBlLCBcIl9faXNMb25nX19cIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcclxuICAgIHJldHVybiAob2JqICYmIG9ialtcIl9faXNMb25nX19cIl0pID09PSB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZy5pc0xvbmcgPSBpc0xvbmc7XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cclxuICogQHR5cGUgeyFPYmplY3R9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVJTlRfQ0FDSEUgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xyXG4gICAgICAgIGlmIChjYWNoZSA9ICgwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSkge1xyXG4gICAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAodmFsdWUgfCAwKSA8IDAgPyAtMSA6IDAsIHRydWUpO1xyXG4gICAgICAgIGlmIChjYWNoZSlcclxuICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFsdWUgfD0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoLTEyOCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDEyOCkpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcclxuICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZWRPYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCB2YWx1ZSA8IDAgPyAtMSA6IDAsIGZhbHNlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gMzIgYml0IGludGVnZXIgdmFsdWUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIDMyIGJpdCBpbnRlZ2VyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21JbnQgPSBmcm9tSW50O1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgdW5zaWduZWQpIHtcclxuICAgIGlmIChpc05hTih2YWx1ZSkpXHJcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgaWYgKHVuc2lnbmVkKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKVxyXG4gICAgICAgICAgICByZXR1cm4gTUFYX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlIDwgMClcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcclxuICAgIHJldHVybiBmcm9tQml0cygodmFsdWUgJSBUV09fUFdSXzMyX0RCTCkgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIHZhbHVlLCBwcm92aWRlZCB0aGF0IGl0IGlzIGEgZmluaXRlIG51bWJlci4gT3RoZXJ3aXNlLCB6ZXJvIGlzIHJldHVybmVkLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSBudW1iZXIgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcclxuICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSA2NCBiaXQgaW50ZWdlciB0aGF0IGNvbWVzIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxvdyBhbmQgaGlnaCBiaXRzLiBFYWNoIGlzXHJcbiAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHMgVGhlIGxvdyAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBvbmVudFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXHJcblxyXG4vKipcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XHJcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XHJcbiAgICBpZiAoc3RyID09PSBcIk5hTlwiIHx8IHN0ciA9PT0gXCJJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCIrSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiLUluZmluaXR5XCIpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgcmFkaXggPSB1bnNpZ25lZCxcclxuICAgICAgICB1bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB1bnNpZ25lZCA9ICEhIHVuc2lnbmVkO1xyXG4gICAgfVxyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG5cclxuICAgIHZhciBwO1xyXG4gICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdpbnRlcmlvciBoeXBoZW4nKTtcclxuICAgIGVsc2UgaWYgKHAgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDgpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgOCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSBaRVJPO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IE1hdGgubWluKDgsIHN0ci5sZW5ndGggLSBpKSxcclxuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xyXG4gICAgICAgIGlmIChzaXplIDwgOCkge1xyXG4gICAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc3VsdC51bnNpZ25lZCA9IHVuc2lnbmVkO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIHRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIExvbmdcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge251bWJlcj19IHJhZGl4IFRoZSByYWRpeCBpbiB3aGljaCB0aGUgdGV4dCBpcyB3cml0dGVuICgyLTM2KSwgZGVmYXVsdHMgdG8gMTBcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbCwgdW5zaWduZWQpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcclxuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyh2YWwsIHVuc2lnbmVkKTtcclxuICAgIC8vIFRocm93cyBmb3Igbm9uLW9iamVjdHMsIGNvbnZlcnRzIG5vbi1pbnN0YW5jZW9mIExvbmc6XHJcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIHNwZWNpZmllZCB2YWx1ZSB0byBhIExvbmcgdXNpbmcgdGhlIGFwcHJvcHJpYXRlIGZyb20qIGZ1bmN0aW9uIGZvciBpdHMgdHlwZS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ3whe2xvdzogbnVtYmVyLCBoaWdoOiBudW1iZXIsIHVuc2lnbmVkOiBib29sZWFufX0gdmFsIFZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XHJcblxyXG4vLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXHJcbi8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzMyX0RCTCA9IFRXT19QV1JfMTZfREJMICogVFdPX1BXUl8xNl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8yNCA9IGZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgWkVSTyA9IGZyb21JbnQoMCk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuWkVSTyA9IFpFUk87XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVWkVSTyA9IGZyb21JbnQoMCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogVW5zaWduZWQgemVyby5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VWkVSTyA9IFVaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgT05FID0gZnJvbUludCgxKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk9ORSA9IE9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFVPTkUgPSBmcm9tSW50KDEsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5VT05FID0gVU9ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE5FR19PTkUgPSBmcm9tSW50KC0xKTtcclxuXHJcbi8qKlxyXG4gKiBTaWduZWQgbmVnYXRpdmUgb25lLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLk5FR19PTkUgPSBORUdfT05FO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweDdGRkZGRkZGfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNQVhfVU5TSUdORURfVkFMVUUgPSBmcm9tQml0cygweEZGRkZGRkZGfDAsIDB4RkZGRkZGRkZ8MCwgdHJ1ZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSB1bnNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwfDAsIGZhbHNlKTtcclxuXHJcbi8qKlxyXG4gKiBNaW5pbXVtIHNpZ25lZCB2YWx1ZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5NSU5fVkFMVUUgPSBNSU5fVkFMVUU7XHJcblxyXG4vKipcclxuICogQGFsaWFzIExvbmcucHJvdG90eXBlXHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIExvbmdQcm90b3R5cGUgPSBMb25nLnByb3RvdHlwZTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uIHRvSW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgdGhlIG5lYXJlc3QgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB2YWx1ZSAoZG91YmxlLCA1MyBiaXQgbWFudGlzc2EpLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xyXG4gICAgaWYgKHRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMKSArICh0aGlzLmxvdyA+Pj4gMCk7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBvdmVycmlkZVxyXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XHJcbiAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xyXG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KVxyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gJzAnO1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBjaGFuZ2UgdGhlIExvbmcgdmFsdWUgYmVmb3JlIGl0IGNhbiBiZSBuZWdhdGVkLCBzbyB3ZSByZW1vdmVcclxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxyXG4gICAgICAgICAgICB2YXIgcmFkaXhMb25nID0gZnJvbU51bWJlcihyYWRpeCksXHJcbiAgICAgICAgICAgICAgICBkaXYgPSB0aGlzLmRpdihyYWRpeExvbmcpLFxyXG4gICAgICAgICAgICAgICAgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYudG9TdHJpbmcocmFkaXgpICsgcmVtMS50b0ludCgpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvIHNldmVyYWwgKDYpIGRpZ2l0cyBlYWNoIHRpbWUgdGhyb3VnaCB0aGUgbG9vcCwgc28gYXMgdG9cclxuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxyXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxyXG4gICAgICAgIHJlbSA9IHRoaXM7XHJcbiAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXHJcbiAgICAgICAgICAgIGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwLFxyXG4gICAgICAgICAgICBkaWdpdHMgPSBpbnR2YWwudG9TdHJpbmcocmFkaXgpO1xyXG4gICAgICAgIHJlbSA9IHJlbURpdjtcclxuICAgICAgICBpZiAocmVtLmlzWmVybygpKVxyXG4gICAgICAgICAgICByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpXHJcbiAgICAgICAgICAgICAgICBkaWdpdHMgPSAnMCcgKyBkaWdpdHM7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0cyA9IGZ1bmN0aW9uIGdldEhpZ2hCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBTaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TG93Qml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0TG93Qml0c1Vuc2lnbmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIC8vIFVuc2lnbmVkIExvbmdzIGFyZSBuZXZlciBuZWdhdGl2ZVxyXG4gICAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xyXG4gICAgdmFyIHZhbCA9IHRoaXMuaGlnaCAhPSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XHJcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pXHJcbiAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IDAgJiYgdGhpcy5sb3cgPT09IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG5lZ2F0aXZlLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBwb3NpdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiBpc1Bvc2l0aXZlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgb2RkLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuKCkge1xyXG4gICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiAodGhpcy5oaWdoID4+PiAzMSkgPT09IDEgJiYgKG90aGVyLmhpZ2ggPj4+IDMxKSA9PT0gMSlcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZXEgPSBMb25nUHJvdG90eXBlLmVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiAhdGhpcy5lcSgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lcSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpID4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFufS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbjtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmd0ZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdlID0gTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWw7XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxyXG4gKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcclxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcclxuICAgIGlmICh0aGlzTmVnICYmICFvdGhlck5lZylcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XHJcbiAgICAvLyBCb3RoIGFyZSBwb3NpdGl2ZSBpZiBhdCBsZWFzdCBvbmUgaXMgdW5zaWduZWRcclxuICAgIHJldHVybiAob3RoZXIuaGlnaCA+Pj4gMCkgPiAodGhpcy5oaWdoID4+PiAwKSB8fCAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIChvdGhlci5sb3cgPj4+IDApID4gKHRoaXMubG93ID4+PiAwKSkgPyAtMSA6IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wID0gTG9uZ1Byb3RvdHlwZS5jb21wYXJlO1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTtcclxuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm5lZyA9IExvbmdQcm90b3R5cGUubmVnYXRlO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gYWRkZW5kIEFkZGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFN1bVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhhZGRlbmQpKVxyXG4gICAgICAgIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxyXG5cclxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBhZGRlbmQuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcclxuICAgIHZhciBiMDAgPSBhZGRlbmQubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCArIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKyBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICsgYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCArIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoc3VidHJhaGVuZCkpXHJcbiAgICAgICAgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcclxuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBkaWZmZXJlbmNlIG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzdWJ0cmFjdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IERpZmZlcmVuY2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcclxuICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSlcclxuICAgICAgICBtdWx0aXBsaWVyID0gZnJvbVZhbHVlKG11bHRpcGxpZXIpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gd2FzbS5tdWwodGhpcy5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGllci5sb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAobXVsdGlwbGllci5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gWkVSTztcclxuICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XHJcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG5cclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIubmVnKCkpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkubXVsKG11bHRpcGxpZXIpLm5lZygpO1xyXG4gICAgfSBlbHNlIGlmIChtdWx0aXBsaWVyLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XHJcblxyXG4gICAgLy8gSWYgYm90aCBsb25ncyBhcmUgc21hbGwsIHVzZSBmbG9hdCBtdWx0aXBsaWNhdGlvblxyXG4gICAgaWYgKHRoaXMubHQoVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChUV09fUFdSXzI0KSlcclxuICAgICAgICByZXR1cm4gZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xyXG5cclxuICAgIC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxyXG4gICAgLy8gV2UgY2FuIHNraXAgcHJvZHVjdHMgdGhhdCB3b3VsZCBvdmVyZmxvdy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBtdWx0aXBsaWVyLmhpZ2ggPj4+IDE2O1xyXG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcclxuICAgIHZhciBiMTYgPSBtdWx0aXBsaWVyLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gbXVsdGlwbGllci5sb3cgJiAweEZGRkY7XHJcblxyXG4gICAgdmFyIGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XHJcbiAgICBjMDAgKz0gYTAwICogYjAwO1xyXG4gICAgYzE2ICs9IGMwMCA+Pj4gMTY7XHJcbiAgICBjMDAgJj0gMHhGRkZGO1xyXG4gICAgYzE2ICs9IGExNiAqIGIwMDtcclxuICAgIGMzMiArPSBjMTYgPj4+IDE2O1xyXG4gICAgYzE2ICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMDAgKiBiMTY7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTMyICogYjAwO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGExNiAqIGIxNjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMDAgKiBiMzI7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xyXG4gICAgYzQ4ICY9IDB4RkZGRjtcclxuICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhlIHJlc3VsdCBpcyBzaWduZWQgaWYgdGhpcyBMb25nIGlzIHNpZ25lZCBvclxyXG4gKiAgdW5zaWduZWQgaWYgdGhpcyBMb25nIGlzIHVuc2lnbmVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG4gICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzaWduZWQgZGl2aXNpb24gb3ZlcmZsb3c6IHRoZSBsYXJnZXN0XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIHBvc2l0aXZlIG51bWJlciwgZHVlIHRvIHR3bydzIGNvbXBsZW1lbnQuXHJcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcclxuICAgICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmIGRpdmlzb3IuaGlnaCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gYmUgY29uc2lzdGVudCB3aXRoIG5vbi13YXNtIGNvZGUgcGF0aFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbS5kaXZfdSA6IHdhc20uZGl2X3MpKFxyXG4gICAgICAgICAgICB0aGlzLmxvdyxcclxuICAgICAgICAgICAgdGhpcy5oaWdoLFxyXG4gICAgICAgICAgICBkaXZpc29yLmxvdyxcclxuICAgICAgICAgICAgZGl2aXNvci5oaWdoXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgdmFyIGFwcHJveCwgcmVtLCByZXM7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHtcclxuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXHJcbiAgICAgICAgLy8gY2xvc3VyZSBsaWJyYXJ5IGFzIGEgd2hvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5lcShPTkUpIHx8IGRpdmlzb3IuZXEoTkVHX09ORSkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTUlOX1ZBTFVFOyAgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcclxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ORTtcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXHJcbiAgICAgICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcclxuICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gT05FIDogTkVHX09ORTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtID0gdGhpcy5zdWIoZGl2aXNvci5tdWwoYXBwcm94KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xyXG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xyXG4gICAgICAgICAgICBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLmRpdihkaXZpc29yKS5uZWcoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XHJcbiAgICAgICAgcmVzID0gWkVSTztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXHJcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxyXG4gICAgICAgIGlmICghZGl2aXNvci51bnNpZ25lZClcclxuICAgICAgICAgICAgZGl2aXNvciA9IGRpdmlzb3IudG9VbnNpZ25lZCgpO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxyXG4gICAgICAgICAgICByZXR1cm4gVVpFUk87XHJcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSkgLy8gMTUgPj4+IDEgPSA3IDsgd2l0aCBkaXZpc29yID0gOCA7IHRydWVcclxuICAgICAgICAgICAgcmV0dXJuIFVPTkU7XHJcbiAgICAgICAgcmVzID0gVVpFUk87XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcclxuICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcclxuICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcclxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcclxuICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxyXG4gICAgcmVtID0gdGhpcztcclxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XHJcbiAgICAgICAgLy8gQXBwcm94aW1hdGUgdGhlIHJlc3VsdCBvZiBkaXZpc2lvbi4gVGhpcyBtYXkgYmUgYSBsaXR0bGUgZ3JlYXRlciBvclxyXG4gICAgICAgIC8vIHNtYWxsZXIgdGhhbiB0aGUgYWN0dWFsIHZhbHVlLlxyXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcclxuXHJcbiAgICAgICAgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxyXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cclxuICAgICAgICB2YXIgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpLFxyXG4gICAgICAgICAgICBkZWx0YSA9IChsb2cyIDw9IDQ4KSA/IDEgOiBwb3dfZGJsKDIsIGxvZzIgLSA0OCksXHJcblxyXG4gICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxyXG4gICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCksXHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcclxuICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBrbm93IHRoZSBhbnN3ZXIgY2FuJ3QgYmUgemVyby4uLiBhbmQgYWN0dWFsbHksIHplcm8gd291bGQgY2F1c2VcclxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cclxuICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxyXG4gICAgICAgICAgICBhcHByb3hSZXMgPSBPTkU7XHJcblxyXG4gICAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcclxuICAgICAgICByZW0gPSByZW0uc3ViKGFwcHJveFJlbSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kdWxvID0gZnVuY3Rpb24gbW9kdWxvKGRpdmlzb3IpIHtcclxuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKVxyXG4gICAgICAgIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20ucmVtX3UgOiB3YXNtLnJlbV9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBSZW1haW5kZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnJlbSA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMofnRoaXMubG93LCB+dGhpcy5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIEFORCBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZChvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyAmIG90aGVyLmxvdywgdGhpcy5oaWdoICYgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgfCBvdGhlci5sb3csIHRoaXMuaGlnaCB8IG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IF4gb3RoZXIubG93LCB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQgPSBmdW5jdGlvbiBzaGlmdExlZnQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNobCA9IExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XHJcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKVxyXG4gICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XHJcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxyXG4gICAgICAgIHJldHVybiBmcm9tQml0cygodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIHRoaXMuaGlnaCA+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIGVsc2VcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IChudW1CaXRzIC0gMzIpLCB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQgPSBmdW5jdGlvbiBzaGlmdFJpZ2h0VW5zaWduZWQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgbnVtQml0cyAmPSA2MztcclxuICAgIGlmIChudW1CaXRzID09PSAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLmhpZ2g7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xyXG4gICAgICAgICAgICB2YXIgbG93ID0gdGhpcy5sb3c7XHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cygobG93ID4+PiBudW1CaXRzKSB8IChoaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChudW1CaXRzID09PSAzMilcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIGZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodFVuc2lnbmVkfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cclxuICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1NpZ25lZCA9IGZ1bmN0aW9uIHRvU2lnbmVkKCkge1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIGZhbHNlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b1Vuc2lnbmVkID0gZnVuY3Rpb24gdG9VbnNpZ25lZCgpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7IUFycmF5LjxudW1iZXI+fSBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNMRSA9IGZ1bmN0aW9uIHRvQnl0ZXNMRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpICAgICAgICAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAyNFxyXG4gICAgXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnRvQnl0ZXNCRSA9IGZ1bmN0aW9uIHRvQnl0ZXNCRSgpIHtcclxuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcclxuICAgICAgICBsbyA9IHRoaXMubG93O1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICBoaSA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGhpID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAyNCAgICAgICAsXHJcbiAgICAgICAgbG8gPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvICAgICAgICAmIDB4ZmZcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XHJcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgbGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzTEUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1swXSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1szXSA8PCAyNCxcclxuICAgICAgICBieXRlc1s0XSAgICAgICB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8IDE2IHxcclxuICAgICAgICBieXRlc1s3XSA8PCAyNCxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xyXG4gICAgcmV0dXJuIG5ldyBMb25nKFxyXG4gICAgICAgIGJ5dGVzWzRdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1s1XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbNl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzddLFxyXG4gICAgICAgIGJ5dGVzWzBdIDw8IDI0IHxcclxuICAgICAgICBieXRlc1sxXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbMl0gPDwgIDggfFxyXG4gICAgICAgIGJ5dGVzWzNdLFxyXG4gICAgICAgIHVuc2lnbmVkXHJcbiAgICApO1xyXG59O1xyXG4iLCIvLyBtaW5pbWFsIGxpYnJhcnkgZW50cnkgcG9pbnQuXG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9zcmMvaW5kZXgtbWluaW1hbFwiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gZXhwb3J0cztcblxuLyoqXG4gKiBCdWlsZCB0eXBlLCBvbmUgb2YgYFwiZnVsbFwiYCwgYFwibGlnaHRcImAgb3IgYFwibWluaW1hbFwiYC5cbiAqIEBuYW1lIGJ1aWxkXG4gKiBAdHlwZSB7c3RyaW5nfVxuICogQGNvbnN0XG4gKi9cbnByb3RvYnVmLmJ1aWxkID0gXCJtaW5pbWFsXCI7XG5cbi8vIFNlcmlhbGl6YXRpb25cbnByb3RvYnVmLldyaXRlciAgICAgICA9IHJlcXVpcmUoXCIuL3dyaXRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlcldyaXRlciA9IHJlcXVpcmUoXCIuL3dyaXRlcl9idWZmZXJcIik7XG5wcm90b2J1Zi5SZWFkZXIgICAgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIik7XG5wcm90b2J1Zi5CdWZmZXJSZWFkZXIgPSByZXF1aXJlKFwiLi9yZWFkZXJfYnVmZmVyXCIpO1xuXG4vLyBVdGlsaXR5XG5wcm90b2J1Zi51dGlsICAgICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5wcm90b2J1Zi5ycGMgICAgICAgICAgPSByZXF1aXJlKFwiLi9ycGNcIik7XG5wcm90b2J1Zi5yb290cyAgICAgICAgPSByZXF1aXJlKFwiLi9yb290c1wiKTtcbnByb3RvYnVmLmNvbmZpZ3VyZSAgICA9IGNvbmZpZ3VyZTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKlxuICogUmVjb25maWd1cmVzIHRoZSBsaWJyYXJ5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBjb25maWd1cmUoKSB7XG4gICAgcHJvdG9idWYudXRpbC5fY29uZmlndXJlKCk7XG4gICAgcHJvdG9idWYuV3JpdGVyLl9jb25maWd1cmUocHJvdG9idWYuQnVmZmVyV3JpdGVyKTtcbiAgICBwcm90b2J1Zi5SZWFkZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJSZWFkZXIpO1xufVxuXG4vLyBTZXQgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudFxuY29uZmlndXJlKCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUmVhZGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyUmVhZGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaW5kZXhPdXRPZlJhbmdlKHJlYWRlciwgd3JpdGVMZW5ndGgpIHtcbiAgICByZXR1cm4gUmFuZ2VFcnJvcihcImluZGV4IG91dCBvZiByYW5nZTogXCIgKyByZWFkZXIucG9zICsgXCIgKyBcIiArICh3cml0ZUxlbmd0aCB8fCAxKSArIFwiID4gXCIgKyByZWFkZXIubGVuKTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlYWRlciBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIGBVaW50OEFycmF5YCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBgQXJyYXlgLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZmZlciBCdWZmZXIgdG8gcmVhZCBmcm9tXG4gKi9cbmZ1bmN0aW9uIFJlYWRlcihidWZmZXIpIHtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYnVmID0gYnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIgcG9zaXRpb24uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnBvcyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGJ1ZmZlci5sZW5ndGg7XG59XG5cbnZhciBjcmVhdGVfYXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gZnVuY3Rpb24gY3JlYXRlX3R5cGVkX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gY3JlYXRlX2FycmF5KGJ1ZmZlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShidWZmZXIpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJpbGxlZ2FsIGJ1ZmZlclwiKTtcbiAgICB9O1xuXG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB1dGlsLkJ1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXJfc2V0dXAoYnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLkJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IEJ1ZmZlclJlYWRlcihidWZmZXIpXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlX2FycmF5KGJ1ZmZlcik7XG4gICAgICAgICAgICB9KShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogY3JlYXRlX2FycmF5O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHJlYWRlciB1c2luZyB0aGUgc3BlY2lmaWVkIGJ1ZmZlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtVaW50OEFycmF5fEJ1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqIEByZXR1cm5zIHtSZWFkZXJ8QnVmZmVyUmVhZGVyfSBBIHtAbGluayBCdWZmZXJSZWFkZXJ9IGlmIGBidWZmZXJgIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgYSB7QGxpbmsgUmVhZGVyfVxuICogQHRocm93cyB7RXJyb3J9IElmIGBidWZmZXJgIGlzIG5vdCBhIHZhbGlkIGJ1ZmZlclxuICovXG5SZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG5cblJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc3ViYXJyYXkgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5BcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUudWludDMyID0gKGZ1bmN0aW9uIHJlYWRfdWludDMyX3NldHVwKCkge1xuICAgIHZhciB2YWx1ZSA9IDQyOTQ5NjcyOTU7IC8vIG9wdGltaXplciB0eXBlLWhpbnQsIHRlbmRzIHRvIGRlb3B0IG90aGVyd2lzZSAoPyEpXG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRfdWludDMyKCkge1xuICAgICAgICB2YWx1ZSA9ICggICAgICAgICB0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcgICAgICAgKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgIDcpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAxNCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDIxKSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmICAxNSkgPDwgMjgpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCh0aGlzLnBvcyArPSA1KSA+IHRoaXMubGVuKSB7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IHRoaXMubGVuO1xuICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgMzIgYml0IHZhbHVlLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gcmVhZF9pbnQzMigpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSB8IDA7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgemlnLXphZyBlbmNvZGVkIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gcmVhZF9zaW50MzIoKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy51aW50MzIoKTtcbiAgICByZXR1cm4gdmFsdWUgPj4+IDEgXiAtKHZhbHVlICYgMSkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRMb25nVmFyaW50KCkge1xuICAgIC8vIHRlbmRzIHRvIGRlb3B0IHdpdGggbG9jYWwgdmFycyBmb3Igb2N0ZXQgZXRjLlxuICAgIHZhciBiaXRzID0gbmV3IExvbmdCaXRzKDAsIDApO1xuICAgIHZhciBpID0gMDtcbiAgICBpZiAodGhpcy5sZW4gLSB0aGlzLnBvcyA+IDQpIHsgLy8gZmFzdCByb3V0ZSAobG8pXG4gICAgICAgIGZvciAoOyBpIDwgNDsgKytpKSB7XG4gICAgICAgICAgICAvLyAxc3QuLjR0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDV0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAyOCkgPj4+IDA7XG4gICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpID4+ICA0KSA+Pj4gMDtcbiAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyAxc3QuLjN0aFxuICAgICAgICAgICAgYml0cy5sbyA9IChiaXRzLmxvIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vIDR0aFxuICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjcpIDw8IGkgKiA3KSA+Pj4gMDtcbiAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChoaSlcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgNTsgKytpKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA+PSB0aGlzLmxlbilcbiAgICAgICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcyk7XG4gICAgICAgICAgICAvLyA2dGguLjEwdGhcbiAgICAgICAgICAgIGJpdHMuaGkgPSAoYml0cy5oaSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IGkgKiA3ICsgMykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB0aHJvdyBFcnJvcihcImludmFsaWQgdmFyaW50IGVuY29kaW5nXCIpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3VpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZS5cbiAqIEBuYW1lIFJlYWRlciNzaW50NjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgdmFyaW50IGFzIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYm9vbCA9IGZ1bmN0aW9uIHJlYWRfYm9vbCgpIHtcbiAgICByZXR1cm4gdGhpcy51aW50MzIoKSAhPT0gMDtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDMyX2VuZChidWYsIGVuZCkgeyAvLyBub3RlIHRoYXQgdGhpcyB1c2VzIGBlbmRgLCBub3QgYHBvc2BcbiAgICByZXR1cm4gKGJ1ZltlbmQgLSA0XVxuICAgICAgICAgIHwgYnVmW2VuZCAtIDNdIDw8IDhcbiAgICAgICAgICB8IGJ1ZltlbmQgLSAyXSA8PCAxNlxuICAgICAgICAgIHwgYnVmW2VuZCAtIDFdIDw8IDI0KSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX2ZpeGVkMzIoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHJldHVybiByZWFkRml4ZWQzMl9lbmQodGhpcy5idWYsIHRoaXMucG9zICs9IDQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBmaXhlZCAzMiBiaXRzIGFzIGEgc2lnbmVkIDMyIGJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNmaXhlZDMyID0gZnVuY3Rpb24gcmVhZF9zZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkgfCAwO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8taW52YWxpZC10aGlzICovXG5cbmZ1bmN0aW9uIHJlYWRGaXhlZDY0KC8qIHRoaXM6IFJlYWRlciAqLykge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgOCk7XG5cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCksIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCkpO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLWludmFsaWQtdGhpcyAqL1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgemlnLXphZyBlbmNvZGVkIGZpeGVkIDY0IGJpdHMuXG4gKiBAbmFtZSBSZWFkZXIjc2ZpeGVkNjRcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0xvbmd9IFZhbHVlIHJlYWRcbiAqL1xuXG4vKipcbiAqIFJlYWRzIGEgZmxvYXQgKDMyIGJpdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHJlYWRfZmxvYXQoKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA0ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA0KTtcblxuICAgIHZhciB2YWx1ZSA9IHV0aWwuZmxvYXQucmVhZEZsb2F0TEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA0O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBkb3VibGUgKDY0IGJpdCBmbG9hdCkgYXMgYSBudW1iZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiByZWFkX2RvdWJsZSgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDggPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRG91YmxlTEUodGhpcy5idWYsIHRoaXMucG9zKTtcbiAgICB0aGlzLnBvcyArPSA4O1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiByZWFkX2J5dGVzKCkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLnVpbnQzMigpLFxuICAgICAgICBzdGFydCAgPSB0aGlzLnBvcyxcbiAgICAgICAgZW5kICAgID0gdGhpcy5wb3MgKyBsZW5ndGg7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZW5kID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuXG4gICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYnVmKSkgLy8gcGxhaW4gYXJyYXlcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiBzdGFydCA9PT0gZW5kIC8vIGZpeCBmb3IgSUUgMTAvV2luOCBhbmQgb3RoZXJzJyBzdWJhcnJheSByZXR1cm5pbmcgYXJyYXkgb2Ygc2l6ZSAxXG4gICAgICAgID8gbmV3IHRoaXMuYnVmLmNvbnN0cnVjdG9yKDApXG4gICAgICAgIDogdGhpcy5fc2xpY2UuY2FsbCh0aGlzLmJ1Ziwgc3RhcnQsIGVuZCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc3RyaW5nIHByZWNlZWRlZCBieSBpdHMgYnl0ZSBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmcoKSB7XG4gICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcygpO1xuICAgIHJldHVybiB1dGY4LnJlYWQoYnl0ZXMsIDAsIGJ5dGVzLmxlbmd0aCk7XG59O1xuXG4vKipcbiAqIFNraXBzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGJ5dGVzIGlmIHNwZWNpZmllZCwgb3RoZXJ3aXNlIHNraXBzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIExlbmd0aCBpZiBrbm93biwgb3RoZXJ3aXNlIGEgdmFyaW50IGlzIGFzc3VtZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiBza2lwKGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5wb3MgKyBsZW5ndGggPiB0aGlzLmxlbilcbiAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCBsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyOCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgd2lyZSB0eXBlLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpcmVUeXBlIFdpcmUgdHlwZSByZWNlaXZlZFxuICogQHJldHVybnMge1JlYWRlcn0gYHRoaXNgXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2tpcFR5cGUgPSBmdW5jdGlvbih3aXJlVHlwZSkge1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhpcy5za2lwKDgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuc2tpcCh0aGlzLnVpbnQzMigpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB3aGlsZSAoKHdpcmVUeXBlID0gdGhpcy51aW50MzIoKSAmIDcpICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwVHlwZSh3aXJlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy5za2lwKDQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSArIFwiIGF0IG9mZnNldCBcIiArIHRoaXMucG9zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlclJlYWRlcl8pIHtcbiAgICBCdWZmZXJSZWFkZXIgPSBCdWZmZXJSZWFkZXJfO1xuICAgIFJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSgpO1xuXG4gICAgdmFyIGZuID0gdXRpbC5Mb25nID8gXCJ0b0xvbmdcIiA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFwidG9OdW1iZXJcIjtcbiAgICB1dGlsLm1lcmdlKFJlYWRlci5wcm90b3R5cGUsIHtcblxuICAgICAgICBpbnQ2NDogZnVuY3Rpb24gcmVhZF9pbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdWludDY0OiBmdW5jdGlvbiByZWFkX3VpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzaW50NjQ6IGZ1bmN0aW9uIHJlYWRfc2ludDY0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRMb25nVmFyaW50LmNhbGwodGhpcykuenpEZWNvZGUoKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXSh0cnVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZml4ZWQ2NDogZnVuY3Rpb24gcmVhZF9zZml4ZWQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkRml4ZWQ2NC5jYWxsKHRoaXMpW2ZuXShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJSZWFkZXI7XG5cbi8vIGV4dGVuZHMgUmVhZGVyXG52YXIgUmVhZGVyID0gcmVxdWlyZShcIi4vcmVhZGVyXCIpO1xuKEJ1ZmZlclJlYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlYWRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlclJlYWRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgcmVhZGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgUmVhZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICovXG5mdW5jdGlvbiBCdWZmZXJSZWFkZXIoYnVmZmVyKSB7XG4gICAgUmVhZGVyLmNhbGwodGhpcywgYnVmZmVyKTtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyLlxuICAgICAqIEBuYW1lIEJ1ZmZlclJlYWRlciNidWZcbiAgICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgICAqL1xufVxuXG5CdWZmZXJSZWFkZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1dGlsLkJ1ZmZlcilcbiAgICAgICAgQnVmZmVyUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkJ1ZmZlci5wcm90b3R5cGUuc2xpY2U7XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlclJlYWRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gcmVhZF9zdHJpbmdfYnVmZmVyKCkge1xuICAgIHZhciBsZW4gPSB0aGlzLnVpbnQzMigpOyAvLyBtb2RpZmllcyBwb3NcbiAgICByZXR1cm4gdGhpcy5idWYudXRmOFNsaWNlXG4gICAgICAgID8gdGhpcy5idWYudXRmOFNsaWNlKHRoaXMucG9zLCB0aGlzLnBvcyA9IE1hdGgubWluKHRoaXMucG9zICsgbGVuLCB0aGlzLmxlbikpXG4gICAgICAgIDogdGhpcy5idWYudG9TdHJpbmcoXCJ1dGYtOFwiLCB0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKTtcbn07XG5cbi8qKlxuICogUmVhZHMgYSBzZXF1ZW5jZSBvZiBieXRlcyBwcmVjZWVkZWQgYnkgaXRzIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBuYW1lIEJ1ZmZlclJlYWRlciNieXRlc1xuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBWYWx1ZSByZWFkXG4gKi9cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLyoqXG4gKiBOYW1lZCByb290cy5cbiAqIFRoaXMgaXMgd2hlcmUgcGJqcyBzdG9yZXMgZ2VuZXJhdGVkIHN0cnVjdHVyZXMgKHRoZSBvcHRpb24gYC1yLCAtLXJvb3RgIHNwZWNpZmllcyBhIG5hbWUpLlxuICogQ2FuIGFsc28gYmUgdXNlZCBtYW51YWxseSB0byBtYWtlIHJvb3RzIGF2YWlsYWJsZSBhY2Nyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogU3RyZWFtaW5nIFJQQyBoZWxwZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgcnBjID0gZXhwb3J0cztcblxuLyoqXG4gKiBSUEMgaW1wbGVtZW50YXRpb24gcGFzc2VkIHRvIHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0gcGVyZm9ybWluZyBhIHNlcnZpY2UgcmVxdWVzdCBvbiBuZXR3b3JrIGxldmVsLCBpLmUuIGJ5IHV0aWxpemluZyBodHRwIHJlcXVlc3RzIG9yIHdlYnNvY2tldHMuXG4gKiBAdHlwZWRlZiBSUENJbXBsXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge01ldGhvZHxycGMuU2VydmljZU1ldGhvZDxNZXNzYWdlPHt9PixNZXNzYWdlPHt9Pj59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZCBiZWluZyBjYWxsZWRcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gcmVxdWVzdERhdGEgUmVxdWVzdCBkYXRhXG4gKiBAcGFyYW0ge1JQQ0ltcGxDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAZXhhbXBsZVxuICogZnVuY3Rpb24gcnBjSW1wbChtZXRob2QsIHJlcXVlc3REYXRhLCBjYWxsYmFjaykge1xuICogICAgIGlmIChwcm90b2J1Zi51dGlsLmxjRmlyc3QobWV0aG9kLm5hbWUpICE9PSBcIm15TWV0aG9kXCIpIC8vIGNvbXBhdGlibGUgd2l0aCBzdGF0aWMgY29kZVxuICogICAgICAgICB0aHJvdyBFcnJvcihcIm5vIHN1Y2ggbWV0aG9kXCIpO1xuICogICAgIGFzeW5jaHJvbm91c2x5T2J0YWluQVJlc3BvbnNlKHJlcXVlc3REYXRhLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlRGF0YSkge1xuICogICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlRGF0YSk7XG4gKiAgICAgfSk7XG4gKiB9XG4gKi9cblxuLyoqXG4gKiBOb2RlLXN0eWxlIGNhbGxiYWNrIGFzIHVzZWQgYnkge0BsaW5rIFJQQ0ltcGx9LlxuICogQHR5cGVkZWYgUlBDSW1wbENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7VWludDhBcnJheXxudWxsfSBbcmVzcG9uc2VdIFJlc3BvbnNlIGRhdGEgb3IgYG51bGxgIHRvIHNpZ25hbCBlbmQgb2Ygc3RyZWFtLCBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhbiBlcnJvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG5ycGMuU2VydmljZSA9IHJlcXVpcmUoXCIuL3JwYy9zZXJ2aWNlXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gV3JpdGVyO1xuXG52YXIgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG52YXIgQnVmZmVyV3JpdGVyOyAvLyBjeWNsaWNcblxudmFyIExvbmdCaXRzICA9IHV0aWwuTG9uZ0JpdHMsXG4gICAgYmFzZTY0ICAgID0gdXRpbC5iYXNlNjQsXG4gICAgdXRmOCAgICAgID0gdXRpbC51dGY4O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHdyaXRlciBvcGVyYXRpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgVWludDhBcnJheSwgbnVtYmVyKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHsqfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gT3AoZm4sIGxlbiwgdmFsKSB7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBjYWxsLlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihVaW50OEFycmF5LCBudW1iZXIsICopfVxuICAgICAqL1xuICAgIHRoaXMuZm4gPSBmbjtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGJ5dGUgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byB3cml0ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbCA9IHZhbDsgLy8gdHlwZSB2YXJpZXNcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5LWZ1bmN0aW9uXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgc3RhdGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIENvcGllZCB3cml0ZXIgc3RhdGUuXG4gKiBAbWVtYmVyb2YgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7V3JpdGVyfSB3cml0ZXIgV3JpdGVyIHRvIGNvcHkgc3RhdGUgZnJvbVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBTdGF0ZSh3cml0ZXIpIHtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaGVhZC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IHdyaXRlci5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCB0YWlsLlxuICAgICAqIEB0eXBlIHtXcml0ZXIuT3B9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gd3JpdGVyLnRhaWw7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGJ1ZmZlciBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IHdyaXRlci5sZW47XG5cbiAgICAvKipcbiAgICAgKiBOZXh0IHN0YXRlLlxuICAgICAqIEB0eXBlIHtTdGF0ZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMubmV4dCA9IHdyaXRlci5zdGF0ZXM7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBgVWludDhBcnJheWAgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBXcml0ZXIoKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gMDtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgaGVhZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMuaGVhZCA9IG5ldyBPcChub29wLCAwLCAwKTtcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdGlvbnMgdGFpbFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy50YWlsID0gdGhpcy5oZWFkO1xuXG4gICAgLyoqXG4gICAgICogTGlua2VkIGZvcmtlZCBzdGF0ZXMuXG4gICAgICogQHR5cGUge09iamVjdHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdGVzID0gbnVsbDtcblxuICAgIC8vIFdoZW4gYSB2YWx1ZSBpcyB3cml0dGVuLCB0aGUgd3JpdGVyIGNhbGN1bGF0ZXMgaXRzIGJ5dGUgbGVuZ3RoIGFuZCBwdXRzIGl0IGludG8gYSBsaW5rZWRcbiAgICAvLyBsaXN0IG9mIG9wZXJhdGlvbnMgdG8gcGVyZm9ybSB3aGVuIGZpbmlzaCgpIGlzIGNhbGxlZC4gVGhpcyBib3RoIGFsbG93cyB1cyB0byBhbGxvY2F0ZVxuICAgIC8vIGJ1ZmZlcnMgb2YgdGhlIGV4YWN0IHJlcXVpcmVkIHNpemUgYW5kIHJlZHVjZXMgdGhlIGFtb3VudCBvZiB3b3JrIHdlIGhhdmUgdG8gZG8gY29tcGFyZWRcbiAgICAvLyB0byBmaXJzdCBjYWxjdWxhdGluZyBvdmVyIG9iamVjdHMgYW5kIHRoZW4gZW5jb2Rpbmcgb3ZlciBvYmplY3RzLiBJbiBvdXIgY2FzZSwgdGhlIGVuY29kaW5nXG4gICAgLy8gcGFydCBpcyBqdXN0IGEgbGlua2VkIGxpc3Qgd2FsayBjYWxsaW5nIG9wZXJhdGlvbnMgd2l0aCBhbHJlYWR5IHByZXBhcmVkIHZhbHVlcy5cbn1cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gdXRpbC5CdWZmZXJcbiAgICAgICAgPyBmdW5jdGlvbiBjcmVhdGVfYnVmZmVyX3NldHVwKCkge1xuICAgICAgICAgICAgcmV0dXJuIChXcml0ZXIuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcldyaXRlcigpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIGNyZWF0ZV9hcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV3JpdGVyKCk7XG4gICAgICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgd3JpdGVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyV3JpdGVyfFdyaXRlcn0gQSB7QGxpbmsgQnVmZmVyV3JpdGVyfSB3aGVuIEJ1ZmZlcnMgYXJlIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGEge0BsaW5rIFdyaXRlcn1cbiAqL1xuV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuXG4vKipcbiAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBCdWZmZXIgc2l6ZVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IEJ1ZmZlclxuICovXG5Xcml0ZXIuYWxsb2MgPSBmdW5jdGlvbiBhbGxvYyhzaXplKSB7XG4gICAgcmV0dXJuIG5ldyB1dGlsLkFycmF5KHNpemUpO1xufTtcblxuLy8gVXNlIFVpbnQ4QXJyYXkgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXIsIGp1c3QgbGlrZSBub2RlIGRvZXMgd2l0aCBidWZmZXJzXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHV0aWwuQXJyYXkgIT09IEFycmF5KVxuICAgIFdyaXRlci5hbGxvYyA9IHV0aWwucG9vbChXcml0ZXIuYWxsb2MsIHV0aWwuQXJyYXkucHJvdG90eXBlLnN1YmFycmF5KTtcblxuLyoqXG4gKiBQdXNoZXMgYSBuZXcgb3BlcmF0aW9uIHRvIHRoZSBxdWV1ZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX0gZm4gRnVuY3Rpb24gdG8gY2FsbFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAcHJpdmF0ZVxuICovXG5Xcml0ZXIucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24gcHVzaChmbiwgbGVuLCB2YWwpIHtcbiAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBPcChmbiwgbGVuLCB2YWwpO1xuICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQnl0ZSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3Bvc10gPSB2YWwgJiAyNTU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50MzIodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwgPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbCAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsID4+Pj0gNztcbiAgICB9XG4gICAgYnVmW3Bvc10gPSB2YWw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbiBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgU2NoZWR1bGVkIHZhcmludCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGV4dGVuZHMgT3BcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBWYWx1ZSBieXRlIGxlbmd0aFxuICogQHBhcmFtIHtudW1iZXJ9IHZhbCBWYWx1ZSB0byB3cml0ZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBWYXJpbnRPcChsZW4sIHZhbCkge1xuICAgIHRoaXMubGVuID0gbGVuO1xuICAgIHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnZhbCA9IHZhbDtcbn1cblxuVmFyaW50T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShPcC5wcm90b3R5cGUpO1xuVmFyaW50T3AucHJvdG90eXBlLmZuID0gd3JpdGVWYXJpbnQzMjtcblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50MzIgPSBmdW5jdGlvbiB3cml0ZV91aW50MzIodmFsdWUpIHtcbiAgICAvLyBoZXJlLCB0aGUgY2FsbCB0byB0aGlzLnB1c2ggaGFzIGJlZW4gaW5saW5lZCBhbmQgYSB2YXJpbnQgc3BlY2lmaWMgT3Agc3ViY2xhc3MgaXMgdXNlZC5cbiAgICAvLyB1aW50MzIgaXMgYnkgZmFyIHRoZSBtb3N0IGZyZXF1ZW50bHkgdXNlZCBvcGVyYXRpb24gYW5kIGJlbmVmaXRzIHNpZ25pZmljYW50bHkgZnJvbSB0aGlzLlxuICAgIHRoaXMubGVuICs9ICh0aGlzLnRhaWwgPSB0aGlzLnRhaWwubmV4dCA9IG5ldyBWYXJpbnRPcChcbiAgICAgICAgKHZhbHVlID0gdmFsdWUgPj4+IDApXG4gICAgICAgICAgICAgICAgPCAxMjggICAgICAgPyAxXG4gICAgICAgIDogdmFsdWUgPCAxNjM4NCAgICAgPyAyXG4gICAgICAgIDogdmFsdWUgPCAyMDk3MTUyICAgPyAzXG4gICAgICAgIDogdmFsdWUgPCAyNjg0MzU0NTYgPyA0XG4gICAgICAgIDogICAgICAgICAgICAgICAgICAgICA1LFxuICAgIHZhbHVlKSkubGVuO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmludDMyID0gZnVuY3Rpb24gd3JpdGVfaW50MzIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPCAwXG4gICAgICAgID8gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCAxMCwgTG9uZ0JpdHMuZnJvbU51bWJlcih2YWx1ZSkpIC8vIDEwIGJ5dGVzIHBlciBzcGVjXG4gICAgICAgIDogdGhpcy51aW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSAzMiBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ludDMyID0gZnVuY3Rpb24gd3JpdGVfc2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudWludDMyKCh2YWx1ZSA8PCAxIF4gdmFsdWUgPj4gMzEpID4+PiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVmFyaW50NjQodmFsLCBidWYsIHBvcykge1xuICAgIHdoaWxlICh2YWwuaGkpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gKHZhbC5sbyA+Pj4gNyB8IHZhbC5oaSA8PCAyNSkgPj4+IDA7XG4gICAgICAgIHZhbC5oaSA+Pj49IDc7XG4gICAgfVxuICAgIHdoaWxlICh2YWwubG8gPiAxMjcpIHtcbiAgICAgICAgYnVmW3BvcysrXSA9IHZhbC5sbyAmIDEyNyB8IDEyODtcbiAgICAgICAgdmFsLmxvID0gdmFsLmxvID4+PiA3O1xuICAgIH1cbiAgICBidWZbcG9zKytdID0gdmFsLmxvO1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS51aW50NjQgPSBmdW5jdGlvbiB3cml0ZV91aW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlVmFyaW50NjQsIGJpdHMubGVuZ3RoKCksIGJpdHMpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQ2NCA9IFdyaXRlci5wcm90b3R5cGUudWludDY0O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgYSB2YXJpbnQsIHppZy16YWcgZW5jb2RlZC5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQ2NCA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQ2NCh2YWx1ZSkge1xuICAgIHZhciBiaXRzID0gTG9uZ0JpdHMuZnJvbSh2YWx1ZSkuenpFbmNvZGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgYm9vbGlzaCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJvb2wgPSBmdW5jdGlvbiB3cml0ZV9ib29sKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCB2YWx1ZSA/IDEgOiAwKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRml4ZWQzMih2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgYnVmW3BvcyAgICBdID0gIHZhbCAgICAgICAgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAxXSA9ICB2YWwgPj4+IDggICAmIDI1NTtcbiAgICBidWZbcG9zICsgMl0gPSAgdmFsID4+PiAxNiAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDNdID0gIHZhbCA+Pj4gMjQ7XG59XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyID0gZnVuY3Rpb24gd3JpdGVfZml4ZWQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgdmFsdWUgPj4+IDApO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgMzIgYml0IHZhbHVlIGFzIGZpeGVkIDMyIGJpdHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkMzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQ2NCA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkNjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpO1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5sbykuX3B1c2god3JpdGVGaXhlZDMyLCA0LCBiaXRzLmhpKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBmaXhlZCA2NCBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zZml4ZWQ2NCA9IFdyaXRlci5wcm90b3R5cGUuZml4ZWQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBmbG9hdCAoMzIgYml0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5mbG9hdCA9IGZ1bmN0aW9uIHdyaXRlX2Zsb2F0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2godXRpbC5mbG9hdC53cml0ZUZsb2F0TEUsIDQsIHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgZG91YmxlICg2NCBiaXQgZmxvYXQpLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHdyaXRlX2RvdWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVEb3VibGVMRSwgOCwgdmFsdWUpO1xufTtcblxudmFyIHdyaXRlQnl0ZXMgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zZXRcbiAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgYnVmLnNldCh2YWwsIHBvcyk7IC8vIGFsc28gd29ya3MgZm9yIHBsYWluIGFycmF5IHZhbHVlc1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIDogZnVuY3Rpb24gd3JpdGVCeXRlc19mb3IodmFsLCBidWYsIHBvcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGJ1Zltwb3MgKyBpXSA9IHZhbFtpXTtcbiAgICB9O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNlcXVlbmNlIG9mIGJ5dGVzLlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gdmFsdWUgQnVmZmVyIG9yIGJhc2U2NCBlbmNvZGVkIHN0cmluZyB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlcyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgaWYgKCFsZW4pXG4gICAgICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIHZhciBidWYgPSBXcml0ZXIuYWxsb2MobGVuID0gYmFzZTY0Lmxlbmd0aCh2YWx1ZSkpO1xuICAgICAgICBiYXNlNjQuZGVjb2RlKHZhbHVlLCBidWYsIDApO1xuICAgICAgICB2YWx1ZSA9IGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDMyKGxlbikuX3B1c2god3JpdGVCeXRlcywgbGVuLCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc3RyaW5nID0gZnVuY3Rpb24gd3JpdGVfc3RyaW5nKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0ZjgubGVuZ3RoKHZhbHVlKTtcbiAgICByZXR1cm4gbGVuXG4gICAgICAgID8gdGhpcy51aW50MzIobGVuKS5fcHVzaCh1dGY4LndyaXRlLCBsZW4sIHZhbHVlKVxuICAgICAgICA6IHRoaXMuX3B1c2god3JpdGVCeXRlLCAxLCAwKTtcbn07XG5cbi8qKlxuICogRm9ya3MgdGhpcyB3cml0ZXIncyBzdGF0ZSBieSBwdXNoaW5nIGl0IHRvIGEgc3RhY2suXG4gKiBDYWxsaW5nIHtAbGluayBXcml0ZXIjcmVzZXR8cmVzZXR9IG9yIHtAbGluayBXcml0ZXIjbGRlbGltfGxkZWxpbX0gcmVzZXRzIHRoZSB3cml0ZXIgdG8gdGhlIHByZXZpb3VzIHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZm9yayA9IGZ1bmN0aW9uIGZvcmsoKSB7XG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgU3RhdGUodGhpcyk7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgIHRoaXMubGVuID0gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoaXMgaW5zdGFuY2UgdG8gdGhlIGxhc3Qgc3RhdGUuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnN0YXRlcykge1xuICAgICAgICB0aGlzLmhlYWQgICA9IHRoaXMuc3RhdGVzLmhlYWQ7XG4gICAgICAgIHRoaXMudGFpbCAgID0gdGhpcy5zdGF0ZXMudGFpbDtcbiAgICAgICAgdGhpcy5sZW4gICAgPSB0aGlzLnN0YXRlcy5sZW47XG4gICAgICAgIHRoaXMuc3RhdGVzID0gdGhpcy5zdGF0ZXMubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG4gICAgICAgIHRoaXMubGVuICA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNldHMgdG8gdGhlIGxhc3Qgc3RhdGUgYW5kIGFwcGVuZHMgdGhlIGZvcmsgc3RhdGUncyBjdXJyZW50IHdyaXRlIGxlbmd0aCBhcyBhIHZhcmludCBmb2xsb3dlZCBieSBpdHMgb3BlcmF0aW9ucy5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmxkZWxpbSA9IGZ1bmN0aW9uIGxkZWxpbSgpIHtcbiAgICB2YXIgaGVhZCA9IHRoaXMuaGVhZCxcbiAgICAgICAgdGFpbCA9IHRoaXMudGFpbCxcbiAgICAgICAgbGVuICA9IHRoaXMubGVuO1xuICAgIHRoaXMucmVzZXQoKS51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gaGVhZC5uZXh0OyAvLyBza2lwIG5vb3BcbiAgICAgICAgdGhpcy50YWlsID0gdGFpbDtcbiAgICAgICAgdGhpcy5sZW4gKz0gbGVuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQubmV4dCwgLy8gc2tpcCBub29wXG4gICAgICAgIGJ1ZiAgPSB0aGlzLmNvbnN0cnVjdG9yLmFsbG9jKHRoaXMubGVuKSxcbiAgICAgICAgcG9zICA9IDA7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgICAgaGVhZC5mbihoZWFkLnZhbCwgYnVmLCBwb3MpO1xuICAgICAgICBwb3MgKz0gaGVhZC5sZW47XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgfVxuICAgIC8vIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5cbldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24oQnVmZmVyV3JpdGVyXykge1xuICAgIEJ1ZmZlcldyaXRlciA9IEJ1ZmZlcldyaXRlcl87XG4gICAgV3JpdGVyLmNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIEJ1ZmZlcldyaXRlci5fY29uZmlndXJlKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIiwiXHJcbmltcG9ydCB7VW5pdFRlc3R9IGZyb20gJy4vdW5pdHRlc3QvVW5pdFRlc3QnO1xyXG5pbXBvcnQgeyBKc01hbmFnZXIgLEdhbWVMYXVuY2ggfSBmcm9tICdjc2hhcnAnO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gJy4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lRGVmJztcclxuaW1wb3J0IHsgUyB9IGZyb20gJy4vZ2xvYmFsL0dhbWVDb25maWcnO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyJztcclxuaW1wb3J0IHsgY29tbW9uVUkgfSBmcm9tICcuL2RhdGEvdWkvY29tbW9uJztcclxuXHJcblxyXG5cclxuY2xhc3MgR2FtZU1haW57XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgSnNNYW5hZ2VyLkluc3RhbmNlLkpzT25BcHBsaWNhdGlvblF1aXQgPSAoKSA9PiB0aGlzLm9uQXBwbGljYXRpb25RdWl0KCk7XHJcbiAgICAgICAgSnNNYW5hZ2VyLkluc3RhbmNlLkpzT25EaXNwb3NlID0gKCkgPT4gdGhpcy5vbkRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgc3RhcnQoKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKFwiR2FtZSBzdGFydCBpbiBKUy4uLi5cIik7XHJcblxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgUy5TdG9yeU1hbmFnZXIuaW5pdGlhbGl6ZSgpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8v6aKE5Yqg6L29ZXhjZWzmlbDmja5cclxuICAgICAgICAgICAgLy9FeGNlbE1hbmFnZXIuSW5zdGFuY2UoRXhjZWxNYW5hZ2VyKTtcclxuICAgICAgXHJcbiAgICAgICAgICAgIC8v5Yqg6L296YCa55SoRmFpcnlHVUnotYTmupBcclxuICAgICAgICAgICAgYXdhaXQgUy5SZXNNYW5hZ2VyLmxvYWRGYWlyeUdVSVBhY2thZ2UoY29tbW9uVUkuUGFja2FnZU5hbWUpO1xyXG5cclxuICAgICAgICAgICAgLy9kbyBVbml0IFRlc3RcclxuICAgICAgICAgICAgLy9Vbml0VGVzdC5kb1Rlc3QoKTtcclxuXHJcbiAgICAgICAgICAgIC8v6L+b5YWl55m75b2V5qih5Z2XXHJcbiAgICAgICAgICAgIGF3YWl0IFMuU2NlbmVNYW5hZ2VyLmxvYWRTY2VuZShTY2VuZURlZi5Mb2dpblNjZW5lKTtcclxuXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvL0pT5ZCv5Yqo5a6M5oiQ77yM6YCa55+lQyPlsYJcclxuICAgICAgICAgICAgR2FtZUxhdW5jaC5JbnN0YW5jZS5Kc0x1YW5jaEZpbmlzaCgpO1xyXG5cclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoZXgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uQXBwbGljYXRpb25RdWl0KCk6dm9pZCB7XHJcblxyXG4gICAgICAgIFMuR2FtZU9iamVjdFBvb2wuY2xlYW51cCh0cnVlKTtcclxuICAgICAgICBMb2dnZXIubG9nKFwiR2FtZSBvbkFwcGxpY2F0aW9uUXVpdCBpbiBKUy4uLi5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRGlzcG9zZSgpOnZvaWQge1xyXG4gICAgICAgIFxyXG4gICAgICAgIExvZ2dlci5sb2coXCJHYW1lIG9uRGlzcG9zZSBpbiBKUy4uLi5cIik7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxubmV3IEdhbWVNYWluKCkuc3RhcnQoKTtcclxuXHJcbiIsImltcG9ydCB7IG5pY2VfdHMgfSBmcm9tIFwiLi9nZW4vcGJcIjtcclxuZXhwb3J0IGNsYXNzIERlY29kZU1zZ3tcclxuXHRwdWJsaWMgcnBjSWQ6bnVtYmVyO1xyXG5cdHB1YmxpYyBtc2dPYmo6YW55O1xyXG59XHJcbmV4cG9ydCBjbGFzcyBPcGNvZGV7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfQzJSX0xvZ2luOm51bWJlciA9IDEwMDA7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfUjJDX0xvZ2luOm51bWJlciA9IDEwMDE7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfQzJHX0xvZ2luR2F0ZTpudW1iZXIgPSAxMDAyO1xyXG5cdHB1YmxpYyBzdGF0aWMgTVNHX0cyQ19Mb2dpbkdhdGU6bnVtYmVyID0gMTAwMztcclxuXHJcblx0cHVibGljIHN0YXRpYyBNU0dfQzJHU19UZXN0Om51bWJlciA9IDIwMDE7XHJcblx0cHVibGljIHN0YXRpYyBNU0dfR1MyQ19UZXN0Om51bWJlciA9IDIwMDI7XHJcblxyXG5cdHB1YmxpYyBzdGF0aWMgbWFwID0ge1xyXG5cdFx0MTAwMCA6IHtcImRlY29kZVwiOm5pY2VfdHMuQzJSX0xvZ2luLmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuQzJSX0xvZ2luLmVuY29kZX0sXHJcblx0XHQxMDAxIDoge1wiZGVjb2RlXCI6bmljZV90cy5SMkNfTG9naW4uZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5SMkNfTG9naW4uZW5jb2RlfSxcclxuXHRcdDEwMDIgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLkMyR19Mb2dpbkdhdGUuZGVjb2RlLFwiZW5jb2RlXCI6bmljZV90cy5DMkdfTG9naW5HYXRlLmVuY29kZX0sXHJcblx0XHQxMDAzIDoge1wiZGVjb2RlXCI6bmljZV90cy5HMkNfTG9naW5HYXRlLmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuRzJDX0xvZ2luR2F0ZS5lbmNvZGV9LFxyXG5cclxuXHRcdDIwMDEgOiB7XCJkZWNvZGVcIjpuaWNlX3RzLkMyR1NfVGVzdC5kZWNvZGUsXCJlbmNvZGVcIjpuaWNlX3RzLkMyR1NfVGVzdC5lbmNvZGV9LFxyXG5cdFx0MjAwMiA6IHtcImRlY29kZVwiOm5pY2VfdHMuR1MyQ19UZXN0LmRlY29kZSxcImVuY29kZVwiOm5pY2VfdHMuR1MyQ19UZXN0LmVuY29kZX1cclxuXHR9XHJcblx0cHVibGljIHN0YXRpYyBkZWNvZGUob3Bjb2RlOm51bWJlciwgbXNnOlVpbnQ4QXJyYXkpOkRlY29kZU1zZyB7XHJcblx0XHRsZXQgbXNnT2JqID0gdGhpcy5tYXBbb3Bjb2RlXVtcImRlY29kZVwiXShtc2cpO1xyXG5cdFx0bGV0IGRlY29kZU1zZyA9IG5ldyBEZWNvZGVNc2coKTtcclxuXHRcdGRlY29kZU1zZy5ycGNJZCA9IG1zZ09iai5ScGNJZDtcclxuXHRcdGRlY29kZU1zZy5tc2dPYmogPSBtc2dPYmo7XHJcblx0XHRyZXR1cm4gZGVjb2RlTXNnO1xyXG5cdH1cclxuXHRwdWJsaWMgc3RhdGljIGVuY29kZShvcGNvZGU6bnVtYmVyLCBtc2c6VWludDhBcnJheSl7XHJcblx0XHRsZXQgYnVmID0gdGhpcy5tYXBbb3Bjb2RlXVtcImVuY29kZVwiXShtc2cpLmZpbmlzaCgpO1xyXG5cdFx0cmV0dXJuIGJ1ZlxyXG5cdH1cclxuXHJcblxyXG5cclxufVxyXG4iLCIvKmVzbGludC1kaXNhYmxlIGJsb2NrLXNjb3BlZC12YXIsIGlkLWxlbmd0aCwgbm8tY29udHJvbC1yZWdleCwgbm8tbWFnaWMtbnVtYmVycywgbm8tcHJvdG90eXBlLWJ1aWx0aW5zLCBuby1yZWRlY2xhcmUsIG5vLXNoYWRvdywgbm8tdmFyLCBzb3J0LXZhcnMqL1xyXG5cInVzZSBzdHJpY3RcIjtcclxuXHJcbnZhciAkcHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqcy9taW5pbWFsXCIpO1xyXG5cclxuLy8gQ29tbW9uIGFsaWFzZXNcclxudmFyICRSZWFkZXIgPSAkcHJvdG9idWYuUmVhZGVyLCAkV3JpdGVyID0gJHByb3RvYnVmLldyaXRlciwgJHV0aWwgPSAkcHJvdG9idWYudXRpbDtcclxuXHJcbnZhciBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XHJcbiRwcm90b2J1Zi51dGlsLkxvbmcgPSBMb25nO1xyXG4kcHJvdG9idWYuY29uZmlndXJlKCk7XHJcblxyXG5cclxuLy8gRXhwb3J0ZWQgcm9vdCBuYW1lc3BhY2VcclxudmFyICRyb290ID0gJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSB8fCAoJHByb3RvYnVmLnJvb3RzW1wiZGVmYXVsdFwiXSA9IHt9KTtcclxuXHJcbiRyb290Lm5pY2VfdHMgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBOYW1lc3BhY2UgbmljZV90cy5cclxuICAgICAqIEBleHBvcnRzIG5pY2VfdHNcclxuICAgICAqIEBuYW1lc3BhY2VcclxuICAgICAqL1xyXG4gICAgdmFyIG5pY2VfdHMgPSB7fTtcclxuXHJcbiAgICBuaWNlX3RzLkMyUl9Mb2dpbiA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEMyUl9Mb2dpbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtBY2NvdW50XSBDMlJfTG9naW4gQWNjb3VudFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtQYXNzd29yZF0gQzJSX0xvZ2luIFBhc3N3b3JkXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgQzJSX0xvZ2luLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgQzJSX0xvZ2luLlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMlJfTG9naW5cclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyUl9Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEMyUl9Mb2dpbihwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMlJfTG9naW4gQWNjb3VudC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IEFjY291bnRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMlJfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4ucHJvdG90eXBlLkFjY291bnQgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMlJfTG9naW4gUGFzc3dvcmQuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBQYXNzd29yZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5wcm90b3R5cGUuUGFzc3dvcmQgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyUl9Mb2dpbiBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyUl9Mb2dpbj19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyUl9Mb2dpbn0gQzJSX0xvZ2luIGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJSX0xvZ2luKHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMlJfTG9naW4gbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMlJfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyUl9Mb2dpbn0gbWVzc2FnZSBDMlJfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuQWNjb3VudCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiQWNjb3VudFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMiA9Ki8xMCkuc3RyaW5nKG1lc3NhZ2UuQWNjb3VudCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBhc3N3b3JkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJQYXNzd29yZFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMiA9Ki8xOCkuc3RyaW5nKG1lc3NhZ2UuUGFzc3dvcmQpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBDMlJfTG9naW4gbWVzc2FnZSwgbGVuZ3RoIGRlbGltaXRlZC4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5DMlJfTG9naW4udmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUMyUl9Mb2dpbn0gbWVzc2FnZSBDMlJfTG9naW4gbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlci5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJSX0xvZ2lufSBDMlJfTG9naW5cclxuICAgICAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHBheWxvYWQgaXMgbm90IGEgcmVhZGVyIG9yIHZhbGlkIGJ1ZmZlclxyXG4gICAgICAgICAqIEB0aHJvd3MgeyRwcm90b2J1Zi51dGlsLlByb3RvY29sRXJyb3J9IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyUl9Mb2dpbigpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5BY2NvdW50ID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGFzc3dvcmQgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJSX0xvZ2luIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJSX0xvZ2luLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQzJSX0xvZ2luIG1lc3NhZ2UuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFjY291bnRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuQWNjb3VudCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWNjb3VudDogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBhc3N3b3JkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIlBhc3N3b3JkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLlBhc3N3b3JkKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJQYXNzd29yZDogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBDMlJfTG9naW4gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMlJfTG9naW59IEMyUl9Mb2dpblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyUl9Mb2dpbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuQzJSX0xvZ2luKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5DMlJfTG9naW4oKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5BY2NvdW50ICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkFjY291bnQgPSBTdHJpbmcob2JqZWN0LkFjY291bnQpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LlBhc3N3b3JkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLlBhc3N3b3JkID0gU3RyaW5nKG9iamVjdC5QYXNzd29yZCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEMyUl9Mb2dpbiBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5DMlJfTG9naW59IG1lc3NhZ2UgQzJSX0xvZ2luXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4udG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkFjY291bnQgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LlBhc3N3b3JkID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BY2NvdW50ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFjY291bnRcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQWNjb3VudCA9IG1lc3NhZ2UuQWNjb3VudDtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuUGFzc3dvcmQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiUGFzc3dvcmRcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuUGFzc3dvcmQgPSBtZXNzYWdlLlBhc3N3b3JkO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgQzJSX0xvZ2luIHRvIEpTT04uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyUl9Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMlJfTG9naW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEMyUl9Mb2dpbjtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgbmljZV90cy5SMkNfTG9naW4gPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBSMkNfTG9naW4uXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAaW50ZXJmYWNlIElSMkNfTG9naW5cclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxudWxsfSBbRXJyb3JdIFIyQ19Mb2dpbiBFcnJvclxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNZXNzYWdlXSBSMkNfTG9naW4gTWVzc2FnZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtBZGRyZXNzXSBSMkNfTG9naW4gQWRkcmVzc1xyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0tleV0gUjJDX0xvZ2luIEtleVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd8bnVsbH0gW0dhdGVJZF0gUjJDX0xvZ2luIEdhdGVJZFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IFIyQ19Mb2dpbi5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIFIyQ19Mb2dpbi5cclxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW49fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBSMkNfTG9naW4ocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUjJDX0xvZ2luIEVycm9yLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gRXJyb3JcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLkVycm9yID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUjJDX0xvZ2luIE1lc3NhZ2UuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBNZXNzYWdlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5NZXNzYWdlID0gXCJcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUjJDX0xvZ2luIEFkZHJlc3MuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBBZGRyZXNzXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5BZGRyZXNzID0gXCJcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUjJDX0xvZ2luIEtleS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gS2V5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5LZXkgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUjJDX0xvZ2luIEdhdGVJZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gR2F0ZUlkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnByb3RvdHlwZS5HYXRlSWQgPSAkdXRpbC5Mb25nID8gJHV0aWwuTG9uZy5mcm9tQml0cygwLDAsZmFsc2UpIDogMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBSMkNfTG9naW4gaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW49fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpbiBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFIyQ19Mb2dpbihwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgUjJDX0xvZ2luIG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuUjJDX0xvZ2luLnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklSMkNfTG9naW59IG1lc3NhZ2UgUjJDX0xvZ2luIG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcclxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkFkZHJlc3MgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkFkZHJlc3NcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLkFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5LZXkgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMiwgd2lyZVR5cGUgMCA9Ki8xNikuaW50NjQobWVzc2FnZS5LZXkpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMywgd2lyZVR5cGUgMCA9Ki8yNCkuaW50NjQobWVzc2FnZS5HYXRlSWQpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkxLCB3aXJlVHlwZSAwID0qLzcyOCkuaW50MzIobWVzc2FnZS5FcnJvcik7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDkyLCB3aXJlVHlwZSAyID0qLzczOCkuc3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIFIyQ19Mb2dpbiBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLlIyQ19Mb2dpbi52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JUjJDX0xvZ2lufSBtZXNzYWdlIFIyQ19Mb2dpbiBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIFIyQ19Mb2dpbiBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpblxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuUjJDX0xvZ2luKCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgOTE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IHJlYWRlci5pbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MjpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5BZGRyZXNzID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcmVhZGVyLmludDY0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBSMkNfTG9naW4gbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLlIyQ19Mb2dpbn0gUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4uZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBSMkNfTG9naW4gbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUjJDX0xvZ2luLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5FcnJvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IGludGVnZXIgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2U6IHN0cmluZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BZGRyZXNzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFkZHJlc3NcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuQWRkcmVzcykpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiQWRkcmVzczogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleSkgJiYgIShtZXNzYWdlLktleSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5LZXkuaGlnaCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIktleTogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZCkgJiYgIShtZXNzYWdlLkdhdGVJZCAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQubG93KSAmJiAkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5HYXRlSWQuaGlnaCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIkdhdGVJZDogaW50ZWdlcnxMb25nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBSMkNfTG9naW4gbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuUjJDX0xvZ2luXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5SMkNfTG9naW59IFIyQ19Mb2dpblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gZnJvbU9iamVjdChvYmplY3QpIHtcclxuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mICRyb290Lm5pY2VfdHMuUjJDX0xvZ2luKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5SMkNfTG9naW4oKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5FcnJvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IG9iamVjdC5FcnJvciB8IDA7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuTWVzc2FnZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gU3RyaW5nKG9iamVjdC5NZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5BZGRyZXNzICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkFkZHJlc3MgPSBTdHJpbmcob2JqZWN0LkFkZHJlc3MpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LktleSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuS2V5ID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LktleSkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IHBhcnNlSW50KG9iamVjdC5LZXksIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gb2JqZWN0LktleTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuS2V5ID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5LZXkubG93ID4+PiAwLCBvYmplY3QuS2V5LmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuR2F0ZUlkICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZylcclxuICAgICAgICAgICAgICAgICAgICAobWVzc2FnZS5HYXRlSWQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuR2F0ZUlkKSkudW5zaWduZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gcGFyc2VJbnQob2JqZWN0LkdhdGVJZCwgMTApO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBvYmplY3QuR2F0ZUlkO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5HYXRlSWQgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LkdhdGVJZC5sb3cgPj4+IDAsIG9iamVjdC5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgUjJDX0xvZ2luIG1lc3NhZ2UuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5SMkNfTG9naW5cclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLlIyQ19Mb2dpbn0gbWVzc2FnZSBSMkNfTG9naW5cclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5JQ29udmVyc2lvbk9wdGlvbnN9IFtvcHRpb25zXSBDb252ZXJzaW9uIG9wdGlvbnNcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFIyQ19Mb2dpbi50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQWRkcmVzcyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gMDtcclxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5BZGRyZXNzICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkFkZHJlc3NcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuQWRkcmVzcyA9IG1lc3NhZ2UuQWRkcmVzcztcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5LZXkgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLktleSkgOiBtZXNzYWdlLktleTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuS2V5ID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLktleSkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBuZXcgJHV0aWwuTG9uZ0JpdHMobWVzc2FnZS5LZXkubG93ID4+PiAwLCBtZXNzYWdlLktleS5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5LZXk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkdhdGVJZCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJHYXRlSWRcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuR2F0ZUlkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5HYXRlSWQpIDogbWVzc2FnZS5HYXRlSWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5HYXRlSWQpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuR2F0ZUlkLmxvdyA+Pj4gMCwgbWVzc2FnZS5HYXRlSWQuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuR2F0ZUlkO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5FcnJvciAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5FcnJvciA9IG1lc3NhZ2UuRXJyb3I7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLk1lc3NhZ2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIG9iamVjdC5NZXNzYWdlID0gbWVzc2FnZS5NZXNzYWdlO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnZlcnRzIHRoaXMgUjJDX0xvZ2luIHRvIEpTT04uXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvSlNPTlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLlIyQ19Mb2dpblxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBSMkNfTG9naW4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudG9PYmplY3QodGhpcywgJHByb3RvYnVmLnV0aWwudG9KU09OT3B0aW9ucyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFIyQ19Mb2dpbjtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgbmljZV90cy5DMkdfTG9naW5HYXRlID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgQzJHX0xvZ2luR2F0ZS5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtLZXldIEMyR19Mb2dpbkdhdGUgS2V5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ3xudWxsfSBbR2F0ZUlkXSBDMkdfTG9naW5HYXRlIEdhdGVJZFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEMyR19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBDMkdfTG9naW5HYXRlLlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElDMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQzJHX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdfTG9naW5HYXRlIEtleS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gS2V5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLktleSA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDMkdfTG9naW5HYXRlIEdhdGVJZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ8TG9uZ30gR2F0ZUlkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUucHJvdG90eXBlLkdhdGVJZCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEMyR19Mb2dpbkdhdGUgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHX0xvZ2luR2F0ZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IEMyR19Mb2dpbkdhdGUgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQzJHX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyR19Mb2dpbkdhdGUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlfSBtZXNzYWdlIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcclxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiS2V5XCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDY0KG1lc3NhZ2UuS2V5KTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJHYXRlSWRcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDIsIHdpcmVUeXBlIDAgPSovMTYpLmludDY0KG1lc3NhZ2UuR2F0ZUlkKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyR19Mb2dpbkdhdGUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdfTG9naW5HYXRlfSBtZXNzYWdlIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHX0xvZ2luR2F0ZSBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBNZXNzYWdlIGxlbmd0aCBpZiBrbm93biBiZWZvcmVoYW5kXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocmVhZGVyLCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSAkUmVhZGVyLmNyZWF0ZShyZWFkZXIpO1xyXG4gICAgICAgICAgICB2YXIgZW5kID0gbGVuZ3RoID09PSB1bmRlZmluZWQgPyByZWFkZXIubGVuIDogcmVhZGVyLnBvcyArIGxlbmd0aCwgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyR19Mb2dpbkdhdGUoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuS2V5ID0gcmVhZGVyLmludDY0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5HYXRlSWQgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBDMkdfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuS2V5ICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIktleVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuS2V5KSAmJiAhKG1lc3NhZ2UuS2V5ICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLktleS5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiS2V5OiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuR2F0ZUlkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkdhdGVJZFwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuR2F0ZUlkKSAmJiAhKG1lc3NhZ2UuR2F0ZUlkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5sb3cpICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkdhdGVJZC5oaWdoKSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiR2F0ZUlkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHX0xvZ2luR2F0ZX0gQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR19Mb2dpbkdhdGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkMyR19Mb2dpbkdhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkMyR19Mb2dpbkdhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5LZXkgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKVxyXG4gICAgICAgICAgICAgICAgICAgIChtZXNzYWdlLktleSA9ICR1dGlsLkxvbmcuZnJvbVZhbHVlKG9iamVjdC5LZXkpKS51bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5LZXkgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5LZXkgPSBwYXJzZUludChvYmplY3QuS2V5LCAxMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IG9iamVjdC5LZXk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LktleSA9PT0gXCJvYmplY3RcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLktleSA9IG5ldyAkdXRpbC5Mb25nQml0cyhvYmplY3QuS2V5LmxvdyA+Pj4gMCwgb2JqZWN0LktleS5oaWdoID4+PiAwKS50b051bWJlcigpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkdhdGVJZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuR2F0ZUlkID0gJHV0aWwuTG9uZy5mcm9tVmFsdWUob2JqZWN0LkdhdGVJZCkpLnVuc2lnbmVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LkdhdGVJZCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkdhdGVJZCA9IHBhcnNlSW50KG9iamVjdC5HYXRlSWQsIDEwKTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gb2JqZWN0LkdhdGVJZDtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmplY3QuR2F0ZUlkID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuR2F0ZUlkID0gbmV3ICR1dGlsLkxvbmdCaXRzKG9iamVjdC5HYXRlSWQubG93ID4+PiAwLCBvYmplY3QuR2F0ZUlkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEMyR19Mb2dpbkdhdGUgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkMyR19Mb2dpbkdhdGV9IG1lc3NhZ2UgQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHX0xvZ2luR2F0ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBsb25nLnRvU3RyaW5nKCkgOiBvcHRpb25zLmxvbmdzID09PSBOdW1iZXIgPyBsb25nLnRvTnVtYmVyKCkgOiBsb25nO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFwiMFwiIDogMDtcclxuICAgICAgICAgICAgICAgIGlmICgkdXRpbC5Mb25nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvbmcgPSBuZXcgJHV0aWwuTG9uZygwLCAwLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LkdhdGVJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gXCIwXCIgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLktleSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJLZXlcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuS2V5ID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5LZXkgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBTdHJpbmcobWVzc2FnZS5LZXkpIDogbWVzc2FnZS5LZXk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LktleSA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/ICR1dGlsLkxvbmcucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZS5LZXkpIDogb3B0aW9ucy5sb25ncyA9PT0gTnVtYmVyID8gbmV3ICR1dGlsLkxvbmdCaXRzKG1lc3NhZ2UuS2V5LmxvdyA+Pj4gMCwgbWVzc2FnZS5LZXkuaGlnaCA+Pj4gMCkudG9OdW1iZXIoKSA6IG1lc3NhZ2UuS2V5O1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5HYXRlSWQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiR2F0ZUlkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLkdhdGVJZCA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuR2F0ZUlkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gU3RyaW5nKG1lc3NhZ2UuR2F0ZUlkKSA6IG1lc3NhZ2UuR2F0ZUlkO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5HYXRlSWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyAkdXRpbC5Mb25nLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1lc3NhZ2UuR2F0ZUlkKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLkdhdGVJZC5sb3cgPj4+IDAsIG1lc3NhZ2UuR2F0ZUlkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCkgOiBtZXNzYWdlLkdhdGVJZDtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEMyR19Mb2dpbkdhdGUgdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdfTG9naW5HYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBDMkdfTG9naW5HYXRlO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLkcyQ19Mb2dpbkdhdGUgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgb2YgYSBHMkNfTG9naW5HYXRlLlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFtFcnJvcl0gRzJDX0xvZ2luR2F0ZSBFcnJvclxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfG51bGx9IFtNZXNzYWdlXSBHMkNfTG9naW5HYXRlIE1lc3NhZ2VcclxuICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfG51bGx9IFtQbGF5ZXJJZF0gRzJDX0xvZ2luR2F0ZSBQbGF5ZXJJZFxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEcyQ19Mb2dpbkdhdGUuXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHNcclxuICAgICAgICAgKiBAY2xhc3NkZXNjIFJlcHJlc2VudHMgYSBHMkNfTG9naW5HYXRlLlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlPX0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gRzJDX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHMkNfTG9naW5HYXRlIEVycm9yLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gRXJyb3JcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5wcm90b3R5cGUuRXJyb3IgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHMkNfTG9naW5HYXRlIE1lc3NhZ2UuXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBNZXNzYWdlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHMkNfTG9naW5HYXRlIFBsYXllcklkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcnxMb25nfSBQbGF5ZXJJZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS5QbGF5ZXJJZCA9ICR1dGlsLkxvbmcgPyAkdXRpbC5Mb25nLmZyb21CaXRzKDAsMCxmYWxzZSkgOiAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEcyQ19Mb2dpbkdhdGUgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JRzJDX0xvZ2luR2F0ZT19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IEcyQ19Mb2dpbkdhdGUgaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRzJDX0xvZ2luR2F0ZShwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkcyQ19Mb2dpbkdhdGUudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHMkNfTG9naW5HYXRlfSBtZXNzYWdlIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcclxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBsYXllcklkICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJQbGF5ZXJJZFwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgMSwgd2lyZVR5cGUgMCA9Ki84KS5pbnQ2NChtZXNzYWdlLlBsYXllcklkKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5MSwgd2lyZVR5cGUgMCA9Ki83MjgpLmludDMyKG1lc3NhZ2UuRXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCA5Miwgd2lyZVR5cGUgMiA9Ki83MzgpLnN0cmluZyhtZXNzYWdlLk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gd3JpdGVyO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHMkNfTG9naW5HYXRlIG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZS52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUcyQ19Mb2dpbkdhdGV9IG1lc3NhZ2UgRzJDX0xvZ2luR2F0ZSBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpLmxkZWxpbSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5HMkNfTG9naW5HYXRlfSBHMkNfTG9naW5HYXRlXHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuRzJDX0xvZ2luR2F0ZSgpO1xyXG4gICAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGVuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhZyA9IHJlYWRlci51aW50MzIoKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGFnID4+PiAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuRXJyb3IgPSByZWFkZXIuaW50MzIoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgOTI6XHJcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gcmVhZGVyLnN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSByZWFkZXIuaW50NjQoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBHMkNfTG9naW5HYXRlIG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS5kZWNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBkZWNvZGVEZWxpbWl0ZWQocmVhZGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3ICRSZWFkZXIocmVhZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWZXJpZmllcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSBcIm9iamVjdFwiIHx8IG1lc3NhZ2UgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYmplY3QgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLkVycm9yKSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJFcnJvcjogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBpZiAoISR1dGlsLmlzU3RyaW5nKG1lc3NhZ2UuTWVzc2FnZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTWVzc2FnZTogc3RyaW5nIGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBsYXllcklkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIlBsYXllcklkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5QbGF5ZXJJZCkgJiYgIShtZXNzYWdlLlBsYXllcklkICYmICR1dGlsLmlzSW50ZWdlcihtZXNzYWdlLlBsYXllcklkLmxvdykgJiYgJHV0aWwuaXNJbnRlZ2VyKG1lc3NhZ2UuUGxheWVySWQuaGlnaCkpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlBsYXllcklkOiBpbnRlZ2VyfExvbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZSBmcm9tIGEgcGxhaW4gb2JqZWN0LiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGludGVybmFsIHR5cGVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBmcm9tT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuRzJDX0xvZ2luR2F0ZX0gRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEcyQ19Mb2dpbkdhdGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkcyQ19Mb2dpbkdhdGUpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkcyQ19Mb2dpbkdhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5FcnJvciAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5FcnJvciA9IG9iamVjdC5FcnJvciB8IDA7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QuTWVzc2FnZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS5NZXNzYWdlID0gU3RyaW5nKG9iamVjdC5NZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5QbGF5ZXJJZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgaWYgKCR1dGlsLkxvbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuUGxheWVySWQgPSAkdXRpbC5Mb25nLmZyb21WYWx1ZShvYmplY3QuUGxheWVySWQpKS51bnNpZ25lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iamVjdC5QbGF5ZXJJZCA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLlBsYXllcklkID0gcGFyc2VJbnQob2JqZWN0LlBsYXllcklkLCAxMCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSBvYmplY3QuUGxheWVySWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0LlBsYXllcklkID09PSBcIm9iamVjdFwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuUGxheWVySWQgPSBuZXcgJHV0aWwuTG9uZ0JpdHMob2JqZWN0LlBsYXllcklkLmxvdyA+Pj4gMCwgb2JqZWN0LlBsYXllcklkLmhpZ2ggPj4+IDApLnRvTnVtYmVyKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEcyQ19Mb2dpbkdhdGUgbWVzc2FnZS4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gb3RoZXIgdHlwZXMgaWYgc3BlY2lmaWVkLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b09iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkcyQ19Mb2dpbkdhdGVcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLkcyQ19Mb2dpbkdhdGV9IG1lc3NhZ2UgRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLklDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgRzJDX0xvZ2luR2F0ZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0ge307XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJHV0aWwuTG9uZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb25nID0gbmV3ICR1dGlsLkxvbmcoMCwgMCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IGxvbmcudG9TdHJpbmcoKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IGxvbmcudG9OdW1iZXIoKSA6IGxvbmc7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3QuUGxheWVySWQgPSBvcHRpb25zLmxvbmdzID09PSBTdHJpbmcgPyBcIjBcIiA6IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlBsYXllcklkICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIlBsYXllcklkXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLlBsYXllcklkID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5QbGF5ZXJJZCA9IG9wdGlvbnMubG9uZ3MgPT09IFN0cmluZyA/IFN0cmluZyhtZXNzYWdlLlBsYXllcklkKSA6IG1lc3NhZ2UuUGxheWVySWQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LlBsYXllcklkID0gb3B0aW9ucy5sb25ncyA9PT0gU3RyaW5nID8gJHV0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtZXNzYWdlLlBsYXllcklkKSA6IG9wdGlvbnMubG9uZ3MgPT09IE51bWJlciA/IG5ldyAkdXRpbC5Mb25nQml0cyhtZXNzYWdlLlBsYXllcklkLmxvdyA+Pj4gMCwgbWVzc2FnZS5QbGF5ZXJJZC5oaWdoID4+PiAwKS50b051bWJlcigpIDogbWVzc2FnZS5QbGF5ZXJJZDtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuRXJyb3IgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwiRXJyb3JcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSBtZXNzYWdlLkVycm9yO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS5NZXNzYWdlICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIk1lc3NhZ2VcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QuTWVzc2FnZSA9IG1lc3NhZ2UuTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEcyQ19Mb2dpbkdhdGUgdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuRzJDX0xvZ2luR2F0ZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gSlNPTiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHMkNfTG9naW5HYXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBHMkNfTG9naW5HYXRlO1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICBuaWNlX3RzLkMyR1NfVGVzdCA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBvZiBhIEMyR1NfVGVzdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBpbnRlcmZhY2UgSUMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfG51bGx9IFt0ZXN0SURdIEMyR1NfVGVzdCB0ZXN0SURcclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdGVzdE5hbWVdIEMyR1NfVGVzdCB0ZXN0TmFtZVxyXG4gICAgICAgICAqL1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEMyR1NfVGVzdC5cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90c1xyXG4gICAgICAgICAqIEBjbGFzc2Rlc2MgUmVwcmVzZW50cyBhIEMyR1NfVGVzdC5cclxuICAgICAgICAgKiBAaW1wbGVtZW50cyBJQzJHU19UZXN0XHJcbiAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKi9cclxuICAgICAgICBmdW5jdGlvbiBDMkdTX1Rlc3QocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICBpZiAocHJvcGVydGllcylcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzW2tleXNbaV1dICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNba2V5c1tpXV0gPSBwcm9wZXJ0aWVzW2tleXNbaV1dO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQzJHU19UZXN0IHRlc3RJRC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHRlc3RJRFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5wcm90b3R5cGUudGVzdElEID0gMDtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQzJHU19UZXN0IHRlc3ROYW1lLlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGVzdE5hbWVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QucHJvdG90eXBlLnRlc3ROYW1lID0gXCJcIjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBDMkdTX1Rlc3QgaW5zdGFuY2UgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBjcmVhdGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3Q9fSBbcHJvcGVydGllc10gUHJvcGVydGllcyB0byBzZXRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdCBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEMyR1NfVGVzdChwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgQzJHU19UZXN0IG1lc3NhZ2UuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuQzJHU19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklDMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICBpZiAoIXdyaXRlcilcclxuICAgICAgICAgICAgICAgIHdyaXRlciA9ICRXcml0ZXIuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwidGVzdElEXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAxLCB3aXJlVHlwZSAwID0qLzgpLmludDMyKG1lc3NhZ2UudGVzdElEKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdE5hbWUgIT0gbnVsbCAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtZXNzYWdlLCBcInRlc3ROYW1lXCIpKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyLnVpbnQzMigvKiBpZCAyLCB3aXJlVHlwZSAyID0qLzE4KS5zdHJpbmcobWVzc2FnZS50ZXN0TmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB3cml0ZXI7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5jb2RlcyB0aGUgc3BlY2lmaWVkIEMyR1NfVGVzdCBtZXNzYWdlLCBsZW5ndGggZGVsaW1pdGVkLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBuaWNlX3RzLkMyR1NfVGVzdC52ZXJpZnl8dmVyaWZ5fSBtZXNzYWdlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5JQzJHU19UZXN0fSBtZXNzYWdlIEMyR1NfVGVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdCB0byBlbmNvZGVcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5Xcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cclxuICAgICAgICAgKiBAcmV0dXJucyB7JHByb3RvYnVmLldyaXRlcn0gV3JpdGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LmVuY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGVuY29kZURlbGltaXRlZChtZXNzYWdlLCB3cml0ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikubGRlbGltKCk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVjb2RlcyBhIEMyR1NfVGVzdCBtZXNzYWdlIGZyb20gdGhlIHNwZWNpZmllZCByZWFkZXIgb3IgYnVmZmVyLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBkZWNvZGVcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuUmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGhdIE1lc3NhZ2UgbGVuZ3RoIGlmIGtub3duIGJlZm9yZWhhbmRcclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIsIGxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9ICRSZWFkZXIuY3JlYXRlKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHZhciBlbmQgPSBsZW5ndGggPT09IHVuZGVmaW5lZCA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoLCBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KCk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gcmVhZGVyLnVpbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0YWcgPj4+IDMpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RJRCA9IHJlYWRlci5pbnQzMigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UudGVzdE5hbWUgPSByZWFkZXIuc3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5za2lwVHlwZSh0YWcgJiA3KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIsIGxlbmd0aCBkZWxpbWl0ZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcmV0dXJucyB7bmljZV90cy5DMkdTX1Rlc3R9IEMyR1NfVGVzdFxyXG4gICAgICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcGF5bG9hZCBpcyBub3QgYSByZWFkZXIgb3IgdmFsaWQgYnVmZmVyXHJcbiAgICAgICAgICogQHRocm93cyB7JHByb3RvYnVmLnV0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcclxuICAgICAgICAgICAgaWYgKCEocmVhZGVyIGluc3RhbmNlb2YgJFJlYWRlcikpXHJcbiAgICAgICAgICAgICAgICByZWFkZXIgPSBuZXcgJFJlYWRlcihyZWFkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGUocmVhZGVyLCByZWFkZXIudWludDMyKCkpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZlcmlmaWVzIGEgQzJHU19UZXN0IG1lc3NhZ2UuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHZlcmlmeVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIFBsYWluIG9iamVjdCB0byB2ZXJpZnlcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEMyR1NfVGVzdC52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobWVzc2FnZSkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09IFwib2JqZWN0XCIgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldHVybiBcIm9iamVjdCBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0SUQgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdElEXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS50ZXN0SUQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInRlc3RJRDogaW50ZWdlciBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0TmFtZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0TmFtZVwiKSlcclxuICAgICAgICAgICAgICAgIGlmICghJHV0aWwuaXNTdHJpbmcobWVzc2FnZS50ZXN0TmFtZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdE5hbWU6IHN0cmluZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgQzJHU19UZXN0IG1lc3NhZ2UgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZnJvbU9iamVjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkMyR1NfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XHJcbiAgICAgICAgICogQHJldHVybnMge25pY2VfdHMuQzJHU19UZXN0fSBDMkdTX1Rlc3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QuZnJvbU9iamVjdCA9IGZ1bmN0aW9uIGZyb21PYmplY3Qob2JqZWN0KSB7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiAkcm9vdC5uaWNlX3RzLkMyR1NfVGVzdClcclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3ICRyb290Lm5pY2VfdHMuQzJHU19UZXN0KCk7XHJcbiAgICAgICAgICAgIGlmIChvYmplY3QudGVzdElEICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RJRCA9IG9iamVjdC50ZXN0SUQgfCAwO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlc3ROYW1lICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3ROYW1lID0gU3RyaW5nKG9iamVjdC50ZXN0TmFtZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEMyR1NfVGVzdCBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuQzJHU19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5DMkdTX1Rlc3R9IG1lc3NhZ2UgQzJHU19UZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBDMkdTX1Rlc3QudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3RJRCA9IDA7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdE5hbWUgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RJRCAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0SURcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdElEID0gbWVzc2FnZS50ZXN0SUQ7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3ROYW1lICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcInRlc3ROYW1lXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3ROYW1lID0gbWVzc2FnZS50ZXN0TmFtZTtcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIEMyR1NfVGVzdCB0byBKU09OLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiB0b0pTT05cclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5DMkdTX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQzJHU19UZXN0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnRvT2JqZWN0KHRoaXMsICRwcm90b2J1Zi51dGlsLnRvSlNPTk9wdGlvbnMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBDMkdTX1Rlc3Q7XHJcbiAgICB9KSgpO1xyXG5cclxuICAgIG5pY2VfdHMuR1MyQ19UZXN0ID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgR1MyQ19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGludGVyZmFjZSBJR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ8bnVsbH0gW0Vycm9yXSBHUzJDX1Rlc3QgRXJyb3JcclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbTWVzc2FnZV0gR1MyQ19UZXN0IE1lc3NhZ2VcclxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ3xudWxsfSBbdGVzdFJlc3BvbnNlXSBHUzJDX1Rlc3QgdGVzdFJlc3BvbnNlXHJcbiAgICAgICAgICovXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnN0cnVjdHMgYSBuZXcgR1MyQ19UZXN0LlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzXHJcbiAgICAgICAgICogQGNsYXNzZGVzYyBSZXByZXNlbnRzIGEgR1MyQ19UZXN0LlxyXG4gICAgICAgICAqIEBpbXBsZW1lbnRzIElHUzJDX1Rlc3RcclxuICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIEdTMkNfVGVzdChwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzKVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXNba2V5c1tpXV0gIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHUzJDX1Rlc3QgRXJyb3IuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfSBFcnJvclxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5wcm90b3R5cGUuRXJyb3IgPSAwO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHUzJDX1Rlc3QgTWVzc2FnZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IE1lc3NhZ2VcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QucHJvdG90eXBlLk1lc3NhZ2UgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHUzJDX1Rlc3QgdGVzdFJlc3BvbnNlLlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ30gdGVzdFJlc3BvbnNlXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnByb3RvdHlwZS50ZXN0UmVzcG9uc2UgPSBcIlwiO1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IEdTMkNfVGVzdCBpbnN0YW5jZSB1c2luZyB0aGUgc3BlY2lmaWVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGNyZWF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdD19IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkdTMkNfVGVzdH0gR1MyQ19UZXN0IGluc3RhbmNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgR1MyQ19UZXN0KHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVuY29kZXMgdGhlIHNwZWNpZmllZCBHUzJDX1Rlc3QgbWVzc2FnZS4gRG9lcyBub3QgaW1wbGljaXRseSB7QGxpbmsgbmljZV90cy5HUzJDX1Rlc3QudmVyaWZ5fHZlcmlmeX0gbWVzc2FnZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGVuY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0ge25pY2VfdHMuSUdTMkNfVGVzdH0gbWVzc2FnZSBHUzJDX1Rlc3QgbWVzc2FnZSBvciBwbGFpbiBvYmplY3QgdG8gZW5jb2RlXHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuV3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gZW5jb2RlIHRvXHJcbiAgICAgICAgICogQHJldHVybnMgeyRwcm90b2J1Zi5Xcml0ZXJ9IFdyaXRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUobWVzc2FnZSwgd3JpdGVyKSB7XHJcbiAgICAgICAgICAgIGlmICghd3JpdGVyKVxyXG4gICAgICAgICAgICAgICAgd3JpdGVyID0gJFdyaXRlci5jcmVhdGUoKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudGVzdFJlc3BvbnNlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJ0ZXN0UmVzcG9uc2VcIikpXHJcbiAgICAgICAgICAgICAgICB3cml0ZXIudWludDMyKC8qIGlkIDEsIHdpcmVUeXBlIDIgPSovMTApLnN0cmluZyhtZXNzYWdlLnRlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobWVzc2FnZSwgXCJFcnJvclwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTEsIHdpcmVUeXBlIDAgPSovNzI4KS5pbnQzMihtZXNzYWdlLkVycm9yKTtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1lc3NhZ2UsIFwiTWVzc2FnZVwiKSlcclxuICAgICAgICAgICAgICAgIHdyaXRlci51aW50MzIoLyogaWQgOTIsIHdpcmVUeXBlIDIgPSovNzM4KS5zdHJpbmcobWVzc2FnZS5NZXNzYWdlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHdyaXRlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmNvZGVzIHRoZSBzcGVjaWZpZWQgR1MyQ19UZXN0IG1lc3NhZ2UsIGxlbmd0aCBkZWxpbWl0ZWQuIERvZXMgbm90IGltcGxpY2l0bHkge0BsaW5rIG5pY2VfdHMuR1MyQ19UZXN0LnZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxyXG4gICAgICAgICAqIEBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtuaWNlX3RzLklHUzJDX1Rlc3R9IG1lc3NhZ2UgR1MyQ19UZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0IHRvIGVuY29kZVxyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLldyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIGVuY29kZSB0b1xyXG4gICAgICAgICAqIEByZXR1cm5zIHskcHJvdG9idWYuV3JpdGVyfSBXcml0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuZW5jb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKS5sZGVsaW0oKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWNvZGVzIGEgR1MyQ19UZXN0IG1lc3NhZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIHJlYWRlciBvciBidWZmZXIuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGRlY29kZVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBuaWNlX3RzLkdTMkNfVGVzdFxyXG4gICAgICAgICAqIEBzdGF0aWNcclxuICAgICAgICAgKiBAcGFyYW0geyRwcm90b2J1Zi5SZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlIGZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTWVzc2FnZSBsZW5ndGggaWYga25vd24gYmVmb3JlaGFuZFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkdTMkNfVGVzdH0gR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHJlYWRlciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmICghKHJlYWRlciBpbnN0YW5jZW9mICRSZWFkZXIpKVxyXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gJFJlYWRlci5jcmVhdGUocmVhZGVyKTtcclxuICAgICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCA9PT0gdW5kZWZpbmVkID8gcmVhZGVyLmxlbiA6IHJlYWRlci5wb3MgKyBsZW5ndGgsIG1lc3NhZ2UgPSBuZXcgJHJvb3QubmljZV90cy5HUzJDX1Rlc3QoKTtcclxuICAgICAgICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0YWcgPSByZWFkZXIudWludDMyKCk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhZyA+Pj4gMykge1xyXG4gICAgICAgICAgICAgICAgY2FzZSA5MTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gcmVhZGVyLmludDMyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkyOlxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuTWVzc2FnZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLnRlc3RSZXNwb25zZSA9IHJlYWRlci5zdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnNraXBUeXBlKHRhZyAmIDcpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlY29kZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZSBmcm9tIHRoZSBzcGVjaWZpZWQgcmVhZGVyIG9yIGJ1ZmZlciwgbGVuZ3RoIGRlbGltaXRlZC5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7JHByb3RvYnVmLlJlYWRlcnxVaW50OEFycmF5fSByZWFkZXIgUmVhZGVyIG9yIGJ1ZmZlciB0byBkZWNvZGUgZnJvbVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkdTMkNfVGVzdH0gR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcclxuICAgICAgICAgKiBAdGhyb3dzIHskcHJvdG9idWYudXRpbC5Qcm90b2NvbEVycm9yfSBJZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xyXG4gICAgICAgICAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiAkUmVhZGVyKSlcclxuICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyAkUmVhZGVyKHJlYWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZShyZWFkZXIsIHJlYWRlci51aW50MzIoKSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmVyaWZpZXMgYSBHUzJDX1Rlc3QgbWVzc2FnZS5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdmVyaWZ5XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gYG51bGxgIGlmIHZhbGlkLCBvdGhlcndpc2UgdGhlIHJlYXNvbiB3aHkgaXQgaXMgbm90XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0IGV4cGVjdGVkXCI7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc0ludGVnZXIobWVzc2FnZS5FcnJvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3I6IGludGVnZXIgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLk1lc3NhZ2UpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIk1lc3NhZ2U6IHN0cmluZyBleHBlY3RlZFwiO1xyXG4gICAgICAgICAgICBpZiAobWVzc2FnZS50ZXN0UmVzcG9uc2UgIT0gbnVsbCAmJiBtZXNzYWdlLmhhc093blByb3BlcnR5KFwidGVzdFJlc3BvbnNlXCIpKVxyXG4gICAgICAgICAgICAgICAgaWYgKCEkdXRpbC5pc1N0cmluZyhtZXNzYWdlLnRlc3RSZXNwb25zZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwidGVzdFJlc3BvbnNlOiBzdHJpbmcgZXhwZWN0ZWRcIjtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3JlYXRlcyBhIEdTMkNfVGVzdCBtZXNzYWdlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIGZyb21PYmplY3RcclxuICAgICAgICAgKiBAbWVtYmVyb2YgbmljZV90cy5HUzJDX1Rlc3RcclxuICAgICAgICAgKiBAc3RhdGljXHJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxyXG4gICAgICAgICAqIEByZXR1cm5zIHtuaWNlX3RzLkdTMkNfVGVzdH0gR1MyQ19UZXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgR1MyQ19UZXN0LmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgJHJvb3QubmljZV90cy5HUzJDX1Rlc3QpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyAkcm9vdC5uaWNlX3RzLkdTMkNfVGVzdCgpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LkVycm9yICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLkVycm9yID0gb2JqZWN0LkVycm9yIHwgMDtcclxuICAgICAgICAgICAgaWYgKG9iamVjdC5NZXNzYWdlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlLk1lc3NhZ2UgPSBTdHJpbmcob2JqZWN0Lk1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAob2JqZWN0LnRlc3RSZXNwb25zZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgbWVzc2FnZS50ZXN0UmVzcG9uc2UgPSBTdHJpbmcob2JqZWN0LnRlc3RSZXNwb25zZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIEdTMkNfVGVzdCBtZXNzYWdlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXHJcbiAgICAgICAgICogQGZ1bmN0aW9uIHRvT2JqZWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHN0YXRpY1xyXG4gICAgICAgICAqIEBwYXJhbSB7bmljZV90cy5HUzJDX1Rlc3R9IG1lc3NhZ2UgR1MyQ19UZXN0XHJcbiAgICAgICAgICogQHBhcmFtIHskcHJvdG9idWYuSUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICBHUzJDX1Rlc3QudG9PYmplY3QgPSBmdW5jdGlvbiB0b09iamVjdChtZXNzYWdlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cykge1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0LnRlc3RSZXNwb25zZSA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICBvYmplY3QuRXJyb3IgPSAwO1xyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRlc3RSZXNwb25zZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJ0ZXN0UmVzcG9uc2VcIikpXHJcbiAgICAgICAgICAgICAgICBvYmplY3QudGVzdFJlc3BvbnNlID0gbWVzc2FnZS50ZXN0UmVzcG9uc2U7XHJcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkVycm9yICE9IG51bGwgJiYgbWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcIkVycm9yXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0LkVycm9yID0gbWVzc2FnZS5FcnJvcjtcclxuICAgICAgICAgICAgaWYgKG1lc3NhZ2UuTWVzc2FnZSAhPSBudWxsICYmIG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJNZXNzYWdlXCIpKVxyXG4gICAgICAgICAgICAgICAgb2JqZWN0Lk1lc3NhZ2UgPSBtZXNzYWdlLk1lc3NhZ2U7XHJcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVydHMgdGhpcyBHUzJDX1Rlc3QgdG8gSlNPTi5cclxuICAgICAgICAgKiBAZnVuY3Rpb24gdG9KU09OXHJcbiAgICAgICAgICogQG1lbWJlcm9mIG5pY2VfdHMuR1MyQ19UZXN0XHJcbiAgICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAgICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBKU09OIG9iamVjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIEdTMkNfVGVzdC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci50b09iamVjdCh0aGlzLCAkcHJvdG9idWYudXRpbC50b0pTT05PcHRpb25zKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gR1MyQ19UZXN0O1xyXG4gICAgfSkoKTtcclxuXHJcbiAgICByZXR1cm4gbmljZV90cztcclxufSkoKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gJHJvb3Q7XHJcbiIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBjb21iYXRVSVxue1xuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJjb21iYXRcIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImNvbWJhdF9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJdGVzdDpzdHJpbmcgPSBcInRlc3RcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJQ2FyZDpzdHJpbmcgPSBcIkNhcmRcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJQ29tYmF0UGFnZTpzdHJpbmcgPSBcIkNvbWJhdFBhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJUm9vbTpzdHJpbmcgPSBcIlJvb21cIjtcbn0iLCIvKiogVGhpcyBpcyBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBjbGFzcyBieSBGYWlyeUdVSS4gUGxlYXNlIGRvIG5vdCBtb2RpZnkgaXQuICoqL1xuXG5leHBvcnQgY2xhc3MgY29tbW9uVUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwiY29tbW9uXCI7XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlQnl0ZXM6c3RyaW5nID0gXCJjb21tb25fZnVpLmJ5dGVzXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSUxvYWRpbmdQYWdlOnN0cmluZyA9IFwiTG9hZGluZ1BhZ2VcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJVUlHdWlkZVdpbjpzdHJpbmcgPSBcIlVJR3VpZGVXaW5cIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJVUlOb3RpY2VXaW46c3RyaW5nID0gXCJVSU5vdGljZVdpblwiO1xufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXHJcblxyXG5leHBvcnQgY2xhc3MgaG9tZVVJXHJcbntcclxuICAgIHB1YmxpYyBzdGF0aWMgUGFja2FnZU5hbWU6c3RyaW5nID0gXCJob21lXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcImhvbWVfZnVpLmJ5dGVzXCI7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJSG9tZVBhZ2U6c3RyaW5nID0gXCJIb21lUGFnZVwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBVSUxldmVsUGFnZTpzdHJpbmcgPSBcIkxldmVsUGFnZVwiO1xyXG4gICAgcHVibGljIHN0YXRpYyBVSVNob3BQYWdlOnN0cmluZyA9IFwiU2hvcFBhZ2VcIjtcclxufSIsIi8qKiBUaGlzIGlzIGFuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGNsYXNzIGJ5IEZhaXJ5R1VJLiBQbGVhc2UgZG8gbm90IG1vZGlmeSBpdC4gKiovXG5cbmV4cG9ydCBjbGFzcyBsb2dpblVJXG57XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlTmFtZTpzdHJpbmcgPSBcImxvZ2luXCI7XG4gICAgcHVibGljIHN0YXRpYyBQYWNrYWdlQnl0ZXM6c3RyaW5nID0gXCJsb2dpbl9mdWkuYnl0ZXNcIjtcbiAgICBwdWJsaWMgc3RhdGljIFVJTG9naW5QYWdlOnN0cmluZyA9IFwiTG9naW5QYWdlXCI7XG4gICAgcHVibGljIHN0YXRpYyBVSVNlbFNlcnZlcldpbjpzdHJpbmcgPSBcIlNlbFNlcnZlcldpblwiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlBcmVhSXRlbTpzdHJpbmcgPSBcIkFyZWFJdGVtXCI7XG59IiwiLyoqIFRoaXMgaXMgYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgY2xhc3MgYnkgRmFpcnlHVUkuIFBsZWFzZSBkbyBub3QgbW9kaWZ5IGl0LiAqKi9cblxuZXhwb3J0IGNsYXNzIHN0b3J5VUlcbntcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VOYW1lOnN0cmluZyA9IFwic3RvcnlcIjtcbiAgICBwdWJsaWMgc3RhdGljIFBhY2thZ2VCeXRlczpzdHJpbmcgPSBcInN0b3J5X2Z1aS5ieXRlc1wiO1xuICAgIHB1YmxpYyBzdGF0aWMgVUlTdG9yeVdpbjpzdHJpbmcgPSBcIlN0b3J5V2luXCI7XG59IiwiXHJcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gJy4vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgUmVzTWFuYWdlciB9IGZyb20gJy4vUmVzTWFuYWdlcic7XHJcbmltcG9ydCB7IFVuaXR5RW5naW5lIH0gZnJvbSAnY3NoYXJwJztcclxuXHJcblxyXG5cclxuLy8gLS0gR2FtZU9iamVjdOe8k+WtmOaxoFxyXG4vLyAtLSDms6jmhI/vvJpcclxuLy8gLS0gMeOAgeaJgOaciemcgOimgemihOiuvumDveS7jui/memHjOWKoOi9ve+8jOS4jeimgeebtOaOpeWIsFJlc291cmNlc01hbmFnZXLljrvliqDovb3vvIznlLHov5nph4znu5/kuIDlgZrnvJPlrZjnrqHnkIZcclxuLy8gLS0gMuOAgee8k+WtmOWIhuS4uuS4pOmDqOWIhu+8muS7jui1hOa6kOWxguWKoOi9veeahOWOn+Wni0dhbWVPYmplY3QoQXNzZXQp77yM5LuOR2FtZU9iamVjdOWunuS+i+WMluWHuuadpeeahOWkmuS4qkluc3RcclxuZXhwb3J0IGNsYXNzIEdhbWVPYmplY3RQb29sIGV4dGVuZHMgU2luZ2xldG9uPEdhbWVPYmplY3RQb29sPntcclxuXHJcbiAgICBwcml2YXRlIF9fY2FjaGVUcmFuc1Jvb3QgPSBudWxsO1xyXG4gICAgcHJpdmF0ZSBfX2dvUG9vbCA9IG5ldyBNYXAoKTtcclxuICAgIHByaXZhdGUgX19pbnN0Q2FjaGU6TWFwPHN0cmluZyxBcnJheTxhbnk+PiA9IG5ldyBNYXA8c3RyaW5nLEFycmF5PGFueT4+KCk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgbGV0IGdvID0gVW5pdHlFbmdpbmUuR2FtZU9iamVjdC5GaW5kKFwiR2FtZU9iamVjdENhY2hlUm9vdFwiKTtcclxuXHJcbiAgICAgICAgaWYoZ28gPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgZ28gPSBuZXcgVW5pdHlFbmdpbmUuR2FtZU9iamVjdChcIkdhbWVPYmplY3RDYWNoZVJvb3RcIik7XHJcbiAgICAgICAgICAgIFVuaXR5RW5naW5lLk9iamVjdC5Eb250RGVzdHJveU9uTG9hZChnbyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9fY2FjaGVUcmFuc1Jvb3QgPSBnby50cmFuc2Zvcm07XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLSDmo4DmtYvmmK/lkKblt7Lnu4/ooqvnvJPlrZhcclxuICAgIHB1YmxpYyBjaGVja0hhc0NhY2hlZChwYXRoOnN0cmluZyl7XHJcblxyXG4gICAgICAgIGxldCBjYWNoZWRJbnN0OkFycmF5PGFueT4gPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICBpZihjYWNoZWRJbnN0ICE9IHVuZGVmaW5lZCAmJiBjYWNoZWRJbnN0Lmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBwb29sZWRHbyA9IHRoaXMuX19nb1Bvb2wuZ2V0KHBhdGgpO1xyXG4gICAgICAgIHJldHVybiBwb29sZWRHbyAhPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g57yT5a2Y5bm25a6e5L6L5YyWR2FtZU9iamVjdFxyXG4gICAgcHVibGljIGNhY2hlQW5kSW5zdEdhbWVPYmplY3QocGF0aDpzdHJpbmcsIGdvOmFueSwgaW5zdF9jb3VudDpudW1iZXIgPSAxKXtcclxuXHJcbiAgICAgICAgdGhpcy5fX2dvUG9vbC5zZXQocGF0aCwgZ28pO1xyXG4gICAgICAgIGlmKGluc3RfY291bnQgPiAwKXtcclxuXHJcbiAgICAgICAgICAgIGxldCBjYWNoZWRJbnN0OkFycmF5PGFueT4gPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICAgICAgZm9yKGxldCBpOm51bWJlciA9MDsgaSA8IGluc3RfY291bnQ7IGkrKyl7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGluc3QgPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKGdvKSBhcyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgaW5zdC50cmFuc2Zvcm0uU2V0UGFyZW50KHRoaXMuX19jYWNoZVRyYW5zUm9vdCk7XHJcbiAgICAgICAgICAgICAgICBpbnN0LlNldEFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FjaGVkSW5zdC5wdXNoKGluc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0g5bCd6K+V5LuO57yT5a2Y5Lit6I635Y+WXHJcbiAgICBwdWJsaWMgdHJ5R2V0RnJvbUNhY2hlKHBhdGg6c3RyaW5nKTphbnl7XHJcblxyXG4gICAgICAgIGlmKCF0aGlzLmNoZWNrSGFzQ2FjaGVkKHBhdGgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNhY2hlZEluc3Q6QXJyYXk8b2JqZWN0PiAgPSB0aGlzLl9faW5zdENhY2hlLmdldChwYXRoKTtcclxuICAgICAgICBpZihjYWNoZWRJbnN0ICE9IHVuZGVmaW5lZCAmJiBjYWNoZWRJbnN0Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCBpbnN0ID0gY2FjaGVkSW5zdC5wb3AoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGluc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcG9vbGVkR28gPSB0aGlzLl9fZ29Qb29sLmdldChwYXRoKTtcclxuICAgICAgICBpZihwb29sZWRHbyAhPSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICBsZXQgaW5zdCA9IFVuaXR5RW5naW5lLkdhbWVPYmplY3QuSW5zdGFudGlhdGUocG9vbGVkR28pO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8v6aKE5Yqg6L2977ya5Y+v5o+Q5L6b5Yid5aeL5a6e5L6L5YyW5Liq5pWwXHJcbiAgICBwdWJsaWMgYXN5bmMgcHJlTG9hZEdhbWVPYmplY3RBc3luYyhwYXRoOnN0cmluZywgaW5zdF9jb3VudDpudW1iZXIsIGNhbGxiYWNrOkZ1bmN0aW9uLC4uLnBhcmFtcyl7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuY2hlY2tIYXNDYWNoZWQocGF0aCkpe1xyXG4gICAgICAgICAgICBpZihjYWxsYmFjayE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwYXJhbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBnbyA9IGF3YWl0IFJlc01hbmFnZXIuSW5zdGFuY2UoUmVzTWFuYWdlcikubG9hZFByZWZhYihwYXRoKTtcclxuICAgICAgICBpZihnbyE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZUFuZEluc3RHYW1lT2JqZWN0KHBhdGgsIGdvLGluc3RfY291bnQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoY2FsbGJhY2shPW51bGwpe1xyXG4gICAgICAgICAgICBjYWxsYmFjayhwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDlvILmraXojrflj5bvvJrlv4XopoHml7bliqDovb1cclxuICAgIHB1YmxpYyBhc3luYyBnZXRHYW1lT2JqZWN0QXN5bmMocGF0aDpzdHJpbmcsIGNhbGxiYWNrOkZ1bmN0aW9uLC4uLnBhcmFtcyl7XHJcblxyXG4gICAgICAgIGxldCBpbnN0OmFueSA9IHRoaXMudHJ5R2V0RnJvbUNhY2hlKHBhdGgpO1xyXG4gICAgICAgIGlmKGluc3QgPT1udWxsKXtcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVMb2FkR2FtZU9iamVjdEFzeW5jKHBhdGgsIDEsIGNhbGxiYWNrLCBwYXJhbXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaW5zdCA9IHRoaXMudHJ5R2V0RnJvbUNhY2hlKHBhdGgpO1xyXG4gICAgICAgIGluc3QuU2V0QWN0aXZlKHRydWUpO1xyXG5cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8tLSDlm57mlLZcclxuICAgIHB1YmxpYyByZWN5Y2xlR2FtZU9iamVjdChwYXRoOnN0cmluZywgaW5zdDphbnkpe1xyXG5cclxuICAgICAgICBpbnN0LnRyYW5zZm9ybS5TZXRQYXJlbnQodGhpcy5fX2NhY2hlVHJhbnNSb290KTtcclxuICAgICAgICBpbnN0LlNldEFjdGl2ZShmYWxzZSk7XHJcblxyXG4gICAgICAgIGxldCBjYWNoZWRJbnN0ID0gdGhpcy5fX2luc3RDYWNoZS5nZXQocGF0aCkgfHwgbmV3IEFycmF5KCk7XHJcbiAgICAgICAgY2FjaGVkSW5zdC5wdXNoKGluc3QpO1xyXG5cclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLnNldChwYXRoLCBjYWNoZWRJbnN0KTtcclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vLS0g5riF55CG57yT5a2YXHJcbiAgICBwdWJsaWMgY2xlYW51cChpbmNsdWRlUG9vbGVkR286Ym9vbGVhbiA9IGZhbHNlKXtcclxuXHJcbiAgICAgICAgdGhpcy5fX2luc3RDYWNoZS5mb3JFYWNoKCh2YWx1ZXMsIGtleSk9PntcclxuXHJcbiAgICAgICAgICAgIGZvcihsZXQgaW5zdCBvZiB2YWx1ZXMpe1xyXG4gICAgICAgICAgICAgICAgaWYoaW5zdCAhPSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBVbml0eUVuZ2luZS5HYW1lT2JqZWN0LkRlc3Ryb3koaW5zdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9faW5zdENhY2hlLmNsZWFyKCk7IFxyXG5cclxuICAgICAgICBpZihpbmNsdWRlUG9vbGVkR28pe1xyXG4gICAgICAgICAgICB0aGlzLl9fZ29Qb29sLmZvckVhY2goKGdvLCBrZXkpPT57XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZ28gIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5yZWxlYXNlQWRkcmVzc0dPKGdvKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9fZ29Qb29sLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiXHJcblxyXG5leHBvcnQgY2xhc3MgTWVzT2Jqe1xyXG4gICAgcHVibGljIGxpc3RlbmVyczpBcnJheTxGdW5jdGlvbj47XHJcbiAgICBwdWJsaWMgb2JqOmFueTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBNZXNzZW5nZXJ7XHJcblxyXG4gICAgcHJpdmF0ZSBsaXN0ZW5lck1hcCA9IG5ldyBNYXA8bnVtYmVyLE1lc09iaj4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIoZV90eXBlOm51bWJlciwgZV9vYmo6YW55LCBlX2xpc3RuZXI6RnVuY3Rpb24pOnZvaWR7XHJcblxyXG4gICAgICAgIGxldCBtc2dPYmogPSB0aGlzLmxpc3RlbmVyTWFwLmdldChlX3R5cGUpO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YobXNnT2JqKSA9PSBcInVuZGVmaW5lZFwiKXtcclxuICAgICAgICAgICAgbXNnT2JqID0gbmV3IE1lc09iaigpO1xyXG4gICAgICAgICAgICBtc2dPYmoub2JqID0gZV9vYmo7XHJcbiAgICAgICAgICAgIG1zZ09iai5saXN0ZW5lcnMgPSBuZXcgQXJyYXk8RnVuY3Rpb24+KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1zZ09iai5saXN0ZW5lcnMucHVzaChlX2xpc3RuZXIpO1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyTWFwLnNldChlX3R5cGUsIG1zZ09iaik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldExpc3RlbmVyKGVfdHlwZTpudW1iZXIpOk1lc09iantcclxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lck1hcC5nZXQoZV90eXBlKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYnJvYWRjYXN0KGVfdHlwZTpudW1iZXIsIC4uLnBhcmFtczphbnlbXSkgOiB2b2lkIHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZW9mKG1zZ09iaikgIT0gXCJ1bmRlZmluZWRcIil7XHJcbiAgICAgICAgICAgIGZvcihsZXQgbCBvZiBtc2dPYmoubGlzdGVuZXJzKXtcclxuICAgICAgICAgICAgICAgbC5hcHBseShtc2dPYmoub2JqLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5VHlwZShlX3R5cGU6bnVtYmVyKSA6dm9pZCB7XHJcblxyXG4gICAgICAgIHRoaXMubGlzdGVuZXJNYXAuZGVsZXRlKGVfdHlwZSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihlX3R5cGU6bnVtYmVyLCBlX2xpc3RlbmVyOkZ1bmN0aW9uICk6dm9pZHtcclxuXHJcbiAgICAgICAgbGV0IG1zZ09iaiA9IHRoaXMubGlzdGVuZXJNYXAuZ2V0KGVfdHlwZSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZihtc2dPYmopICE9IFwidW5kZWZpbmVkXCIpe1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9yKGxldCBpOm51bWJlciA9MDsgaTwgbXNnT2JqLmxpc3RlbmVycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgICAgICBpZihtc2dPYmoubGlzdGVuZXJzW2ldID09IGVfbGlzdGVuZXIpe1xyXG4gICAgICAgICAgICAgICAgICAgIG1zZ09iai5saXN0ZW5lcnMuc3BsaWNlKGksMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNsZWFydXAoKTp2b2lke1xyXG5cclxuICAgICAgICB0aGlzLmxpc3RlbmVyTWFwLmNsZWFyKCk7XHJcbiAgICB9XHJcblxyXG59IiwiXHJcblxyXG5cclxuLy8gRmFpcnlHVUkg5YWD5Lu2IOe7keWumuWZqFxyXG5leHBvcnQgZnVuY3Rpb24gYmluZGVyKG5hbWU6c3RyaW5nKXtcclxuICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQ6YW55LCBrZXk6c3RyaW5nIHwgc3ltYm9sKXtcclxuICAgICAgICB0YXJnZXRbXCJiaW5kZXJzXCJdID0gdGFyZ2V0W1wiYmluZGVyc1wiXSB8fCB7fTtcclxuICAgICAgICB0YXJnZXRbXCJiaW5kZXJzXCJdW2tleV0gPSBuYW1lO1xyXG4gICAgfVxyXG59IiwiXHJcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gJy4vU2luZ2xldG9uJztcclxuaW1wb3J0IHsgJHByb21pc2UgfSBmcm9tICdwdWVydHMnO1xyXG5pbXBvcnQge05pY2VUUywgVW5pdHlFbmdpbmV9IGZyb20gJ2NzaGFycCc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlci9Mb2dnZXInO1xyXG5cclxuZXhwb3J0IGNsYXNzIFJlc01hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248UmVzTWFuYWdlcj57XHJcblxyXG4gICAgcHJpdmF0ZSBfcGtnTWFwOk1hcDxzdHJpbmcsbnVtYmVyPiA9IG5ldyBNYXA8c3RyaW5nLG51bWJlcj4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgbG9hZEZhaXJ5R1VJUGFja2FnZShwYWNrYWdlTmFtZTpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IHRoaXMuX3BrZ01hcC5nZXQocGFja2FnZU5hbWUpO1xyXG4gICAgICAgICAgICBpZihjb3VudCA9PSBudWxsIHx8IGNvdW50IDwgMSl7XHJcbiAgICAgICAgICAgICAgICAvL+ayoeaciee8k+WtmO+8jOWKoOi9vVxyXG4gICAgICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBwYWNrYWdlTmFtZStcIl9mdWkuYnl0ZXNcIjtcclxuICAgICAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkRmFpcnlHVUlQYWNrYWdlKGFkZHJlc3MscGFja2FnZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BrZ01hcC5zZXQocGFja2FnZU5hbWUsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wa2dNYXAuc2V0KHBhY2thZ2VOYW1lLCBjb3VudCsxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1jYXRjaChleCl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBmYWlyeUdVSSA6JHtwYWNrYWdlTmFtZX0gOiAke2V4fWApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgcmVsZWFzZUZhaXJ5R1VJUGFja2FnZShwYWNrYWdlTmFtZSl7XHJcblxyXG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuX3BrZ01hcC5nZXQocGFja2FnZU5hbWUpO1xyXG4gICAgICAgIGlmKGNvdW50IT1udWxsICYmIGNvdW50PjEpe1xyXG4gICAgICAgICAgICB0aGlzLl9wa2dNYXAuc2V0KHBhY2thZ2VOYW1lLCBjb3VudC0xKTtcclxuICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coYHJlbGVhc2UgZmFndWkgcGFja2FnZToke3BhY2thZ2VOYW1lfWApO1xyXG4gICAgICAgICAgICB0aGlzLl9wa2dNYXAuZGVsZXRlKHBhY2thZ2VOYW1lKTtcclxuICAgICAgICAgICAgTmljZVRTLlJlc291cmNlTWFuYWdlci5SZWxlYXNlRkdVSVBhY2thZ2UocGFja2FnZU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkU2NlbmUoc2NlbmVOYW1lOnN0cmluZywgbW9kZSA9IFVuaXR5RW5naW5lLlNjZW5lTWFuYWdlbWVudC5Mb2FkU2NlbmVNb2RlLlNpbmdsZSl7XHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkU2NlbmUoc2NlbmVOYW1lLCBtb2RlLChwcm9ncmVzczpOdW1iZXIpPT57XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIubG9nKFwibG9hZCBzY2VuZTogXCIrcHJvZ3Jlc3MpXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgbGV0IHNjZW5JbnN0YW5jZSA9IGF3YWl0ICRwcm9taXNlKHRhc2spXHJcbiAgICAgICAgICAgIHJldHVybiBzY2VuSW5zdGFuY2VcclxuXHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgTG9hZCBTY2VuZSA6JHtzY2VuZU5hbWV9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBhc3luYyB1bmxvYWRTY2VuZShzY2VuZUluc3RhbmNlOlVuaXR5RW5naW5lLlJlc291cmNlTWFuYWdlbWVudC5SZXNvdXJjZVByb3ZpZGVycy5TY2VuZUluc3RhbmNlKXtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrPSBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlVubG9hZFNjZW5lKHNjZW5lSW5zdGFuY2UpXHJcbiAgICAgICAgICAgIGxldCBnbyA9IGF3YWl0ICRwcm9taXNlKHRhc2spO1xyXG4gICAgICAgICAgICByZXR1cm4gZ287XHJcbiAgICAgICAgfWNhdGNoKGV4KXtcclxuXHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihgVW5sb2FkIHNjZW5lICA6ICR7ZXh9YClcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdW5sb2FkU2NlbmVCeU5hbWUoc2NlbmVOYW1lOnN0cmluZyl7XHJcblxyXG4gICAgICAgIE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuVW5sb2FkU2NlbmVCeU5hbWUoc2NlbmVOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkUHJlZmFiKGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzaz0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkUHJlZmFiKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG4gICAgICAgIH1jYXRjaChleCl7XHJcblxyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYExvYWQgcHJlZmFiIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBhc3luYyBsb2FkVGV4dEFzc2V0KGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFRleHRBc3NldChhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGdvID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBnbztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYExvYWQgdGV4dGFzc2V0IDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBhc3luYyBsb2FkVGV4dEJ5dGVzKGFkZHJlc3M6c3RyaW5nKXtcclxuXHJcbiAgICAgICAgdHJ5e1xyXG4gICAgICAgICAgICBsZXQgdGFzayA9IE5pY2VUUy5SZXNvdXJjZU1hbmFnZXIuTG9hZFRleHRCeXRlcyhhZGRyZXNzKTtcclxuICAgICAgICAgICAgbGV0IGJ5dGVzID0gYXdhaXQgJHByb21pc2UodGFzayk7XHJcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYExvYWRUZXh0Qnl0ZXMgOiR7YWRkcmVzc30gOiAke2V4fWApXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIGxvYWRTcHJpdGUoYWRkcmVzczpzdHJpbmcpe1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCB0YXNrID0gTmljZVRTLlJlc291cmNlTWFuYWdlci5Mb2FkU3ByaXRlKGFkZHJlc3MpO1xyXG4gICAgICAgICAgICBsZXQgZ28gPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdvO1xyXG5cclxuICAgICAgICB9Y2F0Y2goZXgpe1xyXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYExvYWQgc3ByaXRlIDoke2FkZHJlc3N9IDogJHtleH1gKVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgcmVsZWFzZUFkZHJlc3NHTyhnbzphbnkpe1xyXG5cclxuICAgICAgICBOaWNlVFMuUmVzb3VyY2VNYW5hZ2VyLlJlbGVhc2VBZGRyZXNzR08oZ28pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBcclxufSIsIlxyXG5cclxuZXhwb3J0IGNsYXNzIFNpbmdsZXRvbjxUPntcclxuXHJcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTphbnkgPSBudWxsO1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgSW5zdGFuY2U8VD4oIGM6IHsgbmV3KCk6IFQgfSApIDogVHtcclxuXHJcbiAgICAgICAgaWYodGhpcy5pbnN0YW5jZSA9PSBudWxsKXtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBjKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgeyBTdG9yeSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvU3RvcnlcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBJbmtTdGF0ZUluc3BlY3RvcntcblxuICAgIHB1YmxpYyBCaW5kSW5rTWV0aG9kcyhpbmtTdG9yeTpTdG9yeSk6dm9pZHtcbiAgICAgICAgXG4gICAgICAgIC8vM+WPguaVsOS7peS4i+mHh+eUqOatpOaWueW8j1xuICAgICAgICB0aGlzLmJpbmRJbmtNZXRob2RPbmNlKGlua1N0b3J5LFwiR2V0Q2hhcmFjdGVyTmFtZVwiLHRoaXMuZ2V0Q2hhcmFjdGVyTmFtZSk7XG4gICAgICAgIC8vM+WPguaVsOS7peS4iumHh+eUqOatpOaWueW8jyBcbiAgICAgICAgdGhpcy5iaW5kSW5rTWV0aG9kT25jZUdlbmVyYWwoaW5rU3RvcnksXCJHZXRDaGFyYWN0ZXJOYW1lQnlNdXRpUGFyYW1zXCIsdGhpcy5nZXRDaGFyYWN0ZXJOYW1lTXV0aVBhcmFtcyk7XG4gICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDaGFyYWN0ZXJOYW1lKCk6c3RyaW5ne1xuICAgICAgICByZXR1cm4gXCJKdXN0aW4gVGVzdCBQdWVydHNcIjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldENoYXJhY3Rlck5hbWVNdXRpUGFyYW1zKHAxOm51bWJlcixwMjpudW1iZXIscDM6bnVtYmVyKTpzdHJpbmd7XG4gICAgICAgIHJldHVybiBcIkp1c3RpbiBNdXRpIFBhcmFtc1wiO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBiaW5kSW5rTWV0aG9kT25jZShpbmtTdG9yeTpTdG9yeSxmdW5jTmFtZTpzdHJpbmcsZnVuYzpTdG9yeS5FeHRlcm5hbEZ1bmN0aW9uKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaW5rU3RvcnkuQmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUsIGZ1bmMpO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgcHJpdmF0ZSBiaW5kSW5rTWV0aG9kT25jZUdlbmVyYWwoaW5rU3Rvcnk6U3RvcnksIGZ1bmNOYW1lOnN0cmluZyxmdW5jOlN0b3J5LkV4dGVybmFsRnVuY3Rpb24pe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBpbmtTdG9yeS5CaW5kRXh0ZXJuYWxGdW5jdGlvbkdlbmVyYWwoZnVuY05hbWUsIGZ1bmMpO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH0gICAgIFxuICAgIH1cblxuICAgIHB1YmxpYyB1bmJpbmRJbmtNZXRob2QoaW5rU3Rvcnk6U3RvcnksZnVuY05hbWU6c3RyaW5nKXtcbiAgICAgICAgXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIGlua1N0b3J5LlVuYmluZEV4dGVybmFsRnVuY3Rpb24oZnVuY05hbWUpO1xuICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKGVycik7XG4gICAgICAgIH0gICAgIFxuICAgIH1cbn0iLCJpbXBvcnQgeyBTdG9yeSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvU3RvcnlcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5pbXBvcnQgeyBJbmtTdGF0ZUluc3BlY3RvciB9IGZyb20gXCIuL0lua1N0YXRlSW5zcGVjdG9yXCI7XG5pbXBvcnQgeyBTdG9yeU1lc3NhZ2VNYW5hZ2VyIH0gZnJvbSBcIi4vU3RvcnlNZXNzYWdlTWFuYWdlclwiO1xuXG5leHBvcnQgY2xhc3MgSW5rV3JpdGVye1xuXG4gICAgcHVibGljIHN0YXRpYyBERUJVR19TVE9SWV9JRDpzdHJpbmcgPSBcIkRFQlVHX1NUT1JZXCI7XG4gICAgcHVibGljIHN0YXRpYyBDT01NQU5EX1BSRUZJWDpzdHJpbmcgPSBcIj4+PlwiO1xuICAgIHB1YmxpYyBzdGF0aWMgQ09NTUFORF9ERUxJTUlURVI6c3RyaW5nID0gXCI6XCI7XG4gICAgcHVibGljIHN0YXRpYyBDT01NQU5EX0FSR19ERUxJTUlURVI6c3RyaW5nID0gJywnO1xuXG4gICAgcHJpdmF0ZSBfY3VycmVudFN0b3J5OlN0b3J5O1xuICAgIHByaXZhdGUgX2FsbElua0NvbW1hbmRzOk1hcDxzdHJpbmcsRnVuY3Rpb24+ID0gbmV3IE1hcDxzdHJpbmcsRnVuY3Rpb24+KCk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHN0b3J5SnNvbjpzdHJpbmcpe1xuICAgICAgICB0aGlzLnNldHVwSW5rQ29tbWFuZHMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTdHJveShzdG9yeUpzb24pO1xuICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbG9hZCgpOnZvaWR7XG4gICAgICAgIGxldCBzdG9yeVN0YXRlOnN0cmluZyA9IFwiXCI7XG4gICAgICAgIGlmKHN0b3J5U3RhdGUhPW51bGwgJiYgc3RvcnlTdGF0ZSE9XCJcIil7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3Rvcnkuc3RhdGUuTG9hZEpzb24oc3RvcnlTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVN0cm95KGpzb246c3RyaW5nKXtcbiAgICAgICAgdGhpcy5fY3VycmVudFN0b3J5ID0gbmV3IFN0b3J5KGpzb24pO1xuXG4gICAgICAgXG4gICAgfVxuXG4gICAgcHVibGljIGJlZ2luU3Rvcnkoa25vdE5hbWU6c3RyaW5nKXtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJUcnlpbmcgdG8gQWR2YW5jZVN0b3J5IGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWVuIGNyZWF0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuQ2hvb3NlUGF0aFN0cmluZyhrbm90TmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgIGxldCBpbmtTdGF0ZTpJbmtTdGF0ZUluc3BlY3RvciA9IG5ldyBJbmtTdGF0ZUluc3BlY3RvcigpO1xuICAgICAgICAgaW5rU3RhdGUuQmluZElua01ldGhvZHModGhpcy5fY3VycmVudFN0b3J5KTtcblxuICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBnaXZlUmV3YXJkKCk6Ym9vbGVhbntcbiAgICAgICAgTG9nZ2VyLmxvZyhcImdpdmUgcmV3YXJkLi4uXCIpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0dXBJbmtDb21tYW5kcygpOnZvaWR7XG4gICAgICAgIHRoaXMuX2FsbElua0NvbW1hbmRzLnNldChcIkdJVkVfUkVXQVJEXCIsdGhpcy5naXZlUmV3YXJkKVxuICAgIH1cblxuICAgIHByaXZhdGUgaGFuZGxlQ29tbWFuZChjb21tYW5kOnN0cmluZywgYXJnczpzdHJpbmdbXSk6Ym9vbGVhbntcbiAgICAgICAgaWYodGhpcy5fYWxsSW5rQ29tbWFuZHMuaGFzKGNvbW1hbmQpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hbGxJbmtDb21tYW5kcy5nZXQoY29tbWFuZCkoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLmVycm9yKFwiQ291bGQgbm90IGZpbmQgSW5rQ29tbWFuZCB3aXRoIG5hbWU6XCIrY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGFyc2VDb21tYW5kTmFtZSh0ZXh0OnN0cmluZyk6c3RyaW5ne1xuICAgICAgICBsZXQgbnVtOm51bWJlciA9IHRleHQuaW5kZXhPZihJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpO1xuICAgICAgICBsZXQgbnVtMjpudW1iZXIgPSB0ZXh0LmluZGV4T2YoSW5rV3JpdGVyLkNPTU1BTkRfREVMSU1JVEVSKTtcbiAgICAgICAgaWYobnVtMiA9PSAtMSl7XG4gICAgICAgICAgICBudW0yID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVuZ3RoOm51bWJlciA9IG51bTIgLSAobnVtICsgSW5rV3JpdGVyLkNPTU1BTkRfUFJFRklYLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cihudW0gKyBJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgubGVuZ3RoLCBsZW5ndGgpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcGFyc2VDb21tYW5kQXJncyh0ZXh0OnN0cmluZyk6c3RyaW5nW117XG4gICAgICAgIGxldCBudW06bnVtYmVyID0gdGV4dC5pbmRleE9mKElua1dyaXRlci5DT01NQU5EX0RFTElNSVRFUik7XG4gICAgICAgIGlmKG51bSA9PSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbmd0aDpudW1iZXIgPSB0ZXh0Lmxlbmd0aCAtIChudW0gKyAxKTtcbiAgICAgICAgbGV0IGxpc3Q6c3RyaW5nW10gPSB0ZXh0LnN1YnN0cihudW0rMSwgbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltKCkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXQoSW5rV3JpdGVyLkNPTU1BTkRfQVJHX0RFTElNSVRFUik7XG4gICAgICAgIGZvciAobGV0IGk6bnVtYmVyPTA7IGk8bGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGlzdFtpXSA9IGxpc3RbaV0udHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cblxuICAgIHB1YmxpYyBleHRyYWN0U3BlYWtlcihsaW5lOnN0cmluZyk6W3N0cmluZyxzdHJpbmdde1xuICAgICAgICBpZihsaW5lLnN0YXJ0c1dpdGgoSW5rV3JpdGVyLkNPTU1BTkRfUFJFRklYKSl7XG4gICAgICAgICAgICByZXR1cm4gW1wiMFwiLGxpbmUudHJpbSgpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhcnJheTpzdHJpbmdbXSA9IGxpbmUuc3BsaXQoJzonLDIpO1xuICAgICAgICBpZihhcnJheS5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgIGxldCBzcGVha0lEOnN0cmluZyA9IGFycmF5WzBdLnRyaW0oKTtcbiAgICAgICAgICAgIGxldCBzcGVha0NvbnRlbnQ6c3RyaW5nID0gYXJyYXlbMV0udHJpbSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW3NwZWFrSUQsIHNwZWFrQ29udGVudF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1wiMFwiLGxpbmUudHJpbSgpXTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2F2ZUN1cnJlbnRTdG9yeSgpOnZvaWR7XG4gICAgICAgIGxldCBjdXJyU3RhdGUgPSB0aGlzLl9jdXJyZW50U3Rvcnkuc3RhdGUudG9Kc29uKCk7XG4gICAgICAgIC8vVE9ET++9k++9ge+9lu+9hVxuICAgIH1cblxuICAgIHB1YmxpYyBjYW5Db250aW51ZSgpOmJvb2xlYW57XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RvcnkuY2FuQ29udGludWU7XG4gICAgfVxuXG4gICAgcHVibGljIGFkdmFuY2VTdG9yeSgpOnZvaWR7XG4gICAgICAgIGlmKHRoaXMuX2N1cnJlbnRTdG9yeSA9PSBudWxsKXtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKFwiVHJ5aW5nIHRvIEFkdmFuY2VTdG9yeSBpbiBJbmtXcml0ZXIgd2hlbiBubyBzdG9yeSBoYXMgYmVlbiBjcmVhdGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYodGhpcy5fY3VycmVudFN0b3J5LmNhbkNvbnRpbnVlKXtcbiAgICAgICAgICAgIGxldCB0ZXh0OnN0cmluZyA9IHRoaXMuX2N1cnJlbnRTdG9yeS5Db250aW51ZSgpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmKHRleHQgPT0gXCJcIil7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RvcnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHNwZWFrSUQ6c3RyaW5nO1xuICAgICAgICAgICAgbGV0IHNwZWFrQ29udGVudDpzdHJpbmc7XG5cbiAgICAgICAgICAgIFtzcGVha0lELCBzcGVha0NvbnRlbnRdID0gdGhpcy5leHRyYWN0U3BlYWtlcih0ZXh0KTtcblxuICAgICAgICAgICAgbGV0IGNvbW1hbmROYW1lOnN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgYXJnczpzdHJpbmdbXSA9IG51bGw7XG4gICAgICAgICAgICBpZihzcGVha0NvbnRlbnQuc3RhcnRzV2l0aChJbmtXcml0ZXIuQ09NTUFORF9QUkVGSVgpKXtcbiAgICAgICAgICAgICAgICBjb21tYW5kTmFtZSA9IHRoaXMucGFyc2VDb21tYW5kTmFtZShzcGVha0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnBhcnNlQ29tbWFuZEFyZ3Moc3BlYWtDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZihjb21tYW5kTmFtZSAhPSBudWxsICYmIGNvbW1hbmROYW1lICE9XCJcIil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaGFuZGxlQ29tbWFuZChjb21tYW5kTmFtZSwgYXJncykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlU3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vT25Db250ZW50UmVhZHlcbiAgICAgICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWVzc2FnZU1hbmFnZXIpLmJyb2FkY2FzdENvbnRlbnRSZWFkeShcbiAgICAgICAgICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNPTlRFTlRSRUFEWSxcbiAgICAgICAgICAgICAgICAgICAgc3BlYWtDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBzcGVha0lELFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuY3VycmVudFRhZ3MsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZih0aGlzLl9jdXJyZW50U3RvcnkuY3VycmVudENob2ljZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAvL09uQ2hvaWNlc1ByZXNlbnRlZFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5icm9hZGNhc3RDaG9pY2VzUHJlc2VudGVkKFxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DSE9JQ0VTUFJFU0VOVEVELFxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdG9yeS5jdXJyZW50Q2hvaWNlc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAvL09uU3RvcnlGaW5pc2hlZFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5JbnN0YW5jZShTdG9yeU1lc3NhZ2VNYW5hZ2VyKS5icm9hZGNhc3RTdG9yeUZpbmlzaGVkKFxuICAgICAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05TVE9SWUZJTklTSEVEXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgc2VsZWN0Q2hvaWNlKGNob2ljZUluZGV4Om51bWJlcik6dm9pZHtcbiAgICAgICAgaWYodGhpcy5fY3VycmVudFN0b3J5ID09IG51bGwpe1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJUcnlpbmcgdG8gQ2hvb3NlQ2hvaWNlIGluIElua1dyaXRlciB3aGVuIG5vIHN0b3J5IGhhcyBiZWd1blwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkuQ2hvb3NlQ2hvaWNlSW5kZXgoY2hvaWNlSW5kZXgpO1xuICAgICAgICB0aGlzLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nKTphbnl7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RvcnkudmFyaWFibGVzU3RhdGUuR2V0VmFyaWFibGVXaXRoTmFtZSh2YXJpYWJsZU5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWU6c3RyaW5nLCB2YWx1ZTphbnkpe1xuICAgICAgICB0aGlzLl9jdXJyZW50U3RvcnkudmFyaWFibGVzU3RhdGUuJCh2YXJpYWJsZU5hbWUsIHZhbHVlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hvaWNlIH0gZnJvbSBcImlua2pzL2VuZ2luZS9DaG9pY2VcIjtcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tIFwiLi4vY29tbW9uL1Jlc01hbmFnZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBJbmtXcml0ZXIgfSBmcm9tIFwiLi9JbmtXcml0ZXJcIjtcblxuZXhwb3J0IGNsYXNzIFN0b3J5TWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxTdG9yeU1hbmFnZXI+e1xuXG4gICAgcHJpdmF0ZSBfaW5rV3JpdGVyOklua1dyaXRlcjtcbiAgICBwcml2YXRlIHN0b3J5QWRkcmVzczpzdHJpbmcgPSBcIlN0b3J5L1Rlc3RTdG9yeS5qc29uXCI7XG5cbiAgICBwdWJsaWMgZ2V0IGlua1dyaXRlcigpOklua1dyaXRlcntcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lua1dyaXRlcjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBpbml0aWFsaXplKCl7XG5cbiAgICAgICAgaWYodGhpcy5faW5rV3JpdGVyID09IG51bGwpe1xuXG4gICAgICAgICAgICB2YXIganNvbiA9ICAoYXdhaXQgUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKS5sb2FkVGV4dEFzc2V0KHRoaXMuc3RvcnlBZGRyZXNzKSkudGV4dDtcbiAgICAgICAgICAgIHRoaXMuX2lua1dyaXRlciA9IG5ldyBJbmtXcml0ZXIoanNvbik7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBiZWdpblN0b3J5KGtub3ROYW1lOnN0cmluZyk6dm9pZHtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLmJlZ2luU3Rvcnkoa25vdE5hbWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYW5Db250aW51ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyLmNhbkNvbnRpbnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhZHZhbmNlU3RvcnkoKXtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLmFkdmFuY2VTdG9yeSgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZWxlY3RDaG9pY2UoY2hvaWNlOkNob2ljZSk6dm9pZHtcbiAgICAgICAgdGhpcy5faW5rV3JpdGVyLnNlbGVjdENob2ljZShjaG9pY2UuaW5kZXgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBsb2FkQ3VycmVudCgpOnZvaWR7XG4gICAgICAgIGlmKHRoaXMuX2lua1dyaXRlciE9bnVsbCkgdGhpcy5faW5rV3JpdGVyLmxvYWQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0VmFyaWFibGUodmFyaWFibGVOYW1lOnN0cmluZyk6YW55e1xuICAgICAgICByZXR1cm4gdGhpcy5faW5rV3JpdGVyLmdldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZTpzdHJpbmcsIHZhbHVlOmFueSl7XG4gICAgICAgIHRoaXMuaW5rV3JpdGVyLnNldFZhcmlhYmxlKHZhcmlhYmxlTmFtZSwgdmFsdWUpO1xuICAgIH1cblxufSIsImltcG9ydCB7IENob2ljZSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvQ2hvaWNlXCI7XG5pbXBvcnQgeyBNZXNzZW5nZXIgfSBmcm9tIFwiLi4vY29tbW9uL01lc3NlbmdlclwiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcblxuZXhwb3J0IGNsYXNzIFN0b3J5TWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBTaW5nbGV0b248U3RvcnlNZXNzYWdlTWFuYWdlcj57XG5cbiAgICBwdWJsaWMgc3RhdGljIE9OQ09OVEVOVFJFQURZOm51bWJlciA9IDEwMDE7XG4gICAgcHVibGljIHN0YXRpYyBPTkNIT0lDRVNQUkVTRU5URUQ6bnVtYmVyID0gMTAwMjtcbiAgICBwdWJsaWMgc3RhdGljIE9OU1RPUllGSU5JU0hFRDpudW1iZXIgPSAxMDAzO1xuXG4gICAgcHJpdmF0ZSBzdG9yeU1lc3NhZ2U6TWVzc2VuZ2VyID0gbmV3IE1lc3NlbmdlcigpO1xuXG5cbiAgICBwdWJsaWMgYWRkTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsb2JqOmFueSwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuXG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmFkZExpc3RlbmVyKG1zZ0NvZGUsIG9iaiwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lcihtc2dDb2RlOm51bWJlciwgbGlzdGVuZXI6RnVuY3Rpb24pe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5yZW1vdmVMaXN0ZW5lcihtc2dDb2RlLCBsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgcHVibGljIHJlbW92ZUxpc3RlbmVyQnlDb2RlKG1zZ0NvZGU6bnVtYmVyKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXJCeVR5cGUobXNnQ29kZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFydXAoKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuY2xlYXJ1cCgpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RDb250ZW50UmVhZHkoXG4gICAgICAgIG1zZ0NvZGU6bnVtYmVyLFxuICAgICAgICBzcGVha2VyQ29udGVudDpzdHJpbmcsXG4gICAgICAgIHNwZWFrZXJJZDpzdHJpbmcsXG4gICAgICAgIGN1cnJlbnRUYWdzOnN0cmluZ1tdLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXVxuICAgICAgICApXG4gICAge1xuXG4gICAgICAgIHRoaXMuc3RvcnlNZXNzYWdlLmJyb2FkY2FzdChtc2dDb2RlLCBzcGVha2VyQ29udGVudCxzcGVha2VySWQsY3VycmVudFRhZ3MsY3VycmVudENob2ljZXMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBicm9hZGNhc3RDaG9pY2VzUHJlc2VudGVkKFxuICAgICAgICBtZXNnQ29kZTpudW1iZXIsXG4gICAgICAgIGN1cnJlbnRDaG9pY2VzOkNob2ljZVtdXG4gICAgKXtcbiAgICAgICAgdGhpcy5zdG9yeU1lc3NhZ2UuYnJvYWRjYXN0KG1lc2dDb2RlLGN1cnJlbnRDaG9pY2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0U3RvcnlGaW5pc2hlZChtZXNnQ29kZTpudW1iZXIpe1xuICAgICAgICB0aGlzLnN0b3J5TWVzc2FnZS5icm9hZGNhc3QobWVzZ0NvZGUpOyAgIFxuICAgIH1cbn0iLCJpbXBvcnQgeyBVbml0eUVuZ2luZSB9IGZyb20gJ2NzaGFycCc7XG5pbXBvcnQgeyBHYW1lQ29uZmlnIH0gZnJvbSAnLi4vLi4vZ2xvYmFsL0dhbWVDb25maWcnO1xuZW51bSBMb2dUeXBlIHtcblx0RXJyb3IgPSAwLFxuXHRBc3NlcnQgPSAxLFxuXHRXYXJuaW5nID0gMixcblx0TG9nID0gMyxcblx0RXhjZXB0aW9uID0gNFxufVxuXG5leHBvcnQgY2xhc3MgTG9nZ2Vye1xuICAgIHByaXZhdGUgIHN0YXRpYyAgdW5pdHlfbG9nX3RhcmdldCA9IG51bGw7XG5cbiAgICBzdGF0aWMgZ2V0UHJpbnRTdGFjayh0eXBlOiBMb2dUeXBlLCBzaG93U3RhY2sgOiBib29sZWFuLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGFyZ3NbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIExvZ2dlci5MT0dfT0JKRUNUX1RPX0pTT04pIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IGFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmIChzaG93U3RhY2sgfHwgVW5pdHlFbmdpbmUuQXBwbGljYXRpb24uaXNFZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdGFja3MgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMzsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBzdGFja3NbaV07XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSAnXFxuJztcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCFMb2dnZXIudW5pdHlfbG9nX3RhcmdldCkge1xuICAgICAgICAgICAgTG9nZ2VyLnVuaXR5X2xvZ190YXJnZXQgPSBuZXcgVW5pdHlFbmdpbmUuT2JqZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbiAgICBcblxuXHRzdGF0aWMgbG9nKC4uLmFyZ3MpOiB2b2lke1xuICAgICAgICBpZighR2FtZUNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuXG4gICAgICAgIGxldCBtc2cgPSBMb2dnZXIuZ2V0UHJpbnRTdGFjayhMb2dUeXBlLkxvZywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBPdXRwdXRzIGEgd2FybmluZyBtZXNzYWdlIHRvIHRoZSBMb2dnZXIuXG5cdCAqIEBwYXJhbSBtZXNzYWdlICBsaXN0IG9mIEphdmFTY3JpcHQgb2JqZWN0cyB0byBvdXRwdXQuIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25zIG9mIGVhY2ggb2YgdGhlc2Ugb2JqZWN0cyBhcmUgYXBwZW5kZWQgdG9nZXRoZXIgaW4gdGhlIG9yZGVyIGxpc3RlZCBhbmQgb3V0cHV0LlxuXHQgKi9cblx0c3RhdGljIHdhcm4oLi4uYXJncyk6IHZvaWR7XG4gICAgICAgIGlmKCFHYW1lQ29uZmlnLmRlYnVnKSByZXR1cm47XG5cbiAgICAgICAgbGV0IG1zZyA9IExvZ2dlci5nZXRQcmludFN0YWNrKExvZ1R5cGUuV2FybmluZywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgIH1cblxuXHQvKipcblx0ICogT3V0cHV0cyBhbiBlcnJvciBtZXNzYWdlIHRvIHRoZSBMb2dnZXIuXG5cdCAqIEBwYXJhbSBtZXNzYWdlIEEgbGlzdCBvZiBKYXZhU2NyaXB0IG9iamVjdHMgdG8gb3V0cHV0LiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9ucyBvZiBlYWNoIG9mIHRoZXNlIG9iamVjdHMgYXJlIGFwcGVuZGVkIHRvZ2V0aGVyIGluIHRoZSBvcmRlciBsaXN0ZWQgYW5kIG91dHB1dC5cblx0ICovXG5cdHN0YXRpYyBlcnJvciguLi5hcmdzKTogdm9pZHtcbiAgICAgICAgaWYoIUdhbWVDb25maWcuZGVidWcpIHJldHVybjtcblxuICAgICAgICBsZXQgbXNnID0gTG9nZ2VyLmdldFByaW50U3RhY2soTG9nVHlwZS5FcnJvciwgdHJ1ZSwgYXJncyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICB9XG5cblx0LyoqIE91dHB1dHMgYSBzdGFjayB0cmFjZSB0byB0aGUgTG9nZ2VyLlxuXHQgKiBAcGFyYW0gbWVzc2FnZSBBIGxpc3Qgb2YgSmF2YVNjcmlwdCBvYmplY3RzIHRvIG91dHB1dC4gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbnMgb2YgZWFjaCBvZiB0aGVzZSBvYmplY3RzIGFyZSBhcHBlbmRlZCB0b2dldGhlciBpbiB0aGUgb3JkZXIgbGlzdGVkIGFuZCBvdXRwdXQuXG5cdCovXG5cdHN0YXRpYyB0cmFjZSguLi5hcmdzKTogdm9pZHtcbiAgICAgICAgaWYoIUdhbWVDb25maWcuZGVidWcpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIGxldCBtc2cgPSBMb2dnZXIuZ2V0UHJpbnRTdGFjayhMb2dUeXBlLkxvZywgdHJ1ZSwgYXJncyk7XG4gICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgfVxuXG5cdC8qKiBMb2cgSmF2YVNjcmlwdCBPYmplY3RzIGFzIEpTT04gZm9ybWF0ICovXG5cdHN0YXRpYyBMT0dfT0JKRUNUX1RPX0pTT04oLi4uYXJncyk6IGJvb2xlYW57XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxufSIsImltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XHJcbmltcG9ydCB7IE9wY29kZSB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL09wY29kZVwiO1xyXG5pbXBvcnQgeyBOZXRFcnJvckNvZGUgfSBmcm9tIFwiLi9OZXRFcnJvckNvZGVcIjtcclxuaW1wb3J0IHsgTmljZVRTIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBNZXNzYWdlUGFyc2VyIH0gZnJvbSBcIi4vTWVzc2FnZVBhcnNlclwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBNc2dQYWNre1xyXG4gICAgcHVibGljIHNlbmRUaW1lOm51bWJlcjtcclxuICAgIHB1YmxpYyBjYWxsYmFjazpGdW5jdGlvbjtcclxuICAgIHB1YmxpYyByZXRyeVRpbWVzOm51bWJlciA9IDA7XHJcbiAgICBwdWJsaWMgYnl0ZXM6VWludDhBcnJheTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhbWVTZXNzaW9uIGV4dGVuZHMgU2luZ2xldG9uPEdhbWVTZXNzaW9uPntcclxuXHJcbiAgICBwdWJsaWMgaWQ6bnVtYmVyID0gMDsgIC8vc2Vzc2lvbiBJRFxyXG4gICAgcHJpdmF0ZSByZVNlbmRJbnRlcnZhbDpudW1iZXIgPSAxMDAwMDsgLy8xMOenkumHjeWPkeS4gOasoVxyXG4gICAgcHJpdmF0ZSB0aW1lb3V0SW50ZXJ2YWw6bnVtYmVyID0gNTAwMDsgLy8156eS5qOA5p+l5LiA5qyh5piv5ZCm6LaF5pe2XHJcbiAgICBwcml2YXRlIG1heFJlU2VuZFRpbWVzOm51bWJlciA9IDU7IC8v5pyA5aSn6YeN5Y+R5qyh5pWwXHJcbiAgICBwcml2YXRlIHRpbWVvdXRJaW1lcjphbnk7XHJcblxyXG4gICAgcHJpdmF0ZSBfcnBjSWQ6bnVtYmVyID0gMTtcclxuICAgIHByaXZhdGUgY2hhbm5lbDphbnk7XHJcbiAgICBwcml2YXRlIHJlcXVlc3RDYWxsYmFjazpNYXA8bnVtYmVyLE1zZ1BhY2s+ID0gbmV3IE1hcDxudW1iZXIsTXNnUGFjaz4oKTtcclxuICAgIHByaXZhdGUgbGlzdGVuZXJzOk1hcDxudW1iZXIsRnVuY3Rpb24+ID0gbmV3IE1hcDxudW1iZXIsRnVuY3Rpb24+KCk7XHJcblxyXG4gICAgLy/ov5Tlm57nmoTmnI3liqHlmahJRCwg57G75Z6LXHJcbiAgICBwcml2YXRlIF9zZXJ2ZXJJZDpudW1iZXIgPSAtMTtcclxuICAgIHByaXZhdGUgX3NlcnZlclR5cGU6bnVtYmVyID0gMTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBycGNJZCgpOm51bWJlcntcclxuICAgICAgICByZXR1cm4gKyt0aGlzLl9ycGNJZDtcclxuICAgIH1cclxuXHJcbiAgICAvL2FkZHJlc3MtPiBpcDpwb3J0XHJcbiAgICBwdWJsaWMgY29ubmVjdENoYW5uZWwoYWRkcmVzczpzdHJpbmcsIGNvbm5DYWJhY2s6YW55KXtcclxuXHJcbiAgICAgICAgdGhpcy5jaGFubmVsID0gTmljZVRTLlRTZXJ2aWNlLkluc3RhbmNlLkdldENoYW5uZWwoKTtcclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmNoYW5uZWwuZXJyb3JDYWxsYmFjayA9IChjaGFubmVsOmFueSwgY29kZTpudW1iZXIpPT57XHJcbiAgICAgICAgICAgIGlmKGNvZGUgPT0gTmV0RXJyb3JDb2RlLkVSUl9Tb2NrZXRDb25uU3VjYyl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJaW1lciA9IHNldEludGVydmFsKCgpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1RpbWVvdXRNc2coKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMudGltZW91dEludGVydmFsKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29ubkNhYmFjayhjaGFubmVsLCBjb2RlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5yZWFkQ2FsbGJhY2sgPSAoYnVmZmVyOlVpbnQ4QXJyYXkpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25SZWNlaXZlKGJ1ZmZlcik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLkNvbm5lY3QoYWRkcmVzcyk7XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5o6l5pS25pyN5Yqh5Zmo6YCa55+lXHJcbiAgICBwdWJsaWMgbGlzdGVuKG9wY29kZTpudW1iZXIsY2FsbGJhY2s6RnVuY3Rpb24pe1xyXG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnNldChvcGNvZGUsIGNhbGxiYWNrKTtcclxuICAgIH1cclxuXHJcbiAgICAvL+WPkemAgXByb3RvdWJm5raI5oGvXHJcbiAgICAvL+a2iOaBr++8miBycGNfaWRbNF0gLSBvcGNvZGVbMl0gLSBzZXJ2ZXJfaWRbMl0gLSBzZXJ2ZXJfdHlwZVsxXSAtIFxyXG4gICAgcHVibGljIHNlbmQob3Bjb2RlOm51bWJlcixycGNpZDpudW1iZXIsIG1lc3NhZ2U6VWludDhBcnJheSwgY2FsbEJhY2s6RnVuY3Rpb24pe1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8v5bCB6KOF5raI5oGv77yaXHJcbiAgICAgICAgbGV0IHJwY0J1ZjpVaW50OEFycmF5ID0gTWVzc2FnZVBhcnNlci5lbmNvZGVJbnQocnBjaWQpOyAvLzRcclxuICAgICAgICBsZXQgb3Bjb2RlQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZVNob3J0KG9wY29kZSk7IC8vMlxyXG4gICAgICAgIGxldCBzZXJ2ZXJpZEJ1ZjpVaW50OEFycmF5ID0gTWVzc2FnZVBhcnNlci5lbmNvZGVTaG9ydCh0aGlzLl9zZXJ2ZXJJZCk7IC8vMlxyXG4gICAgICAgIGxldCBzZXJ2ZXJ0eXBlQnVmOlVpbnQ4QXJyYXkgPSBNZXNzYWdlUGFyc2VyLmVuY29kZUJ5dGUodGhpcy5fc2VydmVyVHlwZSk7IC8vMVxyXG5cclxuXHJcbiAgICAgICAgbGV0IHNlbmRBcnJheTpVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoNCArIDIgKyAyICsgMSArbWVzc2FnZS5sZW5ndGgpO1xyXG4gICAgICAgIHNlbmRBcnJheS5zZXQocnBjQnVmKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KG9wY29kZUJ1ZiwgICAgNCk7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChzZXJ2ZXJpZEJ1ZiwgIDQgKyAyKTtcclxuICAgICAgICBzZW5kQXJyYXkuc2V0KHNlcnZlcnR5cGVCdWYsIDQgKyAyICsgMik7XHJcbiAgICAgICAgc2VuZEFycmF5LnNldChtZXNzYWdlLCAgICAgICA0ICsgMiArIDIgKyAxKTtcclxuICAgICAgICBcclxuICAgICAgICBpZihjYWxsQmFjayAhPSBudWxsKXtcclxuICAgICAgICAgICAgbGV0IG1zZ1BhY2s6TXNnUGFjayA9IG5ldyBNc2dQYWNrKCk7XHJcbiAgICAgICAgICAgIG1zZ1BhY2suc2VuZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgbXNnUGFjay5jYWxsYmFjayA9IGNhbGxCYWNrO1xyXG4gICAgICAgICAgICBtc2dQYWNrLmJ5dGVzID0gc2VuZEFycmF5O1xyXG5cclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2FsbGJhY2suc2V0KHJwY2lkLCBtc2dQYWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZm9yKGxldCBpIGluIHNlbmRBcnJheSl7XHJcbiAgICAgICAgLy8gICAgIExvZ2dlci5sb2coXCJUUyAtLSBzZW5kIGFycmF5OiBcIitpKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy9Mb2dnZXIubG9nKFwic2VuZCBhcnJheTogXCIrc2VuZEFycmF5KTtcclxuICAgICAgICB0aGlzLmNoYW5uZWwuU2VuZChzZW5kQXJyYXkpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVTZW5kKGJ5dGVzOlVpbnQ4QXJyYXkpe1xyXG4gICAgICAgIHRoaXMuY2hhbm5lbC5TZW5kKGJ5dGVzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25SZWNlaXZlKGJ1ZmZlcjpVaW50OEFycmF5KXtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbXNnQnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcclxuXHJcbiAgICAgICAgbGV0IHJwY2lkID0gTWVzc2FnZVBhcnNlci5kZWNvZGVJbnQobXNnQnVmLnN1YmFycmF5KDAsNCkpO1xyXG4gICAgICAgIGxldCBvcGNvZGUgPSBNZXNzYWdlUGFyc2VyLmRlY29kZVNob3J0KG1zZ0J1Zi5zdWJhcnJheSg0LDYpKTtcclxuICAgICAgICBsZXQgc2VydmVyaWQgPSBNZXNzYWdlUGFyc2VyLmRlY29kZVNob3J0KG1zZ0J1Zi5zdWJhcnJheSg2LDgpKTtcclxuICAgICAgICBsZXQgc2VydmVydHlwZSA9IE1lc3NhZ2VQYXJzZXIuZGVjb2RlQnl0ZShtc2dCdWYuc3ViYXJyYXkoOCw5KSk7XHJcblxyXG4gICAgICAgIHRoaXMuX3NlcnZlcklkID0gc2VydmVyaWQ7XHJcbiAgICAgICAgdGhpcy5fc2VydmVyVHlwZSA9IHNlcnZlcnR5cGU7XHJcblxyXG4gICAgICAgIGxldCBtc2dCeXRlczpVaW50OEFycmF5ID0gbXNnQnVmLnN1YmFycmF5KDkpO1xyXG5cclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICAgIGxldCBkZWNvZGVNc2cgPSAgT3Bjb2RlLmRlY29kZShvcGNvZGUsIG1zZ0J5dGVzKTtcclxuXHJcblxyXG4gICAgICAgICAgICBpZihycGNpZD09dW5kZWZpbmVkIHx8ICF0aGlzLnJlcXVlc3RDYWxsYmFjay5oYXMocnBjaWQpKXtcclxuICAgICAgICAgICAgICAgIC8v5qOA5p+l5piv5ZCm5piv5pyN5Yqh5Zmo5LiL5Y+R55qE5raI5oGvXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmxpc3RlbmVycy5oYXMob3Bjb2RlKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpc3RlbiA9IHRoaXMubGlzdGVuZXJzLmdldChvcGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbihkZWNvZGVNc2cubXNnT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgIFxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIGxldCBtc2dQYWNrOk1zZ1BhY2sgPSB0aGlzLnJlcXVlc3RDYWxsYmFjay5nZXQocnBjaWQpO1xyXG4gICAgICAgICAgICAgICAgbXNnUGFjay5jYWxsYmFjayhkZWNvZGVNc2cubXNnT2JqKTsgIFxyXG4gICAgXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5kZWxldGUocnBjaWQpO1xyXG4gICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9Y2F0Y2goZSl7XHJcbiAgICAgICAgICAgIExvZ2dlci5lcnJvcihcInBhcnNlIG1zZyBlcnJvciwgb3Bjb2RlOlwiK29wY29kZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY2hlY2tUaW1lb3V0TXNnKCl7XHJcblxyXG4gICAgICAgIGxldCBjdXJyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgICAgICB0aGlzLnJlcXVlc3RDYWxsYmFjay5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PntcclxuXHJcbiAgICAgICAgICAgIGlmKHZhbHVlLnJldHJ5VGltZXMgPj0gdGhpcy5tYXhSZVNlbmRUaW1lcykge1xyXG4gICAgICAgICAgICAgICAgLy/otoXov4fmnIDlpKfph43lj5HmrKHmlbDvvIzkuKLlvINcclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coYE1lc3NhZ2UgcmVzZW5kIHRvbyBtb3JlLCBvcGNvZGU6JHtrZXl9LCBsYXN0c2VuZDoke3ZhbHVlLnNlbmRUaW1lfWApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2FsbGJhY2suZGVsZXRlKGtleSk7IFxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgICAgICBpZigoY3VyclRpbWUgLSB2YWx1ZS5zZW5kVGltZSkgPj0gdGhpcy5yZVNlbmRJbnRlcnZhbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUucmV0cnlUaW1lcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNlbmRUaW1lID0gY3VyclRpbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy/ph43lj5Hmtojmga9cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlU2VuZCh2YWx1ZS5ieXRlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmxvZyhgcmVzZW5kIG1lc3NhZ2U6LCBvcGNvZGU6JHtrZXl9LCByZXRyeSB0aW1lczoke3ZhbHVlLnJldHJ5VGltZXN9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGRpc2Nvbm5lY3QoKTp2b2lke1xyXG5cclxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZW91dElpbWVyKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGFubmVsLkRpc3Bvc2UoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IE5pY2VUUyB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7ICRwcm9taXNlIH0gZnJvbSBcInB1ZXJ0c1wiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBIdHRwTWFuYWdlciBleHRlbmRzIFNpbmdsZXRvbjxIdHRwTWFuYWdlcj57XG5cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIFxuICAgIGFzeW5jIGdldCh1cmw6c3RyaW5nKXtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBsZXQgdGFzaz0gTmljZVRTLkh0dHBNYW5hZ2VyLkdldCh1cmwpXG4gICAgICAgICAgICBsZXQgdHh0ID0gYXdhaXQgJHByb21pc2UodGFzayk7XG4gICAgICAgICAgICByZXR1cm4gdHh0O1xuICAgICAgICB9Y2F0Y2goZXgpe1xuXG4gICAgICAgICAgICBMb2dnZXIuZXJyb3IoYEdldCBlcnJvciA6JHt1cmx9IDogJHtleH1gKVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXN5bmMgcG9zdCh1cmw6c3RyaW5nLCBmb3JtOnN0cmluZyl7XG5cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgbGV0IHRhc2s9IE5pY2VUUy5IdHRwTWFuYWdlci5Qb3N0KHVybCwgZm9ybSlcbiAgICAgICAgICAgIGxldCB0eHQgPSBhd2FpdCAkcHJvbWlzZSh0YXNrKTtcbiAgICAgICAgICAgIHJldHVybiB0eHQ7XG5cbiAgICAgICAgfWNhdGNoKGV4KXtcblxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBQb3N0IGVycm9yIDoke3VybH0gOiAke2V4fWApXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCJcbmV4cG9ydCBjbGFzcyBNZXNzYWdlUGFyc2Vye1xuXG5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZUludChuOm51bWJlcik6VWludDhBcnJheXtcblxuICAgICAgICBsZXQgYnVmZmVyOlVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAgICAgYnVmZmVyWzBdID0gbiA+Pj4gMjQ7XG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gPj4+IDE2O1xuICAgICAgICBidWZmZXJbMl0gPSBuID4+PiA4O1xuICAgICAgICBidWZmZXJbM10gPSBuICYgMHhmZjtcblxuICAgICAgICByZXR1cm4gYnVmZmVyXG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkZWNvZGVJbnQoYnVmZmVyOlVpbnQ4QXJyYXkpOm51bWJlcntcbiAgICAgICAgXG4gICAgICAgIGxldCBuID0gYnVmZmVyWzBdIDw8IDI0IHwgYnVmZmVyWzFdIDw8IDE2IHwgYnVmZmVyWzJdIDw8IDggfCBidWZmZXJbM107XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc3RhdGljIGVuY29kZVNob3J0KG46bnVtYmVyKTpVaW50OEFycmF5e1xuXG4gICAgICAgIGxldCBidWZmZXIgOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gICAgICAgIGJ1ZmZlclswXSA9IG4gPj4+IDg7XG4gICAgICAgIGJ1ZmZlclsxXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc3RhdGljIGRlY29kZVNob3J0KGJ1ZmZlcjpVaW50OEFycmF5KTpudW1iZXJ7XG5cbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF0gPDwgOCB8IGJ1ZmZlclsxXTtcblxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZW5jb2RlQnl0ZShuOm51bWJlcik6VWludDhBcnJheXtcblxuICAgICAgICBsZXQgYnVmZmVyIDogVWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgICAgIGJ1ZmZlclswXSA9IG4gJiAweGZmO1xuXG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBkZWNvZGVCeXRlKGJ1ZmZlcjpVaW50OEFycmF5KTpudW1iZXJ7XG5cbiAgICAgICAgbGV0IG4gPSBidWZmZXJbMF07XG5cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuXG5cblxufSIsIlxuXG4gZXhwb3J0IGNsYXNzIE5ldEVycm9yQ29kZVxuIHtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldENvbm5TdWNjOm51bWJlciA9IDEwMDAwMDtcblxuICAgICBwdWJsaWMgc3RhdGljICBFUlJfQ29ubmVjdEdhdGVLZXlFcnJvcjpudW1iZXIgPSAxMDAwMDY7XG5cbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1BlZXJEaXNjb25uZWN0Om51bWJlciAgID0gMTAyMDA4O1xuICAgICBwdWJsaWMgc3RhdGljICBFUlJfU29ja2V0Q2FudFNlbmQ6bnVtYmVyICAgPSAxMDIwMDk7XG4gICAgIHB1YmxpYyBzdGF0aWMgIEVSUl9Tb2NrZXRFcnJvcjpudW1iZXIgICAgICA9IDEwMjAxMDtcbiAgICAgcHVibGljIHN0YXRpYyAgRVJSX1NvY2tldENvbm5FcnJvcjpudW1iZXIgID0gMTAyMDExO1xuXG5cbiAgICAgXG5cbiB9IiwiXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcbmltcG9ydCB7IEdhbWVDb25maWcgfSBmcm9tIFwiLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi9jb21tb24vU2luZ2xldG9uXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vbG9nZ2VyL0xvZ2dlclwiO1xuaW1wb3J0IHsgR2FtZVNlc3Npb24gfSBmcm9tIFwiLi9HYW1lU2Vzc2lvblwiO1xuaW1wb3J0IHsgTmV0RXJyb3JDb2RlIH0gZnJvbSBcIi4vTmV0RXJyb3JDb2RlXCI7XG5cblxuZXhwb3J0IGNsYXNzIFNlc3Npb25NYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFNlc3Npb25NYW5hZ2VyPntcblxuICAgIHByaXZhdGUgc2Vzc2lvblJlYW06R2FtZVNlc3Npb247XG4gICAgcHJpdmF0ZSBzZXNzaW9uR2F0ZTpHYW1lU2Vzc2lvbjtcblxuXG4gICAgcHVibGljIGdldCByZWFsbVJwY0lEKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb25SZWFtLnJwY0lkO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ2F0ZVJwY0lEKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnNlc3Npb25HYXRlLnJwY0lkO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBjb25uZWN0UmVhbG1TZXJ2ZXIoKTpQcm9taXNlPGJvb2xlYW4+IHtcblxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGJvb2xlYW4+KHJlc292ZSA9PntcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYW0gPSBHYW1lU2Vzc2lvbi5JbnN0YW5jZShHYW1lU2Vzc2lvbikuY29ubmVjdENoYW5uZWwoXG4gICAgICAgICAgICAgICAgR2FtZUNvbmZpZy5yZWFsbVNlcnZlcklQK1wiOlwiK0dhbWVDb25maWcucmVhbG1TZXJ2ZXJQb3J0LFxuICAgICAgICAgICAgICAgIChjaGFubmVsOmFueSxjb2RlOm51bWJlcik9PntcbiAgICAgICAgICAgICAgICAgICAgaWYoY29kZSA9PSBOZXRFcnJvckNvZGUuRVJSX1NvY2tldENvbm5TdWNjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYW0uaWQgPSBjaGFubmVsLklkO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvdmUoZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJsb2dpbiByZWFtc2VydmVyIGVyciwgY29kZTogXCIrY29kZSArIFwiLGlkOlwiK2NoYW5uZWwuSWQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZVxuICAgIH1cblxuICAgIFxuICAgIHB1YmxpYyBkaXNjb25uZWN0UmVhbG1TZXJ2ZXIoKXtcbiAgICAgICAgdGhpcy5zZXNzaW9uUmVhbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvblJlYW0gPSBudWxsO1xuICAgIH1cblxuXG4gICAgcHVibGljIGFzeW5jIHNlbmRSZWFsbU1zZyhvcGNvZGU6bnVtYmVyLG1zZzphbnkpOlByb21pc2U8YW55PntcbiAgICAgICAgXG4gICAgICAgIGxldCBycGNJRCA9IHRoaXMuc2Vzc2lvblJlYW0ucnBjSWRcbiAgICAgICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxhbnk+KChyZXNvdmUpID0+IHtcblxuICAgICAgICAgICAgbGV0IGJ1ZiA9IE9wY29kZS5lbmNvZGUob3Bjb2RlLCBtc2cpXG5cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvblJlYW0uc2VuZChvcGNvZGUsIHJwY0lELCBidWYsIChyZXNwb25zZTphbnkpPT57XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXNvdmUocmVzcG9uc2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG5cbiAgICBwdWJsaWMgYXN5bmMgY29ubmVjdEdhdGVTZXJ2ZXIoYWRkcmVzczpzdHJpbmcpOlByb21pc2U8Ym9vbGVhbj57XG5cbiAgICAgICAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxib29sZWFuPihyZXNvdmUgPT57XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25HYXRlID0gR2FtZVNlc3Npb24uSW5zdGFuY2UoR2FtZVNlc3Npb24pLmNvbm5lY3RDaGFubmVsKFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgKGNoYW5uZWw6YW55LGNvZGU6bnVtYmVyKT0+e1xuICAgICAgICAgICAgICAgICAgICBMb2dnZXIubG9nKFwibG9naW4gR2F0ZSBTZXJ2ZXI6IFwiK2NvZGUpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihjb2RlID09IE5ldEVycm9yQ29kZS5FUlJfU29ja2V0Q29ublN1Y2Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZS5pZCA9IGNoYW5uZWwuSWQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3ZlKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb3ZlKGZhbHNlKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZXJyb3IoXCJnYXRlIHNlcnZlciBlcnIsIGNvZGU6IFwiK2NvZGUgKyBcIixpZDpcIitjaGFubmVsLklkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlXG4gICAgfVxuXG5cbiAgICBwdWJsaWMgZGlzY29ubmVjdEdhdGVTZXJ2ZXIoKXtcbiAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZS5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbkdhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBzZW5kR2F0ZU1zZyhvcGNvZGU6bnVtYmVyLCBtc2c6YW55KTpQcm9taXNlPGFueT57XG5cbiAgICAgICAgbGV0IHJwY0lEID0gdGhpcy5zZXNzaW9uR2F0ZS5ycGNJZFxuICAgICAgICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlPGFueT4oKHJlc292ZSkgPT4ge1xuXG4gICAgICAgICAgICBsZXQgYnVmID0gT3Bjb2RlLmVuY29kZShvcGNvZGUsIG1zZylcblxuICAgICAgICAgICAgdGhpcy5zZXNzaW9uR2F0ZS5zZW5kKG9wY29kZSwgcnBjSUQsIGJ1ZiwgKHJlc3BvbnNlOmFueSk9PntcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlc292ZShyZXNwb25zZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHByb21pc2VcblxuICAgIH1cbn0gICBcbiIsImltcG9ydCB7IFVuaXR5RW5naW5lIH0gZnJvbSBcImNzaGFycFwiO1xuaW1wb3J0IHsgUyB9IGZyb20gXCIuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVNjZW5le1xuXG4gICAgcHJpdmF0ZSBwcmVsb2FkUHJlZmFiOk1hcDxzdHJpbmcsbnVtYmVyPjtcbiAgICBwcml2YXRlIHNjZW5lSW5zdGFuY2U6VW5pdHlFbmdpbmUuUmVzb3VyY2VNYW5hZ2VtZW50LlJlc291cmNlUHJvdmlkZXJzLlNjZW5lSW5zdGFuY2VcblxuICAgIHB1YmxpYyBmaW5pc2hDb3VudCA9IDA7XG4gICAgcHVibGljIHRvdGFsQ291bnQgPSAwO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiID0gbmV3IE1hcDxzdHJpbmcsbnVtYmVyPigpO1xuICAgICAgICB0aGlzLmZpbmlzaENvdW50ID0gMDtcbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUHJlbG9hZFByZWZhYihhZGRyZXNzOnN0cmluZywgaW5zdENvdW50KXtcbiAgICAgICAgaWYoIXRoaXMucHJlbG9hZFByZWZhYi5oYXMoYWRkcmVzcykpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucHJlbG9hZFByZWZhYi5zZXQoYWRkcmVzcywgaW5zdENvdW50KTtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbG9hZFByZWZhYi5zZXQoYWRkcmVzcywgdGhpcy5wcmVsb2FkUHJlZmFiLmdldChhZGRyZXNzKSArIGluc3RDb3VudCk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFNjZW5lSW5zdGFuY2Uoc2NlbmVJbnN0YW5jZTpVbml0eUVuZ2luZS5SZXNvdXJjZU1hbmFnZW1lbnQuUmVzb3VyY2VQcm92aWRlcnMuU2NlbmVJbnN0YW5jZSl7XG4gICAgICAgIHRoaXMuc2NlbmVJbnN0YW5jZSA9IHNjZW5lSW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHVibGljIGFic3RyYWN0IG9uRW50ZXIoKTtcbiAgICBwdWJsaWMgYWJzdHJhY3Qgb25Db21wbGV0ZSgpO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkxlYXZlKCk7XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZEFzc2V0c0FzeW5jKCl7XG5cbiAgICAgICAgdGhpcy50b3RhbENvdW50ID0gdGhpcy5wcmVsb2FkUHJlZmFiLnNpemU7XG5cbiAgICAgICAgbGV0IHByZW1pc2VzID0gW107XG5cbiAgICAgICAgdGhpcy5wcmVsb2FkUHJlZmFiLmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgICAgICBsZXQgcHJlbWlzZSA9IFMuR2FtZU9iamVjdFBvb2wucHJlTG9hZEdhbWVPYmplY3RBc3luYyhrZXksIHZhbHVlLCgpPT57XG4gICAgICAgICAgICAgICAgdGhpcy5maW5pc2hDb3VudCsrO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHByZW1pc2VzLnB1c2gocHJlbWlzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByZW1pc2VzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25EZXN0cm95KCl7XG4gXG4gICAgICAgIC8v5riF55CG6LWE5rqQ57yT5a2YXG4gICAgICAgIFMuR2FtZU9iamVjdFBvb2wuY2xlYW51cCh0cnVlKTtcblxuICAgICAgICAvL+WNuOi9veWcuuaZr1xuICAgICAgICBTLlJlc01hbmFnZXIudW5sb2FkU2NlbmUodGhpcy5zY2VuZUluc3RhbmNlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHJlbG9hZFByZWZhYi5jbGVhcigpO1xuICAgIH1cbn0iLCJleHBvcnQgIGNsYXNzIFNjZW5lRGVme1xuXG4gICAgcHVibGljIHN0YXRpYyBMb2FkaW5nU2NlbmU6c3RyaW5nID0gXCJMb2FkaW5nU2NlbmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIExhdW5jaFNjZW5lOnN0cmluZyA9IFwiTGF1bmNoU2NlbmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIEhvbWVTY2VuZTpzdHJpbmcgPSBcIkhvbWVTY2VuZVwiO1xuICAgIHB1YmxpYyBzdGF0aWMgTG9naW5TY2VuZTpzdHJpbmcgPSBcIkxvZ2luU2NlbmVcIjtcbiAgICBwdWJsaWMgc3RhdGljIFB2ZVNjZW5lOnN0cmluZyA9IFwiUHZlU2NlbmVcIjtcbn1cbiIsImltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBQdmVTY2VuZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9wdmUvc2NlbmUvUHZlU2NlbmVcIjtcclxuaW1wb3J0IHsgSG9tZVNjZW5lIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2hvbWUvc2NlbmUvSG9tZVNjZW5lXCI7XHJcbmltcG9ydCB7IExvZ2luU2NlbmUgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvbG9naW4vc2NlbmUvTG9naW5TY2VuZVwiO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gXCIuL1NjZW5lRGVmXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBTY2VuZUZhY3Rvcnl7XHJcblxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgY3JlYXRlU2NlbmUoc2NlbmVOYW1lOnN0cmluZyk6QmFzZVNjZW5le1xyXG5cclxuICAgICAgICBsZXQgc2NlbmU6QmFzZVNjZW5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgc3dpdGNoIChzY2VuZU5hbWUpe1xyXG4gICAgICAgICAgICBjYXNlIFNjZW5lRGVmLkxvZ2luU2NlbmU6XHJcbiAgICAgICAgICAgICAgICBzY2VuZSA9IG5ldyBMb2dpblNjZW5lKCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBTY2VuZURlZi5Ib21lU2NlbmU6XHJcbiAgICAgICAgICAgICAgICBzY2VuZSA9IG5ldyBIb21lU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNjZW5lRGVmLlB2ZVNjZW5lOlxyXG4gICAgICAgICAgICAgICAgc2NlbmUgPSBuZXcgUHZlU2NlbmUoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHNjZW5lO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgY29tbW9uVUkgfSBmcm9tIFwiLi4vLi4vZGF0YS91aS9jb21tb25cIjtcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZVwiO1xuaW1wb3J0IHsgUyB9IGZyb20gXCIuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSBcIi4uL2NvbW1vbi9TaW5nbGV0b25cIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi9sb2dnZXIvTG9nZ2VyXCI7XG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi9CYXNlU2NlbmVcIjtcbmltcG9ydCB7IFNjZW5lRmFjdG9yeSB9IGZyb20gXCIuL1NjZW5lRmFjdG9yeVwiO1xuXG5cblxuXG5leHBvcnQgY2xhc3MgU2NlbmVNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFNjZW5lTWFuYWdlcj57XG5cbiAgICBwcml2YXRlIGN1cnJlbnRTY2VuZTpCYXNlU2NlbmUgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgbG9hZFNjZW5lKHNjZW5lOnN0cmluZyl7XG4gICAgICAgIFxuICAgICAgICB0cnl7XG5cbiAgICAgICAgICAgIC8v5omT5byATG9hZGluZ+eVjOmdolxuICAgICAgICAgICAgUy5VSU1hbmFnZXIub3BlbkxvYWRpbmcoY29tbW9uVUkuUGFja2FnZU5hbWUsIGNvbW1vblVJLlVJTG9hZGluZ1BhZ2UpO1xuXG4gICAgICAgICAgICAvL+a4heeQhuaXp+WcuuaZr1xuICAgICAgICAgICAgaWYodGhpcy5jdXJyZW50U2NlbmUpe1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uTGVhdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5vbkRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy/lvIDlp4vliqDovb3lnLrmma9cbiAgICAgICAgICAgIGxldCBzY2VuZUluc3RhbmNlID0gYXdhaXQgUy5SZXNNYW5hZ2VyLmxvYWRTY2VuZShzY2VuZSk7XG5cbiAgICAgICAgICAgIC8v5byA5aeL5Yqg6L296L+b5YWl5Zy65pmv55qE6LWE5rqQXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9ICBTY2VuZUZhY3RvcnkuY3JlYXRlU2NlbmUoc2NlbmUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuc2V0U2NlbmVJbnN0YW5jZShzY2VuZUluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLm9uRW50ZXIoKTtcblxuICAgICAgICAgICAgLy/orr7nva7lvZPliY3lnLrmma/liqDovb3ov5vluqZUaW1lclxuICAgICAgICAgICAgbGV0IHByb2dyZXNzSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKT0+e1xuXG4gICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gdGhpcy5jdXJyZW50U2NlbmUuZmluaXNoQ291bnQvdGhpcy5jdXJyZW50U2NlbmUudG90YWxDb3VudDtcbiAgICAgICAgICAgICAgICBMb2dnZXIubG9nKFwicHJvZ3Jlc3M6XCIrcHJvZ3Jlc3MgKyBcIiA9IFwiK3RoaXMuY3VycmVudFNjZW5lLmZpbmlzaENvdW50ICsgXCIgPSBcIit0aGlzLmN1cnJlbnRTY2VuZS50b3RhbENvdW50KTtcblxuICAgICAgICAgICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmJyb2FkY2FzdChcbiAgICAgICAgICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TQ0VORV9QUk9HUkVTUyxcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MqMTAwKTtcblxuICAgICAgICAgICAgfSwgMTAwKTtcblxuICAgICAgICAgICAgLy/liqDovb3otYTmupBcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY3VycmVudFNjZW5lLmxvYWRBc3NldHNBc3luYygpO1xuXG4gICAgICAgICAgICAvL+WKoOi9veWujOaIkFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwcm9ncmVzc0ludGVydmFsKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUub25Db21wbGV0ZSgpXG4gICAgICAgICAgICBTLlVJTWFuYWdlci5jbG9zZUxvYWRpbmcoY29tbW9uVUkuVUlMb2FkaW5nUGFnZSk7XG5cbiAgICAgICAgfWNhdGNoKGV4KXtcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJsb2FkIHNjZW5lIGV4Y2VwOlwiK2V4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9XG5cblxuXG4gICAgXG59IiwiXHJcblxyXG5cclxuZXhwb3J0IGVudW0gVUlUeXBlRGVme1xyXG4gICAgVW5rb3duID0gMCxcclxuICAgIFBhZ2UgPSAxLFxyXG4gICAgV2luZG93PTIsXHJcbiAgICBXaWRnZXQgPSAzLFxyXG4gICAgTG9hZGluZyA9NFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVUlMYXllckRlZntcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIEJhY2tncm91bmQ6bnVtYmVyID0gMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgUGFnZTpudW1iZXIgPSAxMDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBOb3JtYWxXaW5kb3c6bnVtYmVyID0gMjAwMDtcclxuICAgIHB1YmxpYyBzdGF0aWMgVG9wV2luZG93Om51bWJlciA9IDMwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIFdpZGdldDpudW1iZXIgPSA0MDAwO1xyXG4gICAgcHVibGljIHN0YXRpYyBMb2FkaW5nOm51bWJlciA9IDUwMDA7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVua293bjpudW1iZXIgPSA5OTk5O1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgIGdldERlZmF1bHRMYXllcih0eXBlOlVJVHlwZURlZik6bnVtYmVye1xyXG5cclxuICAgICAgICBzd2l0Y2godHlwZSl7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLkxvYWRpbmc6IHJldHVybiB0aGlzLkxvYWRpbmc7XHJcbiAgICAgICAgICAgIGNhc2UgVUlUeXBlRGVmLldpZGdldDogcmV0dXJuIHRoaXMuV2lkZ2V0O1xyXG4gICAgICAgICAgICBjYXNlIFVJVHlwZURlZi5XaW5kb3c6IHJldHVybiB0aGlzLk5vcm1hbFdpbmRvdztcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuUGFnZTogcmV0dXJuIHRoaXMuUGFnZTtcclxuICAgICAgICAgICAgY2FzZSBVSVR5cGVEZWYuVW5rb3duOiByZXR1cm4gdGhpcy5Vbmtvd247XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLlVua293bjsgXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJQ29tRGVmc3tcclxuICAgIHB1YmxpYyBzdGF0aWMgQmFja0J0biA9IFwiYmFja19idG5cIjtcclxuICAgIHB1YmxpYyBzdGF0aWMgV2luZG93Q2xvc2VCdG4gPSBcIndpbl9jbG9zZV9idG5cIjtcclxufVxyXG5cclxuXHJcblxyXG4iLCJcclxuaW1wb3J0IHsgVUlMb2dpblBhZ2UgfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlMb2dpblBhZ2VcIjtcclxuaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlIb21lUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9ob21lL3VpL1VJSG9tZVBhZ2VcIjtcclxuaW1wb3J0IHsgVUlMb2FkaW5nIH0gZnJvbSBcIi4vVUlMaWIvVUlMb2FkaW5nXCI7XHJcbmltcG9ydCB7IGxvZ2luVUkgfSBmcm9tIFwiLi4vLi4vZGF0YS91aS9sb2dpblwiO1xyXG5pbXBvcnQgeyBjb21tb25VSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2NvbW1vblwiO1xyXG5pbXBvcnQgeyBob21lVUkgfSBmcm9tIFwiLi4vLi4vZGF0YS91aS9ob21lXCI7XHJcbmltcG9ydCB7IFVJTXNnQm94IH0gZnJvbSBcIi4vVUlMaWIvVUlNc2dCb3hcIjtcclxuaW1wb3J0IHsgVUlTZWxTZXJ2ZXJXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvbG9naW4vdWkvVUlTZWxTZXJ2ZXJXaW5cIjtcclxuaW1wb3J0IHsgVUlTaG9wUGFnZSB9IGZyb20gXCIuLi8uLi9nYW1lL21vZHVsZS9ob21lL3VpL1VJU2hvcFBhZ2VcIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IFVJU3RvcnlXaW4gfSBmcm9tIFwiLi4vLi4vZ2FtZS9tb2R1bGUvc3RvcnkvVUlTdG9yeVdpblwiO1xyXG5pbXBvcnQgeyBjb21iYXRVSSB9IGZyb20gXCIuLi8uLi9kYXRhL3VpL2NvbWJhdFwiO1xyXG5pbXBvcnQgeyBVSUd1aWRlV2luIH0gZnJvbSBcIi4uLy4uL2dhbWUvbW9kdWxlL2d1aWRlL1VJR3VpZGVXaW5cIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uL2xvZ2dlci9Mb2dnZXJcIjtcclxuXHJcblxyXG5cclxuY29uc3QgQ1MgPSByZXF1aXJlKCdjc2hhcnAnKTtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlGYWN0b3J5e1xyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgdWlDYWNoZTpNYXA8c3RyaW5nLFVJUGFuZWw+ID0gbmV3IE1hcDxzdHJpbmcsVUlQYW5lbD4oKTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGNyZWF0ZVVJKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nKXtcclxuICAgICAgICBMb2dnZXIubG9nKGBjcmVhdGUgVUk6ICR7cGtnfToke25hbWV9YClcclxuICAgICAgICBsZXQgY29tcCA9IENTLkZhaXJ5R1VJLlVJUGFja2FnZS5DcmVhdGVPYmplY3QocGtnLCBuYW1lKS5hc0NvbVxyXG4gICAgICAgIFxyXG4gICAgICAgIGxldCB1aTpVSVBhbmVsID0gdGhpcy51aUNhY2hlLmdldChuYW1lKTtcclxuXHJcbiAgICAgICAgaWYoIXVpKXtcclxuXHJcbiAgICAgICAgICAgIHN3aXRjaChwa2cpe1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgY29tbW9uVUkuUGFja2FnZU5hbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb21tb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjb21tb25VSS5VSVVJTm90aWNlV2luOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlNc2dCb3goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vblVJLlVJTG9hZGluZ1BhZ2U6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSUxvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvbW1vblVJLlVJVUlHdWlkZVdpbjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJR3VpZGVXaW4oKVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSBsb2dpblVJLlBhY2thZ2VOYW1lOlxyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbG9naW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBsb2dpblVJLlVJTG9naW5QYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlMb2dpblBhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGxvZ2luVUkuVUlTZWxTZXJ2ZXJXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVNlbFNlcnZlcldpbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIGNvbWJhdFVJLlBhY2thZ2VOYW1lOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgY2FzZSBob21lVUkuUGFja2FnZU5hbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBob21lVUkuVUlIb21lUGFnZTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpID0gbmV3IFVJSG9tZVBhZ2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGhvbWVVSS5VSVNob3BQYWdlOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWkgPSBuZXcgVUlTaG9wUGFnZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICBjYXNlIHN0b3J5VUkuUGFja2FnZU5hbWU6XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBzdG9yeVVJLlVJU3RvcnlXaW46XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aSA9IG5ldyBVSVN0b3J5V2luKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMudWlDYWNoZS5zZXQobmFtZSwgdWkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih1aSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmZ1aSA9IGNvbXA7XHJcbiAgICAgICAgICAgIHVpLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICB1aS5wa2dOYW1lID0gcGtnO1xyXG5cclxuICAgICAgICAgICAgLy/nu5HlrppGYWlyeUdVSeaOp+S7tlxyXG4gICAgICAgICAgICB1aS5iaW5kQWxsKHVpKTtcclxuICAgICAgICAgICAgdWkuYXdha2UoKTtcclxuICAgICAgICBcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgTG9nZ2VyLmVycm9yKGBub3QgY3JlYXRlIHVpOiAke3BrZ30tJHtuYW1lfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuLi9VSVBhbmVsXCI7XHJcbmltcG9ydCB7IFVJVHlwZURlZiB9IGZyb20gXCIuLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XHJcbmltcG9ydCB7IFVJTWVzc2FnZSB9IGZyb20gXCIuLi8uLi8uLi9nYW1lL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyAgVUlMb2FkaW5nIGV4dGVuZHMgVUlQYW5lbHtcclxuXHJcblxyXG4gICAgQGJpbmRlcihcImxvYWRpbmdfcHJlZ3Jlc3NcIilcclxuICAgIHB1YmxpYyBwcm9ncmVzc0xvYWRpbmc6IEZhaXJ5R1VJLkdQcm9ncmVzc0JhcjtcclxuXHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6IHZvaWQge1xyXG4gICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHB1YmxpYyBnZXQgdWlUeXBlKCk6IFVJVHlwZURlZiB7ICAgIFxyXG4gICAgICAgIHJldHVybiBVSVR5cGVEZWYuTG9hZGluZztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmFsdWUgPSAwO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NMb2FkaW5nLnZpc2libGUgPSB0cnVlO1xyXG5cclxuICAgICAgICBTLlVJTWVzc2FnZU1hbmdlci5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TQ0VORV9QUk9HUkVTUyxcclxuICAgICAgICAgICAgdGhpcyxcclxuICAgICAgICAgICAgKHByb2dyZXNzOm51bWJlcik9PntcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3Jlc3NMb2FkaW5nLlR3ZWVuVmFsdWUocHJvZ3Jlc3MsIDAuMSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0xvYWRpbmcudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLnJlbW92ZUxpc3RlbmVyQnlDb2RlKFxyXG4gICAgICAgICAgICBVSU1lc3NhZ2UuTVNHX1NDRU5FX1BST0dSRVNTXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tIFwiLi4vVUlXaW5kb3dcIjtcclxuXHJcbi8vIOmAmueUqOW8ueeql1xyXG5leHBvcnQgY2xhc3MgVUlNc2dCb3hBcmd7XHJcbiAgICBwdWJsaWMgdGl0bGU6c3RyaW5nID0gXCJcIjtcclxuICAgIHB1YmxpYyBjb250ZW50OnN0cmluZyA9IFwiXCI7XHJcbiAgICBwdWJsaWMgYnRuVGV4dDpzdHJpbmcgPSBcIlwiOy8vXCLnoa7lrpp85Y+W5raIfOWFs+mXrVwiXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlNc2dCb3ggZXh0ZW5kcyBVSVdpbmRvd3tcclxuXHJcbiAgICBwcml2YXRlIG1fYXJnOlVJTXNnQm94QXJnO1xyXG5cclxuICAgIEBiaW5kZXIoXCJtc2dUeHRcIilcclxuICAgIHByaXZhdGUgbV90eHQ6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm9rQnRuXCIpXHJcbiAgICBwcml2YXRlIG1fb2tCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJjYW5jZWxCdG5cIilcclxuICAgIHByaXZhdGUgbV9jYW5jZWxCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkF3YWtlKCk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcblxyXG4gICAgICAgIHRoaXMuYmluZEFsbCh0aGlzKVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvblNob3coYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICBcclxuICAgIH1cclxuXHJcbn0iLCJcclxuaW1wb3J0IHsgU2luZ2xldG9uIH0gZnJvbSAnLi4vY29tbW9uL1NpbmdsZXRvbic7XHJcbmltcG9ydCB7IFVJTG9hZGluZyB9IGZyb20gJy4vVUlMaWIvVUlMb2FkaW5nJztcclxuaW1wb3J0IHsgVUlXaW5kb3cgfSBmcm9tICcuL1VJV2luZG93JztcclxuaW1wb3J0IHsgVUlXaWRnZSB9IGZyb20gJy4vVUlXaWRnZSc7XHJcbmltcG9ydCB7IFVJUGFuZWwgfSBmcm9tICcuL1VJUGFuZWwnO1xyXG5pbXBvcnQgeyBVSUZhY3RvcnkgfSBmcm9tICcuL1VJRmFjdG9yeSc7XHJcbmltcG9ydCB7IGhvbWVVSSB9IGZyb20gJy4uLy4uL2RhdGEvdWkvaG9tZSc7XHJcbmltcG9ydCB7IFMgfSBmcm9tICcuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZyc7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlci9Mb2dnZXInO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSVBhZ2VUcmFja3tcclxuICAgIHB1YmxpYyBwa2c6c3RyaW5nO1xyXG4gICAgcHVibGljIG5hbWU6c3RyaW5nO1xyXG4gICAgcHVibGljIGFyZzphbnk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlNYW5hZ2VyIGV4dGVuZHMgU2luZ2xldG9uPFVJTWFuYWdlcj57XHJcblxyXG4gICAgcHJpdmF0ZSAgbV9wYWdlVHJhY2tTdGFjazpBcnJheTxVSVBhZ2VUcmFjaz47XHJcbiAgICBwcml2YXRlIG1fY3VycmVudFBhZ2U6VUlQYWdlVHJhY2s7XHJcblxyXG4gICAgcHJpdmF0ZSBtX2xpc3RMb2FkZWRQYW5lbDpBcnJheTxVSVBhbmVsPjtcclxuXHJcblxyXG4gICAgY29uc3RydWN0b3IoKXtcclxuICAgICAgICBzdXBlcigpO1xyXG5cclxuICAgICAgICB0aGlzLm1fcGFnZVRyYWNrU3RhY2sgPSBuZXcgQXJyYXk8VUlQYWdlVHJhY2s+KCk7XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbCA9IG5ldyBBcnJheTxVSVBhbmVsPigpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGRpc3Ryb3lBbGxMb2FkZWRQYW5lbCgpOnZvaWR7XHJcblxyXG4gICAgICAgIGZvcihsZXQgaT0gdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5sZW5ndGgtMTsgaT49MDsgaS0tKXtcclxuICAgICAgICAgICAgbGV0IHBhbmVsID0gdGhpcy5tX2xpc3RMb2FkZWRQYW5lbFtpXTtcclxuXHJcbiAgICAgICAgICAgIGlmKHBhbmVsLmlzT3Blbil7XHJcbiAgICAgICAgICAgICAgICBwYW5lbC5jbG9zZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8v5Y246L296LWE5rqQXHJcbiAgICAgICAgICAgIFMuUmVzTWFuYWdlci5yZWxlYXNlRmFpcnlHVUlQYWNrYWdlKHBhbmVsLnBrZ05hbWUpO1xyXG4gICAgICAgICAgICBwYW5lbC5kaXNwb3NlKCk7ICBcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhbigpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMuZGlzdHJveUFsbExvYWRlZFBhbmVsKCk7XHJcblxyXG4gICAgICAgIHRoaXMubV9wYWdlVHJhY2tTdGFjay5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMubV9saXN0TG9hZGVkUGFuZWwubGVuZ3RoID0gMDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgb3Blbihwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnPzphbnkpe1xyXG4gICBcclxuICAgICAgICBsZXQgdWk6YW55ID0gdGhpcy5nZXRVSShuYW1lKTtcclxuXHJcbiAgICAgICAgaWYodWkgPT0gbnVsbCl7XHJcbiAgICAgICAgICAgIC8v5Yqg6L29IHBhY2thZ2VcclxuICAgICAgICAgICAgYXdhaXQgUy5SZXNNYW5hZ2VyLmxvYWRGYWlyeUdVSVBhY2thZ2UocGtnKTtcclxuICAgICAgICAgICAgdWkgPSBVSUZhY3RvcnkuY3JlYXRlVUkocGtnLCBuYW1lKTtcclxuICAgICAgICAgICAgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbC5wdXNoKHVpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHVpICE9IG51bGwpe1xyXG4gICAgICAgICAgICAvLyAjIyMgIHVpIGFzIGFueSDosIPnlKjnp4HmnInmlrnms5VcclxuICAgICAgICAgICAgKHVpIGFzIGFueSkuX2ludGVybmFsT3BlbihhcmcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgZ2V0VUkobmFtZTpzdHJpbmcpOlVJUGFuZWx7XHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgcGFuZWwgb2YgdGhpcy5tX2xpc3RMb2FkZWRQYW5lbCkge1xyXG4gICAgICAgICAgICBpZihwYW5lbC5uYW1lID09IG5hbWUpe1xyXG5cclxuICAgICAgICAgICAgICAgIExvZ2dlci5sb2coXCJmaW5kIHBhbmVsIGluIGNhY2hlOiBcIituYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFuZWw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLy/miZPlvIDlnLrmma/pobXpnaIs5q2k6aG16Z2i5LiN6K6h5YWl6aG16Z2i5qCILOaXoOi/lOWbnuS4iuS4gOmdouaMiemSrlxyXG4gICAgcHVibGljIG9wZW5QYWdlSW5TY2VuZShwa2c6c3RyaW5nLCBwYWdlOnN0cmluZywgYXJnOmFueSl7XHJcbiAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcihwa2csIHBhZ2UsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09VUlMb2FkaW5nXHJcbiAgICAvL+aJk+W8gExvYWRpbmfnlYzpnaJcclxuICAgIHB1YmxpYyBvcGVuTG9hZGluZyhwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnPzphbnkpe1xyXG5cclxuICAgICAgICB0aGlzLm9wZW5QYWdlSW5TY2VuZShwa2csIG5hbWUsIGFyZyk7XHJcblxyXG4gICAgfVxyXG4gICAgLy/lhbPpl61Mb2FkaW5n55WM6Z2iXHJcbiAgICBwdWJsaWMgY2xvc2VMb2FkaW5nKG5hbWU6c3RyaW5nLCBhcmc/OmFueSk6dm9pZHtcclxuICAgICAgICBsZXQgdWk6VUlMb2FkaW5nID0gdGhpcy5nZXRVSShuYW1lKSBhcyBVSUxvYWRpbmc7XHJcbiAgICAgICAgaWYodWkgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmNsb3NlKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1QYWdlXHJcbiAgICBwcml2YXRlIG9wZW5QYWdlV29ya2VyKHBrZzpzdHJpbmcsIHBhZ2U6c3RyaW5nLCBhcmc6YW55KXtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UgPSBuZXcgVUlQYWdlVHJhY2soKTtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UucGtnID0gcGtnO1xyXG4gICAgICAgIHRoaXMubV9jdXJyZW50UGFnZS5uYW1lID0gcGFnZTtcclxuICAgICAgICB0aGlzLm1fY3VycmVudFBhZ2UuYXJnID0gYXJnO1xyXG5cclxuICAgICAgICB0aGlzLmRpc3Ryb3lBbGxMb2FkZWRQYW5lbCgpO1xyXG5cclxuICAgICAgICB0aGlzLm9wZW4ocGtnLCBwYWdlLCBhcmcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8v5omT5byA6aG16Z2iLCDkvJrlhbPpl63kuIrkuIDkuKrpobXpnaLkuIrnmoTmiYDmnInnqpflj6MsV2lkaWdldOetiVxyXG4gICAgcHVibGljIG9wZW5QYWdlKHBrZzpzdHJpbmcsIG5hbWU6c3RyaW5nLCBhcmc/OmFueSl7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9jdXJyZW50UGFnZSAhPSB1bmRlZmluZWQgJiYgdGhpcy5tX2N1cnJlbnRQYWdlLm5hbWUhPW5hbWUpe1xyXG4gICAgICAgICAgICB0aGlzLm1fcGFnZVRyYWNrU3RhY2sucHVzaCh0aGlzLm1fY3VycmVudFBhZ2UpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5vcGVuUGFnZVdvcmtlcihwa2csIG5hbWUsIGFyZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy/ov5Tlm57kuIrkuIDkuKrpobXpnaJcclxuICAgIHB1YmxpYyBnb0JhY2tQYWdlKCk6dm9pZHtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX3BhZ2VUcmFja1N0YWNrLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICBsZXQgdHJhY2sgPSB0aGlzLm1fcGFnZVRyYWNrU3RhY2sucG9wKCk7XHJcbiAgICAgICAgICAgIHRoaXMub3BlblBhZ2VXb3JrZXIodHJhY2sucGtnICx0cmFjay5uYW1lLCB0cmFjay5hcmcpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLmVudGVyTWFpblBhZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuXHJcbiAgICAvL+WbnuWIsOS4u+WfjlxyXG4gICAgcHVibGljIGVudGVyTWFpblBhZ2UoKTp2b2lke1xyXG5cclxuICAgICAgICB0aGlzLm1fcGFnZVRyYWNrU3RhY2subGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLm9wZW5QYWdlSW5TY2VuZShob21lVUkuUGFja2FnZU5hbWUgLGhvbWVVSS5VSUhvbWVQYWdlLG51bGwpXHJcbiAgICB9XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09VUlXaW5kb3dcclxuICAgIC8v5omT5byA56qX5Y+jXHJcbiAgICBwdWJsaWMgYXN5bmMgb3BlbldpbmRvdyhwa2c6c3RyaW5nLCBuYW1lOnN0cmluZywgYXJnOmFueSl7XHJcblxyXG4gICAgICAgIGxldCB1aTpVSVdpbmRvdyA9IGF3YWl0IHRoaXMub3Blbihwa2csIG5hbWUsIGFyZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB1aTtcclxuICAgIH1cclxuXHJcbiAgICAvL+WFs+mXreeql+WPo1xyXG4gICAgcHVibGljIGNsb3NlV2luZG93KG5hbWU6c3RyaW5nLCBhcmc6YW55KXtcclxuXHJcbiAgICAgICAgbGV0IHVpOlVJV2luZG93ID0gdGhpcy5nZXRVSShuYW1lKSBhcyBVSVdpbmRvdztcclxuICAgICAgICBpZih1aSAhPSBudWxsKXtcclxuICAgICAgICAgICAgdWkuY2xvc2UoYXJnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09VUlXaWRnZXRcclxuICAgIC8v5omT5byAV2lkaWdldFxyXG4gICAgcHVibGljIGFzeW5jIG9wZW5XaWRnZXQocGtnOnN0cmluZywgbmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaWRnZSA9IGF3YWl0IHRoaXMub3Blbihwa2csIG5hbWUsIGFyZyk7XHJcblxyXG4gICAgICAgIHJldHVybiB1aTtcclxuICAgIH1cclxuXHJcbiAgICAvL3XlhbPpl61XaWRpZ2V0XHJcbiAgICBwdWJsaWMgY2xvc2VXaWRnZXQobmFtZTpzdHJpbmcsIGFyZzphbnkpe1xyXG5cclxuICAgICAgICBsZXQgdWk6VUlXaWRnZSA9IHRoaXMuZ2V0VUkobmFtZSkgYXMgVUlXaWRnZTtcclxuICAgICAgICBpZih1aSE9bnVsbCl7XHJcbiAgICAgICAgICAgIHVpLmNsb3NlKGFyZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBVSVBhbmVsIH0gZnJvbSBcIi4vVUlQYW5lbFwiO1xyXG5pbXBvcnQgeyBVSVR5cGVEZWYsIFVJQ29tRGVmcyB9IGZyb20gXCIuL1VJRGVmaW5lXCI7XHJcbmltcG9ydCB7IEZhaXJ5R1VJIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVSVBhZ2UgZXh0ZW5kcyBVSVBhbmVse1xyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5QYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgbV9idG5Hb0JhY2s6RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMubV9idG5Hb0JhY2sgPSB0aGlzLmZ1aS5HZXRDaGlsZChVSUNvbURlZnMuQmFja0J0bik7XHJcblxyXG4gICAgICAgIGlmKHRoaXMubV9idG5Hb0JhY2shPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5Hb0JhY2sub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgICAgIHRoaXMub25CdG5Hb0JhY2soKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KHZvOmFueSk6dm9pZHtcclxuXHJcbiAgICBcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25DbG9zZShhcmc6YW55KTp2b2lke1xyXG4gICBcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG9uQnRuR29CYWNrKCl7XHJcbiAgICAgICAgUy5VSU1hbmFnZXIuZ29CYWNrUGFnZSgpO1xyXG4gICAgfVxyXG5cclxufSAiLCJpbXBvcnQgeyBVSVR5cGVEZWYsIFVJTGF5ZXJEZWYgfSBmcm9tIFwiLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBVSVBhbmVsIHtcclxuXHJcbiAgICBwdWJsaWMgZnVpOmFueTsgIC8vRmFpcnlHVUkg5a+56LGhXHJcblxyXG4gICAgcHVibGljIHBrZ05hbWU6c3RyaW5nO1xyXG5cclxuXHJcbiAgICBwcml2YXRlIF9uYW1lOnN0cmluZztcclxuICAgIHB1YmxpYyBzZXQgbmFtZSh2OnN0cmluZyl7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IHY7XHJcbiAgICB9XHJcbiAgICBwdWJsaWMgZ2V0IG5hbWUoKTpzdHJpbmd7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCB1aVR5cGUoKTogVUlUeXBlRGVmIHsgICAgXHJcbiAgICAgICAgcmV0dXJuIFVJVHlwZURlZi5Vbmtvd247XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHByaXZhdGUgbV9sYXllcjpVSUxheWVyRGVmID0gVUlMYXllckRlZi5Vbmtvd247XHJcbiAgICBwdWJsaWMgZ2V0IGxheWVyKCkgOiBVSUxheWVyRGVmIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tX2xheWVyOyBcclxuICAgIH1cclxuICAgIHB1YmxpYyBzZXQgbGF5ZXIodiA6IFVJTGF5ZXJEZWYpIHtcclxuICAgICAgICB0aGlzLm1fbGF5ZXIgPSB2O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwdWJsaWMgIGdldCBpc09wZW4oKSA6IGJvb2xlYW57XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmZ1aS52aXNpYmxlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhYnN0cmFjdCBvbkF3YWtlKCk6dm9pZDtcclxuICAgIHB1YmxpYyBhYnN0cmFjdCBvblNob3codm86YW55KTp2b2lkO1xyXG4gICAgcHVibGljIGFic3RyYWN0IG9uQ2xvc2UoYXJnOmFueSk6dm9pZDtcclxuXHJcblxyXG4gICAgcHVibGljIG9uVXBkYXRlKCk6dm9pZHt9XHJcblxyXG4gICAgcHVibGljIGF3YWtlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLm9uQXdha2UoKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy/nu5HlrppGYWlyeUdVSeWFg+S7tlxyXG4gICAgcHVibGljIGJpbmRBbGwodGFyZ2V0OmFueSk6dm9pZHtcclxuICAgICAgICBmb3IobGV0IGsgaW4gdGFyZ2V0W1wiYmluZGVyc1wiXSl7XHJcbiAgICAgICAgICAgIGxldCBmZ3VpTmFtZSA9IHRoaXNbXCJiaW5kZXJzXCJdW2tdO1xyXG4gICAgICAgICAgICB0aGlzW2tdID0gdGhpcy5mdWkuR2V0Q2hpbGQoZmd1aU5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgdXBkYXRlKCk6dm9pZHtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiDmraTnp4HmnInmlrnms5XlnKhVSSBNYW5hZ2Vy5Lit6LCD55SoIO+8jOeJueauiuiwg+eUqOOAglxyXG4gICAgICogQHBhcmFtIGFyZyBcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaW50ZXJuYWxPcGVuKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5sYXllciA9IFVJTGF5ZXJEZWYuZ2V0RGVmYXVsdExheWVyKHRoaXMudWlUeXBlKTtcclxuICAgICAgICBGYWlyeUdVSS5HUm9vdC5pbnN0LkFkZENoaWxkKHRoaXMuZnVpKTtcclxuXHJcbiAgICAgICAgdGhpcy5vblNob3coYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xvc2UoYXJnOmFueSA9IG51bGwpOnZvaWR7XHJcblxyXG4gICAgICAgIHRoaXMub25DbG9zZShhcmcpO1xyXG4gICAgICAgIEZhaXJ5R1VJLkdSb290Lmluc3QuUmVtb3ZlQ2hpbGQodGhpcy5mdWkpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGlzcG9zZSgpOnZvaWR7XHJcbiAgICAgICAgdGhpcy5mdWkuRGlzcG9zZSgpO1xyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgVUlQYW5lbCB9IGZyb20gXCIuL1VJUGFuZWxcIjtcclxuaW1wb3J0IHsgVUlUeXBlRGVmLCBVSUNvbURlZnMgfSBmcm9tIFwiLi9VSURlZmluZVwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuXHJcblxyXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgIFVJV2luZG93IGV4dGVuZHMgVUlQYW5lbHtcclxuICAgXHJcbiAgICBwdWJsaWMgZ2V0IHVpVHlwZSgpOiBVSVR5cGVEZWYgeyAgICBcclxuICAgICAgICByZXR1cm4gVUlUeXBlRGVmLldpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIG1fYnRuQ2xvc2U6RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2J0bkNsb3NlID0gdGhpcy5mdWkuR2V0Q2hpbGQoVUlDb21EZWZzLldpbmRvd0Nsb3NlQnRuKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uU2hvdyhhcmc6YW55KTp2b2lke1xyXG5cclxuICAgICAgICB0aGlzLmZ1aS54ID0gRmFpcnlHVUkuR1Jvb3QuaW5zdC53aWR0aC8yIC0gdGhpcy5mdWkud2lkdGgvMjtcclxuICAgICAgICB0aGlzLmZ1aS55ID0gRmFpcnlHVUkuR1Jvb3QuaW5zdC5oZWlnaHQvMiAtIHRoaXMuZnVpLmhlaWdodC8yO1xyXG5cclxuICAgICAgICBpZih0aGlzLm1fYnRuQ2xvc2UhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHRoaXMubV9idG5DbG9zZS5vbkNsaWNrLkFkZCh0aGlzLm9uQnRuQ2xvc2UpO1xyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuXHJcbiAgICAgICAgaWYodGhpcy5tX2J0bkNsb3NlIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICB0aGlzLm1fYnRuQ2xvc2Uub25DbGljay5SZW1vdmUodGhpcy5vbkJ0bkNsb3NlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvbkJ0bkNsb3NlKCl7XHJcbiAgICAgICAgdGhpcy5jbG9zZSgwKTtcclxuICAgIH1cclxuXHJcbn0iLCJpbXBvcnQgeyBuaWNlX3RzIH0gZnJvbSBcIi4uLy4uL2RhdGEvcGIvZ2VuL3BiXCI7XHJcbmltcG9ydCB7IE9wY29kZSB9IGZyb20gXCIuLi8uLi9kYXRhL3BiL09wY29kZVwiO1xyXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXJcIjtcclxuaW1wb3J0IHsgUyB9IGZyb20gXCIuLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dpbkFQSXtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGJlbmNobWFya1Rlc3QoKXtcclxuXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBpPTE7IGk8MjtpKyspe1xyXG4gICAgICAgICAgICBsZXQgbXNnID0gbmljZV90cy5DMkdTX1Rlc3QuY3JlYXRlKCk7XHJcbiAgICAgICAgICAgIG1zZy50ZXN0SUQgPSBpO1xyXG4gICAgICAgICAgICBtc2cudGVzdE5hbWUgPSBcImJlbmNobWFyayB0ZXN0XCI7XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBTLlNlc3Npb25NYW5hZ2VyLnNlbmRHYXRlTXNnKFxyXG4gICAgICAgICAgICAgICAgT3Bjb2RlLk1TR19DMkdTX1Rlc3QsXHJcbiAgICAgICAgICAgICAgICBtc2dcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICBsZXQgdGVzdCAgPSAgcmVzcG9uc2UgYXMgbmljZV90cy5HUzJDX1Rlc3Q7XHJcbiAgICAgICAgICAgIExvZ2dlci5sb2coXCJjb2RlOiBcIit0ZXN0LkVycm9yICtcIixtc2c6XCIrdGVzdC5NZXNzYWdlICtcIixyZXM6XCIrdGVzdC50ZXN0UmVzcG9uc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBhc3luYyBsb2dpblJlYWxtU2VydmVyKGFjY291bnQ6c3RyaW5nLCBwYXNzd29yZDpzdHJpbmcpOlByb21pc2U8bmljZV90cy5SMkNfTG9naW4+e1xyXG5cclxuICAgICAgICAgbGV0IG1zZyA9IG5pY2VfdHMuQzJSX0xvZ2luLmNyZWF0ZSgpO1xyXG4gICAgICAgICBtc2cuQWNjb3VudCA9IGFjY291bnQ7XHJcbiAgICAgICAgIG1zZy5QYXNzd29yZCA9IHBhc3N3b3JkO1xyXG5cclxuICAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgUy5TZXNzaW9uTWFuYWdlci5zZW5kUmVhbG1Nc2coXHJcbiAgICAgICAgICAgIE9wY29kZS5NU0dfQzJSX0xvZ2luLFxyXG4gICAgICAgICAgICBtc2dcclxuICAgICAgICApXHJcblxyXG4gICAgICAgIHJldHVybiByZXNwb25zZSBhcyBuaWNlX3RzLlIyQ19Mb2dpbjtcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9naW5HYXRlU2VydmVyKGdhdGVJZCwgZ2F0ZUtleSk6UHJvbWlzZTxuaWNlX3RzLkcyQ19Mb2dpbkdhdGU+e1xyXG5cclxuICAgICAgICBsZXQgbXNnID0gbmljZV90cy5DMkdfTG9naW5HYXRlLmNyZWF0ZSgpO1xyXG4gICAgICAgIG1zZy5HYXRlSWQgPSBnYXRlSWQ7XHJcbiAgICAgICAgbXNnLktleSA9IGdhdGVLZXk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgUy5TZXNzaW9uTWFuYWdlci5zZW5kR2F0ZU1zZyhcclxuICAgICAgICAgICAgT3Bjb2RlLk1TR19DMkdfTG9naW5HYXRlLFxyXG4gICAgICAgICAgICBtc2dcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UgYXMgbmljZV90cy5HMkNfTG9naW5HYXRlO1xyXG4gICAgfVxyXG59IiwiXG5cblxuZXhwb3J0IGNsYXNzIFVJTWVzc2FnZXtcblxuXG4gICAgcHVibGljIHN0YXRpYyBNU0dfU0VMRUNUX1NFUlZFUjpudW1iZXIgID0gMTAwMDtcbiAgICBwdWJsaWMgc3RhdGljIE1TR19TQ0VORV9QUk9HUkVTUzpudW1iZXIgPSAxMDAxO1xuICAgIFxuXG5cbn0iLCJpbXBvcnQgeyBNZXNzZW5nZXIgfSBmcm9tIFwiLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9NZXNzZW5nZXJcIjtcbmltcG9ydCB7IFNpbmdsZXRvbiB9IGZyb20gXCIuLi8uLi9mcmFtZXdvcmsvY29tbW9uL1NpbmdsZXRvblwiO1xuXG5cbmV4cG9ydCBjbGFzcyBVSU1lc3NhZ2VNYW5nZXIgZXh0ZW5kcyBTaW5nbGV0b248VUlNZXNzYWdlTWFuZ2VyPntcblxuICAgIHByaXZhdGUgdWlNZXNzYWdlOk1lc3NlbmdlciA9IG5ldyBNZXNzZW5nZXIoKTtcblxuXG4gICAgcHVibGljIGFkZExpc3RlbmVyKG1zZ0NvZGU6bnVtYmVyLG9iajphbnksIGxpc3RlbmVyOkZ1bmN0aW9uKXtcblxuICAgICAgICB0aGlzLnVpTWVzc2FnZS5hZGRMaXN0ZW5lcihtc2dDb2RlLCBvYmosIGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVtb3ZlTGlzdGVuZXIobXNnQ29kZTpudW1iZXIsIGxpc3RlbmVyOkZ1bmN0aW9uKXtcbiAgICAgICAgdGhpcy51aU1lc3NhZ2UucmVtb3ZlTGlzdGVuZXIobXNnQ29kZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVMaXN0ZW5lckJ5Q29kZShtc2dDb2RlOm51bWJlcil7XG4gICAgICAgIHRoaXMudWlNZXNzYWdlLnJlbW92ZUxpc3RlbmVyQnlUeXBlKG1zZ0NvZGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhcnVwKCl7XG4gICAgICAgIHRoaXMudWlNZXNzYWdlLmNsZWFydXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYnJvYWRjYXN0KG1zZ0NvZGU6bnVtYmVyLHBhcmFtczphbnkpe1xuXG5cbiAgICAgICAgdGhpcy51aU1lc3NhZ2UuYnJvYWRjYXN0KG1zZ0NvZGUsIHBhcmFtcylcbiAgICB9XG59IiwiaW1wb3J0IHsgRmFpcnlHVUkgfSBmcm9tIFwiY3NoYXJwXCI7XG5pbXBvcnQgeyBiaW5kZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2NvbW1vbi9OaWNlRGVjb3JhdG9yXCI7XG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlXaW5kb3dcIjtcblxuZXhwb3J0IGNsYXNzIFVJR3VpZGVXaW4gZXh0ZW5kcyBVSVdpbmRvd3tcblxuICAgIEBiaW5kZXIoXCJmb2N1c1wiKVxuICAgIHByaXZhdGUgbV9mb2N1czpGYWlyeUdVSS5HR3JhcGg7XG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgICAgICB0aGlzLm1fZm9jdXMuYWxwaGEgPSAwLjJcblxuICAgICAgICB0aGlzLm1fZm9jdXMuU2V0WFkoNTIwLDU1MClcblxuICAgIH1cblxuICAgIHB1YmxpYyBvblNob3codm86YW55KTp2b2lke1xuICAgICAgICBzdXBlci5vblNob3codm8pO1xuXG4gICAgICBcbiAgICB9XG5cblxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoYXJnKTtcblxuICAgIH1cblxuXG59IiwiaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvaG9tZVwiO1xyXG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcbmltcG9ydCB7IFZvSG9tZSB9IGZyb20gXCIuLi92by9Wb0hvbWVcIjtcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSG9tZVNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuXHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG5cclxuICAgICAgICBsZXQgdm86Vm9Ib21lID0gbmV3IFZvSG9tZSgpO1xyXG4gICAgICAgIHZvLm5hbWUgPSBcIkp1c3RpblwiO1xyXG4gICAgICAgIHZvLmhwID0gMTIwMDtcclxuICAgICAgICB2by5tcCA9IDMzMDA7XHJcbiAgICAgICAgdm8ubW9uZXkgPSA2NjY7XHJcblxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5QYWdlSW5TY2VuZShcclxuICAgICAgICAgICAgaG9tZVVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICBob21lVUkuVUlIb21lUGFnZSxcclxuICAgICAgICAgICAgdm8pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcblxyXG59IiwiaW1wb3J0IHsgVUlQYWdlIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVBhZ2VcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgY29tbW9uVUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9jb21tb25cIjtcclxuaW1wb3J0IHsgaG9tZVVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvaG9tZVwiO1xyXG5pbXBvcnQgeyBWb0hvbWUgfSBmcm9tIFwiLi4vdm8vVm9Ib21lXCI7XHJcbmltcG9ydCB7IExvZ2luQVBJIH0gZnJvbSBcIi4uLy4uLy4uL2FwaS9Mb2dpbkFQSVwiO1xyXG5pbXBvcnQgeyBPcGNvZGUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS9wYi9PcGNvZGVcIjtcclxuaW1wb3J0IHsgbmljZV90cyB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3BiL2dlbi9wYlwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvbG9nZ2VyL0xvZ2dlclwiO1xyXG5cclxuXHJcblxyXG5leHBvcnQgY2xhc3MgVUlIb21lUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiY2hhdEJ0blwiKVxyXG4gICAgcHVibGljIG1fY2hhdEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImJhZ0J0blwiKVxyXG4gICAgcHVibGljIG1fYmFnQnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcbiAgICBAYmluZGVyKFwic2hvcEJ0blwiKVxyXG4gICAgcHVibGljIG1fc2hvcEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcImxldmVsQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9sZXZlbEJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJuYW1lVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9uYW1lTGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuICAgIEBiaW5kZXIoXCJocFR4dFwiKVxyXG4gICAgcHVibGljIG1faHBMYmw6RmFpcnlHVUkuR0xhYmVsO1xyXG4gICAgQGJpbmRlcihcIm1wVHh0XCIpXHJcbiAgICBwdWJsaWMgbV9tcExibDpGYWlyeUdVSS5HTGFiZWw7XHJcbiAgICBAYmluZGVyKFwibW9uZXlUeHRcIilcclxuICAgIHB1YmxpYyBtX21vbmV5TGJsOkZhaXJ5R1VJLkdMYWJlbDtcclxuXHJcblxyXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcclxuXHJcbiAgICAgICAgdGhpcy5tX2NoYXRCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5vbmNoYXRCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fYmFnQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25iYWdCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm1fc2hvcEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9uc2hvcEJ0bigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMubV9sZXZlbEJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9ubGV2ZWxCdG4oKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBcclxuICAgIHB1YmxpYyBvblNob3codm86Vm9Ib21lKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcblxyXG4gICAgICAgIHRoaXMubV9uYW1lTGJsLnRleHQgPSB2by5uYW1lO1xyXG4gICAgICAgIHRoaXMubV9tcExibC50ZXh0ID0gdm8ubXAudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLm1faHBMYmwudGV4dCA9IHZvLmhwLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tX21vbmV5TGJsLnRleHQgPSB2by5tb25leS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBTLkdhbWVTZXNzaW9uLmxpc3RlbihPcGNvZGUuTVNHX0dTMkNfVGVzdCxmdW5jdGlvbihtc2c6bmljZV90cy5HUzJDX1Rlc3Qpe1xyXG4gICAgICAgICAgICBMb2dnZXIubG9nKFwi5pS25Yiw5pyN5Yqh5Zmo5LiL5Y+R55qE5raI5oGv44CC44CC44CC44CCXCIrbXNnLnRlc3RSZXNwb25zZSlcclxuICAgICAgICB9KVxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcclxuICAgICAgICBzdXBlci5vbkNsb3NlKGFyZyk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25jaGF0QnRuKCl7XHJcblxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgIGNvbW1vblVJLlBhY2thZ2VOYW1lLFxyXG4gICAgICAgICAgICBjb21tb25VSS5VSVVJTm90aWNlV2luLFxyXG4gICAgICAgICAgICBudWxsKTtcclxuICAgICAgICBMb2dnZXIubG9nKFwib24gY2hhdC4uLlwiKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbmJhZ0J0bigpe1xyXG4gICAgICAgIExvZ2dlci5sb2coXCJvbiBiYWcgLi5cIik7XHJcblxyXG4gICAgICAgIC8vYmVuY2htYXJrIHRlc3RcclxuICAgICAgICBMb2dpbkFQSS5iZW5jaG1hcmtUZXN0KCk7XHJcblxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uc2hvcEJ0bigpe1xyXG4gICAgICAgIFxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5QYWdlKFxyXG4gICAgICAgICAgICBob21lVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGhvbWVVSS5VSVNob3BQYWdlKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbmxldmVsQnRuKCl7XHJcbiAgICAgICAgTG9nZ2VyLmxvZyhcIm9uIGxldmVsLi4uXCIpO1xyXG4gICAgfVxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgVUlTaG9wUGFnZSBleHRlbmRzIFVJUGFnZXtcblxuXG4gICAgcHVibGljIG9uQXdha2UoKTp2b2lke1xuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XG5cbiAgICB9XG5cbiAgICBcbiAgICBwdWJsaWMgb25TaG93KHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcblxuICAgICAgICBcbiAgICB9XG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgfVxuXG59IiwiXG5cbmV4cG9ydCBjbGFzcyBWb0hvbWV7XG5cbiAgICBwdWJsaWMgbmFtZTpzdHJpbmc7XG4gICAgcHVibGljIGhwOm51bWJlcjtcbiAgICBwdWJsaWMgbXA6bnVtYmVyO1xuICAgIHB1YmxpYyBtb25leTpudW1iZXI7XG5cbn0iLCJcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IHN0b3J5VUkgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZGF0YS91aS9zdG9yeVwiO1xyXG5pbXBvcnQgeyBCYXNlU2NlbmUgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZnJhbWV3b3JrL3NjZW5lL0Jhc2VTY2VuZVwiO1xyXG5pbXBvcnQgeyBTIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBMb2dpblNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuXHJcblxyXG4gICAgcHVibGljIG9uRW50ZXIoKSB7XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Db21wbGV0ZSgpIHtcclxuICAgICAgICBcclxuICAgICAgICBTLlVJTWFuYWdlci5vcGVuUGFnZUluU2NlbmUoXHJcbiAgICAgICAgICAgIGxvZ2luVUkuUGFja2FnZU5hbWUsXHJcbiAgICAgICAgICAgIGxvZ2luVUkuVUlMb2dpblBhZ2UsXHJcbiAgICAgICAgICAgIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkxlYXZlKCkge1xyXG4gICAgICAgIFxyXG4gIFxyXG5cclxuICAgIH1cclxuXHJcblxyXG5cclxufSIsImltcG9ydCB7IFVJUGFnZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlQYWdlXCI7XHJcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcclxuaW1wb3J0IHsgRmFpcnlHVUksIFVuaXR5RW5naW5lIH0gZnJvbSBcImNzaGFycFwiO1xyXG5pbXBvcnQgeyBMb2dpbkFQSSB9IGZyb20gXCIuLi8uLi8uLi9hcGkvTG9naW5BUElcIjtcclxuaW1wb3J0IHsgbG9naW5VSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL2xvZ2luXCI7XHJcbmltcG9ydCB7IFZvU2VydmVyLCBWb1NlcnZlckl0ZW0gfSBmcm9tIFwiLi4vdm8vVm9TZXJ2ZXJcIjtcclxuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSBcIi4uLy4uLy4uL2V2ZW50L1VJTWVzc2FnZVwiO1xyXG5pbXBvcnQgeyBTY2VuZURlZiB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvU2NlbmVEZWZcIjtcclxuaW1wb3J0IHsgc3RvcnlVSSB9IGZyb20gXCIuLi8uLi8uLi8uLi9kYXRhL3VpL3N0b3J5XCI7XHJcbmltcG9ydCB7IGNvbW1vblVJIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2RhdGEvdWkvY29tbW9uXCI7XHJcbmltcG9ydCB7IFMgfSBmcm9tIFwiLi4vLi4vLi4vLi4vZ2xvYmFsL0dhbWVDb25maWdcIjtcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9sb2dnZXIvTG9nZ2VyXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBVSUxvZ2luUGFnZSBleHRlbmRzIFVJUGFnZXtcclxuXHJcbiAgICBAYmluZGVyKFwiYWNjb3VudFwiKVxyXG4gICAgcHVibGljIG1fYWNjb3VudDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG4gICAgQGJpbmRlcihcInBhc3N3b3JkXCIpXHJcbiAgICBwdWJsaWMgbV9wYXNzd29yZDpGYWlyeUdVSS5HVGV4dEZpZWxkO1xyXG5cclxuICAgIEBiaW5kZXIoXCJzZWxzZXJ2ZXJCdG5cIilcclxuICAgIHB1YmxpYyBtX3NlbHNlcnZlckJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJsb2dpbkJ0blwiKVxyXG4gICAgcHVibGljIG1fbG9naW5CdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuXHJcbiAgICBAYmluZGVyKFwic3RvcnlCdG5cIilcclxuICAgIHB1YmxpYyBtX3N0b3J5QnRuOkZhaXJ5R1VJLkdCdXR0b247XHJcblxyXG4gICAgQGJpbmRlcihcIm5ld0d1aWRlQnRuXCIpXHJcbiAgICBwdWJsaWMgbV9uZXdHdWlkZUJ0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG5cclxuICAgIEBiaW5kZXIoXCJob2xkXCIpXHJcbiAgICBwdWJsaWMgbV9ob2xkZXI6RmFpcnlHVUkuR0dyYXBoO1xyXG5cclxuICAgIHByaXZhdGUgZ2F0ZUlkOmFueTtcclxuICAgIHByaXZhdGUgZ2F0ZUtleTpudW1iZXJ8TG9uZztcclxuICAgIHByaXZhdGUgX2VmZmVjdEdvOmFueSA9IG51bGw7XHJcblxyXG4gICAgcHVibGljIGFzeW5jIG9uQXdha2UoKXtcclxuICAgICAgICBzdXBlci5vbkF3YWtlKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5tX2xvZ2luQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25Mb2dpbkNsaWNrKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMubV9zdG9yeUJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICBTLlVJTWFuYWdlci5vcGVuV2luZG93KFxyXG4gICAgICAgICAgICAgICAgc3RvcnlVSS5QYWNrYWdlTmFtZSwgXHJcbiAgICAgICAgICAgICAgICBzdG9yeVVJLlVJU3RvcnlXaW4sXHJcbiAgICAgICAgICAgICAgICBudWxsKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX25ld0d1aWRlQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgICAgICBjb21tb25VSS5QYWNrYWdlTmFtZSxcclxuICAgICAgICAgICAgICAgIGNvbW1vblVJLlVJVUlHdWlkZVdpbixcclxuICAgICAgICAgICAgICAgIG51bGxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5tX3NlbHNlcnZlckJ0bi5vbkNsaWNrLkFkZCgoKT0+e1xyXG4gICAgICAgICAgICB0aGlzLm9wZW5TZWxTZXJ2ZXJXaW4oKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbGV0IGNvbm5lY3RlZCA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuY29ubmVjdFJlYWxtU2VydmVyKCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gdGhpcy5tX2xvZ2luQnRuLmVuYWJsZWQgPSBjb25uZWN0ZWQ7XHJcbiAgICAgICAgLy8gTG9nZ2VyLmxvZyhcImNvbm5lY3QgcmVhbSBzZXJ2ZXI6IFwiK2Nvbm5lY3RlZClcclxuICAgIH1cclxuICAgIFxyXG5cclxuICAgIHByaXZhdGUgb25TZWxlY3RTZXJ2ZXIoc2VydmVySXRlbTpWb1NlcnZlckl0ZW0pe1xyXG5cclxuICAgICAgICBMb2dnZXIubG9nKFwiIHNlcnZlciBzZWxlY3RlZDogXCIrc2VydmVySXRlbS5zZXJ2ZXJOYW1lKVxyXG4gICAgICAgIHRoaXMubV9zZWxzZXJ2ZXJCdG4udGV4dCA9IHNlcnZlckl0ZW0uc2VydmVyTmFtZTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHVibGljIGFzeW5jIG9uU2hvdyh2bzphbnkpe1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcblxyXG4gICAgICAgIC8v5Yqg6L2954m55pWIXHJcbiAgICAgICAgdGhpcy5fZWZmZWN0R28gPSBhd2FpdCBTLlJlc01hbmFnZXIubG9hZFByZWZhYihcIkVmZmVjdC9QcmVmYWIvVUkvZWZfdWlfcGV0X3JhbmtfeWVsbG93X3Rlc3QucHJlZmFiXCIpXHJcbiAgICAgICAgbGV0IGluc3QgPSBVbml0eUVuZ2luZS5HYW1lT2JqZWN0Lkluc3RhbnRpYXRlKHRoaXMuX2VmZmVjdEdvKSBhcyBVbml0eUVuZ2luZS5HYW1lT2JqZWN0O1xyXG4gICAgICAgIGxldCB3cmFwcGVyID0gbmV3IEZhaXJ5R1VJLkdvV3JhcHBlcihpbnN0KTtcclxuICAgICAgICB0aGlzLm1faG9sZGVyLlNldE5hdGl2ZU9iamVjdCh3cmFwcGVyKTtcclxuXHJcblxyXG4gICAgICAgICAvL+ebkeWQrOmAieacjea2iOaBr1xyXG4gICAgICAgICBTLlVJTWVzc2FnZU1hbmdlci5hZGRMaXN0ZW5lcihcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICB0aGlzLFxyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0U2VydmVyXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgICAgICAvL+WNuOi9vemTgeaViFxyXG4gICAgICAgIFMuUmVzTWFuYWdlci5yZWxlYXNlQWRkcmVzc0dPKHRoaXMuX2VmZmVjdEdvKTtcclxuXHJcbiAgICAgICAgUy5VSU1lc3NhZ2VNYW5nZXIucmVtb3ZlTGlzdGVuZXIoXHJcbiAgICAgICAgICAgIFVJTWVzc2FnZS5NU0dfU0VMRUNUX1NFUlZFUixcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdFNlcnZlclxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBvcGVuU2VsU2VydmVyV2luKCl7XHJcblxyXG4gICAgICAgIC8vIOa1i+ivleaVsOaNrlxyXG4gICAgICAgIGxldCB2b1NlcnZlcjpWb1NlcnZlciA9IG5ldyBWb1NlcnZlcigpO1xyXG4gICAgICAgIGZvcihsZXQgaT0xOyBpPDEwOyBpKyspe1xyXG4gICAgICAgICAgICB2b1NlcnZlci5hcmVhTWFwLnNldChpLFwi5YiG5Yy6XCIraSk7XHJcbiAgICAgICAgICAgIHZvU2VydmVyLnNlcnZlck1hcC5zZXQoaSwgbmV3IEFycmF5PFZvU2VydmVySXRlbT4oKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IobGV0IGo9MTsgajwyMDsgaisrKXtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgdm9TZXJ2ZXJJdGVtOlZvU2VydmVySXRlbSA9IG5ldyBWb1NlcnZlckl0ZW0oKTtcclxuICAgICAgICAgICAgICAgIHZvU2VydmVySXRlbS5hcmVhSWQgPSBpO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLnNlcnZlcklkID0gajtcclxuXHJcbiAgICAgICAgICAgICAgICB2b1NlcnZlckl0ZW0uc2VydmVyTmFtZSA9IFwi5rWL6K+V5pyN5Yqh5ZmoXCIraStcIjpcIitqO1xyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXJJdGVtLnNlcnZlclN0YXR1cyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSozKzEpO1xyXG5cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdm9TZXJ2ZXIuc2VydmVyTWFwLmdldChpKS5wdXNoKHZvU2VydmVySXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIFMuVUlNYW5hZ2VyLm9wZW5XaW5kb3coXHJcbiAgICAgICAgICAgIGxvZ2luVUkuUGFja2FnZU5hbWUsIFxyXG4gICAgICAgICAgICBsb2dpblVJLlVJU2VsU2VydmVyV2luLFxyXG4gICAgICAgICAgICB2b1NlcnZlcik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhc3luYyBvbkxvZ2luQ2xpY2soKXtcclxuXHJcbiAgICAgICAgbGV0IGFjY291bnQgPSB0aGlzLm1fYWNjb3VudC50ZXh0O1xyXG4gICAgICAgIGxldCBwYXNzd29yZCA9IHRoaXMubV9wYXNzd29yZC50ZXh0O1xyXG5cclxuICAgICAgICBMb2dnZXIubG9nKGBhY2NvdW50OiR7YWNjb3VudH0gLSBwYXNzd29yZDogJHtwYXNzd29yZH1gKTtcclxuXHJcbiAgICAgICAgUy5TY2VuZU1hbmFnZXIubG9hZFNjZW5lKFNjZW5lRGVmLkhvbWVTY2VuZSk7XHJcblxyXG5cclxuICAgICAgICAvLyBpZihhY2NvdW50ICE9IFwiXCIgJiYgcGFzc3dvcmQgIT0gXCJcIil7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIC8vICAgICBsZXQgbXNnID0gYXdhaXQgTG9naW5BUEkubG9naW5SZWFsbVNlcnZlcihhY2NvdW50LCBwYXNzd29yZClcclxuICAgICAgICAvLyAgICAgdGhpcy5nYXRlSWQgPSBtc2cuR2F0ZUlkO1xyXG4gICAgICAgIC8vICAgICB0aGlzLmdhdGVLZXkgPSBtc2cuS2V5O1xyXG4gICAgICAgIC8vICAgICBMb2dnZXIubG9nKFwibG9naW4gcmVhbSBzdWNjLCBnYXRlIGFkZHI6XCIrbXNnLkFkZHJlc3MgKyBcIixrZXk6XCIrbXNnLktleSk7XHJcblxyXG4gICAgICAgIC8vICAgICBTLlNlc3Npb25NYW5hZ2VyLmRpc2Nvbm5lY3RSZWFsbVNlcnZlcigpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAvLyAgICAgLy/nmbvlvZXnvZHlhbPmnI1cclxuICAgICAgICAvLyAgICAgbGV0IGNvbm5lY3RlZCA9IGF3YWl0IFMuU2Vzc2lvbk1hbmFnZXIuY29ubmVjdEdhdGVTZXJ2ZXIobXNnLkFkZHJlc3MpO1xyXG4gICAgICAgIC8vICAgICBpZihjb25uZWN0ZWQpe1xyXG4gICAgICAgIC8vICAgICAgICAgTG9nZ2VyLmxvZyhcImNvbm5lY3QgZ2F0ZSBzdWNjXCIpXHJcblxyXG4gICAgICAgIC8vICAgICAgICAgbGV0IG1zZyA9IGF3YWl0IExvZ2luQVBJLmxvZ2luR2F0ZVNlcnZlciggdGhpcy5nYXRlSWQsIHRoaXMuZ2F0ZUtleSlcclxuXHJcbiAgICAgICAgLy8gICAgICAgICBsZXQgcGxheWVySUQgPSBtc2cuUGxheWVySWQ7XHJcbiAgICAgICAgLy8gICAgICAgICBMb2dnZXIubG9nKFwibG9naW4gZ2F0ZSByZXNwb25zZS4uXCIgK3BsYXllcklEKTtcclxuXHJcbiAgICAgICAgLy8gICAgICAgICBTLlNjZW5lTWFuYWdlci5sb2FkU2NlbmUoU2NlbmVEZWYuSG9tZVNjZW5lKTtcclxuXHJcbiAgICAgICAgLy8gICAgIH1lbHNle1xyXG4gICAgICAgIC8vICAgICBMb2dnZXIubG9nKFwiY29ubmVjdCBnYXRlIGVyciBcIilcclxuICAgICAgICAvLyAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gIH1cclxuXHJcbiAgICB9XHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcclxuaW1wb3J0IHsgYmluZGVyIH0gZnJvbSBcIi4uLy4uLy4uLy4uL2ZyYW1ld29yay9jb21tb24vTmljZURlY29yYXRvclwiO1xyXG5pbXBvcnQgeyBVSVdpbmRvdyB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvdWkvVUlXaW5kb3dcIjtcclxuaW1wb3J0IHsgUyB9IGZyb20gXCIuLi8uLi8uLi8uLi9nbG9iYWwvR2FtZUNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tIFwiLi4vLi4vLi4vZXZlbnQvVUlNZXNzYWdlXCI7XHJcbmltcG9ydCB7IFZvU2VydmVyLCBWb1NlcnZlckl0ZW0gfSBmcm9tIFwiLi4vdm8vVm9TZXJ2ZXJcIjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFVJU2VsU2VydmVyV2luIGV4dGVuZHMgVUlXaW5kb3d7XHJcblxyXG4gICAgQGJpbmRlcihcImFyZWFMaXN0XCIpXHJcbiAgICBwcml2YXRlIGFyZWFMaXN0OkZhaXJ5R1VJLkdMaXN0O1xyXG4gICAgQGJpbmRlcihcInNlcnZlckxpc3RcIilcclxuICAgIHByaXZhdGUgc2VydmVyTGlzdDpGYWlyeUdVSS5HTGlzdDtcclxuICAgIEBiaW5kZXIoXCJiYWNrQnRuXCIpXHJcbiAgICBwcml2YXRlIGJhY2tCdG46RmFpcnlHVUkuR0J1dHRvbjtcclxuICAgIEBiaW5kZXIoXCJva0J0blwiKVxyXG4gICAgcHJpdmF0ZSBva0J0bjpGYWlyeUdVSS5HQnV0dG9uO1xyXG4gICAgQGJpbmRlcihcInRpdGxlXCIpXHJcbiAgICBwcml2YXRlIHRpdGxlOkZhaXJ5R1VJLkdMYWJlbDtcclxuXHJcbiAgICBwcml2YXRlICBjbGlja0FyZWFJbmRleDpudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSAgY2xpY2tTZXJ2ZXJJbmRleDpudW1iZXIgPSAwO1xyXG4gICAgcHJpdmF0ZSB2b1NlcnZlcjpWb1NlcnZlcjtcclxuXHJcbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25Bd2FrZSgpO1xyXG5cclxuICAgICAgICB0aGlzLmJhY2tCdG4ub25DbGljay5BZGQoKCk9PntcclxuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLm9rQnRuLm9uQ2xpY2suQWRkKCgpPT57XHJcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3RTZXJ2ZXIoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5hcmVhTGlzdC5vbkNsaWNrSXRlbS5BZGQoKGV2ZW50OkZhaXJ5R1VJLkV2ZW50Q29udGV4dCk9PntcclxuICAgICAgICAgICAgdGhpcy5jbGlja0FyZWFJbmRleCA9IHRoaXMuYXJlYUxpc3QuR2V0Q2hpbGRJbmRleChldmVudC5kYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuc2VydmVyTGlzdC5udW1JdGVtcyA9IHRoaXMudm9TZXJ2ZXIuc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0LlJlZnJlc2hWaXJ0dWFsTGlzdCgpO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICB0aGlzLnNlcnZlckxpc3Qub25DbGlja0l0ZW0uQWRkKChldmVudDpGYWlyeUdVSS5FdmVudENvbnRleHQpPT57XHJcblxyXG4gICAgICAgICAgICB0aGlzLmNsaWNrU2VydmVySW5kZXggPSB0aGlzLnNlcnZlckxpc3QuR2V0Q2hpbGRJbmRleChldmVudC5kYXRhKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMudGl0bGUudGV4dCA9IFwi5bey6YCJ5oup5pyN5Yqh5Zmo77yaXCIrdGhpcy5jbGlja1NlcnZlckluZGV4O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcml2YXRlIG9uU2VsZWN0U2VydmVyKCl7XHJcblxyXG4gICAgICAgIGxldCBzZWxJdGVtOlZvU2VydmVySXRlbSA9IHRoaXMudm9TZXJ2ZXIuc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpW3RoaXMuY2xpY2tTZXJ2ZXJJbmRleF07XHJcblxyXG4gICAgICAgIFMuVUlNZXNzYWdlTWFuZ2VyLmJyb2FkY2FzdChcclxuICAgICAgICAgICAgVUlNZXNzYWdlLk1TR19TRUxFQ1RfU0VSVkVSLFxyXG4gICAgICAgICAgICBzZWxJdGVtXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwdWJsaWMgb25TaG93KHZvOlZvU2VydmVyKTp2b2lke1xyXG4gICAgICAgIHN1cGVyLm9uU2hvdyh2byk7XHJcbiAgICAgICAgdGhpcy52b1NlcnZlciA9IHZvO1xyXG5cclxuICAgICAgICB0aGlzLmFyZWFMaXN0LlNldFZpcnR1YWwoKTtcclxuICAgICAgICB0aGlzLmFyZWFMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckFyZWFMaXN0SXRlbShpbmRleCwgb2JqKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXJlYUxpc3QubnVtSXRlbXMgPSB2by5hcmVhTWFwLnNpemU7XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIHRoaXMuc2VydmVyTGlzdC5TZXRWaXJ0dWFsKCk7XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lml0ZW1SZW5kZXJlciA9IChpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KT0+e1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4LCBvYmopO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5zZXJ2ZXJMaXN0Lm51bUl0ZW1zID0gdm8uc2VydmVyTWFwLmdldCh0aGlzLmNsaWNrQXJlYUluZGV4KzEpLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlckFyZWFMaXN0SXRlbShpbmRleDpudW1iZXIsIG9iajpGYWlyeUdVSS5HT2JqZWN0KXtcclxuXHJcbiAgICAgICAgbGV0IGFyZWFCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcclxuICAgICAgICBhcmVhQnRuLnRleHQgPSB0aGlzLnZvU2VydmVyLmFyZWFNYXAuZ2V0KGluZGV4KzEpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlbmRlclNlcnZlckxpc3RJdGVtKGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3Qpe1xyXG4gICAgICAgIGxldCBzZXJ2ZXJCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcclxuXHJcbiAgICAgICAgc2VydmVyQnRuLnRleHQgPSB0aGlzLnZvU2VydmVyLnNlcnZlck1hcC5nZXQodGhpcy5jbGlja0FyZWFJbmRleCsxKVtpbmRleF0uc2VydmVyTmFtZTtcclxuICAgICAgICAvL3NlcnZlckJ0bi5pY29uID0gRmFpcnlHVUkuVUlQYWNrYWdlLlxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbkNsb3NlKGFyZzphbnkpOnZvaWR7XHJcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xyXG5cclxuICAgIH1cclxuXHJcblxyXG59IiwiXG5cblxuZXhwb3J0IGNsYXNzIFZvU2VydmVySXRlbXtcblxuICAgIHB1YmxpYyBhcmVhSWQ6bnVtYmVyO1xuICAgIHB1YmxpYyBzZXJ2ZXJJZDpudW1iZXI7XG4gICAgcHVibGljIHNlcnZlck5hbWU6c3RyaW5nO1xuICAgIHB1YmxpYyBzZXJ2ZXJTdGF0dXM6bnVtYmVyO1xufVxuXG5leHBvcnQgIGNsYXNzIFZvU2VydmVye1xuXG4gICAgcHVibGljIHNlcnZlck1hcDogTWFwPG51bWJlciwgQXJyYXk8Vm9TZXJ2ZXJJdGVtPj4gPSBuZXcgTWFwPG51bWJlciwgQXJyYXk8Vm9TZXJ2ZXJJdGVtPj4oKTtcbiAgICBwdWJsaWMgYXJlYU1hcDpNYXA8bnVtYmVyLHN0cmluZz4gPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xufSIsImltcG9ydCB7IEJhc2VTY2VuZSB9IGZyb20gXCIuLi8uLi8uLi8uLi9mcmFtZXdvcmsvc2NlbmUvQmFzZVNjZW5lXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIFB2ZVNjZW5lIGV4dGVuZHMgQmFzZVNjZW5le1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25FbnRlcigpIHtcclxuICAgICAgICBcclxuICAgIH1cclxuICAgIHB1YmxpYyBvbkNvbXBsZXRlKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG4gICAgcHVibGljIG9uTGVhdmUoKSB7XHJcbiAgICAgICAgXHJcbiAgICB9XHJcblxyXG5cclxuXHJcbn0iLCJpbXBvcnQgeyBGYWlyeUdVSSB9IGZyb20gXCJjc2hhcnBcIjtcbmltcG9ydCB7IENob2ljZSB9IGZyb20gXCJpbmtqcy9lbmdpbmUvQ2hvaWNlXCI7XG5pbXBvcnQgeyBzdG9yeVVJIH0gZnJvbSBcIi4uLy4uLy4uL2RhdGEvdWkvc3RvcnlcIjtcbmltcG9ydCB7IGJpbmRlciB9IGZyb20gXCIuLi8uLi8uLi9mcmFtZXdvcmsvY29tbW9uL05pY2VEZWNvcmF0b3JcIjtcbmltcG9ydCB7IFN0b3J5TWVzc2FnZU1hbmFnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2luay9TdG9yeU1lc3NhZ2VNYW5hZ2VyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiLi4vLi4vLi4vZnJhbWV3b3JrL2xvZ2dlci9Mb2dnZXJcIjtcbmltcG9ydCB7IFVJV2luZG93IH0gZnJvbSBcIi4uLy4uLy4uL2ZyYW1ld29yay91aS9VSVdpbmRvd1wiO1xuaW1wb3J0IHsgU30gZnJvbSBcIi4uLy4uLy4uL2dsb2JhbC9HYW1lQ29uZmlnXCI7XG5cbmV4cG9ydCBjbGFzcyBVSVN0b3J5V2luIGV4dGVuZHMgVUlXaW5kb3d7XG5cbiAgICBAYmluZGVyKFwic3BlYWtlclR4dFwiKVxuICAgIHByaXZhdGUgbV9zcGVha2VyVHh0OkZhaXJ5R1VJLkdSaWNoVGV4dEZpZWxkO1xuICAgIEBiaW5kZXIoXCJidG5MaXN0XCIpXG4gICAgcHJpdmF0ZSBtX2J0bkxpc3Q6RmFpcnlHVUkuR0xpc3Q7XG5cbiAgICBwcml2YXRlIHNob3VsZENvbnRpbmVTdG9yeTpib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBvcHRpb25zTWFwOk1hcDxudW1iZXIsc3RyaW5nPiA9IG5ldyBNYXA8bnVtYmVyLHN0cmluZz4oKTtcbiAgICBwcml2YXRlIGFsbENob2ljZXM6Q2hvaWNlW107XG5cbiAgICBwdWJsaWMgb25Bd2FrZSgpOnZvaWR7XG4gICAgICAgIHN1cGVyLm9uQXdha2UoKTtcblxuICAgICAgICB0aGlzLm1fYnRuTGlzdC5pdGVtUmVuZGVyZXIgPSAoaW5kZXg6bnVtYmVyLCBvYmo6RmFpcnlHVUkuR09iamVjdCk9PntcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQnRuTGlzdChpbmRleCwgb2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubV9idG5MaXN0Lm9uQ2xpY2tJdGVtLkFkZCgoZXZlbnQ6RmFpcnlHVUkuRXZlbnRDb250ZXh0KT0+e1xuICAgICAgICAgICAgIGxldCBjbGlja0lkOm51bWJlciA9IHRoaXMubV9idG5MaXN0LkdldENoaWxkSW5kZXgoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBpZih0aGlzLnNob3VsZENvbnRpbmVTdG9yeSl7XG4gICAgICAgICAgICAgICAgUy5TdG9yeU1hbmFnZXIuYWR2YW5jZVN0b3J5KCk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYXAuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICBTLlN0b3J5TWFuYWdlci5zZWxlY3RDaG9pY2UodGhpcy5hbGxDaG9pY2VzW2NsaWNrSWRdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb25TaG93KHZvOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25TaG93KHZvKTtcblxuICAgICAgICBTLlN0b3J5TWVzc2FnZU1hbmFnZXIuYWRkTGlzdGVuZXIoXG4gICAgICAgICAgICBTdG9yeU1lc3NhZ2VNYW5hZ2VyLk9OQ09OVEVOVFJFQURZLFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHRoaXMuT25Db250ZW50UmVhZHlcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTkNIT0lDRVNQUkVTRU5URUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PbkNob2ljZXNQcmVzZW50ZWRcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgdGhpcy5PblN0b3J5RmluaXNoZWRcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMub3B0aW9uc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IGZhbHNlO1xuXG4gICAgICAgIFMuU3RvcnlNYW5hZ2VyLmJlZ2luU3RvcnkoXCJzdG9yeTJcIik7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIE9uQ29udGVudFJlYWR5KFxuICAgICAgICBzcGVha2VyQ29udGVudDpzdHJpbmcsXG4gICAgICAgIHNwZWFrZXJJZDpzdHJpbmcsXG4gICAgICAgIGN1cnJlbnRUYWdzOnN0cmluZ1tdLFxuICAgICAgICBjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSlcbiAgICB7XG4gICAgICAgIHRoaXMubV9zcGVha2VyVHh0LnRleHQgPSBzcGVha2VyQ29udGVudDtcblxuICAgICAgICBpZihTLlN0b3J5TWFuYWdlci5jYW5Db250aW51ZSl7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbnRpbmVTdG9yeSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGN1cnJlbnRDaG9pY2VzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgIHRoaXMuYWxsQ2hvaWNlcyA9IGN1cnJlbnRDaG9pY2VzO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGV0IGxlbiA9IGN1cnJlbnRDaG9pY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvcihsZXQgaT0wOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hcC5zZXQoaSwgY3VycmVudENob2ljZXNbaV0udGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubV9idG5MaXN0Lm51bUl0ZW1zID0gbGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW5kZXJCdG5MaXN0KGluZGV4Om51bWJlciwgb2JqOkZhaXJ5R1VJLkdPYmplY3Qpe1xuICAgICAgICBsZXQgY29udGludWVCdG46RmFpcnlHVUkuR0J1dHRvbiA9IG9iai5hc0J1dHRvbjtcbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9uc01hcC5zaXplPjApe1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IHRoaXMub3B0aW9uc01hcC5nZXQoaW5kZXgpO1xuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29udGludWVCdG4udGV4dCA9IFwi54K55Ye757un57utXCI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIE9uQ2hvaWNlc1ByZXNlbnRlZChjdXJyZW50Q2hvaWNlczpDaG9pY2VbXSl7XG4gICAgICBcbiAgICAgICAgdGhpcy5zaG91bGRDb250aW5lU3RvcnkgPSBmYWxzZTtcbiAgICAgICAgTG9nZ2VyLmxvZyhcIi4uLi5PbkNob2ljZXNQcmVzZW50ZWQuLi4uLi5cIilcbiAgICB9XG5cbiAgICBwcml2YXRlIE9uU3RvcnlGaW5pc2hlZCgpOnZvaWR7XG5cbiAgICAgICAgTG9nZ2VyLmxvZyhcIlN0b3J5IEZpbmlzaGVkXCIpXG5cbiAgICAgICAgUy5VSU1hbmFnZXIuY2xvc2VXaW5kb3coc3RvcnlVSS5VSVN0b3J5V2luLG51bGwpO1xuICAgIH1cblxuXG4gICAgcHVibGljIG9uQ2xvc2UoYXJnOmFueSk6dm9pZHtcbiAgICAgICAgc3VwZXIub25DbG9zZShhcmcpO1xuXG4gICAgICAgIFMuU3RvcnlNZXNzYWdlTWFuYWdlci5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DT05URU5UUkVBRFksXG4gICAgICAgICAgICB0aGlzLk9uQ29udGVudFJlYWR5XG4gICAgICAgICk7XG4gICAgICAgIFMuU3RvcnlNZXNzYWdlTWFuYWdlci5yZW1vdmVMaXN0ZW5lcihcbiAgICAgICAgICAgIFN0b3J5TWVzc2FnZU1hbmFnZXIuT05DSE9JQ0VTUFJFU0VOVEVELFxuICAgICAgICAgICAgdGhpcy5PbkNob2ljZXNQcmVzZW50ZWRcbiAgICAgICAgKTtcbiAgICAgICAgUy5TdG9yeU1lc3NhZ2VNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKFxuICAgICAgICAgICAgU3RvcnlNZXNzYWdlTWFuYWdlci5PTlNUT1JZRklOSVNIRUQsXG4gICAgICAgICAgICB0aGlzLk9uU3RvcnlGaW5pc2hlZFxuICAgICAgICApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBHYW1lT2JqZWN0UG9vbCB9IGZyb20gXCIuLi9mcmFtZXdvcmsvY29tbW9uL0dhbWVPYmplY3RQb29sXCI7XHJcbmltcG9ydCB7IFJlc01hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL2NvbW1vbi9SZXNNYW5hZ2VyXCI7XHJcbmltcG9ydCB7IFN0b3J5TWFuYWdlciB9IGZyb20gXCIuLi9mcmFtZXdvcmsvaW5rL1N0b3J5TWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTdG9yeU1lc3NhZ2VNYW5hZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9pbmsvU3RvcnlNZXNzYWdlTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBHYW1lU2Vzc2lvbiB9IGZyb20gXCIuLi9mcmFtZXdvcmsvbmV0L0dhbWVTZXNzaW9uXCI7XHJcbmltcG9ydCB7IEh0dHBNYW5hZ2VyIH0gZnJvbSBcIi4uL2ZyYW1ld29yay9uZXQvSHR0cE1hbmFnZXJcIjtcclxuaW1wb3J0IHsgU2Vzc2lvbk1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL25ldC9TZXNzaW9uTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBTY2VuZU1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL3NjZW5lL1NjZW5lTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBVSU1hbmFnZXIgfSBmcm9tIFwiLi4vZnJhbWV3b3JrL3VpL1VJTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBVSU1lc3NhZ2VNYW5nZXIgfSBmcm9tIFwiLi4vZ2FtZS9ldmVudC9VSU1lc3NhZ2VNYW5hZ2VyXCI7XHJcblxyXG5leHBvcnQgIGNsYXNzIEdhbWVDb25maWd7XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBkZWJ1Zzpib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVySVA6c3RyaW5nID0gXCIxMjcuMC4wLjFcIjsgXHJcbiAgICBwdWJsaWMgc3RhdGljIHJlYWxtU2VydmVyUG9ydDpudW1iZXIgPSA5MDAxO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN7XHJcbiAgICBwdWJsaWMgc3RhdGljIFVJTWFuYWdlciA9IFVJTWFuYWdlci5JbnN0YW5jZShVSU1hbmFnZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBVSU1lc3NhZ2VNYW5nZXIgPSBVSU1lc3NhZ2VNYW5nZXIuSW5zdGFuY2UoVUlNZXNzYWdlTWFuZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU2NlbmVNYW5hZ2VyID0gU2NlbmVNYW5hZ2VyLkluc3RhbmNlKFNjZW5lTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIEdhbWVPYmplY3RQb29sID0gR2FtZU9iamVjdFBvb2wuSW5zdGFuY2UoR2FtZU9iamVjdFBvb2wpO1xyXG4gICAgcHVibGljIHN0YXRpYyBSZXNNYW5hZ2VyID0gUmVzTWFuYWdlci5JbnN0YW5jZShSZXNNYW5hZ2VyKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU3RvcnlNYW5hZ2VyID0gU3RvcnlNYW5hZ2VyLkluc3RhbmNlKFN0b3J5TWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIFNlc3Npb25NYW5hZ2VyID0gU2Vzc2lvbk1hbmFnZXIuSW5zdGFuY2UoU2Vzc2lvbk1hbmFnZXIpO1xyXG4gICAgcHVibGljIHN0YXRpYyBHYW1lU2Vzc2lvbiA9IEdhbWVTZXNzaW9uLkluc3RhbmNlKEdhbWVTZXNzaW9uKTtcclxuICAgIHB1YmxpYyBzdGF0aWMgU3RvcnlNZXNzYWdlTWFuYWdlciA9IFN0b3J5TWVzc2FnZU1hbmFnZXIuSW5zdGFuY2UoU3RvcnlNZXNzYWdlTWFuYWdlcik7XHJcbiAgICBwdWJsaWMgc3RhdGljIEh0dHBNYW5hZ2VyID0gSHR0cE1hbmFnZXIuSW5zdGFuY2UoSHR0cE1hbmFnZXIpO1xyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImNzaGFycFwiKTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJwdWVydHNcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==